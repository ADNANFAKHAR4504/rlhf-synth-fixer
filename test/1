import { EC2Client, DescribeVpcsCommand, DescribeSubnetsCommand, DescribeInstancesCommand } from "@aws-sdk/client-ec2";
import { IAMClient, GetRoleCommand } from "@aws-sdk/client-iam";
import fs from "fs";
import path from "path";

const ec2 = new EC2Client({});
const iam = new IAMClient({});

const outputPath = path.resolve(__dirname, "../cfn-outputs/all-outputs.json");
const outputs = JSON.parse(fs.readFileSync(outputPath, "utf-8"));

type Env = "dev" | "staging" | "production";

describe("Terraform Integration Tests", () => {
  const environments: Env[] = ["dev", "staging", "production"];

  environments.forEach((env) => {
    describe(`Environment: ${env}`, () => {
      const vpcId: string = outputs.vpc_id[env];
      const publicSubnetIds: string[] = Object.entries(outputs.public_subnet_ids.value)
        .filter(([key]) => key.startsWith(env))
        .map(([, id]) => id as string);
      const privateSubnetIds: string[] = Object.entries(outputs.private_subnet_ids.value)
        .filter(([key]) => key.startsWith(env))
        .map(([, id]) => id as string);
      const instanceIds: string[] = Object.entries(outputs.ec2_instance_ids.value)
        .filter(([key]) => key.startsWith(env))
        .map(([, id]) => id as string);
      const iamRoleName: string = outputs.iam_role_name[env];
      const igwId: string = outputs.internet_gateway_id[env];
      const natGwId: string = outputs.nat_gateway_id[env];
      const expectedCidr: string = outputs.vpc_cidr[env];

      it("VPC exists and is available", async () => {
        expect(vpcId).toMatch(/^vpc-[a-f0-9]+$/);
        const resp = await ec2.send(new DescribeVpcsCommand({ VpcIds: [vpcId] }));
        expect(resp.Vpcs && resp.Vpcs.length).toBeGreaterThan(0);
        expect(resp.Vpcs![0].State).toBe("available");
      });

      it("Public subnets exist", async () => {
        publicSubnetIds.forEach((s) => expect(s).toMatch(/^subnet-[a-f0-9]+$/));
        const resp = await ec2.send(new DescribeSubnetsCommand({ SubnetIds: publicSubnetIds }));
        expect(resp.Subnets!.length).toBe(publicSubnetIds.length);
      });

      it("Private subnets exist", async () => {
        privateSubnetIds.forEach((s) => expect(s).toMatch(/^subnet-[a-f0-9]+$/));
        const resp = await ec2.send(new DescribeSubnetsCommand({ SubnetIds: privateSubnetIds }));
        expect(resp.Subnets!.length).toBe(privateSubnetIds.length);
      });

      it("EC2 instances exist and match IPs", async () => {
        instanceIds.forEach((i) => expect(i).toMatch(/^i-[a-f0-9]+$/));
        const resp = await ec2.send(new DescribeInstancesCommand({ InstanceIds: instanceIds }));
        expect(resp.Reservations && resp.Reservations.length).toBeGreaterThan(0);
        const allInstances = resp.Reservations!.flatMap((r) => r.Instances!);
        expect(allInstances.length).toBe(instanceIds.length);
      });

      it("Security group exists", async () => {
        const sgId: string = outputs.security_group_id[env];
        expect(sgId).toMatch(/^sg-[a-f0-9]+$/);
      });

      it("IAM role exists", async () => {
        const resp = await iam.send(new GetRoleCommand({ RoleName: iamRoleName }));
        expect(resp.Role).toBeDefined();
      });

      it("Internet Gateway and NAT Gateway IDs exist", () => {
        expect(igwId).toMatch(/^igw-[a-f0-9]+$/);
        expect(natGwId).toMatch(/^nat-[a-f0-9]+$/);
      });

      it("VPC CIDR matches expected", async () => {
        const resp = await ec2.send(new DescribeVpcsCommand({ VpcIds: [vpcId] }));
        expect(resp.Vpcs![0].CidrBlock).toBe(expectedCidr);
      });
    });
  });
});
