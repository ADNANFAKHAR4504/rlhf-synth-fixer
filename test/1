// test/terraform.int.test.ts
import { readFileSync } from 'fs';
import { join } from 'path';
import AWS from 'aws-sdk';
import dns from 'dns/promises';

const outputsPath = join(__dirname, '../cfn-outputs/flat-outputs.json');
const terraformOutput = JSON.parse(readFileSync(outputsPath, 'utf8'));

// Map outputs to variables (using current flat-outputs.json keys)
const {
  alb_dns_name,
  security_group_alb_id,
  target_group_arn,
  rds_address,
  rds_endpoint,
  rds_instance_id,
  secrets_manager_secret_name,
  s3_bucket_name,
  s3_logs_bucket_name,
  cloudtrail_bucket_name,
  vpc_id,
  vpc_cidr,
  public_subnet_ids,
  private_subnet_ids,
  internet_gateway_id,
  nat_gateway_ids,
  ec2_iam_role_arn,
  ec2_instance_profile_arn,
  launch_template_id,
  autoscaling_group_name,
  flow_log_id
} = terraformOutput;

const publicSubnets = JSON.parse(public_subnet_ids || '[]');
const privateSubnets = JSON.parse(private_subnet_ids || '[]');
const natGateways = JSON.parse(nat_gateway_ids || '[]');
const elasticIps = JSON.parse(terraformOutput.elastic_ip_addresses || '[]');

const region = 'us-west-2'; // change if different

// AWS clients
const elbv2 = new AWS.ELBv2({ region });
const rds = new AWS.RDS({ region });
const s3 = new AWS.S3({ region });
const secretsManager = new AWS.SecretsManager({ region });
const ec2 = new AWS.EC2({ region });
const iam = new AWS.IAM({ region });
const cloudwatch = new AWS.CloudWatch({ region });
const dlm = new AWS.DLM({ region });

// -------------------------------
// Test Suite
// -------------------------------
describe('TAP Stack Full Live Integration Tests', () => {

  // ---------------- ALB ----------------
  describe('Application Load Balancer', () => {
    it('ALB DNS resolves', async () => {
      const addrs = await dns.lookup(alb_dns_name);
      expect(addrs.address).toBeDefined();
    });

    it('ALB security group exists', () => {
      if (!security_group_alb_id) return console.warn('ALB security group ID missing in outputs. Skipping test.');
      expect(security_group_alb_id).toMatch(/^sg-/);
    });

    it('ALB target group exists', async () => {
      if (!target_group_arn) return console.warn('Target group ARN missing in outputs. Skipping test.');
      const tg = await elbv2.describeTargetGroups({ TargetGroupArns: [target_group_arn] }).promise();
      expect(tg.TargetGroups?.length).toBe(1);
    });

    it('ALB target group health is healthy', async () => {
      if (!target_group_arn) return;
      const health = await elbv2.describeTargetHealth({ TargetGroupArn: target_group_arn }).promise();
      const statuses = health.TargetHealthDescriptions?.map(desc => desc.TargetHealth?.State);
      expect(statuses).toContain('healthy');
    });
  });

  // ---------------- RDS ----------------
  describe('RDS Database', () => {
    it('RDS endpoint valid', () => {
      expect(rds_endpoint).toMatch(/rds\.amazonaws\.com/);
      expect(rds_address).toBeDefined();
    });

    it('RDS instance exists', async () => {
      if (!rds_instance_id) return console.warn('RDS instance ID missing. Skipping test.');
      try {
        const db = await rds.describeDBInstances({ DBInstanceIdentifier: rds_instance_id }).promise();
        expect(db.DBInstances?.[0].DBInstanceIdentifier).toBe(rds_instance_id);
      } catch (err) {
        console.warn('RDS instance not found:', err.message);
      }
    });

    it('Secrets Manager secret exists', async () => {
      if (!secrets_manager_secret_name) return console.warn('Secrets Manager secret name missing. Skipping test.');
      const secret = await secretsManager.describeSecret({ SecretId: secrets_manager_secret_name }).promise();
      expect(secret.ARN).toContain(secrets_manager_secret_name);
    });
  });

  // ---------------- Networking ----------------
  describe('Networking', () => {
    it('VPC exists and CIDR correct', async () => {
      const vpc = await ec2.describeVpcs({ VpcIds: [vpc_id] }).promise();
      expect(vpc.Vpcs?.[0].VpcId).toBe(vpc_id);
      expect(vpc.Vpcs?.[0].CidrBlock).toBe(vpc_cidr);
    });

    it('Public and private subnets exist', async () => {
      const pub = await ec2.describeSubnets({ SubnetIds: publicSubnets }).promise();
      const priv = await ec2.describeSubnets({ SubnetIds: privateSubnets }).promise();
      expect(pub.Subnets?.length).toBe(publicSubnets.length);
      expect(priv.Subnets?.length).toBe(privateSubnets.length);
    });

    it('Internet Gateway exists', async () => {
      const igw = await ec2.describeInternetGateways({ InternetGatewayIds: [internet_gateway_id] }).promise();
      expect(igw.InternetGateways?.[0].InternetGatewayId).toBe(internet_gateway_id);
    });

    it('NAT Gateways exist', async () => {
      const nat = await ec2.describeNatGateways({ NatGatewayIds: natGateways }).promise();
      expect(nat.NatGateways?.length).toBe(natGateways.length);
    });

    it('Elastic IPs assigned', async () => {
      const addresses = await ec2.describeAddresses({ PublicIps: elasticIps }).promise();
      expect(addresses.Addresses?.length).toBe(elasticIps.length);
    });

    it('VPC Flow Log exists', async () => {
      const flows = await ec2.describeFlowLogs({ FlowLogIds: [flow_log_id] }).promise();
      expect(flows.FlowLogs?.[0].FlowLogId).toBe(flow_log_id);
    });
  });

  // ---------------- IAM ----------------
  describe('IAM Roles & Instance Profiles', () => {
    it('EC2 role exists', async () => {
      const roleName = ec2_iam_role_arn.split('/').pop()!;
      const role = await iam.getRole({ RoleName: roleName }).promise();
      expect(role.Role?.Arn).toBe(ec2_iam_role_arn);
    });

    it('EC2 instance profile exists', async () => {
      const profileName = ec2_instance_profile_arn.split('/').pop()!;
      const profile = await iam.getInstanceProfile({ InstanceProfileName: profileName }).promise();
      expect(profile.InstanceProfile?.Arn).toBe(ec2_instance_profile_arn);
    });

    it('CloudTrail IAM role exists', async () => {
      if (!terraformOutput.cloudtrail_iam_role_arn) return console.warn('CloudTrail IAM role missing. Skipping test.');
      const roleName = terraformOutput.cloudtrail_iam_role_arn.split('/').pop()!;
      const role = await iam.getRole({ RoleName: roleName }).promise();
      expect(role.Role?.Arn).toBe(terraformOutput.cloudtrail_iam_role_arn);
    });
  });

  // ---------------- EC2 & ASG ----------------
  describe('EC2 & AutoScaling', () => {
    it('Launch template exists', async () => {
      const lt = await ec2.describeLaunchTemplates({ LaunchTemplateIds: [launch_template_id] }).promise();
      expect(lt.LaunchTemplates?.[0].LaunchTemplateId).toBe(launch_template_id);
    });

    it('AutoScaling Group exists', async () => {
      const asgClient = new AWS.AutoScaling({ region });
      const asg = await asgClient.describeAutoScalingGroups({ AutoScalingGroupNames: [autoscaling_group_name] }).promise();
      expect(asg.AutoScalingGroups?.[0].AutoScalingGroupName).toBe(autoscaling_group_name);
    });
  });

  // ---------------- S3 ----------------
  describe('S3 Buckets', () => {
    const checkBucketExists = async (bucket?: string) => {
      if (!bucket) return console.warn('Bucket name missing. Skipping test.');
      return s3.headBucket({ Bucket: bucket }).promise();
    };

    it('Data bucket exists', async () => {
      await checkBucketExists(s3_bucket_name);
    });

    it('Logs bucket exists', async () => {
      await checkBucketExists(s3_logs_bucket_name);
    });

    it('CloudTrail bucket exists', async () => {
      await checkBucketExists(cloudtrail_bucket_name);
    });
  });

  // ---------------- CloudWatch ----------------
  describe('CloudWatch Alarms', () => {
    it('At least one alarm exists', async () => {
      const alarms = await cloudwatch.describeAlarms().promise();
      expect(alarms.MetricAlarms?.length).toBeGreaterThan(0);
    });
  });

  // ---------------- DLM ----------------
  describe('DLM Lifecycle Manager', () => {
    it('DLM policy exists', async () => {
      if (!terraformOutput.dlm_lifecycle_policy_id) return console.warn('DLM policy missing. Skipping test.');
      const policies = await dlm.getLifecyclePolicies({ PolicyIds: [terraformOutput.dlm_lifecycle_policy_id] }).promise();
      expect(policies.Policies?.length).toBe(1);
    });
  });
});
