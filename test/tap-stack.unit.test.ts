import fs from 'fs';import path from 'path';const environmentSuffix = process.env.ENVIRONMENT_SUFFIX || 'dev';describe('TapStack CloudFormation Template', () => {  let template: any;  beforeAll(() => {    // Test the JSON template    const templatePath = path.join(__dirname, '../lib/TapStack.json');    const templateContent = fs.readFileSync(templatePath, 'utf8');    template = JSON.parse(templateContent);  });  describe('Template Structure', () => {    test('should have valid CloudFormation format version', () => {      expect(template.AWSTemplateFormatVersion).toBe('2010-09-09');    });    test('should have a description', () => {      expect(template.Description).toBeDefined();      expect(template.Description).toBe(        'Production-ready web application infrastructure with ALB, Auto Scaling, and comprehensive networking in us-east-1'      );    });    test('should have metadata section', () => {      expect(template.Metadata).toBeDefined();      expect(template.Metadata['AWS::CloudFormation::Interface']).toBeDefined();    });    test('should have correct region metadata', () => {      const metadata = template.Metadata['AWS::CloudFormation::Designer'];      expect(metadata.ApplicationMetadata.Region).toBe('us-east-1');    });  });  describe('Parameters', () => {    test('should have all required parameters', () => {      expect(template.Parameters.LatestAmiId).toBeDefined();      expect(template.Parameters.ApplicationS3Bucket).toBeDefined();      expect(template.Parameters.KeyName).toBeDefined();      expect(template.Parameters.EnvironmentSuffix).toBeDefined();    });    test('LatestAmiId parameter should use SSM parameter', () => {      const param = template.Parameters.LatestAmiId;      expect(param.Type).toBe('AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>');      expect(param.Default).toBe('/aws/service/ami-amazon-linux-latest/amzn2-ami-hvm-x86_64-gp2');    });    test('KeyName should have correct default', () => {      expect(template.Parameters.KeyName.Default).toBe('iac-rlhf-aws-trainer-instance');    });    test('EnvironmentSuffix should have validation pattern', () => {      const param = template.Parameters.EnvironmentSuffix;      expect(param.AllowedPattern).toBe('^[a-zA-Z0-9]+$');    });  });  describe('VPC and Networking', () => {    test('should have VPC with correct CIDR', () => {      const vpc = template.Resources.VPC;      expect(vpc).toBeDefined();      expect(vpc.Type).toBe('AWS::EC2::VPC');      expect(vpc.Properties.CidrBlock).toBe('10.0.0.0/16');      expect(vpc.Properties.EnableDnsHostnames).toBe(true);      expect(vpc.Properties.EnableDnsSupport).toBe(true);    });    test('should have Internet Gateway', () => {      const igw = template.Resources.InternetGateway;      expect(igw).toBeDefined();      expect(igw.Type).toBe('AWS::EC2::InternetGateway');    });    test('should have three public subnets in different AZs', () => {      const subnet1 = template.Resources.PublicSubnet1;      const subnet2 = template.Resources.PublicSubnet2;      const subnet3 = template.Resources.PublicSubnet3;      expect(subnet1.Properties.AvailabilityZone).toBe('us-east-1a');      expect(subnet2.Properties.AvailabilityZone).toBe('us-east-1b');      expect(subnet3.Properties.AvailabilityZone).toBe('us-east-1c');      expect(subnet1.Properties.CidrBlock).toBe('10.0.1.0/24');      expect(subnet2.Properties.CidrBlock).toBe('10.0.2.0/24');      expect(subnet3.Properties.CidrBlock).toBe('10.0.3.0/24');    });    test('should have public route table with IGW route', () => {      const routeTable = template.Resources.PublicRouteTable;      const route = template.Resources.DefaultPublicRoute;      expect(routeTable.Type).toBe('AWS::EC2::RouteTable');      expect(route.Type).toBe('AWS::EC2::Route');      expect(route.Properties.DestinationCidrBlock).toBe('0.0.0.0/0');    });  });  describe('Security Groups', () => {    test('should have ALB security group with correct rules', () => {      const sg = template.Resources.ALBSecurityGroup;      expect(sg.Type).toBe('AWS::EC2::SecurityGroup');      expect(sg.Properties.GroupName).toBe('ALB-SecurityGroup');      const inboundRules = sg.Properties.SecurityGroupIngress;      expect(inboundRules).toHaveLength(2);            const httpRule = inboundRules.find((rule: any) => rule.FromPort === 80);      const httpsRule = inboundRules.find((rule: any) => rule.FromPort === 443);            expect(httpRule.CidrIp).toBe('0.0.0.0/0');      expect(httpsRule.CidrIp).toBe('0.0.0.0/0');    });    test('should have EC2 security group with ALB access', () => {      const sg = template.Resources.EC2SecurityGroup;      expect(sg.Type).toBe('AWS::EC2::SecurityGroup');      expect(sg.Properties.GroupName).toBe('EC2-SecurityGroup');      const inboundRules = sg.Properties.SecurityGroupIngress;      const httpFromALB = inboundRules.find((rule: any) => rule.FromPort === 80);            expect(httpFromALB.SourceSecurityGroupId.Ref).toBe('ALBSecurityGroup');    });  });  describe('IAM Resources', () => {    test('should have EC2 role with correct policies', () => {      const role = template.Resources.EC2Role;      expect(role.Type).toBe('AWS::IAM::Role');      expect(role.Properties.ManagedPolicyArns).toContain('arn:aws:iam::aws:policy/CloudWatchAgentServerPolicy');      const policies = role.Properties.Policies;      expect(policies).toHaveLength(1);      expect(policies[0].PolicyName).toBe('S3ApplicationAccess');    });    test('should have instance profile', () => {      const profile = template.Resources.EC2InstanceProfile;      expect(profile.Type).toBe('AWS::IAM::InstanceProfile');      expect(profile.Properties.Roles[0].Ref).toBe('EC2Role');    });  });  describe('Launch Template', () => {    test('should have launch template with correct configuration', () => {      const lt = template.Resources.EC2LaunchTemplate;      expect(lt.Type).toBe('AWS::EC2::LaunchTemplate');      expect(lt.Properties.LaunchTemplateName).toBe('WebApp-LaunchTemplate');      const data = lt.Properties.LaunchTemplateData;      expect(data.InstanceType).toBe('t3.micro');      expect(data.KeyName.Ref).toBe('KeyName');      expect(data.UserData).toBeDefined();    });  });  describe('Application Load Balancer', () => {    test('should have ALB with correct configuration', () => {      const alb = template.Resources.ApplicationLoadBalancer;      expect(alb.Type).toBe('AWS::ElasticLoadBalancingV2::LoadBalancer');      expect(alb.Properties.Name).toBe('WebApp-ALB');      expect(alb.Properties.Scheme).toBe('internet-facing');      expect(alb.Properties.Type).toBe('application');    });    test('should have target group with health checks', () => {      const tg = template.Resources.ALBTargetGroup;      expect(tg.Type).toBe('AWS::ElasticLoadBalancingV2::TargetGroup');      expect(tg.Properties.Name).toBe('WebApp-TargetGroup');      expect(tg.Properties.HealthCheckPath).toBe('/health');      expect(tg.Properties.HealthCheckEnabled).toBe(true);    });    test('should have HTTP and HTTPS listeners', () => {      const httpListener = template.Resources.ALBHTTPListener;      const httpsListener = template.Resources.ALBHTTPSListener;      expect(httpListener.Type).toBe('AWS::ElasticLoadBalancingV2::Listener');      expect(httpListener.Properties.Port).toBe(80);      expect(httpListener.Properties.Protocol).toBe('HTTP');      expect(httpsListener.Type).toBe('AWS::ElasticLoadBalancingV2::Listener');      expect(httpsListener.Properties.Port).toBe(443);    });  });  describe('Auto Scaling', () => {    test('should have auto scaling group with correct configuration', () => {      const asg = template.Resources.AutoScalingGroup;      expect(asg.Type).toBe('AWS::AutoScaling::AutoScalingGroup');      expect(asg.Properties.MinSize).toBe(2);      expect(asg.Properties.MaxSize).toBe(4);      expect(asg.Properties.DesiredCapacity).toBe(2);      expect(asg.Properties.HealthCheckType).toBe('ELB');    });    test('should have scaling policies', () => {      const scaleUp = template.Resources.ScaleUpPolicy;      const scaleDown = template.Resources.ScaleDownPolicy;      expect(scaleUp.Type).toBe('AWS::AutoScaling::ScalingPolicy');      expect(scaleUp.Properties.ScalingAdjustment).toBe(1);      expect(scaleDown.Type).toBe('AWS::AutoScaling::ScalingPolicy');      expect(scaleDown.Properties.ScalingAdjustment).toBe(-1);    });  });  describe('CloudWatch Alarms', () => {    test('should have CPU alarms for scaling', () => {      const highAlarm = template.Resources.CPUAlarmHigh;      const lowAlarm = template.Resources.CPUAlarmLow;      expect(highAlarm.Type).toBe('AWS::CloudWatch::Alarm');      expect(highAlarm.Properties.AlarmName).toBe('WebApp-CPU-High');      expect(highAlarm.Properties.Threshold).toBe(70);      expect(lowAlarm.Type).toBe('AWS::CloudWatch::Alarm');      expect(lowAlarm.Properties.AlarmName).toBe('WebApp-CPU-Low');      expect(lowAlarm.Properties.Threshold).toBe(25);    });  });  describe('Outputs', () => {    test('should have all required outputs', () => {      const expectedOutputs = [        'LoadBalancerDNSName',        'ApplicationHTTPURL',         'ApplicationHTTPSURL',        'VPCId',        'AutoScalingGroupName'      ];      expectedOutputs.forEach(outputKey => {        expect(template.Outputs[outputKey]).toBeDefined();      });    });    test('should have LoadBalancerDNSName output with correct format', () => {      const output = template.Outputs.LoadBalancerDNSName;      expect(output.Description).toBe('DNS name of the Application Load Balancer');      expect(output.Value).toEqual({        'Fn::GetAtt': ['ApplicationLoadBalancer', 'DNSName']      });    });    test('should have application URLs with correct format', () => {      const httpOutput = template.Outputs.ApplicationHTTPURL;      const httpsOutput = template.Outputs.ApplicationHTTPSURL;      expect(httpOutput.Value).toEqual({        'Fn::Sub': 'http://${ApplicationLoadBalancer.DNSName}'      });      expect(httpsOutput.Value).toEqual({        'Fn::Sub': 'https://${ApplicationLoadBalancer.DNSName}'      });    });    test('outputs should have export names', () => {      Object.keys(template.Outputs).forEach(outputKey => {        const output = template.Outputs[outputKey];        expect(output.Export).toBeDefined();        expect(output.Export.Name).toBeDefined();      });    });  });  describe('Resource Tagging', () => {    test('should have consistent tagging across resources', () => {      const taggedResources = [        'VPC',        'InternetGateway',         'PublicSubnet1',        'PublicSubnet2',        'PublicSubnet3',        'ALBSecurityGroup',        'EC2SecurityGroup',        'ApplicationLoadBalancer',        'ALBTargetGroup'      ];      taggedResources.forEach(resourceName => {        const resource = template.Resources[resourceName];        expect(resource.Properties.Tags).toBeDefined();                const envTag = resource.Properties.Tags.find((tag: any) => tag.Key === 'Environment');        expect(envTag).toBeDefined();        expect(envTag.Value).toBe('Production');      });    });  });});