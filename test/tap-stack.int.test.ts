/**
 * Integration tests for TapStack
 * These tests validate the actual deployed infrastructure outputs
 */

import * as fs from 'fs';
import * as path from 'path';

describe('TapStack Integration Tests', () => {
  let outputs: any;

  beforeAll(() => {
    // Read the flat-outputs.json file generated by the deployment
    const outputsPath = path.join(__dirname, '../flat-outputs.json');

    if (fs.existsSync(outputsPath)) {
      const outputsContent = fs.readFileSync(outputsPath, 'utf8');
      outputs = JSON.parse(outputsContent);
    } else {
      // If flat-outputs.json doesn't exist, skip tests
      outputs = null;
    }
  });

  describe('Deployment Outputs Validation', () => {
    it('should have all required outputs', () => {
      if (!outputs) {
        console.log('Skipping test - flat-outputs.json not found');
        return;
      }

      expect(outputs).toHaveProperty('vpcId');
      expect(outputs).toHaveProperty('ecsClusterName');
      expect(outputs).toHaveProperty('ecsClusterArn');
      expect(outputs).toHaveProperty('albDnsName');
      expect(outputs).toHaveProperty('cloudFrontUrl');
      expect(outputs).toHaveProperty('cloudFrontDistributionId');
      expect(outputs).toHaveProperty('dbClusterEndpoint');
      expect(outputs).toHaveProperty('dbClusterIdentifier');
      expect(outputs).toHaveProperty('frontendRepoUrl');
      expect(outputs).toHaveProperty('backendRepoUrl');
      expect(outputs).toHaveProperty('rdsKmsKeyId');
      expect(outputs).toHaveProperty('ecsKmsKeyId');
      expect(outputs).toHaveProperty('dbSecretArn');
      expect(outputs).toHaveProperty('appConfigParamName');
    });
  });

  describe('VPC Outputs', () => {
    it('should have valid VPC ID format', () => {
      if (!outputs) return;

      expect(outputs.vpcId).toBeDefined();
      expect(outputs.vpcId).toMatch(/^vpc-[a-f0-9]+$/);
    });
  });

  describe('ECS Outputs', () => {
    it('should have valid ECS cluster name', () => {
      if (!outputs) return;

      expect(outputs.ecsClusterName).toBeDefined();
      expect(outputs.ecsClusterName).toMatch(/^payment-cluster-/);
    });

    it('should have valid ECS cluster ARN', () => {
      if (!outputs) return;

      expect(outputs.ecsClusterArn).toBeDefined();
      expect(outputs.ecsClusterArn).toMatch(/^arn:aws:ecs:[^:]+:[^:]+:cluster\//);
    });

    it('should have cluster name matching in ARN', () => {
      if (!outputs) return;

      expect(outputs.ecsClusterArn).toContain(outputs.ecsClusterName);
    });
  });

  describe('ALB Outputs', () => {
    it('should have valid ALB DNS name', () => {
      if (!outputs) return;

      expect(outputs.albDnsName).toBeDefined();
      expect(outputs.albDnsName).toMatch(/^payment-alb-[^-]+-[0-9]+\.us-east-1\.elb\.amazonaws\.com$/);
    });
  });

  describe('CloudFront Outputs', () => {
    it('should have valid CloudFront distribution ID', () => {
      if (!outputs) return;

      expect(outputs.cloudFrontDistributionId).toBeDefined();
      expect(outputs.cloudFrontDistributionId).toMatch(/^[A-Z0-9]+$/);
    });

    it('should have valid CloudFront URL', () => {
      if (!outputs) return;

      expect(outputs.cloudFrontUrl).toBeDefined();
      expect(outputs.cloudFrontUrl).toMatch(/^[a-z0-9]+\.cloudfront\.net$/);
    });
  });

  describe('RDS Outputs', () => {
    it('should have valid database cluster endpoint', () => {
      if (!outputs) return;

      expect(outputs.dbClusterEndpoint).toBeDefined();
      expect(outputs.dbClusterEndpoint).toMatch(/^payment-db-[^.]+\.cluster-[^.]+\.[^.]+\.rds\.amazonaws\.com$/);
    });

    it('should have valid database cluster identifier', () => {
      if (!outputs) return;

      expect(outputs.dbClusterIdentifier).toBeDefined();
      expect(outputs.dbClusterIdentifier).toMatch(/^payment-db-/);
    });

    it('should have cluster identifier in endpoint', () => {
      if (!outputs) return;

      expect(outputs.dbClusterEndpoint).toContain(outputs.dbClusterIdentifier);
    });
  });

  describe('ECR Outputs', () => {
    it('should have valid frontend repository URL', () => {
      if (!outputs) return;

      expect(outputs.frontendRepoUrl).toBeDefined();
      expect(outputs.frontendRepoUrl).toMatch(/\.dkr\.ecr\.[^.]+\.amazonaws\.com\/frontend-/);
    });

    it('should have valid backend repository URL', () => {
      if (!outputs) return;

      expect(outputs.backendRepoUrl).toBeDefined();
      expect(outputs.backendRepoUrl).toMatch(/\.dkr\.ecr\.[^.]+\.amazonaws\.com\/backend-/);
    });
  });

  describe('KMS Outputs', () => {
    it('should have valid RDS KMS key ID', () => {
      if (!outputs) return;

      expect(outputs.rdsKmsKeyId).toBeDefined();
      expect(outputs.rdsKmsKeyId).toMatch(/^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/);
    });

    it('should have valid ECS KMS key ID', () => {
      if (!outputs) return;

      expect(outputs.ecsKmsKeyId).toBeDefined();
      expect(outputs.ecsKmsKeyId).toMatch(/^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/);
    });

    it('should have different KMS keys for RDS and ECS', () => {
      if (!outputs) return;

      expect(outputs.rdsKmsKeyId).not.toBe(outputs.ecsKmsKeyId);
    });
  });

  describe('Secrets Manager Outputs', () => {
    it('should have valid database secret ARN', () => {
      if (!outputs) return;

      expect(outputs.dbSecretArn).toBeDefined();
      expect(outputs.dbSecretArn).toMatch(/^arn:aws:secretsmanager:[^:]+:[^:]+:secret:payment-db-credentials-/);
    });
  });

  describe('SSM Parameter Store Outputs', () => {
    it('should have valid app config parameter name', () => {
      if (!outputs) return;

      expect(outputs.appConfigParamName).toBeDefined();
      expect(outputs.appConfigParamName).toMatch(/^\/payment-app\/[^/]+\/config$/);
    });
  });

  describe('Output Consistency', () => {
    it('should have consistent environment suffix across resources', () => {
      if (!outputs) return;

      // Extract environment suffix from cluster name
      const clusterMatch = outputs.ecsClusterName.match(/^payment-cluster-(.+)$/);
      if (clusterMatch) {
        const envSuffix = clusterMatch[1];

        // Check that the same suffix is used across resources
        expect(outputs.dbClusterIdentifier).toContain(envSuffix);
        expect(outputs.appConfigParamName).toContain(envSuffix);
        expect(outputs.frontendRepoUrl).toContain(`frontend-${envSuffix}`);
        expect(outputs.backendRepoUrl).toContain(`backend-${envSuffix}`);
      }
    });

    it('should have all outputs as strings', () => {
      if (!outputs) return;

      Object.values(outputs).forEach(value => {
        expect(typeof value).toBe('string');
      });
    });

    it('should have no empty output values', () => {
      if (!outputs) return;

      Object.entries(outputs).forEach(([key, value]) => {
        expect(value).toBeTruthy();
        expect((value as string).length).toBeGreaterThan(0);
      });
    });
  });

  describe('AWS Region Validation', () => {
    it('should have all resources in us-east-1', () => {
      if (!outputs) return;

      expect(outputs.albDnsName).toContain('us-east-1');
      expect(outputs.ecsClusterArn).toContain('us-east-1');
      expect(outputs.dbSecretArn).toContain('us-east-1');
      expect(outputs.dbClusterEndpoint).toMatch(/us-east-1/);
    });
  });

  describe('Naming Conventions', () => {
    it('should follow payment- prefix naming convention', () => {
      if (!outputs) return;

      expect(outputs.ecsClusterName).toMatch(/^payment-/);
      expect(outputs.dbClusterIdentifier).toMatch(/^payment-/);
      expect(outputs.albDnsName).toMatch(/^payment-/);
    });

    it('should have proper resource naming in parameter paths', () => {
      if (!outputs) return;

      expect(outputs.appConfigParamName).toMatch(/^\/payment-app\//);
    });

    it('should have proper secret naming', () => {
      if (!outputs) return;

      expect(outputs.dbSecretArn).toContain('payment-db-credentials');
    });
  });
});
