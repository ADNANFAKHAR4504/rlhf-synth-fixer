import {
  EC2Client,
  DescribeVpcsCommand,
  DescribeSubnetsCommand,
  DescribeSecurityGroupsCommand,
  DescribeInternetGatewaysCommand,
  DescribeNatGatewaysCommand,
  DescribeLaunchTemplatesCommand,
  DescribeLaunchTemplateVersionsCommand,
} from '@aws-sdk/client-ec2';
import {
  ElasticLoadBalancingV2Client,
  DescribeLoadBalancersCommand,
  DescribeListenersCommand,
  DescribeTargetGroupsCommand,
  DescribeTargetHealthCommand,
} from '@aws-sdk/client-elastic-load-balancing-v2';
import {
  AutoScalingClient,
  DescribeAutoScalingGroupsCommand,
} from '@aws-sdk/client-auto-scaling';
import { IAMClient, GetRoleCommand } from '@aws-sdk/client-iam';
import {
  Route53Client,
  ListResourceRecordSetsCommand,
  ListHealthChecksCommand,
  ResourceRecordSet,
  HealthCheck,
} from '@aws-sdk/client-route-53';
import { SNSClient, GetTopicAttributesCommand } from '@aws-sdk/client-sns';
import {
  BackupClient,
  DescribeBackupVaultCommand,
  GetBackupPlanCommand,
} from '@aws-sdk/client-backup';
import {
  CloudWatchClient,
  DescribeAlarmsCommand,
} from '@aws-sdk/client-cloudwatch';
import https from 'https';
import fs from 'fs';
import path from 'path';

// --- Configuration ---
// This file is generated by running `aws cloudformation describe-stacks --stack-name YourStackName --query "Stacks[0].Outputs"`
// and then manually adding the additional required values listed below.
const outputs: { [key: string]: string } = JSON.parse(
  fs.readFileSync(path.join(__dirname, './cfn-outputs.json'), 'utf8')
);
/*
 * =================================================================
 * REQUIRED `cfn-outputs.json` KEYS
 * =================================================================
 * The following values must be present in cfn-outputs.json for the tests to run:
 *
 * (Values from Stack Outputs)
 * - LoadBalancerDNSName
 * - ApplicationURL
 *
 * (Values to add manually from stack resources/parameters)
 * - StackName
 * - HostedZoneId
 * - HostedZoneName
 * - VPCId
 * - ALBSecurityGroupId
 * - EC2InstanceRoleName
 * - AutoScalingGroupName
 * - TargetGroupArn
 * - ApplicationLoadBalancerArn
 * - NotificationSNSTopicArn
 * - BackupVaultName
 * - LaunchTemplateName
 * =================================================================
 */

// Initialize AWS SDK Clients - Defaults to us-west-2 to match the CFN template.
const region = { region: process.env.AWS_REGION || 'us-west-2' };
const ec2Client = new EC2Client(region);
const elbv2Client = new ElasticLoadBalancingV2Client(region);
const asgClient = new AutoScalingClient(region);
const iamClient = new IAMClient(region);
const route53Client = new Route53Client(region);
const snsClient = new SNSClient(region);
const backupClient = new BackupClient(region);
const cloudWatchClient = new CloudWatchClient(region);

// Increase Jest timeout for AWS async operations
jest.setTimeout(90000); // 90 seconds

describe('Failure Recovery and High Availability Stack Integration Tests', () => {
  // --- Networking Validation ---
  describe('Networking: VPC, Subnets, and Gateways', () => {
    test('VPC should exist and be available', async () => {
      const { Vpcs } = await ec2Client.send(
        new DescribeVpcsCommand({ VpcIds: [outputs.VPCId] })
      );
      expect(Vpcs?.[0]?.State).toBe('available');
    });

    test('Should have 3 public and 3 private subnets', async () => {
      const { Subnets } = await ec2Client.send(
        new DescribeSubnetsCommand({
          Filters: [{ Name: 'vpc-id', Values: [outputs.VPCId] }],
        })
      );
      const publicSubnets =
        Subnets?.filter(s => s.MapPublicIpOnLaunch === true) ?? [];
      const privateSubnets =
        Subnets?.filter(s => s.MapPublicIpOnLaunch === false) ?? [];
      expect(publicSubnets.length).toBe(3);
      expect(privateSubnets.length).toBe(3);
    });

    test('Internet Gateway should be attached to the VPC', async () => {
      const { InternetGateways } = await ec2Client.send(
        new DescribeInternetGatewaysCommand({
          Filters: [{ Name: 'attachment.vpc-id', Values: [outputs.VPCId] }],
        })
      );
      expect(InternetGateways?.length).toBe(1);
      expect(InternetGateways?.[0]?.Attachments?.[0]?.State).toBe('available');
    });

    test('NAT Gateway should exist and be available', async () => {
      const { NatGateways } = await ec2Client.send(
        new DescribeNatGatewaysCommand({
          Filter: [{ Name: 'vpc-id', Values: [outputs.VPCId] }],
        })
      );
      expect(NatGateways?.length).toBe(1);
      expect(NatGateways?.[0]?.State).toBe('available');
    });
  });

  // --- Security Validation ---
  describe('Security: IAM Roles and Security Groups', () => {
    test('EC2 Instance Role should exist and be assumable by EC2', async () => {
      const { Role } = await iamClient.send(
        new GetRoleCommand({ RoleName: outputs.EC2InstanceRoleName })
      );
      const assumeRolePolicy = JSON.parse(
        decodeURIComponent(Role?.AssumeRolePolicyDocument ?? '{}')
      );
      expect(Role).toBeDefined();
      expect(assumeRolePolicy.Statement[0].Principal.Service).toBe(
        'ec2.amazonaws.com'
      );
    });

    test('ALB Security Group should allow inbound HTTP/HTTPS traffic', async () => {
      const { SecurityGroups } = await ec2Client.send(
        new DescribeSecurityGroupsCommand({
          GroupIds: [outputs.ALBSecurityGroupId],
        })
      );
      const sg = SecurityGroups?.[0];
      const httpRule = sg?.IpPermissions?.find(p => p.FromPort === 80);
      const httpsRule = sg?.IpPermissions?.find(p => p.FromPort === 443);
      expect(httpRule?.IpRanges?.[0]?.CidrIp).toBe('0.0.0.0/0');
      expect(httpsRule?.IpRanges?.[0]?.CidrIp).toBe('0.0.0.0/0');
    });

    test('Instance Security Group should only allow traffic from the ALB SG on port 8080', async () => {
      const { SecurityGroups } = await ec2Client.send(
        new DescribeSecurityGroupsCommand({
          Filters: [
            {
              Name: 'group-name',
              Values: [`${outputs.StackName}-Instance-SG`],
            },
          ],
        })
      );
      const sg = SecurityGroups?.[0];
      const appRule = sg?.IpPermissions?.find(p => p.FromPort === 8080);
      expect(sg?.IpPermissions?.length).toBe(1);
      expect(appRule?.UserIdGroupPairs?.[0]?.GroupId).toBe(
        outputs.ALBSecurityGroupId
      );
    });
  });

  // --- Load Balancer & DNS Validation ---
  describe('Load Balancing: ALB, Listeners, Target Group, and DNS', () => {
    test('ALB should exist, be active, and internet-facing', async () => {
      const { LoadBalancers } = await elbv2Client.send(
        new DescribeLoadBalancersCommand({
          LoadBalancerArns: [outputs.ApplicationLoadBalancerArn],
        })
      );
      const alb = LoadBalancers?.[0];
      expect(alb).toBeDefined();
      expect(alb?.State?.Code).toBe('active');
      expect(alb?.Scheme).toBe('internet-facing');
    });

    test('ALB should have an HTTPS listener and an HTTP redirect listener', async () => {
      const { Listeners } = await elbv2Client.send(
        new DescribeListenersCommand({
          LoadBalancerArn: outputs.ApplicationLoadBalancerArn,
        })
      );
      const httpsListener = Listeners?.find(l => l.Port === 443);
      const httpListener = Listeners?.find(l => l.Port === 80);

      expect(httpsListener?.Protocol).toBe('HTTPS');
      expect(httpsListener?.DefaultActions?.[0]?.Type).toBe('forward');
      expect(httpListener?.Protocol).toBe('HTTP');
      expect(httpListener?.DefaultActions?.[0]?.Type).toBe('redirect');
    });

    test('Target Group should have healthy targets', async () => {
      const { TargetHealthDescriptions } = await elbv2Client.send(
        new DescribeTargetHealthCommand({
          TargetGroupArn: outputs.TargetGroupArn,
        })
      );
      // The number of healthy targets should be equal to or greater than the ASG's minimum size.
      expect(TargetHealthDescriptions?.length).toBeGreaterThanOrEqual(2);
      (TargetHealthDescriptions ?? []).forEach(target => {
        expect(target.TargetHealth?.State).toBe('healthy');
      });
    });

    test('Route 53 Alias record should point to the ALB', async () => {
      const { ResourceRecordSets } = await route53Client.send(
        new ListResourceRecordSetsCommand({
          HostedZoneId: outputs.HostedZoneId,
        })
      );
      const appRecord = ResourceRecordSets?.find(
        (r: ResourceRecordSet) => r.Name === outputs.HostedZoneName
      );

      expect(appRecord).toBeDefined();
      expect(appRecord?.Type).toBe('A');
      expect(appRecord?.AliasTarget).toBeDefined();

      const aliasTargetDns = (appRecord?.AliasTarget?.DNSName ?? '')
        .toLowerCase()
        .replace(/\.$/, '');
      const albDns = outputs.LoadBalancerDNSName.toLowerCase();
      expect(aliasTargetDns).toBe(albDns);
    });

    test('Route 53 Health Check should exist for the domain', async () => {
      const { HealthChecks } = await route53Client.send(
        new ListHealthChecksCommand({})
      );
      const healthCheck = HealthChecks?.find(
        (hc: HealthCheck) =>
          hc.HealthCheckConfig?.FullyQualifiedDomainName ===
          outputs.HostedZoneName.slice(0, -1)
      );
      expect(healthCheck).toBeDefined();
      expect(healthCheck?.HealthCheckConfig?.Type).toBe('HTTPS');
    });
  });

  // --- Compute and Application Accessibility ---
  describe('Compute: Auto Scaling Group, Launch Template, and Web App', () => {
    test('Auto Scaling Group should have correct capacity and settings', async () => {
      const { AutoScalingGroups } = await asgClient.send(
        new DescribeAutoScalingGroupsCommand({
          AutoScalingGroupNames: [outputs.AutoScalingGroupName],
        })
      );
      const asg = AutoScalingGroups?.[0];
      // These values should match the defaults in your CloudFormation template.
      expect(asg).toBeDefined();
      expect(asg?.MinSize).toBe(2);
      expect(asg?.MaxSize).toBe(6);
      expect(asg?.DesiredCapacity).toBe(2);
      expect(asg?.HealthCheckType).toBe('ELB');
    });

    test('Launch Template should specify encrypted EBS volumes', async () => {
      const { LaunchTemplates } = await ec2Client.send(
        new DescribeLaunchTemplatesCommand({
          LaunchTemplateNames: [outputs.LaunchTemplateName],
        })
      );
      const ltId = LaunchTemplates?.[0]?.LaunchTemplateId;
      const { LaunchTemplateVersions } = await ec2Client.send(
        new DescribeLaunchTemplateVersionsCommand({
          LaunchTemplateId: ltId,
          Versions: ['$Latest'],
        })
      );
      const ebsConfig =
        LaunchTemplateVersions?.[0]?.LaunchTemplateData
          ?.BlockDeviceMappings?.[0]?.Ebs;
      expect(ebsConfig?.Encrypted).toBe(true);
    });

    test('Application should be accessible via custom domain and return HTTP 200', () => {
      // The ApplicationURL output is "https://www.example.com." but the R53 record is at the apex "example.com."
      // This test corrects the URL to hit the apex domain for the check.
      const url = outputs.ApplicationURL.replace('www.', '');
      return new Promise<void>((resolve, reject) => {
        const request = https.get(
          url,
          // For a real domain with a trusted cert from ACM, you don't need `rejectUnauthorized: false`.
          // It's included here for robustness in test environments.
          { rejectUnauthorized: false },
          response => {
            if (response.statusCode !== 200) {
              return reject(
                new Error(
                  `Request to ${url} failed with status: ${response.statusCode}`
                )
              );
            }
            resolve();
          }
        );
        request.on('error', reject);
      });
    });
  });

  // --- Backup and Monitoring ---
  describe('Backup, Monitoring, and Notifications', () => {
    test('AWS Backup Vault should exist', async () => {
      const { BackupVaultName } = await backupClient.send(
        new DescribeBackupVaultCommand({
          BackupVaultName: outputs.BackupVaultName,
        })
      );
      expect(BackupVaultName).toBe(outputs.BackupVaultName);
    });

    test('AWS Backup Plan with a daily rule should exist', async () => {
      const { BackupPlan } = await backupClient.send(
        new GetBackupPlanCommand({
          BackupPlanId: `${outputs.StackName}-Daily-Plan`,
        })
      );
      const rule = BackupPlan?.Rules?.[0];
      expect(rule?.RuleName).toBe('DailyBackups');
      expect(rule?.ScheduleExpression).toBe('cron(0 5 * * ? *)');
      expect(rule?.Lifecycle?.DeleteAfterDays).toBe(7);
    });

    test('SNS Topic for notifications should exist', async () => {
      const { Attributes } = await snsClient.send(
        new GetTopicAttributesCommand({
          TopicArn: outputs.NotificationSNSTopicArn,
        })
      );
      expect(Attributes).toBeDefined();
      expect(Attributes?.TopicArn).toBe(outputs.NotificationSNSTopicArn);
    });

    test('CloudWatch High CPU alarm should be configured correctly', async () => {
      const { MetricAlarms } = await cloudWatchClient.send(
        new DescribeAlarmsCommand({
          AlarmNames: [`${outputs.StackName}-High-CPU-Utilization`],
        })
      );
      const alarm = MetricAlarms?.[0];
      expect(alarm).toBeDefined();
      expect(alarm?.MetricName).toBe('CPUUtilization');
      expect(alarm?.Namespace).toBe('AWS/EC2');
      expect(alarm?.Statistic).toBe('Average');
      expect(alarm?.Threshold).toBe(75);
      expect(alarm?.Dimensions?.[0]?.Value).toBe(outputs.AutoScalingGroupName);
    });
  });
});
