import {
  EC2Client,
  DescribeVpcsCommand,
  DescribeSubnetsCommand,
  DescribeSecurityGroupsCommand,
  DescribeNatGatewaysCommand,
  DescribeRouteTablesCommand,
} from '@aws-sdk/client-ec2';
import {
  ElasticBeanstalkClient,
  DescribeEnvironmentsCommand,
} from '@aws-sdk/client-elastic-beanstalk';
import { RDSClient, DescribeDBInstancesCommand } from '@aws-sdk/client-rds';
import {
  Route53Client,
  ListResourceRecordSetsCommand,
  ListHostedZonesByNameCommand,
} from '@aws-sdk/client-route-53';
import {
  SecretsManagerClient,
  DescribeSecretCommand,
} from '@aws-sdk/client-secrets-manager';
import * as fs from 'fs';
import * as path from 'path';

// --- Test Configuration ---
// Assumes you have a script that runs 'aws cloudformation describe-stacks' and saves the outputs.
const STACK_NAME = `TapStack${process.env.ENVIRONMENT_SUFFIX}` || 'dev'; // Set your stack name here or via environment variable
const REGION = process.env.AWS_REGION || 'us-east-1';

// --- AWS SDK Clients ---
const ec2Client = new EC2Client({ region: REGION });
const ebClient = new ElasticBeanstalkClient({ region: REGION });
const rdsClient = new RDSClient({ region: REGION });
const route53Client = new Route53Client({ region: REGION });
const secretsManagerClient = new SecretsManagerClient({ region: REGION });

// --- Read Deployed Stack Outputs ---
// This file should be generated by a CI/CD step after 'cdk deploy' or 'sam deploy'
let outputs = {};
try {
  outputs = JSON.parse(
    fs.readFileSync(path.join(__dirname, 'cfn-outputs.json'), 'utf8')
  );
} catch (error) {
  console.warn(
    'cfn-outputs.json not found. Integration tests will be skipped. Make sure to deploy the stack and generate the outputs file.'
  );
}

// Conditionally run tests only if outputs were loaded successfully
const testSuite = Object.keys(outputs).length > 0 ? describe : describe.skip;

testSuite('Node.js Production Stack Integration Tests', () => {
  let vpcId;
  let ebEnvironmentName;
  let dbInstanceIdentifier;

  beforeAll(async () => {
    // Find the deployed Elastic Beanstalk environment to get its VPC and other details
    const ebResponse = await ebClient.send(
      new DescribeEnvironmentsCommand({
        EnvironmentNames: [`${STACK_NAME}-Env`],
      })
    );

    if (!ebResponse.Environments || ebResponse.Environments.length === 0) {
      throw new Error(
        `Could not find deployed Elastic Beanstalk environment named ${STACK_NAME}-Env`
      );
    }
    const environment = ebResponse.Environments[0];
    ebEnvironmentName = environment.EnvironmentName;

    // Find the RDS instance to get its VPC
    const rdsResponse = await rdsClient.send(
      new DescribeDBInstancesCommand({
        DBInstanceIdentifier: `${STACK_NAME.toLowerCase()}db`, // DBName is lowercased by CloudFormation
      })
    );

    if (!rdsResponse.DBInstances || rdsResponse.DBInstances.length === 0) {
      throw new Error(
        `Could not find deployed RDS instance with identifier starting with ${STACK_NAME.toLowerCase()}db`
      );
    }
    const dbInstance = rdsResponse.DBInstances[0];
    vpcId = dbInstance.DBSubnetGroup.VpcId;
    dbInstanceIdentifier = dbInstance.DBInstanceIdentifier;
  }, 60000); // 60-second timeout for beforeAll

  describe('ðŸŒ Networking Infrastructure', () => {
    test('VPC should exist and be in an available state', async () => {
      const { Vpcs } = await ec2Client.send(
        new DescribeVpcsCommand({ VpcIds: [vpcId] })
      );
      expect(Vpcs).toHaveLength(1);
      expect(Vpcs[0].CidrBlock).toBe('10.0.0.0/16');
      expect(Vpcs[0].State).toBe('available');
    });

    test('Should have 2 public and 2 private subnets across different AZs', async () => {
      const { Subnets } = await ec2Client.send(
        new DescribeSubnetsCommand({
          Filters: [{ Name: 'vpc-id', Values: [vpcId] }],
        })
      );

      const publicSubnets = Subnets.filter(s => s.MapPublicIpOnLaunch === true);
      const privateSubnets = Subnets.filter(
        s => s.MapPublicIpOnLaunch === false
      );

      expect(publicSubnets).toHaveLength(2);
      expect(privateSubnets).toHaveLength(2);

      // Verify they are in different AZs
      const publicAzs = new Set(publicSubnets.map(s => s.AvailabilityZone));
      const privateAzs = new Set(privateSubnets.map(s => s.AvailabilityZone));
      expect(publicAzs.size).toBe(2);
      expect(privateAzs.size).toBe(2);
    });

    test('Private subnets should route internet traffic through a NAT Gateway', async () => {
      const { NatGateways } = await ec2Client.send(
        new DescribeNatGatewaysCommand({
          Filter: [
            { Name: 'vpc-id', Values: [vpcId] },
            { Name: 'state', Values: ['available'] },
          ],
        })
      );
      expect(NatGateways.length).toBe(2); // One per AZ

      const { RouteTables } = await ec2Client.send(
        new DescribeRouteTablesCommand({
          Filters: [
            { Name: 'vpc-id', Values: [vpcId] },
            { Name: 'tag:Name', Values: [`${STACK_NAME}-PrivateRouteTable*`] },
          ],
        })
      );

      expect(RouteTables).toHaveLength(2);
      RouteTables.forEach(rt => {
        const natRoute = rt.Routes.find(
          r => r.DestinationCidrBlock === '0.0.0.0/0'
        );
        expect(natRoute.NatGatewayId).toBeDefined();
      });
    });
  });

  describe('ðŸ›¡ï¸ Security', () => {
    test('LoadBalancer Security Group should allow public HTTP/HTTPS traffic', async () => {
      const { SecurityGroups } = await ec2Client.send(
        new DescribeSecurityGroupsCommand({
          Filters: [
            { Name: 'vpc-id', Values: [vpcId] },
            { Name: 'group-name', Values: [`${STACK_NAME}-LBSG`] },
          ],
        })
      );
      expect(SecurityGroups).toHaveLength(1);
      const albSg = SecurityGroups[0];

      const httpRule = albSg.IpPermissions.find(
        p => p.FromPort === 80 && p.ToPort === 80 && p.IpProtocol === 'tcp'
      );
      const httpsRule = albSg.IpPermissions.find(
        p => p.FromPort === 443 && p.ToPort === 443 && p.IpProtocol === 'tcp'
      );

      expect(httpRule?.IpRanges[0].CidrIp).toBe('0.0.0.0/0');
      expect(httpsRule?.IpRanges[0].CidrIp).toBe('0.0.0.0/0');
    });

    test('DB Security Group should only allow traffic from the App Security Group', async () => {
      const { SecurityGroups } = await ec2Client.send(
        new DescribeSecurityGroupsCommand({
          Filters: [
            { Name: 'vpc-id', Values: [vpcId] },
            { Name: 'group-name', Values: [`${STACK_NAME}-DBSG`] },
          ],
        })
      );
      expect(SecurityGroups).toHaveLength(1);
      const dbSg = SecurityGroups[0];

      const appSg = (
        await ec2Client.send(
          new DescribeSecurityGroupsCommand({
            Filters: [
              { Name: 'vpc-id', Values: [vpcId] },
              { Name: 'group-name', Values: [`${STACK_NAME}-AppSG`] },
            ],
          })
        )
      ).SecurityGroups[0];

      const ingressRule = dbSg.IpPermissions.find(p => p.FromPort === 5432);
      expect(ingressRule).toBeDefined();
      expect(ingressRule.UserIdGroupPairs[0].GroupId).toBe(appSg.GroupId);
    });

    test('Database password secret should exist and be encrypted', async () => {
      const secretArn = outputs.DBSecretARN;
      const { ARN, Name, KmsKeyId } = await secretsManagerClient.send(
        new DescribeSecretCommand({ SecretId: secretArn })
      );
      expect(ARN).toBe(secretArn);
      expect(Name).toContain(`${STACK_NAME}/DBSecret`);
      expect(KmsKeyId).toBeDefined(); // Confirms it's encrypted
    });
  });

  describe('ðŸ“¦ Database (RDS)', () => {
    test('RDS instance should be available, Multi-AZ, and encrypted', async () => {
      const { DBInstances } = await rdsClient.send(
        new DescribeDBInstancesCommand({
          DBInstanceIdentifier: dbInstanceIdentifier,
        })
      );
      expect(DBInstances).toHaveLength(1);
      const db = DBInstances[0];

      expect(db.DBInstanceStatus).toBe('available');
      expect(db.MultiAZ).toBe(true);
      expect(db.StorageEncrypted).toBe(true);
      expect(db.Engine).toBe('postgres');
    }, 120000); // Increase timeout as DB can take time to become available
  });

  describe('ðŸš€ Application (Elastic Beanstalk) & DNS', () => {
    test('Elastic Beanstalk environment should be Ready and Healthy', async () => {
      const { Environments } = await ebClient.send(
        new DescribeEnvironmentsCommand({
          EnvironmentNames: [ebEnvironmentName],
        })
      );
      expect(Environments).toHaveLength(1);
      const env = Environments[0];

      expect(env.Status).toBe('Ready');
      expect(env.Health).toBe('Green');
    }, 180000); // Increase timeout as Beanstalk can take time to stabilize

    test('Route 53 should have an A record pointing to the application URL', async () => {
      const hostedZoneName = outputs.HostedZoneName;
      const domainName = outputs.DomainName;
      const applicationUrl = outputs.ApplicationURL;

      const { HostedZones } = await route53Client.send(
        new ListHostedZonesByNameCommand({ DNSName: hostedZoneName })
      );
      const hostedZoneId = HostedZones[0].Id.split('/')[2];

      const { ResourceRecordSets } = await route53Client.send(
        new ListResourceRecordSetsCommand({ HostedZoneId: hostedZoneId })
      );

      const aRecord = ResourceRecordSets.find(
        r => r.Name === `${domainName}.` && r.Type === 'A'
      );
      expect(aRecord).toBeDefined();
      expect(aRecord.AliasTarget.DNSName).toContain(
        applicationUrl.replace('http://', '')
      ); // Alias target is the raw endpoint
    });
  });
});
