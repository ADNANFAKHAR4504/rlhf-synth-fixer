import fs from 'fs';
import path from 'path';

// --- Configuration ---
// These should match the region and project name used for deployment.
const PROJECT_NAME = 'TapStack'; 

// Path to the file containing deployed CloudFormation stack outputs.
const outputsFilePath = 'cfn-outputs/flat-outputs.json';
let outputs: any;

try {
  // Read and parse the outputs JSON file once.
  const outputsContent = fs.readFileSync(outputsFilePath, 'utf8');
  outputs = JSON.parse(outputsContent);
  console.log(`✅ Successfully loaded outputs from: ${outputsFilePath}`);
} catch (error) {
  console.error(`❌ Error reading or parsing outputs file: ${outputsFilePath}`);
  console.error(`Please ensure the file exists and is valid JSON before running integration tests.`);
  console.error(`Error details:`, error);
  // Exit the process to prevent tests from running with missing/invalid outputs.
  process.exit(1);
}

// --- Test Suite ---
describe('CloudFormation Stack Outputs Verification (Post-Deployment)', () => {

  // This test suite verifies the outputs of a deployed stack by reading a JSON file.
  // It does not query live AWS resources but validates the format of the output values.

  test('should have a valid VpcId output', () => {
    const vpcId = outputs.VpcId;
    expect(vpcId).toBeDefined();
    expect(typeof vpcId).toBe('string');
    // Standard VPC ID format, e.g., vpc-0123456789abcdef0
    expect(vpcId).toMatch(/^vpc-[0-9a-f]{17}$/);
  });

  test('should have valid PublicSubnetIds output', () => {
    const publicSubnets = outputs.PublicSubnetIds;
    expect(publicSubnets).toBeDefined();
    expect(typeof publicSubnets).toBe('string');
    
    const subnetArray = publicSubnets.split(',');
    expect(subnetArray).toHaveLength(2); // Expecting two public subnets
    
    // Standard Subnet ID format, e.g., subnet-0123456789abcdef0
    subnetArray.forEach(subnetId => {
      expect(subnetId).toMatch(/^subnet-[0-9a-f]{17}$/);
    });
  });

  test('should have valid PrivateSubnetIds output', () => {
    const privateSubnets = outputs.PrivateSubnetIds;
    expect(privateSubnets).toBeDefined();
    expect(typeof privateSubnets).toBe('string');
    
    const subnetArray = privateSubnets.split(',');
    expect(subnetArray).toHaveLength(2); // Expecting two private subnets
    
    // Standard Subnet ID format
    subnetArray.forEach(subnetId => {
      expect(subnetId).toMatch(/^subnet-[0-9a-f]{17}$/);
    });
  });

  // Use test.each to efficiently test all security groups
  test.each([
    'AlbSecurityGroupId',
    'AppSecurityGroupId',
    'DbSecurityGroupId',
  ])('should have a valid %s output', (outputName) => {
    const sgId = outputs[outputName];
    expect(sgId).toBeDefined();
    expect(typeof sgId).toBe('string');
    // Standard Security Group ID format, e.g., sg-0123456789abcdef0
    expect(sgId).toMatch(/^sg-[0-9a-f]{17}$/);
  });

  test('should have a valid DbSubnetGroupName output', () => {
    const dbSubnetGroup = outputs.DbSubnetGroupName;
    expect(dbSubnetGroup).toBeDefined();
    expect(typeof dbSubnetGroup).toBe('string');
    // The name is generated by CloudFormation but should contain the project name in lowercase.
    expect(dbSubnetGroup).toContain(PROJECT_NAME.toLowerCase());
  });

  test('should have a valid Ec2InstanceRoleArn output', () => {
    const roleArn = outputs.Ec2InstanceRoleArn;
    expect(roleArn).toBeDefined();
    expect(typeof roleArn).toBe('string');
    // Standard AWS ARN format for an IAM role.
    expect(roleArn).toMatch(/^arn:aws:iam::\d{12}:role\/.*$/);
    expect(roleArn).toContain(PROJECT_NAME);
  });

  test('should have a valid NatEipR1PublicIp output', () => {
    const publicIp = outputs.NatEipR1PublicIp;
    expect(publicIp).toBeDefined();
    expect(typeof publicIp).toBe('string');
    // Basic IPv4 address format check.
    expect(publicIp).toMatch(/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/);
  });

  test('should have a valid NatEipR1AllocationId output', () => {
    const allocId = outputs.NatEipR1AllocationId;
    expect(allocId).toBeDefined();
    expect(typeof allocId).toBe('string');
    // Standard EIP allocation ID format, e.g., eipalloc-0123456789abcdef0
    expect(allocId).toMatch(/^eipalloc-[0-9a-f]{17}$/);
  });
});