import fs from 'fs';
import path from 'path';
import {
  DynamoDBClient,
  DescribeTableCommand,
} from '@aws-sdk/client-dynamodb';
import {
  SNSClient,
  GetTopicAttributesCommand,
} from '@aws-sdk/client-sns';
import {
  CloudWatchClient,
  DescribeAlarmsCommand,
} from '@aws-sdk/client-cloudwatch';

// --- Configuration ---
// Read outputs from the file generated by the CI/CD pipeline
let outputs: { [key: string]: string } = {};
try {
  const outputsPath = path.join(__dirname, '../cfn-outputs/flat-outputs.json');
  outputs = JSON.parse(fs.readFileSync(outputsPath, 'utf8'));
} catch (error) {
  // This is expected if running locally before deployment
  console.warn('Could not read cfn-outputs/flat-outputs.json. Skipping integration tests.');
}

// Get environment configuration
const environmentSuffix = process.env.ENVIRONMENT_SUFFIX || 'dev';
const region = process.env.AWS_REGION || 'us-west-2';

// âœ… CRITICAL: Detect LocalStack environment
const isLocalStack =
  process.env.AWS_ENDPOINT_URL?.includes('localhost') ||
  process.env.AWS_ENDPOINT_URL?.includes('localstack') ||
  process.env.CDK_DEFAULT_ACCOUNT === '000000000000';

console.log(`ðŸ”§ Test Environment: ${isLocalStack ? 'LocalStack' : 'AWS'}`);
console.log(`ðŸ“ Region: ${region}`);
console.log(`ðŸ·ï¸  Environment Suffix: ${environmentSuffix}`);

// Initialize AWS clients with LocalStack configuration
const getClientConfig = (service: string) => {
  if (!isLocalStack) {
    return { region };
  }

  const config: any = {
    region,
    credentials: {
      accessKeyId: process.env.AWS_ACCESS_KEY_ID || 'test',
      secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY || 'test',
    },
  };

  // S3 needs special endpoint (not used in this project, but good pattern)
  if (service === 's3') {
    config.endpoint = process.env.AWS_ENDPOINT_URL_S3 || 'http://s3.localhost.localstack.cloud:4566';
    config.forcePathStyle = true;
  } else {
    config.endpoint = process.env.AWS_ENDPOINT_URL || 'http://localhost:4566';
  }

  return config;
};

// Helper: wait for a DynamoDB table to exist and be ACTIVE (retries until timeout)
async function waitForTableActive(tableName: string, timeoutMs = 30000, intervalMs = 1000) {
  const start = Date.now();
  while (Date.now() - start < timeoutMs) {
    try {
      const resp = await dynamoClient.send(new DescribeTableCommand({ TableName: tableName }));
      if (resp.Table && (resp.Table.TableStatus === 'ACTIVE' || resp.Table.TableStatus === 'ACTIVE_WITH_ERRORS' || resp.Table.TableStatus === 'UPDATING')) {
        return resp;
      }
    } catch (err) {
      // If the table is not yet created, AWS SDK throws ResourceNotFoundException â€” keep retrying
    }
    await new Promise((r) => setTimeout(r, intervalMs));
  }
  throw new Error(`Table ${tableName} not found or not active after ${timeoutMs}ms`);
}

const dynamoClient = new DynamoDBClient(getClientConfig('dynamodb'));
const snsClient = new SNSClient(getClientConfig('sns'));
const cloudwatchClient = new CloudWatchClient(getClientConfig('cloudwatch'));

// Conditionally run tests only if the outputs file was loaded
if (Object.keys(outputs).length > 0) {
  describe('DynamoDB Inventory System - Integration Tests', () => {
    let tableArnKey: string | undefined;
    let tableStreamArnKey: string | undefined;

    beforeAll(() => {
      // Find the output keys dynamically
      tableArnKey = Object.keys(outputs).find(key => key.endsWith('TableArn'));
      tableStreamArnKey = Object.keys(outputs).find(key => key.endsWith('TableStreamArn'));
    });

    test('should have a valid Table ARN output', () => {
      expect(tableArnKey).toBeDefined();
      const tableArn = outputs[tableArnKey!];

      // Use the dynamic region in the validation regex
      const arnRegex = new RegExp(`^arn:aws:dynamodb:${region}:\\d{12}:table\\/ProductInventory$`);
      expect(tableArn).toMatch(arnRegex);
    });

    test('should have a valid Table Stream ARN output', () => {
      expect(tableStreamArnKey).toBeDefined();
      const streamArn = outputs[tableStreamArnKey!];

      // Use the dynamic region in the validation regex
      const streamArnRegex = new RegExp(`^arn:aws:dynamodb:${region}:\\d{12}:table\\/ProductInventory\\/stream\\/\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}$`);
      expect(streamArn).toMatch(streamArnRegex);
    });

    // ðŸ§ª E2E Test: Verify DynamoDB Table Configuration
    test('E2E: should verify DynamoDB table exists and is configured correctly', async () => {
      // Wait for table to be present and active (helps CI stability)
      const response = await waitForTableActive('ProductInventory', 30000, 1000);

      expect(response.Table).toBeDefined();
      expect(response.Table?.TableName).toBe('ProductInventory');
      // Allow for several active-like statuses (some LocalStack versions report different states)
      expect(['ACTIVE','ACTIVE_WITH_ERRORS','UPDATING']).toContain(response.Table?.TableStatus);
      
      // Verify partition key and sort key
      const keySchema = response.Table?.KeySchema;
      expect(keySchema).toHaveLength(2);
      expect(keySchema?.[0].AttributeName).toBe('productId');
      expect(keySchema?.[0].KeyType).toBe('HASH');
      expect(keySchema?.[1].AttributeName).toBe('warehouseId');
      expect(keySchema?.[1].KeyType).toBe('RANGE');

      // Verify billing mode
      expect(response.Table?.BillingModeSummary?.BillingMode).toBe('PAY_PER_REQUEST');

      // Verify stream is enabled
      expect(response.Table?.StreamSpecification?.StreamEnabled).toBe(true);
      expect(response.Table?.StreamSpecification?.StreamViewType).toBe('NEW_AND_OLD_IMAGES');

      console.log('âœ… DynamoDB table configuration verified');
    }, 60000);

    // ðŸ§ª E2E Test: Verify Global Secondary Index
    test('E2E: should verify GSI (WarehouseIndex) is configured correctly', async () => {
      const response = await waitForTableActive('ProductInventory', 30000, 1000);

      const gsi = response.Table?.GlobalSecondaryIndexes?.find(
        (index) => index.IndexName === 'WarehouseIndex'
      );

      expect(gsi).toBeDefined();
      // Some LocalStack versions might report 'ACTIVE' or not set status immediately
      expect(gsi?.KeySchema?.[0].AttributeName).toBe('warehouseId');
      expect(gsi?.KeySchema?.[0].KeyType).toBe('HASH');
      expect(gsi?.KeySchema?.[1].AttributeName).toBe('lastUpdated');
      expect(gsi?.KeySchema?.[1].KeyType).toBe('RANGE');
      expect(gsi?.Projection?.ProjectionType).toBe('ALL');

      console.log('âœ… GSI (WarehouseIndex) verified');
    }, 60000);

    // ðŸ§ª E2E Test: Verify Local Secondary Index
    test('E2E: should verify LSI (StatusIndex) is configured correctly', async () => {
      const response = await waitForTableActive('ProductInventory', 30000, 1000);

      const lsi = response.Table?.LocalSecondaryIndexes?.find(
        (index) => index.IndexName === 'StatusIndex'
      );

      expect(lsi).toBeDefined();
      expect(lsi?.KeySchema?.[0].AttributeName).toBe('productId');
      expect(lsi?.KeySchema?.[0].KeyType).toBe('HASH');
      expect(lsi?.KeySchema?.[1].AttributeName).toBe('stockStatus');
      expect(lsi?.KeySchema?.[1].KeyType).toBe('RANGE');
      expect(lsi?.Projection?.ProjectionType).toBe('ALL');

      console.log('âœ… LSI (StatusIndex) verified');
    }, 60000);
  });
} else {
  // If the outputs file is not found, run a placeholder test to indicate why the suite was skipped
  describe('DynamoDB Inventory System - Integration Tests', () => {
    test('skipping integration tests because cfn-outputs.json was not found', () => {
      expect(true).toBe(true);
    });
  });
}
