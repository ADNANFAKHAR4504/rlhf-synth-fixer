import * as fs from 'fs';
import * as path from 'path';
import {
  EC2Client,
  DescribeInstancesCommand,
  Instance,
  DescribeVolumesCommand,
} from '@aws-sdk/client-ec2';
import {
  KMSClient,
  DescribeKeyCommand,
  ListAliasesCommand,
} from '@aws-sdk/client-kms';
import {
  S3Client,
  GetBucketEncryptionCommand,
  GetPublicAccessBlockCommand,
} from '@aws-sdk/client-s3';
import {
  ConfigServiceClient,
  DescribeConfigRulesCommand,
} from '@aws-sdk/client-config-service';

/* ----------------------------- Utilities & Types ----------------------------- */

// Type definition for the structure of the Terraform output JSON
type TfOutputValue<T> = { sensitive: boolean; type: any; value: T };
type DeploymentSummary = {
  [region: string]: {
    s3_bucket_name: string;
    ec2_instance_id: string;
    kms_key_arn: string;
  };
};
type StructuredOutputs = {
  deployment_summary: TfOutputValue<DeploymentSummary>;
};

/**
 * Reads and validates the structured outputs from the CI/CD pipeline.
 * @returns The parsed and validated deployment summary.
 */
function readDeploymentOutputs(): DeploymentSummary {
  const filePath = path.resolve(process.cwd(), 'cfn-outputs/all-outputs.json');
  if (!fs.existsSync(filePath)) {
    throw new Error(
      `Outputs file not found at ${filePath}. This file must be generated by the CI/CD 'Get Deployment Outputs' stage.`
    );
  }
  const outputs = JSON.parse(
    fs.readFileSync(filePath, 'utf8')
  ) as StructuredOutputs;

  const summary = outputs.deployment_summary?.value;
  if (!summary) {
    throw new Error('`deployment_summary` missing in outputs file.');
  }

  // Validate that expected regions and their properties exist
  const expectedRegions = ['us-east-1', 'us-west-2'];
  for (const region of expectedRegions) {
    if (
      !summary[region]?.s3_bucket_name ||
      !summary[region]?.ec2_instance_id ||
      !summary[region]?.kms_key_arn
    ) {
      throw new Error(
        `Output for region '${region}' is incomplete. Check s3_bucket_name, ec2_instance_id, and kms_key_arn.`
      );
    }
  }

  return summary;
}

/**
 * A simple retry mechanism for eventually consistent AWS API calls.
 */
async function retry<T>(
  fn: () => Promise<T>,
  attempts = 5,
  delayMs = 2000
): Promise<T> {
  let lastError: any;
  for (let i = 0; i < attempts; i++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error;
      await new Promise(resolve => setTimeout(resolve, delayMs * (i + 1)));
    }
  }
  throw lastError;
}

/* ----------------------------- Test Suite ----------------------------- */

describe('LIVE: Multi-Region AWS Infrastructure Integration Tests', () => {
  const outputs = readDeploymentOutputs();
  const regions = Object.keys(outputs);
  const TEST_TIMEOUT = 120_000;

  // Verify we have the expected regions
  it('should have deployed to us-east-1 and us-west-2 regions', () => {
    expect(regions).toContain('us-east-1');
    expect(regions).toContain('us-west-2');
    expect(regions).toHaveLength(2);
  });

  // Loop through each region defined in the output file and run a dedicated suite of tests
  for (const region of regions) {
    describe(`Region: ${region}`, () => {
      const regionOutputs = outputs[region];
      const ec2Client = new EC2Client({ region });
      const kmsClient = new KMSClient({ region });
      const s3Client = new S3Client({ region });
      const configClient = new ConfigServiceClient({ region });

      test(
        'KMS Key should be correctly configured with a 10-day deletion window and proper alias',
        async () => {
          // 1. Check the key itself
          const keyData = await retry(() =>
            kmsClient.send(
              new DescribeKeyCommand({ KeyId: regionOutputs.kms_key_arn })
            )
          );
          expect(keyData.KeyMetadata).toBeDefined();
          expect(keyData.KeyMetadata?.DeletionDate).toBeUndefined(); // It should not be pending deletion
          expect(keyData.KeyMetadata?.KeyState).toBe('Enabled');

          // Verify the deletion window is set to 10 days (this is set during key creation)
          // Note: We can't directly check this after creation, but we verify the key is not scheduled for deletion

          // 2. Check the alias
          const aliasData = await retry(() =>
            kmsClient.send(
              new ListAliasesCommand({ KeyId: regionOutputs.kms_key_arn })
            )
          );
          const expectedAlias = 'alias/nova-app-key';
          const alias = aliasData.Aliases?.find(
            a => a.AliasName === expectedAlias
          );
          expect(alias).toBeDefined();
          expect(alias?.TargetKeyId).toBe(keyData.KeyMetadata?.KeyId);
        },
        TEST_TIMEOUT
      );

      test(
        'S3 Bucket should enforce KMS encryption and block all public access',
        async () => {
          // 1. Check Server-Side Encryption
          const encryptionData = await retry(() =>
            s3Client.send(
              new GetBucketEncryptionCommand({
                Bucket: regionOutputs.s3_bucket_name,
              })
            )
          );
          const sseRule =
            encryptionData.ServerSideEncryptionConfiguration?.Rules?.[0];
          expect(
            sseRule?.ApplyServerSideEncryptionByDefault?.SSEAlgorithm
          ).toBe('aws:kms');
          expect(
            sseRule?.ApplyServerSideEncryptionByDefault?.KMSMasterKeyID
          ).toBe(regionOutputs.kms_key_arn);

          // 2. Check Public Access Block
          const pabData = await retry(() =>
            s3Client.send(
              new GetPublicAccessBlockCommand({
                Bucket: regionOutputs.s3_bucket_name,
              })
            )
          );
          expect(pabData.PublicAccessBlockConfiguration?.BlockPublicAcls).toBe(
            true
          );
          expect(
            pabData.PublicAccessBlockConfiguration?.BlockPublicPolicy
          ).toBe(true);
          expect(pabData.PublicAccessBlockConfiguration?.IgnorePublicAcls).toBe(
            true
          );
          expect(
            pabData.PublicAccessBlockConfiguration?.RestrictPublicBuckets
          ).toBe(true);
        },
        TEST_TIMEOUT
      );

      test(
        'EC2 Instance should be a t3.micro, have an encrypted root volume, and an IAM profile',
        async () => {
          const instanceData = await retry(() =>
            ec2Client.send(
              new DescribeInstancesCommand({
                InstanceIds: [regionOutputs.ec2_instance_id],
              })
            )
          );
          const instance: Instance | undefined =
            instanceData.Reservations?.[0]?.Instances?.[0];
          expect(instance).toBeDefined();

          // 1. Check basic instance properties
          expect(instance?.InstanceType).toBe('t3.micro');
          expect(instance?.State?.Name).toBe('running');

          // 2. Check for IAM Instance Profile
          expect(instance?.IamInstanceProfile?.Arn).toContain(
            'nova-ec2-instance-profile'
          );

          // 3. Check for encrypted root volume
          const rootDeviceName = instance?.RootDeviceName;
          expect(rootDeviceName).toBeDefined();
          const rootVolume = instance?.BlockDeviceMappings?.find(
            bdm => bdm.DeviceName === rootDeviceName
          );
          expect(rootVolume?.Ebs?.VolumeId).toBeDefined();

          // Verify root volume encryption
          if (rootVolume?.Ebs?.VolumeId) {
            const volumeData = await retry(() =>
              ec2Client.send(
                new DescribeVolumesCommand({
                  VolumeIds: [rootVolume.Ebs!.VolumeId!],
                })
              )
            );
            const volume = volumeData.Volumes?.[0];
            expect(volume?.Encrypted).toBe(true);
            expect(volume?.KmsKeyId).toContain(
              regionOutputs.kms_key_arn.split('/').pop()
            );
          }

          // 4. Verify instance tags
          const tags = instance?.Tags || [];
          const nameTag = tags.find(t => t.Key === 'Name');
          expect(nameTag?.Value).toBe(`nova-app-server-${region}`);
          const ownerTag = tags.find(t => t.Key === 'Owner');
          expect(ownerTag?.Value).toBe('nova-devops-team');
          const purposeTag = tags.find(t => t.Key === 'Purpose');
          expect(purposeTag?.Value).toBe('Nova Application Baseline');
        },
        TEST_TIMEOUT
      );

      test(
        'AWS Config rules for compliance should be deployed',
        async () => {
          const expectedRules = [
            'S3_BUCKET_SERVER_SIDE_ENCRYPTION_ENABLED',
            'ENCRYPTED_VOLUMES',
            'IAM_ROLE_MANAGED_POLICY_CHECK',
          ];

          // Get all Config rules in the region
          const rulesData = await retry(() =>
            configClient.send(new DescribeConfigRulesCommand({}))
          );

          const deployedRuleNames =
            rulesData.ConfigRules?.map(r => r.ConfigRuleName) || [];

          // Check that all expected rules are present
          for (const expectedRule of expectedRules) {
            expect(deployedRuleNames).toContain(expectedRule);
          }

          // Verify the rules are properly configured
          const relevantRules =
            rulesData.ConfigRules?.filter(r =>
              expectedRules.includes(r.ConfigRuleName || '')
            ) || [];

          expect(relevantRules).toHaveLength(expectedRules.length);

          // Verify each rule is active and properly sourced
          for (const rule of relevantRules) {
            expect(rule.ConfigRuleState).not.toBe('DELETING');
            expect(rule.Source?.Owner).toBe('AWS');
            expect(rule.Source?.SourceIdentifier).toBe(rule.ConfigRuleName);
          }
        },
        TEST_TIMEOUT
      );

      test(
        'Config S3 bucket should exist for storing configuration history',
        async () => {
          const configBucketName = `nova-config-bucket-${outputs[region].s3_bucket_name.split('-')[3]}-${region}`;

          // Try to get the bucket encryption (this will fail if bucket doesn't exist)
          try {
            const encryptionData = await retry(() =>
              s3Client.send(
                new GetBucketEncryptionCommand({
                  Bucket: configBucketName,
                })
              )
            );
            // Config bucket should exist (no specific encryption requirement for Config bucket)
            expect(encryptionData).toBeDefined();
          } catch (error: any) {
            // If the bucket doesn't exist, this test should fail
            if (error.name === 'NoSuchBucket') {
              throw new Error(
                `Config bucket ${configBucketName} does not exist`
              );
            }
            // For other errors, we might have permission issues but bucket exists
            console.warn(
              `Could not fully verify Config bucket ${configBucketName}: ${error.message}`
            );
          }
        },
        TEST_TIMEOUT
      );
    });
  }

  describe('Cross-Region Validation', () => {
    test('IAM role should be accessible from both regions', async () => {
      // IAM is global, so we can check from any region
      const ec2ClientEast = new EC2Client({ region: 'us-east-1' });
      const ec2ClientWest = new EC2Client({ region: 'us-west-2' });

      // Check that instances in both regions have the same IAM instance profile
      const instanceDataEast = await retry(() =>
        ec2ClientEast.send(
          new DescribeInstancesCommand({
            InstanceIds: [outputs['us-east-1'].ec2_instance_id],
          })
        )
      );

      const instanceDataWest = await retry(() =>
        ec2ClientWest.send(
          new DescribeInstancesCommand({
            InstanceIds: [outputs['us-west-2'].ec2_instance_id],
          })
        )
      );

      const profileEast =
        instanceDataEast.Reservations?.[0]?.Instances?.[0]?.IamInstanceProfile
          ?.Arn;
      const profileWest =
        instanceDataWest.Reservations?.[0]?.Instances?.[0]?.IamInstanceProfile
          ?.Arn;

      // Both should have the same IAM instance profile (different ARN but same profile name)
      expect(profileEast).toContain('nova-ec2-instance-profile');
      expect(profileWest).toContain('nova-ec2-instance-profile');
    });

    test('All resources should have consistent tagging across regions', async () => {
      for (const region of regions) {
        const ec2Client = new EC2Client({ region });
        const kmsClient = new KMSClient({ region });

        // Check EC2 instance tags
        const instanceData = await retry(() =>
          ec2Client.send(
            new DescribeInstancesCommand({
              InstanceIds: [outputs[region].ec2_instance_id],
            })
          )
        );
        const instanceTags =
          instanceData.Reservations?.[0]?.Instances?.[0]?.Tags || [];
        const ownerTag = instanceTags.find(t => t.Key === 'Owner');
        const purposeTag = instanceTags.find(t => t.Key === 'Purpose');

        expect(ownerTag?.Value).toBe('nova-devops-team');
        expect(purposeTag?.Value).toBe('Nova Application Baseline');
      }
    });
  });
});
