import * as fs from 'fs';
import * as path from 'path';
import {
  EC2Client,
  DescribeInstancesCommand,
  Instance,
} from '@aws-sdk/client-ec2';
import {
  KMSClient,
  DescribeKeyCommand,
  ListAliasesCommand,
} from '@aws-sdk/client-kms';
import {
  S3Client,
  GetBucketEncryptionCommand,
  GetPublicAccessBlockCommand,
} from '@aws-sdk/client-s3';
import {
  ConfigServiceClient,
  DescribeConfigRulesCommand,
} from '@aws-sdk/client-config-service';

/* ----------------------------- Utilities & Types ----------------------------- */

// Type definition for the structure of the Terraform output JSON
type TfOutputValue<T> = { sensitive: boolean; type: any; value: T };
type DeploymentSummary = {
  [region: string]: {
    s3_bucket_name: string;
    ec2_instance_id: string;
    kms_key_arn: string;
  };
};
type StructuredOutputs = {
  deployment_summary: TfOutputValue<DeploymentSummary>;
};

/**
 * Reads and validates the structured outputs from the CI/CD pipeline.
 * @returns The parsed and validated deployment summary.
 */
function readDeploymentOutputs(): DeploymentSummary {
  const filePath = path.resolve(process.cwd(), 'cfn-outputs/all-outputs.json');
  if (!fs.existsSync(filePath)) {
    throw new Error(
      `Outputs file not found at ${filePath}. This file must be generated by the CI/CD 'Get Deployment Outputs' stage.`
    );
  }
  const outputs = JSON.parse(
    fs.readFileSync(filePath, 'utf8')
  ) as StructuredOutputs;

  const summary = outputs.deployment_summary?.value;
  if (!summary) {
    throw new Error('`deployment_summary` missing in outputs file.');
  }

  // Validate that expected regions and their properties exist
  for (const region of ['us-east-1', 'us-west-2']) {
    if (
      !summary[region]?.s3_bucket_name ||
      !summary[region]?.ec2_instance_id ||
      !summary[region]?.kms_key_arn
    ) {
      throw new Error(
        `Output for region '${region}' is incomplete. Check s3_bucket_name, ec2_instance_id, and kms_key_arn.`
      );
    }
  }

  return summary;
}

/**
 * A simple retry mechanism for eventually consistent AWS API calls.
 */
async function retry<T>(
  fn: () => Promise<T>,
  attempts = 5,
  delayMs = 2000
): Promise<T> {
  let lastError: any;
  for (let i = 0; i < attempts; i++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error;
      await new Promise(resolve => setTimeout(resolve, delayMs * (i + 1)));
    }
  }
  throw lastError;
}

/* ----------------------------- Test Suite ----------------------------- */

describe('LIVE: Multi-Region AWS Infrastructure Integration Tests', () => {
  const outputs = readDeploymentOutputs();
  const regions = Object.keys(outputs);
  const TEST_TIMEOUT = 120_000;

  // Loop through each region defined in the output file and run a dedicated suite of tests
  for (const region of regions) {
    describe(`Region: ${region}`, () => {
      const regionOutputs = outputs[region];
      const ec2Client = new EC2Client({ region });
      const kmsClient = new KMSClient({ region });
      const s3Client = new S3Client({ region });
      const configClient = new ConfigServiceClient({ region });

      test(
        'KMS Key should be correctly configured with a 10-day deletion window and proper alias',
        async () => {
          // 1. Check the key itself
          const keyData = await retry(() =>
            kmsClient.send(
              new DescribeKeyCommand({ KeyId: regionOutputs.kms_key_arn })
            )
          );
          expect(keyData.KeyMetadata).toBeDefined();
          expect(keyData.KeyMetadata?.DeletionDate).toBeUndefined(); // It should not be pending deletion
          expect(keyData.KeyMetadata?.KeyState).toBe('Enabled');

          // 2. Check the alias
          const aliasData = await retry(() =>
            kmsClient.send(
              new ListAliasesCommand({ KeyId: regionOutputs.kms_key_arn })
            )
          );
          const expectedAlias = 'alias/nova-app-key';
          const alias = aliasData.Aliases?.find(
            a => a.AliasName === expectedAlias
          );
          expect(alias).toBeDefined();
          expect(alias?.TargetKeyId).toBe(keyData.KeyMetadata?.KeyId);
        },
        TEST_TIMEOUT
      );

      test(
        'S3 Bucket should enforce KMS encryption and block all public access',
        async () => {
          // 1. Check Server-Side Encryption
          const encryptionData = await retry(() =>
            s3Client.send(
              new GetBucketEncryptionCommand({
                Bucket: regionOutputs.s3_bucket_name,
              })
            )
          );
          const sseRule =
            encryptionData.ServerSideEncryptionConfiguration?.Rules?.[0];
          expect(
            sseRule?.ApplyServerSideEncryptionByDefault?.SSEAlgorithm
          ).toBe('aws:kms');
          expect(
            sseRule?.ApplyServerSideEncryptionByDefault?.KMSMasterKeyID
          ).toBe(regionOutputs.kms_key_arn);

          // 2. Check Public Access Block
          const pabData = await retry(() =>
            s3Client.send(
              new GetPublicAccessBlockCommand({
                Bucket: regionOutputs.s3_bucket_name,
              })
            )
          );
          expect(pabData.PublicAccessBlockConfiguration?.BlockPublicAcls).toBe(
            true
          );
          expect(
            pabData.PublicAccessBlockConfiguration?.BlockPublicPolicy
          ).toBe(true);
          expect(pabData.PublicAccessBlockConfiguration?.IgnorePublicAcls).toBe(
            true
          );
          expect(
            pabData.PublicAccessBlockConfiguration?.RestrictPublicBuckets
          ).toBe(true);
        },
        TEST_TIMEOUT
      );

      test(
        'EC2 Instance should be a t3.micro, have an encrypted root volume, and an IAM profile',
        async () => {
          const instanceData = await retry(() =>
            ec2Client.send(
              new DescribeInstancesCommand({
                InstanceIds: [regionOutputs.ec2_instance_id],
              })
            )
          );
          const instance: Instance | undefined =
            instanceData.Reservations?.[0]?.Instances?.[0];
          expect(instance).toBeDefined();

          // 1. Check basic instance properties
          expect(instance?.InstanceType).toBe('t3.micro');
          expect(instance?.State?.Name).toBe('running');

          // 2. Check for IAM Instance Profile
          expect(instance?.IamInstanceProfile?.Arn).toContain(
            'nova-ec2-instance-profile'
          );

          // 3. Check for encrypted root volume
          const rootDeviceName = instance?.RootDeviceName;
          expect(rootDeviceName).toBeDefined();
          const rootVolume = instance?.BlockDeviceMappings?.find(
            bdm => bdm.DeviceName === rootDeviceName
          );
          expect(rootVolume?.Ebs?.VolumeId).toBeDefined();
        },
        TEST_TIMEOUT
      );

      test(
        'AWS Config rules for compliance should be deployed',
        async () => {
          const expectedRules = [
            'S3_BUCKET_SERVER_SIDE_ENCRYPTION_ENABLED',
            'ENCRYPTED_VOLUMES',
            'IAM_ROLE_MANAGED_POLICY_CHECK',
          ];
          const rulesData = await retry(() =>
            configClient.send(
              new DescribeConfigRulesCommand({ ConfigRuleNames: expectedRules })
            )
          );
          const deployedRuleNames =
            rulesData.ConfigRules?.map(r => r.ConfigRuleName) || [];
          expect(deployedRuleNames).toHaveLength(expectedRules.length);
          expect(deployedRuleNames).toEqual(
            expect.arrayContaining(expectedRules)
          );
        },
        TEST_TIMEOUT
      );
    });
  }
});
