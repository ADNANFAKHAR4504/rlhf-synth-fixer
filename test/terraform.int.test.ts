import * as fs from 'fs';
import * as path from 'path';
import {
  EC2Client,
  DescribeLaunchTemplateVersionsCommand,
  LaunchTemplateVersion,
} from '@aws-sdk/client-ec2';
import {
  AutoScalingClient,
  DescribeAutoScalingGroupsCommand,
} from '@aws-sdk/client-auto-scaling';
import {
  ElasticLoadBalancingV2Client,
  DescribeLoadBalancersCommand,
  DescribeLoadBalancersCommandOutput,
} from '@aws-sdk/client-elastic-load-balancing-v2';
import { RDSClient, DescribeDBInstancesCommand } from '@aws-sdk/client-rds';
import { S3Client, GetBucketVersioningCommand } from '@aws-sdk/client-s3';
import {
  LambdaClient,
  GetFunctionConfigurationCommand,
  GetFunctionConfigurationCommandOutput,
} from '@aws-sdk/client-lambda';
import {
  EventBridgeClient,
  DescribeRuleCommand,
  ListTargetsByRuleCommand,
} from '@aws-sdk/client-eventbridge';
import {
  Route53Client,
  ListResourceRecordSetsCommand,
  ListHostedZonesByNameCommand,
  HostedZone,
} from '@aws-sdk/client-route-53';

/* ----------------------------- Utilities & Types ----------------------------- */

type TfOutputValue = { sensitive: boolean; type: string; value: string };
type StructuredOutputs = {
  primary_alb_dns: TfOutputValue;
  secondary_alb_dns: TfOutputValue;
  rds_endpoint: TfOutputValue;
  s3_bucket_name: TfOutputValue;
  application_url: TfOutputValue;
};

function readDeploymentOutputs(): Record<string, string> {
  const filePath = path.resolve(process.cwd(), 'cfn-outputs/all-outputs.json');
  if (!fs.existsSync(filePath)) {
    throw new Error(
      `Outputs file not found at ${filePath}. This file must be generated by the CI/CD 'Get Deployment Outputs' stage.`
    );
  }
  const outputs = JSON.parse(
    fs.readFileSync(filePath, 'utf8')
  ) as StructuredOutputs;

  const extractedValues: Record<string, string> = {};
  for (const key in outputs) {
    if (outputs[key as keyof StructuredOutputs]?.value) {
      extractedValues[key] = outputs[key as keyof StructuredOutputs].value;
    } else {
      throw new Error(
        `Output key '${key}' is missing or invalid in the outputs file.`
      );
    }
  }
  return extractedValues;
}

async function retry<T>(
  fn: () => Promise<T>,
  attempts = 5,
  delayMs = 2000
): Promise<T> {
  let lastError: any;
  for (let i = 0; i < attempts; i++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error;
      await new Promise(resolve => setTimeout(resolve, delayMs * (i + 1)));
    }
  }
  throw lastError;
}

/* ----------------------------- Test Suite ----------------------------- */

describe('LIVE: Multi-Region Infrastructure Integration Tests', () => {
  const outputs = readDeploymentOutputs();
  const primaryRegion = 'us-east-1';
  const secondaryRegion = 'us-west-2';
  const SUFFIX = '291295';
  const TEST_TIMEOUT = 180_000;
  jest.setTimeout(TEST_TIMEOUT);

  describe(`Region: Primary (${primaryRegion})`, () => {
    const ec2Client = new EC2Client({ region: primaryRegion });
    const asClient = new AutoScalingClient({ region: primaryRegion });
    const elbClient = new ElasticLoadBalancingV2Client({
      region: primaryRegion,
    });
    const rdsClient = new RDSClient({ region: primaryRegion });
    const lambdaClient = new LambdaClient({ region: primaryRegion });
    const eventsClient = new EventBridgeClient({ region: primaryRegion });

    it('should have a correctly configured Application Load Balancer', async () => {
      const { LoadBalancers } = (await retry(() =>
        elbClient.send(
          new DescribeLoadBalancersCommand({
            Names: [`alb-app-primary-${SUFFIX}`],
          })
        )
      )) as DescribeLoadBalancersCommandOutput;
      const alb = LoadBalancers?.[0];
      expect(alb).toBeDefined();
      expect(alb?.DNSName).toEqual(outputs.primary_alb_dns);
    });

    it('should have a correctly configured Auto Scaling Group and Launch Template', async () => {
      const { AutoScalingGroups } = await retry(() =>
        asClient.send(
          new DescribeAutoScalingGroupsCommand({
            AutoScalingGroupNames: [`asg-app-primary-${SUFFIX}`],
          })
        )
      );
      const asg = AutoScalingGroups?.[0];
      expect(asg).toBeDefined();
      expect(asg?.LaunchTemplate).toBeDefined();

      const { LaunchTemplateVersions } = await ec2Client.send(
        new DescribeLaunchTemplateVersionsCommand({
          LaunchTemplateId: asg!.LaunchTemplate!.LaunchTemplateId!,
        })
      );
      const defaultVersion = LaunchTemplateVersions?.find(
        v => v.DefaultVersion
      ) as LaunchTemplateVersion;
      expect(defaultVersion).toBeDefined();
      const ebsConfig =
        defaultVersion.LaunchTemplateData?.BlockDeviceMappings?.[0].Ebs;
      expect(ebsConfig?.Encrypted).toBe(true);
    });

    it('should have a secure, Multi-AZ RDS PostgreSQL instance', async () => {
      const { DBInstances } = await retry(() =>
        rdsClient.send(
          new DescribeDBInstancesCommand({
            DBInstanceIdentifier: `rds-postgres-primary-db-${SUFFIX}`,
          })
        )
      );
      const rds = DBInstances?.[0];
      expect(rds).toBeDefined();
      expect(rds?.MultiAZ).toBe(true);
    });

    it('should have a cost-saving Lambda function triggered by a CloudWatch Event rule', async () => {
      const configuration = (await retry(() =>
        lambdaClient.send(
          new GetFunctionConfigurationCommand({
            FunctionName: `lambda-cost-saver-nova-${SUFFIX}`,
          })
        )
      )) as GetFunctionConfigurationCommandOutput;
      expect(configuration).toBeDefined();

      const rule = await eventsClient.send(
        new DescribeRuleCommand({
          Name: `rule-daily-resource-shutdown-${SUFFIX}`,
        })
      );
      expect(rule.ScheduleExpression).toBe('cron(0 0 * * ? *)');

      const { Targets } = await eventsClient.send(
        new ListTargetsByRuleCommand({
          Rule: `rule-daily-resource-shutdown-${SUFFIX}`,
        })
      );
      expect(Targets?.[0].Arn).toBe(configuration?.FunctionArn);
    });
  });

  describe(`Region: Secondary (${secondaryRegion})`, () => {
    const asClient = new AutoScalingClient({ region: secondaryRegion });
    const elbClient = new ElasticLoadBalancingV2Client({
      region: secondaryRegion,
    });

    it('should have a correctly configured Application Load Balancer', async () => {
      const { LoadBalancers } = (await retry(() =>
        elbClient.send(
          new DescribeLoadBalancersCommand({
            Names: [`alb-app-secondary-${SUFFIX}`],
          })
        )
      )) as DescribeLoadBalancersCommandOutput;
      const alb = LoadBalancers?.[0];
      expect(alb).toBeDefined();
      expect(alb?.DNSName).toEqual(outputs.secondary_alb_dns);
    });
  });

  describe('Global Resources (S3, Route 53)', () => {
    const s3Client = new S3Client({ region: primaryRegion });
    const route53Client = new Route53Client({ region: primaryRegion });

    it('should have a secure S3 bucket with versioning and encryption', async () => {
      const bucketName = outputs.s3_bucket_name;
      const versioning = await retry(() =>
        s3Client.send(new GetBucketVersioningCommand({ Bucket: bucketName }))
      );
      expect(versioning.Status).toBe('Enabled');
    });

    it('should have a Route 53 failover configuration pointing to both ALBs', async () => {
      const appUrl = new URL(outputs.application_url);
      const domainName = appUrl.hostname.split('.').slice(1).join('.');

      const { HostedZones } = await route53Client.send(
        new ListHostedZonesByNameCommand({ DNSName: domainName })
      );
      const zoneId = HostedZones?.find(
        (z: HostedZone) => z.Name === `${domainName}.`
      )?.Id;
      expect(zoneId).toBeDefined();

      const { ResourceRecordSets } = await retry(() =>
        route53Client.send(
          new ListResourceRecordSetsCommand({
            HostedZoneId: zoneId,
            StartRecordName: appUrl.hostname,
            StartRecordType: 'A',
          })
        )
      );

      const records = ResourceRecordSets?.filter(
        r => r.Name === `${appUrl.hostname}.`
      );
      expect(records?.length).toBe(2);

      const primaryRecord = records?.find(r => r.Failover === 'PRIMARY');
      expect(primaryRecord?.AliasTarget?.DNSName).toContain(
        outputs.primary_alb_dns
      );
    });
  });
});
