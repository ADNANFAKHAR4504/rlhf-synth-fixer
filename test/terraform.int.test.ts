/**
 * AWS Secure Infrastructure Project - Integration Tests
 * 
 * These tests validate the deployed infrastructure using real AWS resources
 * by reading from the outputs file generated by CI/CD pipeline deployment.
 */

import {
  DescribeSecurityGroupsCommand,
  DescribeSubnetsCommand,
  DescribeVpcsCommand,
  EC2Client,
  DescribeNatGatewaysCommand
} from '@aws-sdk/client-ec2';
import {
  DescribeLoadBalancersCommand,
  DescribeTargetGroupsCommand,
  ElasticLoadBalancingV2Client
} from '@aws-sdk/client-elastic-load-balancing-v2';
import {
  DescribeDBInstancesCommand,
  RDSClient
} from '@aws-sdk/client-rds';
import {
  GetBucketEncryptionCommand,
  GetBucketVersioningCommand,
  GetPublicAccessBlockCommand,
  S3Client
} from '@aws-sdk/client-s3';
import {
  DescribeClusterCommand,
  DescribeNodegroupCommand,
  EKSClient
} from '@aws-sdk/client-eks';
import {
  DescribeTrailsCommand,
  CloudTrailClient
} from '@aws-sdk/client-cloudtrail';
import {
  GetPipelineCommand,
  CodePipelineClient
} from '@aws-sdk/client-codepipeline';
import {
  BatchGetProjectsCommand,
  CodeBuildClient
} from '@aws-sdk/client-codebuild';
import {
  DescribeKeyCommand,
  KMSClient
} from '@aws-sdk/client-kms';
import * as fs from "fs";
import * as path from "path";

/** ===================== Types & IO ===================== */

type TfValue<T> = { sensitive: boolean; type: any; value: T };

type Outputs = {
  aws_region?: TfValue<string>;
  vpc_id?: TfValue<string>;
  vpc_cidr?: TfValue<string>;
  public_subnet_ids?: TfValue<string[]>;
  private_subnet_ids?: TfValue<string[]>;
  eks_cluster_id?: TfValue<string>;
  eks_cluster_name?: TfValue<string>;
  eks_cluster_arn?: TfValue<string>;
  eks_cluster_endpoint?: TfValue<string>;
  eks_cluster_version?: TfValue<string>;
  eks_node_group_name?: TfValue<string>;
  rds_endpoint?: TfValue<string>;
  rds_instance_id?: TfValue<string>;
  rds_port?: TfValue<number>;
  alb_dns_name?: TfValue<string>;
  alb_zone_id?: TfValue<string>;
  alb_target_group_arn?: TfValue<string>;
  kms_key_id?: TfValue<string>;
  kms_key_arn?: TfValue<string>;
  cloudtrail_arn?: TfValue<string>;
  codepipeline_name?: TfValue<string>;
  codebuild_project_name?: TfValue<string>;
  s3_alb_logs_bucket?: TfValue<string>;
  s3_codepipeline_artifacts_bucket?: TfValue<string>;
  s3_cloudtrail_bucket?: TfValue<string>;
  nginx_service_endpoint?: TfValue<string>;
};

const outputsPath = path.resolve(process.cwd(), "cfn-outputs/all-outputs.json");

function loadOutputs(): Outputs {
  if (!fs.existsSync(outputsPath)) {
    throw new Error(`Outputs file not found at ${outputsPath}. Please ensure CI/CD pipeline has run and created the outputs file.`);
  }
  const raw = fs.readFileSync(outputsPath, "utf8");
  return JSON.parse(raw) as Outputs;
}

/** ===================== Test Suite ===================== */

describe("AWS Secure Infrastructure Integration Tests", () => {
  let outputs: Outputs;
  let awsRegion: string;
  let ec2Client: EC2Client;
  let elbv2Client: ElasticLoadBalancingV2Client;
  let rdsClient: RDSClient;
  let s3Client: S3Client;
  let eksClient: EKSClient;
  let cloudTrailClient: CloudTrailClient;
  let codePipelineClient: CodePipelineClient;
  let codeBuildClient: CodeBuildClient;
  let kmsClient: KMSClient;

  beforeAll(async () => {
    outputs = loadOutputs();
    awsRegion = outputs.aws_region?.value || 'us-west-2';
    
    // Initialize AWS clients for the deployed region
    ec2Client = new EC2Client({ region: awsRegion });
    elbv2Client = new ElasticLoadBalancingV2Client({ region: awsRegion });
    rdsClient = new RDSClient({ region: awsRegion });
    s3Client = new S3Client({ region: awsRegion });
    eksClient = new EKSClient({ region: awsRegion });
    cloudTrailClient = new CloudTrailClient({ region: awsRegion });
    codePipelineClient = new CodePipelineClient({ region: awsRegion });
    codeBuildClient = new CodeBuildClient({ region: awsRegion });
    kmsClient = new KMSClient({ region: awsRegion });
  });

  afterAll(async () => {
    // Clean up AWS clients
    ec2Client.destroy();
    elbv2Client.destroy();
    rdsClient.destroy();
    s3Client.destroy();
    eksClient.destroy();
    cloudTrailClient.destroy();
    codePipelineClient.destroy();
    codeBuildClient.destroy();
    kmsClient.destroy();
  });

  describe("1. Infrastructure Outputs Validation", () => {
    test("All required outputs are present", () => {
      const requiredOutputs = [
        'aws_region', 'vpc_id', 'eks_cluster_name', 'eks_cluster_endpoint',
        'alb_dns_name', 'rds_endpoint', 'kms_key_arn', 'codepipeline_name'
      ];
      
      requiredOutputs.forEach(outputName => {
        expect(outputs[outputName as keyof Outputs]).toBeDefined();
        expect(outputs[outputName as keyof Outputs]?.value).toBeTruthy();
      });
    });

    test("Region is set to us-west-2", () => {
      expect(outputs.aws_region?.value).toBe('us-west-2');
    });

    test("Sensitive outputs are properly marked", () => {
      expect(outputs.rds_endpoint?.sensitive).toBe(true);
    });
  });

  describe("2. VPC and Networking Validation", () => {
    test("VPC exists and has correct configuration", async () => {
      const vpcId = outputs.vpc_id?.value;
      expect(vpcId).toBeTruthy();

      const response = await ec2Client.send(new DescribeVpcsCommand({
        VpcIds: [vpcId!]
      }));

      expect(response.Vpcs).toHaveLength(1);
      const vpc = response.Vpcs![0];
      expect(vpc.State).toBe('available');
      expect(vpc.CidrBlock).toBe(outputs.vpc_cidr?.value || '10.0.0.0/16');
      expect(vpc.DhcpOptionsId).toBeTruthy();
      expect(vpc.InstanceTenancy).toBe('default');
    });

    test("Public subnets are configured correctly", async () => {
      const subnetIds = outputs.public_subnet_ids?.value || [];
      expect(subnetIds.length).toBeGreaterThanOrEqual(2);

      const response = await ec2Client.send(new DescribeSubnetsCommand({
        SubnetIds: subnetIds
      }));

      expect(response.Subnets).toHaveLength(subnetIds.length);
      response.Subnets?.forEach(subnet => {
        expect(subnet.State).toBe('available');
        expect(subnet.MapPublicIpOnLaunch).toBe(true);
        expect(subnet.VpcId).toBe(outputs.vpc_id?.value);
      });
    });

    test("Private subnets are configured correctly", async () => {
      const subnetIds = outputs.private_subnet_ids?.value || [];
      expect(subnetIds.length).toBeGreaterThanOrEqual(2);

      const response = await ec2Client.send(new DescribeSubnetsCommand({
        SubnetIds: subnetIds
      }));

      expect(response.Subnets).toHaveLength(subnetIds.length);
      response.Subnets?.forEach(subnet => {
        expect(subnet.State).toBe('available');
        expect(subnet.MapPublicIpOnLaunch).toBe(false);
        expect(subnet.VpcId).toBe(outputs.vpc_id?.value);
      });
    });

    test("NAT Gateways are deployed in public subnets", async () => {
      const vpcId = outputs.vpc_id?.value;
      const response = await ec2Client.send(new DescribeNatGatewaysCommand({
        Filter: [{ Name: 'vpc-id', Values: [vpcId!] }]
      }));

      expect(response.NatGateways).toBeTruthy();
      expect(response.NatGateways!.length).toBeGreaterThan(0);
      
      response.NatGateways?.forEach(nat => {
        expect(nat.State).toBe('available');
        expect(nat.VpcId).toBe(vpcId);
      });
    });
  });

  describe("3. Security Groups Validation", () => {
    test("Security groups follow least privilege principles", async () => {
      const vpcId = outputs.vpc_id?.value;
      const response = await ec2Client.send(new DescribeSecurityGroupsCommand({
        Filters: [{ Name: 'vpc-id', Values: [vpcId!] }]
      }));

      const securityGroups = response.SecurityGroups || [];
      expect(securityGroups.length).toBeGreaterThan(3);

      // Find ALB security group
      const albSg = securityGroups.find(sg => 
        sg.GroupName?.includes('alb') || sg.Description?.includes('ALB') || sg.Description?.includes('load balancer')
      );
      expect(albSg).toBeTruthy();
      
      // ALB should allow HTTP/HTTPS from internet
      const httpRule = albSg?.IpPermissions?.find(rule => rule.FromPort === 80);
      const httpsRule = albSg?.IpPermissions?.find(rule => rule.FromPort === 443);
      expect(httpRule).toBeTruthy();
      expect(httpsRule).toBeTruthy();

      // Find RDS security group
      const rdsSg = securityGroups.find(sg => 
        sg.GroupName?.includes('rds') || sg.GroupName?.includes('db') || sg.Description?.includes('RDS') || sg.Description?.includes('database')
      );
      expect(rdsSg).toBeTruthy();
      
      // RDS should only allow PostgreSQL port from EKS nodes
      const pgRule = rdsSg?.IpPermissions?.find(rule => rule.FromPort === 5432);
      expect(pgRule).toBeTruthy();
      expect(pgRule?.UserIdGroupPairs?.length).toBeGreaterThan(0);
    });
  });

  describe("4. KMS Key Validation", () => {
    test("KMS key is configured with key rotation", async () => {
      const keyId = outputs.kms_key_id?.value;
      expect(keyId).toBeTruthy();

      const response = await kmsClient.send(new DescribeKeyCommand({
        KeyId: keyId!
      }));

      expect(response.KeyMetadata).toBeTruthy();
      expect(response.KeyMetadata!.KeyState).toBe('Enabled');
      expect(response.KeyMetadata!.KeyUsage).toBe('ENCRYPT_DECRYPT');
      expect(response.KeyMetadata!.MultiRegion).toBe(false);
    });
  });

  describe("5. EKS Cluster Validation", () => {
    test("EKS cluster is running and properly configured", async () => {
      const clusterName = outputs.eks_cluster_name?.value;
      expect(clusterName).toBeTruthy();

      const response = await eksClient.send(new DescribeClusterCommand({
        name: clusterName!
      }));

      expect(response.cluster).toBeTruthy();
      const cluster = response.cluster!;
      
      expect(cluster.status).toBe('ACTIVE');
      expect(cluster.version).toBe(outputs.eks_cluster_version?.value || '1.29');
      expect(cluster.endpoint).toBe(outputs.eks_cluster_endpoint?.value);
      expect(cluster.resourcesVpcConfig?.vpcId).toBe(outputs.vpc_id?.value);
      expect(cluster.resourcesVpcConfig?.endpointPrivateAccess).toBe(true);
      expect(cluster.resourcesVpcConfig?.endpointPublicAccess).toBe(true);
      expect(cluster.encryptionConfig).toBeTruthy();
      expect(cluster.logging?.clusterLogging?.some((log: any) => log.enabled === true)).toBe(true);
    });

    test("EKS node group is active and properly scaled", async () => {
      const clusterName = outputs.eks_cluster_name?.value;
      const nodeGroupName = outputs.eks_node_group_name?.value;
      
      const response = await eksClient.send(new DescribeNodegroupCommand({
        clusterName: clusterName!,
        nodegroupName: nodeGroupName!
      }));

      expect(response.nodegroup).toBeTruthy();
      const nodeGroup = response.nodegroup!;
      
      expect(nodeGroup.status).toBe('ACTIVE');
      expect(nodeGroup.capacityType).toBe('ON_DEMAND');
      expect(nodeGroup.instanceTypes).toContain('t3.medium');
      expect(nodeGroup.scalingConfig?.minSize).toBe(1);
      expect(nodeGroup.scalingConfig?.maxSize).toBe(2);
      expect(nodeGroup.scalingConfig?.desiredSize).toBe(1);
      expect(nodeGroup.subnets).toEqual(expect.arrayContaining(outputs.private_subnet_ids?.value || []));
    });
  });

  describe("6. RDS Database Validation", () => {
    test("RDS PostgreSQL instance is available and secure", async () => {
      const instanceId = outputs.rds_instance_id?.value;
      expect(instanceId).toBeTruthy();

      const response = await rdsClient.send(new DescribeDBInstancesCommand({
        DBInstanceIdentifier: instanceId!
      }));

      expect(response.DBInstances).toHaveLength(1);
      const dbInstance = response.DBInstances![0];
      
      expect(dbInstance.DBInstanceStatus).toBe('available');
      expect(dbInstance.Engine).toBe('postgres');
      expect(dbInstance.EngineVersion).toMatch(/^15\.8/);
      expect(dbInstance.DBInstanceClass).toBe('db.t3.micro');
      expect(dbInstance.StorageEncrypted).toBe(true);
      expect(dbInstance.MultiAZ).toBe(true);
      expect(dbInstance.PubliclyAccessible).toBe(false);
      expect(dbInstance.VpcSecurityGroups?.some(sg => sg.Status === 'active')).toBe(true);
    });
  });

  describe("7. Load Balancer Validation", () => {
    test("Application Load Balancer is active and accessible", async () => {
      const albDnsName = outputs.alb_dns_name?.value;
      expect(albDnsName).toBeTruthy();

      const response = await elbv2Client.send(new DescribeLoadBalancersCommand({
        Names: [albDnsName!.split('.')[0]] // Extract ALB name from DNS
      }));

      expect(response.LoadBalancers).toHaveLength(1);
      const alb = response.LoadBalancers![0];
      
      expect(alb.State?.Code).toBe('active');
      expect(alb.Type).toBe('application');
      expect(alb.Scheme).toBe('internet-facing');
      expect(alb.VpcId).toBe(outputs.vpc_id?.value);
      expect(alb.AvailabilityZones?.length).toBeGreaterThanOrEqual(2);
    });

    test("Target group is healthy", async () => {
      const targetGroupArn = outputs.alb_target_group_arn?.value;
      expect(targetGroupArn).toBeTruthy();

      const response = await elbv2Client.send(new DescribeTargetGroupsCommand({
        TargetGroupArns: [targetGroupArn!]
      }));

      expect(response.TargetGroups).toHaveLength(1);
      const targetGroup = response.TargetGroups![0];
      
      expect(targetGroup.Protocol).toBe('HTTP');
      expect(targetGroup.Port).toBe(80);
      expect(targetGroup.VpcId).toBe(outputs.vpc_id?.value);
      expect(targetGroup.HealthCheckPath).toBe('/');
    });
  });

  describe("8. S3 Buckets Security Validation", () => {
    test("S3 buckets have encryption enabled", async () => {
      const buckets = [
        outputs.s3_alb_logs_bucket?.value,
        outputs.s3_codepipeline_artifacts_bucket?.value,
        outputs.s3_cloudtrail_bucket?.value
      ].filter(Boolean);

      expect(buckets.length).toBeGreaterThan(0);

      for (const bucketName of buckets) {
        const encryptionResponse = await s3Client.send(new GetBucketEncryptionCommand({
          Bucket: bucketName!
        }));

        expect(encryptionResponse.ServerSideEncryptionConfiguration).toBeTruthy();
        const rule = encryptionResponse.ServerSideEncryptionConfiguration!.Rules![0];
        expect(rule.ApplyServerSideEncryptionByDefault?.SSEAlgorithm).toBe('aws:kms');
        expect(rule.ApplyServerSideEncryptionByDefault?.KMSMasterKeyID).toBeTruthy();
      }
    });

    test("S3 buckets have versioning enabled", async () => {
      const buckets = [
        outputs.s3_alb_logs_bucket?.value,
        outputs.s3_codepipeline_artifacts_bucket?.value,
        outputs.s3_cloudtrail_bucket?.value
      ].filter(Boolean);

      for (const bucketName of buckets) {
        const versioningResponse = await s3Client.send(new GetBucketVersioningCommand({
          Bucket: bucketName!
        }));

        expect(versioningResponse.Status).toBe('Enabled');
      }
    });

    test("S3 buckets have public access blocked", async () => {
      const buckets = [
        outputs.s3_alb_logs_bucket?.value,
        outputs.s3_codepipeline_artifacts_bucket?.value,
        outputs.s3_cloudtrail_bucket?.value
      ].filter(Boolean);

      for (const bucketName of buckets) {
        const publicAccessResponse = await s3Client.send(new GetPublicAccessBlockCommand({
          Bucket: bucketName!
        }));

        const config = publicAccessResponse.PublicAccessBlockConfiguration!;
        expect(config.BlockPublicAcls).toBe(true);
        expect(config.BlockPublicPolicy).toBe(true);
        expect(config.IgnorePublicAcls).toBe(true);
        expect(config.RestrictPublicBuckets).toBe(true);
      }
    });
  });

  describe("9. CloudTrail Validation", () => {
    test("CloudTrail is active and logging", async () => {
      const trailArn = outputs.cloudtrail_arn?.value;
      expect(trailArn).toBeTruthy();

      const trailName = trailArn!.split('/').pop();
      const response = await cloudTrailClient.send(new DescribeTrailsCommand({
        trailNameList: [trailName!]
      }));

      expect(response.trailList).toHaveLength(1);
      const trail = response.trailList![0];
      
      expect((trail as any).IsLogging).toBe(true);
      expect(trail.S3BucketName).toBe(outputs.s3_cloudtrail_bucket?.value);
      expect(trail.KmsKeyId).toBeTruthy();
      expect(trail.IncludeGlobalServiceEvents).toBe(true);
    });
  });

  describe("10. CI/CD Pipeline Validation", () => {
    test("CodePipeline exists and is configured", async () => {
      const pipelineName = outputs.codepipeline_name?.value;
      expect(pipelineName).toBeTruthy();

      const response = await codePipelineClient.send(new GetPipelineCommand({
        name: pipelineName!
      }));

      expect(response.pipeline).toBeTruthy();
      const pipeline = response.pipeline!;
      
      expect(pipeline.stages).toBeTruthy();
      expect(pipeline.stages!.length).toBeGreaterThanOrEqual(2);
      
      const stageNames = pipeline.stages!.map(stage => stage.name);
      expect(stageNames).toContain('Source');
      expect(stageNames).toContain('Build');
      
      expect(pipeline.artifactStore).toBeTruthy();
      expect(pipeline.artifactStore!.type).toBe('S3');
      expect(pipeline.artifactStore!.encryptionKey).toBeTruthy();
    });

    test("CodeBuild project is configured", async () => {
      const projectName = outputs.codebuild_project_name?.value;
      expect(projectName).toBeTruthy();

      const response = await codeBuildClient.send(new BatchGetProjectsCommand({
        names: [projectName!]
      }));

      expect(response.projects).toHaveLength(1);
      const project = response.projects![0];
      
      expect(project.serviceRole).toBeTruthy();
      expect(project.artifacts?.type).toBe('CODEPIPELINE');
      expect(project.environment?.type).toBe('LINUX_CONTAINER');
      expect(project.environment?.computeType).toBeTruthy();
    });
  });

  describe("11. End-to-End Connectivity Tests", () => {
    test("NGINX service endpoint is reachable", async () => {
      const endpoint = outputs.nginx_service_endpoint?.value;
      expect(endpoint).toBeTruthy();

      // Note: In a real test, you might want to add HTTP connectivity tests
      // This validates the endpoint format and ALB DNS name structure
      expect(endpoint).toMatch(/^http:\/\//);
      expect(endpoint).toContain(outputs.alb_dns_name?.value!);
    });
  });

  describe("12. Resource Tagging Compliance", () => {
    test("All major resources have consistent tags", async () => {
      // This is a sampling test - in practice you'd check all resources
      const vpcId = outputs.vpc_id?.value;
      const vpcResponse = await ec2Client.send(new DescribeVpcsCommand({
        VpcIds: [vpcId!]
      }));

      const vpc = vpcResponse.Vpcs![0];
      const tags = vpc.Tags || [];
      const tagMap = Object.fromEntries(tags.map(t => [t.Key!, t.Value!]));
      
      expect(tagMap['Environment']).toBeTruthy();
      expect(tagMap['Project']).toBeTruthy();
      expect(tagMap['ManagedBy']).toBe('terraform');
      expect(tagMap['Owner']).toBeTruthy();
    });
  });
});