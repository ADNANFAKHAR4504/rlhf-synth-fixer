import * as fs from 'fs';
import * as path from 'path';
import {
  EC2Client,
  DescribeInstancesCommand,
  Instance,
  DescribeVolumesCommand,
} from '@aws-sdk/client-ec2';
import {
  KMSClient,
  DescribeKeyCommand,
  ListAliasesCommand,
} from '@aws-sdk/client-kms';
import {
  S3Client,
  GetBucketEncryptionCommand,
  GetPublicAccessBlockCommand,
} from '@aws-sdk/client-s3';

/* ----------------------------- Utilities & Types ----------------------------- */

// Type definition for the structure of the Terraform output JSON
type TfOutputValue<T> = { sensitive: boolean; type: any; value: T };
type DeploymentSummary = {
  [region: string]: {
    s3_bucket_name: string;
    ec2_instance_id: string;
    kms_key_arn: string;
  };
};
type StructuredOutputs = {
  deployment_summary: TfOutputValue<DeploymentSummary>;
};

/**
 * Reads and validates the structured outputs from the CI/CD pipeline.
 * @returns The parsed and validated deployment summary.
 */
function readDeploymentOutputs(): DeploymentSummary {
  const filePath = path.resolve(process.cwd(), 'cfn-outputs/all-outputs.json');
  if (!fs.existsSync(filePath)) {
    throw new Error(
      `Outputs file not found at ${filePath}. This file must be generated by the CI/CD 'Get Deployment Outputs' stage.`
    );
  }
  const outputs = JSON.parse(
    fs.readFileSync(filePath, 'utf8')
  ) as StructuredOutputs;

  const summary = outputs.deployment_summary?.value;
  if (!summary) {
    throw new Error('`deployment_summary` missing in outputs file.');
  }

  // Validate that expected regions and their properties exist
  const expectedRegions = ['eu-north-1', 'us-west-2']; // Updated to reflect the region change
  for (const region of expectedRegions) {
    if (
      !summary[region]?.s3_bucket_name ||
      !summary[region]?.ec2_instance_id ||
      !summary[region]?.kms_key_arn
    ) {
      throw new Error(
        `Output for region '${region}' is incomplete. Check s3_bucket_name, ec2_instance_id, and kms_key_arn.`
      );
    }
  }

  return summary;
}

/**
 * A simple retry mechanism for eventually consistent AWS API calls.
 */
async function retry<T>(
  fn: () => Promise<T>,
  attempts = 5,
  delayMs = 2000
): Promise<T> {
  let lastError: any;
  for (let i = 0; i < attempts; i++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error;
      await new Promise(resolve => setTimeout(resolve, delayMs * (i + 1)));
    }
  }
  throw lastError;
}

/* ----------------------------- Test Suite ----------------------------- */

describe('LIVE: Multi-Region AWS Infrastructure Integration Tests', () => {
  const outputs = readDeploymentOutputs();
  const regions = Object.keys(outputs);
  const TEST_TIMEOUT = 120_000;

  // Verify we have the expected regions
  it('should have deployed to eu-north-1 and us-west-2 regions', () => {
    expect(regions).toContain('eu-north-1');
    expect(regions).toContain('us-west-2');
    expect(regions).toHaveLength(2);
  });

  // Loop through each region defined in the output file and run a dedicated suite of tests
  for (const region of regions) {
    describe(`Region: ${region}`, () => {
      const regionOutputs = outputs[region];
      const ec2Client = new EC2Client({ region });
      const kmsClient = new KMSClient({ region });
      const s3Client = new S3Client({ region });

      test(
        'KMS Key should be correctly configured with a 10-day deletion window and proper alias',
        async () => {
          // 1. Check the key itself
          const keyData = await retry(() =>
            kmsClient.send(
              new DescribeKeyCommand({ KeyId: regionOutputs.kms_key_arn })
            )
          );
          expect(keyData.KeyMetadata).toBeDefined();
          expect(keyData.KeyMetadata?.DeletionDate).toBeUndefined(); // It should not be pending deletion
          expect(keyData.KeyMetadata?.KeyState).toBe('Enabled');

          // 2. Check the alias
          const aliasData = await retry(() =>
            kmsClient.send(
              new ListAliasesCommand({ KeyId: regionOutputs.kms_key_arn })
            )
          );
          const expectedAlias = 'alias/nova-app-key';
          const alias = aliasData.Aliases?.find(
            a => a.AliasName === expectedAlias
          );
          expect(alias).toBeDefined();
          expect(alias?.TargetKeyId).toBe(keyData.KeyMetadata?.KeyId);
        },
        TEST_TIMEOUT
      );

      test(
        'S3 Bucket should enforce KMS encryption and block all public access',
        async () => {
          // 1. Check Server-Side Encryption
          const encryptionData = await retry(() =>
            s3Client.send(
              new GetBucketEncryptionCommand({
                Bucket: regionOutputs.s3_bucket_name,
              })
            )
          );
          const sseRule =
            encryptionData.ServerSideEncryptionConfiguration?.Rules?.[0];
          expect(
            sseRule?.ApplyServerSideEncryptionByDefault?.SSEAlgorithm
          ).toBe('aws:kms');
          expect(
            sseRule?.ApplyServerSideEncryptionByDefault?.KMSMasterKeyID
          ).toBe(regionOutputs.kms_key_arn);

          // 2. Check Public Access Block
          const pabData = await retry(() =>
            s3Client.send(
              new GetPublicAccessBlockCommand({
                Bucket: regionOutputs.s3_bucket_name,
              })
            )
          );
          expect(pabData.PublicAccessBlockConfiguration?.BlockPublicAcls).toBe(
            true
          );
          expect(
            pabData.PublicAccessBlockConfiguration?.BlockPublicPolicy
          ).toBe(true);
          expect(pabData.PublicAccessBlockConfiguration?.IgnorePublicAcls).toBe(
            true
          );
          expect(
            pabData.PublicAccessBlockConfiguration?.RestrictPublicBuckets
          ).toBe(true);
        },
        TEST_TIMEOUT
      );

      test(
        'EC2 Instance should be a t3.micro, have an encrypted root volume, and an IAM profile',
        async () => {
          const instanceData = await retry(() =>
            ec2Client.send(
              new DescribeInstancesCommand({
                InstanceIds: [regionOutputs.ec2_instance_id],
              })
            )
          );
          const instance: Instance | undefined =
            instanceData.Reservations?.[0]?.Instances?.[0];
          expect(instance).toBeDefined();

          // 1. Check basic instance properties
          expect(instance?.InstanceType).toBe('t3.micro');
          expect(instance?.State?.Name).toBe('running');

          // 2. Check for IAM Instance Profile
          expect(instance?.IamInstanceProfile?.Arn).toContain(
            'nova-ec2-instance-profile'
          );

          // 3. Check for encrypted root volume
          const rootDeviceName = instance?.RootDeviceName;
          expect(rootDeviceName).toBeDefined();
          const rootVolume = instance?.BlockDeviceMappings?.find(
            bdm => bdm.DeviceName === rootDeviceName
          );
          expect(rootVolume?.Ebs?.VolumeId).toBeDefined();

          // Verify root volume encryption
          if (rootVolume?.Ebs?.VolumeId) {
            const volumeData = await retry(() =>
              ec2Client.send(
                new DescribeVolumesCommand({
                  VolumeIds: [rootVolume.Ebs!.VolumeId!],
                })
              )
            );
            const volume = volumeData.Volumes?.[0];
            expect(volume?.Encrypted).toBe(true);
            expect(volume?.KmsKeyId).toContain(
              regionOutputs.kms_key_arn.split('/').pop()
            );
          }

          // 4. Verify instance tags
          const tags = instance?.Tags || [];
          const nameTag = tags.find(t => t.Key === 'Name');
          expect(nameTag?.Value).toBe(`nova-app-server-${region}`);
          const ownerTag = tags.find(t => t.Key === 'Owner');
          expect(ownerTag?.Value).toBe('nova-devops-team');
          const purposeTag = tags.find(t => t.Key === 'Purpose');
          expect(purposeTag?.Value).toBe('Nova Application Baseline');
        },
        TEST_TIMEOUT
      );
    });
  }
});
