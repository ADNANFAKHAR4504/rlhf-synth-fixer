{
  "task_id": "101000802",
  "status": "in_progress",
  "platform": "Pulumi",
  "language": "Python",
  "language_normalized": "py",
  "difficulty": "hard",
  "complexity": "hard",
  "region": "us-east-2",
  "subtask": "Serverless Infrastructure",
  "team": "synth",
  "turn_type": "single",
  "po_id": "101000802",
  "worktree_path": "/var/www/turing/iac-test-automations/worktree/synth-101000802",
  "branch": "synth-101000802",
  "background": "A fintech startup needs to deploy a serverless payment webhook processing system that can handle high-volume transaction notifications from multiple payment providers. The system must process events asynchronously, store transaction records durably, and provide real-time analytics while maintaining PCI compliance standards.",
  "problem": "Create a Pulumi Python program to deploy a serverless webhook processing system for payment notifications. The configuration must: 1. Create an API Gateway REST API with /webhook POST endpoint that validates API keys. 2. Deploy a Lambda function that processes incoming webhooks and writes to DynamoDB. 3. Set up a DynamoDB table with partition key 'transaction_id' and sort key 'timestamp'. 4. Configure DynamoDB Streams to trigger a second Lambda function for analytics processing. 5. Create an S3 bucket for storing processed transaction audit logs with encryption. 6. Implement dead letter queues using SQS for failed Lambda invocations. 7. Set up CloudWatch alarms for Lambda errors exceeding 1% error rate. 8. Configure API Gateway to log all requests to CloudWatch Logs. 9. Create a Lambda function that archives old transactions from DynamoDB to S3 daily. 10. Implement proper IAM roles and policies for all Lambda functions. Expected output: A complete Pulumi Python program that creates all resources with proper configurations, exports the API Gateway endpoint URL, DynamoDB table name, and S3 bucket name for integration with external systems.",
  "aws_services": [
    "API Gateway",
    "Lambda",
    "DynamoDB",
    "DynamoDB Streams",
    "S3",
    "SQS",
    "CloudWatch",
    "IAM"
  ],
  "constraints": [
    "All Lambda functions must use Python 3.9 runtime with 512MB memory allocation",
    "DynamoDB tables must use on-demand billing mode with point-in-time recovery enabled",
    "API Gateway must implement request throttling at 10,000 requests per second",
    "Lambda functions must have reserved concurrent executions set to prevent cold starts",
    "All S3 buckets must have versioning enabled and lifecycle policies for 90-day retention",
    "CloudWatch Log Groups must have 30-day retention periods configured",
    "Lambda execution roles must follow least privilege principle with explicit resource ARNs",
    "DynamoDB streams must trigger Lambda functions with batch size of exactly 100 records",
    "All resources must be tagged with Environment, Project, and CostCenter tags"
  ],
  "key_requirements": [
    "API Gateway REST API with /webhook POST endpoint and API key validation",
    "Lambda function for webhook processing writing to DynamoDB",
    "DynamoDB table with partition key 'transaction_id' and sort key 'timestamp'",
    "DynamoDB Streams triggering analytics Lambda function",
    "S3 bucket with encryption for audit logs",
    "SQS dead letter queues for failed Lambda invocations",
    "CloudWatch alarms for Lambda errors >1% error rate",
    "API Gateway logging to CloudWatch",
    "Lambda function for daily DynamoDB to S3 archival",
    "Proper IAM roles and policies for all Lambda functions"
  ],
  "expected_outputs": [
    "API Gateway endpoint URL",
    "DynamoDB table name",
    "S3 bucket name"
  ],
  "validation_checklist": [
    "Platform: Pulumi (not CDK, Terraform, or CloudFormation)",
    "Language: Python (py) with Python 3.9 runtime for Lambda",
    "Region: us-east-2",
    "All 10 infrastructure requirements implemented",
    "All 9 technical constraints satisfied",
    "All required outputs exported",
    "PCI compliance considerations addressed",
    "Environment suffix used in all resource names"
  ]
}
