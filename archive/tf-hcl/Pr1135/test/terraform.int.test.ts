/**
 * AWS Secure Infrastructure Project - Integration Tests
 *
 * These tests validate the deployed infrastructure using real AWS resources
 * by reading from the outputs file generated by CI/CD pipeline deployment.
 */

import {
  CloudTrailClient,
  DescribeTrailsCommand,
} from '@aws-sdk/client-cloudtrail';
import {
  BatchGetProjectsCommand,
  CodeBuildClient,
} from '@aws-sdk/client-codebuild';
import {
  CodePipelineClient,
  GetPipelineCommand,
} from '@aws-sdk/client-codepipeline';
import {
  DescribeNatGatewaysCommand,
  DescribeSecurityGroupsCommand,
  DescribeSubnetsCommand,
  DescribeVpcsCommand,
  EC2Client,
} from '@aws-sdk/client-ec2';
import {
  DescribeClusterCommand,
  DescribeNodegroupCommand,
  EKSClient,
} from '@aws-sdk/client-eks';
import {
  DescribeLoadBalancersCommand,
  DescribeTargetGroupsCommand,
  ElasticLoadBalancingV2Client,
} from '@aws-sdk/client-elastic-load-balancing-v2';
import { DescribeKeyCommand, KMSClient } from '@aws-sdk/client-kms';
import { DescribeDBInstancesCommand, RDSClient } from '@aws-sdk/client-rds';
import {
  GetBucketEncryptionCommand,
  GetBucketVersioningCommand,
  GetPublicAccessBlockCommand,
  S3Client,
} from '@aws-sdk/client-s3';
import * as fs from 'fs';
import * as path from 'path';

/** ===================== Types & IO ===================== */

type TfValue<T> = { sensitive: boolean; type: any; value: T };

type Outputs = {
  aws_region?: TfValue<string>;
  vpc_id?: TfValue<string>;
  vpc_cidr?: TfValue<string>;
  public_subnet_ids?: TfValue<string[]>;
  private_subnet_ids?: TfValue<string[]>;
  eks_cluster_id?: TfValue<string>;
  eks_cluster_name?: TfValue<string>;
  eks_cluster_arn?: TfValue<string>;
  eks_cluster_endpoint?: TfValue<string>;
  eks_cluster_version?: TfValue<string>;
  eks_node_group_name?: TfValue<string>;
  rds_endpoint?: TfValue<string>;
  rds_instance_id?: TfValue<string>;
  rds_port?: TfValue<number>;
  alb_dns_name?: TfValue<string>;
  alb_zone_id?: TfValue<string>;
  alb_target_group_arn?: TfValue<string>;
  kms_key_id?: TfValue<string>;
  kms_key_arn?: TfValue<string>;
  cloudtrail_arn?: TfValue<string>;
  codepipeline_name?: TfValue<string>;
  codebuild_project_name?: TfValue<string>;
  s3_alb_logs_bucket?: TfValue<string>;
  s3_codepipeline_artifacts_bucket?: TfValue<string>;
  s3_cloudtrail_bucket?: TfValue<string>;
  nginx_service_endpoint?: TfValue<string>;
};

const outputsPath = path.resolve(process.cwd(), 'cfn-outputs/all-outputs.json');

function loadOutputs(): Outputs {
  if (!fs.existsSync(outputsPath)) {
    throw new Error(
      `Outputs file not found at ${outputsPath}. Please ensure CI/CD pipeline has run and created the outputs file.`
    );
  }
  const raw = fs.readFileSync(outputsPath, 'utf8');
  return JSON.parse(raw) as Outputs;
}

/** ===================== Test Suite ===================== */

describe('AWS Secure Infrastructure Integration Tests', () => {
  let outputs: Outputs;
  let awsRegion: string;
  let ec2Client: EC2Client;
  let elbv2Client: ElasticLoadBalancingV2Client;
  let rdsClient: RDSClient;
  let s3Client: S3Client;
  let eksClient: EKSClient;
  let cloudTrailClient: CloudTrailClient;
  let codePipelineClient: CodePipelineClient;
  let codeBuildClient: CodeBuildClient;
  let kmsClient: KMSClient;

  beforeAll(async () => {
    outputs = loadOutputs();
    awsRegion = outputs.aws_region?.value || 'us-west-2';

    // Initialize AWS clients for the deployed region
    ec2Client = new EC2Client({ region: awsRegion });
    elbv2Client = new ElasticLoadBalancingV2Client({ region: awsRegion });
    rdsClient = new RDSClient({ region: awsRegion });
    s3Client = new S3Client({ region: awsRegion });
    eksClient = new EKSClient({ region: awsRegion });
    cloudTrailClient = new CloudTrailClient({ region: awsRegion });
    codePipelineClient = new CodePipelineClient({ region: awsRegion });
    codeBuildClient = new CodeBuildClient({ region: awsRegion });
    kmsClient = new KMSClient({ region: awsRegion });
  });

  afterAll(async () => {
    // Clean up AWS clients
    ec2Client.destroy();
    elbv2Client.destroy();
    rdsClient.destroy();
    s3Client.destroy();
    eksClient.destroy();
    cloudTrailClient.destroy();
    codePipelineClient.destroy();
    codeBuildClient.destroy();
    kmsClient.destroy();
  });

  describe('1. Infrastructure Outputs Validation', () => {
    test('All required outputs are present', () => {
      const requiredOutputs = [
        'aws_region',
        'vpc_id',
        'eks_cluster_name',
        'eks_cluster_endpoint',
        'alb_dns_name',
        'rds_endpoint',
        'kms_key_arn',
        'codepipeline_name',
      ];

      requiredOutputs.forEach(outputName => {
        expect(outputs[outputName as keyof Outputs]).toBeDefined();
        expect(outputs[outputName as keyof Outputs]?.value).toBeTruthy();
      });
    });

    test('Region is set to us-west-2', () => {
      expect(outputs.aws_region?.value).toBe('us-west-2');
    });

    test('Sensitive outputs are properly marked', () => {
      expect(outputs.rds_endpoint?.sensitive).toBe(true);
    });
  });

  describe('2. VPC and Networking Validation', () => {
    test('VPC exists and has correct configuration', async () => {
      const vpcId = outputs.vpc_id?.value;
      expect(vpcId).toBeTruthy();

      const response = await ec2Client.send(
        new DescribeVpcsCommand({
          VpcIds: [vpcId!],
        })
      );

      expect(response.Vpcs).toHaveLength(1);
      const vpc = response.Vpcs![0];
      expect(vpc.State).toBe('available');
      expect(vpc.CidrBlock).toBe(outputs.vpc_cidr?.value || '10.0.0.0/16');
      expect(vpc.DhcpOptionsId).toBeTruthy();
      expect(vpc.InstanceTenancy).toBe('default');
    });

    test('Public subnets are configured correctly', async () => {
      const subnetIds = outputs.public_subnet_ids?.value || [];
      expect(subnetIds.length).toBeGreaterThanOrEqual(2);

      const response = await ec2Client.send(
        new DescribeSubnetsCommand({
          SubnetIds: subnetIds,
        })
      );

      expect(response.Subnets).toHaveLength(subnetIds.length);
      response.Subnets?.forEach(subnet => {
        expect(subnet.State).toBe('available');
        expect(subnet.MapPublicIpOnLaunch).toBe(true);
        expect(subnet.VpcId).toBe(outputs.vpc_id?.value);
      });
    });

    test('Private subnets are configured correctly', async () => {
      const subnetIds = outputs.private_subnet_ids?.value || [];
      expect(subnetIds.length).toBeGreaterThanOrEqual(2);

      const response = await ec2Client.send(
        new DescribeSubnetsCommand({
          SubnetIds: subnetIds,
        })
      );

      expect(response.Subnets).toHaveLength(subnetIds.length);
      response.Subnets?.forEach(subnet => {
        expect(subnet.State).toBe('available');
        expect(subnet.MapPublicIpOnLaunch).toBe(false);
        expect(subnet.VpcId).toBe(outputs.vpc_id?.value);
      });
    });

    test('NAT Gateways are deployed in public subnets', async () => {
      const vpcId = outputs.vpc_id?.value;
      const response = await ec2Client.send(
        new DescribeNatGatewaysCommand({
          Filter: [{ Name: 'vpc-id', Values: [vpcId!] }],
        })
      );

      expect(response.NatGateways).toBeTruthy();
      expect(response.NatGateways!.length).toBeGreaterThan(0);

      response.NatGateways?.forEach(nat => {
        expect(nat.State).toBe('available');
        expect(nat.VpcId).toBe(vpcId);
      });
    });
  });

  describe('3. Security Groups Validation', () => {
    test('Security groups follow least privilege principles', async () => {
      const vpcId = outputs.vpc_id?.value;
      const response = await ec2Client.send(
        new DescribeSecurityGroupsCommand({
          Filters: [{ Name: 'vpc-id', Values: [vpcId!] }],
        })
      );

      const securityGroups = response.SecurityGroups || [];
      expect(securityGroups.length).toBeGreaterThan(3);

      // Find ALB security group
      const albSg = securityGroups.find(
        sg =>
          sg.GroupName?.includes('alb') ||
          sg.Description?.includes('ALB') ||
          sg.Description?.includes('load balancer')
      );
      expect(albSg).toBeTruthy();

      // ALB should allow HTTP/HTTPS from internet
      const httpRule = albSg?.IpPermissions?.find(rule => rule.FromPort === 80);
      const httpsRule = albSg?.IpPermissions?.find(
        rule => rule.FromPort === 443
      );
      expect(httpRule).toBeTruthy();
      expect(httpsRule).toBeTruthy();

      // Find RDS security group
      const rdsSg = securityGroups.find(
        sg =>
          sg.GroupName?.includes('rds') ||
          sg.GroupName?.includes('db') ||
          sg.Description?.includes('RDS') ||
          sg.Description?.includes('database')
      );
      expect(rdsSg).toBeTruthy();

      // RDS should only allow PostgreSQL port from EKS nodes
      const pgRule = rdsSg?.IpPermissions?.find(rule => rule.FromPort === 5432);
      expect(pgRule).toBeTruthy();
      expect(pgRule?.UserIdGroupPairs?.length).toBeGreaterThan(0);
    });

    test('ALB security group has correct ingress and egress rules', async () => {
      const vpcId = outputs.vpc_id?.value;
      const response = await ec2Client.send(
        new DescribeSecurityGroupsCommand({
          Filters: [{ Name: 'vpc-id', Values: [vpcId!] }],
        })
      );

      const albSg = response.SecurityGroups?.find(
        sg =>
          sg.GroupName?.includes('alb') ||
          sg.Description?.includes('ALB') ||
          sg.Description?.includes('Application Load Balancer')
      );
      expect(albSg).toBeTruthy();

      // Validate HTTP ingress rule (port 80)
      const httpRule = albSg?.IpPermissions?.find(rule => rule.FromPort === 80 && rule.ToPort === 80);
      expect(httpRule).toBeTruthy();
      expect(httpRule?.IpProtocol).toBe('tcp');
      expect(httpRule?.IpRanges?.some(range => range.CidrIp === '0.0.0.0/0')).toBe(true);

      // Validate HTTPS ingress rule (port 443)
      const httpsRule = albSg?.IpPermissions?.find(rule => rule.FromPort === 443 && rule.ToPort === 443);
      expect(httpsRule).toBeTruthy();
      expect(httpsRule?.IpProtocol).toBe('tcp');
      expect(httpsRule?.IpRanges?.some(range => range.CidrIp === '0.0.0.0/0')).toBe(true);

      // Validate egress rule (all traffic outbound)
      const egressRule = albSg?.IpPermissionsEgress?.find(rule => rule.IpProtocol === '-1');
      expect(egressRule).toBeTruthy();
      expect(egressRule?.IpRanges?.some(range => range.CidrIp === '0.0.0.0/0')).toBe(true);
    });

    test('RDS security group only allows PostgreSQL from EKS nodes', async () => {
      const vpcId = outputs.vpc_id?.value;
      const response = await ec2Client.send(
        new DescribeSecurityGroupsCommand({
          Filters: [{ Name: 'vpc-id', Values: [vpcId!] }],
        })
      );

      const rdsSg = response.SecurityGroups?.find(
        sg =>
          sg.GroupName?.includes('rds') ||
          sg.GroupName?.includes('db') ||
          sg.Description?.includes('RDS') ||
          sg.Description?.includes('PostgreSQL')
      );
      expect(rdsSg).toBeTruthy();

      // Find EKS nodes security group
      const eksNodesSg = response.SecurityGroups?.find(
        sg =>
          sg.GroupName?.includes('nodes') ||
          sg.Description?.includes('worker nodes') ||
          sg.Description?.includes('EKS worker')
      );
      expect(eksNodesSg).toBeTruthy();

      // Validate PostgreSQL ingress rule (port 5432)
      const pgRule = rdsSg?.IpPermissions?.find(rule => rule.FromPort === 5432 && rule.ToPort === 5432);
      expect(pgRule).toBeTruthy();
      expect(pgRule?.IpProtocol).toBe('tcp');

      // Should only allow from EKS nodes security group
      expect(pgRule?.UserIdGroupPairs?.length).toBeGreaterThan(0);
      expect(pgRule?.UserIdGroupPairs?.some(pair => pair.GroupId === eksNodesSg?.GroupId)).toBe(true);

      // Should not allow from 0.0.0.0/0
      expect(pgRule?.IpRanges?.length).toBe(0);
    });

    test('EKS cluster security group has correct rules', async () => {
      const vpcId = outputs.vpc_id?.value;
      const response = await ec2Client.send(
        new DescribeSecurityGroupsCommand({
          Filters: [{ Name: 'vpc-id', Values: [vpcId!] }],
        })
      );

      const eksClusterSg = response.SecurityGroups?.find(
        sg =>
          sg.GroupName?.includes('cluster') ||
          sg.Description?.includes('EKS cluster') ||
          sg.Description?.includes('control plane')
      );
      expect(eksClusterSg).toBeTruthy();

      // Validate HTTPS ingress rule from nodes (port 443)
      const httpsRule = eksClusterSg?.IpPermissions?.find(rule => rule.FromPort === 443 && rule.ToPort === 443);
      expect(httpsRule).toBeTruthy();
      expect(httpsRule?.IpProtocol).toBe('tcp');

      // Should allow self-referencing for cluster communication
      const selfReference = httpsRule?.UserIdGroupPairs?.find(pair => pair.GroupId === eksClusterSg?.GroupId);
      expect(selfReference).toBeTruthy();

      // Validate egress rule (all traffic outbound)
      const egressRule = eksClusterSg?.IpPermissionsEgress?.find(rule => rule.IpProtocol === '-1');
      expect(egressRule).toBeTruthy();
    });

    test('EKS nodes security group has correct rules', async () => {
      const vpcId = outputs.vpc_id?.value;
      const response = await ec2Client.send(
        new DescribeSecurityGroupsCommand({
          Filters: [{ Name: 'vpc-id', Values: [vpcId!] }],
        })
      );

      const eksNodesSg = response.SecurityGroups?.find(
        sg =>
          sg.GroupName?.includes('nodes') ||
          sg.Description?.includes('worker nodes') ||
          sg.Description?.includes('EKS worker')
      );
      expect(eksNodesSg).toBeTruthy();

      const albSg = response.SecurityGroups?.find(
        sg =>
          sg.GroupName?.includes('alb') ||
          sg.Description?.includes('ALB') ||
          sg.Description?.includes('Application Load Balancer')
      );

      const eksClusterSg = response.SecurityGroups?.find(
        sg =>
          sg.GroupName?.includes('cluster') ||
          sg.Description?.includes('EKS cluster') ||
          sg.Description?.includes('control plane')
      );

      // Node to node communication (self-referencing)
      const selfReferenceRule = eksNodesSg?.IpPermissions?.find(rule => 
        rule.IpProtocol === '-1' && rule.UserIdGroupPairs?.some(pair => pair.GroupId === eksNodesSg?.GroupId)
      );
      expect(selfReferenceRule).toBeTruthy();

      // Communication from cluster
      const clusterRule = eksNodesSg?.IpPermissions?.find(rule => 
        rule.IpProtocol === '-1' && rule.UserIdGroupPairs?.some(pair => pair.GroupId === eksClusterSg?.GroupId)
      );
      expect(clusterRule).toBeTruthy();

      // HTTP from ALB
      const albHttpRule = eksNodesSg?.IpPermissions?.find(rule => 
        rule.FromPort === 80 && rule.ToPort === 80 && 
        rule.UserIdGroupPairs?.some(pair => pair.GroupId === albSg?.GroupId)
      );
      expect(albHttpRule).toBeTruthy();

      // All outbound traffic
      const egressRule = eksNodesSg?.IpPermissionsEgress?.find(rule => rule.IpProtocol === '-1');
      expect(egressRule).toBeTruthy();
    });
  });

  describe('4. KMS Key Validation', () => {
    test('KMS key is configured with key rotation', async () => {
      const keyId = outputs.kms_key_id?.value;
      expect(keyId).toBeTruthy();

      const response = await kmsClient.send(
        new DescribeKeyCommand({
          KeyId: keyId!,
        })
      );

      expect(response.KeyMetadata).toBeTruthy();
      expect(response.KeyMetadata!.KeyState).toBe('Enabled');
      expect(response.KeyMetadata!.KeyUsage).toBe('ENCRYPT_DECRYPT');
      expect(response.KeyMetadata!.MultiRegion).toBe(false);
    });

    test('KMS key has proper policy with required permissions', async () => {
      const keyId = outputs.kms_key_id?.value;
      expect(keyId).toBeTruthy();

      // Get the key policy
      const { GetKeyPolicyCommand } = await import('@aws-sdk/client-kms');
      const policyDetailResponse = await kmsClient.send(
        new GetKeyPolicyCommand({
          KeyId: keyId!,
          PolicyName: 'default',
        })
      );

      expect(policyDetailResponse.Policy).toBeTruthy();
      const policy = JSON.parse(policyDetailResponse.Policy!);
      expect(policy.Version).toBe('2012-10-17');
      expect(policy.Statement).toBeTruthy();
      expect(Array.isArray(policy.Statement)).toBe(true);

      // Check for root account permissions statement
      const rootStatement = policy.Statement.find((stmt: any) =>
        stmt.Sid === 'Enable IAM User Permissions' &&
        stmt.Effect === 'Allow' &&
        stmt.Action === 'kms:*'
      );
      expect(rootStatement).toBeTruthy();
      expect(rootStatement.Principal.AWS).toContain('root');

      // Check for AWS services permissions statement
      const servicesStatement = policy.Statement.find((stmt: any) =>
        stmt.Sid === 'Allow use of the key by AWS services' &&
        stmt.Effect === 'Allow'
      );
      expect(servicesStatement).toBeTruthy();
      expect(servicesStatement.Principal.Service).toContain('ec2.amazonaws.com');
      expect(servicesStatement.Principal.Service).toContain('s3.amazonaws.com');
      expect(servicesStatement.Principal.Service).toContain('rds.amazonaws.com');
      expect(servicesStatement.Principal.Service).toContain('eks.amazonaws.com');
      expect(servicesStatement.Principal.Service).toContain('logs.amazonaws.com');
      expect(servicesStatement.Principal.Service).toContain('cloudtrail.amazonaws.com');

      // Verify required actions for services
      expect(servicesStatement.Action).toContain('kms:Encrypt');
      expect(servicesStatement.Action).toContain('kms:Decrypt');
      expect(servicesStatement.Action).toContain('kms:ReEncrypt*');
      expect(servicesStatement.Action).toContain('kms:GenerateDataKey*');
      expect(servicesStatement.Action).toContain('kms:CreateGrant');
      expect(servicesStatement.Action).toContain('kms:DescribeKey');

      // Check for EKS nodes permissions statement
      const eksNodesStatement = policy.Statement.find((stmt: any) =>
        stmt.Sid === 'Allow EKS nodes to use the key' &&
        stmt.Effect === 'Allow'
      );
      expect(eksNodesStatement).toBeTruthy();
      expect(eksNodesStatement.Action).toContain('kms:Decrypt');
      expect(eksNodesStatement.Action).toContain('kms:GenerateDataKey');
      expect(eksNodesStatement.Action).toContain('kms:CreateGrant');
      expect(eksNodesStatement.Condition).toBeTruthy();
      expect(eksNodesStatement.Condition.StringLike).toBeTruthy();
    });

    test('KMS key rotation is enabled', async () => {
      const keyId = outputs.kms_key_id?.value;
      expect(keyId).toBeTruthy();

      const { GetKeyRotationStatusCommand } = await import('@aws-sdk/client-kms');
      const rotationResponse = await kmsClient.send(
        new GetKeyRotationStatusCommand({
          KeyId: keyId!,
        })
      );

      expect(rotationResponse.KeyRotationEnabled).toBe(true);
    });

    test('KMS key alias exists and points to correct key', async () => {
      const keyId = outputs.kms_key_id?.value;
      const keyArn = outputs.kms_key_arn?.value;
      expect(keyId).toBeTruthy();
      expect(keyArn).toBeTruthy();

      const { ListAliasesCommand } = await import('@aws-sdk/client-kms');
      const aliasResponse = await kmsClient.send(
        new ListAliasesCommand({
          KeyId: keyId!,
        })
      );

      expect(aliasResponse.Aliases).toBeTruthy();
      expect(aliasResponse.Aliases!.length).toBeGreaterThan(0);

      // Should have corp-key alias
      const corpKeyAlias = aliasResponse.Aliases!.find(alias =>
        alias.AliasName?.includes('corp') && alias.AliasName?.includes('key')
      );
      expect(corpKeyAlias).toBeTruthy();
      expect(corpKeyAlias!.TargetKeyId).toBe(keyId);
    });
  });

  describe('5. EKS Cluster Validation', () => {
    test('EKS cluster is running and properly configured', async () => {
      const clusterName = outputs.eks_cluster_name?.value;
      expect(clusterName).toBeTruthy();

      const response = await eksClient.send(
        new DescribeClusterCommand({
          name: clusterName!,
        })
      );

      expect(response.cluster).toBeTruthy();
      const cluster = response.cluster!;

      expect(cluster.status).toBe('ACTIVE');
      expect(cluster.version).toBe(
        outputs.eks_cluster_version?.value || '1.29'
      );
      expect(cluster.endpoint).toBe(outputs.eks_cluster_endpoint?.value);
      expect(cluster.resourcesVpcConfig?.vpcId).toBe(outputs.vpc_id?.value);
      expect(cluster.resourcesVpcConfig?.endpointPrivateAccess).toBe(true);
      expect(cluster.resourcesVpcConfig?.endpointPublicAccess).toBe(true);
      expect(cluster.encryptionConfig).toBeTruthy();
      expect(
        cluster.logging?.clusterLogging?.some(
          (log: any) => log.enabled === true
        )
      ).toBe(true);
    });

    test('EKS node group is active and properly scaled', async () => {
      const clusterName = outputs.eks_cluster_name?.value;
      const nodeGroupName = outputs.eks_node_group_name?.value;

      const response = await eksClient.send(
        new DescribeNodegroupCommand({
          clusterName: clusterName!,
          nodegroupName: nodeGroupName!,
        })
      );

      expect(response.nodegroup).toBeTruthy();
      const nodeGroup = response.nodegroup!;

      expect(nodeGroup.status).toBe('ACTIVE');
      expect(nodeGroup.capacityType).toBe('ON_DEMAND');
      expect(nodeGroup.instanceTypes).toContain('t3.medium');
      expect(nodeGroup.scalingConfig?.minSize).toBe(1);
      expect(nodeGroup.scalingConfig?.maxSize).toBe(2);
      expect(nodeGroup.scalingConfig?.desiredSize).toBe(1);
      expect(nodeGroup.subnets).toEqual(
        expect.arrayContaining(outputs.private_subnet_ids?.value || [])
      );
    });
  });

  describe('6. RDS Database Validation', () => {
    test('RDS PostgreSQL instance is available and secure', async () => {
      const instanceId = outputs.rds_instance_id?.value;
      expect(instanceId).toBeTruthy();

      // Try to find the DB instance by identifier or list all and find it
      let dbInstance;
      try {
        const response = await rdsClient.send(
          new DescribeDBInstancesCommand({
            DBInstanceIdentifier: instanceId!,
          })
        );
        dbInstance = response.DBInstances![0];
      } catch (error) {
        // If specific instance not found, try to find our specific instance
        const allResponse = await rdsClient.send(
          new DescribeDBInstancesCommand({})
        );
        dbInstance = allResponse.DBInstances?.find(
          db =>
            (db.DBInstanceIdentifier?.includes('corp-') &&
              db.Engine === 'postgres') ||
            (db.DBName?.includes('maindb') && db.Engine === 'postgres') ||
            db.DBInstanceIdentifier === instanceId
        );
      }

      expect(dbInstance).toBeTruthy();

      expect(dbInstance!.DBInstanceStatus).toBe('available');
      expect(dbInstance!.Engine).toBe('postgres');
      expect(dbInstance!.EngineVersion).toMatch(/^(15|16|17)\./);
      expect(dbInstance!.DBInstanceClass).toBe('db.t3.micro');
      expect(dbInstance!.StorageEncrypted).toBe(true);
      expect(dbInstance!.PubliclyAccessible).toBe(false);
      expect(
        dbInstance!.VpcSecurityGroups?.some(sg => sg.Status === 'active')
      ).toBe(true);
    });
  });

  describe('7. Load Balancer Validation', () => {
    test('Application Load Balancer is active and accessible', async () => {
      const albDnsName = outputs.alb_dns_name?.value;
      expect(albDnsName).toBeTruthy();

      const response = await elbv2Client.send(
        new DescribeLoadBalancersCommand({})
      );

      // First try to find by exact DNS name
      let alb = response.LoadBalancers?.find(lb => lb.DNSName === albDnsName);

      // If not found, find ALBs in our VPC and then filter by name pattern
      if (!alb) {
        const albsInVpc = response.LoadBalancers?.filter(
          lb => lb.VpcId === outputs.vpc_id?.value
        );
        alb = albsInVpc?.find(
          lb =>
            lb.LoadBalancerName?.includes('corp-') ||
            lb.DNSName?.includes(albDnsName!.split('.')[0])
        );
      }

      expect(alb).toBeTruthy();

      expect(alb!.State?.Code).toBe('active');
      expect(alb!.Type).toBe('application');
      expect(alb!.Scheme).toBe('internet-facing');
      expect(alb!.VpcId).toBe(outputs.vpc_id?.value);
      expect(alb!.AvailabilityZones?.length).toBeGreaterThanOrEqual(2);
    });

    test('Target group is healthy', async () => {
      const targetGroupArn = outputs.alb_target_group_arn?.value;
      expect(targetGroupArn).toBeTruthy();

      const response = await elbv2Client.send(
        new DescribeTargetGroupsCommand({
          TargetGroupArns: [targetGroupArn!],
        })
      );

      expect(response.TargetGroups).toHaveLength(1);
      const targetGroup = response.TargetGroups![0];

      expect(targetGroup.Protocol).toBe('HTTP');
      expect(targetGroup.Port).toBe(80);
      expect(targetGroup.VpcId).toBe(outputs.vpc_id?.value);
      expect(targetGroup.HealthCheckPath).toBe('/');
    });

    test('Target group has correct health check configuration', async () => {
      const targetGroupArn = outputs.alb_target_group_arn?.value;
      expect(targetGroupArn).toBeTruthy();

      const response = await elbv2Client.send(
        new DescribeTargetGroupsCommand({
          TargetGroupArns: [targetGroupArn!],
        })
      );

      const targetGroup = response.TargetGroups![0];

      // Validate health check settings match Terraform configuration
      expect(targetGroup.HealthCheckEnabled).toBe(true);
      expect(targetGroup.HealthyThresholdCount).toBe(2);
      expect(targetGroup.UnhealthyThresholdCount).toBe(2);
      expect(targetGroup.HealthCheckTimeoutSeconds).toBe(5);
      expect(targetGroup.HealthCheckIntervalSeconds).toBe(30);
      expect(targetGroup.HealthCheckPath).toBe('/');
      expect(targetGroup.HealthCheckProtocol).toBe('HTTP');
      expect(targetGroup.HealthCheckPort).toBe('traffic-port');
      expect(targetGroup.Matcher?.HttpCode).toBe('200');
    });

    test('Target group health check endpoint accessibility', async () => {
      const targetGroupArn = outputs.alb_target_group_arn?.value;
      expect(targetGroupArn).toBeTruthy();

      // Get target health status
      const { DescribeTargetHealthCommand } = await import('@aws-sdk/client-elastic-load-balancing-v2');
      const healthResponse = await elbv2Client.send(
        new DescribeTargetHealthCommand({
          TargetGroupArn: targetGroupArn!,
        })
      );

      expect(healthResponse.TargetHealthDescriptions).toBeTruthy();
      
      // Verify each target's health status and reason
      for (const targetHealth of healthResponse.TargetHealthDescriptions || []) {
        expect(targetHealth.Target).toBeTruthy();
        expect(targetHealth.TargetHealth).toBeTruthy();
        
        // Target should be either healthy, initial, or draining (acceptable states)
        // unhealthy, unused, unavailable, or unhealthy.draining would indicate issues
        const acceptableStates = ['healthy', 'initial', 'draining'];
        expect(acceptableStates).toContain(targetHealth.TargetHealth!.State!);
        
        // If unhealthy, check the reason for troubleshooting
        if (targetHealth.TargetHealth!.State === 'unhealthy') {
          console.warn(`Target ${targetHealth.Target!.Id} is unhealthy: ${targetHealth.TargetHealth!.Reason}`);
          console.warn(`Description: ${targetHealth.TargetHealth!.Description}`);
        }
      }
    });

    test('ALB listeners are configured correctly', async () => {
      const albDnsName = outputs.alb_dns_name?.value;
      expect(albDnsName).toBeTruthy();

      // Get load balancer ARN first
      const lbResponse = await elbv2Client.send(
        new DescribeLoadBalancersCommand({})
      );
      
      const alb = lbResponse.LoadBalancers?.find(lb => 
        lb.DNSName === albDnsName || lb.VpcId === outputs.vpc_id?.value
      );
      expect(alb).toBeTruthy();

      // Get listeners for this load balancer
      const { DescribeListenersCommand } = await import('@aws-sdk/client-elastic-load-balancing-v2');
      const listenersResponse = await elbv2Client.send(
        new DescribeListenersCommand({
          LoadBalancerArn: alb!.LoadBalancerArn!,
        })
      );

      expect(listenersResponse.Listeners).toBeTruthy();
      expect(listenersResponse.Listeners!.length).toBeGreaterThan(0);

      // Validate HTTP listener (port 80)
      const httpListener = listenersResponse.Listeners!.find(listener => 
        listener.Port === 80 && listener.Protocol === 'HTTP'
      );
      expect(httpListener).toBeTruthy();
      expect(httpListener!.DefaultActions).toBeTruthy();
      expect(httpListener!.DefaultActions!.length).toBeGreaterThan(0);
      
      // Validate default action forwards to target group
      const forwardAction = httpListener!.DefaultActions!.find(action => 
        action.Type === 'forward'
      );
      expect(forwardAction).toBeTruthy();
      expect(forwardAction!.TargetGroupArn).toBe(outputs.alb_target_group_arn?.value);
    });

    test('ALB access logs are enabled and configured', async () => {
      const albDnsName = outputs.alb_dns_name?.value;
      expect(albDnsName).toBeTruthy();

      // Get load balancer attributes
      const lbResponse = await elbv2Client.send(
        new DescribeLoadBalancersCommand({})
      );
      
      const alb = lbResponse.LoadBalancers?.find(lb => 
        lb.DNSName === albDnsName || lb.VpcId === outputs.vpc_id?.value
      );
      expect(alb).toBeTruthy();

      const { DescribeLoadBalancerAttributesCommand } = await import('@aws-sdk/client-elastic-load-balancing-v2');
      const attributesResponse = await elbv2Client.send(
        new DescribeLoadBalancerAttributesCommand({
          LoadBalancerArn: alb!.LoadBalancerArn!,
        })
      );

      expect(attributesResponse.Attributes).toBeTruthy();
      
      // Check access logs are enabled (this was our main fix)
      const accessLogsEnabled = attributesResponse.Attributes!.find(attr => 
        attr.Key === 'access_logs.s3.enabled'
      );
      expect(accessLogsEnabled).toBeTruthy();
      expect(accessLogsEnabled!.Value).toBe('true');

      // Check S3 bucket is configured
      const accessLogsBucket = attributesResponse.Attributes!.find(attr => 
        attr.Key === 'access_logs.s3.bucket'
      );
      expect(accessLogsBucket).toBeTruthy();
      expect(accessLogsBucket!.Value).toBe(outputs.s3_alb_logs_bucket?.value);

      // Check prefix is configured
      const accessLogsPrefix = attributesResponse.Attributes!.find(attr => 
        attr.Key === 'access_logs.s3.prefix'
      );
      expect(accessLogsPrefix).toBeTruthy();
      expect(accessLogsPrefix!.Value).toBe('alb-logs');
    });
  });

  describe('8. S3 Buckets Security Validation', () => {
    test('S3 buckets have encryption enabled', async () => {
      const buckets = [
        outputs.s3_alb_logs_bucket?.value,
        outputs.s3_codepipeline_artifacts_bucket?.value,
        outputs.s3_cloudtrail_bucket?.value,
      ].filter(Boolean);

      expect(buckets.length).toBeGreaterThan(0);

      for (const bucketName of buckets) {
        const encryptionResponse = await s3Client.send(
          new GetBucketEncryptionCommand({
            Bucket: bucketName!,
          })
        );

        expect(
          encryptionResponse.ServerSideEncryptionConfiguration
        ).toBeTruthy();
        const rule =
          encryptionResponse.ServerSideEncryptionConfiguration!.Rules![0];
        expect(rule.ApplyServerSideEncryptionByDefault?.SSEAlgorithm).toBe(
          'aws:kms'
        );
        expect(
          rule.ApplyServerSideEncryptionByDefault?.KMSMasterKeyID
        ).toBeTruthy();
      }
    });

    test('S3 buckets have versioning enabled', async () => {
      const buckets = [
        outputs.s3_alb_logs_bucket?.value,
        outputs.s3_codepipeline_artifacts_bucket?.value,
        outputs.s3_cloudtrail_bucket?.value,
      ].filter(Boolean);

      for (const bucketName of buckets) {
        const versioningResponse = await s3Client.send(
          new GetBucketVersioningCommand({
            Bucket: bucketName!,
          })
        );

        expect(versioningResponse.Status).toBe('Enabled');
      }
    });

    test('S3 buckets have public access blocked', async () => {
      const buckets = [
        outputs.s3_alb_logs_bucket?.value,
        outputs.s3_codepipeline_artifacts_bucket?.value,
        outputs.s3_cloudtrail_bucket?.value,
      ].filter(Boolean);

      for (const bucketName of buckets) {
        const publicAccessResponse = await s3Client.send(
          new GetPublicAccessBlockCommand({
            Bucket: bucketName!,
          })
        );

        const config = publicAccessResponse.PublicAccessBlockConfiguration!;
        expect(config.BlockPublicAcls).toBe(true);
        expect(config.BlockPublicPolicy).toBe(true);
        expect(config.IgnorePublicAcls).toBe(true);
        expect(config.RestrictPublicBuckets).toBe(true);
      }
    });
  });

  describe('9. CloudTrail Validation', () => {
    test('CloudTrail is active and logging', async () => {
      const trailArn = outputs.cloudtrail_arn?.value;
      expect(trailArn).toBeTruthy();

      const trailName = trailArn!.split('/').pop();
      const response = await cloudTrailClient.send(
        new DescribeTrailsCommand({
          trailNameList: [trailName!],
        })
      );

      expect(response.trailList).toHaveLength(1);
      const trail = response.trailList![0];

      // Note: CloudTrail logging status is not returned in DescribeTrails
      // We just check that the trail exists and is configured properly
      expect(trail).toBeTruthy();
      expect(trail.S3BucketName).toBe(outputs.s3_cloudtrail_bucket?.value);
      expect(trail.KmsKeyId).toBeTruthy();
      expect(trail.IncludeGlobalServiceEvents).toBe(true);
    });

    test('CloudTrail is actively logging', async () => {
      const trailArn = outputs.cloudtrail_arn?.value;
      expect(trailArn).toBeTruthy();

      const trailName = trailArn!.split('/').pop();
      
      // Get trail status to verify it's logging
      const { GetTrailStatusCommand } = await import('@aws-sdk/client-cloudtrail');
      const statusResponse = await cloudTrailClient.send(
        new GetTrailStatusCommand({
          Name: trailName!,
        })
      );

      expect(statusResponse.IsLogging).toBe(true);
      expect(statusResponse.LatestDeliveryTime).toBeTruthy();
      
      // Verify no recent delivery errors
      if (statusResponse.LatestDeliveryError) {
        console.warn(`CloudTrail delivery error: ${statusResponse.LatestDeliveryError}`);
        console.warn(`Error time: ${statusResponse.LatestCloudWatchLogsDeliveryTime || 'Unknown'}`);
      }
    });

    test('CloudTrail event selectors are configured correctly', async () => {
      const trailArn = outputs.cloudtrail_arn?.value;
      expect(trailArn).toBeTruthy();

      const trailName = trailArn!.split('/').pop();
      
      // Get event selectors
      const { GetEventSelectorsCommand } = await import('@aws-sdk/client-cloudtrail');
      const eventSelectorsResponse = await cloudTrailClient.send(
        new GetEventSelectorsCommand({
          TrailName: trailName!,
        })
      );

      expect(eventSelectorsResponse.EventSelectors).toBeTruthy();
      expect(eventSelectorsResponse.EventSelectors!.length).toBeGreaterThan(0);
      
      const eventSelector = eventSelectorsResponse.EventSelectors![0];
      expect(eventSelector.ReadWriteType).toBe('All');
      expect(eventSelector.IncludeManagementEvents).toBe(true);
      
      // Verify exclusions for specific services as configured in Terraform
      const excludedSources = eventSelector.ExcludeManagementEventSources || [];
      expect(excludedSources).toContain('kms.amazonaws.com');
      expect(excludedSources).toContain('rdsdata.amazonaws.com');
    });

    test('CloudTrail S3 bucket policy allows CloudTrail access', async () => {
      const bucketName = outputs.s3_cloudtrail_bucket?.value;
      expect(bucketName).toBeTruthy();

      // Get bucket policy
      const { GetBucketPolicyCommand } = await import('@aws-sdk/client-s3');
      const policyResponse = await s3Client.send(
        new GetBucketPolicyCommand({
          Bucket: bucketName!,
        })
      );

      expect(policyResponse.Policy).toBeTruthy();
      const policy = JSON.parse(policyResponse.Policy!);
      expect(policy.Version).toBe('2012-10-17');
      expect(policy.Statement).toBeTruthy();
      expect(Array.isArray(policy.Statement)).toBe(true);

      // Verify CloudTrail AclCheck statement
      const aclCheckStatement = policy.Statement.find((stmt: any) =>
        stmt.Sid === 'AWSCloudTrailAclCheck' &&
        stmt.Effect === 'Allow' &&
        stmt.Action === 's3:GetBucketAcl'
      );
      expect(aclCheckStatement).toBeTruthy();
      expect(aclCheckStatement.Principal.Service).toBe('cloudtrail.amazonaws.com');
      expect(aclCheckStatement.Resource).toMatch(/arn:aws:s3:::/);

      // Verify CloudTrail Write statement
      const writeStatement = policy.Statement.find((stmt: any) =>
        stmt.Sid === 'AWSCloudTrailWrite' &&
        stmt.Effect === 'Allow' &&
        stmt.Action === 's3:PutObject'
      );
      expect(writeStatement).toBeTruthy();
      expect(writeStatement.Principal.Service).toBe('cloudtrail.amazonaws.com');
      expect(writeStatement.Resource).toMatch(/arn:aws:s3:::.*\/\*/);
      expect(writeStatement.Condition).toBeTruthy();
      expect(writeStatement.Condition.StringEquals).toBeTruthy();
      expect(writeStatement.Condition.StringEquals['s3:x-amz-acl']).toBe('bucket-owner-full-control');
    });

    test('ALB logs S3 bucket policy allows ELB service access', async () => {
      const bucketName = outputs.s3_alb_logs_bucket?.value;
      expect(bucketName).toBeTruthy();

      // Get bucket policy
      const { GetBucketPolicyCommand } = await import('@aws-sdk/client-s3');
      const policyResponse = await s3Client.send(
        new GetBucketPolicyCommand({
          Bucket: bucketName!,
        })
      );

      expect(policyResponse.Policy).toBeTruthy();
      const policy = JSON.parse(policyResponse.Policy!);
      expect(policy.Statement).toBeTruthy();

      // Find statements that allow ELB service account access
      const elbStatements = policy.Statement.filter((stmt: any) =>
        stmt.Effect === 'Allow' && 
        (stmt.Principal?.AWS || stmt.Principal?.Service)
      );
      expect(elbStatements.length).toBeGreaterThan(0);

      // Verify at least one statement allows s3:PutObject for ALB logs
      const putObjectStatement = elbStatements.find((stmt: any) =>
        stmt.Action === 's3:PutObject' || 
        (Array.isArray(stmt.Action) && stmt.Action.includes('s3:PutObject'))
      );
      expect(putObjectStatement).toBeTruthy();

      // Verify at least one statement allows s3:GetBucketAcl for ALB logs  
      const getBucketAclStatement = elbStatements.find((stmt: any) =>
        stmt.Action === 's3:GetBucketAcl' ||
        (Array.isArray(stmt.Action) && stmt.Action.includes('s3:GetBucketAcl'))
      );
      expect(getBucketAclStatement).toBeTruthy();
    });

    test('S3 bucket policies restrict public access', async () => {
      const buckets = [
        outputs.s3_alb_logs_bucket?.value,
        outputs.s3_codepipeline_artifacts_bucket?.value,
        outputs.s3_cloudtrail_bucket?.value,
      ].filter(Boolean);

      for (const bucketName of buckets) {
        // Check public access block configuration
        const { GetPublicAccessBlockCommand } = await import('@aws-sdk/client-s3');
        const publicAccessResponse = await s3Client.send(
          new GetPublicAccessBlockCommand({
            Bucket: bucketName!,
          })
        );

        const config = publicAccessResponse.PublicAccessBlockConfiguration!;
        expect(config.BlockPublicAcls).toBe(true);
        expect(config.BlockPublicPolicy).toBe(true);
        expect(config.IgnorePublicAcls).toBe(true);
        expect(config.RestrictPublicBuckets).toBe(true);

        // Verify bucket ACL doesn't allow public access
        const { GetBucketAclCommand } = await import('@aws-sdk/client-s3');
        const aclResponse = await s3Client.send(
          new GetBucketAclCommand({
            Bucket: bucketName!,
          })
        );

        expect(aclResponse.Grants).toBeTruthy();
        
        // Should not have any grants to AllUsers or AuthenticatedUsers
        const publicGrants = aclResponse.Grants!.filter(grant =>
          grant.Grantee?.URI?.includes('AllUsers') ||
          grant.Grantee?.URI?.includes('AuthenticatedUsers')
        );
        expect(publicGrants.length).toBe(0);
      }
    });

    test('S3 bucket policies enforce encryption', async () => {
      const buckets = [
        outputs.s3_alb_logs_bucket?.value,
        outputs.s3_codepipeline_artifacts_bucket?.value,
        outputs.s3_cloudtrail_bucket?.value,
      ].filter(Boolean);

      for (const bucketName of buckets) {
        try {
          const { GetBucketPolicyCommand } = await import('@aws-sdk/client-s3');
          const policyResponse = await s3Client.send(
            new GetBucketPolicyCommand({
              Bucket: bucketName!,
            })
          );

          const policy = JSON.parse(policyResponse.Policy!);
          
          // Look for statements that enforce encryption
          const encryptionStatements = policy.Statement.filter((stmt: any) =>
            stmt.Effect === 'Deny' && 
            stmt.Condition &&
            (stmt.Condition.Bool || stmt.Condition.StringNotEquals)
          );

          console.log(`Bucket ${bucketName} has ${encryptionStatements.length} encryption enforcement statements`);

          // While not all buckets may have explicit encryption enforcement policies,
          // they should at least have server-side encryption configuration
          const { GetBucketEncryptionCommand } = await import('@aws-sdk/client-s3');
          const encryptionResponse = await s3Client.send(
            new GetBucketEncryptionCommand({
              Bucket: bucketName!,
            })
          );

          expect(encryptionResponse.ServerSideEncryptionConfiguration).toBeTruthy();
          const rules = encryptionResponse.ServerSideEncryptionConfiguration!.Rules!;
          expect(rules.length).toBeGreaterThan(0);
          
          const rule = rules[0];
          expect(rule.ApplyServerSideEncryptionByDefault?.SSEAlgorithm).toBe('aws:kms');
          expect(rule.ApplyServerSideEncryptionByDefault?.KMSMasterKeyID).toBeTruthy();
          
        } catch (error) {
          // Some buckets might not have explicit bucket policies, which is OK if they have other security measures
          console.log(`Bucket ${bucketName} policy check: ${error}`);
        }
      }
    });
  });

  describe('10. CI/CD Pipeline Validation', () => {
    test('CodePipeline exists and is configured', async () => {
      const pipelineName = outputs.codepipeline_name?.value;
      expect(pipelineName).toBeTruthy();

      const response = await codePipelineClient.send(
        new GetPipelineCommand({
          name: pipelineName!,
        })
      );

      expect(response.pipeline).toBeTruthy();
      const pipeline = response.pipeline!;

      expect(pipeline.stages).toBeTruthy();
      expect(pipeline.stages!.length).toBeGreaterThanOrEqual(2);

      const stageNames = pipeline.stages!.map(stage => stage.name);
      expect(stageNames).toContain('Source');
      expect(stageNames).toContain('Build');

      expect(pipeline.artifactStore).toBeTruthy();
      expect(pipeline.artifactStore!.type).toBe('S3');
      expect(pipeline.artifactStore!.encryptionKey).toBeTruthy();
    });

    test('CodeBuild project is configured', async () => {
      const projectName = outputs.codebuild_project_name?.value;
      expect(projectName).toBeTruthy();

      const response = await codeBuildClient.send(
        new BatchGetProjectsCommand({
          names: [projectName!],
        })
      );

      expect(response.projects).toHaveLength(1);
      const project = response.projects![0];

      expect(project.serviceRole).toBeTruthy();
      expect(project.artifacts?.type).toBe('CODEPIPELINE');
      expect(project.environment?.type).toBe('LINUX_CONTAINER');
      expect(project.environment?.computeType).toBeTruthy();
    });

    test('CodePipeline has proper IAM roles and permissions', async () => {
      const pipelineName = outputs.codepipeline_name?.value;
      expect(pipelineName).toBeTruthy();

      const response = await codePipelineClient.send(
        new GetPipelineCommand({
          name: pipelineName!,
        })
      );

      const pipeline = response.pipeline!;
      expect(pipeline.roleArn).toBeTruthy();
      
      // Validate pipeline role ARN format
      expect(pipeline.roleArn).toMatch(/arn:aws:iam::\d+:role\/.+codepipeline.+/i);
      
      // Validate artifact store configuration
      expect(pipeline.artifactStore).toBeTruthy();
      expect(pipeline.artifactStore!.location).toBe(outputs.s3_codepipeline_artifacts_bucket?.value);
      expect(pipeline.artifactStore!.encryptionKey).toBeTruthy();
      expect(pipeline.artifactStore!.encryptionKey!.type).toBe('KMS');
      expect(pipeline.artifactStore!.encryptionKey!.id).toBe(outputs.kms_key_arn?.value);
    });

    test('CodePipeline stages are configured correctly', async () => {
      const pipelineName = outputs.codepipeline_name?.value;
      expect(pipelineName).toBeTruthy();

      const response = await codePipelineClient.send(
        new GetPipelineCommand({
          name: pipelineName!,
        })
      );

      const pipeline = response.pipeline!;
      const stageNames = pipeline.stages!.map(stage => stage.name);
      
      // Should have Source and Build stages at minimum
      expect(stageNames).toContain('Source');
      expect(stageNames).toContain('Build');

      // Validate Source stage
      const sourceStage = pipeline.stages!.find(stage => stage.name === 'Source');
      expect(sourceStage).toBeTruthy();
      expect(sourceStage!.actions).toBeTruthy();
      expect(sourceStage!.actions!.length).toBeGreaterThan(0);
      
      const sourceAction = sourceStage!.actions![0];
      expect(sourceAction.actionTypeId?.category).toBe('Source');
      expect(sourceAction.actionTypeId?.owner).toBe('AWS');
      expect(sourceAction.actionTypeId?.provider).toBe('CodeStarSourceConnection');
      expect(sourceAction.configuration?.FullRepositoryId).toBeTruthy();
      expect(sourceAction.configuration?.BranchName).toBeTruthy();
      expect(sourceAction.configuration?.ConnectionArn).toBeTruthy();

      // Validate Build stage
      const buildStage = pipeline.stages!.find(stage => stage.name === 'Build');
      expect(buildStage).toBeTruthy();
      expect(buildStage!.actions).toBeTruthy();
      expect(buildStage!.actions!.length).toBeGreaterThan(0);
      
      const buildAction = buildStage!.actions![0];
      expect(buildAction.actionTypeId?.category).toBe('Build');
      expect(buildAction.actionTypeId?.owner).toBe('AWS');
      expect(buildAction.actionTypeId?.provider).toBe('CodeBuild');
      expect(buildAction.configuration?.ProjectName).toBe(outputs.codebuild_project_name?.value);
    });

    test('CodePipeline execution history and status', async () => {
      const pipelineName = outputs.codepipeline_name?.value;
      expect(pipelineName).toBeTruthy();

      // Get pipeline execution history
      const { ListPipelineExecutionsCommand } = await import('@aws-sdk/client-codepipeline');
      const executionsResponse = await codePipelineClient.send(
        new ListPipelineExecutionsCommand({
          pipelineName: pipelineName!,
          maxResults: 10,
        })
      );

      expect(executionsResponse.pipelineExecutionSummaries).toBeTruthy();
      
      // If there are executions, validate their structure
      if (executionsResponse.pipelineExecutionSummaries!.length > 0) {
        const latestExecution = executionsResponse.pipelineExecutionSummaries![0];
        expect(latestExecution.pipelineExecutionId).toBeTruthy();
        expect(latestExecution.status).toBeTruthy();
        expect(['InProgress', 'Succeeded', 'Failed', 'Cancelled', 'Superseded']).toContain(latestExecution.status!);
        
        // Log execution status for debugging
        console.log(`Latest pipeline execution status: ${latestExecution.status}`);
        if (latestExecution.status === 'Failed') {
          console.warn(`Pipeline execution failed at: ${latestExecution.lastUpdateTime}`);
        }
      }
    });

    test('CodeBuild project has correct build specifications', async () => {
      const projectName = outputs.codebuild_project_name?.value;
      expect(projectName).toBeTruthy();

      const response = await codeBuildClient.send(
        new BatchGetProjectsCommand({
          names: [projectName!],
        })
      );

      const project = response.projects![0];

      // Validate environment settings
      expect(project.environment?.image).toBe('aws/codebuild/standard:5.0');
      expect(project.environment?.privilegedMode).toBe(false);
      expect(project.environment?.imagePullCredentialsType).toBe('CODEBUILD');

      // Validate service role
      expect(project.serviceRole).toMatch(/arn:aws:iam::\d+:role\/.+codebuild.+/i);

      // Validate source settings
      expect(project.source?.type).toBe('CODEPIPELINE');
      expect(project.source?.buildspec).toBe('buildspec.yml');

      // Validate artifacts
      expect(project.artifacts?.type).toBe('CODEPIPELINE');
    });

    test('CodeBuild project can access required resources', async () => {
      const projectName = outputs.codebuild_project_name?.value;
      expect(projectName).toBeTruthy();

      // Get build history to verify project can execute
      const { ListBuildsForProjectCommand } = await import('@aws-sdk/client-codebuild');
      const buildsResponse = await codeBuildClient.send(
        new ListBuildsForProjectCommand({
          projectName: projectName!,
          sortOrder: 'DESCENDING',
        })
      );

      expect(buildsResponse.ids).toBeTruthy();
      
      // If there are builds, check their status
      if (buildsResponse.ids!.length > 0) {
        const { BatchGetBuildsCommand } = await import('@aws-sdk/client-codebuild');
        const buildDetailsResponse = await codeBuildClient.send(
          new BatchGetBuildsCommand({
            ids: [buildsResponse.ids![0]], // Get latest build
          })
        );

        if (buildDetailsResponse.builds && buildDetailsResponse.builds.length > 0) {
          const latestBuild = buildDetailsResponse.builds[0];
          expect(latestBuild.buildStatus).toBeTruthy();
          expect(['IN_PROGRESS', 'SUCCEEDED', 'FAILED', 'FAULT', 'TIMED_OUT', 'STOPPED']).toContain(latestBuild.buildStatus!);
          
          // Log build status for debugging
          console.log(`Latest build status: ${latestBuild.buildStatus}`);
          if (latestBuild.buildStatus === 'FAILED') {
            console.warn(`Build failed at: ${latestBuild.endTime || latestBuild.startTime}`);
          }
        }
      }
    });

    test('CodeStar connection is configured and pending/available', async () => {
      const pipelineName = outputs.codepipeline_name?.value;
      expect(pipelineName).toBeTruthy();

      const response = await codePipelineClient.send(
        new GetPipelineCommand({
          name: pipelineName!,
        })
      );

      const pipeline = response.pipeline!;
      const sourceStage = pipeline.stages!.find(stage => stage.name === 'Source');
      const sourceAction = sourceStage!.actions![0];
      const connectionArn = sourceAction.configuration?.ConnectionArn;

      expect(connectionArn).toBeTruthy();
      expect(connectionArn).toMatch(/arn:aws:codestar-connections:.+:\d+:connection\/.+/);

      // Note: We can't directly test the connection status without additional permissions
      // but we can validate the ARN format and that it's configured in the pipeline
      console.log(`CodeStar connection ARN: ${connectionArn}`);
    });
  });

  describe('11. End-to-End Connectivity Tests', () => {
    test('NGINX service endpoint is reachable', async () => {
      const endpoint = outputs.nginx_service_endpoint?.value;
      expect(endpoint).toBeTruthy();

      // Note: In a real test, you might want to add HTTP connectivity tests
      // This validates the endpoint format and ALB DNS name structure
      expect(endpoint).toMatch(/^http:\/\//);
      expect(endpoint).toContain(outputs.alb_dns_name?.value!);
    });
  });

  describe('12. Resource Tagging Compliance', () => {
    test('All major resources have consistent tags', async () => {
      // This is a sampling test - in practice you'd check all resources
      const vpcId = outputs.vpc_id?.value;
      const vpcResponse = await ec2Client.send(
        new DescribeVpcsCommand({
          VpcIds: [vpcId!],
        })
      );

      const vpc = vpcResponse.Vpcs![0];
      const tags = vpc.Tags || [];
      const tagMap = Object.fromEntries(tags.map(t => [t.Key!, t.Value!]));

      expect(tagMap['Environment']).toBeTruthy();
      expect(tagMap['Project']).toBeTruthy();
      expect(tagMap['ManagedBy']).toBe('terraform');
      expect(tagMap['Owner']).toBeTruthy();
    });
  });
});
