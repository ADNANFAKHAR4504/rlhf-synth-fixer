# Payment Processing API Gateway - Infrastructure Prompt

Hey, I'm working on infrastructure for a fintech startup that needs to expose their payment processing microservice through a REST API. We've already got a Lambda function called 'payment-processor' running in the region, and now we need to put API Gateway in front of it so our mobile app can hit it securely. This is for actual payment processing, so we've got some pretty strict compliance requirements around authentication, throttling, and logging that we need to nail down.

For security and authentication, we absolutely need API key-based auth on this thing. Create an API key called 'mobile-app-key' with a proper description - this'll be what our mobile app uses to authenticate requests. Then set up a usage plan that enforces throttle limits of 100 requests per second with a daily quota of 10,000 requests per day. That should be plenty for our current user base while preventing any abuse or runaway costs. Associate that API key with the usage plan so the throttling actually gets enforced. All IAM roles need to follow least privilege principle since we're dealing with financial data here, so only grant the absolute minimum permissions needed for API Gateway to invoke the Lambda function.

The API itself should be a REST API named 'payment-api' with a clear description about what it does. I need a resource path at '/process-payment' with a POST method configured, and that method needs to require the API key we created earlier. The integration with the Lambda function needs to use AWS_PROXY integration type - that's important because we want the Lambda to receive the full request context and handle the response formatting itself. Make sure the API uses REGIONAL endpoint configuration, not edge-optimized, since our traffic is all coming from one geographic area anyway.

Oh, and super important - create an aws_lambda_permission resource so API Gateway is actually allowed to invoke that payment-processor Lambda. The principal should be apigateway.amazonaws.com and the source_arn should reference the API Gateway execution ARN. Without this permission, the integration will fail with 500 errors even though everything else looks right.

For CORS, the POST method responses need to include headers specifically for the origin https://app.example.com - our mobile app's backend domain. You'll need to set up the method response for the POST method with status code 200 and response parameters for Access-Control-Allow-Origin, Access-Control-Allow-Headers, and Access-Control-Allow-Methods. In the integration response, map Access-Control-Allow-Origin to 'https://app.example.com'. Since this is AWS_PROXY integration, the Lambda function will handle setting these headers in its response, but we need to declare them as allowed response headers in API Gateway.

For monitoring and compliance, we need CloudWatch logging enabled on the API Gateway with INFO level logging. This is non-negotiable for our auditors - they want to see every request that comes through. The log retention must be set to exactly 7 days, not more, not less - that's what our compliance team determined is the sweet spot between audit requirements and cost management. Make sure the logs capture enough detail to track who's calling the API and when, but don't log sensitive payment data. You'll need to create the CloudWatch log group and set up an IAM role that allows API Gateway to write logs to CloudWatch.

Once everything's configured, create a deployment to a 'prod' stage. We're skipping dev/staging for now and going straight to production since this is our MVP launch.

For file organization, just put everything in main.tf. I mean everything - the terraform and provider blocks at the top, then data sources for getting the existing Lambda function and current region info, then variables for the region and any configurable settings, then locals for common_tags and reusable values, then a random_string resource for unique naming where needed (8 chars, no special chars, lowercase only), then all the API Gateway resources organized with clear comment headers (the REST API, resources, methods, method responses, integration responses, API key, usage plan, Lambda permission, CloudWatch role and log group, deployment, and stage), and finally all the outputs at the bottom. Keep it all in one file, it's easier to manage for this scope.

Make sure to output the invoke URL so we can test it immediately, and also output the API key value - we'll need that to give to the mobile team. The invoke URL should be the full HTTPS endpoint for the prod stage that we can hit with curl or Postman.