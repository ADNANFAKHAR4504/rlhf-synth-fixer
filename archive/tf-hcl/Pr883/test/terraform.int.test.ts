import * as fs from 'fs';
import * as path from 'path';
import {
  EC2Client,
  DescribeInstancesCommand,
  Instance,
  DescribeVolumesCommand,
  DescribeSecurityGroupsCommand,
  DescribeVpcsCommand,
  DescribeSubnetsCommand,
  DescribeRouteTablesCommand,
  DescribeInternetGatewaysCommand,
} from '@aws-sdk/client-ec2';
import {
  KMSClient,
  DescribeKeyCommand,
  ListAliasesCommand,
} from '@aws-sdk/client-kms';
import {
  S3Client,
  GetBucketEncryptionCommand,
  GetPublicAccessBlockCommand,
} from '@aws-sdk/client-s3';
import {
  ConfigServiceClient,
  DescribeConfigRulesCommand,
} from '@aws-sdk/client-config-service';

/* ----------------------------- Utilities & Types ----------------------------- */

// Type definition for the structure of the Terraform output JSON
type TfOutputValue<T> = { sensitive: boolean; type: any; value: T };
type DeploymentSummary = {
  [region: string]: {
    s3_bucket_name: string;
    ec2_instance_id: string;
    kms_key_arn: string;
  };
};
type StructuredOutputs = {
  deployment_summary: TfOutputValue<DeploymentSummary>;
};

/**
 * Reads and validates the structured outputs from the CI/CD pipeline.
 * @returns The parsed and validated deployment summary.
 */
function readDeploymentOutputs(): DeploymentSummary {
  const filePath = path.resolve(process.cwd(), 'cfn-outputs/all-outputs.json');
  if (!fs.existsSync(filePath)) {
    throw new Error(
      `Outputs file not found at ${filePath}. This file must be generated by the CI/CD 'Get Deployment Outputs' stage.`
    );
  }
  const outputs = JSON.parse(
    fs.readFileSync(filePath, 'utf8')
  ) as StructuredOutputs;

  const summary = outputs.deployment_summary?.value;
  if (!summary) {
    throw new Error('`deployment_summary` missing in outputs file.');
  }

  const expectedRegions = ['eu-north-1', 'us-west-2'];
  for (const region of expectedRegions) {
    if (
      !summary[region]?.s3_bucket_name ||
      !summary[region]?.ec2_instance_id ||
      !summary[region]?.kms_key_arn
    ) {
      throw new Error(
        `Output for region '${region}' is incomplete. Check s3_bucket_name, ec2_instance_id, and kms_key_arn.`
      );
    }
  }

  return summary;
}

/**
 * A simple retry mechanism for eventually consistent AWS API calls.
 */
async function retry<T>(
  fn: () => Promise<T>,
  attempts = 5,
  delayMs = 2000
): Promise<T> {
  let lastError: any;
  for (let i = 0; i < attempts; i++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error;
      await new Promise(resolve => setTimeout(resolve, delayMs * (i + 1)));
    }
  }
  throw lastError;
}

/* ----------------------------- Test Suite ----------------------------- */

describe('LIVE: Multi-Region AWS Infrastructure Integration Tests', () => {
  const outputs = readDeploymentOutputs();
  const regions = Object.keys(outputs);
  const TEST_TIMEOUT = 180_000; // 3 minutes per test

  it('should have deployed to eu-north-1 and us-west-2 regions', () => {
    expect(regions).toContain('eu-north-1');
    expect(regions).toContain('us-west-2');
    expect(regions).toHaveLength(2);
  });

  for (const region of regions) {
    describe(`Region: ${region}`, () => {
      const regionOutputs = outputs[region];
      const ec2Client = new EC2Client({ region });
      const configClient = new ConfigServiceClient({ region });

      test(
        'EC2 Instance and its dependencies should be secure and correctly configured',
        async () => {
          const instanceData = await retry(() =>
            ec2Client.send(
              new DescribeInstancesCommand({
                InstanceIds: [regionOutputs.ec2_instance_id],
              })
            )
          );
          const instance: Instance | undefined =
            instanceData.Reservations?.[0]?.Instances?.[0];
          expect(instance).toBeDefined();

          // 1. Check basic instance properties
          expect(instance?.InstanceType).toBe('t3.micro');
          expect(instance?.State?.Name).toBe('running');

          // 2. Check for IAM Instance Profile
          expect(instance?.IamInstanceProfile?.Arn).toContain(
            'nova-ec2-instance-profile-291844'
          );

          // 3. Check Security Group rules
          const sgId = instance?.SecurityGroups?.[0]?.GroupId;
          expect(sgId).toBeDefined();
          const sgData = await ec2Client.send(
            new DescribeSecurityGroupsCommand({ GroupIds: [sgId!] })
          );
          const sshRule = sgData.SecurityGroups?.[0]?.IpPermissions?.find(
            p => p.FromPort === 22
          );
          expect(sshRule).toBeDefined();
          expect(sshRule?.IpRanges?.[0]?.CidrIp).not.toBe('0.0.0.0/0'); // Verify SSH is not open to the world

          // 4. Check for encrypted root volume
          const rootDeviceName = instance?.RootDeviceName;
          expect(rootDeviceName).toBeDefined();
          const rootVolume = instance?.BlockDeviceMappings?.find(
            bdm => bdm.DeviceName === rootDeviceName
          );
          expect(rootVolume?.Ebs?.VolumeId).toBeDefined();

          // 5. Verify root volume encryption with the correct custom KMS key
          if (rootVolume?.Ebs?.VolumeId) {
            const volumeData = await retry(() =>
              ec2Client.send(
                new DescribeVolumesCommand({
                  VolumeIds: [rootVolume.Ebs!.VolumeId!],
                })
              )
            );
            const volume = volumeData.Volumes?.[0];
            expect(volume?.Encrypted).toBe(true);
            expect(volume?.KmsKeyId).toBe(regionOutputs.kms_key_arn);
          }
        },
        TEST_TIMEOUT
      );

      test(
        'Network infrastructure (VPC, Subnet, IGW, Routing) should be correctly configured',
        async () => {
          // 1. Get instance details to find network components
          const instanceData = await retry(() =>
            ec2Client.send(
              new DescribeInstancesCommand({
                InstanceIds: [regionOutputs.ec2_instance_id],
              })
            )
          );
          const instance: Instance | undefined =
            instanceData.Reservations?.[0]?.Instances?.[0];
          expect(instance).toBeDefined();

          const vpcId = instance?.VpcId;
          const subnetId = instance?.SubnetId;
          expect(vpcId).toBeDefined();
          expect(subnetId).toBeDefined();

          // 2. Verify the VPC is a custom VPC
          const vpcData = await ec2Client.send(
            new DescribeVpcsCommand({ VpcIds: [vpcId!] })
          );
          expect(vpcData.Vpcs?.[0]?.IsDefault).toBe(false);

          // 3. Verify the Subnet is in the correct VPC and has public IP mapping
          const subnetData = await ec2Client.send(
            new DescribeSubnetsCommand({ SubnetIds: [subnetId!] })
          );
          const subnet = subnetData.Subnets?.[0];
          expect(subnet?.VpcId).toBe(vpcId);

          // 4. Verify the route table has a default route to an Internet Gateway
          const routeTableData = await ec2Client.send(
            new DescribeRouteTablesCommand({
              Filters: [{ Name: 'association.subnet-id', Values: [subnetId!] }],
            })
          );
          const routeTable = routeTableData.RouteTables?.[0];
          const defaultRoute = routeTable?.Routes?.find(
            r => r.DestinationCidrBlock === '0.0.0.0/0'
          );
          const igwId = defaultRoute?.GatewayId;
          expect(igwId).toBeDefined();
          expect(igwId).toMatch(/^igw-/);

          // 5. Verify the Internet Gateway is attached to the VPC
          const igwData = await ec2Client.send(
            new DescribeInternetGatewaysCommand({
              InternetGatewayIds: [igwId!],
            })
          );
          expect(igwData.InternetGateways?.[0]?.Attachments?.[0]?.VpcId).toBe(
            vpcId
          );
        },
        TEST_TIMEOUT
      );

      test(
        'AWS Config rules for compliance should be deployed and active',
        async () => {
          const expectedRules = [
            'S3_BUCKET_SERVER_SIDE_ENCRYPTION_ENABLED',
            'ENCRYPTED_VOLUMES',
            'IAM_ROLE_MANAGED_POLICY_CHECK',
          ];

          const rulesData = await retry(() =>
            configClient.send(
              new DescribeConfigRulesCommand({ ConfigRuleNames: expectedRules })
            )
          );
          const deployedRuleNames =
            rulesData.ConfigRules?.map(r => r.ConfigRuleName) || [];
          expect(deployedRuleNames).toHaveLength(expectedRules.length);
          expect(deployedRuleNames).toEqual(
            expect.arrayContaining(expectedRules)
          );

          for (const rule of rulesData.ConfigRules || []) {
            expect(rule.ConfigRuleState).toBe('ACTIVE');
          }
        },
        TEST_TIMEOUT
      );
    });
  }
});
