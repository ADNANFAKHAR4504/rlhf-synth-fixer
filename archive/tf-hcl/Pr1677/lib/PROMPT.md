Here’s a more natural, human-written prompt you can paste into Claude:

I’m wiring up AWS IAM with Terraform and I need production-ready HCL that’s secure, audit-friendly, and easy to extend. Please write the code so it passes SOC 2/GDPR scrutiny and follows least-privilege by default—no blanket wildcards; scope actions to specific resources and use `Condition` where it makes sense. Tag every IAM resource for auditability with `owner`, `purpose`, and `env`, and use a consistent `Name`. All roles and policy names should start with `corp-`. The estate span multiple AWS accounts and two regions (us-east-1 and eu-west-1), and some roles will be assumed cross-account (think `assume_role` with an optional external ID).

Keep the repo simple: Terraform v1.0+ with the AWS provider, and put everything in exactly two files at the root—`provider.tf` and `tap_stack.tf`. No extra folders or files, no Terragrunt.

In `provider.tf`, include: the Terraform and provider blocks (pin the AWS provider version); default region `us-east-1` plus an `eu` alias for `eu-west-1`; an example of assuming into a target account via `assume_role` (account ID and role name as variables); and `default_tags` so `owner`, `purpose`, and `env` flow everywhere.

In `tap_stack.tf`, set up `locals` for `name_prefix = "corp-"` and a `common_tags` map that gets merged into all resources. Add a practical permission boundary that blocks dangerous patterns (e.g., no wildcard admin, restrict actions to the two allowed regions, and deny sensitive console actions if `aws:MultiFactorAuthPresent` is false). Keep it tight and comment briefly on why each restriction exists. Model roles from a single `var.roles` map so I can define multiple roles at once. For each role, I want a trust policy (via `aws_iam_policy_document`) that can handle same-account or cross-account principals and optionally requires an external ID; one or more least-privilege inline policies (prefer `aws_iam_policy_document` + `aws_iam_role_policy`; attach AWS managed policies only when truly appropriate); the permission boundary attached; and names shaped like `corp-<purpose>-<env>` (e.g., `corp-ci-deployer-dev`). Please include three clear examples:
• `corp-security-auditor-ENV`: focused read access for SOC 2 evidence (logs, IAM read, Config read, CloudTrail read) without resorting to a giant “read-everything” policy.
• `corp-ci-deployer-ENV`: can assume a narrow set of deploy roles and write only to specific resources/paths (show resource-level scoping).
• `corp-breakglass-ENV`: powerful but contained by the permission boundary, with short session duration and comments on when/how it’s used.

Expose variables for `env` (`dev` | `staging` | `prod`), `owner`, `purpose`, `target_account_id`, `external_id` (optional), and `roles` (a map/object describing purpose, trusted principals, and allowed actions/resources). Add outputs for each role ARN, the permission boundary ARN, and a flattened list of final tags.

Sprinkle short comments that tie choices to SOC 2/GDPR expectations (e.g., MFA requirements = stronger access control; permission boundary = preventive control; tagging = asset inventory & traceability). As a comment, include a tiny CI snippet showing `terraform fmt -check`, `terraform validate`, `tflint`, and `checkov`. Also add a couple of “sanity” examples in comments—e.g., show that a wildcard action would be blocked by the boundary, and that a user without MFA can’t perform a sensitive action.

Style-wise, keep it tidy and straightforward. Prefer `aws_iam_policy_document` over raw JSON blobs, use realistic names with the `corp-` prefix and an `env` suffix, and don’t over-engineer—make it easy to extend to edit `var.roles`. Return only the two files, `provider.tf` and `tap_stack.tf`, with the code and comments described above.
