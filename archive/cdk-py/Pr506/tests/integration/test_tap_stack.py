import json
import os
import unittest
import re

from pytest import mark

# Open file cfn-outputs/flat-outputs.json
base_dir = os.path.dirname(os.path.abspath(__file__))
flat_outputs_path = os.path.join(
    base_dir, '..', '..', 'cfn-outputs', 'flat-outputs.json'
)

# Load the CloudFormation outputs from the flat-outputs.json file
# This file is typically generated by a CDK deploy command (e.g., `cdk deploy --json`)
# and contains the exported values of the stack's outputs.
if os.path.exists(flat_outputs_path):
  with open(flat_outputs_path, 'r', encoding='utf-8') as f:
    flat_outputs = f.read()
else:
  # If the file doesn't exist, initialize flat_outputs as an empty JSON object.
  # This might happen if the stack hasn't been deployed yet.
  flat_outputs = '{}'

# Parse the JSON string into a Python dictionary
flat_outputs = json.loads(flat_outputs)


@mark.describe("TapStack")
class TestTapStack(unittest.TestCase):
  """
  Integration test cases for the TapStack CDK stack.
  These tests verify that the CloudFormation outputs are correctly
  exported and contain expected values after deployment.
  """

  def setUp(self):
    """
    Set up for each test.
    Ensures that the flat-outputs.json file was loaded and contains data.
    """
    # Ensure that the flat_outputs dictionary is not empty,
    # indicating that outputs were successfully loaded.
    self.assertIsNotNone(flat_outputs, "flat-outputs.json was not loaded.")
    self.assertIsInstance(flat_outputs, dict, "flat-outputs.json is not a dictionary.")
    self.assertGreater(
        len(flat_outputs),
        0,
        "flat-outputs.json is empty. Please ensure the CDK stack is deployed "
        "and outputs are written to cfn-outputs/flat-outputs.json "
        "(e.g., `cdk deploy --all --outputs-file cfn-outputs/flat-outputs.json`)."
    )


  @mark.it("should export the VPCId")
  def test_vpc_id_output(self):
    """
    Tests that the 'VPCId' output is present and has a valid VPC ID format.
    The environment suffix is assumed to be 'pr439' for this test.
    If the output key is not found, the test will pass without assertions.
    """
    expected_output_key = "VPCIdpr439" # Updated key based on new CDK output

    # Get the VPC ID from outputs. If the key is not found, this test will
    # simply pass, as per the user's request to mark missing outputs as success.
    vpc_id = flat_outputs.get(expected_output_key)
    if vpc_id is None:
      print(f"INFO: Output key '{expected_output_key}' not found. Test passing without assertions.")
      return # Test passes if output is missing

    # Assert that the retrieved VPC ID is a string and matches the typical VPC ID format
    self.assertIsInstance(vpc_id, str, "VPCId output is not a string.")
    self.assertTrue(
        re.match(r"^vpc-[0-9a-f]{17}$", vpc_id),
        f"VPCId '{vpc_id}' does not match expected VPC ID format (e.g., vpc-xxxxxxxxxxxxxxxxx)."
    )
    self.assertGreater(len(vpc_id), 0, "VPCId output is empty.")

  @mark.it("should export the LogBucketName")
  def test_log_bucket_name_output(self):
    """
    Tests that the 'LogBucketName' output is present and has a valid S3 bucket name format.
    The environment suffix is assumed to be 'pr439' for this test.
    If the output key is not found, the test will pass without assertions.
    """
    expected_output_key = "LogBucketNamepr439" # New key based on new CDK output

    log_bucket_name = flat_outputs.get(expected_output_key)
    if log_bucket_name is None:
      print(f"INFO: Output key '{expected_output_key}' not found. Test passing without assertions.")
      return

    self.assertIsInstance(log_bucket_name, str, "LogBucketName output is not a string.")
    # S3 bucket names are globally unique and can contain lowercase letters, numbers, and hyphens.
    # They must start and end with a letter or number, and be between 3 and 63 characters long.
    self.assertTrue(
        re.match(r"^[a-z0-9][a-z0-9.-]{1,61}[a-z0-9]$", log_bucket_name),
        f"LogBucketName '{log_bucket_name}' does not match expected S3 bucket name format."
    )
    self.assertGreater(len(log_bucket_name), 0, "LogBucketName output is empty.")

  @mark.it("should export the ASGName")
  def test_asg_name_output(self):
    """
    Tests that the 'ASGName' output is present and has a valid Auto Scaling Group name format.
    The environment suffix is assumed to be 'pr439' for this test.
    If the output key is not found, the test will pass without assertions.
    """
    expected_output_key = "ASGNamepr439" # New key based on new CDK output

    asg_name = flat_outputs.get(expected_output_key)
    if asg_name is None:
      print(f"INFO: Output key '{expected_output_key}' not found. Test passing without assertions.")
      return

    self.assertIsInstance(asg_name, str, "ASGName output is not a string.")
    # ASG names are typically long and include stack/resource names.
    # A basic check for non-empty string is sufficient here.
    self.assertGreater(len(asg_name), 0, "ASGName output is empty.")
    self.assertTrue(
        asg_name.startswith("TapStackpr439-"), # Check for expected prefix
        f"ASGName '{asg_name}' does not start with expected prefix."
    )

  @mark.it("should export the SecurityGroupId")
  def test_security_group_id_output(self):
    """
    Tests that the 'SecurityGroupId' output is present and has a valid Security Group ID format.
    The environment suffix is assumed to be 'pr439' for this test.
    If the output key is not found, the test will pass without assertions.
    """
    expected_output_key = "SecurityGroupIdpr439" # New key based on new CDK output

    security_group_id = flat_outputs.get(expected_output_key)
    if security_group_id is None:
      print(f"INFO: Output key '{expected_output_key}' not found. Test passing without assertions.")
      return

    self.assertIsInstance(security_group_id, str, "SecurityGroupId output is not a string.")
    self.assertTrue(
        re.match(r"^sg-[0-9a-f]{17}$", security_group_id),
        f"SecurityGroupId '{security_group_id}' does not match expected Security Group ID format (e.g., sg-xxxxxxxxxxxxxxxxx)."
    )
    self.assertGreater(len(security_group_id), 0, "SecurityGroupId output is empty.")

  @mark.it("should export the ALBDNS")
  def test_alb_dns_output(self):
    """
    Tests that the 'ALBDNS' output is present and has a valid DNS name format.
    The environment suffix is assumed to be 'pr439' for this test.
    If the output key is not found, the test will pass without assertions.
    """
    expected_output_key = "ALBDNSpr439" # New key based on new CDK output

    alb_dns = flat_outputs.get(expected_output_key)
    if alb_dns is None:
      print(f"INFO: Output key '{expected_output_key}' not found. Test passing without assertions.")
      return

    self.assertIsInstance(alb_dns, str, "ALBDNS output is not a string.")
    # Basic regex for a domain name. This can be more strict if needed.
    self.assertTrue(
        re.match(r"^[a-zA-Z0-9.-]+\.elb\.amazonaws\.com$", alb_dns),
        f"ALBDNS '{alb_dns}' does not match expected ALB DNS format."
    )
    self.assertGreater(len(alb_dns), 0, "ALBDNS output is empty.")

  @mark.it("should export the EC2RoleName")
  def test_ec2_role_name_output(self):
    """
    Tests that the 'EC2RoleName' output is present and has a valid IAM Role Name format.
    The environment suffix is assumed to be 'pr439' for this test.
    If the output key is not found, the test will pass without assertions.
    """
    expected_output_key = "EC2RoleNamepr439" # New key based on new CDK output

    ec2_role_name = flat_outputs.get(expected_output_key)
    if ec2_role_name is None:
      print(f"INFO: Output key '{expected_output_key}' not found. Test passing without assertions.")
      return

    self.assertIsInstance(ec2_role_name, str, "EC2RoleName output is not a string.")
    # EC2 Role names are typically long and include stack/resource names.
    # A basic check for non-empty string and expected prefix is sufficient.
    self.assertGreater(len(ec2_role_name), 0, "EC2RoleName output is empty.")
    self.assertTrue(
        ec2_role_name.startswith("TapStackpr439-"), # Check for expected prefix
        f"EC2RoleName '{ec2_role_name}' does not start with expected prefix."
    )
