import fs from 'fs';
import path from 'path';

const environmentSuffix = process.env.ENVIRONMENT_SUFFIX || 'test';

describe('Aurora Global Database CloudFormation Template - Unit Tests', () => {
  let template: any;

  beforeAll(() => {
    const templatePath = path.join(__dirname, '../lib/TapStack.json');
    const templateContent = fs.readFileSync(templatePath, 'utf8');
    template = JSON.parse(templateContent);
  });

  describe('Template Structure', () => {
    test('should have valid CloudFormation format version', () => {
      expect(template.AWSTemplateFormatVersion).toBe('2010-09-09');
    });

    test('should have Aurora Global Database description', () => {
      expect(template.Description).toBeDefined();
      expect(template.Description).toContain('Aurora Global Database');
      expect(template.Description).toContain('Cross-Region Disaster Recovery');
    });

    test('should have all required sections', () => {
      expect(template.Parameters).toBeDefined();
      expect(template.Conditions).toBeDefined();
      expect(template.Resources).toBeDefined();
      expect(template.Outputs).toBeDefined();
    });
  });

  describe('Parameters', () => {
    test('should have EnvironmentSuffix parameter with correct validation', () => {
      const param = template.Parameters.EnvironmentSuffix;
      expect(param).toBeDefined();
      expect(param.Type).toBe('String');
      expect(param.AllowedPattern).toBe('^[a-z0-9-]{3,20}$');
      expect(param.ConstraintDescription).toContain('lowercase');
    });

    test('should have database configuration parameters', () => {
      expect(template.Parameters.DatabaseName).toBeDefined();
      expect(template.Parameters.MasterUsername).toBeDefined();
      // MasterUserPassword parameter removed - password is now auto-generated by Secrets Manager
      // expect(template.Parameters.MasterUserPassword).toBeDefined();
      // expect(template.Parameters.MasterUserPassword.NoEcho).toBe(true);
    });

    test('should have DBInstanceClass parameter with valid instance types', () => {
      const param = template.Parameters.DBInstanceClass;
      expect(param).toBeDefined();
      expect(param.Default).toBe('db.r6g.large');
      expect(param.AllowedValues).toContain('db.r6g.large');
      expect(param.AllowedValues).toContain('db.r5.large');
    });

    test('should have monitoring parameters', () => {
      expect(template.Parameters.EnableEnhancedMonitoring).toBeDefined();
      expect(template.Parameters.MonitoringInterval).toBeDefined();
      expect(template.Parameters.EnablePerformanceInsights).toBeDefined();
      expect(template.Parameters.PerformanceInsightsRetention).toBeDefined();
    });

    test('should have BackupRetentionPeriod with valid range', () => {
      const param = template.Parameters.BackupRetentionPeriod;
      expect(param).toBeDefined();
      expect(param.Type).toBe('Number');
      expect(param.MinValue).toBe(1);
      expect(param.MaxValue).toBe(35);
      expect(param.Default).toBe(7);
    });

    test('should have AlarmEmail parameter with email validation', () => {
      const param = template.Parameters.AlarmEmail;
      expect(param).toBeDefined();
      expect(param.Type).toBe('String');
      expect(param.AllowedPattern).toContain('@');
    });
  });

  describe('Conditions', () => {
    test('should have EnableEnhancedMonitoringCondition', () => {
      const condition = template.Conditions.EnableEnhancedMonitoringCondition;
      expect(condition).toBeDefined();
      expect(condition['Fn::Equals']).toBeDefined();
      expect(condition['Fn::Equals'][0]).toEqual({ Ref: 'EnableEnhancedMonitoring' });
      expect(condition['Fn::Equals'][1]).toBe('true');
    });

    test('should have EnablePerformanceInsightsCondition', () => {
      const condition = template.Conditions.EnablePerformanceInsightsCondition;
      expect(condition).toBeDefined();
      expect(condition['Fn::Equals']).toBeDefined();
    });
  });

  describe('VPC and Networking Resources', () => {
    test('should have PrimaryVPC resource', () => {
      const vpc = template.Resources.PrimaryVPC;
      expect(vpc).toBeDefined();
      expect(vpc.Type).toBe('AWS::EC2::VPC');
      expect(vpc.Properties.CidrBlock).toBe('10.0.0.0/16');
      expect(vpc.Properties.EnableDnsHostnames).toBe(true);
      expect(vpc.Properties.EnableDnsSupport).toBe(true);
    });

    test('should have three primary subnets across availability zones', () => {
      expect(template.Resources.PrimarySubnet1).toBeDefined();
      expect(template.Resources.PrimarySubnet2).toBeDefined();
      expect(template.Resources.PrimarySubnet3).toBeDefined();

      const subnet1 = template.Resources.PrimarySubnet1;
      expect(subnet1.Type).toBe('AWS::EC2::Subnet');
      expect(subnet1.Properties.CidrBlock).toBe('10.0.1.0/24');
      expect(subnet1.Properties.MapPublicIpOnLaunch).toBe(false);
    });

    test('should have PrimaryDBSubnetGroup with all subnets', () => {
      const subnetGroup = template.Resources.PrimaryDBSubnetGroup;
      expect(subnetGroup).toBeDefined();
      expect(subnetGroup.Type).toBe('AWS::RDS::DBSubnetGroup');
      expect(subnetGroup.Properties.SubnetIds).toHaveLength(3);
      expect(subnetGroup.Properties.SubnetIds).toContainEqual({ Ref: 'PrimarySubnet1' });
      expect(subnetGroup.Properties.SubnetIds).toContainEqual({ Ref: 'PrimarySubnet2' });
      expect(subnetGroup.Properties.SubnetIds).toContainEqual({ Ref: 'PrimarySubnet3' });
    });

    test('should have PrimarySecurityGroup with restrictive rules', () => {
      const sg = template.Resources.PrimarySecurityGroup;
      expect(sg).toBeDefined();
      expect(sg.Type).toBe('AWS::EC2::SecurityGroup');

      const ingress = sg.Properties.SecurityGroupIngress;
      expect(ingress).toHaveLength(1);
      expect(ingress[0].IpProtocol).toBe('tcp');
      expect(ingress[0].FromPort).toBe(5432);
      expect(ingress[0].ToPort).toBe(5432);
      expect(ingress[0].CidrIp).toBe('10.0.0.0/16');
    });
  });

  describe('IAM Resources', () => {
    test('should have EnhancedMonitoringRole with correct condition', () => {
      const role = template.Resources.EnhancedMonitoringRole;
      expect(role).toBeDefined();
      expect(role.Type).toBe('AWS::IAM::Role');
      expect(role.Condition).toBe('EnableEnhancedMonitoringCondition');
    });

    test('EnhancedMonitoringRole should have correct assume role policy', () => {
      const role = template.Resources.EnhancedMonitoringRole;
      const assumeRole = role.Properties.AssumeRolePolicyDocument;
      expect(assumeRole.Statement[0].Principal.Service).toBe('monitoring.rds.amazonaws.com');
      expect(assumeRole.Statement[0].Action).toBe('sts:AssumeRole');
    });

    test('EnhancedMonitoringRole should have correct managed policy', () => {
      const role = template.Resources.EnhancedMonitoringRole;
      expect(role.Properties.ManagedPolicyArns).toContainEqual(
        'arn:aws:iam::aws:policy/service-role/AmazonRDSEnhancedMonitoringRole'
      );
    });
  });

  describe('Aurora Global Database Resources', () => {
    test('should have GlobalCluster resource', () => {
      const cluster = template.Resources.GlobalCluster;
      expect(cluster).toBeDefined();
      expect(cluster.Type).toBe('AWS::RDS::GlobalCluster');
      expect(cluster.Properties.Engine).toBe('aurora-postgresql');
      expect(cluster.Properties.EngineVersion).toBe('14.6');
      expect(cluster.Properties.StorageEncrypted).toBe(true);
    });

    test('GlobalCluster should have DeletionProtection disabled for testing', () => {
      const cluster = template.Resources.GlobalCluster;
      expect(cluster.Properties.DeletionProtection).toBe(false);
    });

    test('should have PrimaryDBClusterParameterGroup', () => {
      const paramGroup = template.Resources.PrimaryDBClusterParameterGroup;
      expect(paramGroup).toBeDefined();
      expect(paramGroup.Type).toBe('AWS::RDS::DBClusterParameterGroup');
      expect(paramGroup.Properties.Family).toBe('aurora-postgresql14');
      expect(paramGroup.Properties.Parameters['rds.force_ssl']).toBe('1');
    });

    test('should have PrimaryDBParameterGroup', () => {
      const paramGroup = template.Resources.PrimaryDBParameterGroup;
      expect(paramGroup).toBeDefined();
      expect(paramGroup.Type).toBe('AWS::RDS::DBParameterGroup');
      expect(paramGroup.Properties.Family).toBe('aurora-postgresql14');
    });

    test('should have PrimaryDBCluster with correct configuration', () => {
      const cluster = template.Resources.PrimaryDBCluster;
      expect(cluster).toBeDefined();
      expect(cluster.Type).toBe('AWS::RDS::DBCluster');
      // DependsOn is now an array containing DatabaseSecret
      expect(cluster.DependsOn).toBeDefined();
      expect(Array.isArray(cluster.DependsOn)).toBe(true);
      expect(cluster.DependsOn).toContain('DatabaseSecret');
      expect(cluster.Properties.Engine).toBe('aurora-postgresql');
      expect(cluster.Properties.StorageEncrypted).toBe(true);
      expect(cluster.Properties.EnableIAMDatabaseAuthentication).toBe(true);
      expect(cluster.Properties.DeletionProtection).toBe(false);
    });

    test('PrimaryDBCluster should enable CloudWatch Logs export', () => {
      const cluster = template.Resources.PrimaryDBCluster;
      expect(cluster.Properties.EnableCloudwatchLogsExports).toContainEqual('postgresql');
    });

    test('should have two primary DB instances', () => {
      const instance1 = template.Resources.PrimaryDBInstance1;
      const instance2 = template.Resources.PrimaryDBInstance2;

      expect(instance1).toBeDefined();
      expect(instance2).toBeDefined();
      expect(instance1.Type).toBe('AWS::RDS::DBInstance');
      expect(instance2.Type).toBe('AWS::RDS::DBInstance');
    });

    test('primary DB instances should have correct promotion tiers', () => {
      const instance1 = template.Resources.PrimaryDBInstance1;
      const instance2 = template.Resources.PrimaryDBInstance2;

      expect(instance1.Properties.PromotionTier).toBe(1);
      expect(instance2.Properties.PromotionTier).toBe(2);
    });

    test('primary DB instances should not be publicly accessible', () => {
      const instance1 = template.Resources.PrimaryDBInstance1;
      const instance2 = template.Resources.PrimaryDBInstance2;

      expect(instance1.Properties.PubliclyAccessible).toBe(false);
      expect(instance2.Properties.PubliclyAccessible).toBe(false);
    });

    test('primary DB instances should have conditional monitoring configuration', () => {
      const instance1 = template.Resources.PrimaryDBInstance1;

      expect(instance1.Properties.MonitoringRoleArn).toBeDefined();
      expect(instance1.Properties.MonitoringRoleArn['Fn::If']).toBeDefined();
      expect(instance1.Properties.MonitoringRoleArn['Fn::If'][0]).toBe('EnableEnhancedMonitoringCondition');
    });
  });

  describe('Monitoring and Alerting Resources', () => {
    test('should have AlarmTopic SNS topic', () => {
      const topic = template.Resources.AlarmTopic;
      expect(topic).toBeDefined();
      expect(topic.Type).toBe('AWS::SNS::Topic');
      // Subscription is now conditional - check for Fn::If structure
      expect(topic.Properties.Subscription).toBeDefined();
      expect(topic.Properties.Subscription['Fn::If']).toBeDefined();
      expect(topic.Properties.Subscription['Fn::If'][0]).toBe('HasAlarmEmail');
      // Check the subscription structure when email is provided
      const subscriptionArray = topic.Properties.Subscription['Fn::If'][1];
      expect(Array.isArray(subscriptionArray)).toBe(true);
      expect(subscriptionArray[0].Protocol).toBe('email');
      expect(subscriptionArray[0].Endpoint).toEqual({ Ref: 'AlarmEmail' });
    });

    test('should have PrimaryCPUAlarm', () => {
      const alarm = template.Resources.PrimaryCPUAlarm;
      expect(alarm).toBeDefined();
      expect(alarm.Type).toBe('AWS::CloudWatch::Alarm');
      expect(alarm.Properties.MetricName).toBe('CPUUtilization');
      expect(alarm.Properties.Threshold).toBe(80);
      expect(alarm.Properties.ComparisonOperator).toBe('GreaterThanThreshold');
    });

    test('should have PrimaryConnectionsAlarm', () => {
      const alarm = template.Resources.PrimaryConnectionsAlarm;
      expect(alarm).toBeDefined();
      expect(alarm.Properties.MetricName).toBe('DatabaseConnections');
      expect(alarm.Properties.Threshold).toBe(800);
    });

    test('should have PrimaryReplicationLagAlarm for global database', () => {
      const alarm = template.Resources.PrimaryReplicationLagAlarm;
      expect(alarm).toBeDefined();
      expect(alarm.Properties.MetricName).toBe('AuroraGlobalDBReplicationLag');
      expect(alarm.Properties.Threshold).toBe(1000);
    });

    test('should have PrimaryStorageAlarm', () => {
      const alarm = template.Resources.PrimaryStorageAlarm;
      expect(alarm).toBeDefined();
      expect(alarm.Properties.MetricName).toBe('FreeLocalStorage');
      expect(alarm.Properties.ComparisonOperator).toBe('LessThanThreshold');
    });

    test('all alarms should reference AlarmTopic', () => {
      const alarms = ['PrimaryCPUAlarm', 'PrimaryConnectionsAlarm', 'PrimaryReplicationLagAlarm', 'PrimaryStorageAlarm'];

      alarms.forEach(alarmName => {
        const alarm = template.Resources[alarmName];
        expect(alarm.Properties.AlarmActions).toContainEqual({ Ref: 'AlarmTopic' });
      });
    });
  });

  describe('Resource Naming Convention', () => {
    test('all resources should use EnvironmentSuffix in naming', () => {
      const resourcesWithNames = [
        'PrimaryVPC',
        'PrimarySubnet1',
        'PrimaryDBSubnetGroup',
        'PrimarySecurityGroup',
        'GlobalCluster',
        'PrimaryDBCluster',
        'PrimaryDBInstance1',
        'AlarmTopic',
      ];

      resourcesWithNames.forEach(resourceName => {
        const resource = template.Resources[resourceName];
        if (resource.Properties.VpcId || resource.Properties.DBClusterIdentifier) {
          return;
        }

        const nameProperty =
          resource.Properties.TopicName ||
          resource.Properties.DBClusterIdentifier ||
          resource.Properties.DBInstanceIdentifier ||
          resource.Properties.GlobalClusterIdentifier ||
          resource.Properties.GroupName ||
          resource.Properties.RoleName ||
          resource.Properties.DBSubnetGroupName ||
          resource.Properties.DBClusterParameterGroupName ||
          resource.Properties.DBParameterGroupName;

        if (nameProperty && typeof nameProperty === 'object' && nameProperty['Fn::Sub']) {
          expect(nameProperty['Fn::Sub']).toContain('${EnvironmentSuffix}');
        }
      });
    });

    test('all resources should have proper tags', () => {
      const resourcesWithTags = Object.keys(template.Resources).filter(key => {
        const resource = template.Resources[key];
        return resource.Properties && resource.Properties.Tags;
      });

      expect(resourcesWithTags.length).toBeGreaterThan(0);

      resourcesWithTags.forEach(resourceName => {
        const resource = template.Resources[resourceName];
        const tags = resource.Properties.Tags;

        const nameTag = tags.find((t: any) => t.Key === 'Name');
        const envTag = tags.find((t: any) => t.Key === 'Environment');

        expect(nameTag).toBeDefined();
        expect(envTag).toBeDefined();
        expect(envTag.Value).toEqual({ Ref: 'EnvironmentSuffix' });
      });
    });
  });

  describe('Outputs', () => {
    test('should have GlobalClusterIdentifier output', () => {
      const output = template.Outputs.GlobalClusterIdentifier;
      expect(output).toBeDefined();
      expect(output.Value).toEqual({ Ref: 'GlobalCluster' });
      expect(output.Export).toBeDefined();
    });

    test('should have PrimaryClusterIdentifier output', () => {
      const output = template.Outputs.PrimaryClusterIdentifier;
      expect(output).toBeDefined();
      expect(output.Value).toEqual({ Ref: 'PrimaryDBCluster' });
    });

    test('should have PrimaryClusterEndpoint output', () => {
      const output = template.Outputs.PrimaryClusterEndpoint;
      expect(output).toBeDefined();
      expect(output.Value['Fn::GetAtt']).toEqual(['PrimaryDBCluster', 'Endpoint.Address']);
    });

    test('should have PrimaryClusterReaderEndpoint output', () => {
      const output = template.Outputs.PrimaryClusterReaderEndpoint;
      expect(output).toBeDefined();
      expect(output.Value['Fn::GetAtt']).toEqual(['PrimaryDBCluster', 'ReadEndpoint.Address']);
    });

    test('should have networking outputs', () => {
      expect(template.Outputs.PrimaryVPCId).toBeDefined();
      expect(template.Outputs.PrimarySecurityGroupId).toBeDefined();
    });

    test('should have monitoring outputs', () => {
      expect(template.Outputs.AlarmTopicArn).toBeDefined();
      expect(template.Outputs.EnhancedMonitoringRoleArn).toBeDefined();
    });

    test('EnhancedMonitoringRoleArn output should be conditional', () => {
      const output = template.Outputs.EnhancedMonitoringRoleArn;
      expect(output.Condition).toBe('EnableEnhancedMonitoringCondition');
    });

    test('all outputs should have exports with EnvironmentSuffix', () => {
      Object.keys(template.Outputs).forEach(outputKey => {
        const output = template.Outputs[outputKey];
        if (output.Export && output.Export.Name) {
          expect(output.Export.Name['Fn::Sub']).toContain('${EnvironmentSuffix}');
        }
      });
    });
  });

  describe('Security Best Practices', () => {
    test('should enforce SSL connections', () => {
      const paramGroup = template.Resources.PrimaryDBClusterParameterGroup;
      expect(paramGroup.Properties.Parameters['rds.force_ssl']).toBe('1');
    });

    test('should enable IAM database authentication', () => {
      const cluster = template.Resources.PrimaryDBCluster;
      expect(cluster.Properties.EnableIAMDatabaseAuthentication).toBe(true);
    });

    test('should enable storage encryption', () => {
      const globalCluster = template.Resources.GlobalCluster;
      const primaryCluster = template.Resources.PrimaryDBCluster;

      expect(globalCluster.Properties.StorageEncrypted).toBe(true);
      expect(primaryCluster.Properties.StorageEncrypted).toBe(true);
    });

    test('should not allow public access to database instances', () => {
      const instance1 = template.Resources.PrimaryDBInstance1;
      const instance2 = template.Resources.PrimaryDBInstance2;

      expect(instance1.Properties.PubliclyAccessible).toBe(false);
      expect(instance2.Properties.PubliclyAccessible).toBe(false);
    });

    test('should have restrictive security group rules', () => {
      const sg = template.Resources.PrimarySecurityGroup;
      const ingress = sg.Properties.SecurityGroupIngress;

      expect(ingress).toHaveLength(1);
      expect(ingress[0].CidrIp).not.toBe('0.0.0.0/0');
    });
  });

  describe('High Availability Configuration', () => {
    test('should deploy across multiple availability zones', () => {
      const subnet1 = template.Resources.PrimarySubnet1;
      const subnet2 = template.Resources.PrimarySubnet2;
      const subnet3 = template.Resources.PrimarySubnet3;

      expect(subnet1.Properties.AvailabilityZone['Fn::Select'][0]).toBe(0);
      expect(subnet2.Properties.AvailabilityZone['Fn::Select'][0]).toBe(1);
      expect(subnet3.Properties.AvailabilityZone['Fn::Select'][0]).toBe(2);
    });

    test('should have multiple database instances for failover', () => {
      expect(template.Resources.PrimaryDBInstance1).toBeDefined();
      expect(template.Resources.PrimaryDBInstance2).toBeDefined();
    });

    test('should have backup retention configured', () => {
      const cluster = template.Resources.PrimaryDBCluster;
      expect(cluster.Properties.BackupRetentionPeriod).toEqual({ Ref: 'BackupRetentionPeriod' });
    });
  });

  describe('Template Validation', () => {
    test('should have valid JSON structure', () => {
      expect(template).toBeDefined();
      expect(typeof template).toBe('object');
    });

    test('should have minimum required resource count', () => {
      const resourceCount = Object.keys(template.Resources).length;
      expect(resourceCount).toBeGreaterThanOrEqual(15);
    });

    test('should have all required parameter types defined', () => {
      Object.keys(template.Parameters).forEach(paramKey => {
        const param = template.Parameters[paramKey];
        expect(param.Type).toBeDefined();
      });
    });

    test('should have descriptions for all parameters', () => {
      Object.keys(template.Parameters).forEach(paramKey => {
        const param = template.Parameters[paramKey];
        expect(param.Description).toBeDefined();
        expect(param.Description.length).toBeGreaterThan(0);
      });
    });

    test('should have descriptions for all outputs', () => {
      Object.keys(template.Outputs).forEach(outputKey => {
        const output = template.Outputs[outputKey];
        expect(output.Description).toBeDefined();
        expect(output.Description.length).toBeGreaterThan(0);
      });
    });
  });
});
