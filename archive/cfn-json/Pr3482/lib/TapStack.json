{
  "AWSTemplateFormatVersion": "2010-09-09",
  "Description": "Appointment Scheduler with conflict detection and reminder notifications",
  "Parameters": {
    "EnvironmentSuffix": {
      "Type": "String",
      "Default": "dev",
      "Description": "Environment suffix for resource naming",
      "AllowedPattern": "^[a-zA-Z0-9]+$"
    }
  },
  "Resources": {
    "AppointmentsTable": {
      "Type": "AWS::DynamoDB::Table",
      "Properties": {
        "TableName": {
          "Fn::Sub": "AppointmentsTable-${EnvironmentSuffix}"
        },
        "AttributeDefinitions": [
          {
            "AttributeName": "appointmentId",
            "AttributeType": "S"
          },
          {
            "AttributeName": "userId",
            "AttributeType": "S"
          },
          {
            "AttributeName": "startTime",
            "AttributeType": "S"
          }
        ],
        "KeySchema": [
          {
            "AttributeName": "appointmentId",
            "KeyType": "HASH"
          }
        ],
        "GlobalSecondaryIndexes": [
          {
            "IndexName": "UserAppointmentsIndex",
            "KeySchema": [
              {
                "AttributeName": "userId",
                "KeyType": "HASH"
              },
              {
                "AttributeName": "startTime",
                "KeyType": "RANGE"
              }
            ],
            "Projection": {
              "ProjectionType": "ALL"
            },
            "ProvisionedThroughput": {
              "ReadCapacityUnits": 5,
              "WriteCapacityUnits": 5
            }
          }
        ],
        "BillingMode": "PROVISIONED",
        "ProvisionedThroughput": {
          "ReadCapacityUnits": 10,
          "WriteCapacityUnits": 10
        },
        "StreamSpecification": {
          "StreamViewType": "NEW_AND_OLD_IMAGES"
        },
        "PointInTimeRecoverySpecification": {
          "PointInTimeRecoveryEnabled": true
        }
      }
    },
    "NotificationTopic": {
      "Type": "AWS::SNS::Topic",
      "Properties": {
        "TopicName": {
          "Fn::Sub": "AppointmentNotifications-${EnvironmentSuffix}"
        },
        "DisplayName": "Appointment Notifications",
        "KmsMasterKeyId": "alias/aws/sns"
      }
    },
    "ConflictDetectorRole": {
      "Type": "AWS::IAM::Role",
      "Properties": {
        "AssumeRolePolicyDocument": {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Effect": "Allow",
              "Principal": {
                "Service": "lambda.amazonaws.com"
              },
              "Action": "sts:AssumeRole"
            }
          ]
        },
        "ManagedPolicyArns": [
          "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
        ],
        "Policies": [
          {
            "PolicyName": "DynamoDBAccess",
            "PolicyDocument": {
              "Version": "2012-10-17",
              "Statement": [
                {
                  "Effect": "Allow",
                  "Action": [
                    "dynamodb:Query",
                    "dynamodb:GetItem",
                    "dynamodb:PutItem",
                    "dynamodb:UpdateItem",
                    "dynamodb:ConditionCheckItem"
                  ],
                  "Resource": [
                    {
                      "Fn::GetAtt": [
                        "AppointmentsTable",
                        "Arn"
                      ]
                    },
                    {
                      "Fn::Sub": "${AppointmentsTable.Arn}/index/*"
                    }
                  ]
                }
              ]
            }
          },
          {
            "PolicyName": "EventBridgeAccess",
            "PolicyDocument": {
              "Version": "2012-10-17",
              "Statement": [
                {
                  "Effect": "Allow",
                  "Action": [
                    "events:PutRule",
                    "events:PutTargets",
                    "events:DeleteRule",
                    "events:RemoveTargets"
                  ],
                  "Resource": {
                    "Fn::Sub": "arn:aws:events:${AWS::Region}:${AWS::AccountId}:rule/appointment-reminder-*"
                  }
                }
              ]
            }
          },
          {
            "PolicyName": "CloudWatchMetrics",
            "PolicyDocument": {
              "Version": "2012-10-17",
              "Statement": [
                {
                  "Effect": "Allow",
                  "Action": [
                    "cloudwatch:PutMetricData"
                  ],
                  "Resource": "*"
                }
              ]
            }
          }
        ]
      }
    },
    "ReminderSenderRole": {
      "Type": "AWS::IAM::Role",
      "Properties": {
        "AssumeRolePolicyDocument": {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Effect": "Allow",
              "Principal": {
                "Service": [
                  "lambda.amazonaws.com",
                  "events.amazonaws.com"
                ]
              },
              "Action": "sts:AssumeRole"
            }
          ]
        },
        "ManagedPolicyArns": [
          "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
        ],
        "Policies": [
          {
            "PolicyName": "DynamoDBRead",
            "PolicyDocument": {
              "Version": "2012-10-17",
              "Statement": [
                {
                  "Effect": "Allow",
                  "Action": [
                    "dynamodb:GetItem",
                    "dynamodb:Query"
                  ],
                  "Resource": [
                    {
                      "Fn::GetAtt": [
                        "AppointmentsTable",
                        "Arn"
                      ]
                    },
                    {
                      "Fn::Sub": "${AppointmentsTable.Arn}/index/*"
                    }
                  ]
                }
              ]
            }
          },
          {
            "PolicyName": "SNSPublish",
            "PolicyDocument": {
              "Version": "2012-10-17",
              "Statement": [
                {
                  "Effect": "Allow",
                  "Action": [
                    "sns:Publish"
                  ],
                  "Resource": {
                    "Ref": "NotificationTopic"
                  }
                }
              ]
            }
          },
          {
            "PolicyName": "CloudWatchMetrics",
            "PolicyDocument": {
              "Version": "2012-10-17",
              "Statement": [
                {
                  "Effect": "Allow",
                  "Action": [
                    "cloudwatch:PutMetricData"
                  ],
                  "Resource": "*"
                }
              ]
            }
          }
        ]
      }
    },
    "APIGatewayCloudWatchLogsRole": {
      "Type": "AWS::IAM::Role",
      "Properties": {
        "AssumeRolePolicyDocument": {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Effect": "Allow",
              "Principal": {
                "Service": "apigateway.amazonaws.com"
              },
              "Action": "sts:AssumeRole"
            }
          ]
        },
        "ManagedPolicyArns": [
          "arn:aws:iam::aws:policy/service-role/AmazonAPIGatewayPushToCloudWatchLogs"
        ]
      }
    },
    "ApiGatewayAccount": {
      "Type": "AWS::ApiGateway::Account",
      "Properties": {
        "CloudWatchRoleArn": {
          "Fn::GetAtt": [
            "APIGatewayCloudWatchLogsRole",
            "Arn"
          ]
        }
      }
    },
    "ConflictDetectorFunction": {
      "Type": "AWS::Lambda::Function",
      "DependsOn": [
        "ConflictDetectorLogGroup"
      ],
      "Properties": {
        "FunctionName": {
          "Fn::Sub": "ConflictDetector-${EnvironmentSuffix}"
        },
        "Runtime": "python3.11",
        "Handler": "index.handler",
        "Role": {
          "Fn::GetAtt": [
            "ConflictDetectorRole",
            "Arn"
          ]
        },
        "Code": {
          "ZipFile": "import json\nimport boto3\nimport os\nimport uuid\nfrom datetime import datetime, timedelta\nfrom decimal import Decimal\nfrom boto3.dynamodb.conditions import Key, Attr\n\ndynamodb = boto3.resource('dynamodb')\nevents = boto3.client('events')\ncloudwatch = boto3.client('cloudwatch')\n\ntable_name = os.environ['TABLE_NAME']\nreminder_function_arn = os.environ['REMINDER_FUNCTION_ARN']\ntable = dynamodb.Table(table_name)\n\ndef decimal_default(obj):\n    if isinstance(obj, Decimal):\n        return float(obj)\n    raise TypeError\n\ndef handler(event, context):\n    try:\n        body = json.loads(event['body'])\n        user_id = body['userId']\n        start_time = body['startTime']\n        end_time = body['endTime']\n        appointment_details = body.get('details', {})\n\n        # Check for conflicts\n        conflict = check_conflicts(user_id, start_time, end_time)\n\n        if conflict:\n            # Log metric for failed booking\n            cloudwatch.put_metric_data(\n                Namespace='AppointmentScheduler',\n                MetricData=[\n                    {\n                        'MetricName': 'BookingConflicts',\n                        'Value': 1,\n                        'Unit': 'Count'\n                    }\n                ]\n            )\n\n            return {\n                'statusCode': 409,\n                'body': json.dumps({\n                    'error': 'Appointment conflict detected',\n                    'conflictingAppointment': conflict\n                })\n            }\n\n        # Create appointment with conditional write\n        appointment_id = str(uuid.uuid4())\n        appointment = create_appointment(\n            appointment_id, user_id, start_time, end_time, appointment_details\n        )\n\n        if appointment:\n            # Schedule reminders\n            schedule_reminders(appointment_id, start_time, user_id)\n\n            # Log metric for successful booking\n            cloudwatch.put_metric_data(\n                Namespace='AppointmentScheduler',\n                MetricData=[\n                    {\n                        'MetricName': 'BookingSuccess',\n                        'Value': 1,\n                        'Unit': 'Count'\n                    }\n                ]\n            )\n\n            return {\n                'statusCode': 201,\n                'body': json.dumps({\n                    'appointmentId': appointment_id,\n                    'message': 'Appointment scheduled successfully'\n                }, default=decimal_default)\n            }\n        else:\n            return {\n                'statusCode': 500,\n                'body': json.dumps({'error': 'Failed to create appointment'})\n            }\n\n    except Exception as e:\n        cloudwatch.put_metric_data(\n            Namespace='AppointmentScheduler',\n            MetricData=[\n                {\n                    'MetricName': 'BookingErrors',\n                    'Value': 1,\n                    'Unit': 'Count'\n                }\n            ]\n        )\n\n        return {\n            'statusCode': 500,\n            'body': json.dumps({'error': str(e)})\n        }\n\ndef check_conflicts(user_id, start_time, end_time):\n    try:\n        # Query existing appointments for the user\n        response = table.query(\n            IndexName='UserAppointmentsIndex',\n            KeyConditionExpression=Key('userId').eq(user_id) &\n                                   Key('startTime').between(start_time, end_time)\n        )\n\n        if response['Items']:\n            return response['Items'][0]\n\n        # Also check if any appointment ends during this time\n        earlier_start = (datetime.fromisoformat(start_time) - timedelta(hours=4)).isoformat()\n        response = table.query(\n            IndexName='UserAppointmentsIndex',\n            KeyConditionExpression=Key('userId').eq(user_id) &\n                                   Key('startTime').between(earlier_start, start_time)\n        )\n\n        for item in response['Items']:\n            if item['endTime'] > start_time:\n                return item\n\n        return None\n\n    except Exception as e:\n        print(f\"Error checking conflicts: {str(e)}\")\n        return None\n\ndef create_appointment(appointment_id, user_id, start_time, end_time, details):\n    try:\n        item = {\n            'appointmentId': appointment_id,\n            'userId': user_id,\n            'startTime': start_time,\n            'endTime': end_time,\n            'details': details,\n            'createdAt': datetime.utcnow().isoformat(),\n            'status': 'scheduled'\n        }\n\n        # Conditional write to prevent duplicate appointments\n        table.put_item(\n            Item=item,\n            ConditionExpression=Attr('appointmentId').not_exists()\n        )\n\n        return item\n\n    except Exception as e:\n        print(f\"Error creating appointment: {str(e)}\")\n        return None\n\ndef schedule_reminders(appointment_id, start_time, user_id):\n    try:\n        appointment_dt = datetime.fromisoformat(start_time.replace('Z', '+00:00'))\n\n        # Schedule 24-hour reminder\n        reminder_24h = appointment_dt - timedelta(hours=24)\n        if reminder_24h > datetime.now(appointment_dt.tzinfo) if appointment_dt.tzinfo else datetime.utcnow():\n            create_eventbridge_rule(\n                f\"appointment-reminder-24h-{appointment_id}\",\n                reminder_24h,\n                appointment_id,\n                user_id,\n                \"24_hour\"\n            )\n\n        # Schedule 1-hour reminder\n        reminder_1h = appointment_dt - timedelta(hours=1)\n        if reminder_1h > datetime.now(appointment_dt.tzinfo) if appointment_dt.tzinfo else datetime.utcnow():\n            create_eventbridge_rule(\n                f\"appointment-reminder-1h-{appointment_id}\",\n                reminder_1h,\n                appointment_id,\n                user_id,\n                \"1_hour\"\n            )\n\n    except Exception as e:\n        print(f\"Error scheduling reminders: {str(e)}\")\n\ndef create_eventbridge_rule(rule_name, trigger_time, appointment_id, user_id, reminder_type):\n    try:\n        # Create the rule with cron expression (more reliable than at())\n        utc_time = trigger_time.utctimetuple() if trigger_time.tzinfo else trigger_time.timetuple()\n        cron_expr = f\"cron({utc_time.tm_min} {utc_time.tm_hour} {utc_time.tm_mday} {utc_time.tm_mon} ? {utc_time.tm_year})\"\n        events.put_rule(\n            Name=rule_name,\n            ScheduleExpression=cron_expr,\n            State='ENABLED',\n            Description=f\"Reminder for appointment {appointment_id}\"\n        )\n\n        # Add Lambda target\n        events.put_targets(\n            Rule=rule_name,\n            Targets=[\n                {\n                    'Id': '1',\n                    'Arn': reminder_function_arn,\n                    'Input': json.dumps({\n                        'appointmentId': appointment_id,\n                        'userId': user_id,\n                        'reminderType': reminder_type\n                    })\n                }\n            ]\n        )\n\n    except Exception as e:\n        print(f\"Error creating EventBridge rule: {str(e)}\")"
        },
        "Environment": {
          "Variables": {
            "TABLE_NAME": {
              "Ref": "AppointmentsTable"
            },
            "REMINDER_FUNCTION_ARN": {
              "Fn::GetAtt": [
                "ReminderSenderFunction",
                "Arn"
              ]
            }
          }
        },
        "Timeout": 30,
        "MemorySize": 256
      }
    },
    "ReminderSenderFunction": {
      "Type": "AWS::Lambda::Function",
      "DependsOn": [
        "ReminderSenderLogGroup"
      ],
      "Properties": {
        "FunctionName": {
          "Fn::Sub": "ReminderSender-${EnvironmentSuffix}"
        },
        "Runtime": "python3.11",
        "Handler": "index.handler",
        "Role": {
          "Fn::GetAtt": [
            "ReminderSenderRole",
            "Arn"
          ]
        },
        "Code": {
          "ZipFile": "import json\nimport boto3\nimport os\nfrom datetime import datetime\n\nsns = boto3.client('sns')\ndynamodb = boto3.resource('dynamodb')\ncloudwatch = boto3.client('cloudwatch')\nevents = boto3.client('events')\n\ntable_name = os.environ['TABLE_NAME']\ntopic_arn = os.environ['TOPIC_ARN']\ntable = dynamodb.Table(table_name)\n\ndef handler(event, context):\n    try:\n        # Get appointment details\n        appointment_id = event['appointmentId']\n        user_id = event['userId']\n        reminder_type = event['reminderType']\n\n        # Fetch appointment from DynamoDB\n        response = table.get_item(\n            Key={'appointmentId': appointment_id}\n        )\n\n        if 'Item' not in response:\n            print(f\"Appointment {appointment_id} not found\")\n            return {\n                'statusCode': 404,\n                'body': json.dumps({'error': 'Appointment not found'})\n            }\n\n        appointment = response['Item']\n\n        # Check if appointment is still scheduled\n        if appointment.get('status') != 'scheduled':\n            print(f\"Appointment {appointment_id} is not in scheduled status\")\n            return {\n                'statusCode': 200,\n                'body': json.dumps({'message': 'Appointment not active'})\n            }\n\n        # Send notification\n        message = format_reminder_message(appointment, reminder_type)\n\n        sns.publish(\n            TopicArn=topic_arn,\n            Subject=f\"Appointment Reminder - {reminder_type.replace('_', ' ').title()}\",\n            Message=message,\n            MessageAttributes={\n                'userId': {'DataType': 'String', 'StringValue': user_id},\n                'appointmentId': {'DataType': 'String', 'StringValue': appointment_id},\n                'reminderType': {'DataType': 'String', 'StringValue': reminder_type}\n            }\n        )\n\n        # Log metric\n        cloudwatch.put_metric_data(\n            Namespace='AppointmentScheduler',\n            MetricData=[\n                {\n                    'MetricName': 'RemindersSent',\n                    'Value': 1,\n                    'Unit': 'Count',\n                    'Dimensions': [\n                        {\n                            'Name': 'ReminderType',\n                            'Value': reminder_type\n                        }\n                    ]\n                }\n            ]\n        )\n\n        # Clean up EventBridge rule after execution\n        cleanup_rule(appointment_id, reminder_type)\n\n        return {\n            'statusCode': 200,\n            'body': json.dumps({\n                'message': 'Reminder sent successfully',\n                'appointmentId': appointment_id,\n                'reminderType': reminder_type\n            })\n        }\n\n    except Exception as e:\n        print(f\"Error sending reminder: {str(e)}\")\n\n        cloudwatch.put_metric_data(\n            Namespace='AppointmentScheduler',\n            MetricData=[\n                {\n                    'MetricName': 'ReminderErrors',\n                    'Value': 1,\n                    'Unit': 'Count'\n                }\n            ]\n        )\n\n        return {\n            'statusCode': 500,\n            'body': json.dumps({'error': str(e)})\n        }\n\ndef format_reminder_message(appointment, reminder_type):\n    start_time = appointment['startTime']\n    details = appointment.get('details', {})\n\n    if reminder_type == '24_hour':\n        message = f\"Reminder: You have an appointment scheduled for tomorrow at {start_time}.\"\n    else:  # 1_hour\n        message = f\"Reminder: Your appointment is in 1 hour at {start_time}.\"\n\n    if details.get('location'):\n        message += f\"\\nLocation: {details['location']}\"\n\n    if details.get('description'):\n        message += f\"\\nDescription: {details['description']}\"\n\n    message += \"\\n\\nPlease ensure you arrive on time.\"\n\n    return message\n\ndef cleanup_rule(appointment_id, reminder_type):\n    try:\n        if reminder_type == '24_hour':\n            rule_name = f\"appointment-reminder-24h-{appointment_id}\"\n        else:\n            rule_name = f\"appointment-reminder-1h-{appointment_id}\"\n\n        # Remove targets first\n        events.remove_targets(Rule=rule_name, Ids=['1'])\n\n        # Then delete the rule\n        events.delete_rule(Name=rule_name)\n\n        print(f\"Cleaned up EventBridge rule: {rule_name}\")\n\n    except Exception as e:\n        print(f\"Error cleaning up rule: {str(e)}\")"
        },
        "Environment": {
          "Variables": {
            "TABLE_NAME": {
              "Ref": "AppointmentsTable"
            },
            "TOPIC_ARN": {
              "Ref": "NotificationTopic"
            }
          }
        },
        "Timeout": 30,
        "MemorySize": 256
      }
    },
    "ReminderSenderPermission": {
      "Type": "AWS::Lambda::Permission",
      "Properties": {
        "FunctionName": {
          "Ref": "ReminderSenderFunction"
        },
        "Action": "lambda:InvokeFunction",
        "Principal": "events.amazonaws.com",
        "SourceArn": {
          "Fn::Sub": "arn:aws:events:${AWS::Region}:${AWS::AccountId}:rule/appointment-reminder-*"
        }
      }
    },
    "AppointmentApi": {
      "Type": "AWS::ApiGateway::RestApi",
      "Properties": {
        "Name": {
          "Fn::Sub": "AppointmentScheduler-${EnvironmentSuffix}"
        },
        "Description": "API for appointment scheduling",
        "EndpointConfiguration": {
          "Types": [
            "REGIONAL"
          ]
        }
      }
    },
    "AppointmentResource": {
      "Type": "AWS::ApiGateway::Resource",
      "Properties": {
        "RestApiId": {
          "Ref": "AppointmentApi"
        },
        "ParentId": {
          "Fn::GetAtt": [
            "AppointmentApi",
            "RootResourceId"
          ]
        },
        "PathPart": "appointments"
      }
    },
    "AppointmentMethod": {
      "Type": "AWS::ApiGateway::Method",
      "Properties": {
        "RestApiId": {
          "Ref": "AppointmentApi"
        },
        "ResourceId": {
          "Ref": "AppointmentResource"
        },
        "HttpMethod": "POST",
        "AuthorizationType": "NONE",
        "Integration": {
          "Type": "AWS_PROXY",
          "IntegrationHttpMethod": "POST",
          "Uri": {
            "Fn::Sub": "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${ConflictDetectorFunction.Arn}/invocations"
          }
        }
      }
    },
    "ApiGatewayInvokePermission": {
      "Type": "AWS::Lambda::Permission",
      "Properties": {
        "FunctionName": {
          "Ref": "ConflictDetectorFunction"
        },
        "Action": "lambda:InvokeFunction",
        "Principal": "apigateway.amazonaws.com",
        "SourceArn": {
          "Fn::Sub": "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${AppointmentApi}/*/*"
        }
      }
    },
    "ApiDeployment": {
      "Type": "AWS::ApiGateway::Deployment",
      "DependsOn": [
        "AppointmentMethod"
      ],
      "Properties": {
        "RestApiId": {
          "Ref": "AppointmentApi"
        },
        "StageName": "prod",
        "StageDescription": {
          "ThrottlingBurstLimit": 100,
          "ThrottlingRateLimit": 50,
          "MetricsEnabled": true,
          "LoggingLevel": "INFO"
        }
      }
    },
    "ConflictDetectorLogGroup": {
      "Type": "AWS::Logs::LogGroup",
      "Properties": {
        "LogGroupName": {
          "Fn::Sub": "/aws/lambda/ConflictDetector-${EnvironmentSuffix}"
        },
        "RetentionInDays": 7
      }
    },
    "ReminderSenderLogGroup": {
      "Type": "AWS::Logs::LogGroup",
      "Properties": {
        "LogGroupName": {
          "Fn::Sub": "/aws/lambda/ReminderSender-${EnvironmentSuffix}"
        },
        "RetentionInDays": 7
      }
    },
    "BookingMetricFilter": {
      "Type": "AWS::Logs::MetricFilter",
      "Properties": {
        "FilterName": "BookingMetrics",
        "FilterPattern": "[time, request_id, event_type = BOOKING_SUCCESS || event_type = BOOKING_CONFLICT || event_type = BOOKING_ERROR, ...]",
        "LogGroupName": {
          "Ref": "ConflictDetectorLogGroup"
        },
        "MetricTransformations": [
          {
            "MetricName": "BookingAttempts",
            "MetricNamespace": "AppointmentScheduler",
            "MetricValue": "1",
            "DefaultValue": 0
          }
        ]
      }
    },
    "BookingSuccessAlarm": {
      "Type": "AWS::CloudWatch::Alarm",
      "Properties": {
        "AlarmName": {
          "Fn::Sub": "LowBookingSuccessRate-${EnvironmentSuffix}"
        },
        "AlarmDescription": "Alert when booking success rate drops below 90%",
        "MetricName": "BookingAttempts",
        "Namespace": "AppointmentScheduler",
        "Statistic": "Sum",
        "Period": 300,
        "EvaluationPeriods": 2,
        "Threshold": 10,
        "ComparisonOperator": "LessThanThreshold",
        "TreatMissingData": "notBreaching"
      }
    }
  },
  "Outputs": {
    "ApiEndpoint": {
      "Description": "API Gateway endpoint URL",
      "Value": {
        "Fn::Sub": "https://${AppointmentApi}.execute-api.${AWS::Region}.amazonaws.com/prod"
      }
    },
    "AppointmentsTableName": {
      "Description": "DynamoDB table name",
      "Value": {
        "Ref": "AppointmentsTable"
      }
    },
    "NotificationTopicArn": {
      "Description": "SNS topic ARN for notifications",
      "Value": {
        "Ref": "NotificationTopic"
      }
    }
  }
}
