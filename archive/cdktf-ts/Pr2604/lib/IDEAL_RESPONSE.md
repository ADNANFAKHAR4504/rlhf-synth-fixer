# CDKTF TypeScript: AWS Multi-Tier Web Application

This project provides a comprehensive, monolithic CDKTF stack written in TypeScript to deploy a secure, scalable, and highly available multi-tier web application environment on AWS.

## Project Structure

```
.
├── bin/
│   └── tap.ts              # Entry point of the CDKTF application
├── lib/
│   └── tap-stack.ts        # Core monolithic stack with all AWS resources
└── tests/
    ├── tap-stack.int.test.ts # Integration tests for resource interactions
    └── tap-stack.unit.test.ts  # Unit tests for individual resource configurations
```

## Core Principles & Best Practices Followed

### 1. Monolithic & Self-Contained Stack

All AWS resources are defined within a single `TapStack` class in `lib/tap-stack.ts`. This provides a clear, holistic view of the infrastructure, ideal for tightly coupled components. The stack is self-contained, creating all necessary components without requiring user-provided values, ensuring consistent and reproducible deployments.

### 2. High Availability

- **Multi-AZ VPC**: The network is built across two Availability Zones (`us-east-1a` and `us-east-1b`) to protect against single-zone failures.
- **Auto Scaling**: An Auto Scaling Group manages the application tier, ensuring a minimum of 2 instances are always running and scaling up to 10 based on load.
- **Load Balancing**: An Application Load Balancer (ALB) is placed in the public subnets to distribute traffic evenly across the application instances in the private subnets.
- **Multi-AZ RDS**: The RDS PostgreSQL database is deployed in a Multi-AZ configuration for automatic failover in case the primary database instance fails.

### 3. Security by Default

- **Network Segmentation**: A classic multi-tier architecture is used. The ALB resides in public subnets, while the application EC2 instances and the RDS database are isolated in private subnets, preventing direct public internet access to the core application and data layers.
- **Least Privilege IAM**: The EC2 instance role is granted only the specific permissions required to send logs to CloudWatch. No other permissions are granted.
- **Strict Security Groups**:
  - **ALB Security Group**: Only allows inbound HTTP (port 80) traffic from the internet.
  - **Application Security Group**: Only allows inbound traffic from the ALB's security group on the application port (8080).
  - **Database Security Group**: Only allows inbound traffic from the application's security group on the PostgreSQL port (5432).
- **Data Encryption**: The RDS database is configured with **Encryption at Rest** enabled by default.

### 4. Operational Excellence

- **Centralized Logging**: A CloudWatch Log Group is created to collect logs from all application instances. ALB access logs are sent to an S3 bucket, and RDS logs are exported to CloudWatch.
- **Randomized Resource Naming**: A random suffix generated by `Fn.uuid()` is appended to all globally unique resource names to prevent naming conflicts across deployments.
- **Automated Backups**: The RDS instance is configured with automated daily backups with a **30-day retention period**.
- **Consistent Tagging**: All resources are automatically tagged with `environment: production` via the AWS provider configuration, simplifying cost allocation and resource management.

## Getting Started

**Install Dependencies:**

```bash
npm install
```

**Synthesize the Stack:**

```bash
npx cdktf synth
```

**Run Tests:**

```bash
npm test
```

**Deploy to AWS:**

```bash
npx cdktf deploy
```

---

## Complete Infrastructure Code

### `bin/tap.ts`

```typescript
#!/usr/bin/env node
import { App } from 'cdktf';
import { TapStack } from '../lib/tap-stack';

const app = new App();

new TapStack(app, 'tap-aws-stack', {
  env: {
    region: 'us-east-1',
  },
});

app.synth();
```

### `lib/tap-stack.ts`

```typescript
import { Construct } from 'constructs';
import { App, TerraformStack, Fn } from 'cdktf';
import { AwsProvider } from '@cdktf/provider-aws/lib/provider';
import { Vpc } from '@cdktf/provider-aws/lib/vpc';
import { Subnet } from '@cdktf/provider-aws/lib/subnet';
import { InternetGateway } from '@cdktf/provider-aws/lib/internet-gateway';
import { RouteTable } from '@cdktf/provider-aws/lib/route-table';
import { RouteTableAssociation } from '@cdktf/provider-aws/lib/route-table-association';
import { Eip } from '@cdktf/provider-aws/lib/eip';
import { NatGateway } from '@cdktf/provider-aws/lib/nat-gateway';
import { SecurityGroup } from '@cdktf/provider-aws/lib/security-group';
import { DbInstance } from '@cdktf/provider-aws/lib/db-instance';
import { DbSubnetGroup } from '@cdktf/provider-aws/lib/db-subnet-group';
import { IamRole } from '@cdktf/provider-aws/lib/iam-role';
import { IamPolicy } from '@cdktf/provider-aws/lib/iam-policy';
import { IamRolePolicyAttachment } from '@cdktf/provider-aws/lib/iam-role-policy-attachment';
import { IamInstanceProfile } from '@cdktf/provider-aws/lib/iam-instance-profile';
import { Lb } from '@cdktf/provider-aws/lib/lb';
import { LbTargetGroup } from '@cdktf/provider-aws/lib/lb-target-group';
import { LbListener } from '@cdktf/provider-aws/lib/lb-listener';
import { LaunchTemplate } from '@cdktf/provider-aws/lib/launch-template';
import { AutoscalingGroup } from '@cdktf/provider-aws/lib/autoscaling-group';
import { AutoscalingPolicy } from '@cdktf/provider-aws/lib/autoscaling-policy';
import { CloudwatchLogGroup } from '@cdktf/provider-aws/lib/cloudwatch-log-group';
import { DataAwsAmi } from '@cdktf/provider-aws/lib/data-aws-ami';
import { S3Bucket } from '@cdktf/provider-aws/lib/s3-bucket';

interface TapStackConfig {
  env: {
    region: string;
  };
}

export class TapStack extends TerraformStack {
  constructor(scope: Construct, id: string, config: TapStackConfig) {
    super(scope, id);

    const region = config.env.region;
    const randomSuffix = Fn.substr(Fn.uuid(), 0, 8);
    const availabilityZones = [`${region}a`, `${region}b`];

    // 1. AWS Provider and Global Tagging
    new AwsProvider(this, 'aws', {
      region,
      defaultTags: [
        {
          tags: {
            environment: 'production',
            managed_by: 'cdktf',
          },
        },
      ],
    });

    // 2. Networking (VPC, Subnets, Gateways) for High Availability
    const vpc = new Vpc(this, 'main-vpc', {
      cidrBlock: '10.0.0.0/16',
      enableDnsHostnames: true,
      enableDnsSupport: true,
    });

    const igw = new InternetGateway(this, 'main-igw', { vpcId: vpc.id });

    const publicSubnets = availabilityZones.map(
      (zone, index) =>
        new Subnet(this, `public-subnet-${index}`, {
          vpcId: vpc.id,
          cidrBlock: `10.0.${index + 1}.0/24`,
          availabilityZone: zone,
          mapPublicIpOnLaunch: true,
        })
    );

    const privateSubnets = availabilityZones.map(
      (zone, index) =>
        new Subnet(this, `private-subnet-${index}`, {
          vpcId: vpc.id,
          cidrBlock: `10.0.${100 + index + 1}.0/24`,
          availabilityZone: zone,
        })
    );

    const publicRouteTable = new RouteTable(this, 'public-rt', {
      vpcId: vpc.id,
      route: [{ cidrBlock: '0.0.0.0/0', gatewayId: igw.id }],
    });

    publicSubnets.forEach((subnet, index) => {
      new RouteTableAssociation(this, `public-rta-${index}`, {
        subnetId: subnet.id,
        routeTableId: publicRouteTable.id,
      });
    });

    // NAT Gateways in each public subnet for HA outbound traffic from private subnets
    availabilityZones.forEach((zone, index) => {
      const eip = new Eip(this, `nat-eip-${index}`, { domain: 'vpc' });
      const natGateway = new NatGateway(this, `nat-gw-${index}`, {
        allocationId: eip.id,
        subnetId: publicSubnets[index].id,
      });
      const privateRouteTable = new RouteTable(this, `private-rt-${index}`, {
        vpcId: vpc.id,
        route: [{ cidrBlock: '0.0.0.0/0', natGatewayId: natGateway.id }],
      });
      new RouteTableAssociation(this, `private-rta-${index}`, {
        subnetId: privateSubnets[index].id,
        routeTableId: privateRouteTable.id,
      });
    });

    // 3. Security (Strict Security Groups)
    const albSg = new SecurityGroup(this, 'alb-sg', {
      name: `alb-sg-${randomSuffix}`,
      vpcId: vpc.id,
      description: 'Allow HTTP traffic to ALB',
      ingress: [
        {
          protocol: 'tcp',
          fromPort: 80,
          toPort: 80,
          cidrBlocks: ['0.0.0.0/0'],
        },
      ],
      egress: [
        { protocol: '-1', fromPort: 0, toPort: 0, cidrBlocks: ['0.0.0.0/0'] },
      ],
    });

    const ec2Sg = new SecurityGroup(this, 'ec2-sg', {
      name: `ec2-sg-${randomSuffix}`,
      vpcId: vpc.id,
      description: 'Allow traffic from ALB to EC2 instances',
      ingress: [
        {
          protocol: 'tcp',
          fromPort: 8080,
          toPort: 8080,
          securityGroups: [albSg.id],
        },
      ],
      egress: [
        { protocol: '-1', fromPort: 0, toPort: 0, cidrBlocks: ['0.0.0.0/0'] },
      ],
    });

    const rdsSg = new SecurityGroup(this, 'rds-sg', {
      name: `rds-sg-${randomSuffix}`,
      vpcId: vpc.id,
      description: 'Allow traffic from EC2 to RDS',
      ingress: [
        {
          protocol: 'tcp',
          fromPort: 5432,
          toPort: 5432,
          securityGroups: [ec2Sg.id],
        },
      ],
    });

    // 4. Logging (Centralized in CloudWatch and S3)
    const albLogBucket = new S3Bucket(this, 'alb-log-bucket', {
      bucket: `alb-logs-${randomSuffix}`,
    });

    const appLogGroup = new CloudwatchLogGroup(this, 'app-log-group', {
      name: `/app/web-logs-${randomSuffix}`,
      retentionInDays: 30,
    });

    // 5. Application Load Balancer
    const alb = new Lb(this, 'alb', {
      name: `app-lb-${randomSuffix}`,
      internal: false,
      loadBalancerType: 'application',
      securityGroups: [albSg.id],
      subnets: publicSubnets.map(subnet => subnet.id),
      accessLogs: {
        bucket: albLogBucket.bucket,
        prefix: 'alb-logs',
        enabled: true,
      },
    });

    const targetGroup = new LbTargetGroup(this, 'target-group', {
      name: `app-tg-${randomSuffix}`,
      port: 8080,
      protocol: 'HTTP',
      vpcId: vpc.id,
      healthCheck: {
        path: '/health',
        protocol: 'HTTP',
        interval: 30,
      },
    });

    new LbListener(this, 'listener', {
      loadBalancerArn: alb.arn,
      port: 80,
      protocol: 'HTTP',
      defaultAction: [{ type: 'forward', targetGroupArn: targetGroup.arn }],
    });

    // 6. Database (Encrypted, Multi-AZ, Backups)
    const dbSubnetGroup = new DbSubnetGroup(this, 'rds-subnet-group', {
      name: `rds-subnet-group-${randomSuffix}`,
      subnetIds: privateSubnets.map(subnet => subnet.id),
    });

    new DbInstance(this, 'rds-instance', {
      identifier: `app-db-${randomSuffix}`,
      allocatedStorage: 20,
      instanceClass: 'db.t3.micro',
      engine: 'postgres',
      engineVersion: '15.3',
      username: 'appadmin',
      password: 'MustBeChangedInSecretsManager',
      dbSubnetGroupName: dbSubnetGroup.name,
      vpcSecurityGroupIds: [rdsSg.id],
      multiAz: true,
      storageEncrypted: true,
      backupRetentionPeriod: 30,
      skipFinalSnapshot: true,
      enabledCloudwatchLogsExports: ['postgresql', 'upgrade'],
    });

    // 7. IAM (Least Privilege for EC2)
    const ec2Role = new IamRole(this, 'ec2-role', {
      name: `ec2-role-${randomSuffix}`,
      assumeRolePolicy: JSON.stringify({
        Version: '2012-10-17',
        Statement: [
          {
            Action: 'sts:AssumeRole',
            Effect: 'Allow',
            Principal: { Service: 'ec2.amazonaws.com' },
          },
        ],
      }),
    });

    const ec2Policy = new IamPolicy(this, 'ec2-policy', {
      name: `ec2-policy-${randomSuffix}`,
      policy: JSON.stringify({
        Version: '2012-10-17',
        Statement: [
          {
            Action: [
              'logs:CreateLogStream',
              'logs:PutLogEvents',
              'logs:DescribeLogStreams',
            ],
            Effect: 'Allow',
            Resource: `${appLogGroup.arn}:*`,
          },
          {
            Action: 'ssm:GetParameter',
            Effect: 'Allow',
            Resource: `arn:aws:ssm:${region}:*:parameter/aws/service/cloudwatch-agent/*`,
          },
        ],
      }),
    });

    new IamRolePolicyAttachment(this, 'ec2-policy-attachment', {
      role: ec2Role.name,
      policyArn: ec2Policy.arn,
    });
    const instanceProfile = new IamInstanceProfile(
      this,
      'ec2-instance-profile',
      { name: `ec2-instance-profile-${randomSuffix}`, role: ec2Role.name }
    );

    // 8. Compute (Auto Scaling for Scalability & Resilience)
    const ami = new DataAwsAmi(this, 'amazon-linux-2', {
      mostRecent: true,
      filter: [{ name: 'name', values: ['amzn2-ami-hvm-*-x86_64-gp2'] }],
      owners: ['amazon'],
    });

    const userData = `#!/bin/bash
yum update -y
yum install -y amazon-cloudwatch-agent
/opt/aws/amazon-cloudwatch-agent/bin/amazon-cloudwatch-agent-ctl -a fetch-config -m ec2 -s -c ssm:AmazonCloudWatch-linux
# Your application deployment script would go here
# For example:
# yum install -y nodejs
# # Fetch app from S3/CodeDeploy and start it on port 8080
`;

    const launchTemplate = new LaunchTemplate(this, 'launch-template', {
      name: `app-launch-template-${randomSuffix}`,
      imageId: ami.id,
      instanceType: 't3.micro',
      iamInstanceProfile: { name: instanceProfile.name },
      vpcSecurityGroupIds: [ec2Sg.id],
      userData: Fn.base64(userData),
    });

    const asg = new AutoscalingGroup(this, 'autoscaling-group', {
      name: `app-asg-${randomSuffix}`,
      launchTemplate: { id: launchTemplate.id, version: '$Latest' },
      minSize: 2,
      maxSize: 10,
      desiredCapacity: 2,
      vpcZoneIdentifier: privateSubnets.map(subnet => subnet.id),
      targetGroupArns: [targetGroup.arn],
    });

    new AutoscalingPolicy(this, 'cpu-scaling-policy', {
      name: `cpu-scaling-policy-${randomSuffix}`,
      autoscalingGroupName: asg.name,
      policyType: 'TargetTrackingScaling',
      estimatedInstanceWarmup: 300,
      targetTrackingConfiguration: {
        predefinedMetricSpecification: {
          predefinedMetricType: 'ASGAverageCPUUtilization',
        },
        targetValue: 50.0,
      },
    });
  }
}
```

### `tests/tap-stack.unit.test.ts`

```typescript
import './setup.js';

declare global {
  namespace jest {
    interface Matchers<R> {
      toHaveResource(construct: any): R;
      toHaveResourceWithProperties(construct: any, properties: any): R;
    }
  }
}

import { Testing, TerraformStack } from 'cdktf';
import { TapStack } from '../lib/tap-stack';
import { Vpc } from '@cdktf/provider-aws/lib/vpc';
import { DbInstance } from '@cdktf/provider-aws/lib/db-instance';
import { AutoscalingGroup } from '@cdktf/provider-aws/lib/autoscaling-group';
import { Lb } from '@cdktf/provider-aws/lib/lb';
import { IamPolicy } from '@cdktf/provider-aws/lib/iam-policy';

describe('Unit Tests for TapStack', () => {
  let stack: TerraformStack;
  let synthesized: string;

  beforeAll(() => {
    const app = Testing.app();
    stack = new TapStack(app, 'test-stack', {
      env: { region: 'us-east-1' },
    });
    synthesized = Testing.synth(stack);
  });

  it('should create a VPC', () => {
    expect(synthesized).toHaveResource(Vpc);
  });

  it('should create a Multi-AZ RDS instance with backups', () => {
    expect(synthesized).toHaveResourceWithProperties(DbInstance, {
      multi_az: true,
      backup_retention_period: 30,
    });
  });

  it('should create an Auto Scaling Group with correct capacity', () => {
    expect(synthesized).toHaveResourceWithProperties(AutoscalingGroup, {
      min_size: 2,
      max_size: 10,
    });
  });

  it('should create an Application Load Balancer', () => {
    expect(synthesized).toHaveResource(Lb);
  });

  it('should create an IAM policy with least privilege for CloudWatch', () => {
    expect(synthesized).toHaveResourceWithProperties(IamPolicy, {
      policy: expect.stringContaining(
        '"Resource":"${aws_cloudwatch_log_group.app-log-group.arn}:*"'
      ),
    });
    // Ensure it doesn't have wildcard resource permissions for other services
    expect(synthesized).not.toHaveResourceWithProperties(IamPolicy, {
      policy: expect.stringContaining('"Resource":"*"'),
    });
  });
});
```

### `tests/tap-stack.int.test.ts`

```typescript
import './setup.js';

declare global {
  namespace jest {
    interface Matchers<R> {
      toHaveResource(construct: any): R;
      toHaveResourceWithProperties(construct: any, properties: any): R;
    }
  }
}

import { Testing, TerraformStack } from 'cdktf';
import { TapStack } from '../lib/tap-stack';
import { SecurityGroup } from '@cdktf/provider-aws/lib/security-group';
import { AutoscalingGroup } from '@cdktf/provider-aws/lib/autoscaling-group';
import { Lb } from '@cdktf/provider-aws/lib/lb';
import { DbInstance } from '@cdktf/provider-aws/lib/db-instance';

describe('Integration Tests for TapStack', () => {
  let stack: TerraformStack;
  let synthesized: string;

  beforeAll(() => {
    const app = Testing.app();
    stack = new TapStack(app, 'test-stack', {
      env: { region: 'us-east-1' },
    });
    synthesized = Testing.synth(stack);
  });

  it('should place the ALB in public subnets', () => {
    expect(synthesized).toHaveResourceWithProperties(Lb, {
      subnets: [
        '${aws_subnet.public-subnet-0.id}',
        '${aws_subnet.public-subnet-1.id}',
      ],
    });
  });

  it('should place the ASG in private subnets', () => {
    expect(synthesized).toHaveResourceWithProperties(AutoscalingGroup, {
      vpc_zone_identifier: [
        '${aws_subnet.private-subnet-0.id}',
        '${aws_subnet.private-subnet-1.id}',
      ],
    });
  });

  it('should configure the App SG to only allow traffic from the ALB SG', () => {
    expect(synthesized).toHaveResourceWithProperties(SecurityGroup, {
      name: expect.stringMatching(/^ec2-sg-/),
      ingress: expect.arrayContaining([
        expect.objectContaining({
          security_groups: ['${aws_security_group.alb-sg.id}'],
        }),
      ]),
    });
  });

  it('should configure the DB SG to only allow traffic from the App SG', () => {
    expect(synthesized).toHaveResourceWithProperties(SecurityGroup, {
      name: expect.stringMatching(/^rds-sg-/),
      ingress: expect.arrayContaining([
        expect.objectContaining({
          security_groups: ['${aws_security_group.ec2-sg.id}'],
        }),
      ]),
    });
  });

  it('should associate the RDS instance with the DB security group', () => {
    expect(synthesized).toHaveResourceWithProperties(DbInstance, {
      vpc_security_group_ids: ['${aws_security_group.rds-sg.id}'],
    });
  });
});
```
