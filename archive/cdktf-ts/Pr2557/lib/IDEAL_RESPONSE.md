CDKTF TypeScript: AWS Multi-Tier Web Application
This project provides a comprehensive, monolithic CDKTF stack written in TypeScript to deploy a secure, scalable, and highly available multi-tier web application environment on AWS.

Project Structure
.
├── bin/
│ └── tap.ts # Entry point of the CDKTF application
├── lib/
│ └── tap-stack.ts # Core monolithic stack with all AWS resources
└── tests/
├── tap-stack.int.test.ts # Integration tests for resource interactions
└── tap-stack.unit.test.ts # Unit tests for individual resource configurations

Core Principles & Best Practices Followed

1. Monolithic & Self-Contained Stack
   All AWS resources are defined within a single TapStack class in lib/tap-stack.ts. This provides a clear, holistic view of the infrastructure, ideal for tightly coupled components. The stack is self-contained, creating all necessary components without requiring user-provided values, ensuring consistent and reproducible deployments.

2. High Availability
   Multi-AZ VPC: The network is built across two Availability Zones (us-east-1a and us-east-1b) to protect against single-zone failures.

Auto Scaling: An Auto Scaling Group manages the application tier, ensuring a minimum of 2 instances are always running and scaling up to 5 based on load.

Load Balancing: An Application Load Balancer (ALB) is placed in the public subnets to distribute traffic evenly across the application instances in the private subnets.

Multi-AZ RDS: The RDS MySQL database is deployed in a Multi-AZ configuration for automatic failover in case the primary database instance fails.

3. Security by Default
   Network Segmentation: A classic multi-tier architecture is used. The ALB resides in public subnets, while the application EC2 instances and the RDS database are isolated in private subnets, preventing direct public internet access to the core application and data layers.

Least Privilege IAM: The EC2 instance role is granted only the specific permissions required to send logs to CloudWatch. No other permissions are granted.

Strict Security Groups:

ALB Security Group: Only allows inbound HTTP (port 80) and HTTPS (port 443) traffic from the internet.

Application Security Group: Only allows inbound traffic from the ALB's security group.

Database Security Group: Only allows inbound traffic from the application's security group on the MySQL port (3306).

4. Operational Excellence
   Centralized Logging: A CloudWatch Log Group is created to collect logs from all application instances. The EC2 instances are configured via a launch template with an IAM role that permits writing to this log group.

Randomized Resource Naming: A random suffix generated by Fn.uuid() is appended to all globally unique resource names to prevent naming conflicts across deployments.

Automated Backups: The RDS instance is configured with automated daily backups with a 7-day retention period.

Getting Started
Install Dependencies:

npm install

Synthesize the Stack:

npx cdktf synth

Run Tests:

npm test

Deploy to AWS:

npx cdktf deploy

Infrastructure Code
bin/tap.ts
#!/usr/bin/env node
import { App } from "cdktf";
import { TapStack } from "../lib/tap-stack";

const app = new App();

new TapStack(app, "tap-aws-stack", {
env: {
region: "us-east-1",
},
});

app.synth();

lib/tap-stack.ts
import { Construct } from "constructs";
import { App, TerraformStack, Fn } from "cdktf";
import { AwsProvider } from "@cdktf/provider-aws/lib/provider";
import { Vpc } from "@cdktf/provider-aws/lib/vpc";
import { Subnet } from "@cdktf/provider-aws/lib/subnet";
import { InternetGateway } from "@cdktf/provider-aws/lib/internet-gateway";
import { RouteTable } from "@cdktf/provider-aws/lib/route-table";
import { RouteTableAssociation } from "@cdktf/provider-aws/lib/route-table-association";
import { Eip } from "@cdktf/provider-aws/lib/eip";
import { NatGateway } from "@cdktf/provider-aws/lib/nat-gateway";
import { SecurityGroup } from "@cdktf/provider-aws/lib/security-group";
import { DbInstance } from "@cdktf/provider-aws/lib/db-instance";
import { DbSubnetGroup } from "@cdktf/provider-aws/lib/db-subnet-group";
import { IamRole } from "@cdktf/provider-aws/lib/iam-role";
import { IamPolicy } from "@cdktf/provider-aws/lib/iam-policy";
import { IamRolePolicyAttachment } from "@cdktf/provider-aws/lib/iam-role-policy-attachment";
import { IamInstanceProfile } from "@cdktf/provider-aws/lib/iam-instance-profile";
import { Lb } from "@cdktf/provider-aws/lib/lb";
import { LbTargetGroup } from "@cdktf/provider-aws/lib/lb-target-group";
import { LbListener } from "@cdktf/provider-aws/lib/lb-listener";
import { LaunchTemplate } from "@cdktf/provider-aws/lib/launch-template";
import { AutoscalingGroup } from "@cdktf/provider-aws/lib/autoscaling-group";
import { CloudwatchLogGroup } from "@cdktf/provider-aws/lib/cloudwatch-log-group";
import { DataAwsAmi } from "@cdktf/provider-aws/lib/data-aws-ami";

interface TapStackConfig {
env: {
region: string;
};
}

export class TapStack extends TerraformStack {
constructor(scope: Construct, id: string, config: TapStackConfig) {
super(scope, id);

    const region = config.env.region;
    const randomSuffix = Fn.substr(Fn.uuid(), 0, 8);

    // 1. AWS Provider and VPC Setup
    new AwsProvider(this, "aws", { region });

    const vpc = new Vpc(this, "main-vpc", {
      cidrBlock: "10.0.0.0/16",
      enableDnsHostnames: true,
    });

    const igw = new InternetGateway(this, "main-igw", { vpcId: vpc.id });

    // Public Subnets and Routing
    const publicSubnetA = new Subnet(this, "public-subnet-a", {
      vpcId: vpc.id,
      cidrBlock: "10.0.1.0/24",
      availabilityZone: `${region}a`,
      mapPublicIpOnLaunch: true,
    });

    const publicSubnetB = new Subnet(this, "public-subnet-b", {
      vpcId: vpc.id,
      cidrBlock: "10.0.2.0/24",
      availabilityZone: `${region}b`,
      mapPublicIpOnLaunch: true,
    });

    const publicRouteTable = new RouteTable(this, "public-rt", {
      vpcId: vpc.id,
      route: [{ cidrBlock: "0.0.0.0/0", gatewayId: igw.id }],
    });

    new RouteTableAssociation(this, "public-rta-a", {
      subnetId: publicSubnetA.id,
      routeTableId: publicRouteTable.id,
    });

    new RouteTableAssociation(this, "public-rta-b", {
      subnetId: publicSubnetB.id,
      routeTableId: publicRouteTable.id,
    });

    // Private Subnets and Routing with NAT Gateways
    const privateSubnetA = new Subnet(this, "private-subnet-a", {
      vpcId: vpc.id,
      cidrBlock: "10.0.101.0/24",
      availabilityZone: `${region}a`,
    });

    const privateSubnetB = new Subnet(this, "private-subnet-b", {
      vpcId: vpc.id,
      cidrBlock: "10.0.102.0/24",
      availabilityZone: `${region}b`,
    });

    const eipA = new Eip(this, "nat-eip-a", { domain: "vpc" });
    const natGatewayA = new NatGateway(this, "nat-gw-a", {
      allocationId: eipA.id,
      subnetId: publicSubnetA.id,
    });
    const privateRouteTableA = new RouteTable(this, "private-rt-a", {
      vpcId: vpc.id,
      route: [{ cidrBlock: "0.0.0.0/0", natGatewayId: natGatewayA.id }],
    });
    new RouteTableAssociation(this, "private-rta-a", {
      subnetId: privateSubnetA.id,
      routeTableId: privateRouteTableA.id,
    });

    // 2. Security Groups (Web, App, DB)
    const albSg = new SecurityGroup(this, "alb-sg", {
      name: `alb-sg-${randomSuffix}`,
      vpcId: vpc.id,
      description: "Allow HTTP/HTTPS traffic to ALB",
      ingress: [
        { protocol: "tcp", fromPort: 80, toPort: 80, cidrBlocks: ["0.0.0.0/0"] },
        { protocol: "tcp", fromPort: 443, toPort: 443, cidrBlocks: ["0.0.0.0/0"] },
      ],
      egress: [
        { protocol: "-1", fromPort: 0, toPort: 0, cidrBlocks: ["0.0.0.0/0"] },
      ],
    });

    const appSg = new SecurityGroup(this, "app-sg", {
      name: `app-sg-${randomSuffix}`,
      vpcId: vpc.id,
      description: "Allow traffic from ALB to App",
      ingress: [
        { protocol: "tcp", fromPort: 80, toPort: 80, securityGroups: [albSg.id] },
      ],
       egress: [
        { protocol: "-1", fromPort: 0, toPort: 0, cidrBlocks: ["0.0.0.0/0"] },
      ],
    });

    const rdsSg = new SecurityGroup(this, "rds-sg", {
      name: `rds-sg-${randomSuffix}`,
      vpcId: vpc.id,
      description: "Allow traffic from App to RDS",
      ingress: [
        { protocol: "tcp", fromPort: 3306, toPort: 3306, securityGroups: [appSg.id] },
      ],
    });

    // 3. CloudWatch Log Group
    const logGroup = new CloudwatchLogGroup(this, "app-log-group", {
      name: `/app/logs-${randomSuffix}`,
      retentionInDays: 7,
    });

    // 4. IAM Role and Policy for EC2 (Least Privilege)
    const ec2Role = new IamRole(this, "ec2-role", {
      name: `ec2-role-${randomSuffix}`,
      assumeRolePolicy: JSON.stringify({
        Version: "2012-10-17",
        Statement: [{ Action: "sts:AssumeRole", Effect: "Allow", Principal: { Service: "ec2.amazonaws.com" } }],
      }),
    });

    const ec2Policy = new IamPolicy(this, "ec2-policy", {
      name: `ec2-policy-${randomSuffix}`,
      policy: JSON.stringify({
        Version: "2012-10-17",
        Statement: [{
          Action: ["logs:CreateLogStream", "logs:PutLogEvents"],
          Effect: "Allow",
          Resource: `${logGroup.arn}:*`,
        }],
      }),
    });

    new IamRolePolicyAttachment(this, "ec2-policy-attachment", {
      role: ec2Role.name,
      policyArn: ec2Policy.arn,
    });

    const instanceProfile = new IamInstanceProfile(this, "ec2-instance-profile", {
      name: `ec2-instance-profile-${randomSuffix}`,
      role: ec2Role.name,
    });

    // 5. RDS Database (Multi-AZ with Backups)
    const dbSubnetGroup = new DbSubnetGroup(this, "rds-subnet-group", {
      name: `rds-subnet-group-${randomSuffix}`,
      subnetIds: [privateSubnetA.id, privateSubnetB.id],
    });

    new DbInstance(this, "rds-instance", {
      identifier: `app-db-${randomSuffix}`,
      allocatedStorage: 20,
      instanceClass: "db.t3.micro",
      engine: "mysql",
      engineVersion: "8.0",
      username: "admin",
      password: "MustBeChangedInSecretsManager1",
      dbSubnetGroupName: dbSubnetGroup.name,
      vpcSecurityGroupIds: [rdsSg.id],
      multiAz: true,
      backupRetentionPeriod: 7, // Enable automated backups
      skipFinalSnapshot: true,
    });

    // 6. ALB, Target Group, and Listener
    const alb = new Lb(this, "alb", {
      name: `app-lb-${randomSuffix}`,
      internal: false,
      loadBalancerType: "application",
      securityGroups: [albSg.id],
      subnets: [publicSubnetA.id, publicSubnetB.id],
    });

    const targetGroup = new LbTargetGroup(this, "target-group", {
      name: `app-tg-${randomSuffix}`,
      port: 80,
      protocol: "HTTP",
      vpcId: vpc.id,
      healthCheck: {
        path: "/health",
        protocol: "HTTP",
      },
    });

    new LbListener(this, "listener", {
      loadBalancerArn: alb.arn,
      port: 80,
      protocol: "HTTP",
      defaultAction: [{
        type: "forward",
        targetGroupArn: targetGroup.arn,
      }],
    });

    // 7. Launch Template and Auto Scaling Group
    const ami = new DataAwsAmi(this, "amazon-linux-2", {
      mostRecent: true,
      filter: [
        { name: "name", values: ["amzn2-ami-hvm-*-x86_64-gp2"] },
        { name: "virtualization-type", values: ["hvm"] },
      ],
      owners: ["amazon"],
    });

    const launchTemplate = new LaunchTemplate(this, "launch-template", {
      name: `app-launch-template-${randomSuffix}`,
      imageId: ami.id,
      instanceType: "t3.micro",
      iamInstanceProfile: { name: instanceProfile.name },
      vpcSecurityGroupIds: [appSg.id],
      // User data can be added here to install CloudWatch agent, etc.
    });

    new AutoscalingGroup(this, "autoscaling-group", {
      name: `app-asg-${randomSuffix}`,
      launchTemplate: { id: launchTemplate.id, version: "$Latest" },
      minSize: 2,
      maxSize: 5,
      desiredCapacity: 2,
      vpcZoneIdentifier: [privateSubnetA.id, privateSubnetB.id],
      targetGroupArns: [targetGroup.arn],
    });

}
}

tests/tap-stack.unit.test.ts
import "./setup.js";

declare global {
namespace jest {
interface Matchers<R> {
toHaveResource(construct: any): R;
toHaveResourceWithProperties(construct: any, properties: any): R;
}
}
}

import { Testing, TerraformStack } from "cdktf";
import { TapStack } from "../lib/tap-stack";
import { Vpc } from "@cdktf/provider-aws/lib/vpc";
import { DbInstance } from "@cdktf/provider-aws/lib/db-instance";
import { AutoscalingGroup } from "@cdktf/provider-aws/lib/autoscaling-group";
import { Lb } from "@cdktf/provider-aws/lib/lb";
import { IamPolicy } from "@cdktf/provider-aws/lib/iam-policy";

describe("Unit Tests for TapStack", () => {
let stack: TerraformStack;
let synthesized: string;

beforeAll(() => {
const app = Testing.app();
stack = new TapStack(app, "test-stack", {
env: { region: "us-east-1" },
});
synthesized = Testing.synth(stack);
});

it("should create a VPC", () => {
expect(synthesized).toHaveResource(Vpc);
});

it("should create a Multi-AZ RDS instance with backups", () => {
expect(synthesized).toHaveResourceWithProperties(DbInstance, {
multi_az: true,
backup_retention_period: 7,
});
});

it("should create an Auto Scaling Group with correct capacity", () => {
expect(synthesized).toHaveResourceWithProperties(AutoscalingGroup, {
min_size: 2,
max_size: 5,
});
});

it("should create an Application Load Balancer", () => {
expect(synthesized).toHaveResource(Lb);
});

it("should create an IAM policy with least privilege for CloudWatch", () => {
expect(synthesized).toHaveResourceWithProperties(IamPolicy, {
policy: expect.stringContaining('"Resource":"${aws_cloudwatch_log_group.app-log-group.arn}:_"'),
});
// Ensure it doesn't have wildcard resource permissions
expect(synthesized).not.toHaveResourceWithProperties(IamPolicy, {
policy: expect.stringContaining('"Resource":"_"'),
});
});
});

tests/tap-stack.int.test.ts
import "./setup.js";

declare global {
namespace jest {
interface Matchers<R> {
toHaveResource(construct: any): R;
toHaveResourceWithProperties(construct: any, properties: any): R;
}
}
}

import { Testing, TerraformStack } from "cdktf";
import { TapStack } from "../lib/tap-stack";
import { SecurityGroup } from "@cdktf/provider-aws/lib/security-group";
import { AutoscalingGroup } from "@cdktf/provider-aws/lib/autoscaling-group";
import { Lb } from "@cdktf/provider-aws/lib/lb";
import { DbInstance } from "@cdktf/provider-aws/lib/db-instance";

describe("Integration Tests for TapStack", () => {
let stack: TerraformStack;
let synthesized: string;

beforeAll(() => {
const app = Testing.app();
stack = new TapStack(app, "test-stack", {
env: { region: "us-east-1" },
});
synthesized = Testing.synth(stack);
});

it("should place the ALB in public subnets", () => {
expect(synthesized).toHaveResourceWithProperties(Lb, {
subnets: [
"${aws_subnet.public-subnet-a.id}",
"${aws_subnet.public-subnet-b.id}",
],
});
});

it("should place the ASG in private subnets", () => {
expect(synthesized).toHaveResourceWithProperties(AutoscalingGroup, {
vpc_zone_identifier: [
"${aws_subnet.private-subnet-a.id}",
"${aws_subnet.private-subnet-b.id}",
],
});
});

it("should configure the App SG to only allow traffic from the ALB SG", () => {
expect(synthesized).toHaveResourceWithProperties(SecurityGroup, {
name: expect.stringMatching(/^app-sg-/),
ingress: expect.arrayContaining([
expect.objectContaining({
security_groups: ["${aws_security_group.alb-sg.id}"],
}),
]),
});
});

it("should configure the DB SG to only allow traffic from the App SG", () => {
expect(synthesized).toHaveResourceWithProperties(SecurityGroup, {
name: expect.stringMatching(/^rds-sg-/),
ingress: expect.arrayContaining([
expect.objectContaining({
security_groups: ["${aws_security_group.app-sg.id}"],
}),
]),
});
});

it("should associate the RDS instance with the DB security group", () => {
expect(synthesized).toHaveResourceWithProperties(DbInstance, {
vpc_security_group_ids: ["${aws_security_group.rds-sg.id}"]
});
});
});
