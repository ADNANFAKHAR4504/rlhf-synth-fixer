import fs from 'fs';
import path from 'path';
import { S3Client, GetBucketNotificationConfigurationCommand, GetBucketNotificationConfigurationCommandOutput, PutObjectCommand } from '@aws-sdk/client-s3';
import { LambdaClient, InvokeCommand } from '@aws-sdk/client-lambda';
import { IAMClient, GetRolePolicyCommand } from '@aws-sdk/client-iam';
import { CloudWatchLogsClient, DescribeLogStreamsCommand, GetLogEventsCommand } from '@aws-sdk/client-cloudwatch-logs';

// Helper function to wait
const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

// Load CloudFormation Outputs after successful CDK deploy
let outputs: any;
try {
  // This file is expected to be generated by your CloudFormation deployment process.
  // Make sure your deployment pipeline saves outputs to this path.
  outputs = JSON.parse(
    fs.readFileSync('cfn-outputs/flat-outputs.json', 'utf8')
  );
} catch (error) {
  console.error("Could not load cfn-outputs/flat-outputs.json. Please ensure your CloudFormation stack is deployed and outputs are saved.");
  console.error(error);
  // Exit the process if outputs are not available, as integration tests cannot proceed.
  // This ensures the test runner doesn't try to run these tests without deployed resources.
  process.exit(1); 
}

// Extract CloudFormation outputs
const s3BucketName = outputs.S3BucketName;
const lambdaFunctionName = outputs.LambdaFunctionName;
const lambdaExecutionRoleArn = outputs.LambdaExecutionRoleArn;

// Add explicit checks for required outputs before proceeding
if (!s3BucketName) {
  throw new Error("CloudFormation output 'S3BucketName' is missing. Ensure the stack is deployed and outputs are correctly saved.");
}
if (!lambdaFunctionName) {
  throw new Error("CloudFormation output 'LambdaFunctionName' is missing. Ensure the stack is deployed and outputs are correctly saved.");
}
if (!lambdaExecutionRoleArn) {
  throw new Error("CloudFormation output 'LambdaExecutionRoleArn' is missing. Ensure the stack is deployed and outputs are correctly saved.");
}

const accountId = lambdaExecutionRoleArn.split(':')[4]; // Extract account ID from ARN
const awsRegion = process.env.AWS_REGION || 'us-east-1'; // Use environment variable for region

// Initialize AWS SDK clients
const s3 = new S3Client({ region: awsRegion });
const lambda = new LambdaClient({ region: awsRegion });
const iam = new IAMClient({ region: awsRegion });
const cloudwatch = new CloudWatchLogsClient({ region: awsRegion });

// Define test data
const testObjectKey = `test-object-${Date.now()}.txt`; // Unique object key for each test run
const testPayload = { key: 'value' }; // Example payload for direct Lambda invocation (if needed)


describe('Lambda Triggered by S3 Events Integration Tests', () => {

  describe('Lambda Function and S3 Bucket Integration', () => {

    // Test: Verify that the Lambda function can be triggered by an S3 event
    test('Lambda should be triggered by S3 object creation and process the event', async () => {
      // Check if the Lambda function and S3 bucket are properly deployed
      expect(s3BucketName).toBeDefined();
      expect(lambdaFunctionName).toBeDefined();

      // Upload a test object to the S3 bucket to trigger the Lambda function
      const params = {
        Bucket: s3BucketName,
        Key: testObjectKey,
        Body: 'Test content for S3 trigger',
      };

      try {
        console.log(`Uploading object '${testObjectKey}' to bucket '${s3BucketName}'...`);
        await s3.send(new PutObjectCommand(params));
        console.log('Object uploaded. Waiting for Lambda to process...');

        // Wait for the Lambda function to be triggered and logs to appear
        await sleep(10000); // Increased wait time to ensure logs are propagated

        // Verify Lambda execution by checking CloudWatch logs for specific messages
        const logGroupName = `/aws/lambda/${lambdaFunctionName}`;
        let logEvents: any[] = [];
        let nextToken: string | undefined;

        // Retry fetching logs to account for potential delays
        for (let i = 0; i < 5; i++) {
          const logStreamsResponse = await cloudwatch.send(new DescribeLogStreamsCommand({
            logGroupName,
            orderBy: 'LastEventTime',
            descending: true,
            limit: 1, // Get the most recent log stream
          }));

          const latestLogStreamName = logStreamsResponse.logStreams?.[0]?.logStreamName;

          if (latestLogStreamName) {
            const getLogEventsResponse = await cloudwatch.send(new GetLogEventsCommand({
              logGroupName,
              logStreamName: latestLogStreamName,
              startTime: Date.now() - 60 * 1000, // Look for logs in the last 60 seconds
              limit: 50,
            }));
            logEvents = getLogEventsResponse.events || [];
            nextToken = getLogEventsResponse.nextForwardToken;

            const foundLog = logEvents.some(event => 
              event.message?.includes(`Successfully processed S3 event for key: ${testObjectKey}`)
            );

            if (foundLog) {
              console.log(`Found log for S3 event processing of key: ${testObjectKey}`);
              break; // Found the log, exit retry loop
            }
          }
          await sleep(5000); // Wait before retrying log fetch
        }

        const s3EventProcessedLog = logEvents.find(event =>
          event.message?.includes(`Successfully processed S3 event for key: ${testObjectKey}`)
        );

        expect(s3EventProcessedLog).toBeDefined(); // Assert that the log indicating S3 event processing was found

      } catch (error) {
        console.error('Error occurred during the S3 upload or Lambda log verification:', error);
        expect(error).toBeNull(); // Handle error gracefully
      }
    }, 30000); // Increased timeout for this test to 30 seconds

    // Test: Verify the IAM role permissions for Lambda to access S3
    test('Lambda should have the correct IAM role to access S3', async () => {
      try {
        // Get the IAM role policy attached to the Lambda execution role
        const roleName = lambdaExecutionRoleArn.substring(lambdaExecutionRoleArn.lastIndexOf('/') + 1);
        const policyResponse = await iam.send(new GetRolePolicyCommand({
          RoleName: roleName,
          PolicyName: 'LambdaS3AccessAndLogsPolicy', // Corrected policy name
        }));

        // Decode and parse the policy document
        const decodedPolicyDocument = decodeURIComponent(policyResponse.PolicyDocument!);
        const policyJson = JSON.parse(decodedPolicyDocument);

        // Validate the IAM policy includes the correct permissions to access S3
        const s3Statement = policyJson.Statement.find((s: any) => 
          Array.isArray(s.Action) ? s.Action.includes('s3:GetObject') : s.Action === 's3:GetObject'
        );

        expect(s3Statement).toBeDefined();
        expect(s3Statement.Resource).toContain(s3BucketName); // Validate the bucket name is included

      } catch (error) {
        console.error('Error occurred while fetching IAM role policy:', error);
        expect(error).toBeNull(); // Handle error gracefully
      }
    });

  });

  describe('S3 Bucket Notification Configuration', () => {

    // Test: Verify that S3 bucket notification is configured correctly for Lambda trigger
    test('S3 bucket should have a notification configured for Lambda function', async () => {
      try {
        // Get the bucket notification configuration
        const notificationConfig: GetBucketNotificationConfigurationCommandOutput = await s3.send(new GetBucketNotificationConfigurationCommand({
          Bucket: s3BucketName,
        }));

        // Verify that the Lambda function is listed as an event source
        const expectedLambdaArn = `arn:aws:lambda:${awsRegion}:${accountId}:function:${lambdaFunctionName}`;
        const lambdaConfig = notificationConfig.LambdaFunctionConfigurations?.find(
          (config) => config.LambdaFunctionArn === expectedLambdaArn // Corrected property to LambdaFunctionArn
        );

        expect(lambdaConfig).toBeDefined();
        expect(lambdaConfig?.Events).toContain('s3:ObjectCreated:*');  // Check for object creation event trigger

      } catch (error) {
        console.error('Error occurred while checking S3 bucket notification configuration:', error);
        expect(error).toBeNull(); // Handle error gracefully
      }
    });

  });

  describe('Error Handling', () => {

    // Test: Ensure Lambda handles errors gracefully if incorrect payload is sent
    test('Lambda should handle invalid payload gracefully', async () => {
      const invalidPayload = {
        invalidKey: 'invalidValue',
      };

      try {
        // Invoke Lambda directly with invalid payload
        const lambdaResponse = await lambda.send(new InvokeCommand({
          FunctionName: lambdaFunctionName,
          Payload: JSON.stringify(invalidPayload),
        }));

        const responsePayload = JSON.parse(new TextDecoder().decode(lambdaResponse.Payload!));

        // Lambda always returns 200 for successful invocation, but application-level status is in payload.
        expect(lambdaResponse.StatusCode).toBe(200); 
        expect(responsePayload).toHaveProperty('statusCode', 400);
        
        // Parse the 'body' string within the responsePayload to check its 'message' property
        const parsedBody = JSON.parse(responsePayload.body);
        expect(parsedBody).toHaveProperty('message', 'Invalid input: Expected an S3 object creation event.');

      } catch (error) {
        console.error('Error occurred during Lambda invocation with invalid payload:', error);
        expect(error).toBeNull(); // Handle error gracefully
      }
    });

  });

  describe('CloudWatch Logs', () => {
    // Test: Check if Lambda logs exist in CloudWatch after being triggered
    test('Lambda should write logs to CloudWatch', async () => {
      try {
        // Fetch the CloudWatch log streams for the Lambda function
        const logGroupName = `/aws/lambda/${lambdaFunctionName}`;
        
        let logStreams: any[] = [];
        // Retry fetching log streams to account for potential delays
        for (let i = 0; i < 5; i++) {
          const describeLogStreamsResponse = await cloudwatch.send(new DescribeLogStreamsCommand({
            logGroupName,
            orderBy: 'LastEventTime',
            descending: true,
          }));
          logStreams = describeLogStreamsResponse.logStreams || [];
          if (logStreams.length > 0) {
            break; // Found log streams, exit retry loop
          }
          await sleep(5000); // Wait before retrying
        }

        // Verify that at least one log stream exists for the Lambda function
        expect(logStreams.length).toBeGreaterThan(0);
        expect(logStreams[0].logStreamName).toBeDefined();

      } catch (error) {
        console.error('Error occurred while fetching CloudWatch logs:', error);
        expect(error).toBeNull(); // Handle error gracefully
      }
    }, 20000); // Increased timeout for log verification
  });

});
