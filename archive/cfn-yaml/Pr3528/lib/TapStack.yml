AWSTemplateFormatVersion: '2010-09-09'
Description: 'TAP Stack - Task Assignment Platform CloudFormation Template with Complete Feedback System'

Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: 'Environment Configuration'
        Parameters:
          - EnvironmentSuffix
      - Label:
          default: 'Notification Configuration'
        Parameters:
          - NotificationEmail

Parameters:
  EnvironmentSuffix:
    Type: String
    Default: 'dev'
    Description: 'Environment suffix for resource naming (e.g., dev, staging, prod)'
    AllowedPattern: '^[a-zA-Z0-9]+$'
    ConstraintDescription: 'Must contain only alphanumeric characters'
  
  NotificationEmail:
    Type: String
    Default: 'noreply@example.com'
    Description: 'Email address for weekly report notifications'
    AllowedPattern: '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    ConstraintDescription: 'Must be a valid email address'

Resources:
  # Enhanced DynamoDB Table with GSI for feedback data
  TurnAroundPromptTable:
    Type: AWS::DynamoDB::Table
    DeletionPolicy: Delete
    UpdateReplacePolicy: Delete
    Properties:
      TableName: !Sub 'TurnAroundPromptTable${EnvironmentSuffix}'
      AttributeDefinitions:
        - AttributeName: 'id'
          AttributeType: 'S'
        - AttributeName: 'timestamp'
          AttributeType: 'N'
        - AttributeName: 'sentiment'
          AttributeType: 'S'
        - AttributeName: 'datePartition'
          AttributeType: 'S'
      KeySchema:
        - AttributeName: 'id'
          KeyType: 'HASH'
      BillingMode: PAY_PER_REQUEST
      DeletionProtectionEnabled: false
      GlobalSecondaryIndexes:
        - IndexName: 'DateSentimentIndex'
          KeySchema:
            - AttributeName: 'datePartition'
              KeyType: 'HASH'
            - AttributeName: 'timestamp'
              KeyType: 'RANGE'
          Projection:
            ProjectionType: 'ALL'
        - IndexName: 'SentimentTimestampIndex'
          KeySchema:
            - AttributeName: 'sentiment'
              KeyType: 'HASH'
            - AttributeName: 'timestamp'
              KeyType: 'RANGE'
          Projection:
            ProjectionType: 'ALL'
      StreamSpecification:
        StreamViewType: 'NEW_AND_OLD_IMAGES'
      Tags:
        - Key: 'iac-rlhf-amazon'
          Value: 'true'
        - Key: 'Environment'
          Value: !Ref EnvironmentSuffix

  # S3 Bucket for storing weekly reports
  ReportsBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub 'feedback-reports-${EnvironmentSuffix}-${AWS::AccountId}'
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: 'AES256'
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      VersioningConfiguration:
        Status: 'Enabled'
      LifecycleConfiguration:
        Rules:
          - Id: 'DeleteOldReports'
            Status: 'Enabled'
            ExpirationInDays: 90
      Tags:
        - Key: 'iac-rlhf-amazon'
          Value: 'true'
        - Key: 'Environment'
          Value: !Ref EnvironmentSuffix

  # IAM Role for Feedback Processing Lambda
  FeedbackProcessorRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub 'FeedbackProcessorRole-${EnvironmentSuffix}'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: 'Allow'
            Principal:
              Service: 'lambda.amazonaws.com'
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole'
      Policies:
        - PolicyName: 'FeedbackProcessorPolicy'
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: 'Allow'
                Action:
                  - 'dynamodb:PutItem'
                  - 'dynamodb:UpdateItem'
                  - 'dynamodb:GetItem'
                Resource: !GetAtt TurnAroundPromptTable.Arn
              - Effect: 'Allow'
                Action:
                  - 'comprehend:DetectSentiment'
                  - 'comprehend:DetectKeyPhrases'
                  - 'comprehend:DetectEntities'
                Resource: '*'
              - Effect: 'Allow'
                Action:
                  - 'logs:CreateLogGroup'
                  - 'logs:CreateLogStream'
                  - 'logs:PutLogEvents'
                Resource: !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:*'
              - Effect: 'Allow'
                Action:
                  - 'cloudwatch:PutMetricData'
                Resource: '*'
      Tags:
        - Key: 'iac-rlhf-amazon'
          Value: 'true'
        - Key: 'Environment'
          Value: !Ref EnvironmentSuffix

  # IAM Role for Report Generator Lambda
  ReportGeneratorRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub 'ReportGeneratorRole-${EnvironmentSuffix}'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: 'Allow'
            Principal:
              Service: 'lambda.amazonaws.com'
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole'
      Policies:
        - PolicyName: 'ReportGeneratorPolicy'
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: 'Allow'
                Action:
                  - 'dynamodb:Query'
                  - 'dynamodb:Scan'
                  - 'dynamodb:GetItem'
                Resource:
                  - !GetAtt TurnAroundPromptTable.Arn
                  - !Sub '${TurnAroundPromptTable.Arn}/index/*'
              - Effect: 'Allow'
                Action:
                  - 's3:PutObject'
                  - 's3:PutObjectAcl'
                Resource: !Sub '${ReportsBucket.Arn}/*'
              - Effect: 'Allow'
                Action:
                  - 'ses:SendEmail'
                  - 'ses:SendRawEmail'
                Resource: '*'
              - Effect: 'Allow'
                Action:
                  - 'logs:CreateLogGroup'
                  - 'logs:CreateLogStream'
                  - 'logs:PutLogEvents'
                Resource: !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:*'
              - Effect: 'Allow'
                Action:
                  - 'cloudwatch:PutMetricData'
                Resource: '*'
      Tags:
        - Key: 'iac-rlhf-amazon'
          Value: 'true'
        - Key: 'Environment'
          Value: !Ref EnvironmentSuffix

  # Lambda Function for Processing Feedback
  FeedbackProcessorFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub 'FeedbackProcessor-${EnvironmentSuffix}'
      Runtime: 'python3.10'
      Handler: 'index.lambda_handler'
      Role: !GetAtt FeedbackProcessorRole.Arn
      Timeout: 30
      MemorySize: 256
      Environment:
        Variables:
          TABLE_NAME: !Ref TurnAroundPromptTable
          ENVIRONMENT: !Ref EnvironmentSuffix
      Code:
        ZipFile: |
          import json
          import boto3
          import uuid
          import time
          import logging
          from datetime import datetime
          from decimal import Decimal
          import os

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          dynamodb = boto3.resource('dynamodb')
          comprehend = boto3.client('comprehend')
          cloudwatch = boto3.client('cloudwatch')

          TABLE_NAME = os.environ['TABLE_NAME']
          ENVIRONMENT = os.environ['ENVIRONMENT']

          def decimal_default(obj):
              if isinstance(obj, Decimal):
                  return float(obj)
              raise TypeError

          def validate_input(body):
              """Validate input data"""
              errors = []
              
              if not body.get('feedback'):
                  errors.append('Feedback text is required')
              elif len(body['feedback']) < 10:
                  errors.append('Feedback must be at least 10 characters')
              elif len(body['feedback']) > 5000:
                  errors.append('Feedback must not exceed 5000 characters')
              
              if not body.get('userEmail'):
                  errors.append('User email is required')
              elif '@' not in body['userEmail']:
                  errors.append('Invalid email format')
              
              if not body.get('category'):
                  errors.append('Category is required')
              elif body['category'] not in ['general', 'bug', 'feature', 'improvement']:
                  errors.append('Invalid category. Must be: general, bug, feature, or improvement')
              
              return errors

          def analyze_sentiment(text):
              """Analyze sentiment using AWS Comprehend"""
              try:
                  response = comprehend.detect_sentiment(
                      Text=text,
                      LanguageCode='en'
                  )
                  
                  key_phrases_response = comprehend.detect_key_phrases(
                      Text=text,
                      LanguageCode='en'
                  )
                  
                  entities_response = comprehend.detect_entities(
                      Text=text,
                      LanguageCode='en'
                  )
                  
                  return {
                      'sentiment': response['Sentiment'],
                      'sentimentScores': response['SentimentScore'],
                      'keyPhrases': [phrase['Text'] for phrase in key_phrases_response.get('KeyPhrases', [])[:5]],
                      'entities': [{'Text': entity['Text'], 'Type': entity['Type']} 
                                 for entity in entities_response.get('Entities', [])[:5]]
                  }
              except Exception as e:
                  logger.error(f"Comprehend analysis failed: {str(e)}")
                  return {
                      'sentiment': 'NEUTRAL',
                      'sentimentScores': {'Positive': 0, 'Negative': 0, 'Neutral': 1, 'Mixed': 0},
                      'keyPhrases': [],
                      'entities': []
                  }

          def send_metrics(sentiment):
              """Send custom metrics to CloudWatch"""
              try:
                  cloudwatch.put_metric_data(
                      Namespace=f'FeedbackSystem/{ENVIRONMENT}',
                      MetricData=[
                          {
                              'MetricName': 'FeedbackSubmissions',
                              'Value': 1,
                              'Unit': 'Count',
                              'Dimensions': [
                                  {
                                      'Name': 'Sentiment',
                                      'Value': sentiment
                                  },
                                  {
                                      'Name': 'Environment',
                                      'Value': ENVIRONMENT
                                  }
                              ]
                          }
                      ]
                  )
              except Exception as e:
                  logger.error(f"Failed to send metrics: {str(e)}")

          def lambda_handler(event, context):
              """Main Lambda handler for processing feedback"""
              try:
                  # Parse request body
                  if isinstance(event.get('body'), str):
                      body = json.loads(event['body'])
                  else:
                      body = event.get('body', {})
                  
                  # Validate input
                  validation_errors = validate_input(body)
                  if validation_errors:
                      return {
                          'statusCode': 400,
                          'headers': {
                              'Content-Type': 'application/json',
                              'Access-Control-Allow-Origin': '*'
                          },
                          'body': json.dumps({
                              'error': 'Validation failed',
                              'details': validation_errors
                          })
                      }
                  
                  # Analyze sentiment
                  sentiment_data = analyze_sentiment(body['feedback'])
                  
                  # Prepare item for DynamoDB
                  timestamp = int(time.time())
                  date_partition = datetime.utcfromtimestamp(timestamp).strftime('%Y-%m')
                  
                  item = {
                      'id': str(uuid.uuid4()),
                      'timestamp': timestamp,
                      'datePartition': date_partition,
                      'feedback': body['feedback'],
                      'userEmail': body['userEmail'],
                      'category': body['category'],
                      'sentiment': sentiment_data['sentiment'],
                      'sentimentScores': sentiment_data['sentimentScores'],
                      'keyPhrases': sentiment_data['keyPhrases'],
                      'entities': sentiment_data['entities'],
                      'createdAt': datetime.utcnow().isoformat(),
                      'environment': ENVIRONMENT,
                      'rating': body.get('rating', 0),
                      'metadata': body.get('metadata', {})
                  }
                  
                  # Store in DynamoDB
                  table = dynamodb.Table(TABLE_NAME)
                  table.put_item(Item=item)
                  
                  # Send metrics
                  send_metrics(sentiment_data['sentiment'])
                  
                  logger.info(f"Successfully processed feedback: {item['id']}")
                  
                  return {
                      'statusCode': 200,
                      'headers': {
                          'Content-Type': 'application/json',
                          'Access-Control-Allow-Origin': '*'
                      },
                      'body': json.dumps({
                          'message': 'Feedback processed successfully',
                          'feedbackId': item['id'],
                          'sentiment': sentiment_data['sentiment']
                      }, default=decimal_default)
                  }
                  
              except Exception as e:
                  logger.error(f"Error processing feedback: {str(e)}")
                  return {
                      'statusCode': 500,
                      'headers': {
                          'Content-Type': 'application/json',
                          'Access-Control-Allow-Origin': '*'
                      },
                      'body': json.dumps({
                          'error': 'Internal server error',
                          'message': 'Failed to process feedback'
                      })
                  }
      Tags:
        - Key: 'iac-rlhf-amazon'
          Value: 'true'
        - Key: 'Environment'
          Value: !Ref EnvironmentSuffix

  # Lambda Function for Generating Reports
  ReportGeneratorFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub 'ReportGenerator-${EnvironmentSuffix}'
      Runtime: 'python3.10'
      Handler: 'index.lambda_handler'
      Role: !GetAtt ReportGeneratorRole.Arn
      Timeout: 60
      MemorySize: 512
      Environment:
        Variables:
          TABLE_NAME: !Ref TurnAroundPromptTable
          BUCKET_NAME: !Ref ReportsBucket
          NOTIFICATION_EMAIL: !Ref NotificationEmail
          ENVIRONMENT: !Ref EnvironmentSuffix
      Code:
        ZipFile: |
          import json
          import boto3
          import logging
          import os
          from datetime import datetime, timedelta
          from collections import defaultdict
          from decimal import Decimal

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          dynamodb = boto3.resource('dynamodb')
          s3 = boto3.client('s3')
          ses = boto3.client('ses')
          cloudwatch = boto3.client('cloudwatch')

          TABLE_NAME = os.environ['TABLE_NAME']
          BUCKET_NAME = os.environ['BUCKET_NAME']
          NOTIFICATION_EMAIL = os.environ['NOTIFICATION_EMAIL']
          ENVIRONMENT = os.environ['ENVIRONMENT']

          def decimal_default(obj):
              if isinstance(obj, Decimal):
                  return float(obj)
              raise TypeError

          def query_weekly_feedback():
              """Query feedback from the last 7 days"""
              table = dynamodb.Table(TABLE_NAME)
              
              # Calculate date range
              end_date = datetime.utcnow()
              start_date = end_date - timedelta(days=7)
              start_timestamp = int(start_date.timestamp())
              end_timestamp = int(end_date.timestamp())
              
              # Get current and previous month partitions
              partitions = [
                  start_date.strftime('%Y-%m'),
                  end_date.strftime('%Y-%m')
              ]
              
              all_items = []
              
              for partition in set(partitions):
                  try:
                      response = table.query(
                          IndexName='DateSentimentIndex',
                          KeyConditionExpression='datePartition = :partition AND #ts BETWEEN :start AND :end',
                          ExpressionAttributeNames={
                              '#ts': 'timestamp'
                          },
                          ExpressionAttributeValues={
                              ':partition': partition,
                              ':start': start_timestamp,
                              ':end': end_timestamp
                          }
                      )
                      all_items.extend(response.get('Items', []))
                      
                      # Handle pagination
                      while 'LastEvaluatedKey' in response:
                          response = table.query(
                              IndexName='DateSentimentIndex',
                              KeyConditionExpression='datePartition = :partition AND #ts BETWEEN :start AND :end',
                              ExpressionAttributeNames={
                                  '#ts': 'timestamp'
                              },
                              ExpressionAttributeValues={
                                  ':partition': partition,
                                  ':start': start_timestamp,
                                  ':end': end_timestamp
                              },
                              ExclusiveStartKey=response['LastEvaluatedKey']
                          )
                          all_items.extend(response.get('Items', []))
                  except Exception as e:
                      logger.error(f"Error querying partition {partition}: {str(e)}")
              
              return all_items

          def generate_report(feedback_items):
              """Generate weekly report from feedback items"""
              report = {
                  'reportDate': datetime.utcnow().isoformat(),
                  'environment': ENVIRONMENT,
                  'totalFeedback': len(feedback_items),
                  'dateRange': {
                      'start': (datetime.utcnow() - timedelta(days=7)).isoformat(),
                      'end': datetime.utcnow().isoformat()
                  }
              }
              
              # Analyze sentiments
              sentiment_counts = defaultdict(int)
              category_counts = defaultdict(int)
              sentiment_scores_sum = defaultdict(float)
              ratings = []
              key_phrases_all = []
              
              for item in feedback_items:
                  sentiment_counts[item.get('sentiment', 'UNKNOWN')] += 1
                  category_counts[item.get('category', 'uncategorized')] += 1
                  
                  if 'rating' in item and item['rating']:
                      ratings.append(float(item['rating']))
                  
                  if 'sentimentScores' in item:
                      for key, value in item['sentimentScores'].items():
                          sentiment_scores_sum[key] += float(value)
                  
                  if 'keyPhrases' in item:
                      key_phrases_all.extend(item['keyPhrases'])
              
              # Calculate averages
              if feedback_items:
                  avg_sentiment_scores = {
                      key: value / len(feedback_items) 
                      for key, value in sentiment_scores_sum.items()
                  }
              else:
                  avg_sentiment_scores = {}
              
              # Find top key phrases
              phrase_counts = defaultdict(int)
              for phrase in key_phrases_all:
                  phrase_counts[phrase] += 1
              top_phrases = sorted(phrase_counts.items(), key=lambda x: x[1], reverse=True)[:10]
              
              report['sentimentDistribution'] = dict(sentiment_counts)
              report['categoryDistribution'] = dict(category_counts)
              report['averageSentimentScores'] = avg_sentiment_scores
              report['averageRating'] = sum(ratings) / len(ratings) if ratings else 0
              report['topKeyPhrases'] = [{'phrase': phrase, 'count': count} for phrase, count in top_phrases]
              
              # Add sample feedback by sentiment
              report['samplesBysentiment'] = {}
              for sentiment in ['POSITIVE', 'NEGATIVE', 'NEUTRAL', 'MIXED']:
                  samples = [item for item in feedback_items if item.get('sentiment') == sentiment][:2]
                  report['samplesBysentiment'][sentiment] = [
                      {
                          'feedback': sample.get('feedback', ''),
                          'category': sample.get('category', ''),
                          'rating': float(sample.get('rating', 0))
                      }
                      for sample in samples
                  ]
              
              return report

          def save_report_to_s3(report):
              """Save report to S3"""
              timestamp = datetime.utcnow()
              file_key = f"reports/{ENVIRONMENT}/{timestamp.strftime('%Y/%m')}/weekly_report_{timestamp.strftime('%Y%m%d_%H%M%S')}.json"
              
              s3.put_object(
                  Bucket=BUCKET_NAME,
                  Key=file_key,
                  Body=json.dumps(report, indent=2, default=decimal_default),
                  ContentType='application/json',
                  Metadata={
                      'environment': ENVIRONMENT,
                      'report_type': 'weekly',
                      'generated_at': timestamp.isoformat()
                  }
              )
              
              return file_key

          def send_email_notification(report, report_url):
              """Send email notification with report summary"""
              subject = f"Weekly Feedback Report - {ENVIRONMENT} - {datetime.utcnow().strftime('%Y-%m-%d')}"
              
              html_body = f"""
              <html>
              <head></head>
              <body>
                  <h1>Weekly Feedback Report</h1>
                  <p>Environment: <strong>{ENVIRONMENT}</strong></p>
                  <p>Report Date: <strong>{report['reportDate']}</strong></p>
                  
                  <h2>Summary</h2>
                  <ul>
                      <li>Total Feedback: <strong>{report['totalFeedback']}</strong></li>
                      <li>Average Rating: <strong>{report['averageRating']:.2f}</strong></li>
                  </ul>
                  
                  <h2>Sentiment Distribution</h2>
                  <ul>
                      {"".join([f"<li>{k}: {v}</li>" for k, v in report.get('sentimentDistribution', {}).items()])}
                  </ul>
                  
                  <h2>Category Distribution</h2>
                  <ul>
                      {"".join([f"<li>{k}: {v}</li>" for k, v in report.get('categoryDistribution', {}).items()])}
                  </ul>
                  
                  <h2>Top Key Phrases</h2>
                  <ol>
                      {"".join([f"<li>{phrase['phrase']} ({phrase['count']} mentions)</li>" for phrase in report.get('topKeyPhrases', [])[:5]])}
                  </ol>
                  
                  <p>Full report available at: <a href="{report_url}">{report_url}</a></p>
              </body>
              </html>
              """
              
              text_body = f"""
              Weekly Feedback Report
              Environment: {ENVIRONMENT}
              Report Date: {report['reportDate']}
              
              Summary:
              - Total Feedback: {report['totalFeedback']}
              - Average Rating: {report['averageRating']:.2f}
              
              Full report available at: {report_url}
              """
              
              try:
                  ses.send_email(
                      Source=NOTIFICATION_EMAIL,
                      Destination={'ToAddresses': [NOTIFICATION_EMAIL]},
                      Message={
                          'Subject': {'Data': subject},
                          'Body': {
                              'Text': {'Data': text_body},
                              'Html': {'Data': html_body}
                          }
                      }
                  )
                  logger.info(f"Email notification sent to {NOTIFICATION_EMAIL}")
              except Exception as e:
                  logger.error(f"Failed to send email: {str(e)}")
                  # Don't fail the entire function if email fails

          def send_metrics(report):
              """Send report metrics to CloudWatch"""
              try:
                  cloudwatch.put_metric_data(
                      Namespace=f'FeedbackSystem/{ENVIRONMENT}',
                      MetricData=[
                          {
                              'MetricName': 'WeeklyReportGenerated',
                              'Value': 1,
                              'Unit': 'Count'
                          },
                          {
                              'MetricName': 'WeeklyFeedbackCount',
                              'Value': report['totalFeedback'],
                              'Unit': 'Count'
                          },
                          {
                              'MetricName': 'WeeklyAverageRating',
                              'Value': report['averageRating'],
                              'Unit': 'None'
                          }
                      ]
                  )
              except Exception as e:
                  logger.error(f"Failed to send metrics: {str(e)}")

          def lambda_handler(event, context):
              """Main Lambda handler for generating reports"""
              try:
                  logger.info("Starting weekly report generation")
                  
                  # Query feedback data
                  feedback_items = query_weekly_feedback()
                  logger.info(f"Found {len(feedback_items)} feedback items")
                  
                  # Generate report
                  report = generate_report(feedback_items)
                  
                  # Save to S3
                  report_key = save_report_to_s3(report)
                  report_url = f"https://{BUCKET_NAME}.s3.amazonaws.com/{report_key}"
                  logger.info(f"Report saved to S3: {report_key}")
                  
                  # Send email notification
                  send_email_notification(report, report_url)
                  
                  # Send metrics
                  send_metrics(report)
                  
                  return {
                      'statusCode': 200,
                      'body': json.dumps({
                          'message': 'Report generated successfully',
                          'reportKey': report_key,
                          'totalFeedback': report['totalFeedback']
                      }, default=decimal_default)
                  }
                  
              except Exception as e:
                  logger.error(f"Error generating report: {str(e)}")
                  return {
                      'statusCode': 500,
                      'body': json.dumps({
                          'error': 'Failed to generate report',
                          'details': str(e)
                      })
                  }
      Tags:
        - Key: 'iac-rlhf-amazon'
          Value: 'true'
        - Key: 'Environment'
          Value: !Ref EnvironmentSuffix

  # API Gateway REST API
  FeedbackApi:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: !Sub 'FeedbackAPI-${EnvironmentSuffix}'
      Description: 'REST API for feedback submission'
      EndpointConfiguration:
        Types:
          - 'REGIONAL'
      Tags:
        - Key: 'iac-rlhf-amazon'
          Value: 'true'
        - Key: 'Environment'
          Value: !Ref EnvironmentSuffix

  # API Gateway Request Validator
  ApiRequestValidator:
    Type: AWS::ApiGateway::RequestValidator
    Properties:
      Name: 'RequestBodyValidator'
      RestApiId: !Ref FeedbackApi
      ValidateRequestBody: true
      ValidateRequestParameters: false

  # API Gateway Model for Request Validation
  FeedbackModel:
    Type: AWS::ApiGateway::Model
    Properties:
      ContentType: 'application/json'
      Name: 'FeedbackModel'
      RestApiId: !Ref FeedbackApi
      Schema:
        $schema: 'http://json-schema.org/draft-04/schema#'
        title: 'Feedback'
        type: 'object'
        required:
          - 'feedback'
          - 'userEmail'
          - 'category'
        properties:
          feedback:
            type: 'string'
            minLength: 10
            maxLength: 5000
          userEmail:
            type: 'string'
            pattern: '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
          category:
            type: 'string'
            enum:
              - 'general'
              - 'bug'
              - 'feature'
              - 'improvement'
          rating:
            type: 'number'
            minimum: 1
            maximum: 5
          metadata:
            type: 'object'

  # API Gateway Resource
  FeedbackResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      ParentId: !GetAtt FeedbackApi.RootResourceId
      PathPart: 'feedback'
      RestApiId: !Ref FeedbackApi

  # API Gateway Method
  FeedbackMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      AuthorizationType: 'NONE'
      HttpMethod: 'POST'
      ResourceId: !Ref FeedbackResource
      RestApiId: !Ref FeedbackApi
      RequestValidatorId: !Ref ApiRequestValidator
      RequestModels:
        application/json: !Ref FeedbackModel
      Integration:
        Type: 'AWS_PROXY'
        IntegrationHttpMethod: 'POST'
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${FeedbackProcessorFunction.Arn}/invocations'
      MethodResponses:
        - StatusCode: 200
          ResponseModels:
            application/json: 'Empty'
        - StatusCode: 400
        - StatusCode: 500

  # Lambda Permission for API Gateway
  ApiGatewayInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref FeedbackProcessorFunction
      Action: 'lambda:InvokeFunction'
      Principal: 'apigateway.amazonaws.com'
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${FeedbackApi}/*/*'

  # API Gateway Deployment
  ApiDeployment:
    Type: AWS::ApiGateway::Deployment
    DependsOn:
      - FeedbackMethod
    Properties:
      RestApiId: !Ref FeedbackApi
      StageName: !Ref EnvironmentSuffix

  # EventBridge Rule for Weekly Reports (Every Monday at 9 AM UTC)
  WeeklyReportSchedule:
    Type: AWS::Events::Rule
    Properties:
      Name: !Sub 'WeeklyReportSchedule-${EnvironmentSuffix}'
      Description: 'Trigger weekly report generation every Monday at 9 AM UTC'
      ScheduleExpression: 'cron(0 9 ? * MON *)'
      State: 'ENABLED'
      Targets:
        - Arn: !GetAtt ReportGeneratorFunction.Arn
          Id: 'ReportGeneratorTarget'

  # Permission for EventBridge to invoke Lambda
  EventBridgeInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref ReportGeneratorFunction
      Action: 'lambda:InvokeFunction'
      Principal: 'events.amazonaws.com'
      SourceArn: !GetAtt WeeklyReportSchedule.Arn

  # CloudWatch Alarms
  FeedbackProcessorErrorAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !Sub 'FeedbackProcessor-Errors-${EnvironmentSuffix}'
      AlarmDescription: 'Alert when feedback processor Lambda has errors'
      MetricName: 'Errors'
      Namespace: 'AWS/Lambda'
      Statistic: 'Sum'
      Period: 300
      EvaluationPeriods: 1
      Threshold: 5
      ComparisonOperator: 'GreaterThanThreshold'
      Dimensions:
        - Name: 'FunctionName'
          Value: !Ref FeedbackProcessorFunction
      TreatMissingData: 'notBreaching'

  ReportGeneratorErrorAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !Sub 'ReportGenerator-Errors-${EnvironmentSuffix}'
      AlarmDescription: 'Alert when report generator Lambda has errors'
      MetricName: 'Errors'
      Namespace: 'AWS/Lambda'
      Statistic: 'Sum'
      Period: 300
      EvaluationPeriods: 1
      Threshold: 1
      ComparisonOperator: 'GreaterThanThreshold'
      Dimensions:
        - Name: 'FunctionName'
          Value: !Ref ReportGeneratorFunction
      TreatMissingData: 'notBreaching'

  ApiGateway4xxAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !Sub 'API-4xx-Errors-${EnvironmentSuffix}'
      AlarmDescription: 'Alert when API has high 4xx error rate'
      MetricName: '4XXError'
      Namespace: 'AWS/ApiGateway'
      Statistic: 'Sum'
      Period: 300
      EvaluationPeriods: 2
      Threshold: 10
      ComparisonOperator: 'GreaterThanThreshold'
      Dimensions:
        - Name: 'ApiName'
          Value: !Sub 'FeedbackAPI-${EnvironmentSuffix}'
        - Name: 'Stage'
          Value: !Ref EnvironmentSuffix
      TreatMissingData: 'notBreaching'

  ApiGateway5xxAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !Sub 'API-5xx-Errors-${EnvironmentSuffix}'
      AlarmDescription: 'Alert when API has 5xx errors'
      MetricName: '5XXError'
      Namespace: 'AWS/ApiGateway'
      Statistic: 'Sum'
      Period: 300
      EvaluationPeriods: 1
      Threshold: 3
      ComparisonOperator: 'GreaterThanThreshold'
      Dimensions:
        - Name: 'ApiName'
          Value: !Sub 'FeedbackAPI-${EnvironmentSuffix}'
        - Name: 'Stage'
          Value: !Ref EnvironmentSuffix
      TreatMissingData: 'notBreaching'

  # CloudWatch Log Groups
  FeedbackProcessorLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/aws/lambda/FeedbackProcessor-${EnvironmentSuffix}'
      RetentionInDays: 7

  ReportGeneratorLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/aws/lambda/ReportGenerator-${EnvironmentSuffix}'
      RetentionInDays: 7

Outputs:
  TurnAroundPromptTableName:
    Description: 'Name of the DynamoDB table'
    Value: !Ref TurnAroundPromptTable
    Export:
      Name: !Sub '${AWS::StackName}-TurnAroundPromptTableName'

  TurnAroundPromptTableArn:
    Description: 'ARN of the DynamoDB table'
    Value: !GetAtt TurnAroundPromptTable.Arn
    Export:
      Name: !Sub '${AWS::StackName}-TurnAroundPromptTableArn'

  ApiEndpoint:
    Description: 'API Gateway endpoint URL for feedback submission'
    Value: !Sub 'https://${FeedbackApi}.execute-api.${AWS::Region}.amazonaws.com/${EnvironmentSuffix}/feedback'
    Export:
      Name: !Sub '${AWS::StackName}-ApiEndpoint'

  ReportsBucketName:
    Description: 'Name of the S3 bucket for reports'
    Value: !Ref ReportsBucket
    Export:
      Name: !Sub '${AWS::StackName}-ReportsBucketName'

  FeedbackProcessorFunctionArn:
    Description: 'ARN of the Feedback Processor Lambda function'
    Value: !GetAtt FeedbackProcessorFunction.Arn
    Export:
      Name: !Sub '${AWS::StackName}-FeedbackProcessorFunctionArn'

  ReportGeneratorFunctionArn:
    Description: 'ARN of the Report Generator Lambda function'
    Value: !GetAtt ReportGeneratorFunction.Arn
    Export:
      Name: !Sub '${AWS::StackName}-ReportGeneratorFunctionArn'

  StackName:
    Description: 'Name of this CloudFormation stack'
    Value: !Ref AWS::StackName
    Export:
      Name: !Sub '${AWS::StackName}-StackName'

  EnvironmentSuffix:
    Description: 'Environment suffix used for this deployment'
    Value: !Ref EnvironmentSuffix
    Export:
      Name: !Sub '${AWS::StackName}-EnvironmentSuffix'
