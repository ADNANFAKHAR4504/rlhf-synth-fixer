import fs from 'fs';
import path from 'path';
import { randomBytes } from 'crypto';

const environmentSuffix = process.env.ENVIRONMENT_SUFFIX || 'dev';

// Generate unique test identifiers with randomness
const generateUniqueId = (): string => randomBytes(6).toString('hex');
const testRunId = generateUniqueId();

describe(`SecureAWSEnvironment-${testRunId} CloudFormation Template Unit Tests`, () => {
  let template: any;

  beforeAll(() => {
    const templatePath = path.join(__dirname, '../lib/TapStack.json');
    const templateContent = fs.readFileSync(templatePath, 'utf8');
    template = JSON.parse(templateContent);
  });

  describe(`TemplateStructure-${generateUniqueId()}`, () => {
    test(`should have valid CloudFormation format version - ${generateUniqueId()}`, () => {
      expect(template.AWSTemplateFormatVersion).toBe('2010-09-09');
    });

    test(`should have security-focused description - ${generateUniqueId()}`, () => {
      expect(template.Description).toBeDefined();
      expect(template.Description).toContain('Secure AWS Environment Setup');
      expect(template.Description).toContain('IAM 2FA');
      expect(template.Description).toContain('encrypted S3');
      expect(template.Description).toContain('CloudTrail logging');
    });

    test(`should have required sections - ${generateUniqueId()}`, () => {
      expect(template.Parameters).toBeDefined();
      expect(template.Resources).toBeDefined();
      expect(template.Outputs).toBeDefined();
    });
  });

  describe(`Parameters-${generateUniqueId()}`, () => {
    test(`should have EnvironmentName parameter - ${generateUniqueId()}`, () => {
      expect(template.Parameters.EnvironmentName).toBeDefined();
      expect(template.Parameters.EnvironmentName.Type).toBe('String');
      expect(template.Parameters.EnvironmentName.Default).toBe('SecureEnv');
    });

    test(`should not have CloudTrailBucketName parameter (auto-generated for uniqueness) - ${generateUniqueId()}`, () => {
      // CloudTrailBucketName parameter was removed to fix S3 endpoint addressing issues
      // The bucket name is now auto-generated by CloudFormation for global uniqueness
      expect(template.Parameters.CloudTrailBucketName).toBeUndefined();
    });
  });

  describe(`IAMSecurity-${generateUniqueId()}`, () => {
    test(`should have MFA enforcement policy - ${generateUniqueId()}`, () => {
      const mfaPolicy = template.Resources.EnforceMFAPolicy;
      expect(mfaPolicy).toBeDefined();
      expect(mfaPolicy.Type).toBe('AWS::IAM::ManagedPolicy');
      expect(mfaPolicy.Properties.Description).toContain('MFA');
    });

    test(`should enforce MFA in policy statements - ${generateUniqueId()}`, () => {
      const mfaPolicy = template.Resources.EnforceMFAPolicy;
      const statements = mfaPolicy.Properties.PolicyDocument.Statement;
      
      const denyStatement = statements.find((s: any) => s.Sid === 'DenyAllExceptUnlessSignedInWithMFA');
      expect(denyStatement).toBeDefined();
      expect(denyStatement.Effect).toBe('Deny');
      expect(denyStatement.Condition.BoolIfExists['aws:MultiFactorAuthPresent']).toBe('false');
    });

    test(`should have secure users group - ${generateUniqueId()}`, () => {
      const usersGroup = template.Resources.SecureUsersGroup;
      expect(usersGroup).toBeDefined();
      expect(usersGroup.Type).toBe('AWS::IAM::Group');
      expect(usersGroup.Properties.ManagedPolicyArns).toContainEqual({ Ref: 'EnforceMFAPolicy' });
    });

    test(`should have sample secure user with forced password reset - ${generateUniqueId()}`, () => {
      const sampleUser = template.Resources.SampleSecureUser;
      expect(sampleUser).toBeDefined();
      expect(sampleUser.Type).toBe('AWS::IAM::User');
      expect(sampleUser.Properties.LoginProfile.PasswordResetRequired).toBe(true);
      expect(sampleUser.Properties.Groups).toContainEqual({ Ref: 'SecureUsersGroup' });
    });

    test(`should have regional restriction policy for EC2 - ${generateUniqueId()}`, () => {
      const regionalPolicy = template.Resources.RegionalRestrictionPolicy;
      expect(regionalPolicy).toBeDefined();
      expect(regionalPolicy.Type).toBe('AWS::IAM::ManagedPolicy');
      
      const statements = regionalPolicy.Properties.PolicyDocument.Statement;
      const allowStatement = statements.find((s: any) => s.Sid === 'AllowEC2InUSWest2Only');
      expect(allowStatement.Condition.StringEquals['aws:RequestedRegion']).toBe('us-west-2');
    });
  });

  describe(`S3Security-${generateUniqueId()}`, () => {
    test(`should have encrypted S3 bucket - ${generateUniqueId()}`, () => {
      const s3Bucket = template.Resources.SecureS3Bucket;
      expect(s3Bucket).toBeDefined();
      expect(s3Bucket.Type).toBe('AWS::S3::Bucket');
      
      const encryption = s3Bucket.Properties.BucketEncryption.ServerSideEncryptionConfiguration[0];
      expect(encryption.ServerSideEncryptionByDefault.SSEAlgorithm).toBe('AES256');
    });

    test(`should block all public access on S3 bucket - ${generateUniqueId()}`, () => {
      const s3Bucket = template.Resources.SecureS3Bucket;
      const publicAccess = s3Bucket.Properties.PublicAccessBlockConfiguration;
      
      expect(publicAccess.BlockPublicAcls).toBe(true);
      expect(publicAccess.BlockPublicPolicy).toBe(true);
      expect(publicAccess.IgnorePublicAcls).toBe(true);
      expect(publicAccess.RestrictPublicBuckets).toBe(true);
    });

    test(`should have versioning enabled - ${generateUniqueId()}`, () => {
      const s3Bucket = template.Resources.SecureS3Bucket;
      expect(s3Bucket.Properties.VersioningConfiguration.Status).toBe('Enabled');
    });

    test(`should have secure transport policy - ${generateUniqueId()}`, () => {
      const bucketPolicy = template.Resources.SecureS3BucketPolicyAttachment;
      expect(bucketPolicy).toBeDefined();
      expect(bucketPolicy.Type).toBe('AWS::S3::BucketPolicy');
      
      const statements = bucketPolicy.Properties.PolicyDocument.Statement;
      const secureTransport = statements.find((s: any) => s.Sid === 'DenyInsecureConnections');
      expect(secureTransport.Condition.Bool['aws:SecureTransport']).toBe('false');
    });

    test(`should enforce encryption for uploads - ${generateUniqueId()}`, () => {
      const bucketPolicy = template.Resources.SecureS3BucketPolicyAttachment;
      const statements = bucketPolicy.Properties.PolicyDocument.Statement;
      const encryptionPolicy = statements.find((s: any) => s.Sid === 'DenyUnencryptedObjectUploads');
      
      expect(encryptionPolicy).toBeDefined();
      expect(encryptionPolicy.Action).toBe('s3:PutObject');
      expect(encryptionPolicy.Condition.StringNotEquals['s3:x-amz-server-side-encryption']).toBe('AES256');
    });
  });

  describe(`CloudTrailLogging-${generateUniqueId()}`, () => {
    test(`should have CloudTrail logs bucket - ${generateUniqueId()}`, () => {
      const cloudTrailBucket = template.Resources.CloudTrailLogsBucket;
      expect(cloudTrailBucket).toBeDefined();
      expect(cloudTrailBucket.Type).toBe('AWS::S3::Bucket');
      expect(cloudTrailBucket.Properties.BucketEncryption.ServerSideEncryptionConfiguration[0].ServerSideEncryptionByDefault.SSEAlgorithm).toBe('AES256');
    });

    test(`should have CloudTrail with global service events - ${generateUniqueId()}`, () => {
      const cloudTrail = template.Resources.SecurityCloudTrail;
      expect(cloudTrail).toBeDefined();
      expect(cloudTrail.Type).toBe('AWS::CloudTrail::Trail');
      expect(cloudTrail.Properties.IncludeGlobalServiceEvents).toBe(true);
      expect(cloudTrail.Properties.IsMultiRegionTrail).toBe(true);
    });

    test(`should have log file validation enabled - ${generateUniqueId()}`, () => {
      const cloudTrail = template.Resources.SecurityCloudTrail;
      expect(cloudTrail.Properties.EnableLogFileValidation).toBe(true);
      expect(cloudTrail.Properties.IsLogging).toBe(true);
    });

    test(`should log S3 data events - ${generateUniqueId()}`, () => {
      const cloudTrail = template.Resources.SecurityCloudTrail;
      const eventSelectors = cloudTrail.Properties.EventSelectors[0];
      expect(eventSelectors.ReadWriteType).toBe('All');
      expect(eventSelectors.IncludeManagementEvents).toBe(true);
      
      const s3ObjectResource = eventSelectors.DataResources.find((r: any) => r.Type === 'AWS::S3::Object');
      expect(s3ObjectResource).toBeDefined();
    });

    test(`should have proper bucket policy for CloudTrail - ${generateUniqueId()}`, () => {
      const bucketPolicy = template.Resources.CloudTrailBucketPolicy;
      expect(bucketPolicy).toBeDefined();
      expect(bucketPolicy.Type).toBe('AWS::S3::BucketPolicy');
      
      const statements = bucketPolicy.Properties.PolicyDocument.Statement;
      const aclCheck = statements.find((s: any) => s.Sid === 'AWSCloudTrailAclCheck');
      const writeAccess = statements.find((s: any) => s.Sid === 'AWSCloudTrailWrite');
      
      expect(aclCheck.Principal.Service).toBe('cloudtrail.amazonaws.com');
      expect(writeAccess.Principal.Service).toBe('cloudtrail.amazonaws.com');
    });
  });

  describe(`EC2Security-${generateUniqueId()}`, () => {
    test(`should have restrictive security group - ${generateUniqueId()}`, () => {
      const securityGroup = template.Resources.SecureSecurityGroup;
      expect(securityGroup).toBeDefined();
      expect(securityGroup.Type).toBe('AWS::EC2::SecurityGroup');
    });

    test(`should allow SSH only from private networks - ${generateUniqueId()}`, () => {
      const securityGroup = template.Resources.SecureSecurityGroup;
      const sshRule = securityGroup.Properties.SecurityGroupIngress.find((rule: any) => rule.FromPort === 22);
      
      expect(sshRule).toBeDefined();
      expect(sshRule.CidrIp).toBe('10.0.0.0/8');
      expect(sshRule.IpProtocol).toBe('tcp');
    });

    test(`should allow HTTPS access - ${generateUniqueId()}`, () => {
      const securityGroup = template.Resources.SecureSecurityGroup;
      const httpsRule = securityGroup.Properties.SecurityGroupIngress.find((rule: any) => rule.FromPort === 443);
      
      expect(httpsRule).toBeDefined();
      expect(httpsRule.CidrIp).toBe('0.0.0.0/0');
    });

    test(`should have controlled outbound access - ${generateUniqueId()}`, () => {
      const securityGroup = template.Resources.SecureSecurityGroup;
      const egressRules = securityGroup.Properties.SecurityGroupEgress;
      
      expect(egressRules).toHaveLength(2);
      const httpsEgress = egressRules.find((rule: any) => rule.FromPort === 443);
      const httpEgress = egressRules.find((rule: any) => rule.FromPort === 80);
      
      expect(httpsEgress).toBeDefined();
      expect(httpEgress).toBeDefined();
    });
  });

  describe(`Outputs-${generateUniqueId()}`, () => {
    test(`should export all required outputs - ${generateUniqueId()}`, () => {
      const requiredOutputs = [
        'SecureS3BucketName',
        'CloudTrailArn',
        'SecureUsersGroupName',
        'SecurityGroupId'
      ];

      requiredOutputs.forEach(outputName => {
        expect(template.Outputs[outputName]).toBeDefined();
        expect(template.Outputs[outputName].Export.Name).toBeDefined();
      });
    });

    test(`should have proper export naming convention - ${generateUniqueId()}`, () => {
      // Check that exports follow the naming convention
      expect(template.Outputs.SecureS3BucketName.Export.Name).toEqual({
        'Fn::Sub': '${AWS::StackName}-SecureS3Bucket'
      });
      expect(template.Outputs.CloudTrailArn.Export.Name).toEqual({
        'Fn::Sub': '${AWS::StackName}-CloudTrailArn'
      });
    });
  });

  describe(`SecurityCompliance-${generateUniqueId()}`, () => {
    test(`should not have any hardcoded secrets - ${generateUniqueId()}`, () => {
      const templateStr = JSON.stringify(template);
      
      // Check for potential hardcoded secrets patterns
      expect(templateStr).not.toMatch(/password[\s]*[:=][\s]*["'][^"']*["']/i);
      expect(templateStr).not.toMatch(/secret[\s]*[:=][\s]*["'][^"']*["']/i);
      expect(templateStr).not.toMatch(/key[\s]*[:=][\s]*["'][^"']*["']/i);
      expect(templateStr).not.toMatch(/token[\s]*[:=][\s]*["'][^"']*["']/i);
    });

    test(`should use parameter references for sensitive values - ${generateUniqueId()}`, () => {
      const sampleUser = template.Resources.SampleSecureUser;
      // Hardcoded temporary password should require reset
      expect(sampleUser.Properties.LoginProfile.PasswordResetRequired).toBe(true);
    });

    test(`should have proper resource dependencies - ${generateUniqueId()}`, () => {
      const cloudTrail = template.Resources.SecurityCloudTrail;
      expect(cloudTrail.DependsOn).toBe('CloudTrailBucketPolicy');
    });

    test(`should use environment name prefix consistently - ${generateUniqueId()}`, () => {
      const resources = template.Resources;
      
      Object.keys(resources).forEach(resourceKey => {
        const resource = resources[resourceKey];
        if (resource.Properties && resource.Properties.ManagedPolicyName) {
          expect(resource.Properties.ManagedPolicyName['Fn::Sub']).toContain('${EnvironmentName}');
        }
        if (resource.Properties && resource.Properties.GroupName && resource.Properties.GroupName['Fn::Sub']) {
          expect(resource.Properties.GroupName['Fn::Sub']).toContain('${EnvironmentName}');
        }
        if (resource.Properties && resource.Properties.UserName && resource.Properties.UserName['Fn::Sub']) {
          expect(resource.Properties.UserName['Fn::Sub']).toContain('${EnvironmentName}');
        }
      });
    });

    test(`should have proper IAM policy versions - ${generateUniqueId()}`, () => {
      const resources = template.Resources;
      
      Object.keys(resources).forEach(resourceKey => {
        const resource = resources[resourceKey];
        if (resource.Properties && resource.Properties.PolicyDocument) {
          expect(resource.Properties.PolicyDocument.Version).toBe('2012-10-17');
        }
      });
    });
  });

  describe(`ResourceCounting-${generateUniqueId()}`, () => {
    test(`should have expected number of IAM resources - ${generateUniqueId()}`, () => {
      const iamResources = Object.keys(template.Resources).filter(key => 
        template.Resources[key].Type.startsWith('AWS::IAM::')
      );
      expect(iamResources.length).toBeGreaterThanOrEqual(5);
    });

    test(`should have expected number of S3 resources - ${generateUniqueId()}`, () => {
      const s3Resources = Object.keys(template.Resources).filter(key => 
        template.Resources[key].Type.startsWith('AWS::S3::')
      );
      expect(s3Resources.length).toBeGreaterThanOrEqual(3);
    });

    test(`should have CloudTrail resource - ${generateUniqueId()}`, () => {
      const cloudTrailResources = Object.keys(template.Resources).filter(key => 
        template.Resources[key].Type === 'AWS::CloudTrail::Trail'
      );
      expect(cloudTrailResources.length).toBe(1);
    });

    test(`should have EC2 security group - ${generateUniqueId()}`, () => {
      const ec2Resources = Object.keys(template.Resources).filter(key => 
        template.Resources[key].Type === 'AWS::EC2::SecurityGroup'
      );
      expect(ec2Resources.length).toBe(1);
    });
  });

  describe(`ValidationChecks-${generateUniqueId()}`, () => {
    test(`should have valid JSON structure - ${generateUniqueId()}`, () => {
      expect(template).toBeDefined();
      expect(typeof template).toBe('object');
      expect(template).not.toBeNull();
    });

    test(`should not have circular references - ${generateUniqueId()}`, () => {
      expect(() => JSON.stringify(template)).not.toThrow();
    });

    test(`should have consistent naming patterns - ${generateUniqueId()}`, () => {
      const resourceKeys = Object.keys(template.Resources);
      resourceKeys.forEach(key => {
        // Resource names should be PascalCase
        expect(key).toMatch(/^[A-Z][a-zA-Z0-9]*$/);
      });
    });
  });
});