AWSTemplateFormatVersion: '2010-09-09'
Description: 'Serverless Transaction Processing Pipeline with API Gateway, Lambda, Step Functions, DynamoDB, and EventBridge'

Parameters:
  AllowedCORSDomain:
    Type: String
    Default: 'https://example.com'
    Description: 'Allowed domain for CORS configuration'
  
  Environment:
    Type: String
    Default: 'production'
    Description: 'Environment name'
    AllowedValues:
      - development
      - staging
      - production

Resources:
  # ========================================
  # KMS Key for Environment Variable Encryption
  # ========================================
  TransactionKMSKey:
    Type: AWS::KMS::Key
    Properties:
      Description: 'KMS key for encrypting Lambda environment variables'
      KeyPolicy:
        Version: '2012-10-17'
        Statement:
          - Sid: Enable IAM User Permissions
            Effect: Allow
            Principal:
              AWS: !Sub 'arn:aws:iam::${AWS::AccountId}:root'
            Action: 'kms:*'
            Resource: '*'
          - Sid: Allow Lambda Functions to use the key
            Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action:
              - 'kms:Decrypt'
              - 'kms:GenerateDataKey'
            Resource: '*'

  TransactionKMSKeyAlias:
    Type: AWS::KMS::Alias
    Properties:
      AliasName: alias/transaction-processing-key
      TargetKeyId: !Ref TransactionKMSKey

  # ========================================
  # DynamoDB Tables
  # ========================================
  TransactionsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub '${AWS::StackName}-Transactions'
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: transactionId
          AttributeType: S
        - AttributeName: timestamp
          AttributeType: N
      KeySchema:
        - AttributeName: transactionId
          KeyType: HASH
        - AttributeName: timestamp
          KeyType: RANGE
      SSESpecification:
        SSEEnabled: true
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      StreamSpecification:
        StreamViewType: NEW_AND_OLD_IMAGES
      Tags:
        - Key: Environment
          Value: !Ref Environment

  FraudPatternsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub '${AWS::StackName}-FraudPatterns'
      BillingMode: PROVISIONED
      ProvisionedThroughput:
        ReadCapacityUnits: 100
        WriteCapacityUnits: 100
      AttributeDefinitions:
        - AttributeName: patternId
          AttributeType: S
        - AttributeName: riskScore
          AttributeType: N
      KeySchema:
        - AttributeName: patternId
          KeyType: HASH
        - AttributeName: riskScore
          KeyType: RANGE
      SSESpecification:
        SSEEnabled: true
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      Tags:
        - Key: Environment
          Value: !Ref Environment

  # ========================================
  # SQS Dead Letter Queues
  # ========================================
  TransactionValidatorDLQ:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: !Sub '${AWS::StackName}-TransactionValidator-DLQ'
      MessageRetentionPeriod: 1209600  # 14 days
      KmsMasterKeyId: alias/aws/sqs

  FraudDetectorDLQ:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: !Sub '${AWS::StackName}-FraudDetector-DLQ'
      MessageRetentionPeriod: 1209600
      KmsMasterKeyId: alias/aws/sqs

  AuditLoggerDLQ:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: !Sub '${AWS::StackName}-AuditLogger-DLQ'
      MessageRetentionPeriod: 1209600
      KmsMasterKeyId: alias/aws/sqs

  # ========================================
  # IAM Roles for Lambda Functions
  # ========================================
  TransactionValidatorRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${AWS::StackName}-TransactionValidatorRole'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        - arn:aws:iam::aws:policy/AWSXRayDaemonWriteAccess
      Policies:
        - PolicyName: TransactionValidatorPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'dynamodb:GetItem'
                  - 'dynamodb:PutItem'
                  - 'dynamodb:Query'
                Resource:
                  - !GetAtt TransactionsTable.Arn
                  - !Sub '${TransactionsTable.Arn}/index/*'
              - Effect: Allow
                Action:
                  - 'sqs:SendMessage'
                  - 'sqs:GetQueueAttributes'
                Resource: !GetAtt TransactionValidatorDLQ.Arn
              - Effect: Allow
                Action:
                  - 'kms:Decrypt'
                Resource: !GetAtt TransactionKMSKey.Arn
              - Effect: Allow
                Action:
                  - 'logs:CreateLogGroup'
                  - 'logs:CreateLogStream'
                  - 'logs:PutLogEvents'
                Resource: !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:*'

  FraudDetectorRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${AWS::StackName}-FraudDetectorRole'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        - arn:aws:iam::aws:policy/AWSXRayDaemonWriteAccess
      Policies:
        - PolicyName: FraudDetectorPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'dynamodb:GetItem'
                  - 'dynamodb:Query'
                  - 'dynamodb:Scan'
                Resource:
                  - !GetAtt FraudPatternsTable.Arn
                  - !Sub '${FraudPatternsTable.Arn}/index/*'
              - Effect: Allow
                Action:
                  - 'dynamodb:GetItem'
                  - 'dynamodb:UpdateItem'
                Resource:
                  - !GetAtt TransactionsTable.Arn
              - Effect: Allow
                Action:
                  - 'sqs:SendMessage'
                  - 'sqs:GetQueueAttributes'
                Resource: !GetAtt FraudDetectorDLQ.Arn
              - Effect: Allow
                Action:
                  - 'kms:Decrypt'
                Resource: !GetAtt TransactionKMSKey.Arn
              - Effect: Allow
                Action:
                  - 'logs:CreateLogGroup'
                  - 'logs:CreateLogStream'
                  - 'logs:PutLogEvents'
                Resource: !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:*'

  AuditLoggerRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${AWS::StackName}-AuditLoggerRole'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        - arn:aws:iam::aws:policy/AWSXRayDaemonWriteAccess
      Policies:
        - PolicyName: AuditLoggerPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'dynamodb:GetItem'
                  - 'dynamodb:PutItem'
                Resource:
                  - !GetAtt TransactionsTable.Arn
              - Effect: Allow
                Action:
                  - 'sqs:SendMessage'
                  - 'sqs:GetQueueAttributes'
                Resource: !GetAtt AuditLoggerDLQ.Arn
              - Effect: Allow
                Action:
                  - 'kms:Decrypt'
                Resource: !GetAtt TransactionKMSKey.Arn
              - Effect: Allow
                Action:
                  - 'logs:CreateLogGroup'
                  - 'logs:CreateLogStream'
                  - 'logs:PutLogEvents'
                Resource: !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:*'

  # ========================================
  # Lambda Functions
  # ========================================
  TransactionValidatorLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${AWS::StackName}-TransactionValidator'
      Runtime: python3.11
      Architectures:
        - arm64
      Handler: index.handler
      Role: !GetAtt TransactionValidatorRole.Arn
      MemorySize: 256
      Timeout: 30
      ReservedConcurrentExecutions: 100
      TracingConfig:
        Mode: Active
      Environment:
        Variables:
          TRANSACTIONS_TABLE: !Ref TransactionsTable
          ENVIRONMENT: !Ref Environment
      KmsKeyArn: !GetAtt TransactionKMSKey.Arn
      DeadLetterConfig:
        TargetArn: !GetAtt TransactionValidatorDLQ.Arn
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          from aws_xray_sdk.core import xray_recorder
          from aws_xray_sdk.core import patch_all
          
          patch_all()
          
          dynamodb = boto3.resource('dynamodb')
          table = dynamodb.Table(os.environ['TRANSACTIONS_TABLE'])
          
          @xray_recorder.capture('validate_transaction')
          def handler(event, context):
              try:
                  # Transaction validation logic
                  transaction = json.loads(event.get('body', '{}')) if isinstance(event, dict) and 'body' in event else event
                  
                  # Validate required fields
                  required_fields = ['transactionId', 'amount', 'currency', 'timestamp']
                  for field in required_fields:
                      if field not in transaction:
                          raise ValueError(f"Missing required field: {field}")
                  
                  # Validate amount
                  if transaction['amount'] <= 0:
                      raise ValueError("Amount must be positive")
                  
                  # Store in DynamoDB
                  table.put_item(Item=transaction)
                  
                  return {
                      'statusCode': 200,
                      'body': json.dumps({
                          'status': 'validated',
                          'transactionId': transaction['transactionId']
                      })
                  }
              except Exception as e:
                  print(f"Error: {str(e)}")
                  return {
                      'statusCode': 400,
                      'body': json.dumps({'error': str(e)})
                  }

  FraudDetectorLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${AWS::StackName}-FraudDetector'
      Runtime: python3.11
      Architectures:
        - arm64
      Handler: index.handler
      Role: !GetAtt FraudDetectorRole.Arn
      MemorySize: 512
      Timeout: 30
      ReservedConcurrentExecutions: 50
      TracingConfig:
        Mode: Active
      Environment:
        Variables:
          FRAUD_PATTERNS_TABLE: !Ref FraudPatternsTable
          TRANSACTIONS_TABLE: !Ref TransactionsTable
          ENVIRONMENT: !Ref Environment
      KmsKeyArn: !GetAtt TransactionKMSKey.Arn
      DeadLetterConfig:
        TargetArn: !GetAtt FraudDetectorDLQ.Arn
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          from aws_xray_sdk.core import xray_recorder
          from aws_xray_sdk.core import patch_all
          
          patch_all()
          
          dynamodb = boto3.resource('dynamodb')
          fraud_table = dynamodb.Table(os.environ['FRAUD_PATTERNS_TABLE'])
          transactions_table = dynamodb.Table(os.environ['TRANSACTIONS_TABLE'])
          
          @xray_recorder.capture('detect_fraud')
          def handler(event, context):
              try:
                  transaction = event
                  
                  # Fraud detection logic
                  risk_score = 0
                  
                  # Check amount threshold
                  if transaction.get('amount', 0) > 10000:
                      risk_score += 30
                  
                  # Check velocity (simplified)
                  if transaction.get('amount', 0) > 5000:
                      risk_score += 20
                  
                  # Update transaction with fraud score
                  transactions_table.update_item(
                      Key={
                          'transactionId': transaction['transactionId'],
                          'timestamp': transaction['timestamp']
                      },
                      UpdateExpression='SET fraudRiskScore = :score, fraudChecked = :checked',
                      ExpressionAttributeValues={
                          ':score': risk_score,
                          ':checked': True
                      }
                  )
                  
                  return {
                      'statusCode': 200,
                      'body': json.dumps({
                          'status': 'fraud_check_complete',
                          'transactionId': transaction['transactionId'],
                          'riskScore': risk_score,
                          'suspicious': risk_score > 50
                      })
                  }
              except Exception as e:
                  print(f"Error: {str(e)}")
                  return {
                      'statusCode': 500,
                      'body': json.dumps({'error': str(e)})
                  }

  AuditLoggerLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${AWS::StackName}-AuditLogger'
      Runtime: python3.11
      Architectures:
        - arm64
      Handler: index.handler
      Role: !GetAtt AuditLoggerRole.Arn
      MemorySize: 128
      Timeout: 30
      ReservedConcurrentExecutions: 25
      TracingConfig:
        Mode: Active
      Environment:
        Variables:
          TRANSACTIONS_TABLE: !Ref TransactionsTable
          ENVIRONMENT: !Ref Environment
      KmsKeyArn: !GetAtt TransactionKMSKey.Arn
      DeadLetterConfig:
        TargetArn: !GetAtt AuditLoggerDLQ.Arn
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          from datetime import datetime
          from aws_xray_sdk.core import xray_recorder
          from aws_xray_sdk.core import patch_all
          
          patch_all()
          
          dynamodb = boto3.resource('dynamodb')
          table = dynamodb.Table(os.environ['TRANSACTIONS_TABLE'])
          
          @xray_recorder.capture('audit_log')
          def handler(event, context):
              try:
                  # Parse event from EventBridge or direct invocation
                  if 'detail' in event:
                      transaction = event['detail']
                  else:
                      transaction = event
                  
                  # Create audit log entry
                  audit_entry = {
                      'transactionId': transaction.get('transactionId', 'unknown'),
                      'auditTimestamp': datetime.utcnow().isoformat(),
                      'eventType': 'transaction_processed',
                      'details': json.dumps(transaction)
                  }
                  
                  # Update transaction with audit info
                  table.update_item(
                      Key={
                          'transactionId': transaction['transactionId'],
                          'timestamp': transaction['timestamp']
                      },
                      UpdateExpression='SET auditLog = :audit, lastUpdated = :time',
                      ExpressionAttributeValues={
                          ':audit': audit_entry,
                          ':time': datetime.utcnow().isoformat()
                      }
                  )
                  
                  return {
                      'statusCode': 200,
                      'body': json.dumps({
                          'status': 'audit_logged',
                          'transactionId': transaction.get('transactionId')
                      })
                  }
              except Exception as e:
                  print(f"Error: {str(e)}")
                  return {
                      'statusCode': 500,
                      'body': json.dumps({'error': str(e)})
                  }

  # ========================================
  # Health Check Lambda
  # ========================================
  HealthCheckLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${AWS::StackName}-HealthCheckRole'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: HealthCheckPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'dynamodb:DescribeTable'
                Resource:
                  - !GetAtt TransactionsTable.Arn
                  - !GetAtt FraudPatternsTable.Arn
              - Effect: Allow
                Action:
                  - 'states:DescribeStateMachine'
                Resource: !Ref TransactionProcessingStateMachine
              - Effect: Allow
                Action:
                  - 'logs:CreateLogGroup'
                  - 'logs:CreateLogStream'
                  - 'logs:PutLogEvents'
                Resource: !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:*'

  HealthCheckLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${AWS::StackName}-HealthCheck'
      Runtime: python3.11
      Architectures:
        - arm64
      Handler: index.handler
      Role: !GetAtt HealthCheckLambdaRole.Arn
      MemorySize: 128
      Timeout: 10
      Environment:
        Variables:
          TRANSACTIONS_TABLE: !Ref TransactionsTable
          FRAUD_PATTERNS_TABLE: !Ref FraudPatternsTable
          STATE_MACHINE_ARN: !Ref TransactionProcessingStateMachine
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          
          dynamodb = boto3.client('dynamodb')
          sfn = boto3.client('stepfunctions')
          
          def test_dynamodb_tables():
              """Test DynamoDB tables connectivity and status"""
              try:
                  transactions_table = os.environ['TRANSACTIONS_TABLE']
                  fraud_table = os.environ['FRAUD_PATTERNS_TABLE']
                  
                  # Check Transactions Table
                  trans_response = dynamodb.describe_table(TableName=transactions_table)
                  trans_status = trans_response['Table']['TableStatus']
                  
                  # Check Fraud Patterns Table
                  fraud_response = dynamodb.describe_table(TableName=fraud_table)
                  fraud_status = fraud_response['Table']['TableStatus']
                  
                  if trans_status == 'ACTIVE' and fraud_status == 'ACTIVE':
                      return {
                          'status': 'success',
                          'transactions_table': trans_status,
                          'fraud_patterns_table': fraud_status
                      }
                  else:
                      return {
                          'status': 'degraded',
                          'transactions_table': trans_status,
                          'fraud_patterns_table': fraud_status
                      }
              except Exception as e:
                  return {
                      'status': 'failed',
                      'error': str(e)
                  }
          
          def test_step_functions():
              """Test Step Functions State Machine status"""
              try:
                  state_machine_arn = os.environ['STATE_MACHINE_ARN']
                  response = sfn.describe_state_machine(stateMachineArn=state_machine_arn)
                  
                  status = response['status']
                  return {
                      'status': 'success' if status == 'ACTIVE' else 'failed',
                      'state_machine_status': status
                  }
              except Exception as e:
                  return {
                      'status': 'failed',
                      'error': str(e)
                  }
          
          def handler(event, context):
              """Health check handler"""
              try:
                  # Test DynamoDB
                  dynamodb_health = test_dynamodb_tables()
                  
                  # Test Step Functions
                  sfn_health = test_step_functions()
                  
                  # Determine overall health
                  all_healthy = (
                      dynamodb_health['status'] == 'success' and 
                      sfn_health['status'] == 'success'
                  )
                  
                  response_code = 200 if all_healthy else 503
                  
                  response_body = {
                      'status': 'healthy' if all_healthy else 'unhealthy',
                      'timestamp': context.request_time_epoch if hasattr(context, 'request_time_epoch') else None,
                      'services': {
                          'dynamodb': dynamodb_health,
                          'step_functions': sfn_health
                      },
                      'environment': os.environ.get('AWS_REGION', 'unknown')
                  }
                  
                  return {
                      'statusCode': response_code,
                      'headers': {
                          'Content-Type': 'application/json',
                          'Access-Control-Allow-Origin': '*'
                      },
                      'body': json.dumps(response_body)
                  }
              except Exception as e:
                  return {
                      'statusCode': 500,
                      'headers': {
                          'Content-Type': 'application/json',
                          'Access-Control-Allow-Origin': '*'
                      },
                      'body': json.dumps({
                          'status': 'error',
                          'message': str(e)
                      })
                  }

  HealthCheckLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/aws/lambda/${HealthCheckLambda}'
      RetentionInDays: 7

  # ========================================
  # CloudWatch Log Groups
  # ========================================
  TransactionValidatorLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/aws/lambda/${TransactionValidatorLambda}'
      RetentionInDays: 7

  FraudDetectorLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/aws/lambda/${FraudDetectorLambda}'
      RetentionInDays: 7

  AuditLoggerLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/aws/lambda/${AuditLoggerLambda}'
      RetentionInDays: 7

  # ========================================
  # Step Functions State Machine
  # ========================================
  StateMachineRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${AWS::StackName}-StateMachineRole'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: states.amazonaws.com
            Action: 'sts:AssumeRole'
      Policies:
        - PolicyName: StateMachinePolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'lambda:InvokeFunction'
                Resource:
                  - !GetAtt TransactionValidatorLambda.Arn
                  - !GetAtt FraudDetectorLambda.Arn
                  - !GetAtt AuditLoggerLambda.Arn
              - Effect: Allow
                Action:
                  - 'xray:PutTraceSegments'
                  - 'xray:PutTelemetryRecords'
                Resource: '*'
              - Effect: Allow
                Action:
                  - 'logs:CreateLogDelivery'
                  - 'logs:GetLogDelivery'
                  - 'logs:UpdateLogDelivery'
                  - 'logs:DeleteLogDelivery'
                  - 'logs:ListLogDeliveries'
                  - 'logs:PutResourcePolicy'
                  - 'logs:DescribeResourcePolicies'
                  - 'logs:DescribeLogGroups'
                Resource: '*'

  TransactionProcessingStateMachine:
    Type: AWS::StepFunctions::StateMachine
    Properties:
      StateMachineName: !Sub '${AWS::StackName}-TransactionProcessing'
      RoleArn: !GetAtt StateMachineRole.Arn
      TracingConfiguration:
        Enabled: true
      LoggingConfiguration:
        Level: ALL
        IncludeExecutionData: true
        Destinations:
          - CloudWatchLogsLogGroup:
              LogGroupArn: !GetAtt StateMachineLogGroup.Arn
      DefinitionString: !Sub |
        {
          "Comment": "Transaction Processing Pipeline",
          "StartAt": "ValidateTransaction",
          "States": {
            "ValidateTransaction": {
              "Type": "Task",
              "Resource": "arn:aws:states:::lambda:invoke",
              "Parameters": {
                "FunctionName": "${TransactionValidatorLambda.Arn}",
                "Payload.$": "$"
              },
              "ResultPath": "$.validationResult",
              "ResultSelector": {
                "statusCode.$": "$.Payload.statusCode",
                "body.$": "$.Payload.body"
              },
              "Retry": [
                {
                  "ErrorEquals": ["Lambda.ServiceException", "Lambda.AWSLambdaException"],
                  "IntervalSeconds": 2,
                  "MaxAttempts": 3,
                  "BackoffRate": 2
                }
              ],
              "Catch": [
                {
                  "ErrorEquals": ["States.ALL"],
                  "Next": "HandleError"
                }
              ],
              "Next": "CheckValidation"
            },
            "CheckValidation": {
              "Type": "Choice",
              "Choices": [
                {
                  "Variable": "$.validationResult.statusCode",
                  "NumericEquals": 200,
                  "Next": "ParallelProcessing"
                }
              ],
              "Default": "ValidationFailed"
            },
            "ParallelProcessing": {
              "Type": "Parallel",
              "Branches": [
                {
                  "StartAt": "FraudDetection",
                  "States": {
                    "FraudDetection": {
                      "Type": "Task",
                      "Resource": "arn:aws:states:::lambda:invoke",
                      "Parameters": {
                        "FunctionName": "${FraudDetectorLambda.Arn}",
                        "Payload.$": "$"
                      },
                      "ResultPath": "$.fraudResult",
                      "Retry": [
                        {
                          "ErrorEquals": ["Lambda.ServiceException", "Lambda.AWSLambdaException"],
                          "IntervalSeconds": 2,
                          "MaxAttempts": 3,
                          "BackoffRate": 2
                        }
                      ],
                      "End": true
                    }
                  }
                },
                {
                  "StartAt": "AuditLogging",
                  "States": {
                    "AuditLogging": {
                      "Type": "Task",
                      "Resource": "arn:aws:states:::lambda:invoke",
                      "Parameters": {
                        "FunctionName": "${AuditLoggerLambda.Arn}",
                        "Payload.$": "$"
                      },
                      "ResultPath": "$.auditResult",
                      "Retry": [
                        {
                          "ErrorEquals": ["Lambda.ServiceException", "Lambda.AWSLambdaException"],
                          "IntervalSeconds": 2,
                          "MaxAttempts": 3,
                          "BackoffRate": 2
                        }
                      ],
                      "End": true
                    }
                  }
                }
              ],
              "Next": "ProcessingComplete"
            },
            "ProcessingComplete": {
              "Type": "Succeed"
            },
            "ValidationFailed": {
              "Type": "Fail",
              "Cause": "Transaction validation failed"
            },
            "HandleError": {
              "Type": "Fail",
              "Cause": "Error in transaction processing"
            }
          }
        }

  StateMachineLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/aws/stepfunctions/${AWS::StackName}-TransactionProcessing'
      RetentionInDays: 7

  # ========================================
  # API Gateway REST API
  # ========================================
  TransactionAPI:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: !Sub '${AWS::StackName}-TransactionAPI'
      Description: 'Transaction Processing REST API'
      EndpointConfiguration:
        Types:
          - REGIONAL
      Policy:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal: '*'
            Action: 'execute-api:Invoke'
            Resource: '*'

  APIGatewayAccount:
    Type: AWS::ApiGateway::Account
    Properties:
      CloudWatchRoleArn: !GetAtt APIGatewayCloudWatchRole.Arn

  APIGatewayCloudWatchRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - apigateway.amazonaws.com
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AmazonAPIGatewayPushToCloudWatchLogs

  APILogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/aws/api-gateway/${TransactionAPI}'
      RetentionInDays: 30

  TransactionRequestValidator:
    Type: AWS::ApiGateway::RequestValidator
    Properties:
      RestApiId: !Ref TransactionAPI
      ValidateRequestBody: true
      ValidateRequestParameters: true

  TransactionModel:
    Type: AWS::ApiGateway::Model
    Properties:
      RestApiId: !Ref TransactionAPI
      ContentType: 'application/json'
      Name: 'TransactionModel'
      Schema:
        $schema: 'http://json-schema.org/draft-04/schema#'
        type: object
        required:
          - transactionId
          - amount
          - currency
          - timestamp
        properties:
          transactionId:
            type: string
          amount:
            type: number
            minimum: 0
          currency:
            type: string
          timestamp:
            type: number

  TransactionResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref TransactionAPI
      ParentId: !GetAtt TransactionAPI.RootResourceId
      PathPart: 'transactions'

  TransactionMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref TransactionAPI
      ResourceId: !Ref TransactionResource
      HttpMethod: POST
      AuthorizationType: AWS_IAM
      RequestValidatorId: !Ref TransactionRequestValidator
      RequestModels:
        'application/json': !Ref TransactionModel
      Integration:
        Type: AWS
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:states:action/StartExecution'
        Credentials: !GetAtt APIGatewayStepFunctionsRole.Arn
        RequestTemplates:
          'application/json': !Sub |
            {
              "input": "$util.escapeJavaScript($input.body)",
              "stateMachineArn": "${TransactionProcessingStateMachine}"
            }
        IntegrationResponses:
          - StatusCode: 200
            ResponseTemplates:
              'application/json': |
                {
                  "executionId": "$input.json('$.executionArn').split(':').get(7)",
                  "status": "processing"
                }
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: !Sub "'${AllowedCORSDomain}'"
      MethodResponses:
        - StatusCode: 200
          ResponseModels:
            'application/json': 'Empty'
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true

  TransactionOptionsMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref TransactionAPI
      ResourceId: !Ref TransactionResource
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        RequestTemplates:
          'application/json': '{"statusCode": 200}'
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: !Sub "'${AllowedCORSDomain}'"
            ResponseTemplates:
              'application/json': ''
      MethodResponses:
        - StatusCode: 200
          ResponseModels:
            'application/json': 'Empty'
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Origin: true

  # Health Check Endpoint
  HealthResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref TransactionAPI
      ParentId: !GetAtt TransactionAPI.RootResourceId
      PathPart: 'health'

  HealthMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref TransactionAPI
      ResourceId: !Ref HealthResource
      HttpMethod: GET
      AuthorizationType: NONE
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${HealthCheckLambda.Arn}/invocations'
        IntegrationResponses:
          - StatusCode: 200
      MethodResponses:
        - StatusCode: 200
          ResponseModels:
            'application/json': 'Empty'

  HealthMethodPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref HealthCheckLambda
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${TransactionAPI}/*/*/health'

  APIGatewayStepFunctionsRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - apigateway.amazonaws.com
            Action: 'sts:AssumeRole'
      Policies:
        - PolicyName: StepFunctionsExecutionPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'states:StartExecution'
                Resource: !Ref TransactionProcessingStateMachine

  APIDeployment:
    Type: AWS::ApiGateway::Deployment
    DependsOn:
      - TransactionMethod
      - TransactionOptionsMethod
      - HealthMethod
    Properties:
      RestApiId: !Ref TransactionAPI
      StageName: !Ref Environment
      StageDescription:
        TracingEnabled: true
        LoggingLevel: INFO
        DataTraceEnabled: true
        MetricsEnabled: true
        AccessLogSetting:
          DestinationArn: !GetAtt APILogGroup.Arn
          Format: '$context.requestId - $context.error.message $context.error.messageString'
        ThrottlingBurstLimit: 10000
        ThrottlingRateLimit: 10000

  # ========================================
  # EventBridge Rule
  # ========================================
  TransactionCompleteEventRule:
    Type: AWS::Events::Rule
    Properties:
      Name: !Sub '${AWS::StackName}-TransactionCompleteRule'
      Description: 'Trigger audit logging when transaction completes'
      EventPattern:
        source:
          - aws.states
        detail-type:
          - Step Functions Execution Status Change
        detail:
          status:
            - SUCCEEDED
          stateMachineArn:
            - !Ref TransactionProcessingStateMachine
      State: ENABLED
      Targets:
        - Arn: !GetAtt AuditLoggerLambda.Arn
          Id: AuditLoggerTarget
          RetryPolicy:
            MaximumRetryAttempts: 2

  PermissionForEventsToInvokeLambda:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref AuditLoggerLambda
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt TransactionCompleteEventRule.Arn

Outputs:
  APIEndpoint:
    Description: 'API Gateway endpoint URL'
    Value: !Sub 'https://${TransactionAPI}.execute-api.${AWS::Region}.amazonaws.com/${Environment}'
    Export:
      Name: !Sub '${AWS::StackName}-APIEndpoint'

  StateMachineArn:
    Description: 'Step Functions State Machine ARN'
    Value: !Ref TransactionProcessingStateMachine
    Export:
      Name: !Sub '${AWS::StackName}-StateMachineArn'

  TransactionsTableName:
    Description: 'DynamoDB Transactions table name'
    Value: !Ref TransactionsTable
    Export:
      Name: !Sub '${AWS::StackName}-TransactionsTable'

  FraudPatternsTableName:
    Description: 'DynamoDB Fraud Patterns table name'
    Value: !Ref FraudPatternsTable
    Export:
      Name: !Sub '${AWS::StackName}-FraudPatternsTable'