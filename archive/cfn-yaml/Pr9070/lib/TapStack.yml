AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: 'Highly Resilient Serverless Application - API Gateway, Lambda, DynamoDB with X-Ray tracing'

Globals:
  Function:
    Timeout: 30
    MemorySize: 256
    Runtime: python3.11
    Tracing: Active
    Environment:
      Variables:
        POWERTOOLS_SERVICE_NAME: serverless-app
        POWERTOOLS_LOG_LEVEL: INFO

Parameters:
  EnvironmentSuffix:
    Type: String
    Default: 'dev'
    Description: 'Environment suffix for resource naming (e.g., dev, staging, prod)'
    AllowedPattern: '^[a-zA-Z0-9]+$'
    ConstraintDescription: 'Must contain only alphanumeric characters'
  
  ProjectName:
    Type: String
    Default: 'serverless-app'
    Description: 'Project name for resource naming'
    AllowedPattern: '^[a-zA-Z0-9-]+$'
    ConstraintDescription: 'Must contain only alphanumeric characters and hyphens'

Resources:
  # DynamoDB Table with on-demand billing
  DataTable:
    Type: AWS::DynamoDB::Table
    DeletionPolicy: Delete
    UpdateReplacePolicy: Delete
    Properties:
      TableName: !Sub '${ProjectName}-${EnvironmentSuffix}-data-table'
      AttributeDefinitions:
        - AttributeName: 'id'
          AttributeType: 'S'
        - AttributeName: 'timestamp'
          AttributeType: 'N'
      KeySchema:
        - AttributeName: 'id'
          KeyType: 'HASH'
        - AttributeName: 'timestamp'
          KeyType: 'RANGE'
      BillingMode: PAY_PER_REQUEST
      DeletionProtectionEnabled: false
      StreamSpecification:
        StreamViewType: NEW_AND_OLD_IMAGES
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      Tags:
        - Key: Environment
          Value: !Ref EnvironmentSuffix
        - Key: Project
          Value: !Ref ProjectName

  # S3 Bucket for API Gateway Access Logs
  ApiGatewayLogsBucket:
    Type: AWS::S3::Bucket
    DeletionPolicy: Delete
    Properties:
      BucketName: !Sub '${ProjectName}-${EnvironmentSuffix}-api-logs-${AWS::AccountId}-${AWS::Region}'
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      LifecycleConfiguration:
        Rules:
          - Id: DeleteOldLogs
            Status: Enabled
            ExpirationInDays: 90
      Tags:
        - Key: Environment
          Value: !Ref EnvironmentSuffix
        - Key: Project
          Value: !Ref ProjectName

  # S3 Bucket Policy for API Gateway Access Logs
  ApiGatewayLogsBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref ApiGatewayLogsBucket
      PolicyDocument:
        Statement:
          - Sid: AllowApiGatewayLogs
            Effect: Allow
            Principal:
              Service: apigateway.amazonaws.com
            Action:
              - s3:PutObject
            Resource: !Sub '${ApiGatewayLogsBucket.Arn}/*'
            Condition:
              StringEquals:
                aws:SourceAccount: !Ref AWS::AccountId

  # IAM Role for Lambda Function
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${ProjectName}-${EnvironmentSuffix}-lambda-execution-role'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        - arn:aws:iam::aws:policy/AWSXRayDaemonWriteAccess
      Policies:
        - PolicyName: DynamoDBAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:PutItem
                  - dynamodb:UpdateItem
                  - dynamodb:DeleteItem
                  - dynamodb:Query
                  - dynamodb:Scan
                Resource: !GetAtt DataTable.Arn
        - PolicyName: SQSAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - sqs:SendMessage
                  - sqs:GetQueueAttributes
                Resource: !GetAtt DeadLetterQueue.Arn
      Tags:
        - Key: Environment
          Value: !Ref EnvironmentSuffix
        - Key: Project
          Value: !Ref ProjectName

  # Lambda Function
  ServerlessFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !Sub '${ProjectName}-${EnvironmentSuffix}-serverless-function'
      InlineCode: |
        import json
        import os
        import boto3
        from datetime import datetime

        dynamodb = boto3.resource('dynamodb')
        table_name = os.environ['TABLE_NAME']
        table = dynamodb.Table(table_name)

        def lambda_handler(event, context):
            """
            Main Lambda handler for API Gateway requests
            Supports GET, POST, PUT, DELETE operations on DynamoDB
            """
            try:
                http_method = event.get('httpMethod', '')
                path_parameters = event.get('pathParameters', {})
                body = event.get('body', '{}')

                if http_method == 'GET':
                    # GET /data - scan all items
                    response = table.scan()
                    return {
                        'statusCode': 200,
                        'headers': {'Content-Type': 'application/json'},
                        'body': json.dumps({
                            'items': response.get('Items', []),
                            'count': response.get('Count', 0)
                        })
                    }

                elif http_method == 'POST':
                    # POST /data - create new item
                    data = json.loads(body)
                    item_id = data.get('id', str(datetime.now().timestamp()))
                    timestamp = int(datetime.now().timestamp())

                    item = {
                        'id': item_id,
                        'timestamp': timestamp,
                        'data': data.get('data', {}),
                        'created_at': datetime.now().isoformat()
                    }

                    table.put_item(Item=item)
                    return {
                        'statusCode': 201,
                        'headers': {'Content-Type': 'application/json'},
                        'body': json.dumps({
                            'message': 'Item created successfully',
                            'item': item
                        })
                    }

                elif http_method == 'PUT':
                    # PUT /data/{id} - update existing item
                    item_id = path_parameters.get('id')
                    data = json.loads(body)
                    timestamp = data.get('timestamp', int(datetime.now().timestamp()))

                    response = table.update_item(
                        Key={'id': item_id, 'timestamp': timestamp},
                        UpdateExpression='SET #data = :data, updated_at = :updated_at',
                        ExpressionAttributeNames={'#data': 'data'},
                        ExpressionAttributeValues={
                            ':data': data.get('data', {}),
                            ':updated_at': datetime.now().isoformat()
                        },
                        ReturnValues='ALL_NEW'
                    )

                    return {
                        'statusCode': 200,
                        'headers': {'Content-Type': 'application/json'},
                        'body': json.dumps({
                            'message': 'Item updated successfully',
                            'item': response.get('Attributes', {})
                        })
                    }

                elif http_method == 'DELETE':
                    # DELETE /data/{id} - delete item
                    item_id = path_parameters.get('id')
                    data = json.loads(body) if body else {}
                    timestamp = data.get('timestamp', int(datetime.now().timestamp()))

                    table.delete_item(
                        Key={'id': item_id, 'timestamp': timestamp}
                    )

                    return {
                        'statusCode': 200,
                        'headers': {'Content-Type': 'application/json'},
                        'body': json.dumps({
                            'message': 'Item deleted successfully'
                        })
                    }

                else:
                    return {
                        'statusCode': 405,
                        'headers': {'Content-Type': 'application/json'},
                        'body': json.dumps({
                            'error': 'Method not allowed'
                        })
                    }

            except Exception as e:
                return {
                    'statusCode': 500,
                    'headers': {'Content-Type': 'application/json'},
                    'body': json.dumps({
                        'error': str(e)
                    })
                }
      Handler: index.lambda_handler
      Runtime: python3.11
      Role: !GetAtt LambdaExecutionRole.Arn
      Environment:
        Variables:
          TABLE_NAME: !Ref DataTable
          ENVIRONMENT: !Ref EnvironmentSuffix
          PROJECT_NAME: !Ref ProjectName
          LOG_LEVEL: INFO
      Events:
        ApiGatewayGetEvent:
          Type: Api
          Properties:
            RestApiId: !Ref ServerlessApi
            Path: /data
            Method: GET
        ApiGatewayPostEvent:
          Type: Api
          Properties:
            RestApiId: !Ref ServerlessApi
            Path: /data
            Method: POST
        ApiGatewayPutEvent:
          Type: Api
          Properties:
            RestApiId: !Ref ServerlessApi
            Path: /data/{id}
            Method: PUT
        ApiGatewayDeleteEvent:
          Type: Api
          Properties:
            RestApiId: !Ref ServerlessApi
            Path: /data/{id}
            Method: DELETE
      ReservedConcurrentExecutions: 100
      DeadLetterQueue:
        Type: SQS
        TargetArn: !GetAtt DeadLetterQueue.Arn
      Tags:
        Environment: !Ref EnvironmentSuffix
        Project: !Ref ProjectName

  # Lambda Version
  ServerlessFunctionVersion:
    Type: AWS::Lambda::Version
    Properties:
      FunctionName: !Ref ServerlessFunction
      Description: !Sub 'Version for ${EnvironmentSuffix} environment'

  # Lambda Alias
  ServerlessFunctionAlias:
    Type: AWS::Lambda::Alias
    Properties:
      FunctionName: !Ref ServerlessFunction
      FunctionVersion: !GetAtt ServerlessFunctionVersion.Version
      Name: !Sub '${EnvironmentSuffix}-alias'
      Description: !Sub 'Alias for ${EnvironmentSuffix} environment'

  # Dead Letter Queue for Lambda
  DeadLetterQueue:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: !Sub '${ProjectName}-${EnvironmentSuffix}-dlq'
      MessageRetentionPeriod: 1209600  # 14 days
      Tags:
        - Key: Environment
          Value: !Ref EnvironmentSuffix
        - Key: Project
          Value: !Ref ProjectName

  # API Gateway REST API
  ServerlessApi:
    Type: AWS::Serverless::Api
    Properties:
      Name: !Sub '${ProjectName}-${EnvironmentSuffix}-api'
      StageName: !Ref EnvironmentSuffix
      TracingEnabled: true
      Cors:
        AllowMethods: "'GET,POST,PUT,DELETE,OPTIONS'"
        AllowHeaders: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
        AllowOrigin: "'*'"
        MaxAge: "'600'"
      Variables:
        Environment: !Ref EnvironmentSuffix
        ProjectName: !Ref ProjectName
        TableName: !Ref DataTable
      AccessLogSetting:
        DestinationArn: !GetAtt ApiGatewayLogGroup.Arn
        Format: '{"requestId":"$context.requestId","ip":"$context.identity.sourceIp","caller":"$context.identity.caller","user":"$context.identity.user","requestTime":"$context.requestTime","httpMethod":"$context.httpMethod","resourcePath":"$context.resourcePath","status":"$context.status","protocol":"$context.protocol","responseLength":"$context.responseLength"}'
      MethodSettings:
        - ResourcePath: "/*"
          HttpMethod: "*"
          LoggingLevel: INFO
          DataTraceEnabled: true
          MetricsEnabled: true
      Tags:
        Environment: !Ref EnvironmentSuffix
        Project: !Ref ProjectName

  # CloudWatch Log Group for Lambda
  LambdaLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/aws/lambda/${ProjectName}-${EnvironmentSuffix}-serverless-function'
      RetentionInDays: 14
      Tags:
        - Key: Environment
          Value: !Ref EnvironmentSuffix
        - Key: Project
          Value: !Ref ProjectName

  # CloudWatch Log Group for API Gateway
  ApiGatewayLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub 'API-Gateway-Execution-Logs_${ServerlessApi}/${EnvironmentSuffix}'
      RetentionInDays: 14
      Tags:
        - Key: Environment
          Value: !Ref EnvironmentSuffix
        - Key: Project
          Value: !Ref ProjectName

  # CloudWatch Alarms
  LambdaErrorAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !Sub '${ProjectName}-${EnvironmentSuffix}-lambda-errors'
      AlarmDescription: 'Lambda function error rate alarm'
      MetricName: Errors
      Namespace: AWS/Lambda
      Statistic: Sum
      Period: 300
      EvaluationPeriods: 2
      Threshold: 5
      ComparisonOperator: GreaterThanOrEqualToThreshold
      Dimensions:
        - Name: FunctionName
          Value: !Ref ServerlessFunction
      TreatMissingData: notBreaching

  LambdaDurationAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !Sub '${ProjectName}-${EnvironmentSuffix}-lambda-duration'
      AlarmDescription: 'Lambda function duration alarm'
      MetricName: Duration
      Namespace: AWS/Lambda
      Statistic: Average
      Period: 300
      EvaluationPeriods: 2
      Threshold: 25000  # 25 seconds
      ComparisonOperator: GreaterThanThreshold
      Dimensions:
        - Name: FunctionName
          Value: !Ref ServerlessFunction
      TreatMissingData: notBreaching

  # IAM Role for API Gateway CloudWatch Logging
  ApiGatewayCloudWatchRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${ProjectName}-${EnvironmentSuffix}-apigateway-cloudwatch-role'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: apigateway.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AmazonAPIGatewayPushToCloudWatchLogs
      Tags:
        - Key: Environment
          Value: !Ref EnvironmentSuffix
        - Key: Project
          Value: !Ref ProjectName

Outputs:
  ApiGatewayUrl:
    Description: 'URL of the API Gateway'
    Value: !Sub 'https://${ServerlessApi}.execute-api.${AWS::Region}.amazonaws.com/${EnvironmentSuffix}'
    Export:
      Name: !Sub '${AWS::StackName}-ApiGatewayUrl'

  LambdaFunctionName:
    Description: 'Name of the Lambda function'
    Value: !Ref ServerlessFunction
    Export:
      Name: !Sub '${AWS::StackName}-LambdaFunctionName'

  LambdaFunctionArn:
    Description: 'ARN of the Lambda function'
    Value: !GetAtt ServerlessFunction.Arn
    Export:
      Name: !Sub '${AWS::StackName}-LambdaFunctionArn'

  DynamoDBTableName:
    Description: 'Name of the DynamoDB table'
    Value: !Ref DataTable
    Export:
      Name: !Sub '${AWS::StackName}-DynamoDBTableName'

  DynamoDBTableArn:
    Description: 'ARN of the DynamoDB table'
    Value: !GetAtt DataTable.Arn
    Export:
      Name: !Sub '${AWS::StackName}-DynamoDBTableArn'

  S3BucketName:
    Description: 'Name of the S3 bucket for API Gateway logs'
    Value: !Ref ApiGatewayLogsBucket
    Export:
      Name: !Sub '${AWS::StackName}-S3BucketName'

  LambdaAliasArn:
    Description: 'ARN of the Lambda alias'
    Value: !Ref ServerlessFunctionAlias
    Export:
      Name: !Sub '${AWS::StackName}-LambdaAliasArn'

  LambdaVersionArn:
    Description: 'ARN of the Lambda version'
    Value: !Ref ServerlessFunctionVersion
    Export:
      Name: !Sub '${AWS::StackName}-LambdaVersionArn'

  DeadLetterQueueUrl:
    Description: 'URL of the Dead Letter Queue'
    Value: !Ref DeadLetterQueue
    Export:
      Name: !Sub '${AWS::StackName}-DeadLetterQueueUrl'

  DeadLetterQueueArn:
    Description: 'ARN of the Dead Letter Queue'
    Value: !GetAtt DeadLetterQueue.Arn
    Export:
      Name: !Sub '${AWS::StackName}-DeadLetterQueueArn'

  StackName:
    Description: 'Name of this CloudFormation stack'
    Value: !Ref AWS::StackName
    Export:
      Name: !Sub '${AWS::StackName}-StackName'

  EnvironmentSuffix:
    Description: 'Environment suffix used for this deployment'
    Value: !Ref EnvironmentSuffix
    Export:
      Name: !Sub '${AWS::StackName}-EnvironmentSuffix'
