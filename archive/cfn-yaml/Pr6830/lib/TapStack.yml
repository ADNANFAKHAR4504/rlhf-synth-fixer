AWSTemplateFormatVersion: '2010-09-09'
Description: 'Serverless Transaction Validation System - CloudFormation Template'

Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: 'Environment Configuration'
        Parameters:
          - EnvironmentSuffix
          - Environment

Parameters:
  EnvironmentSuffix:
    Type: String
    Default: 'dev'
    Description: 'Environment suffix for resource naming (e.g., dev, staging, prod)'
    AllowedPattern: '^[a-zA-Z0-9]+$'
    ConstraintDescription: 'Must contain only alphanumeric characters'

  Environment:
    Type: String
    Default: 'development'
    AllowedValues:
      - 'development'
      - 'staging'
      - 'production'
    Description: 'Environment type for conditional resource creation'

Conditions:
  IsProduction: !Equals [!Ref Environment, 'production']

Resources:
  # KMS Key for Lambda environment variable encryption
  LambdaKMSKey:
    Type: AWS::KMS::Key
    DeletionPolicy: Delete
    UpdateReplacePolicy: Delete
    Properties:
      Description: 'Customer-managed KMS key for Lambda environment variable encryption'
      EnableKeyRotation: true
      KeyPolicy:
        Version: '2012-10-17'
        Statement:
          - Sid: 'Enable IAM User Permissions'
            Effect: Allow
            Principal:
              AWS: !Sub 'arn:aws:iam::${AWS::AccountId}:root'
            Action: 'kms:*'
            Resource: '*'
          - Sid: 'Allow Lambda to use the key'
            Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action:
              - 'kms:Decrypt'
              - 'kms:DescribeKey'
            Resource: '*'

  LambdaKMSKeyAlias:
    Type: AWS::KMS::Alias
    Properties:
      AliasName: !Sub 'alias/transaction-processor-${EnvironmentSuffix}'
      TargetKeyId: !Ref LambdaKMSKey

  # DynamoDB Table for transaction records
  TransactionRecordsTable:
    Type: AWS::DynamoDB::Table
    DeletionPolicy: Delete
    UpdateReplacePolicy: Delete
    Properties:
      TableName: !Sub 'TransactionRecords-${EnvironmentSuffix}'
      AttributeDefinitions:
        - AttributeName: 'transactionId'
          AttributeType: 'S'
        - AttributeName: 'timestamp'
          AttributeType: 'N'
        - AttributeName: 'status'
          AttributeType: 'S'
      KeySchema:
        - AttributeName: 'transactionId'
          KeyType: 'HASH'
        - AttributeName: 'timestamp'
          KeyType: 'RANGE'
      BillingMode: PAY_PER_REQUEST
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      GlobalSecondaryIndexes:
        - IndexName: 'StatusIndex'
          KeySchema:
            - AttributeName: 'status'
              KeyType: 'HASH'
          Projection:
            ProjectionType: INCLUDE
            NonKeyAttributes:
              - 'transactionId'
              - 'amount'
              - 'timestamp'
      DeletionProtectionEnabled: false

  # Dead Letter Queue (conditional for production only)
  TransactionDLQ:
    Type: AWS::SQS::Queue
    Condition: IsProduction
    DeletionPolicy: Delete
    UpdateReplacePolicy: Delete
    Properties:
      QueueName: !Sub 'TransactionDLQ-${EnvironmentSuffix}'
      MessageRetentionPeriod: 1209600  # 14 days
      VisibilityTimeout: 300

  # SQS Queue for transaction processing
  TransactionQueue:
    Type: AWS::SQS::Queue
    DeletionPolicy: Delete
    UpdateReplacePolicy: Delete
    Properties:
      QueueName: !Sub 'TransactionQueue-${EnvironmentSuffix}'
      MessageRetentionPeriod: 1209600  # 14 days (as per requirement)
      VisibilityTimeout: 1800  # 6 times Lambda timeout (6 * 300 = 1800 seconds)
      RedrivePolicy:
        !If
          - IsProduction
          - deadLetterTargetArn: !GetAtt TransactionDLQ.Arn
            maxReceiveCount: 3
          - !Ref AWS::NoValue

  # IAM Role for Lambda function
  TransactionProcessorRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub 'TransactionProcessorRole-${EnvironmentSuffix}'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole'
      Policies:
        - PolicyName: 'DynamoDBAccess'
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'dynamodb:PutItem'
                  - 'dynamodb:GetItem'
                  - 'dynamodb:UpdateItem'
                  - 'dynamodb:Query'
                  - 'dynamodb:Scan'
                Resource:
                  - !GetAtt TransactionRecordsTable.Arn
                  - !Sub '${TransactionRecordsTable.Arn}/index/*'
        - PolicyName: 'SQSAccess'
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'sqs:ReceiveMessage'
                  - 'sqs:DeleteMessage'
                  - 'sqs:GetQueueAttributes'
                Resource: !GetAtt TransactionQueue.Arn
        - PolicyName: 'KMSAccess'
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'kms:Decrypt'
                  - 'kms:DescribeKey'
                Resource: !GetAtt LambdaKMSKey.Arn

  # Lambda Function for transaction processing
  TransactionProcessorFunction:
    Type: AWS::Lambda::Function
    DeletionPolicy: Delete
    UpdateReplacePolicy: Delete
    Properties:
      FunctionName: !Sub 'TransactionProcessor-${EnvironmentSuffix}'
      Runtime: nodejs20.x
      Handler: index.handler
      Role: !GetAtt TransactionProcessorRole.Arn
      Timeout: 300  # 5 minutes (maximum as per requirement)
      MemorySize: 1024  # 1024MB as per requirement
      ReservedConcurrentExecutions: 100  # Exactly 100 as per requirement
      Architectures:
        - arm64  # AWS Graviton2 for cost optimization
      KmsKeyArn: !GetAtt LambdaKMSKey.Arn  # Encrypt environment variables
      Environment:
        Variables:
          TABLE_NAME: !Ref TransactionRecordsTable
          QUEUE_URL: !Ref TransactionQueue
          ENVIRONMENT: !Ref Environment
      Code:
        ZipFile: |
          const { DynamoDBClient, PutItemCommand } = require('@aws-sdk/client-dynamodb');
          const dynamoClient = new DynamoDBClient({ region: process.env.AWS_REGION });

          exports.handler = async (event) => {
            console.log('Processing transaction batch:', JSON.stringify(event));

            const tableName = process.env.TABLE_NAME;
            const results = [];

            // Process each SQS message
            for (const record of event.Records) {
              try {
                const transaction = JSON.parse(record.body);

                // Basic fraud validation
                const status = transaction.amount > 10000 ? 'flagged' : 'approved';

                // Store transaction in DynamoDB
                const params = {
                  TableName: tableName,
                  Item: {
                    transactionId: { S: transaction.transactionId || `txn-${Date.now()}` },
                    timestamp: { N: Date.now().toString() },
                    status: { S: status },
                    amount: { N: (transaction.amount || 0).toString() },
                    provider: { S: transaction.provider || 'unknown' },
                    processedAt: { S: new Date().toISOString() }
                  }
                };

                await dynamoClient.send(new PutItemCommand(params));

                results.push({
                  messageId: record.messageId,
                  status: 'success',
                  transactionStatus: status
                });

                console.log(`Transaction ${transaction.transactionId} processed: ${status}`);
              } catch (error) {
                console.error('Error processing transaction:', error);
                results.push({
                  messageId: record.messageId,
                  status: 'error',
                  error: error.message
                });
                // SQS will retry or send to DLQ based on configuration
                throw error;
              }
            }

            return {
              statusCode: 200,
              body: JSON.stringify({
                message: 'Batch processed',
                results: results
              })
            };
          };

  # Event Source Mapping - Lambda triggered by SQS
  TransactionProcessorEventSourceMapping:
    Type: AWS::Lambda::EventSourceMapping
    Properties:
      EventSourceArn: !GetAtt TransactionQueue.Arn
      FunctionName: !Ref TransactionProcessorFunction
      BatchSize: 10  # Batch size of 10 as per requirement
      Enabled: true

Outputs:
  TransactionProcessorFunctionName:
    Description: 'Name of the Transaction Processor Lambda function'
    Value: !Ref TransactionProcessorFunction
    Export:
      Name: !Sub '${AWS::StackName}-TransactionProcessorFunctionName'

  TransactionProcessorFunctionArn:
    Description: 'ARN of the Transaction Processor Lambda function'
    Value: !GetAtt TransactionProcessorFunction.Arn
    Export:
      Name: !Sub '${AWS::StackName}-TransactionProcessorFunctionArn'

  TransactionRecordsTableName:
    Description: 'Name of the DynamoDB TransactionRecords table'
    Value: !Ref TransactionRecordsTable
    Export:
      Name: !Sub '${AWS::StackName}-TransactionRecordsTableName'

  TransactionRecordsTableArn:
    Description: 'ARN of the DynamoDB TransactionRecords table'
    Value: !GetAtt TransactionRecordsTable.Arn
    Export:
      Name: !Sub '${AWS::StackName}-TransactionRecordsTableArn'

  TransactionQueueUrl:
    Description: 'URL of the Transaction SQS Queue'
    Value: !Ref TransactionQueue
    Export:
      Name: !Sub '${AWS::StackName}-TransactionQueueUrl'

  TransactionQueueArn:
    Description: 'ARN of the Transaction SQS Queue'
    Value: !GetAtt TransactionQueue.Arn
    Export:
      Name: !Sub '${AWS::StackName}-TransactionQueueArn'

  TransactionDLQUrl:
    Condition: IsProduction
    Description: 'URL of the Transaction Dead Letter Queue (Production only)'
    Value: !Ref TransactionDLQ
    Export:
      Name: !Sub '${AWS::StackName}-TransactionDLQUrl'

  LambdaKMSKeyArn:
    Description: 'ARN of the KMS key for Lambda encryption'
    Value: !GetAtt LambdaKMSKey.Arn
    Export:
      Name: !Sub '${AWS::StackName}-LambdaKMSKeyArn'

  LambdaKMSKeyId:
    Description: 'Key ID of the KMS key for Lambda encryption'
    Value: !Ref LambdaKMSKey
    Export:
      Name: !Sub '${AWS::StackName}-LambdaKMSKeyId'

  StackName:
    Description: 'Name of this CloudFormation stack'
    Value: !Ref AWS::StackName
    Export:
      Name: !Sub '${AWS::StackName}-StackName'

  EnvironmentSuffix:
    Description: 'Environment suffix used for this deployment'
    Value: !Ref EnvironmentSuffix
    Export:
      Name: !Sub '${AWS::StackName}-EnvironmentSuffix'

  Environment:
    Description: 'Environment type for this deployment'
    Value: !Ref Environment
    Export:
      Name: !Sub '${AWS::StackName}-Environment'
