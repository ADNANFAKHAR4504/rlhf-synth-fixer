import fs from 'fs';
import path from 'path';

const environmentSuffix = process.env.ENVIRONMENT_SUFFIX || 'dev';

describe('TapStack CloudFormation Template', () => {
  let template: any;

  beforeAll(() => {
    // Load the JSON template that's generated by cfn-flip from YAML
    const templatePath = path.join(__dirname, '../lib/TapStack.json');
    const templateContent = fs.readFileSync(templatePath, 'utf8');
    template = JSON.parse(templateContent);
  });

  describe('Template Structure', () => {
    test('should have valid CloudFormation format version', () => {
      expect(template.AWSTemplateFormatVersion).toBe('2010-09-09');
    });

    test('should have a description', () => {
      expect(template.Description).toBeDefined();
      expect(template.Description).toBe('Secure, highly available web application infrastructure');
    });

    test('should have Parameters section', () => {
      expect(template.Parameters).toBeDefined();
      expect(typeof template.Parameters).toBe('object');
    });

    test('should have Mappings section', () => {
      expect(template.Mappings).toBeDefined();
      expect(typeof template.Mappings).toBe('object');
    });

    test('should have Resources section', () => {
      expect(template.Resources).toBeDefined();
      expect(typeof template.Resources).toBe('object');
    });

    test('should have Outputs section', () => {
      expect(template.Outputs).toBeDefined();
      expect(typeof template.Outputs).toBe('object');
    });
  });

  describe('Parameters', () => {
    test('should have EnvironmentSuffix parameter', () => {
      expect(template.Parameters.EnvironmentSuffix).toBeDefined();
      const param = template.Parameters.EnvironmentSuffix;
      expect(param.Type).toBe('String');
      expect(param.Default).toBe('dev');
      expect(param.Description).toBe('Environment suffix for resources');
    });

    test('should have RandomSuffix parameter', () => {
      expect(template.Parameters.RandomSuffix).toBeDefined();
      const param = template.Parameters.RandomSuffix;
      expect(param.Type).toBe('String');
      expect(param.Default).toBe('573481771');
      expect(param.Description).toBe('Random suffix for S3 bucket names to ensure global uniqueness');
    });

    test('should have LatestAmiId parameter', () => {
      expect(template.Parameters.LatestAmiId).toBeDefined();
      const param = template.Parameters.LatestAmiId;
      expect(param.Type).toBe('AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>');
      expect(param.Default).toBe('/aws/service/ami-amazon-linux-latest/amzn2-ami-hvm-x86_64-gp2');
    });
  });

  describe('Mappings', () => {
    test('should have SubnetConfig mapping', () => {
      expect(template.Mappings.SubnetConfig).toBeDefined();
      expect(template.Mappings.SubnetConfig.VPC.CIDR).toBe('10.0.0.0/16');
      expect(template.Mappings.SubnetConfig.PublicSubnet1.CIDR).toBe('10.0.1.0/24');
      expect(template.Mappings.SubnetConfig.PublicSubnet2.CIDR).toBe('10.0.2.0/24');
      expect(template.Mappings.SubnetConfig.PrivateSubnet1.CIDR).toBe('10.0.10.0/24');
      expect(template.Mappings.SubnetConfig.PrivateSubnet2.CIDR).toBe('10.0.20.0/24');
    });
  });

  describe('KMS Resources', () => {
    test('should have MasterKMSKey resource', () => {
      expect(template.Resources.MasterKMSKey).toBeDefined();
      const kmsKey = template.Resources.MasterKMSKey;
      expect(kmsKey.Type).toBe('AWS::KMS::Key');
      expect(kmsKey.Properties.Description).toBe('Master KMS key for encryption');
    });

    test('MasterKMSKey should have proper key policy', () => {
      const kmsKey = template.Resources.MasterKMSKey;
      const keyPolicy = kmsKey.Properties.KeyPolicy;
      expect(keyPolicy.Version).toBe('2012-10-17');
      expect(keyPolicy.Statement).toHaveLength(4);
    });

    test('should have MasterKMSKeyAlias resource', () => {
      expect(template.Resources.MasterKMSKeyAlias).toBeDefined();
      const alias = template.Resources.MasterKMSKeyAlias;
      expect(alias.Type).toBe('AWS::KMS::Alias');
    });
  });

  describe('VPC and Networking Resources', () => {
    test('should have VPC resource', () => {
      expect(template.Resources.VPC).toBeDefined();
      const vpc = template.Resources.VPC;
      expect(vpc.Type).toBe('AWS::EC2::VPC');
      expect(vpc.Properties.EnableDnsHostnames).toBe(true);
      expect(vpc.Properties.EnableDnsSupport).toBe(true);
    });

    test('should have Internet Gateway', () => {
      expect(template.Resources.InternetGateway).toBeDefined();
      expect(template.Resources.InternetGateway.Type).toBe('AWS::EC2::InternetGateway');
    });

    test('should have NAT Gateway and EIP', () => {
      expect(template.Resources.NATGateway).toBeDefined();
      expect(template.Resources.NATGatewayEIP).toBeDefined();
      expect(template.Resources.NATGateway.Type).toBe('AWS::EC2::NatGateway');
      expect(template.Resources.NATGatewayEIP.Type).toBe('AWS::EC2::EIP');
    });

    test('should have public and private subnets', () => {
      expect(template.Resources.PublicSubnet1).toBeDefined();
      expect(template.Resources.PublicSubnet2).toBeDefined();
      expect(template.Resources.PrivateSubnet1).toBeDefined();
      expect(template.Resources.PrivateSubnet2).toBeDefined();

      expect(template.Resources.PublicSubnet1.Type).toBe('AWS::EC2::Subnet');
      expect(template.Resources.PublicSubnet1.Properties.MapPublicIpOnLaunch).toBe(true);
    });

    test('should have route tables and associations', () => {
      expect(template.Resources.PublicRouteTable).toBeDefined();
      expect(template.Resources.PrivateRouteTable).toBeDefined();
      expect(template.Resources.PublicSubnet1Association).toBeDefined();
      expect(template.Resources.PublicSubnet2Association).toBeDefined();
      expect(template.Resources.PrivateSubnet1Association).toBeDefined();
      expect(template.Resources.PrivateSubnet2Association).toBeDefined();
    });
  });

  describe('S3 Resources', () => {
    test('should have LoggingBucket with proper configuration', () => {
      expect(template.Resources.LoggingBucket).toBeDefined();
      const bucket = template.Resources.LoggingBucket;
      expect(bucket.Type).toBe('AWS::S3::Bucket');
      expect(bucket.Properties.VersioningConfiguration.Status).toBe('Enabled');
      expect(bucket.Properties.PublicAccessBlockConfiguration.BlockPublicAcls).toBe(true);
    });

    test('should have ApplicationBucket with proper configuration', () => {
      expect(template.Resources.ApplicationBucket).toBeDefined();
      const bucket = template.Resources.ApplicationBucket;
      expect(bucket.Type).toBe('AWS::S3::Bucket');
      expect(bucket.Properties.VersioningConfiguration.Status).toBe('Enabled');
      expect(bucket.Properties.LoggingConfiguration).toBeDefined();
    });

    test('S3 buckets should use RandomSuffix for naming', () => {
      const loggingBucket = template.Resources.LoggingBucket;
      const applicationBucket = template.Resources.ApplicationBucket;

      expect(loggingBucket.Properties.BucketName).toEqual({
        'Fn::Sub': 'logging-bucket-${RandomSuffix}'
      });
      expect(applicationBucket.Properties.BucketName).toEqual({
        'Fn::Sub': 'application-bucket-${RandomSuffix}'
      });
    });
  });

  describe('CloudTrail Resources', () => {
    test('should have CloudTrail resources', () => {
      expect(template.Resources.CloudTrail).toBeDefined();
      expect(template.Resources.CloudTrailLogGroup).toBeDefined();
      expect(template.Resources.CloudTrailRole).toBeDefined();
      expect(template.Resources.CloudTrailBucketPolicy).toBeDefined();
    });

    test('CloudTrail should have proper configuration', () => {
      const cloudTrail = template.Resources.CloudTrail;
      expect(cloudTrail.Type).toBe('AWS::CloudTrail::Trail');
      expect(cloudTrail.Properties.IncludeGlobalServiceEvents).toBe(true);
      expect(cloudTrail.Properties.IsMultiRegionTrail).toBe(true);
      expect(cloudTrail.Properties.EnableLogFileValidation).toBe(true);
    });
  });

  describe('VPC Flow Logs', () => {
    test('should have VPC Flow Log resources', () => {
      expect(template.Resources.VPCFlowLog).toBeDefined();
      expect(template.Resources.VPCFlowLogGroup).toBeDefined();
      expect(template.Resources.VPCFlowLogRole).toBeDefined();
    });

    test('VPC Flow Log should have correct configuration', () => {
      const flowLog = template.Resources.VPCFlowLog;
      expect(flowLog.Type).toBe('AWS::EC2::FlowLog');
      expect(flowLog.Properties.ResourceType).toBe('VPC');
      expect(flowLog.Properties.TrafficType).toBe('ALL');
      expect(flowLog.Properties.LogDestinationType).toBe('cloud-watch-logs');
    });
  });

  describe('Security Groups', () => {
    test('should have all required security groups', () => {
      expect(template.Resources.ALBSecurityGroup).toBeDefined();
      expect(template.Resources.WebServerSecurityGroup).toBeDefined();
      expect(template.Resources.DatabaseSecurityGroup).toBeDefined();
    });

    test('ALB Security Group should allow HTTP and HTTPS', () => {
      const albSG = template.Resources.ALBSecurityGroup;
      expect(albSG.Type).toBe('AWS::EC2::SecurityGroup');
      const ingress = albSG.Properties.SecurityGroupIngress;
      expect(ingress).toHaveLength(2);
      expect(ingress[0].FromPort).toBe(80);
      expect(ingress[1].FromPort).toBe(443);
    });

    test('should have separate security group rules to avoid circular dependencies', () => {
      expect(template.Resources.WebServerSecurityGroupIngressHTTP).toBeDefined();
      expect(template.Resources.WebServerSecurityGroupIngressHTTPS).toBeDefined();
      expect(template.Resources.ALBSecurityGroupEgressHTTP).toBeDefined();
      expect(template.Resources.ALBSecurityGroupEgressHTTPS).toBeDefined();
    });
  });

  describe('Database Resources', () => {
    test('should have database secret', () => {
      expect(template.Resources.DbSecret).toBeDefined();
      const secret = template.Resources.DbSecret;
      expect(secret.Type).toBe('AWS::SecretsManager::Secret');
      expect(secret.Properties.GenerateSecretString.PasswordLength).toBe(16);
    });

    test('should have RDS database with proper configuration', () => {
      expect(template.Resources.RDSDatabase).toBeDefined();
      const db = template.Resources.RDSDatabase;
      expect(db.Type).toBe('AWS::RDS::DBInstance');
      expect(db.Properties.Engine).toBe('mysql');
      expect(db.Properties.StorageEncrypted).toBe(true);
      expect(db.Properties.MultiAZ).toBe(true);
      expect(db.Properties.DeletionProtection).toBe(false);
    });

    test('should have DB subnet group', () => {
      expect(template.Resources.DBSubnetGroup).toBeDefined();
      const subnetGroup = template.Resources.DBSubnetGroup;
      expect(subnetGroup.Type).toBe('AWS::RDS::DBSubnetGroup');
    });

    test('should have RDS monitoring role', () => {
      expect(template.Resources.RDSMonitoringRole).toBeDefined();
      const role = template.Resources.RDSMonitoringRole;
      expect(role.Type).toBe('AWS::IAM::Role');
    });
  });

  describe('Load Balancer Resources', () => {
    test('should have Application Load Balancer', () => {
      expect(template.Resources.ApplicationLoadBalancer).toBeDefined();
      const alb = template.Resources.ApplicationLoadBalancer;
      expect(alb.Type).toBe('AWS::ElasticLoadBalancingV2::LoadBalancer');
      expect(alb.Properties.Type).toBe('application');
      expect(alb.Properties.Scheme).toBe('internet-facing');
    });

    test('should have ALB Target Group', () => {
      expect(template.Resources.ALBTargetGroup).toBeDefined();
      const tg = template.Resources.ALBTargetGroup;
      expect(tg.Type).toBe('AWS::ElasticLoadBalancingV2::TargetGroup');
      expect(tg.Properties.Port).toBe(80);
      expect(tg.Properties.Protocol).toBe('HTTP');
    });

    test('should have ALB Listener with proper configuration', () => {
      expect(template.Resources.ALBListener).toBeDefined();
      const listener = template.Resources.ALBListener;
      expect(listener.Type).toBe('AWS::ElasticLoadBalancingV2::Listener');
      expect(listener.Properties.Port).toBe(80);
      expect(listener.Properties.DefaultActions[0].Type).toBe('forward');
    });
  });

  describe('WAF Resources', () => {
    test('should have WebACL', () => {
      expect(template.Resources.WebACL).toBeDefined();
      const webACL = template.Resources.WebACL;
      expect(webACL.Type).toBe('AWS::WAFv2::WebACL');
      expect(webACL.Properties.Scope).toBe('REGIONAL');
      expect(webACL.Properties.Rules).toHaveLength(3);
    });

    test('WebACL should have rate limiting rule', () => {
      const webACL = template.Resources.WebACL;
      const rateLimitRule = webACL.Properties.Rules.find((rule: any) => rule.Name === 'RateLimitRule');
      expect(rateLimitRule).toBeDefined();
      expect(rateLimitRule.Statement.RateBasedStatement.Limit).toBe(2000);
    });

    test('should have WebACL association', () => {
      expect(template.Resources.WebACLAssociation).toBeDefined();
      const association = template.Resources.WebACLAssociation;
      expect(association.Type).toBe('AWS::WAFv2::WebACLAssociation');
    });
  });

  describe('EC2 and Auto Scaling Resources', () => {
    test('should have EC2 role and instance profile', () => {
      expect(template.Resources.EC2Role).toBeDefined();
      expect(template.Resources.EC2InstanceProfile).toBeDefined();

      const role = template.Resources.EC2Role;
      expect(role.Type).toBe('AWS::IAM::Role');
      expect(role.Properties.ManagedPolicyArns).toContain('arn:aws:iam::aws:policy/CloudWatchAgentServerPolicy');
    });

    test('should have Launch Template', () => {
      expect(template.Resources.WebServerLaunchTemplate).toBeDefined();
      const lt = template.Resources.WebServerLaunchTemplate;
      expect(lt.Type).toBe('AWS::EC2::LaunchTemplate');
      expect(lt.Properties.LaunchTemplateData.InstanceType).toBe('t3.micro');
    });

    test('should have Auto Scaling Group', () => {
      expect(template.Resources.AutoScalingGroup).toBeDefined();
      const asg = template.Resources.AutoScalingGroup;
      expect(asg.Type).toBe('AWS::AutoScaling::AutoScalingGroup');
      expect(asg.Properties.MinSize).toBe(2);
      expect(asg.Properties.MaxSize).toBe(6);
      expect(asg.Properties.DesiredCapacity).toBe(2);
    });
  });

  describe('Outputs', () => {
    test('should have all required outputs', () => {
      const expectedOutputs = [
        'VPCId',
        'LoadBalancerDNS',
        'LoggingBucketName',
        'ApplicationBucketName',
        'DatabaseEndpoint',
        'KMSKeyId'
      ];

      expectedOutputs.forEach(outputName => {
        expect(template.Outputs[outputName]).toBeDefined();
      });
    });

    test('outputs should have proper export names', () => {
      const expectedExports = {
        'VPCId': 'VPC-ID',
        'LoadBalancerDNS': 'ALB-DNS',
        'LoggingBucketName': 'LoggingBucket',
        'ApplicationBucketName': 'ApplicationBucket',
        'DatabaseEndpoint': 'DatabaseEndpoint',
        'KMSKeyId': 'KMSKey'
      };

      Object.entries(expectedExports).forEach(([outputKey, exportName]) => {
        const output = template.Outputs[outputKey];
        expect(output.Export).toBeDefined();
        expect(output.Export.Name).toEqual({
          'Fn::Sub': `\${EnvironmentSuffix}-${exportName}`
        });
      });
    });

    test('LoadBalancerDNS output should reference ALB DNS name', () => {
      const output = template.Outputs.LoadBalancerDNS;
      expect(output.Value).toEqual({
        'Fn::GetAtt': ['ApplicationLoadBalancer', 'DNSName']
      });
    });
  });

  describe('Security and Best Practices', () => {
    test('all S3 buckets should have encryption enabled', () => {
      const s3Resources = Object.keys(template.Resources).filter(key =>
        template.Resources[key].Type === 'AWS::S3::Bucket'
      );

      s3Resources.forEach(resourceName => {
        const bucket = template.Resources[resourceName];
        expect(bucket.Properties.BucketEncryption).toBeDefined();
        expect(bucket.Properties.BucketEncryption.ServerSideEncryptionConfiguration[0].ServerSideEncryptionByDefault.SSEAlgorithm).toBe('aws:kms');
      });
    });

    test('all S3 buckets should have public access blocked', () => {
      const s3Resources = Object.keys(template.Resources).filter(key =>
        template.Resources[key].Type === 'AWS::S3::Bucket'
      );

      s3Resources.forEach(resourceName => {
        const bucket = template.Resources[resourceName];
        const publicAccessBlock = bucket.Properties.PublicAccessBlockConfiguration;
        expect(publicAccessBlock.BlockPublicAcls).toBe(true);
        expect(publicAccessBlock.BlockPublicPolicy).toBe(true);
        expect(publicAccessBlock.IgnorePublicAcls).toBe(true);
        expect(publicAccessBlock.RestrictPublicBuckets).toBe(true);
      });
    });

    test('RDS should have encryption and backup enabled', () => {
      const rds = template.Resources.RDSDatabase;
      expect(rds.Properties.StorageEncrypted).toBe(true);
      expect(rds.Properties.BackupRetentionPeriod).toBeGreaterThan(0);
    });

    test('database credentials should use Secrets Manager', () => {
      const rds = template.Resources.RDSDatabase;
      expect(rds.Properties.MasterUsername).toEqual({
        'Fn::Join': ['', ['{{resolve:secretsmanager:', { Ref: 'DbSecret' }, ':SecretString:username}}']]
      });
      expect(rds.Properties.MasterUserPassword).toEqual({
        'Fn::Join': ['', ['{{resolve:secretsmanager:', { Ref: 'DbSecret' }, ':SecretString:password}}']]
      });
    });
  });

  describe('Resource Dependencies', () => {
    test('should not have circular dependencies', () => {
      // This test ensures that the template structure doesn't create circular dependencies
      // by checking that security group rules are separate resources
      expect(template.Resources.WebServerSecurityGroupIngressHTTP).toBeDefined();
      expect(template.Resources.ALBSecurityGroupEgressHTTP).toBeDefined();
    });

    test('NAT Gateway should depend on Internet Gateway attachment', () => {
      const natGatewayEIP = template.Resources.NATGatewayEIP;
      expect(natGatewayEIP.DependsOn).toBe('AttachGateway');
    });
  });

  describe('Template Validation', () => {
    test('should have valid YAML structure', () => {
      expect(template).toBeDefined();
      expect(typeof template).toBe('object');
    });

    test('should not have any undefined or null required sections', () => {
      expect(template.AWSTemplateFormatVersion).not.toBeNull();
      expect(template.Description).not.toBeNull();
      expect(template.Parameters).not.toBeNull();
      expect(template.Resources).not.toBeNull();
      expect(template.Outputs).not.toBeNull();
    });

    test('should have reasonable number of resources for infrastructure template', () => {
      const resourceCount = Object.keys(template.Resources).length;
      expect(resourceCount).toBeGreaterThan(20); // Should have many resources for full infrastructure
    });

    test('should have exactly 3 parameters', () => {
      const parameterCount = Object.keys(template.Parameters).length;
      expect(parameterCount).toBe(3);
    });

    test('should have exactly 6 outputs', () => {
      const outputCount = Object.keys(template.Outputs).length;
      expect(outputCount).toBe(6);
    });
  });

  describe('Resource Naming Convention', () => {
    test('most resources should use EnvironmentSuffix for naming', () => {
      const resourcesWithEnvironmentSuffix = [
        'VPC', 'InternetGateway', 'PublicSubnet1', 'PublicSubnet2',
        'PrivateSubnet1', 'PrivateSubnet2', 'NATGateway',
        'PublicRouteTable', 'PrivateRouteTable', 'ALBSecurityGroup',
        'WebServerSecurityGroup', 'DatabaseSecurityGroup'
      ];

      resourcesWithEnvironmentSuffix.forEach(resourceName => {
        const resource = template.Resources[resourceName];
        if (resource && resource.Properties && resource.Properties.Tags) {
          const nameTag = resource.Properties.Tags.find((tag: any) => tag.Key === 'Name');
          if (nameTag) {
            expect(nameTag.Value).toEqual({
              'Fn::Sub': expect.stringContaining('${EnvironmentSuffix}')
            });
          }
        }
      });
    });

    test('export names should follow naming convention', () => {
      const expectedExports = {
        'VPCId': 'VPC-ID',
        'LoadBalancerDNS': 'ALB-DNS',
        'LoggingBucketName': 'LoggingBucket',
        'ApplicationBucketName': 'ApplicationBucket',
        'DatabaseEndpoint': 'DatabaseEndpoint',
        'KMSKeyId': 'KMSKey'
      };

      Object.entries(expectedExports).forEach(([outputKey, exportName]) => {
        const output = template.Outputs[outputKey];
        expect(output.Export.Name).toEqual({
          'Fn::Sub': `\${EnvironmentSuffix}-${exportName}`
        });
      });
    });
  });
});