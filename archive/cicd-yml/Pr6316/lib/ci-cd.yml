# azure-pipelines.yml
# Production-grade CI/CD Pipeline for Global IoT Edge Computing Platform
# Version: 1.0.0

# ============================================================================
# PREREQUISITES AND SETUP REQUIREMENTS
# ============================================================================
#
# Before running this pipeline, ensure the following are configured:
#
# 1. AZURE SERVICE CONNECTIONS (Azure DevOps Project Settings > Service Connections)
#    - IoT-Platform-Subscription: Azure Resource Manager connection with Contributor access
#    - ACR-Connection: Docker Registry connection to Azure Container Registry
#    - Snyk-Service: Snyk security scanning service connection
#
# 2. VARIABLE GROUPS OR PIPELINE VARIABLES
#    - subscriptionId: Your Azure subscription ID (set in variables section or variable group)
#    - teamsWebhookUrl: Microsoft Teams incoming webhook URL for notifications
#    - pagerDutyIntegrationKey: PagerDuty integration key for alerts
#    - TRIGGER_ROLLBACK: Set to 'true' when queuing pipeline to manually trigger rollback
#                       (used for emergency rollbacks independent of deployment failure)
#
# 3. TERRAFORM BACKEND (Must be created before first run)
#    Resource Group: terraform-state-rg
#    Storage Account: tfstateiot
#    Container: tfstate
#    State File: iot-platform.tfstate
#    Bootstrap command:
#      az group create --name terraform-state-rg --location eastus
#      az storage account create --name tfstateiot --resource-group terraform-state-rg \
#        --location eastus --sku Standard_LRS
#      az storage container create --name tfstate --account-name tfstateiot
#
# 4. CUSTOM AGENT POOLS (Optional - will fallback to Azure-hosted if not available)
#    - Performance-Testing-Pool: Self-hosted agents with Standard_D4s_v3 VMs
#    - Staging-Testing-Pool: Self-hosted agents with Standard_D8s_v3 VMs
#
# 5. REQUIRED SCRIPTS (See scripts/ directory)
#    The pipeline requires 30+ bash/python scripts in the scripts/ directory.
#    A validation job will check for missing scripts at pipeline start.
#    See SCRIPTS_INTERFACE.md for detailed script specifications.
#
# 6. AZURE ENVIRONMENTS (Azure DevOps > Pipelines > Environments)
#    - dev: Development environment
#    - staging: Staging environment with approval gates
#    - production: Production environment with manual approval
#
# 7. AZURE RESOURCES (Created by Terraform during deployment)
#    - Azure IoT Hub
#    - Azure Container Registry
#    - Azure Kubernetes Service (AKS)
#    - Azure Functions
#    - Azure Cosmos DB
#    - Azure Event Hubs
#    - Azure Traffic Manager
#    - Azure CDN
#    - Azure Redis Cache
#
# ============================================================================

trigger:
  branches:
    include:
    - main
    - develop
    - feature/*
  paths:
    exclude:
    - README.md
    - docs/*

pr:
  branches:
    include:
    - main
    - develop
  paths:
    exclude:
    - README.md
    - docs/*

schedules:
- cron: "0 2 * * *"
  displayName: Nightly full pipeline execution
  branches:
    include:
    - main
  always: true

variables:
  # Azure subscription and service connections
  azureSubscription: 'IoT-Platform-Subscription'
  subscriptionId: '00000000-0000-0000-0000-000000000000'  # Replace with actual subscription ID
  dockerRegistryServiceConnection: 'ACR-Connection'

  # Container registry and clusters
  acrName: 'iotplatformacr'
  aksCluster: 'iot-analytics-cluster'
  iotHubName: 'global-iot-hub'
  devAksCluster: 'dev-iot-analytics'
  stagingAksCluster: 'staging-iot-analytics'
  prodAksRegions: 'eastus,westus,northeurope,southeastasia,australiaeast,brazilsouth'

  # Resource group names
  devResourceGroup: 'dev-iot-rg'
  stagingResourceGroup: 'staging-iot-rg'
  prodResourceGroupPrefix: 'prod-iot'
  terraformStateResourceGroup: 'terraform-state-rg'

  # Function app names
  devFunctionApp: 'dev-iot-functions'
  stagingFunctionApp: 'staging-iot-functions'
  prodFunctionAppPrefix: 'prod-iot-functions'

  # CDN configuration
  cdnProfileName: 'iot-cdn-profile'
  cdnEndpointName: 'iot-cdn-endpoint'
  prodGlobalResourceGroup: 'prod-iot-global-rg'

  # Terraform backend configuration
  terraformStateStorageAccount: 'tfstateiot'
  terraformStateContainer: 'tfstate'
  terraformStateKey: 'iot-platform.tfstate'

  # Build configuration
  buildConfiguration: 'Release'
  nodeVersion: '18.x'
  terraformVersion: '1.6.0'

  # Test configuration
  testDeviceCount: 1000
  performanceDeviceCount: 100000
  canaryTrafficSplit: 10
  errorRateThreshold: 1

  # Notification endpoints
  teamsWebhookUrl: ''  # Set via pipeline variable or variable group
  pagerDutyIntegrationKey: ''  # Set via pipeline variable or variable group

  # Paths
  functionsPath: 'src/functions'
  edgeModulesPath: 'src/edge-modules'
  analyticsPath: 'src/analytics'
  infrastructurePath: 'infrastructure/terraform'
  scriptsPath: 'scripts'

  # Feature flags
  ${{ if eq(variables['Build.Reason'], 'PullRequest') }}:
    runFullPipeline: false
  ${{ else }}:
    runFullPipeline: true

stages:
# ==================== VALIDATION STAGE ====================
- stage: Validation
  displayName: 'Validation Stage'
  jobs:
  - job: validateScripts
    displayName: 'Validate Required Scripts Existence'
    pool:
      vmImage: 'ubuntu-latest'
    timeoutInMinutes: 10
    steps:
    - script: |
        echo "Checking for required scripts..."
        MISSING_SCRIPTS=()

        # List of required scripts
        REQUIRED_SCRIPTS=(
          "validate-iot-config.sh"
          "validate-device-twins.py"
          "validate-edge-manifests.py"
          "integration-tests.sh"
          "edge-runtime-tests.sh"
          "performance-tests.sh"
          "generate-sbom.sh"
          "compliance-check.sh"
          "validate-security-config.sh"
          "device-scenario-tests.sh"
          "validate-telemetry-flow.sh"
          "test-offline-sync.sh"
          "deploy-canary.sh"
          "monitor-canary.sh"
          "rollback-canary.sh"
          "staging-e2e-tests.sh"
          "disaster-recovery-test.sh"
          "pre-deploy-checks.sh"
          "deploy-iot-hub.sh"
          "deploy-event-hubs.sh"
          "deploy-aks.sh"
          "configure-cosmos.sh"
          "validate-region-deployment.sh"
          "configure-traffic-manager.sh"
          "route-traffic.sh"
          "post-deploy-validation.sh"
          "setup-monitoring.sh"
          "create-alerts.sh"
          "create-dashboards.sh"
          "notify-pagerduty.sh"
          "rollback-iot.sh"
          "rollback-functions.sh"
          "rollback-traffic-manager.sh"
          "notify-rollback.sh"
        )

        for script in "${REQUIRED_SCRIPTS[@]}"; do
          if [ ! -f "$(scriptsPath)/$script" ]; then
            MISSING_SCRIPTS+=("$script")
            echo "⚠️  Missing: $script"
          else
            echo "✓ Found: $script"
          fi
        done

        if [ ${#MISSING_SCRIPTS[@]} -gt 0 ]; then
          echo ""
          echo "========================================="
          echo "WARNING: ${#MISSING_SCRIPTS[@]} required scripts are missing"
          echo "========================================="
          echo "Pipeline may fail at runtime when these scripts are invoked."
          echo "Please ensure these scripts are created before deployment stages."
          echo ""
          echo "Missing scripts should implement the following interfaces:"
          echo "See SCRIPTS_INTERFACE.md for detailed documentation."
          exit 1
        else
          echo ""
          echo "✅ All required scripts are present"
        fi
      displayName: 'Check required scripts existence'
      continueOnError: true

  - job: lintCode
    displayName: 'Code Linting and Type Checking'
    dependsOn: validateScripts
    pool:
      vmImage: 'ubuntu-latest'
    timeoutInMinutes: 30
    steps:
    - task: NodeTool@0
      inputs:
        versionSpec: '$(nodeVersion)'
      displayName: 'Install Node.js'
    
    - task: Cache@2
      inputs:
        key: 'npm | "$(Agent.OS)" | $(functionsPath)/package-lock.json'
        path: '$(functionsPath)/node_modules'
        cacheHitVar: 'CACHE_RESTORED'
      displayName: 'Cache npm packages'
    
    - script: |
        cd $(functionsPath)
        npm ci
      displayName: 'Install dependencies'
      condition: ne(variables.CACHE_RESTORED, 'true')
    
    - script: |
        cd $(functionsPath)
        npm run lint
        npm run type-check
      displayName: 'Run ESLint and TypeScript compiler'
    
    - task: TerraformInstaller@0
      inputs:
        terraformVersion: '$(terraformVersion)'
      displayName: 'Install Terraform'
    
    - script: |
        cd $(infrastructurePath)
        terraform init -backend=false
        terraform validate
      displayName: 'Validate Terraform configurations'
    
    - script: |
        docker run --rm -i hadolint/hadolint < $(edgeModulesPath)/SensorProcessor/Dockerfile
        docker run --rm -i hadolint/hadolint < $(edgeModulesPath)/DataFilter/Dockerfile
        docker run --rm -i hadolint/hadolint < $(edgeModulesPath)/LocalAnalytics/Dockerfile
      displayName: 'Lint Dockerfiles with Hadolint'
    
    - script: |
        find $(scriptsPath) -name "*.sh" -exec shellcheck {} \;
      displayName: 'Check shell scripts with ShellCheck'

  - job: checkDependencies
    displayName: 'Check Dependencies for Vulnerabilities'
    pool:
      vmImage: 'ubuntu-latest'
    timeoutInMinutes: 30
    steps:
    - task: NodeTool@0
      inputs:
        versionSpec: '$(nodeVersion)'
      displayName: 'Install Node.js'
    
    - script: |
        cd $(functionsPath)
        npm audit --audit-level=moderate
      displayName: 'Run npm audit on Functions'
    
    - task: SnykSecurityScan@1
      inputs:
        serviceConnectionEndpoint: 'Snyk-Service'
        testType: 'app'
        severityThreshold: 'high'
        monitorWhen: 'always'
        targetFile: '$(functionsPath)/package.json'
      displayName: 'Snyk scan for Node.js Functions'
    
    - task: UseDotNet@2
      inputs:
        version: '7.x'
      displayName: 'Install .NET SDK'
    
    - script: |
        dotnet list $(edgeModulesPath)/SensorProcessor/*.csproj package --vulnerable --include-transitive
        dotnet list $(edgeModulesPath)/DataFilter/*.csproj package --vulnerable --include-transitive
        dotnet list $(edgeModulesPath)/LocalAnalytics/*.csproj package --vulnerable --include-transitive
      displayName: 'Check C# IoT Edge modules for vulnerable packages'

  - job: validateIoTConfig
    displayName: 'Validate IoT Configurations'
    pool:
      vmImage: 'ubuntu-latest'
    timeoutInMinutes: 20
    steps:
    - task: AzureCLI@2
      inputs:
        azureSubscription: '$(azureSubscription)'
        scriptType: 'bash'
        scriptLocation: 'scriptPath'
        scriptPath: '$(scriptsPath)/validate-iot-config.sh'
        arguments: '$(iotHubName)'
        useGlobalConfig: true
        addSpnToEnvironment: false
      displayName: 'Validate IoT Hub device provisioning templates'
    
    - script: |
        python3 $(scriptsPath)/validate-device-twins.py config/device-twin-schemas/*.json
      displayName: 'Validate device twin schemas'
    
    - script: |
        python3 $(scriptsPath)/validate-edge-manifests.py config/edge-deployments/*.json
      displayName: 'Validate layered edge deployment manifests'

# ==================== BUILD STAGE ====================
- stage: Build
  displayName: 'Build Stage'
  dependsOn: Validation
  condition: and(succeeded(), eq(variables.runFullPipeline, true))
  jobs:
  - job: buildFunctions
    displayName: 'Build Azure Functions'
    pool:
      vmImage: 'ubuntu-latest'
    timeoutInMinutes: 30
    steps:
    - task: NodeTool@0
      inputs:
        versionSpec: '$(nodeVersion)'
      displayName: 'Install Node.js'
    
    - task: Cache@2
      inputs:
        key: 'npm | "$(Agent.OS)" | $(functionsPath)/package-lock.json'
        path: '$(functionsPath)/node_modules'
        cacheHitVar: 'CACHE_RESTORED'
      displayName: 'Cache npm packages'
    
    - script: |
        cd $(functionsPath)
        npm ci --production
      displayName: 'Install production dependencies'
      condition: ne(variables.CACHE_RESTORED, 'true')
    
    - script: |
        cd $(functionsPath)
        npm run build
        npm prune --production
      displayName: 'Compile TypeScript Functions'
    
    - task: ArchiveFiles@2
      inputs:
        rootFolderOrFile: '$(functionsPath)'
        includeRootFolder: false
        archiveType: 'zip'
        archiveFile: '$(Build.ArtifactStagingDirectory)/functions.zip'
      displayName: 'Archive Functions'
    
    - publish: '$(Build.ArtifactStagingDirectory)/functions.zip'
      artifact: 'functions'
      displayName: 'Publish Functions artifact'

  - job: buildEdgeModules
    displayName: 'Build IoT Edge Modules'
    pool:
      vmImage: 'ubuntu-latest'
    timeoutInMinutes: 45
    steps:
    - task: Docker@2
      inputs:
        containerRegistry: '$(dockerRegistryServiceConnection)'
        command: 'buildAndPush'
        repository: 'iot-edge/sensor-processor'
        dockerfile: '$(edgeModulesPath)/SensorProcessor/Dockerfile'
        buildContext: '$(edgeModulesPath)/SensorProcessor'
        tags: |
          $(Build.BuildId)
          latest
      displayName: 'Build and push SensorProcessor module'
    
    - task: Docker@2
      inputs:
        containerRegistry: '$(dockerRegistryServiceConnection)'
        command: 'buildAndPush'
        repository: 'iot-edge/data-filter'
        dockerfile: '$(edgeModulesPath)/DataFilter/Dockerfile'
        buildContext: '$(edgeModulesPath)/DataFilter'
        tags: |
          $(Build.BuildId)
          latest
      displayName: 'Build and push DataFilter module'
    
    - task: Docker@2
      inputs:
        containerRegistry: '$(dockerRegistryServiceConnection)'
        command: 'buildAndPush'
        repository: 'iot-edge/local-analytics'
        dockerfile: '$(edgeModulesPath)/LocalAnalytics/Dockerfile'
        buildContext: '$(edgeModulesPath)/LocalAnalytics'
        tags: |
          $(Build.BuildId)
          latest
      displayName: 'Build and push LocalAnalytics module'

  - job: buildAnalyticsContainers
    displayName: 'Build Analytics Containers for AKS'
    pool:
      vmImage: 'ubuntu-latest'
    timeoutInMinutes: 45
    steps:
    - task: Docker@2
      inputs:
        containerRegistry: '$(dockerRegistryServiceConnection)'
        command: 'buildAndPush'
        repository: 'analytics/timeseries-analyzer'
        dockerfile: '$(analyticsPath)/TimeSeriesAnalyzer/Dockerfile'
        buildContext: '$(analyticsPath)/TimeSeriesAnalyzer'
        tags: |
          $(Build.BuildId)
          latest
      displayName: 'Build and push TimeSeriesAnalyzer'
    
    - task: Docker@2
      inputs:
        containerRegistry: '$(dockerRegistryServiceConnection)'
        command: 'buildAndPush'
        repository: 'analytics/anomaly-detector'
        dockerfile: '$(analyticsPath)/AnomalyDetector/Dockerfile'
        buildContext: '$(analyticsPath)/AnomalyDetector'
        tags: |
          $(Build.BuildId)
          latest
      displayName: 'Build and push AnomalyDetector'
    
    - task: Docker@2
      inputs:
        containerRegistry: '$(dockerRegistryServiceConnection)'
        command: 'buildAndPush'
        repository: 'analytics/predictive-model'
        dockerfile: '$(analyticsPath)/PredictiveModel/Dockerfile'
        buildContext: '$(analyticsPath)/PredictiveModel'
        tags: |
          $(Build.BuildId)
          latest
      displayName: 'Build and push PredictiveModel'

  - job: planInfrastructure
    displayName: 'Plan Infrastructure with Terraform'
    pool:
      vmImage: 'ubuntu-latest'
    timeoutInMinutes: 30
    steps:
    - task: TerraformInstaller@0
      inputs:
        terraformVersion: '$(terraformVersion)'
      displayName: 'Install Terraform'
    
    - task: TerraformTaskV4@4
      inputs:
        provider: 'azurerm'
        command: 'init'
        workingDirectory: '$(infrastructurePath)'
        backendServiceArm: '$(azureSubscription)'
        backendAzureRmResourceGroupName: '$(terraformStateResourceGroup)'
        backendAzureRmStorageAccountName: '$(terraformStateStorageAccount)'
        backendAzureRmContainerName: '$(terraformStateContainer)'
        backendAzureRmKey: '$(terraformStateKey)'
      displayName: 'Terraform Init'
    
    - task: TerraformTaskV4@4
      inputs:
        provider: 'azurerm'
        command: 'plan'
        workingDirectory: '$(infrastructurePath)'
        commandOptions: '-out=tfplan'
        environmentServiceNameAzureRM: '$(azureSubscription)'
      displayName: 'Terraform Plan'
    
    - publish: '$(infrastructurePath)/tfplan'
      artifact: 'terraform-plan'
      displayName: 'Publish Terraform plan'

# ==================== TEST STAGE ====================
- stage: Test
  displayName: 'Test Stage'
  dependsOn: Build
  condition: succeeded()
  jobs:
  - job: unitTests
    displayName: 'Unit Tests'
    pool:
      vmImage: 'ubuntu-latest'
    timeoutInMinutes: 30
    steps:
    - task: NodeTool@0
      inputs:
        versionSpec: '$(nodeVersion)'
      displayName: 'Install Node.js'
    
    - script: |
        cd $(functionsPath)
        npm ci
        npm test -- --coverage --testResultsProcessor=jest-junit
      displayName: 'Run Jest tests for Functions'
    
    - task: PublishTestResults@2
      inputs:
        testResultsFormat: 'JUnit'
        testResultsFiles: '**/junit.xml'
        searchFolder: '$(functionsPath)'
        mergeTestResults: true
        testRunTitle: 'Functions Unit Tests'
      displayName: 'Publish Functions test results'
    
    - task: PublishCodeCoverageResults@1
      inputs:
        codeCoverageTool: 'Cobertura'
        summaryFileLocation: '$(functionsPath)/coverage/cobertura-coverage.xml'
      displayName: 'Publish code coverage'
    
    - task: UseDotNet@2
      inputs:
        version: '7.x'
      displayName: 'Install .NET SDK'
    
    - script: |
        dotnet test $(edgeModulesPath)/SensorProcessor.Tests/*.csproj --logger:"trx" --collect:"XPlat Code Coverage"
        dotnet test $(edgeModulesPath)/DataFilter.Tests/*.csproj --logger:"trx" --collect:"XPlat Code Coverage"
        dotnet test $(edgeModulesPath)/LocalAnalytics.Tests/*.csproj --logger:"trx" --collect:"XPlat Code Coverage"
      displayName: 'Run MSTest for C# modules'
    
    - task: PublishTestResults@2
      inputs:
        testResultsFormat: 'VSTest'
        testResultsFiles: '**/*.trx'
        searchFolder: '$(edgeModulesPath)'
        mergeTestResults: true
        testRunTitle: 'Edge Modules Unit Tests'
      displayName: 'Publish C# test results'

  - job: integrationTests
    displayName: 'Integration Tests'
    pool:
      vmImage: 'ubuntu-latest'
    timeoutInMinutes: 60
    steps:
    - task: AzureResourceManagerTemplateDeployment@3
      inputs:
        deploymentScope: 'Resource Group'
        azureResourceManagerConnection: '$(azureSubscription)'
        subscriptionId: '$(subscriptionId)'
        action: 'Create Or Update Resource Group'
        resourceGroupName: 'test-iot-rg-$(Build.BuildId)'
        location: 'eastus'
        templateLocation: 'Linked artifact'
        csmFile: 'templates/test-environment.json'
        deploymentMode: 'Incremental'
      displayName: 'Deploy test IoT Hub and Functions'
    
    - task: AzureCLI@2
      inputs:
        azureSubscription: '$(azureSubscription)'
        scriptType: 'bash'
        scriptLocation: 'scriptPath'
        scriptPath: '$(scriptsPath)/integration-tests.sh'
        arguments: 'test-iot-rg-$(Build.BuildId)'
        useGlobalConfig: true
      displayName: 'Run integration tests'
    
    - task: AzureResourceManagerTemplateDeployment@3
      inputs:
        deploymentScope: 'Resource Group'
        azureResourceManagerConnection: '$(azureSubscription)'
        subscriptionId: '$(subscriptionId)'
        action: 'DeleteRG'
        resourceGroupName: 'test-iot-rg-$(Build.BuildId)'
      displayName: 'Clean up test resources'
      condition: always()

  - job: edgeRuntimeTests
    displayName: 'Edge Runtime Tests'
    pool:
      vmImage: 'ubuntu-latest'
    timeoutInMinutes: 45
    steps:
    - script: |
        pip install iotedgedev
      displayName: 'Install IoT Edge Dev Tool'
    
    - script: |
        iotedgedev init
        iotedgedev build
        iotedgedev start --setup --file config/deployment.test.json
      displayName: 'Setup local IoT Edge runtime'
    
    - task: AzureCLI@2
      inputs:
        azureSubscription: '$(azureSubscription)'
        scriptType: 'bash'
        scriptLocation: 'scriptPath'
        scriptPath: '$(scriptsPath)/edge-runtime-tests.sh'
        useGlobalConfig: true
      displayName: 'Test inter-module communication and offline resilience'
    
    - script: |
        iotedgedev stop
      displayName: 'Stop IoT Edge runtime'
      condition: always()

  - job: performanceTests
    displayName: 'Performance Tests'
    pool:
      name: 'Performance-Testing-Pool'
      vmImage: 'Standard_D4s_v3'
    timeoutInMinutes: 120
    steps:
    - task: AzureCLI@2
      inputs:
        azureSubscription: '$(azureSubscription)'
        scriptType: 'bash'
        scriptLocation: 'scriptPath'
        scriptPath: '$(scriptsPath)/performance-tests.sh'
        arguments: '$(performanceDeviceCount)'
        useGlobalConfig: true
      displayName: 'Simulate 100k devices and measure performance'
    
    - publish: '$(System.DefaultWorkingDirectory)/performance-results'
      artifact: 'performance-test-results'
      displayName: 'Publish performance test results'

# ==================== SECURITY STAGE ====================
- stage: Security
  displayName: 'Security Stage'
  dependsOn: Build
  condition: succeeded()
  jobs:
  - job: containerScan
    displayName: 'Container Security Scanning'
    pool:
      vmImage: 'ubuntu-latest'
    timeoutInMinutes: 45
    steps:
    - script: |
        docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
          aquasec/trivy image --severity HIGH,CRITICAL --exit-code 1 \
          $(acrName).azurecr.io/iot-edge/sensor-processor:$(Build.BuildId)
      displayName: 'Trivy scan SensorProcessor'
      continueOnError: false
    
    - script: |
        docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
          aquasec/trivy image --severity HIGH,CRITICAL --exit-code 1 \
          $(acrName).azurecr.io/iot-edge/data-filter:$(Build.BuildId)
      displayName: 'Trivy scan DataFilter'
      continueOnError: false
    
    - script: |
        docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
          aquasec/trivy image --severity HIGH,CRITICAL --exit-code 1 \
          $(acrName).azurecr.io/iot-edge/local-analytics:$(Build.BuildId)
      displayName: 'Trivy scan LocalAnalytics'
      continueOnError: false
    
    - script: |
        bash $(scriptsPath)/generate-sbom.sh $(Build.BuildId)
      displayName: 'Generate SBOM with Grype'
    
    - publish: '$(System.DefaultWorkingDirectory)/sbom'
      artifact: 'sbom-reports'
      displayName: 'Publish SBOM reports'

  - job: sastScan
    displayName: 'Static Application Security Testing'
    pool:
      vmImage: 'ubuntu-latest'
    timeoutInMinutes: 30
    steps:
    - task: PowerShell@2
      inputs:
        targetType: 'inline'
        script: |
          Install-Module -Name PSScriptAnalyzer -Force -Scope CurrentUser
          Invoke-ScriptAnalyzer -Path $(scriptsPath) -Recurse -ReportSummary
      displayName: 'PSScriptAnalyzer on PowerShell scripts'
    
    - script: |
        pip install semgrep
        semgrep --config=auto $(functionsPath) --json --output=semgrep-results.json
      displayName: 'Semgrep scan on TypeScript code'
    
    - script: |
        pip install checkov
        checkov -d $(infrastructurePath) --framework terraform --compact
      displayName: 'Checkov scan on Terraform files'
      continueOnError: false

  - job: secretScan
    displayName: 'Secret Detection'
    pool:
      vmImage: 'ubuntu-latest'
    timeoutInMinutes: 20
    steps:
    - script: |
        docker run --rm -v $(Build.SourcesDirectory):/src \
          trufflesecurity/trufflehog:latest filesystem /src \
          --fail --json --output=/src/trufflehog-results.json
      displayName: 'TruffleHog secret scan'
      continueOnError: false
    
    - publish: '$(Build.SourcesDirectory)/trufflehog-results.json'
      artifact: 'secret-scan-results'
      condition: failed()
      displayName: 'Publish secret scan results if found'

  - job: complianceScan
    displayName: 'Compliance and Policy Scanning'
    pool:
      vmImage: 'ubuntu-latest'
    timeoutInMinutes: 30
    steps:
    - task: AzureCLI@2
      inputs:
        azureSubscription: '$(azureSubscription)'
        scriptType: 'bash'
        scriptLocation: 'scriptPath'
        scriptPath: '$(scriptsPath)/compliance-check.sh'
        useGlobalConfig: true
      displayName: 'Azure Policy compliance check'
    
    - task: AzureCLI@2
      inputs:
        azureSubscription: '$(azureSubscription)'
        scriptType: 'bash'
        scriptLocation: 'scriptPath'
        scriptPath: '$(scriptsPath)/validate-security-config.sh'
        useGlobalConfig: true
      displayName: 'Validate NSG rules and encryption'

# ==================== DEPLOY DEV STAGE ====================
- stage: DeployDev
  displayName: 'Deploy to Dev Environment'
  dependsOn: 
  - Test
  - Security
  condition: and(succeeded(), ne(variables['Build.Reason'], 'PullRequest'))
  jobs:
  - deployment: deployInfra
    displayName: 'Deploy Infrastructure'
    pool:
      vmImage: 'ubuntu-latest'
    environment: 'dev'
    strategy:
      runOnce:
        deploy:
          steps:
          - download: current
            artifact: 'terraform-plan'
            displayName: 'Download Terraform plan'
          
          - task: TerraformInstaller@0
            inputs:
              terraformVersion: '$(terraformVersion)'
            displayName: 'Install Terraform'
          
          - task: AzureCLI@2
            inputs:
              azureSubscription: '$(azureSubscription)'
              scriptType: 'bash'
              scriptLocation: 'inline'
              inlineScript: |
                cd $(infrastructurePath)
                terraform init
                terraform workspace select dev || terraform workspace new dev
                terraform apply -auto-approve
              useGlobalConfig: true
              addSpnToEnvironment: false
            displayName: 'Apply Terraform for dev environment'

  - deployment: deployFunctions
    displayName: 'Deploy Azure Functions'
    dependsOn: deployInfra
    pool:
      vmImage: 'ubuntu-latest'
    environment: 'dev'
    strategy:
      runOnce:
        deploy:
          steps:
          - download: current
            artifact: 'functions'
            displayName: 'Download Functions artifact'
          
          - task: AzureCLI@2
            inputs:
              azureSubscription: '$(azureSubscription)'
              scriptType: 'bash'
              scriptLocation: 'inline'
              inlineScript: |
                az functionapp deployment source config-zip \
                  --resource-group $(devResourceGroup) \
                  --name $(devFunctionApp) \
                  --src $(Pipeline.Workspace)/functions/functions.zip
              useGlobalConfig: true
              addSpnToEnvironment: false
            displayName: 'Deploy Functions to dev'

  - deployment: deployEdge
    displayName: 'Deploy IoT Edge Configurations'
    dependsOn: deployInfra
    pool:
      vmImage: 'ubuntu-latest'
    environment: 'dev'
    strategy:
      runOnce:
        deploy:
          steps:
          - task: AzureCLI@2
            inputs:
              azureSubscription: '$(azureSubscription)'
              scriptType: 'bash'
              scriptLocation: 'scriptPath'
              scriptPath: '$(scriptsPath)/deploy-edge-manifests.sh'
              arguments: 'dev $(Build.BuildId)'
              useGlobalConfig: true
              addSpnToEnvironment: false
            displayName: 'Deploy layered edge deployments to dev-* devices'

  - deployment: deployAKS
    displayName: 'Deploy to AKS'
    dependsOn: deployInfra
    pool:
      vmImage: 'ubuntu-latest'
    environment: 'dev'
    strategy:
      runOnce:
        deploy:
          steps:
          - task: AzureCLI@2
            inputs:
              azureSubscription: '$(azureSubscription)'
              scriptType: 'bash'
              scriptLocation: 'inline'
              inlineScript: |
                az aks get-credentials --resource-group dev-iot-rg --name $(devAksCluster)
                kubectl apply -f manifests/dev/ --recursive
                kubectl set image deployment/timeseries-analyzer \
                  timeseries-analyzer=$(acrName).azurecr.io/analytics/timeseries-analyzer:$(Build.BuildId)
                kubectl set image deployment/anomaly-detector \
                  anomaly-detector=$(acrName).azurecr.io/analytics/anomaly-detector:$(Build.BuildId)
                kubectl set image deployment/predictive-model \
                  predictive-model=$(acrName).azurecr.io/analytics/predictive-model:$(Build.BuildId)
              useGlobalConfig: true
              addSpnToEnvironment: false
            displayName: 'Deploy analytics workloads to AKS'

# ==================== INTEGRATION TEST STAGE ====================
- stage: IntegrationTest
  displayName: 'Integration Testing'
  dependsOn: DeployDev
  condition: succeeded()
  jobs:
  - job: deviceScenarios
    displayName: 'Test Device Scenarios'
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - task: AzureCLI@2
      inputs:
        azureSubscription: '$(azureSubscription)'
        scriptType: 'bash'
        scriptLocation: 'scriptPath'
        scriptPath: '$(scriptsPath)/device-scenario-tests.sh'
        arguments: '$(testDeviceCount) dev'
        useGlobalConfig: true
      displayName: 'Simulate 1000 test devices'
    
    - task: AzureCLI@2
      inputs:
        azureSubscription: '$(azureSubscription)'
        scriptType: 'bash'
        scriptLocation: 'scriptPath'
        scriptPath: '$(scriptsPath)/validate-telemetry-flow.sh'
        arguments: 'dev'
        useGlobalConfig: true
      displayName: 'Validate telemetry ingestion'
    
    - task: AzureCLI@2
      inputs:
        azureSubscription: '$(azureSubscription)'
        scriptType: 'bash'
        scriptLocation: 'scriptPath'
        scriptPath: '$(scriptsPath)/test-offline-sync.sh'
        arguments: 'dev'
        useGlobalConfig: true
      displayName: 'Test edge offline synchronization'

# ==================== CANARY DEPLOY STAGE ====================
- stage: CanaryDeploy
  displayName: 'Canary Deployment to Staging'
  dependsOn: IntegrationTest
  condition: succeeded()
  jobs:
  - deployment: deployCanary
    displayName: 'Deploy Canary'
    pool:
      vmImage: 'ubuntu-latest'
    environment: 'staging-canary'
    strategy:
      runOnce:
        deploy:
          steps:
          - task: AzureCLI@2
            inputs:
              azureSubscription: '$(azureSubscription)'
              scriptType: 'bash'
              scriptLocation: 'scriptPath'
              scriptPath: '$(scriptsPath)/deploy-canary.sh'
              arguments: 'staging $(Build.BuildId) $(canaryTrafficSplit)'
              useGlobalConfig: true
              addSpnToEnvironment: false
            displayName: 'Deploy canary with 90/10 traffic split'
          
          - task: HelmDeploy@0
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscription: '$(azureSubscription)'
              azureResourceGroup: '$(stagingResourceGroup)'
              kubernetesCluster: '$(stagingAksCluster)'
              command: 'upgrade'
              chartType: 'FilePath'
              chartPath: 'charts/flagger'
              releaseName: 'flagger'
              arguments: '--set canary.enabled=true --set canary.weight=$(canaryTrafficSplit)'
            displayName: 'Configure Flagger for progressive delivery'

  - job: monitorCanary
    displayName: 'Monitor Canary Metrics'
    dependsOn: deployCanary
    pool:
      vmImage: 'ubuntu-latest'
    timeoutInMinutes: 35
    steps:
    - task: AzureCLI@2
      inputs:
        azureSubscription: '$(azureSubscription)'
        scriptType: 'bash'
        scriptLocation: 'scriptPath'
        scriptPath: '$(scriptsPath)/monitor-canary.sh'
        arguments: 'staging $(errorRateThreshold) 30'
        useGlobalConfig: true
      displayName: 'Monitor canary for 30 minutes'
    
    - task: AzureCLI@2
      condition: failed()
      inputs:
        azureSubscription: '$(azureSubscription)'
        scriptType: 'bash'
        scriptLocation: 'scriptPath'
        scriptPath: '$(scriptsPath)/rollback-canary.sh'
        arguments: 'staging'
        useGlobalConfig: true
      displayName: 'Rollback canary on failure'

# ==================== STAGING DEPLOY STAGE ====================
- stage: StagingDeploy
  displayName: 'Full Staging Deployment'
  dependsOn: CanaryDeploy
  condition: succeeded()
  jobs:
  - deployment: promoteCanary
    displayName: 'Promote Canary to Full Staging'
    pool:
      vmImage: 'ubuntu-latest'
    environment: 'staging'
    strategy:
      runOnce:
        deploy:
          steps:
          - task: AzureCLI@2
            inputs:
              azureSubscription: '$(azureSubscription)'
              scriptType: 'bash'
              scriptLocation: 'scriptPath'
              scriptPath: '$(scriptsPath)/promote-canary.sh'
              arguments: 'staging'
              useGlobalConfig: true
              addSpnToEnvironment: false
            displayName: 'Promote traffic to 100% canary'

  - job: stagingE2ETests
    displayName: 'Staging E2E Tests'
    dependsOn: promoteCanary
    pool:
      name: 'Staging-Testing-Pool'
      vmImage: 'Standard_D8s_v3'
    steps:
    - task: AzureCLI@2
      inputs:
        azureSubscription: '$(azureSubscription)'
        scriptType: 'bash'
        scriptLocation: 'scriptPath'
        scriptPath: '$(scriptsPath)/staging-e2e-tests.sh'
        arguments: '10000 staging'
        useGlobalConfig: true
      displayName: 'Run E2E tests with 10k devices'
    
    - task: AzureCLI@2
      inputs:
        azureSubscription: '$(azureSubscription)'
        scriptType: 'bash'
        scriptLocation: 'scriptPath'
        scriptPath: '$(scriptsPath)/disaster-recovery-test.sh'
        arguments: 'staging'
        useGlobalConfig: true
      displayName: 'Test failover and disaster recovery'

# ==================== PRODUCTION APPROVAL STAGE ====================
- stage: ProductionApproval
  displayName: 'Production Deployment Approval'
  dependsOn: StagingDeploy
  condition: succeeded()
  jobs:
  - job: waitForApprovals
    displayName: 'Wait for Approvals'
    pool: server
    timeoutInMinutes: 4320  # 72 hours
    steps:
    - task: ManualValidation@0
      timeoutInMinutes: 4320
      inputs:
        notifyUsers: 'security-team@company.com'
        instructions: 'Security team approval required for production deployment. Please review security scan results and validate compliance.'
      displayName: 'Security Team Approval'
    
    - task: ManualValidation@0
      timeoutInMinutes: 4320
      inputs:
        notifyUsers: 'iot-ops@company.com'
        instructions: 'IoT Operations team approval required. Please review staging test results and confirm production readiness.'
      displayName: 'IoT Operations Team Approval'

# ==================== DEPLOY PRODUCTION STAGE ====================
- stage: DeployProduction
  displayName: 'Deploy to Production'
  dependsOn: ProductionApproval
  condition: succeeded()
  jobs:
  - deployment: deployProductionRegions
    displayName: 'Sequential Regional Deployment'
    pool:
      vmImage: 'ubuntu-latest'
    environment: 'production'
    timeoutInMinutes: 180  # 3 hours for multi-region deployment
    cancelTimeoutInMinutes: 10  # Allow time for cleanup on cancellation
    strategy:
      runOnce:
        preDeploy:
          steps:
          - task: AzureCLI@2
            inputs:
              azureSubscription: '$(azureSubscription)'
              scriptType: 'bash'
              scriptLocation: 'scriptPath'
              scriptPath: '$(scriptsPath)/pre-deploy-checks.sh'
              arguments: 'production'
              useGlobalConfig: true
              addSpnToEnvironment: false
            displayName: 'Pre-deployment health checks'
            retryCountOnTaskFailure: 2
        
        deploy:
          steps:
          - script: |
              # Set variables for proper substitution
              PROD_REGIONS="$(prodAksRegions)"
              BUILD_ID="$(Build.BuildId)"
              SCRIPTS_PATH="$(scriptsPath)"
              PROD_RG_PREFIX="$(prodResourceGroupPrefix)"

              IFS=',' read -ra REGIONS <<< "${PROD_REGIONS}"
              for region in "${REGIONS[@]}"; do
                echo "##[group]Deploying to region: ${region}"

                # Deploy infrastructure with proper variable expansion
                az deployment group create \
                  --resource-group "${PROD_RG_PREFIX}-${region}-rg" \
                  --template-file templates/production/main.bicep \
                  --parameters region="${region}" buildId="${BUILD_ID}"

                # Deploy IoT Hub
                bash "${SCRIPTS_PATH}/deploy-iot-hub.sh" production "${region}" "${BUILD_ID}"

                # Deploy Event Hubs
                bash "${SCRIPTS_PATH}/deploy-event-hubs.sh" production "${region}"

                # Deploy AKS
                bash "${SCRIPTS_PATH}/deploy-aks.sh" production "${region}" "${BUILD_ID}"

                # Configure Cosmos DB
                bash "${SCRIPTS_PATH}/configure-cosmos.sh" production "${region}"

                echo "##[endgroup]"

                # Validate deployment before proceeding to next region
                bash "${SCRIPTS_PATH}/validate-region-deployment.sh" production "${region}"

                sleep 60  # Brief pause between regions
              done
            displayName: 'Deploy to all production regions'
            retryCountOnTaskFailure: 2
          
          - task: AzureCLI@2
            inputs:
              azureSubscription: '$(azureSubscription)'
              scriptType: 'bash'
              scriptLocation: 'scriptPath'
              scriptPath: '$(scriptsPath)/configure-traffic-manager.sh'
              arguments: 'production $(prodAksRegions)'
              useGlobalConfig: true
              addSpnToEnvironment: false
            displayName: 'Configure Traffic Manager for global routing'
            retryCountOnTaskFailure: 2
        
        routeTraffic:
          steps:
          - task: AzureCLI@2
            inputs:
              azureSubscription: '$(azureSubscription)'
              scriptType: 'bash'
              scriptLocation: 'scriptPath'
              scriptPath: '$(scriptsPath)/route-traffic.sh'
              arguments: 'production gradual'
              useGlobalConfig: true
              addSpnToEnvironment: false
            displayName: 'Gradually route traffic to new deployment'
            retryCountOnTaskFailure: 2
        
        postRouteTraffic:
          steps:
          - task: AzureCLI@2
            inputs:
              azureSubscription: '$(azureSubscription)'
              scriptType: 'bash'
              scriptLocation: 'scriptPath'
              scriptPath: '$(scriptsPath)/post-deploy-validation.sh'
              arguments: 'production'
              useGlobalConfig: true
              addSpnToEnvironment: false
            displayName: 'Post-deployment validation'

# ==================== MONITORING STAGE ====================
- stage: Monitoring
  displayName: 'Configure Monitoring'
  dependsOn: DeployProduction
  condition: succeeded()
  jobs:
  - job: setupMonitoring
    displayName: 'Setup Monitoring and Alerts'
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - task: AzureCLI@2
      inputs:
        azureSubscription: '$(azureSubscription)'
        scriptType: 'bash'
        scriptLocation: 'scriptPath'
        scriptPath: '$(scriptsPath)/setup-monitoring.sh'
        arguments: 'production'
        useGlobalConfig: true
      displayName: 'Configure Application Insights and Log Analytics'
    
    - task: AzureCLI@2
      inputs:
        azureSubscription: '$(azureSubscription)'
        scriptType: 'bash'
        scriptLocation: 'scriptPath'
        scriptPath: '$(scriptsPath)/create-alerts.sh'
        arguments: 'production'
        useGlobalConfig: true
      displayName: 'Create Azure Monitor alerts'
    
    - task: AzureCLI@2
      inputs:
        azureSubscription: '$(azureSubscription)'
        scriptType: 'bash'
        scriptLocation: 'scriptPath'
        scriptPath: '$(scriptsPath)/create-dashboards.sh'
        arguments: 'production'
        useGlobalConfig: true
      displayName: 'Create monitoring dashboards'
    
    - task: PowerShell@2
      inputs:
        targetType: 'inline'
        script: |
          $webhookUrl = "$(teamsWebhookUrl)"
          $body = @{
            "@type" = "MessageCard"
            "@context" = "https://schema.org/extensions"
            "summary" = "IoT Platform Deployment Complete"
            "title" = "Production Deployment Successful"
            "sections" = @(
              @{
                "activityTitle" = "Build $(Build.BuildId)"
                "facts" = @(
                  @{ "name" = "Environment"; "value" = "Production" }
                  @{ "name" = "Regions"; "value" = "$(prodAksRegions)" }
                  @{ "name" = "Status"; "value" = "Deployed" }
                )
              }
            )
          } | ConvertTo-Json -Depth 10
          
          Invoke-RestMethod -Uri $webhookUrl -Method Post -Body $body -ContentType "application/json"
      displayName: 'Send notification to Teams'
    
    - task: PowerShell@2
      inputs:
        targetType: 'inline'
        script: |
          bash $(scriptsPath)/notify-pagerduty.sh "deployment" "success" "$(Build.BuildId)"
      displayName: 'Send notification to PagerDuty'

# ==================== ROLLBACK STAGE ====================
# This stage can be triggered in two ways:
# 1. Automatically when DeployProduction stage fails
# 2. Manually by setting the TRIGGER_ROLLBACK variable to 'true' when queuing the pipeline
- stage: Rollback
  displayName: 'Rollback Production'
  dependsOn: DeployProduction
  condition: or(failed(), eq(variables['TRIGGER_ROLLBACK'], 'true'))
  jobs:
  - deployment: rollbackProduction
    displayName: 'Rollback to Previous Version'
    pool:
      vmImage: 'ubuntu-latest'
    environment: 'production-rollback'
    timeoutInMinutes: 90  # Extended timeout for rollback operations
    cancelTimeoutInMinutes: 10  # Allow cleanup time
    strategy:
      runOnce:
        deploy:
          steps:
          - task: AzureCLI@2
            inputs:
              azureSubscription: '$(azureSubscription)'
              scriptType: 'bash'
              scriptLocation: 'scriptPath'
              scriptPath: '$(scriptsPath)/rollback-iot.sh'
              arguments: 'production'
              useGlobalConfig: true
              addSpnToEnvironment: false
            displayName: 'Rollback IoT Hub edge deployments'
            retryCountOnTaskFailure: 2

          - task: AzureCLI@2
            inputs:
              azureSubscription: '$(azureSubscription)'
              scriptType: 'bash'
              scriptLocation: 'scriptPath'
              scriptPath: '$(scriptsPath)/rollback-functions.sh'
              arguments: 'production'
              useGlobalConfig: true
              addSpnToEnvironment: false
            displayName: 'Rollback Azure Functions'
            retryCountOnTaskFailure: 2

          - task: AzureCLI@2
            inputs:
              azureSubscription: '$(azureSubscription)'
              scriptType: 'bash'
              scriptLocation: 'scriptPath'
              scriptPath: '$(scriptsPath)/rollback-traffic-manager.sh'
              arguments: 'production'
              useGlobalConfig: true
              addSpnToEnvironment: false
            displayName: 'Revert Traffic Manager configuration'
            retryCountOnTaskFailure: 2
          
          - task: AzureCLI@2
            inputs:
              azureSubscription: '$(azureSubscription)'
              scriptType: 'bash'
              scriptLocation: 'inline'
              inlineScript: |
                # Set variables for proper substitution
                PROD_GLOBAL_RG="$(prodGlobalResourceGroup)"
                CDN_PROFILE="$(cdnProfileName)"
                CDN_ENDPOINT="$(cdnEndpointName)"
                PROD_REGIONS="$(prodAksRegions)"
                PROD_RG_PREFIX="$(prodResourceGroupPrefix)"

                # Clear CDN caches
                az cdn endpoint purge \
                  --resource-group "${PROD_GLOBAL_RG}" \
                  --profile-name "${CDN_PROFILE}" \
                  --name "${CDN_ENDPOINT}" \
                  --content-paths "/*"

                # Clear Redis caches without service interruption
                # Using FLUSHALL instead of force-reboot to avoid availability impact
                IFS=',' read -ra REGIONS <<< "${PROD_REGIONS}"
                for region in "${REGIONS[@]}"; do
                  echo "Flushing Redis cache in region: ${region}"

                  # Get Redis connection details and flush cache
                  REDIS_KEY=$(az redis list-keys \
                    --resource-group "${PROD_RG_PREFIX}-${region}-rg" \
                    --name "iot-redis-${region}" \
                    --query primaryKey -o tsv)

                  REDIS_HOST=$(az redis show \
                    --resource-group "${PROD_RG_PREFIX}-${region}-rg" \
                    --name "iot-redis-${region}" \
                    --query hostName -o tsv)

                  # Use redis-cli to flush cache without reboot
                  redis-cli -h "${REDIS_HOST}" -a "${REDIS_KEY}" --tls FLUSHALL
                  echo "Cache flushed for region: ${region}"
                done
              useGlobalConfig: true
              addSpnToEnvironment: false
            displayName: 'Clear caches'
            retryCountOnTaskFailure: 1
          
          - task: PowerShell@2
            inputs:
              targetType: 'inline'
              script: |
                bash $(scriptsPath)/notify-rollback.sh "production" "$(Build.BuildId)"
            displayName: 'Send rollback notifications'