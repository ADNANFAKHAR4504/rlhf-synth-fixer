You are an expert AWS Cloud Architect and DevOps engineer.

* First, read the documentation of this project (ignore files in archive/ folder)
* Read package.json and Pipfile to understand the commands available.
* You are given a problem described in lib/PROMPT.md.
* Is proven that the response from that LLM has not passed the QA pipeline.
* You will find inside metadata.json file the platform and language that you will need to use to solve the problem.
* None of the resources to be created can have a Retain policy. As they are going to be destroyed at the end of the QA pipeline.
* our QA pipeline involes: (Check the package.json and the Pipfile to know which commands to run)
* Build inside /lib the necessary infrastructure as code to solve the problem described in lib/PROMPT.md.
  * If the infrastructure is already there, skip this step and validate that it passes the QA pipeline.
*  The QA pipeline:
  1. lint - Fix until it passes. Check in package.json and PipFile the necessary commands to lint each platform+language
    * If platform is cfn, you will need to run the cfn lint command, check Pipfile for the cfn-lint commands
  2. build - Fix until it passes
  3. synth - Only when needed (platforms: cdk, tf, pulumi), fix until it passes.
  4. deploy
    * Deploy the resources
    * Remember that the goal is to generate infrastructure that best fits the problem described in lib/PROMPT.md.
    * If you have to deviate from the problem, document it in lib/IDEAL_RESPONSE.md.
    * Get the outputs from the deployment, as you will need them for the integration tests. Store them in cfn-outputs/flat-outputs.json.
  5. Write unit tests for testing the code in lib/, you will find the placeholder files inside test/ folder.
    * If its a json file, you will need to write a test that validates the json file.
    * If its a yaml file, you will need to run pipenv run `pipenv run cfn-flip-to-json` to convert the yaml file to json and then write a test that validates the json file.
  6. run unit tests: npm run test:unit. and fix it until it passes and also passes the coverage.
  7. Write integration tests for testing the code in lib/ inside the file in test/ folder.
    * Do not mock the responses, is cfn-outputs are missing, let the tests fail.
    * You will need to collect the outputs from aws. Check the .github/workflows/ci-cd.yml file to see how to collect the outputs.
    * If the outputs are not available, ignore this step until the deployment pipeline has passed.
    * Your integration tests should not only assert that the resources were created, but also that any end-to-end workflows are working as expected.
  8. Run integration tests: npm run test:integration. And fix it until it passes.
    * Use the outputs from the deploy step to test the integration tests. If the outputs are not available, stop processing here and commit to the PR.
    * The integration tests should be able to validate the e2e workflow of the application.
    * To fix the problems in the integration tests, read the aws documentation for the resources involved to address problems.
  9. Run build, lint, unit tests, and integrations tests until everything passes.
  10. Once integration tests have passed, you will need to fill the file lib/IDEAL_RESPONSE.md.
    * For this task, you will need to answer as if you were the LLM, but with the knowledge that you have gone through the QA pipeline and fixed all the issues.
    * Just provide the ideal response as if you were the LLM asked to solve the problem.
    * Provide all the file structure and file_names that were created or modified.
    * Every inserted code, should be prepended by its relative path in the project.
  11. Double check that the lib/IDEAL_RESPONSE.md is solving the problem described in lib/PROMPT.md and its coherent with the Infrastructure as code.
    * If it is not, you will to start the process again from step 1, but taking into account what you have learned.
  12. Run markdownlint on the md files inside lib/ folder to ensure that they are following the markdown style guide.
  13. If lib/MODEL_RESPONSE is present, Compare lib/MODEL_RESPONSE.md with lib/IDEAL_RESPONSE.md, and highlight in MODEL_FAILURES.md the differences between the two files and why the IDEAL_RESPONSE.md solves the problem better.
    * Dont mention the differences on Retain Policies.
  14. Store in metadata.json the field `subtask`, which should be the category of the problem: (IaC Program Optimization| Infrastructure Migration | etc...), and the field subject_labels (e.g: "General Infrastructure Tooling QA", "IaC Optimization", "Web Application Deployment", etc...)
  15. Update metadata.json. set testDependencies as a list of dependencies and versions to run the unit tests and integration tests.
  16. Destroy all resources created in the QA pipeline.
    * If you have created any resources that are not needed for the deployment, you will need to destroy them as well.
    * If you have created any resources that are needed for the deployment, you will need to destroy them as well.
    * If you have created any resources that are not needed for the deployment, you will need to destroy them as well.
    * If you have created any resources that are needed for the deployment, you will need to destroy them as well.

Considerations:
* If the deployment needs to be done in a specific region, that region will be stored in the file lib/AWS_REGION as a single line text file.
* You can try to pass the QA pipeline up to 4 deployments, if you fail to pass the QA pipeline after 4 deployments, you will need to ask for help.
* After you have finished, disregard if you have succeeded or not, destroy the resources created in the QA pipeline.
* Reproducibility is key, so every step should be documented in the IDEAL_RESPONSE.md file.
  * If commands need to be run (specially for AWS CLI), they should be documented in the IDEAL_RESPONSE.md file.
* Every time you make changes in the code, you will need to run the lint, build, synth, and unit tests steps again.
* You will need to run the tests after each step to ensure that everything is working as expected.
* If you find any issues in the code, you will need to fix them before proceeding to the next step.
* You will need to read the latest documentation for the resources involved to get the best practices. Very useful as you might not be updated with the latest features from AWS.
* For integration tests, you will need to collect the outputs from the stack in AWS, and all its children. Generally, parent stack is called `TapStack${{ env.ENVIRONMENT_SUFFIX }}`
* The ENVIRONMENT_SUFFIX is `format('pr{0}', github.event.number)` if the PR number is available, otherwise it is `dev`.
* Every resource created should be destroyed at the end of the QA pipeline. Do not use Retain policy.
* If the prompt requires to deploy a resource in a specific region, you will need to specify it in the code, not in the command line. as default region is us-east-1.
* If you need feedback or you are stuck, dont hesitate to ask for help to the reviewer in github PR comments.
* If its a cfn template, keep all the resources in the same file, do not split them into multiple files.
* If you create s3 buckets, request the reviewer to empty the bucket before destroying the stack, as it will fail if the bucket is not empty.
* If you need to create resources that are needed for deployment, add the necessary commands in a .sh file and commit it to the lib/ folder. Request the reviewer to run it before deploying the stack.
* If you need auxiliar files, such as bash commands, create them in the lib/ folder, and document them in the IDEAL_RESPONSE.md file.
* If you need to run run aws cli commands that are not part of the QA pipeline, ask the reviewer to do them and give you feedback.
* IDEAL_RESPONSE.md should not reference other .md files or the process of creating the response. It should be a standalone document that describes the solution to the problem.
* IMPORTANT: Your highest priority is that IDEAL_RESPONSE.md is the perfect response to the problem described in lib/PROMPT.md, and that it is coherent with the Infrastructure as code created in the lib/ folder.