import pytest
from aws_cdk import App, Stack
from aws_cdk.assertions import Template, Match

# Assuming your TapStack is in a file named 'lib/tap_stack.py'
# You might need to adjust this import path based on your project structure
from lib.tap_stack import TapStack, TapStackProps

@pytest.fixture
def app():
    """Fixture to provide a CDK App instance for testing."""
    return App()

@pytest.fixture
def default_stack(app):
    """Fixture to provide a default TapStack instance for testing."""
    return TapStack(app, "TapStackTest")

@pytest.fixture
def qa_stack(app):
    """Fixture to provide a TapStack instance with 'qa' environment suffix."""
    return TapStack(app, "TapStackQaTest", props=TapStackProps(environment_suffix="qa"))

@pytest.fixture
def prod_stack(app):
    """Fixture to provide a TapStack instance with 'prod' environment suffix."""
    return TapStack(app, "TapStackProdTest", props=TapStackProps(environment_suffix="prod"))

class TestTapStack:
  """
  Unit tests for the TapStack CDK construct.
  These tests verify the CloudFormation template generated by the stack.
  """

  def test_defaults_env_suffix_to_dev(self, default_stack):
    """Test that the environment suffix defaults to 'dev'."""
    template = Template.from_stack(default_stack)
    # Check for a resource that uses the resource_name helper, like the S3 bucket name
    template.has_resource_properties("AWS::S3::Bucket", {
        "BucketName": "tap-dev-bucket"
    })

  def test_creates_s3_bucket_with_env_suffix(self, qa_stack):
    """Test S3 bucket creation with the specified environment suffix."""
    template = Template.from_stack(qa_stack)
    template.resource_count_is("AWS::S3::Bucket", 1)
    template.has_resource_properties("AWS::S3::Bucket", {
        "BucketName": "tap-qa-bucket",
        "VersioningConfiguration": Match.absent(), # Versioning is False
        # PublicAccessBlockConfiguration might not be explicitly present if it's the default
        # due to public_read_access=False, so we remove the explicit check here.
    })
    # Check removal policy
    template.has_resource("AWS::S3::Bucket", {
        "DeletionPolicy": "Delete",
        "UpdateReplacePolicy": "Delete"
    })

  def test_creates_dynamodb_table(self, qa_stack):
    """Test DynamoDB table creation with correct partition key and billing mode."""
    template = Template.from_stack(qa_stack)
    template.resource_count_is("AWS::DynamoDB::Table", 1)
    template.has_resource_properties("AWS::DynamoDB::Table", {
        "TableName": "tap-qa-table",
        "KeySchema": [{
            "AttributeName": "id",
            "KeyType": "HASH"
        }],
        "AttributeDefinitions": [{
            "AttributeName": "id",
            "AttributeType": "S"
        }],
        "BillingMode": "PAY_PER_REQUEST" # Corrected: Expect PAY_PER_REQUEST
    })
    # Check removal policy
    template.has_resource("AWS::DynamoDB::Table", {
        "DeletionPolicy": "Delete",
        "UpdateReplacePolicy": "Delete"
    })

  def test_creates_lambda_function_with_env(self, qa_stack):
    """Test Lambda function creation with correct environment variables."""
    template = Template.from_stack(qa_stack)
    # Corrected: Expect 3 Lambda functions (1 main + 2 custom resources for S3 event source)
    template.resource_count_is("AWS::Lambda::Function", 3)
    template.has_resource_properties("AWS::Lambda::Function", {
        "FunctionName": "tap-qa-lambda",
        "Runtime": "python3.11",
        "Handler": "index.handler",
        "Environment": {
            "Variables": {
                "TABLE_NAME": Match.any_value(), # Value is a Ref, so use Match.any_value()
                "BUCKET_NAME": Match.any_value() # Value is a Ref, so use Match.any_value()
            }
        }
    })

  def test_lambda_has_permissions(self, qa_stack):
    """Test that the Lambda function has correct IAM permissions."""
    template = Template.from_stack(qa_stack)

    # Find the logical ID of the AppLambda's role
    # This assumes a consistent naming convention for the Lambda's service role
    lambda_role_logical_id_match = template.find_resources("AWS::IAM::Role", {
        "Properties": {
            "Tags": Match.array_with([
                Match.object_like({"Key": "aws-cdk:auto-delete-objects", "Value": "true"}),
                Match.object_like({"Key": "aws-cdk:auto-delete-objects-handler", "Value": "true"})
            ]),
            "Description": Match.string_like_regexp("Service role for .*AppLambda.*")
        }
    })
    # Fallback if the above match is too specific, try to find the role by its assumed role policy
    if not lambda_role_logical_id_match:
        lambda_role_logical_id_match = template.find_resources("AWS::IAM::Role", {
            "Properties": {
                "AssumeRolePolicyDocument": {
                    "Statement": Match.array_with([
                        Match.object_like({
                            "Action": "sts:AssumeRole",
                            "Effect": "Allow",
                            "Principal": {"Service": "lambda.amazonaws.com"}
                        })
                    ])
                }
            }
        })

    # Filter for the specific role associated with AppLambda, not the custom resource handlers
    app_lambda_role_logical_id = None
    for logical_id, resource in lambda_role_logical_id_match.items():
        # Check if this role is referenced by the AppLambda function
        if "AppLambda" in template.to_json()["Resources"][logical_id]["Properties"].get("Tags", {}): # This is a heuristic, better to check Lambda Function's Role property
            app_lambda_role_logical_id = logical_id
            break
    
    # A more robust way to get the AppLambda's role logical ID:
    # Find the AppLambda function itself
    app_lambda_resource = template.find_resources("AWS::Lambda::Function", {
        "Properties": {
            "FunctionName": "tap-qa-lambda"
        }
    })
    if app_lambda_resource:
        app_lambda_logical_id = list(app_lambda_resource.keys())[0]
        app_lambda_role_ref = template.to_json()["Resources"][app_lambda_logical_id]["Properties"]["Role"]
        if isinstance(app_lambda_role_ref, dict) and "Fn::GetAtt" in app_lambda_role_ref:
            app_lambda_role_logical_id = app_lambda_role_ref["Fn::GetAtt"][0]
        elif isinstance(app_lambda_role_ref, dict) and "Ref" in app_lambda_role_ref:
            app_lambda_role_logical_id = app_lambda_role_ref["Ref"]

    assert app_lambda_role_logical_id, "Could not find the logical ID for AppLambda's role."
    lambda_role_ref = {"Ref": app_lambda_role_logical_id}

    # Check for DynamoDB read/write permissions
    template.has_resource_properties("AWS::IAM::Policy", {
        "PolicyDocument": {
            "Statement": Match.array_with([
                Match.object_like({
                    "Action": Match.array_with(["dynamodb:BatchGetItem", "dynamodb:GetRecords", "dynamodb:GetShardIterator", "dynamodb:Query", "dynamodb:GetItem", "dynamodb:Scan", "dynamodb:BatchWriteItem", "dynamodb:PutItem", "dynamodb:UpdateItem", "dynamodb:DeleteItem"]),
                    "Effect": "Allow",
                    "Resource": Match.array_with([
                        Match.object_like({"Fn::GetAtt": [Match.string_like_regexp("AppTable.*"), "Arn"]}), # Table ARN
                        # The /index/* part is only present if Global Secondary Indexes are defined,
                        # which is not the case in the current stack.
                        # Match.object_like({"Fn::Join": ["", [Match.object_like({"Fn::GetAtt": [Match.string_like_regexp("AppTable.*"), "Arn"]}), "/index/*"]]})
                    ])
                })
            ])
        },
        "PolicyName": Match.string_like_regexp("AppLambdaServiceRoleDefaultPolicy.*"),
        "Roles": Match.array_with([lambda_role_ref]) # Ensure this policy is attached to the AppLambda's role
    })

    # Check for S3 read/write permissions
    template.has_resource_properties("AWS::IAM::Policy", {
        "PolicyDocument": {
            "Statement": Match.array_with([
                Match.object_like({
                    "Action": Match.array_with(["s3:GetObject*", "s3:GetBucket*", "s3:List*", "s3:DeleteObject*", "s3:PutObject*", "s3:AbortMultipartUpload"]),
                    "Effect": "Allow",
                    "Resource": Match.array_with([
                        Match.object_like({"Fn::GetAtt": [Match.string_like_regexp("AppBucket.*"), "Arn"]}), # Bucket ARN
                        Match.object_like({"Fn::Join": ["", [Match.object_like({"Fn::GetAtt": [Match.string_like_regexp("AppBucket.*"), "Arn"]}), "/*"]]}) # Objects ARN
                    ])
                })
            ])
        },
        "PolicyName": Match.string_like_regexp("AppLambdaServiceRoleDefaultPolicy.*"),
        "Roles": Match.array_with([lambda_role_ref]) # Ensure this policy is attached to the AppLambda's role
    })

  def test_s3_event_source_mapping(self, default_stack):
    """
    Test that S3 is set as an event source for the Lambda function.
    For S3, this means checking the S3 Bucket Notification Configuration
    and the Lambda Permission that allows S3 to invoke the function.
    """
    template = Template.from_stack(default_stack)

    # Check for the S3 Bucket Notification Configuration
    # Using Match.objectLike for the bucket properties to allow for other properties
    # while specifically checking the NotificationConfiguration.
    template.has_resource_properties("AWS::S3::Bucket", {
        "NotificationConfiguration": {
            "LambdaConfigurations": [
                {
                    "Event": "s3:ObjectCreated:*",
                    "Function": Match.object_like({"Fn::GetAtt": [Match.any_value(), "Arn"]})
                }
            ]
        }
    })

    # Check for the Lambda Permission allowing S3 to invoke the function
    template.has_resource_properties("AWS::Lambda::Permission", {
        "Action": "lambda:InvokeFunction",
        "FunctionName": Match.object_like({"Fn::GetAtt": [Match.any_value(), "Arn"]}),
        "Principal": "s3.amazonaws.com",
        "SourceAccount": Match.object_like({"Ref": "AWS::AccountId"}),
        "SourceArn": Match.object_like({"Fn::GetAtt": [Match.any_value(), "Arn"]})
    })

  def test_stack_outputs(self, prod_stack):
    """Test that CloudFormation outputs are defined for resources."""
    template = Template.from_stack(prod_stack)

    # S3 Bucket Output
    template.has_output("S3BucketName", {
        "Export": {
            "Name": "tap-prod-bucket-name"
        },
        "Value": Match.any_value() # Value will be a Ref, not a literal string
    })

    # DynamoDB Table Output
    template.has_output("DynamoDBTableName", {
        "Export": {
            "Name": "tap-prod-table-name"
        },
        "Value": Match.any_value() # Value will be a Ref
    })

    # Lambda Function Output
    template.has_output("LambdaFunctionName", {
        "Export": {
            "Name": "tap-prod-lambda-name"
        },
        "Value": Match.any_value() # Value will be a Ref
    })

    # Lambda Role ARN Output
    template.has_output("LambdaRoleArn", {
        "Export": {
            "Name": "tap-prod-lambda-role-arn"
        },
        "Value": Match.any_value() # Value will be a Ref
    })
