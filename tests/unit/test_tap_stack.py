import pytest
from aws_cdk import App
from aws_cdk.assertions import Template, Match

# Assuming your TapStack is in a file named 'lib/tap_stack.py'
# You might need to adjust this import path based on your project structure
from lib.tap_stack import TapStack, TapStackProps

@pytest.fixture
def app_fixture():
  """Fixture to provide a CDK App instance for testing."""
  return App()

@pytest.fixture
def default_stack_fixture(app_fixture):
  """Fixture to provide a default TapStack instance for testing."""
  return TapStack(app_fixture, "TapStackTest")

@pytest.fixture
def qa_stack_fixture(app_fixture):
  """Fixture to provide a TapStack instance with 'qa' environment suffix."""
  return TapStack(app_fixture, "TapStackQaTest",
                  props=TapStackProps(environment_suffix="qa"))

@pytest.fixture
def prod_stack_fixture(app_fixture):
  """Fixture to provide a TapStack instance with 'prod' environment suffix."""
  return TapStack(app_fixture, "TapStackProdTest",
                  props=TapStackProps(environment_suffix="prod"))

class TestTapStack:
  """
  Unit tests for the TapStack CDK construct.
  These tests verify the CloudFormation template generated by the stack.
  """

  def test_defaults_env_suffix_to_dev(self, default_stack_fixture):
    """Test that the environment suffix defaults to 'dev'."""
    template = Template.from_stack(default_stack_fixture)
    # Check for a resource that uses the resource_name helper, like the S3 bucket name
    template.has_resource_properties("AWS::S3::Bucket", {
        "BucketName": "tap-dev-bucket"
    })
    
    # Check that auto_delete_objects is False
    # This is a custom resource, so check for its logical ID
    template.has_resource("Custom::S3AutoDeleteObjects", Match.absent())
    

  def test_creates_dynamodb_table(self, qa_stack_fixture):
    """Test DynamoDB table creation with correct partition key and billing mode."""
    template = Template.from_stack(qa_stack_fixture)
    # Expect 0 DynamoDB tables if it's completely removed from the stack
    template.resource_count_is("AWS::DynamoDB::Table", 0)


  def test_creates_lambda_function_with_env(self, qa_stack_fixture):
    """Test Lambda function creation with correct environment variables."""
    template = Template.from_stack(qa_stack_fixture)
    # Corrected: Expect 3 Lambda functions (1 main + 1 custom resource for S3 event source
    # + 1 custom resource for CloudWatch Log Retention)
    template.resource_count_is("AWS::Lambda::Function", 3)
    template.has_resource_properties("AWS::Lambda::Function", {
        "FunctionName": "tap-qa-lambda",
        "Runtime": "python3.11", # Keep as string, as it's a string in CFN
        "Handler": "index.handler",
        "Environment": {
            "Variables": {
                "BUCKET_NAME": Match.any_value(), # Value is a Ref, so use Match.any_value()
            }
        }
    })

  def test_lambda_has_permissions(self, qa_stack_fixture):
    """Test that the Lambda function has correct IAM permissions."""
    template = Template.from_stack(qa_stack_fixture)

    # Find the AppLambda function resource in the template
    app_lambda_resources = template.find_resources("AWS::Lambda::Function", {
        "Properties": {
            "FunctionName": "tap-qa-lambda"
        }
    })
    assert len(app_lambda_resources) == 1, "Expected exactly one AppLambda function."
    app_lambda_logical_id = list(app_lambda_resources.keys())[0]

    # Get the Ref/Fn::GetAtt to the AppLambda's role from its properties in the
    # synthesized template
    lambda_role_property_from_template = \
      template.to_json()["Resources"][app_lambda_logical_id]["Properties"]["Role"]

    # Extract the logical ID of the role from this property
    lambda_role_logical_id_in_template = None
    if isinstance(lambda_role_property_from_template, dict):
      if "Ref" in lambda_role_property_from_template:
        lambda_role_logical_id_in_template = lambda_role_property_from_template["Ref"]
      elif "Fn::GetAtt" in lambda_role_property_from_template:
        lambda_role_logical_id_in_template = \
          lambda_role_property_from_template["Fn::GetAtt"][0]

    assert lambda_role_logical_id_in_template, \
      "Could not extract logical ID of Lambda role from template."

    # Now use this extracted logical ID for the assertion
    # Use Match.object_like with a regex for the Ref value to handle dynamic logical IDs
    lambda_role_ref_matcher = \
      Match.object_like({"Ref": Match.string_like_regexp(
          f"^{lambda_role_logical_id_in_template}$")})


    # Check for S3 read/write permissions
    template.has_resource_properties("AWS::IAM::Policy", {
        "PolicyDocument": {
            "Statement": Match.array_with([
                Match.object_like({
                    "Action": Match.array_with([
                        Match.string_like_regexp("s3:GetObject.*"),
                        Match.string_like_regexp("s3:GetBucket.*"),
                        Match.string_like_regexp("s3:List.*"),
                        Match.string_like_regexp("s3:DeleteObject.*"),
                        "s3:PutObject", # Specific action
                        "s3:PutObjectLegalHold",
                        "s3:PutObjectRetention",
                        "s3:PutObjectTagging",
                        "s3:PutObjectVersionTagging",
                        "s3:Abort*" # Changed from s3:AbortMultipartUpload to s3:Abort*
                    ]),
                    "Effect": "Allow",
                    "Resource": Match.array_with([
                        Match.object_like({"Fn::GetAtt": [
                            Match.string_like_regexp("AppBucket.*"), "Arn"]}), # Bucket ARN
                        Match.object_like({"Fn::Join": ["", Match.array_with([ # Corrected Fn::Join structure
                            Match.object_like({"Fn::GetAtt": Match.array_with([
                                Match.string_like_regexp("AppBucket.*"), "Arn"])
                            }),
                            "/*"
                        ])]}) # Objects ARN
                    ])
                })
            ])
        },
        "PolicyName": Match.string_like_regexp("AppLambdaServiceRoleDefaultPolicy.*"),
        "Roles": Match.array_with([lambda_role_ref_matcher]) # Ensure this policy is attached to the AppLambda's role
    })

  def test_s3_event_source_mapping(self, default_stack_fixture):
    """
    Test that S3 is set as an event source for the Lambda function.
    For S3, this means checking the AWS::Lambda::Permission that allows S3 to invoke the function.
    """
    template = Template.from_stack(default_stack_fixture)

    # For S3 event sources, CDK creates an AWS::Lambda::Permission resource.
    # It does NOT directly add a "NotificationConfiguration" property to the S3 bucket resource.
    # Therefore, the assertion for NotificationConfiguration on AWS::S3::Bucket has been removed.

    template.has_resource_properties("AWS::Lambda::Permission", {
        "Action": "lambda:InvokeFunction",
        "FunctionName": Match.object_like({"Fn::GetAtt": [
            Match.string_like_regexp("AppLambda.*"), "Arn"]}),
        "Principal": "s3.amazonaws.com",
        "SourceAccount": Match.object_like({"Ref": "AWS::AccountId"}),
        "SourceArn": Match.object_like({"Fn::GetAtt": [
            Match.string_like_regexp("AppBucket.*"), "Arn"]})
    })

  def test_stack_outputs(self, prod_stack_fixture):
    """Test that CloudFormation outputs are defined for resources."""
    template = Template.from_stack(prod_stack_fixture)

    # S3 Bucket Output
    template.has_output("S3BucketName", {
        "Export": {
            "Name": "tap-prod-bucket-name"
        },
        "Value": Match.any_value() # Value will be a Ref, not a literal string
    })

    # Lambda Function Output
    template.has_output("LambdaFunctionName", {
        "Export": {
            "Name": "tap-prod-lambda-name"
        },
        "Value": Match.any_value() # Value will be a Ref
    })

    # Lambda Role ARN Output
    template.has_output("LambdaRoleArn", {
        "Export": {
            "Name": "tap-prod-lambda-role-arn"
        },
        "Value": Match.any_value() # Value will be a Ref
    })