import pytest
from aws_cdk import App, Stack
from aws_cdk.assertions import Template, Match

# Assuming your TapStack is in a file named 'lib/tap_stack.py'
# You might need to adjust this import path based on your project structure
from lib.tap_stack import TapStack, TapStackProps

@pytest.fixture
def app():
  """Fixture to provide a CDK App instance for testing."""
  return App()

@pytest.fixture
def default_stack(app):
  """Fixture to provide a default TapStack instance for testing."""
  return TapStack(app, "TapStackTest")

@pytest.fixture
def qa_stack(app):
  """Fixture to provide a TapStack instance with 'qa' environment suffix."""
  return TapStack(app, "TapStackQaTest", props=TapStackProps(environment_suffix="qa"))

@pytest.fixture
def prod_stack(app):
  """Fixture to provide a TapStack instance with 'prod' environment suffix."""
  return TapStack(app, "TapStackProdTest", props=TapStackProps(environment_suffix="prod"))

class TestTapStack:
  """
  Unit tests for the TapStack CDK construct.
  These tests verify the CloudFormation template generated by the stack.
  """

  def test_defaults_env_suffix_to_dev(self, default_stack):
    """Test that the environment suffix defaults to 'dev'."""
    template = Template.from_stack(default_stack)
    template.has_resource_properties("AWS::S3::Bucket", {
      "BucketName": "tap-dev-bucket"
    })

  def test_creates_s3_bucket_with_env_suffix(self, qa_stack):
    """Test S3 bucket creation with the specified environment suffix."""
    template = Template.from_stack(qa_stack)
    template.resource_count_is("AWS::S3::Bucket", 1)
    template.has_resource_properties("AWS::S3::Bucket", {
      "BucketName": "tap-qa-bucket",
      "VersioningConfiguration": Match.absent(),
      "PublicAccessBlockConfiguration": {
        "BlockPublicAcls": True,
        "BlockPublicPolicy": True,
        "IgnorePublicAcls": True,
        "RestrictPublicBuckets": True
      }
    })
    template.has_resource("AWS::S3::Bucket", {
      "DeletionPolicy": "Delete",
      "UpdateReplacePolicy": "Delete"
    })

  def test_creates_dynamodb_table(self, qa_stack):
    """Test DynamoDB table creation with correct partition key and billing mode."""
    template = Template.from_stack(qa_stack)
    template.resource_count_is("AWS::DynamoDB::Table", 1)
    template.has_resource_properties("AWS::DynamoDB::Table", {
      "TableName": "tap-qa-table",
      "KeySchema": [{
        "AttributeName": "id",
        "KeyType": "HASH"
      }],
      "AttributeDefinitions": [{
        "AttributeName": "id",
        "AttributeType": "S"
      }],
      "BillingMode": "PAY_PER_REQUEST"
    })
    template.has_resource("AWS::DynamoDB::Table", {
      "DeletionPolicy": "Delete",
      "UpdateReplacePolicy": "Delete"
    })

  def test_creates_lambda_function_with_env(self, qa_stack):
    """Test Lambda function creation with correct environment variables."""
    template = Template.from_stack(qa_stack)
    template.resource_count_is("AWS::Lambda::Function", 3)
    template.has_resource_properties("AWS::Lambda::Function", {
      "FunctionName": "tap-qa-lambda",
      "Runtime": "python3.11",
      "Handler": "index.handler",
      "Environment": {
        "Variables": {
          "TABLE_NAME": Match.any_value(),
          "BUCKET_NAME": Match.any_value()
        }
      }
    })

  def test_lambda_has_permissions(self, qa_stack):
    """Test that the Lambda function has correct IAM permissions."""
    template = Template.from_stack(qa_stack)

    template.has_resource_properties("AWS::IAM::Policy", {
      "PolicyDocument": {
        "Statement": Match.array_with([
          Match.object_like({
            "Action": Match.array_with([
              "dynamodb:BatchGetItem", "dynamodb:GetRecords", "dynamodb:GetShardIterator",
              "dynamodb:Query", "dynamodb:GetItem", "dynamodb:Scan",
              "dynamodb:BatchWriteItem", "dynamodb:PutItem",
              "dynamodb:UpdateItem", "dynamodb:DeleteItem"
            ]),
            "Effect": "Allow",
            "Resource": [
              Match.object_like({"Fn::GetAtt": [Match.any_value(), "Arn"]}),
              Match.object_like({"Fn::Join": ["", [Match.object_like({"Fn::GetAtt": [Match.any_value(), "Arn"]}), "/index/*"]]})
            ]
          })
        ])
      },
      "PolicyName": Match.string_like_regexp("AppLambdaServiceRoleDefaultPolicy.*")
    })

    template.has_resource_properties("AWS::IAM::Policy", {
      "PolicyDocument": {
        "Statement": Match.array_with([
          Match.object_like({
            "Action": Match.array_with([
              "s3:GetObject*", "s3:GetBucket*", "s3:List*",
              "s3:DeleteObject*", "s3:PutObject*", "s3:AbortMultipartUpload"
            ]),
            "Effect": "Allow",
            "Resource": Match.array_with([
              Match.object_like({"Fn::GetAtt": [Match.any_value(), "Arn"]}),
              Match.object_like({"Fn::Join": ["", [Match.object_like({"Fn::GetAtt": [Match.any_value(), "Arn"]}), "/*"]]})
            ])
          })
        ])
      },
      "PolicyName": Match.string_like_regexp("AppLambdaServiceRoleDefaultPolicy.*")
    })

  def test_s3_event_source_mapping(self, default_stack):
    """
    Test that S3 is set as an event source for the Lambda function.
    For S3, this means checking the S3 Bucket Notification Configuration
    and the Lambda Permission that allows S3 to invoke the function.
    """
    template = Template.from_stack(default_stack)

    template.has_resource_properties("AWS::S3::Bucket", {
      "NotificationConfiguration": {
        "LambdaConfigurations": [
          {
            "Event": "s3:ObjectCreated:*",
            "Function": Match.object_like({"Fn::GetAtt": [Match.any_value(), "Arn"]})
          }
        ]
      }
    })

    template.has_resource_properties("AWS::Lambda::Permission", {
      "Action": "lambda:InvokeFunction",
      "FunctionName": Match.object_like({"Fn::GetAtt": [Match.any_value(), "Arn"]}),
      "Principal": "s3.amazonaws.com",
      "SourceAccount": Match.object_like({"Ref": "AWS::AccountId"}),
      "SourceArn": Match.object_like({"Fn::GetAtt": [Match.any_value(), "Arn"]})
    })

  def test_stack_outputs(self, prod_stack):
    """Test that CloudFormation outputs are defined for resources."""
    template = Template.from_stack(prod_stack)

    template.has_output("S3BucketName", {
      "Export": {
        "Name": "tap-prod-bucket-name"
      },
      "Value": Match.any_value()
    })

    template.has_output("DynamoDBTableName", {
      "Export": {
        "Name": "tap-prod-table-name"
      },
      "Value": Match.any_value()
    })

    template.has_output("LambdaFunctionName", {
      "Export": {
        "Name": "tap-prod-lambda-name"
      },
      "Value": Match.any_value()
    })

    template.has_output("LambdaRoleArn", {
      "Export": {
        "Name": "tap-prod-lambda-role-arn"
      },
      "Value": Match.any_value()
    })
