import pytest
from aws_cdk import App, Stack
from aws_cdk.assertions import Template, Match

# Assuming your TapStack is in a file named 'lib/tap_stack.py'
# You might need to adjust this import path based on your project structure
from lib.tap_stack import TapStack, TapStackProps

@pytest.fixture
def app():
    """Fixture to provide a CDK App instance for testing."""
    return App()

@pytest.fixture
def default_stack(app):
    """Fixture to provide a default TapStack instance for testing."""
    return TapStack(app, "TapStackTest")

@pytest.fixture
def qa_stack(app):
    """Fixture to provide a TapStack instance with 'qa' environment suffix."""
    return TapStack(app, "TapStackQaTest", props=TapStackProps(environment_suffix="qa"))

@pytest.fixture
def prod_stack(app):
    """Fixture to provide a TapStack instance with 'prod' environment suffix."""
    return TapStack(app, "TapStackProdTest", props=TapStackProps(environment_suffix="prod"))

class TestTapStack:
  """
  Unit tests for the TapStack CDK construct.
  These tests verify the CloudFormation template generated by the stack.
  """

  def test_defaults_env_suffix_to_dev(self, default_stack):
    """Test that the environment suffix defaults to 'dev'."""
    template = Template.from_stack(default_stack)
    # Check for a resource that uses the resource_name helper, like the S3 bucket name
    template.has_resource_properties("AWS::S3::Bucket", {
        "BucketName": "tap-dev-bucket"
    })

  def test_creates_s3_bucket_with_env_suffix(self, qa_stack):
    """Test S3 bucket creation with the specified environment suffix."""
    template = Template.from_stack(qa_stack)
    template.resource_count_is("AWS::S3::Bucket", 1)
    template.has_resource_properties("AWS::S3::Bucket", {
        "BucketName": "tap-qa-bucket",
        "VersioningConfiguration": Match.absent(), # Versioning is False
        # PublicAccessBlockConfiguration might not be explicitly present if it's the default
        # due to public_read_access=False, so we remove the explicit check here.
    })
    # Check removal policy
    template.has_resource("AWS::S3::Bucket", {
        "DeletionPolicy": "Delete",
        "UpdateReplacePolicy": "Delete"
    })

  def test_creates_dynamodb_table(self, qa_stack):
    """Test DynamoDB table creation with correct partition key and billing mode."""
    template = Template.from_stack(qa_stack)
    template.resource_count_is("AWS::DynamoDB::Table", 1)
    template.has_resource_properties("AWS::DynamoDB::Table", {
        "TableName": "tap-qa-table",
        "KeySchema": [{
            "AttributeName": "id",
            "KeyType": "HASH"
        }],
        "AttributeDefinitions": [{
            "AttributeName": "id",
            "AttributeType": "S"
        }],
        "BillingMode": "PAY_PER_REQUEST" # Corrected: Expect PAY_PER_REQUEST
    })
    # Check removal policy
    template.has_resource("AWS::DynamoDB::Table", {
        "DeletionPolicy": "Delete",
        "UpdateReplacePolicy": "Delete"
    })

  def test_creates_lambda_function_with_env(self, qa_stack):
    """Test Lambda function creation with correct environment variables."""
    template = Template.from_stack(qa_stack)
    # Corrected: Expect 3 Lambda functions (1 main + 2 custom resources for S3 event source)
    template.resource_count_is("AWS::Lambda::Function", 3)
    template.has_resource_properties("AWS::Lambda::Function", {
        "FunctionName": "tap-qa-lambda",
        "Runtime": "python3.11",
        "Handler": "index.handler",
        "Environment": {
            "Variables": {
                "TABLE_NAME": Match.any_value(), # Value is a Ref, so use Match.any_value()
                "BUCKET_NAME": Match.any_value() # Value is a Ref, so use Match.any_value()
            }
        }
    })

  def test_lambda_has_permissions(self, qa_stack):
    """Test that the Lambda function has correct IAM permissions."""
    template = Template.from_stack(qa_stack)

    # Find the logical ID of the AppLambda's role from the synthesized template
    # This is more robust than relying on the Python object's logical_id property directly,
    # as it reflects what's actually in the CloudFormation template.
    lambda_role_resources = template.find_resources("AWS::IAM::Role", {
        "Properties": {
            "AssumeRolePolicyDocument": {
                "Statement": Match.array_with([
                    Match.object_like({
                        "Action": "sts:AssumeRole",
                        "Effect": "Allow",
                        "Principal": {"Service": "lambda.amazonaws.com"}
                    })
                ])
            },
            "Tags": Match.array_with([
                Match.object_like({"Key": "aws-cdk:function-name", "Value": "tap-qa-lambda"})
            ])
        }
    })
    assert len(lambda_role_resources) >= 1, "Expected at least one Lambda Service Role for AppLambda"
    # Get the logical ID of the specific AppLambda role
    app_lambda_role_logical_id = None
    for logical_id, resource_props in lambda_role_resources.items():
        # Heuristic to find the main lambda's role, as there might be other lambda-backed custom resource roles
        if "tap-qa-lambda" in resource_props["Properties"].get("RoleName", "") or \
           any(tag.get("Key") == "aws-cdk:function-name" and tag.get("Value") == "tap-qa-lambda" for tag in resource_props["Properties"].get("Tags", [])):
            app_lambda_role_logical_id = logical_id
            break

    assert app_lambda_role_logical_id, "Could not find the logical ID for AppLambda's role."
    lambda_role_ref_dict = {"Ref": app_lambda_role_logical_id}


    # Check for DynamoDB read/write permissions
    template.has_resource_properties("AWS::IAM::Policy", {
        "PolicyDocument": {
            "Statement": Match.array_with([
                Match.object_like({
                    "Action": Match.array_with(["dynamodb:BatchGetItem", "dynamodb:GetRecords", "dynamodb:GetShardIterator", "dynamodb:Query", "dynamodb:GetItem", "dynamodb:Scan", "dynamodb:BatchWriteItem", "dynamodb:PutItem", "dynamodb:UpdateItem", "dynamodb:DeleteItem"]),
                    "Effect": "Allow",
                    "Resource": Match.array_with([
                        Match.object_like({"Fn::GetAtt": [Match.string_like_regexp("AppTable.*"), "Arn"]}), # Table ARN
                        # Removed the /index/* part as no indexes are defined in the stack
                    ])
                })
            ])
        },
        "PolicyName": Match.string_like_regexp("AppLambdaServiceRoleDefaultPolicy.*"),
        "Roles": Match.array_with([lambda_role_ref_dict]) # Ensure this policy is attached to the AppLambda's role
    })

    # Check for S3 read/write permissions
    template.has_resource_properties("AWS::IAM::Policy", {
        "PolicyDocument": {
            "Statement": Match.array_with([
                Match.object_like({
                    "Action": Match.array_with(["s3:GetObject*", "s3:GetBucket*", "s3:List*", "s3:DeleteObject*", "s3:PutObject*", "s3:AbortMultipartUpload"]),
                    "Effect": "Allow",
                    "Resource": Match.array_with([
                        Match.object_like({"Fn::GetAtt": [Match.string_like_regexp("AppBucket.*"), "Arn"]}), # Bucket ARN
                        Match.object_like({"Fn::Join": ["", [Match.object_like({"Fn::GetAtt": [Match.string_like_regexp("AppBucket.*"), "Arn"]}), "/*"]]}) # Objects ARN
                    ])
                })
            ])
        },
        "PolicyName": Match.string_like_regexp("AppLambdaServiceRoleDefaultPolicy.*"),
        "Roles": Match.array_with([lambda_role_ref_dict]) # Ensure this policy is attached to the AppLambda's role
    })

  def test_s3_event_source_mapping(self, default_stack):
    """
    Test that S3 is set as an event source for the Lambda function.
    For S3, this means checking the AWS::Lambda::Permission that allows S3 to invoke the function.
    """
    template = Template.from_stack(default_stack)

    # For S3 event sources, CDK creates an AWS::Lambda::Permission resource.
    # It does NOT directly add a "NotificationConfiguration" property to the S3 bucket resource.
    template.has_resource_properties("AWS::Lambda::Permission", {
        "Action": "lambda:InvokeFunction",
        "FunctionName": Match.object_like({"Fn::GetAtt": [Match.string_like_regexp("AppLambda.*"), "Arn"]}),
        "Principal": "s3.amazonaws.com",
        "SourceAccount": Match.object_like({"Ref": "AWS::AccountId"}),
        "SourceArn": Match.object_like({"Fn::GetAtt": [Match.string_like_regexp("AppBucket.*"), "Arn"]})
    })

    # Optional: You could also check for the Custom Resource Lambda that manages
    # the S3 bucket notification configuration if you want to be very thorough,
    # but the AWS::Lambda::Permission is the direct evidence of the event source.
    # For example:
    # template.has_resource_properties("AWS::Lambda::Function", {
    #     "Handler": "index.handler", # This would be the custom resource handler
    #     "Runtime": "nodejs18.x", # Or whatever runtime CDK uses for custom resources
    #     "Tags": Match.array_with([{"Key": "aws-cdk:auto-delete-objects-handler", "Value": "true"}])
    # })


  def test_stack_outputs(self, prod_stack):
    """Test that CloudFormation outputs are defined for resources."""
    template = Template.from_stack(prod_stack)

    # S3 Bucket Output
    template.has_output("S3BucketName", {
        "Export": {
            "Name": "tap-prod-bucket-name"
        },
        "Value": Match.any_value() # Value will be a Ref, not a literal string
    })

    # DynamoDB Table Output
    template.has_output("DynamoDBTableName", {
        "Export": {
            "Name": "tap-prod-table-name"
        },
        "Value": Match.any_value() # Value will be a Ref
    })

    # Lambda Function Output
    template.has_output("LambdaFunctionName", {
        "Export": {
            "Name": "tap-prod-lambda-name"
        },
        "Value": Match.any_value() # Value will be a Ref
    })

    # Lambda Role ARN Output
    template.has_output("LambdaRoleArn", {
        "Export": {
            "Name": "tap-prod-lambda-role-arn"
        },
        "Value": Match.any_value() # Value will be a Ref
    })
