import pytest
from aws_cdk import App, Stack
from aws_cdk.assertions import Template, Match

# Assuming your TapStack is in a file named 'lib/tap_stack.py'
# You might need to adjust this import path based on your project structure
from lib.tap_stack import TapStack, TapStackProps

@pytest.fixture
def app():
    """Fixture to provide a CDK App instance for testing."""
    return App()

@pytest.fixture
def default_stack(app):
    """Fixture to provide a default TapStack instance for testing."""
    return TapStack(app, "TapStackTest")

@pytest.fixture
def qa_stack(app):
    """Fixture to provide a TapStack instance with 'qa' environment suffix."""
    return TapStack(app, "TapStackQaTest", props=TapStackProps(environment_suffix="qa"))

@pytest.fixture
def prod_stack(app):
    """Fixture to provide a TapStack instance with 'prod' environment suffix."""
    return TapStack(app, "TapStackProdTest", props=TapStackProps(environment_suffix="prod"))

class TestTapStack:
  """
  Unit tests for the TapStack CDK construct.
  These tests verify the CloudFormation template generated by the stack.
  """

  def test_defaults_env_suffix_to_dev(self, default_stack):
    """Test that the environment suffix defaults to 'dev'."""
    template = Template.from_stack(default_stack)
    # Check for a resource that uses the resource_name helper, like the S3 bucket name
    template.has_resource_properties("AWS::S3::Bucket", {
        "BucketName": "tap-dev-bucket"
    })

  def test_creates_s3_bucket_with_env_suffix(self, qa_stack):
    """Test S3 bucket creation with the specified environment suffix."""
    template = Template.from_stack(qa_stack)
    template.resource_count_is("AWS::S3::Bucket", 1)
    template.has_resource_properties("AWS::S3::Bucket", {
        "BucketName": "tap-qa-bucket",
        "VersioningConfiguration": Match.absent(), # Versioning is False
        # PublicAccessBlockConfiguration might not be explicitly present if it's the default
        # due to public_read_access=False, so we remove the explicit check here.
    })
    # Check removal policy
    template.has_resource("AWS::S3::Bucket", {
        "DeletionPolicy": "Delete",
        "UpdateReplacePolicy": "Delete"
    })

  def test_creates_dynamodb_table(self, qa_stack):
    """Test DynamoDB table creation with correct partition key and billing mode."""
    template = Template.from_stack(qa_stack)
    template.resource_count_is("AWS::DynamoDB::Table", 1)
    template.has_resource_properties("AWS::DynamoDB::Table", {
        "TableName": "tap-qa-table",
        "KeySchema": [{
            "AttributeName": "id",
            "KeyType": "HASH"
        }],
        "AttributeDefinitions": [{
            "AttributeName": "id",
            "AttributeType": "S"
        }],
        "BillingMode": "PAY_PER_REQUEST" # Corrected: Expect PAY_PER_REQUEST
    })
    # Check removal policy
    template.has_resource("AWS::DynamoDB::Table", {
        "DeletionPolicy": "Delete",
        "UpdateReplacePolicy": "Delete"
    })

  def test_creates_lambda_function_with_env(self, qa_stack):
    """Test Lambda function creation with correct environment variables."""
    template = Template.from_stack(qa_stack)
    # Corrected: Expect 3 Lambda functions (1 main + 2 custom resources for S3 event source)
    template.resource_count_is("AWS::Lambda::Function", 3)
    template.has_resource_properties("AWS::Lambda::Function", {
        "FunctionName": "tap-qa-lambda",
        "Runtime": "python3.11",
        "Handler": "index.handler",
        "Environment": {
            "Variables": {
                "TABLE_NAME": Match.any_value(), # Value is a Ref, so use Match.any_value()
                "BUCKET_NAME": Match.any_value() # Value is a Ref, so use Match.any_value()
            }
        }
    })

  def test_lambda_has_permissions(self, qa_stack):
    """Test that the Lambda function has correct IAM permissions."""
    template = Template.from_stack(qa_stack)

    # Get the logical ID of the AppLambda's role directly from the stack's lambda_fn object
    # This is the most reliable way to get the exact reference CDK uses.
    lambda_role_ref = qa_stack.lambda_fn.role.node.default_child.logical_id
    lambda_role_ref_dict = {"Ref": lambda_role_ref}


    # Check for DynamoDB read/write permissions
    template.has_resource_properties("AWS::IAM::Policy", {
        "PolicyDocument": {
            "Statement": Match.array_with([
                Match.object_like({
                    "Action": Match.array_with(["dynamodb:BatchGetItem", "dynamodb:GetRecords", "dynamodb:GetShardIterator", "dynamodb:Query", "dynamodb:GetItem", "dynamodb:Scan", "dynamodb:BatchWriteItem", "dynamodb:PutItem", "dynamodb:UpdateItem", "dynamodb:DeleteItem"]),
                    "Effect": "Allow",
                    "Resource": Match.array_with([
                        Match.object_like({"Fn::GetAtt": [Match.string_like_regexp("AppTable.*"), "Arn"]}), # Table ARN
                        # Removed the /index/* part as no indexes are defined in the stack
                    ])
                })
            ])
        },
        "PolicyName": Match.string_like_regexp("AppLambdaServiceRoleDefaultPolicy.*"),
        "Roles": Match.array_with([lambda_role_ref_dict]) # Ensure this policy is attached to the AppLambda's role
    })

    # Check for S3 read/write permissions
    template.has_resource_properties("AWS::IAM::Policy", {
        "PolicyDocument": {
            "Statement": Match.array_with([
                Match.object_like({
                    "Action": Match.array_with(["s3:GetObject*", "s3:GetBucket*", "s3:List*", "s3:DeleteObject*", "s3:PutObject*", "s3:AbortMultipartUpload"]),
                    "Effect": "Allow",
                    "Resource": Match.array_with([
                        Match.object_like({"Fn::GetAtt": [Match.string_like_regexp("AppBucket.*"), "Arn"]}), # Bucket ARN
                        Match.object_like({"Fn::Join": ["", [Match.object_like({"Fn::GetAtt": [Match.string_like_regexp("AppBucket.*"), "Arn"]}), "/*"]]}) # Objects ARN
                    ])
                })
            ])
        },
        "PolicyName": Match.string_like_regexp("AppLambdaServiceRoleDefaultPolicy.*"),
        "Roles": Match.array_with([lambda_role_ref_dict]) # Ensure this policy is attached to the AppLambda's role
    })

  def test_s3_event_source_mapping(self, default_stack):
    """
    Test that S3 is set as an event source for the Lambda function.
    For S3, this means checking the S3 Bucket Notification Configuration
    and the Lambda Permission that allows S3 to invoke the function.
    """
    template = Template.from_stack(default_stack)

    # Check for the S3 Bucket Notification Configuration
    # Using Match.objectLike for the bucket properties to allow for other properties
    # while specifically checking the NotificationConfiguration.
    template.has_resource_properties("AWS::S3::Bucket", {
        "NotificationConfiguration": {
            "LambdaConfigurations": [
                {
                    "Event": "s3:ObjectCreated:*",
                    "Function": Match.object_like({"Fn::GetAtt": [Match.string_like_regexp("AppLambda.*"), "Arn"]})
                }
            ]
        }
    })

    # Check for the Lambda Permission allowing S3 to invoke the function
    template.has_resource_properties("AWS::Lambda::Permission", {
        "Action": "lambda:InvokeFunction",
        "FunctionName": Match.object_like({"Fn::GetAtt": [Match.string_like_regexp("AppLambda.*"), "Arn"]}),
        "Principal": "s3.amazonaws.com",
        "SourceAccount": Match.object_like({"Ref": "AWS::AccountId"}),
        "SourceArn": Match.object_like({"Fn::GetAtt": [Match.string_like_regexp("AppBucket.*"), "Arn"]})
    })

  def test_stack_outputs(self, prod_stack):
    """Test that CloudFormation outputs are defined for resources."""
    template = Template.from_stack(prod_stack)

    # S3 Bucket Output
    template.has_output("S3BucketName", {
        "Export": {
            "Name": "tap-prod-bucket-name"
        },
        "Value": Match.any_value() # Value will be a Ref, not a literal string
    })

    # DynamoDB Table Output
    template.has_output("DynamoDBTableName", {
        "Export": {
            "Name": "tap-prod-table-name"
        },
        "Value": Match.any_value() # Value will be a Ref
    })

    # Lambda Function Output
    template.has_output("LambdaFunctionName", {
        "Export": {
            "Name": "tap-prod-lambda-name"
        },
        "Value": Match.any_value() # Value will be a Ref
    })

    # Lambda Role ARN Output
    template.has_output("LambdaRoleArn", {
        "Export": {
            "Name": "tap-prod-lambda-role-arn"
        },
        "Value": Match.any_value() # Value will be a Ref
    })
