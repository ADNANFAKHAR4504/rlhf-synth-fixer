# Overview

Please find solution files below.

## ./bin/tap.ts

```typescript
#!/usr/bin/env node
import * as cdk from 'aws-cdk-lib';
import { Tags } from 'aws-cdk-lib';
import { TapStack } from '../lib/tap-stack';

const app = new cdk.App();

// Get environment suffix from context (set by CI/CD pipeline) or use 'dev' as default
const environmentSuffix = app.node.tryGetContext('environmentSuffix') || 'dev';
const stackName = `TapStack${environmentSuffix}`;
const repositoryName = process.env.REPOSITORY || 'unknown';
const commitAuthor = process.env.COMMIT_AUTHOR || 'unknown';

// Apply tags to all stacks in this app (optional - you can do this at stack level instead)
Tags.of(app).add('Environment', environmentSuffix);
Tags.of(app).add('Repository', repositoryName);
Tags.of(app).add('Author', commitAuthor);

new TapStack(app, stackName, {
  stackName: stackName, // This ensures CloudFormation stack name includes the suffix
  environmentSuffix: environmentSuffix, // Pass the suffix to the stack
  env: {
    account: process.env.CDK_DEFAULT_ACCOUNT,
    region: process.env.CDK_DEFAULT_REGION,
  },
});

```

## ./lib/lambda/crud-handler.ts

```typescript
import { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda';
import { DynamoDBClient } from '@aws-sdk/client-dynamodb';
import {
  DynamoDBDocumentClient,
  GetCommand,
  PutCommand,
  DeleteCommand,
  ScanCommand,
  QueryCommand,
  UpdateCommand,
} from '@aws-sdk/lib-dynamodb';

const client = new DynamoDBClient({ region: process.env.REGION });
const dynamodb = DynamoDBDocumentClient.from(client);

interface ApplicationRecord {
  id: string;
  timestamp: number;
  status: 'active' | 'inactive' | 'pending' | 'completed';
  title: string;
  description?: string;
  data?: Record<string, unknown>;
  createdAt: string;
  updatedAt: string;
  createdBy?: string;
}

/**
 * CRUD operations handler for application records
 * Supports creating, reading, updating, and deleting records in DynamoDB
 * Also supports querying by status using GSI
 */
export const handler = async (
  event: APIGatewayProxyEvent
): Promise<APIGatewayProxyResult> => {
  console.log('CRUD Event:', JSON.stringify(event));

  const { httpMethod, pathParameters, body, queryStringParameters } = event;
  const tableName = process.env.DYNAMODB_TABLE_NAME;

  if (!tableName) {
    return {
      statusCode: 500,
      headers: {
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*',
      },
      body: JSON.stringify({ error: 'Table name not configured' }),
    };
  }

  try {
    let response: unknown;
    let statusCode = 200;

    switch (httpMethod) {
      case 'GET':
        if (pathParameters?.id) {
          // Get specific item by ID
          if (!pathParameters.timestamp) {
            return {
              statusCode: 400,
              headers: {
                'Content-Type': 'application/json',
                'Access-Control-Allow-Origin': '*',
              },
              body: JSON.stringify({
                error: 'timestamp parameter is required for GET by ID',
              }),
            };
          }

          const result = await dynamodb.send(
            new GetCommand({
              TableName: tableName,
              Key: {
                id: pathParameters.id,
                timestamp: parseInt(pathParameters.timestamp),
              },
            })
          );

          if (!result.Item) {
            statusCode = 404;
            response = { error: 'Item not found' };
          } else {
            response = result.Item;
          }
        } else if (queryStringParameters?.status) {
          // Query by status using GSI
          const queryResult = await dynamodb.send(
            new QueryCommand({
              TableName: tableName,
              IndexName: 'StatusIndex',
              KeyConditionExpression: '#status = :status',
              ExpressionAttributeNames: {
                '#status': 'status',
              },
              ExpressionAttributeValues: {
                ':status': queryStringParameters.status,
              },
              Limit: 50,
              ScanIndexForward: false, // Sort by timestamp descending
            })
          );
          response = {
            items: queryResult.Items || [],
            count: queryResult.Count,
          };
        } else {
          // Scan all items
          const scanResult = await dynamodb.send(
            new ScanCommand({
              TableName: tableName,
              Limit: 20,
            })
          );
          response = {
            items: scanResult.Items || [],
            count: scanResult.Count,
          };
        }
        break;

      case 'POST':
        // Create new item
        const inputData = JSON.parse(body || '{}');

        // Validate required fields
        if (!inputData.title) {
          return {
            statusCode: 400,
            headers: {
              'Content-Type': 'application/json',
              'Access-Control-Allow-Origin': '*',
            },
            body: JSON.stringify({
              error: 'title field is required',
            }),
          };
        }

        const newItem: ApplicationRecord = {
          id: inputData.id || `item-${Date.now()}`,
          timestamp: Date.now(),
          status: inputData.status || 'pending',
          title: inputData.title,
          description: inputData.description,
          data: inputData.data,
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
          createdBy: inputData.createdBy || 'system',
        };

        await dynamodb.send(
          new PutCommand({
            TableName: tableName,
            Item: newItem,
          })
        );

        statusCode = 201;
        response = {
          message: 'Item created successfully',
          item: newItem,
        };
        break;

      case 'PUT':
        // Update existing item
        if (!pathParameters?.id || !pathParameters?.timestamp) {
          return {
            statusCode: 400,
            headers: {
              'Content-Type': 'application/json',
              'Access-Control-Allow-Origin': '*',
            },
            body: JSON.stringify({
              error: 'id and timestamp parameters are required for update',
            }),
          };
        }

        const updateData = JSON.parse(body || '{}');

        // Build update expression
        const updateExpressions: string[] = [];
        const expressionAttributeNames: Record<string, string> = {};
        const expressionAttributeValues: Record<string, unknown> = {};

        if (updateData.title) {
          updateExpressions.push('#title = :title');
          expressionAttributeNames['#title'] = 'title';
          expressionAttributeValues[':title'] = updateData.title;
        }

        if (updateData.description !== undefined) {
          updateExpressions.push('#description = :description');
          expressionAttributeNames['#description'] = 'description';
          expressionAttributeValues[':description'] = updateData.description;
        }

        if (updateData.status) {
          updateExpressions.push('#status = :status');
          expressionAttributeNames['#status'] = 'status';
          expressionAttributeValues[':status'] = updateData.status;
        }

        if (updateData.data) {
          updateExpressions.push('#data = :data');
          expressionAttributeNames['#data'] = 'data';
          expressionAttributeValues[':data'] = updateData.data;
        }

        // Always update the updatedAt timestamp
        updateExpressions.push('#updatedAt = :updatedAt');
        expressionAttributeNames['#updatedAt'] = 'updatedAt';
        expressionAttributeValues[':updatedAt'] = new Date().toISOString();

        if (updateExpressions.length === 1) {
          // Only updatedAt is being updated
          return {
            statusCode: 400,
            headers: {
              'Content-Type': 'application/json',
              'Access-Control-Allow-Origin': '*',
            },
            body: JSON.stringify({
              error: 'No valid fields to update',
            }),
          };
        }

        const updateResult = await dynamodb.send(
          new UpdateCommand({
            TableName: tableName,
            Key: {
              id: pathParameters.id,
              timestamp: parseInt(pathParameters.timestamp),
            },
            UpdateExpression: `SET ${updateExpressions.join(', ')}`,
            ExpressionAttributeNames: expressionAttributeNames,
            ExpressionAttributeValues: expressionAttributeValues,
            ReturnValues: 'ALL_NEW',
          })
        );

        response = {
          message: 'Item updated successfully',
          item: updateResult.Attributes,
        };
        break;

      case 'DELETE':
        // Delete item
        if (!pathParameters?.id || !pathParameters?.timestamp) {
          return {
            statusCode: 400,
            headers: {
              'Content-Type': 'application/json',
              'Access-Control-Allow-Origin': '*',
            },
            body: JSON.stringify({
              error: 'id and timestamp parameters are required for deletion',
            }),
          };
        }

        await dynamodb.send(
          new DeleteCommand({
            TableName: tableName,
            Key: {
              id: pathParameters.id,
              timestamp: parseInt(pathParameters.timestamp),
            },
          })
        );

        response = {
          message: 'Item deleted successfully',
          id: pathParameters.id,
          timestamp: pathParameters.timestamp,
        };
        break;

      default:
        statusCode = 405;
        response = { error: `Method ${httpMethod} not supported` };
    }

    return {
      statusCode,
      headers: {
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*',
      },
      body: JSON.stringify(response),
    };
  } catch (error) {
    console.error('Error:', error);
    return {
      statusCode: 500,
      headers: {
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*',
      },
      body: JSON.stringify({
        error: error instanceof Error ? error.message : 'Unknown error',
        type: error instanceof Error ? error.constructor.name : 'UnknownError',
      }),
    };
  }
};

```

## ./lib/lambda/file-processing-handler.ts

```typescript
import { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda';
import {
  S3Client,
  PutObjectCommand,
  GetObjectCommand,
  DeleteObjectCommand,
} from '@aws-sdk/client-s3';
import { getSignedUrl } from '@aws-sdk/s3-request-presigner';
import { DynamoDBClient } from '@aws-sdk/client-dynamodb';
import {
  DynamoDBDocumentClient,
  PutCommand,
  QueryCommand,
  DeleteCommand,
} from '@aws-sdk/lib-dynamodb';

const s3Client = new S3Client({ region: process.env.REGION });
const dynamoClient = new DynamoDBClient({ region: process.env.REGION });
const dynamodb = DynamoDBDocumentClient.from(dynamoClient);

interface FileMetadata {
  id: string;
  timestamp: number;
  status: 'uploaded' | 'processing' | 'completed' | 'failed';
  fileName: string;
  fileKey: string;
  fileSize: number;
  contentType: string;
  uploadedBy?: string;
  tags?: string[];
  createdAt: string;
  updatedAt: string;
}

const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB
const ALLOWED_CONTENT_TYPES = [
  'text/plain',
  'text/csv',
  'application/json',
  'application/pdf',
  'image/jpeg',
  'image/png',
  'image/gif',
];

/**
 * File processing handler that manages file uploads to S3 and tracks metadata in DynamoDB
 * Supports file validation, metadata tracking, and secure file access
 */
export const handler = async (
  event: APIGatewayProxyEvent
): Promise<APIGatewayProxyResult> => {
  console.log('File Processing Event:', JSON.stringify(event));

  const bucketName = process.env.S3_BUCKET_NAME;
  const tableName = process.env.DYNAMODB_TABLE_NAME;
  const { httpMethod, body, pathParameters, queryStringParameters } = event;

  if (!bucketName || !tableName) {
    return {
      statusCode: 500,
      headers: {
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*',
      },
      body: JSON.stringify({
        error: 'Bucket name or table name not configured',
      }),
    };
  }

  try {
    let response: unknown;
    let statusCode = 200;

    switch (httpMethod) {
      case 'POST':
        // Upload file with metadata tracking
        const fileData = JSON.parse(body || '{}');

        // Validation
        if (!fileData.fileName) {
          return {
            statusCode: 400,
            headers: {
              'Content-Type': 'application/json',
              'Access-Control-Allow-Origin': '*',
            },
            body: JSON.stringify({
              error: 'fileName is required',
            }),
          };
        }

        const contentType = fileData.contentType || 'application/octet-stream';
        if (!ALLOWED_CONTENT_TYPES.includes(contentType)) {
          return {
            statusCode: 400,
            headers: {
              'Content-Type': 'application/json',
              'Access-Control-Allow-Origin': '*',
            },
            body: JSON.stringify({
              error: `Content type ${contentType} not allowed`,
              allowedTypes: ALLOWED_CONTENT_TYPES,
            }),
          };
        }

        const content = fileData.content || '';
        const fileSize = Buffer.byteLength(content, 'utf8');

        if (fileSize > MAX_FILE_SIZE) {
          return {
            statusCode: 400,
            headers: {
              'Content-Type': 'application/json',
              'Access-Control-Allow-Origin': '*',
            },
            body: JSON.stringify({
              error: `File size ${fileSize} exceeds maximum ${MAX_FILE_SIZE} bytes`,
            }),
          };
        }

        const fileId = `file-${Date.now()}`;
        const fileKey = `uploads/${fileId}/${fileData.fileName}`;

        // Upload to S3
        await s3Client.send(
          new PutObjectCommand({
            Bucket: bucketName,
            Key: fileKey,
            Body: content,
            ContentType: contentType,
            Metadata: {
              uploadedBy: fileData.uploadedBy || 'system',
              uploadTimestamp: new Date().toISOString(),
            },
          })
        );

        // Store metadata in DynamoDB
        const metadata: FileMetadata = {
          id: fileId,
          timestamp: Date.now(),
          status: 'uploaded',
          fileName: fileData.fileName,
          fileKey: fileKey,
          fileSize: fileSize,
          contentType: contentType,
          uploadedBy: fileData.uploadedBy || 'system',
          tags: fileData.tags || [],
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
        };

        await dynamodb.send(
          new PutCommand({
            TableName: tableName,
            Item: metadata,
          })
        );

        // Generate presigned URL for download
        const downloadUrl = await getSignedUrl(
          s3Client,
          new GetObjectCommand({
            Bucket: bucketName,
            Key: fileKey,
          }),
          { expiresIn: 3600 } // 1 hour
        );

        statusCode = 201;
        response = {
          message: 'File uploaded successfully',
          file: {
            ...metadata,
            downloadUrl,
          },
        };
        break;

      case 'GET':
        if (pathParameters?.filename) {
          // Get specific file metadata and generate presigned URL
          const getFileId = pathParameters.filename;

          // Query DynamoDB for file metadata
          const queryResult = await dynamodb.send(
            new QueryCommand({
              TableName: tableName,
              KeyConditionExpression: 'id = :id',
              ExpressionAttributeValues: {
                ':id': getFileId,
              },
            })
          );

          if (!queryResult.Items || queryResult.Items.length === 0) {
            statusCode = 404;
            response = { error: 'File not found' };
          } else {
            const fileMetadata = queryResult.Items[0] as FileMetadata;

            // Generate presigned URL
            const downloadUrl = await getSignedUrl(
              s3Client,
              new GetObjectCommand({
                Bucket: bucketName,
                Key: fileMetadata.fileKey,
              }),
              { expiresIn: 3600 }
            );

            response = {
              ...fileMetadata,
              downloadUrl,
            };
          }
        } else if (queryStringParameters?.status) {
          // Query files by status using GSI
          const queryResult = await dynamodb.send(
            new QueryCommand({
              TableName: tableName,
              IndexName: 'StatusIndex',
              KeyConditionExpression: '#status = :status',
              ExpressionAttributeNames: {
                '#status': 'status',
              },
              ExpressionAttributeValues: {
                ':status': queryStringParameters.status,
              },
              Limit: 50,
            })
          );

          response = {
            files: queryResult.Items || [],
            count: queryResult.Count,
          };
        } else {
          // List all file metadata from DynamoDB
          const queryResult = await dynamodb.send(
            new QueryCommand({
              TableName: tableName,
              IndexName: 'StatusIndex',
              KeyConditionExpression: '#status = :status',
              ExpressionAttributeNames: {
                '#status': 'status',
              },
              ExpressionAttributeValues: {
                ':status': 'uploaded',
              },
              Limit: 20,
            })
          );

          response = {
            files: queryResult.Items || [],
            count: queryResult.Count,
          };
        }
        break;

      case 'DELETE':
        // Delete file from S3 and metadata from DynamoDB
        if (!pathParameters?.filename) {
          return {
            statusCode: 400,
            headers: {
              'Content-Type': 'application/json',
              'Access-Control-Allow-Origin': '*',
            },
            body: JSON.stringify({
              error: 'File ID required for deletion',
            }),
          };
        }

        const deleteFileId = pathParameters.filename;

        // Get file metadata
        const deleteQueryResult = await dynamodb.send(
          new QueryCommand({
            TableName: tableName,
            KeyConditionExpression: 'id = :id',
            ExpressionAttributeValues: {
              ':id': deleteFileId,
            },
          })
        );

        if (!deleteQueryResult.Items || deleteQueryResult.Items.length === 0) {
          statusCode = 404;
          response = { error: 'File not found' };
        } else {
          const fileMetadata = deleteQueryResult.Items[0] as FileMetadata;

          // Delete from S3
          await s3Client.send(
            new DeleteObjectCommand({
              Bucket: bucketName,
              Key: fileMetadata.fileKey,
            })
          );

          // Delete from DynamoDB
          await dynamodb.send(
            new DeleteCommand({
              TableName: tableName,
              Key: {
                id: fileMetadata.id,
                timestamp: fileMetadata.timestamp,
              },
            })
          );

          response = {
            message: 'File deleted successfully',
            fileId: deleteFileId,
          };
        }
        break;

      default:
        statusCode = 405;
        response = { error: `Method ${httpMethod} not supported` };
    }

    return {
      statusCode,
      headers: {
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*',
      },
      body: JSON.stringify(response),
    };
  } catch (error) {
    console.error('Error:', error);
    return {
      statusCode: 500,
      headers: {
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*',
      },
      body: JSON.stringify({
        error: error instanceof Error ? error.message : 'Unknown error',
        type: error instanceof Error ? error.constructor.name : 'UnknownError',
      }),
    };
  }
};

```

## ./lib/lambda/main-handler.ts

```typescript
import { APIGatewayProxyEvent, APIGatewayProxyResult } from 'aws-lambda';
import { DynamoDBClient, DescribeTableCommand } from '@aws-sdk/client-dynamodb';
import { S3Client, HeadBucketCommand } from '@aws-sdk/client-s3';
import {
  SecretsManagerClient,
  GetSecretValueCommand,
} from '@aws-sdk/client-secrets-manager';

const dynamoClient = new DynamoDBClient({ region: process.env.REGION });
const s3Client = new S3Client({ region: process.env.REGION });
const secretsClient = new SecretsManagerClient({ region: process.env.REGION });

interface ServiceStatus {
  service: string;
  status: 'healthy' | 'unhealthy';
  message?: string;
  details?: Record<string, unknown>;
}

/**
 * Health check handler that validates connectivity and access to all AWS services
 * This provides a comprehensive system status check for the application
 */
export const handler = async (
  event: APIGatewayProxyEvent
): Promise<APIGatewayProxyResult> => {
  console.log('Health check initiated:', JSON.stringify(event));

  const tableName = process.env.DYNAMODB_TABLE_NAME;
  const bucketName = process.env.S3_BUCKET_NAME;
  const secretName = process.env.SECRET_NAME;

  const serviceChecks: ServiceStatus[] = [];

  // Check DynamoDB connectivity
  try {
    const tableInfo = await dynamoClient.send(
      new DescribeTableCommand({ TableName: tableName })
    );
    serviceChecks.push({
      service: 'DynamoDB',
      status: 'healthy',
      details: {
        tableName: tableInfo.Table?.TableName,
        itemCount: tableInfo.Table?.ItemCount,
        status: tableInfo.Table?.TableStatus,
      },
    });
  } catch (error) {
    console.error('DynamoDB health check failed:', error);
    serviceChecks.push({
      service: 'DynamoDB',
      status: 'unhealthy',
      message: error instanceof Error ? error.message : 'Unknown error',
    });
  }

  // Check S3 connectivity
  try {
    await s3Client.send(new HeadBucketCommand({ Bucket: bucketName }));
    serviceChecks.push({
      service: 'S3',
      status: 'healthy',
      details: {
        bucketName,
      },
    });
  } catch (error) {
    console.error('S3 health check failed:', error);
    serviceChecks.push({
      service: 'S3',
      status: 'unhealthy',
      message: error instanceof Error ? error.message : 'Unknown error',
    });
  }

  // Check Secrets Manager connectivity
  try {
    const secretValue = await secretsClient.send(
      new GetSecretValueCommand({ SecretId: secretName })
    );
    serviceChecks.push({
      service: 'Secrets Manager',
      status: 'healthy',
      details: {
        secretName,
        versionId: secretValue.VersionId,
      },
    });
  } catch (error) {
    console.error('Secrets Manager health check failed:', error);
    serviceChecks.push({
      service: 'Secrets Manager',
      status: 'unhealthy',
      message: error instanceof Error ? error.message : 'Unknown error',
    });
  }

  // Determine overall health status
  const allHealthy = serviceChecks.every(check => check.status === 'healthy');
  const statusCode = allHealthy ? 200 : 503;

  const response: APIGatewayProxyResult = {
    statusCode,
    headers: {
      'Content-Type': 'application/json',
      'Access-Control-Allow-Origin': '*',
    },
    body: JSON.stringify({
      status: allHealthy ? 'healthy' : 'degraded',
      environment: process.env.ENVIRONMENT_SUFFIX,
      region: process.env.REGION,
      timestamp: new Date().toISOString(),
      services: serviceChecks,
    }),
  };

  return response;
};

```

## ./lib/lambda/node_modules/@aws/lambda-invoke-store/dist/invoke-store.d.ts

```typescript
/**
 * Generic store context that uses protected keys for Lambda fields
 * and allows custom user properties
 */
export interface InvokeStoreContext {
    [key: string | symbol]: unknown;
}
/**
 * InvokeStore implementation class
 */
declare class InvokeStoreImpl {
    private static storage;
    static readonly PROTECTED_KEYS: {
        readonly REQUEST_ID: symbol;
        readonly X_RAY_TRACE_ID: symbol;
    };
    /**
     * Initialize and run code within an invoke context
     */
    static run<T>(context: InvokeStoreContext, fn: () => T | Promise<T>): T | Promise<T>;
    /**
     * Get the complete current context
     */
    static getContext(): InvokeStoreContext | undefined;
    /**
     * Get a specific value from the context by key
     */
    static get<T = unknown>(key: string | symbol): T | undefined;
    /**
     * Set a custom value in the current context
     * Protected Lambda context fields cannot be overwritten
     */
    static set(key: string | symbol, value: unknown): void;
    /**
     * Get the current request ID
     */
    static getRequestId(): string;
    /**
     * Get the current X-ray trace ID
     */
    static getXRayTraceId(): string | undefined;
    /**
     * Check if we're currently within an invoke context
     */
    static hasContext(): boolean;
    /**
     * Check if a key is protected (readonly Lambda context field)
     */
    private static isProtectedKey;
}
export declare const InvokeStore: typeof InvokeStoreImpl;
export {};

```

## ./lib/lambda/node_modules/@aws/lambda-invoke-store/package.json

```json
{
  "name": "@aws/lambda-invoke-store",
  "version": "0.0.1",
  "description": "Invoke scoped data storage for AWS Lambda Node.js Runtime Environment",
  "homepage": "https://github.com/awslabs/aws-lambda-invoke-store",
  "main": "./dist/invoke-store.js",
  "types": "./dist/invoke-store.d.ts",
  "files": [
    "dist"
  ],
  "repository": {
    "type": "git",
    "url": "git+https://github.com/awslabs/aws-lambda-invoke-store.git"
  },
  "license": "Apache-2.0",
  "author": {
    "name": "Amazon Web Services",
    "url": "http://aws.amazon.com"
  },
  "scripts": {
    "build": "tsc",
    "test": "vitest run",
    "test:watch": "vitest watch",
    "clean": "rm -rf dist"
  },
  "devDependencies": {
    "@tsconfig/node18": "^18.2.4",
    "@types/node": "^18.19.112",
    "typescript": "~5.4.5",
    "vitest": "^3.1.1"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "packageManager": "yarn@4.9.4"
}

```

## ./lib/lambda/node_modules/@aws-crypto/crc32/build/main/aws_crc32.d.ts

```typescript
import { SourceData, Checksum } from "@aws-sdk/types";
export declare class AwsCrc32 implements Checksum {
    private crc32;
    update(toHash: SourceData): void;
    digest(): Promise<Uint8Array>;
    reset(): void;
}

```

## ./lib/lambda/node_modules/@aws-crypto/crc32/build/main/index.d.ts

```typescript
export declare function crc32(data: Uint8Array): number;
export declare class Crc32 {
    private checksum;
    update(data: Uint8Array): this;
    digest(): number;
}
export { AwsCrc32 } from "./aws_crc32";

```

## ./lib/lambda/node_modules/@aws-crypto/crc32/build/module/aws_crc32.d.ts

```typescript
import { SourceData, Checksum } from "@aws-sdk/types";
export declare class AwsCrc32 implements Checksum {
    private crc32;
    update(toHash: SourceData): void;
    digest(): Promise<Uint8Array>;
    reset(): void;
}

```

## ./lib/lambda/node_modules/@aws-crypto/crc32/build/module/index.d.ts

```typescript
export declare function crc32(data: Uint8Array): number;
export declare class Crc32 {
    private checksum;
    update(data: Uint8Array): this;
    digest(): number;
}
export { AwsCrc32 } from "./aws_crc32";

```

## ./lib/lambda/node_modules/@aws-crypto/crc32/package.json

```json
{
  "name": "@aws-crypto/crc32",
  "version": "5.2.0",
  "scripts": {
    "prepublishOnly": "tsc -p tsconfig.json && tsc -p tsconfig.module.json",
    "pretest": "tsc -p tsconfig.test.json",
    "test": "mocha --require ts-node/register test/**/*test.ts"
  },
  "main": "./build/main/index.js",
  "module": "./build/module/index.js",
  "types": "./build/main/index.d.ts",
  "repository": {
    "type": "git",
    "url": "git@github.com:aws/aws-sdk-js-crypto-helpers.git"
  },
  "author": {
    "name": "AWS Crypto Tools Team",
    "email": "aws-cryptools@amazon.com",
    "url": "https://docs.aws.amazon.com/aws-crypto-tools/index.html?id=docs_gateway#lang/en_us"
  },
  "homepage": "https://github.com/aws/aws-sdk-js-crypto-helpers/tree/master/packages/crc32",
  "license": "Apache-2.0",
  "dependencies": {
    "@aws-crypto/util": "^5.2.0",
    "@aws-sdk/types": "^3.222.0",
    "tslib": "^2.6.2"
  },
  "engines": {
    "node": ">=16.0.0"
  },
  "gitHead": "c11b171b35ec5c093364f0e0d8dc4ab1af68e748"
}

```

## ./lib/lambda/node_modules/@aws-crypto/crc32/src/aws_crc32.ts

```typescript
// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

import { SourceData, Checksum } from "@aws-sdk/types";
import { convertToBuffer, isEmptyData, numToUint8 } from "@aws-crypto/util";
import { Crc32 } from "./index";

export class AwsCrc32 implements Checksum {
  private crc32 = new Crc32();

  update(toHash: SourceData) {
    if (isEmptyData(toHash)) return;

    this.crc32.update(convertToBuffer(toHash));
  }

  async digest(): Promise<Uint8Array> {
    return numToUint8(this.crc32.digest());
  }

  reset(): void {
    this.crc32 = new Crc32();
  }
}

```

## ./lib/lambda/node_modules/@aws-crypto/crc32/src/index.ts

```typescript
import {uint32ArrayFrom} from "@aws-crypto/util";

export function crc32(data: Uint8Array): number {
  return new Crc32().update(data).digest();
}

export class Crc32 {
  private checksum = 0xffffffff;

  update(data: Uint8Array): this {
    for (const byte of data) {
      this.checksum =
        (this.checksum >>> 8) ^ lookupTable[(this.checksum ^ byte) & 0xff];
    }

    return this;
  }

  digest(): number {
    return (this.checksum ^ 0xffffffff) >>> 0;
  }
}

// prettier-ignore
const a_lookUpTable = [
  0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA,
  0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
  0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
  0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,
  0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE,
  0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
  0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC,
  0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,
  0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
  0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
  0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940,
  0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
  0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116,
  0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
  0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
  0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
  0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A,
  0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
  0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818,
  0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
  0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
  0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,
  0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C,
  0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
  0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2,
  0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,
  0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
  0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,
  0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086,
  0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
  0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4,
  0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,
  0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
  0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,
  0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,
  0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
  0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE,
  0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,
  0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
  0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
  0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252,
  0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
  0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60,
  0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,
  0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
  0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,
  0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04,
  0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
  0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A,
  0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
  0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
  0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,
  0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E,
  0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
  0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C,
  0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,
  0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
  0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,
  0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0,
  0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
  0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6,
  0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,
  0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
  0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D,
];
const lookupTable: Uint32Array = uint32ArrayFrom(a_lookUpTable)
export { AwsCrc32 } from "./aws_crc32";

```

## ./lib/lambda/node_modules/@aws-crypto/crc32/tsconfig.json

```json
{
  "extends": "../tsconfig.json",
  "compilerOptions": {
    "rootDir": "./src",
    "outDir": "./build/main",
  },
  "include": ["src/**/*.ts"],
  "exclude": ["node_modules/**"]
}

```

## ./lib/lambda/node_modules/@aws-crypto/crc32/tsconfig.module.json

```json
{
  "extends": "./tsconfig",
  "compilerOptions": {
    "outDir": "build/module",
    "module": "esnext",
  }
}

```

## ./lib/lambda/node_modules/@aws-crypto/crc32c/build/main/aws_crc32c.d.ts

```typescript
import { Checksum, SourceData } from "@aws-sdk/types";
export declare class AwsCrc32c implements Checksum {
    private crc32c;
    update(toHash: SourceData): void;
    digest(): Promise<Uint8Array>;
    reset(): void;
}

```

## ./lib/lambda/node_modules/@aws-crypto/crc32c/build/main/index.d.ts

```typescript
export declare function crc32c(data: Uint8Array): number;
export declare class Crc32c {
    private checksum;
    update(data: Uint8Array): this;
    digest(): number;
}
export { AwsCrc32c } from "./aws_crc32c";

```

## ./lib/lambda/node_modules/@aws-crypto/crc32c/build/module/aws_crc32c.d.ts

```typescript
import { Checksum, SourceData } from "@aws-sdk/types";
export declare class AwsCrc32c implements Checksum {
    private crc32c;
    update(toHash: SourceData): void;
    digest(): Promise<Uint8Array>;
    reset(): void;
}

```

## ./lib/lambda/node_modules/@aws-crypto/crc32c/build/module/index.d.ts

```typescript
export declare function crc32c(data: Uint8Array): number;
export declare class Crc32c {
    private checksum;
    update(data: Uint8Array): this;
    digest(): number;
}
export { AwsCrc32c } from "./aws_crc32c";

```

## ./lib/lambda/node_modules/@aws-crypto/crc32c/package.json

```json
{
  "name": "@aws-crypto/crc32c",
  "version": "5.2.0",
  "scripts": {
    "prepublishOnly": "tsc -p tsconfig.json && tsc -p tsconfig.module.json",
    "pretest": "tsc -p tsconfig.test.json",
    "test": "mocha --require ts-node/register test/**/*test.ts"
  },
  "main": "./build/main/index.js",
  "module": "./build/module/index.js",
  "types": "./build/main/index.d.ts",
  "repository": {
    "type": "git",
    "url": "git@github.com:aws/aws-sdk-js-crypto-helpers.git"
  },
  "author": {
    "name": "AWS Crypto Tools Team",
    "email": "aws-cryptools@amazon.com",
    "url": "https://docs.aws.amazon.com/aws-crypto-tools/index.html?id=docs_gateway#lang/en_us"
  },
  "homepage": "https://github.com/aws/aws-sdk-js-crypto-helpers/tree/master/packages/crc32c",
  "license": "Apache-2.0",
  "dependencies": {
    "@aws-crypto/util": "^5.2.0",
    "@aws-sdk/types": "^3.222.0",
    "tslib": "^2.6.2"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "c11b171b35ec5c093364f0e0d8dc4ab1af68e748"
}

```

## ./lib/lambda/node_modules/@aws-crypto/crc32c/src/aws_crc32c.ts

```typescript
// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

import { Checksum, SourceData } from "@aws-sdk/types";
import { convertToBuffer, isEmptyData, numToUint8 } from "@aws-crypto/util";
import { Crc32c } from "./index";

export class AwsCrc32c implements Checksum {
  private crc32c = new Crc32c();

  update(toHash: SourceData) {
    if (isEmptyData(toHash)) return;

    this.crc32c.update(convertToBuffer(toHash));
  }

  async digest(): Promise<Uint8Array> {
    return numToUint8(this.crc32c.digest());
  }

  reset(): void {
    this.crc32c = new Crc32c();
  }
}

```

## ./lib/lambda/node_modules/@aws-crypto/crc32c/src/index.ts

```typescript
// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

import {uint32ArrayFrom} from "@aws-crypto/util";

export function crc32c(data: Uint8Array): number {
  return new Crc32c().update(data).digest();
}

export class Crc32c {
  private checksum = 0xffffffff;

  update(data: Uint8Array): this {
    for (const byte of data) {
      this.checksum =
        (this.checksum >>> 8) ^ lookupTable[(this.checksum ^ byte) & 0xff];
    }

    return this;
  }

  digest(): number {
    return (this.checksum ^ 0xffffffff) >>> 0;
  }
}

// prettier-ignore
const a_lookupTable = [
  0x00000000, 0xF26B8303, 0xE13B70F7, 0x1350F3F4, 0xC79A971F, 0x35F1141C, 0x26A1E7E8, 0xD4CA64EB,
  0x8AD958CF, 0x78B2DBCC, 0x6BE22838, 0x9989AB3B, 0x4D43CFD0, 0xBF284CD3, 0xAC78BF27, 0x5E133C24,
  0x105EC76F, 0xE235446C, 0xF165B798, 0x030E349B, 0xD7C45070, 0x25AFD373, 0x36FF2087, 0xC494A384,
  0x9A879FA0, 0x68EC1CA3, 0x7BBCEF57, 0x89D76C54, 0x5D1D08BF, 0xAF768BBC, 0xBC267848, 0x4E4DFB4B,
  0x20BD8EDE, 0xD2D60DDD, 0xC186FE29, 0x33ED7D2A, 0xE72719C1, 0x154C9AC2, 0x061C6936, 0xF477EA35,
  0xAA64D611, 0x580F5512, 0x4B5FA6E6, 0xB93425E5, 0x6DFE410E, 0x9F95C20D, 0x8CC531F9, 0x7EAEB2FA,
  0x30E349B1, 0xC288CAB2, 0xD1D83946, 0x23B3BA45, 0xF779DEAE, 0x05125DAD, 0x1642AE59, 0xE4292D5A,
  0xBA3A117E, 0x4851927D, 0x5B016189, 0xA96AE28A, 0x7DA08661, 0x8FCB0562, 0x9C9BF696, 0x6EF07595,
  0x417B1DBC, 0xB3109EBF, 0xA0406D4B, 0x522BEE48, 0x86E18AA3, 0x748A09A0, 0x67DAFA54, 0x95B17957,
  0xCBA24573, 0x39C9C670, 0x2A993584, 0xD8F2B687, 0x0C38D26C, 0xFE53516F, 0xED03A29B, 0x1F682198,
  0x5125DAD3, 0xA34E59D0, 0xB01EAA24, 0x42752927, 0x96BF4DCC, 0x64D4CECF, 0x77843D3B, 0x85EFBE38,
  0xDBFC821C, 0x2997011F, 0x3AC7F2EB, 0xC8AC71E8, 0x1C661503, 0xEE0D9600, 0xFD5D65F4, 0x0F36E6F7,
  0x61C69362, 0x93AD1061, 0x80FDE395, 0x72966096, 0xA65C047D, 0x5437877E, 0x4767748A, 0xB50CF789,
  0xEB1FCBAD, 0x197448AE, 0x0A24BB5A, 0xF84F3859, 0x2C855CB2, 0xDEEEDFB1, 0xCDBE2C45, 0x3FD5AF46,
  0x7198540D, 0x83F3D70E, 0x90A324FA, 0x62C8A7F9, 0xB602C312, 0x44694011, 0x5739B3E5, 0xA55230E6,
  0xFB410CC2, 0x092A8FC1, 0x1A7A7C35, 0xE811FF36, 0x3CDB9BDD, 0xCEB018DE, 0xDDE0EB2A, 0x2F8B6829,
  0x82F63B78, 0x709DB87B, 0x63CD4B8F, 0x91A6C88C, 0x456CAC67, 0xB7072F64, 0xA457DC90, 0x563C5F93,
  0x082F63B7, 0xFA44E0B4, 0xE9141340, 0x1B7F9043, 0xCFB5F4A8, 0x3DDE77AB, 0x2E8E845F, 0xDCE5075C,
  0x92A8FC17, 0x60C37F14, 0x73938CE0, 0x81F80FE3, 0x55326B08, 0xA759E80B, 0xB4091BFF, 0x466298FC,
  0x1871A4D8, 0xEA1A27DB, 0xF94AD42F, 0x0B21572C, 0xDFEB33C7, 0x2D80B0C4, 0x3ED04330, 0xCCBBC033,
  0xA24BB5A6, 0x502036A5, 0x4370C551, 0xB11B4652, 0x65D122B9, 0x97BAA1BA, 0x84EA524E, 0x7681D14D,
  0x2892ED69, 0xDAF96E6A, 0xC9A99D9E, 0x3BC21E9D, 0xEF087A76, 0x1D63F975, 0x0E330A81, 0xFC588982,
  0xB21572C9, 0x407EF1CA, 0x532E023E, 0xA145813D, 0x758FE5D6, 0x87E466D5, 0x94B49521, 0x66DF1622,
  0x38CC2A06, 0xCAA7A905, 0xD9F75AF1, 0x2B9CD9F2, 0xFF56BD19, 0x0D3D3E1A, 0x1E6DCDEE, 0xEC064EED,
  0xC38D26C4, 0x31E6A5C7, 0x22B65633, 0xD0DDD530, 0x0417B1DB, 0xF67C32D8, 0xE52CC12C, 0x1747422F,
  0x49547E0B, 0xBB3FFD08, 0xA86F0EFC, 0x5A048DFF, 0x8ECEE914, 0x7CA56A17, 0x6FF599E3, 0x9D9E1AE0,
  0xD3D3E1AB, 0x21B862A8, 0x32E8915C, 0xC083125F, 0x144976B4, 0xE622F5B7, 0xF5720643, 0x07198540,
  0x590AB964, 0xAB613A67, 0xB831C993, 0x4A5A4A90, 0x9E902E7B, 0x6CFBAD78, 0x7FAB5E8C, 0x8DC0DD8F,
  0xE330A81A, 0x115B2B19, 0x020BD8ED, 0xF0605BEE, 0x24AA3F05, 0xD6C1BC06, 0xC5914FF2, 0x37FACCF1,
  0x69E9F0D5, 0x9B8273D6, 0x88D28022, 0x7AB90321, 0xAE7367CA, 0x5C18E4C9, 0x4F48173D, 0xBD23943E,
  0xF36E6F75, 0x0105EC76, 0x12551F82, 0xE03E9C81, 0x34F4F86A, 0xC69F7B69, 0xD5CF889D, 0x27A40B9E,
  0x79B737BA, 0x8BDCB4B9, 0x988C474D, 0x6AE7C44E, 0xBE2DA0A5, 0x4C4623A6, 0x5F16D052, 0xAD7D5351,
];

const lookupTable: Uint32Array = uint32ArrayFrom(a_lookupTable)
export { AwsCrc32c } from "./aws_crc32c";

```

## ./lib/lambda/node_modules/@aws-crypto/crc32c/tsconfig.json

```json
{
  "extends": "../tsconfig.json",
  "compilerOptions": {
    "rootDir": "./src",
    "outDir": "./build/main",
  },
  "include": ["src/**/*.ts"],
  "exclude": ["node_modules/**"]
}

```

## ./lib/lambda/node_modules/@aws-crypto/crc32c/tsconfig.module.json

```json
{
  "extends": "./tsconfig",
  "compilerOptions": {
    "outDir": "build/module",
    "module": "esnext",
  }
}

```

## ./lib/lambda/node_modules/@aws-crypto/sha1-browser/build/main/constants.d.ts

```typescript
export declare const SHA_1_HASH: {
    name: "SHA-1";
};
export declare const SHA_1_HMAC_ALGO: {
    name: "HMAC";
    hash: {
        name: "SHA-1";
    };
};
export declare const EMPTY_DATA_SHA_1: Uint8Array;

```

## ./lib/lambda/node_modules/@aws-crypto/sha1-browser/build/main/crossPlatformSha1.d.ts

```typescript
import { Checksum, SourceData } from "@aws-sdk/types";
export declare class Sha1 implements Checksum {
    private hash;
    constructor(secret?: SourceData);
    update(data: SourceData, encoding?: "utf8" | "ascii" | "latin1"): void;
    digest(): Promise<Uint8Array>;
    reset(): void;
}

```

## ./lib/lambda/node_modules/@aws-crypto/sha1-browser/build/main/index.d.ts

```typescript
export * from "./crossPlatformSha1";
export { Sha1 as WebCryptoSha1 } from "./webCryptoSha1";

```

## ./lib/lambda/node_modules/@aws-crypto/sha1-browser/build/main/isEmptyData.d.ts

```typescript
import { SourceData } from "@aws-sdk/types";
export declare function isEmptyData(data: SourceData): boolean;

```

## ./lib/lambda/node_modules/@aws-crypto/sha1-browser/build/main/webCryptoSha1.d.ts

```typescript
import { Checksum, SourceData } from "@aws-sdk/types";
export declare class Sha1 implements Checksum {
    private readonly key;
    private toHash;
    constructor(secret?: SourceData);
    update(data: SourceData): void;
    digest(): Promise<Uint8Array>;
    reset(): void;
}

```

## ./lib/lambda/node_modules/@aws-crypto/sha1-browser/build/module/constants.d.ts

```typescript
export declare const SHA_1_HASH: {
    name: "SHA-1";
};
export declare const SHA_1_HMAC_ALGO: {
    name: "HMAC";
    hash: {
        name: "SHA-1";
    };
};
export declare const EMPTY_DATA_SHA_1: Uint8Array;

```

## ./lib/lambda/node_modules/@aws-crypto/sha1-browser/build/module/crossPlatformSha1.d.ts

```typescript
import { Checksum, SourceData } from "@aws-sdk/types";
export declare class Sha1 implements Checksum {
    private hash;
    constructor(secret?: SourceData);
    update(data: SourceData, encoding?: "utf8" | "ascii" | "latin1"): void;
    digest(): Promise<Uint8Array>;
    reset(): void;
}

```

## ./lib/lambda/node_modules/@aws-crypto/sha1-browser/build/module/index.d.ts

```typescript
export * from "./crossPlatformSha1";
export { Sha1 as WebCryptoSha1 } from "./webCryptoSha1";

```

## ./lib/lambda/node_modules/@aws-crypto/sha1-browser/build/module/isEmptyData.d.ts

```typescript
import { SourceData } from "@aws-sdk/types";
export declare function isEmptyData(data: SourceData): boolean;

```

## ./lib/lambda/node_modules/@aws-crypto/sha1-browser/build/module/webCryptoSha1.d.ts

```typescript
import { Checksum, SourceData } from "@aws-sdk/types";
export declare class Sha1 implements Checksum {
    private readonly key;
    private toHash;
    constructor(secret?: SourceData);
    update(data: SourceData): void;
    digest(): Promise<Uint8Array>;
    reset(): void;
}

```

## ./lib/lambda/node_modules/@aws-crypto/sha1-browser/node_modules/@smithy/is-array-buffer/dist-types/index.d.ts

```typescript
/**
 * @internal
 */
export declare const isArrayBuffer: (arg: any) => arg is ArrayBuffer;

```

## ./lib/lambda/node_modules/@aws-crypto/sha1-browser/node_modules/@smithy/is-array-buffer/dist-types/ts3.4/index.d.ts

```typescript
/**
 * @internal
 */
export declare const isArrayBuffer: (arg: any) => arg is ArrayBuffer;

```

## ./lib/lambda/node_modules/@aws-crypto/sha1-browser/node_modules/@smithy/is-array-buffer/package.json

```json
{
  "name": "@smithy/is-array-buffer",
  "version": "2.2.0",
  "description": "Provides a function for detecting if an argument is an ArrayBuffer",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline is-array-buffer",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../.prettierignore --write \"**/*.{ts,md,json}\"",
    "test": "yarn g:jest"
  },
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "dependencies": {
    "tslib": "^2.6.2"
  },
  "engines": {
    "node": ">=14.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/awslabs/smithy-typescript/tree/main/packages/is-array-buffer",
  "repository": {
    "type": "git",
    "url": "https://github.com/awslabs/smithy-typescript.git",
    "directory": "packages/is-array-buffer"
  },
  "devDependencies": {
    "@tsconfig/recommended": "1.0.1",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  }
}
```

## ./lib/lambda/node_modules/@aws-crypto/sha1-browser/node_modules/@smithy/util-buffer-from/dist-types/index.d.ts

```typescript
import { Buffer } from "buffer";
/**
 * @internal
 */
export declare const fromArrayBuffer: (input: ArrayBuffer, offset?: number, length?: number) => Buffer;
/**
 * @internal
 */
export type StringEncoding = "ascii" | "utf8" | "utf16le" | "ucs2" | "base64" | "latin1" | "binary" | "hex";
/**
 * @internal
 */
export declare const fromString: (input: string, encoding?: StringEncoding) => Buffer;

```

## ./lib/lambda/node_modules/@aws-crypto/sha1-browser/node_modules/@smithy/util-buffer-from/dist-types/ts3.4/index.d.ts

```typescript
import { Buffer } from "buffer";
/**
 * @internal
 */
export declare const fromArrayBuffer: (input: ArrayBuffer, offset?: number, length?: number) => Buffer;
/**
 * @internal
 */
export type StringEncoding = "ascii" | "utf8" | "utf16le" | "ucs2" | "base64" | "latin1" | "binary" | "hex";
/**
 * @internal
 */
export declare const fromString: (input: string, encoding?: StringEncoding) => Buffer;

```

## ./lib/lambda/node_modules/@aws-crypto/sha1-browser/node_modules/@smithy/util-buffer-from/package.json

```json
{
  "name": "@smithy/util-buffer-from",
  "version": "2.2.0",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline util-buffer-from",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../.prettierignore --write \"**/*.{ts,md,json}\"",
    "test": "yarn g:jest"
  },
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "dependencies": {
    "@smithy/is-array-buffer": "^2.2.0",
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "@tsconfig/recommended": "1.0.1",
    "@types/node": "^14.14.31",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "engines": {
    "node": ">=14.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/awslabs/smithy-typescript/tree/main/packages/util-buffer-from",
  "repository": {
    "type": "git",
    "url": "https://github.com/awslabs/smithy-typescript.git",
    "directory": "packages/util-buffer-from"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  }
}
```

## ./lib/lambda/node_modules/@aws-crypto/sha1-browser/node_modules/@smithy/util-utf8/dist-types/fromUtf8.browser.d.ts

```typescript
export declare const fromUtf8: (input: string) => Uint8Array;

```

## ./lib/lambda/node_modules/@aws-crypto/sha1-browser/node_modules/@smithy/util-utf8/dist-types/fromUtf8.d.ts

```typescript
export declare const fromUtf8: (input: string) => Uint8Array;

```

## ./lib/lambda/node_modules/@aws-crypto/sha1-browser/node_modules/@smithy/util-utf8/dist-types/index.d.ts

```typescript
export * from "./fromUtf8";
export * from "./toUint8Array";
export * from "./toUtf8";

```

## ./lib/lambda/node_modules/@aws-crypto/sha1-browser/node_modules/@smithy/util-utf8/dist-types/toUint8Array.d.ts

```typescript
export declare const toUint8Array: (data: string | ArrayBuffer | ArrayBufferView) => Uint8Array;

```

## ./lib/lambda/node_modules/@aws-crypto/sha1-browser/node_modules/@smithy/util-utf8/dist-types/toUtf8.browser.d.ts

```typescript
/**
 *
 * This does not convert non-utf8 strings to utf8, it only passes through strings if
 * a string is received instead of a Uint8Array.
 *
 */
export declare const toUtf8: (input: Uint8Array | string) => string;

```

## ./lib/lambda/node_modules/@aws-crypto/sha1-browser/node_modules/@smithy/util-utf8/dist-types/toUtf8.d.ts

```typescript
/**
 *
 * This does not convert non-utf8 strings to utf8, it only passes through strings if
 * a string is received instead of a Uint8Array.
 *
 */
export declare const toUtf8: (input: Uint8Array | string) => string;

```

## ./lib/lambda/node_modules/@aws-crypto/sha1-browser/node_modules/@smithy/util-utf8/dist-types/ts3.4/fromUtf8.browser.d.ts

```typescript
export declare const fromUtf8: (input: string) => Uint8Array;

```

## ./lib/lambda/node_modules/@aws-crypto/sha1-browser/node_modules/@smithy/util-utf8/dist-types/ts3.4/fromUtf8.d.ts

```typescript
export declare const fromUtf8: (input: string) => Uint8Array;

```

## ./lib/lambda/node_modules/@aws-crypto/sha1-browser/node_modules/@smithy/util-utf8/dist-types/ts3.4/index.d.ts

```typescript
export * from "./fromUtf8";
export * from "./toUint8Array";
export * from "./toUtf8";

```

## ./lib/lambda/node_modules/@aws-crypto/sha1-browser/node_modules/@smithy/util-utf8/dist-types/ts3.4/toUint8Array.d.ts

```typescript
export declare const toUint8Array: (data: string | ArrayBuffer | ArrayBufferView) => Uint8Array;

```

## ./lib/lambda/node_modules/@aws-crypto/sha1-browser/node_modules/@smithy/util-utf8/dist-types/ts3.4/toUtf8.browser.d.ts

```typescript
/**
 *
 * This does not convert non-utf8 strings to utf8, it only passes through strings if
 * a string is received instead of a Uint8Array.
 *
 */
export declare const toUtf8: (input: Uint8Array | string) => string;

```

## ./lib/lambda/node_modules/@aws-crypto/sha1-browser/node_modules/@smithy/util-utf8/dist-types/ts3.4/toUtf8.d.ts

```typescript
/**
 *
 * This does not convert non-utf8 strings to utf8, it only passes through strings if
 * a string is received instead of a Uint8Array.
 *
 */
export declare const toUtf8: (input: Uint8Array | string) => string;

```

## ./lib/lambda/node_modules/@aws-crypto/sha1-browser/node_modules/@smithy/util-utf8/package.json

```json
{
  "name": "@smithy/util-utf8",
  "version": "2.3.0",
  "description": "A UTF-8 string <-> UInt8Array converter",
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline util-utf8",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../.prettierignore --write \"**/*.{ts,md,json}\"",
    "test": "yarn g:jest"
  },
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "dependencies": {
    "@smithy/util-buffer-from": "^2.2.0",
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "@tsconfig/recommended": "1.0.1",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "types": "./dist-types/index.d.ts",
  "engines": {
    "node": ">=14.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "browser": {
    "./dist-es/fromUtf8": "./dist-es/fromUtf8.browser",
    "./dist-es/toUtf8": "./dist-es/toUtf8.browser"
  },
  "react-native": {},
  "homepage": "https://github.com/awslabs/smithy-typescript/tree/main/packages/util-utf8",
  "repository": {
    "type": "git",
    "url": "https://github.com/awslabs/smithy-typescript.git",
    "directory": "packages/util-utf8"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  }
}
```

## ./lib/lambda/node_modules/@aws-crypto/sha1-browser/package.json

```json
{
  "name": "@aws-crypto/sha1-browser",
  "version": "5.2.0",
  "scripts": {
    "prepublishOnly": "tsc -p tsconfig.json && tsc -p tsconfig.module.json",
    "pretest": "tsc -p tsconfig.test.json",
    "test": "mocha --require ts-node/register test/**/*test.ts"
  },
  "repository": {
    "type": "git",
    "url": "git@github.com:aws/aws-sdk-js-crypto-helpers.git"
  },
  "author": {
    "name": "AWS Crypto Tools Team",
    "email": "aws-cryptools@amazon.com",
    "url": "https://docs.aws.amazon.com/aws-crypto-tools/index.html?id=docs_gateway#lang/en_us"
  },
  "homepage": "https://github.com/aws/aws-sdk-js-crypto-helpers/tree/master/packages/sha1-browser",
  "license": "Apache-2.0",
  "dependencies": {
    "@aws-crypto/supports-web-crypto": "^5.2.0",
    "@aws-crypto/util": "^5.2.0",
    "@aws-sdk/types": "^3.222.0",
    "@aws-sdk/util-locate-window": "^3.0.0",
    "@smithy/util-utf8": "^2.0.0",
    "tslib": "^2.6.2"
  },
  "main": "./build/main/index.js",
  "module": "./build/module/index.js",
  "types": "./build/main/index.d.ts",
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "c11b171b35ec5c093364f0e0d8dc4ab1af68e748"
}

```

## ./lib/lambda/node_modules/@aws-crypto/sha1-browser/src/constants.ts

```typescript
export const SHA_1_HASH: { name: "SHA-1" } = { name: "SHA-1" };

export const SHA_1_HMAC_ALGO: { name: "HMAC"; hash: { name: "SHA-1" } } = {
  name: "HMAC",
  hash: SHA_1_HASH,
};

export const EMPTY_DATA_SHA_1 = new Uint8Array([
  218,
  57,
  163,
  238,
  94,
  107,
  75,
  13,
  50,
  85,
  191,
  239,
  149,
  96,
  24,
  144,
  175,
  216,
  7,
  9,
]);

```

## ./lib/lambda/node_modules/@aws-crypto/sha1-browser/src/crossPlatformSha1.ts

```typescript
import { Sha1 as WebCryptoSha1 } from "./webCryptoSha1";
import { Checksum, SourceData } from "@aws-sdk/types";
import { supportsWebCrypto } from "@aws-crypto/supports-web-crypto";
import { locateWindow } from "@aws-sdk/util-locate-window";
import { convertToBuffer } from "@aws-crypto/util";

export class Sha1 implements Checksum {
  private hash: Checksum;

  constructor(secret?: SourceData) {
    if (supportsWebCrypto(locateWindow())) {
      this.hash = new WebCryptoSha1(secret);
    } else {
      throw new Error("SHA1 not supported");
    }
  }

  update(data: SourceData, encoding?: "utf8" | "ascii" | "latin1"): void {
    this.hash.update(convertToBuffer(data));
  }

  digest(): Promise<Uint8Array> {
    return this.hash.digest();
  }

  reset(): void {
    this.hash.reset();
  }
}

```

## ./lib/lambda/node_modules/@aws-crypto/sha1-browser/src/index.ts

```typescript
export * from "./crossPlatformSha1";
export { Sha1 as WebCryptoSha1 } from "./webCryptoSha1";

```

## ./lib/lambda/node_modules/@aws-crypto/sha1-browser/src/isEmptyData.ts

```typescript
import { SourceData } from "@aws-sdk/types";

export function isEmptyData(data: SourceData): boolean {
  if (typeof data === "string") {
    return data.length === 0;
  }

  return data.byteLength === 0;
}

```

## ./lib/lambda/node_modules/@aws-crypto/sha1-browser/src/webCryptoSha1.ts

```typescript
import { Checksum, SourceData } from "@aws-sdk/types";
import { fromUtf8 } from "@smithy/util-utf8";
import { isEmptyData } from "./isEmptyData";
import { EMPTY_DATA_SHA_1, SHA_1_HASH, SHA_1_HMAC_ALGO } from "./constants";
import { locateWindow } from "@aws-sdk/util-locate-window";

export class Sha1 implements Checksum {
  private readonly key: Promise<CryptoKey> | undefined;
  private toHash: Uint8Array = new Uint8Array(0);

  constructor(secret?: SourceData) {
    if (secret !== void 0) {
      this.key = new Promise((resolve, reject) => {
        locateWindow()
          .crypto.subtle.importKey(
            "raw",
            convertToBuffer(secret),
            SHA_1_HMAC_ALGO,
            false,
            ["sign"]
          )
          .then(resolve, reject);
      });
      this.key.catch(() => {});
    }
  }

  update(data: SourceData): void {
    if (isEmptyData(data)) {
      return;
    }

    const update = convertToBuffer(data);
    const typedArray = new Uint8Array(
      this.toHash.byteLength + update.byteLength
    );
    typedArray.set(this.toHash, 0);
    typedArray.set(update, this.toHash.byteLength);
    this.toHash = typedArray;
  }

  digest(): Promise<Uint8Array> {
    if (this.key) {
      return this.key.then((key) =>
        locateWindow()
          .crypto.subtle.sign(SHA_1_HMAC_ALGO, key, this.toHash)
          .then((data) => new Uint8Array(data))
      );
    }

    if (isEmptyData(this.toHash)) {
      return Promise.resolve(EMPTY_DATA_SHA_1);
    }

    return Promise.resolve()
      .then(() => locateWindow().crypto.subtle.digest(SHA_1_HASH, this.toHash))
      .then((data) => Promise.resolve(new Uint8Array(data)));
  }

  reset(): void {
    this.toHash = new Uint8Array(0);
  }
}

function convertToBuffer(data: SourceData): Uint8Array {
  if (typeof data === "string") {
    return fromUtf8(data);
  }

  if (ArrayBuffer.isView(data)) {
    return new Uint8Array(
      data.buffer,
      data.byteOffset,
      data.byteLength / Uint8Array.BYTES_PER_ELEMENT
    );
  }

  return new Uint8Array(data);
}

```

## ./lib/lambda/node_modules/@aws-crypto/sha1-browser/tsconfig.json

```json
{
  "extends": "../tsconfig.json",
  "compilerOptions": {
    "rootDir": "./src",
    "outDir": "./build/main",
    "lib": ["dom"],
  },
  "include": ["src/**/*.ts"],
  "exclude": ["node_modules/**"]
}

```

## ./lib/lambda/node_modules/@aws-crypto/sha1-browser/tsconfig.module.json

```json
{
  "extends": "./tsconfig",
  "compilerOptions": {
    "outDir": "build/module",
    "module": "esnext",
  }
}

```

## ./lib/lambda/node_modules/@aws-crypto/sha256-browser/build/main/constants.d.ts

```typescript
export declare const SHA_256_HASH: {
    name: "SHA-256";
};
export declare const SHA_256_HMAC_ALGO: {
    name: "HMAC";
    hash: {
        name: "SHA-256";
    };
};
export declare const EMPTY_DATA_SHA_256: Uint8Array;

```

## ./lib/lambda/node_modules/@aws-crypto/sha256-browser/build/main/crossPlatformSha256.d.ts

```typescript
import { Checksum, SourceData } from "@aws-sdk/types";
export declare class Sha256 implements Checksum {
    private hash;
    constructor(secret?: SourceData);
    update(data: SourceData, encoding?: "utf8" | "ascii" | "latin1"): void;
    digest(): Promise<Uint8Array>;
    reset(): void;
}

```

## ./lib/lambda/node_modules/@aws-crypto/sha256-browser/build/main/index.d.ts

```typescript
export * from "./crossPlatformSha256";
export { Sha256 as WebCryptoSha256 } from "./webCryptoSha256";

```

## ./lib/lambda/node_modules/@aws-crypto/sha256-browser/build/main/isEmptyData.d.ts

```typescript
import { SourceData } from "@aws-sdk/types";
export declare function isEmptyData(data: SourceData): boolean;

```

## ./lib/lambda/node_modules/@aws-crypto/sha256-browser/build/main/webCryptoSha256.d.ts

```typescript
import { Checksum, SourceData } from "@aws-sdk/types";
export declare class Sha256 implements Checksum {
    private readonly secret?;
    private key;
    private toHash;
    constructor(secret?: SourceData);
    update(data: SourceData): void;
    digest(): Promise<Uint8Array>;
    reset(): void;
}

```

## ./lib/lambda/node_modules/@aws-crypto/sha256-browser/build/module/constants.d.ts

```typescript
export declare const SHA_256_HASH: {
    name: "SHA-256";
};
export declare const SHA_256_HMAC_ALGO: {
    name: "HMAC";
    hash: {
        name: "SHA-256";
    };
};
export declare const EMPTY_DATA_SHA_256: Uint8Array;

```

## ./lib/lambda/node_modules/@aws-crypto/sha256-browser/build/module/crossPlatformSha256.d.ts

```typescript
import { Checksum, SourceData } from "@aws-sdk/types";
export declare class Sha256 implements Checksum {
    private hash;
    constructor(secret?: SourceData);
    update(data: SourceData, encoding?: "utf8" | "ascii" | "latin1"): void;
    digest(): Promise<Uint8Array>;
    reset(): void;
}

```

## ./lib/lambda/node_modules/@aws-crypto/sha256-browser/build/module/index.d.ts

```typescript
export * from "./crossPlatformSha256";
export { Sha256 as WebCryptoSha256 } from "./webCryptoSha256";

```

## ./lib/lambda/node_modules/@aws-crypto/sha256-browser/build/module/isEmptyData.d.ts

```typescript
import { SourceData } from "@aws-sdk/types";
export declare function isEmptyData(data: SourceData): boolean;

```

## ./lib/lambda/node_modules/@aws-crypto/sha256-browser/build/module/webCryptoSha256.d.ts

```typescript
import { Checksum, SourceData } from "@aws-sdk/types";
export declare class Sha256 implements Checksum {
    private readonly secret?;
    private key;
    private toHash;
    constructor(secret?: SourceData);
    update(data: SourceData): void;
    digest(): Promise<Uint8Array>;
    reset(): void;
}

```

## ./lib/lambda/node_modules/@aws-crypto/sha256-browser/node_modules/@smithy/is-array-buffer/dist-types/index.d.ts

```typescript
/**
 * @internal
 */
export declare const isArrayBuffer: (arg: any) => arg is ArrayBuffer;

```

## ./lib/lambda/node_modules/@aws-crypto/sha256-browser/node_modules/@smithy/is-array-buffer/dist-types/ts3.4/index.d.ts

```typescript
/**
 * @internal
 */
export declare const isArrayBuffer: (arg: any) => arg is ArrayBuffer;

```

## ./lib/lambda/node_modules/@aws-crypto/sha256-browser/node_modules/@smithy/is-array-buffer/package.json

```json
{
  "name": "@smithy/is-array-buffer",
  "version": "2.2.0",
  "description": "Provides a function for detecting if an argument is an ArrayBuffer",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline is-array-buffer",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../.prettierignore --write \"**/*.{ts,md,json}\"",
    "test": "yarn g:jest"
  },
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "dependencies": {
    "tslib": "^2.6.2"
  },
  "engines": {
    "node": ">=14.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/awslabs/smithy-typescript/tree/main/packages/is-array-buffer",
  "repository": {
    "type": "git",
    "url": "https://github.com/awslabs/smithy-typescript.git",
    "directory": "packages/is-array-buffer"
  },
  "devDependencies": {
    "@tsconfig/recommended": "1.0.1",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  }
}
```

## ./lib/lambda/node_modules/@aws-crypto/sha256-browser/node_modules/@smithy/util-buffer-from/dist-types/index.d.ts

```typescript
import { Buffer } from "buffer";
/**
 * @internal
 */
export declare const fromArrayBuffer: (input: ArrayBuffer, offset?: number, length?: number) => Buffer;
/**
 * @internal
 */
export type StringEncoding = "ascii" | "utf8" | "utf16le" | "ucs2" | "base64" | "latin1" | "binary" | "hex";
/**
 * @internal
 */
export declare const fromString: (input: string, encoding?: StringEncoding) => Buffer;

```

## ./lib/lambda/node_modules/@aws-crypto/sha256-browser/node_modules/@smithy/util-buffer-from/dist-types/ts3.4/index.d.ts

```typescript
import { Buffer } from "buffer";
/**
 * @internal
 */
export declare const fromArrayBuffer: (input: ArrayBuffer, offset?: number, length?: number) => Buffer;
/**
 * @internal
 */
export type StringEncoding = "ascii" | "utf8" | "utf16le" | "ucs2" | "base64" | "latin1" | "binary" | "hex";
/**
 * @internal
 */
export declare const fromString: (input: string, encoding?: StringEncoding) => Buffer;

```

## ./lib/lambda/node_modules/@aws-crypto/sha256-browser/node_modules/@smithy/util-buffer-from/package.json

```json
{
  "name": "@smithy/util-buffer-from",
  "version": "2.2.0",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline util-buffer-from",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../.prettierignore --write \"**/*.{ts,md,json}\"",
    "test": "yarn g:jest"
  },
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "dependencies": {
    "@smithy/is-array-buffer": "^2.2.0",
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "@tsconfig/recommended": "1.0.1",
    "@types/node": "^14.14.31",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "engines": {
    "node": ">=14.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/awslabs/smithy-typescript/tree/main/packages/util-buffer-from",
  "repository": {
    "type": "git",
    "url": "https://github.com/awslabs/smithy-typescript.git",
    "directory": "packages/util-buffer-from"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  }
}
```

## ./lib/lambda/node_modules/@aws-crypto/sha256-browser/node_modules/@smithy/util-utf8/dist-types/fromUtf8.browser.d.ts

```typescript
export declare const fromUtf8: (input: string) => Uint8Array;

```

## ./lib/lambda/node_modules/@aws-crypto/sha256-browser/node_modules/@smithy/util-utf8/dist-types/fromUtf8.d.ts

```typescript
export declare const fromUtf8: (input: string) => Uint8Array;

```

## ./lib/lambda/node_modules/@aws-crypto/sha256-browser/node_modules/@smithy/util-utf8/dist-types/index.d.ts

```typescript
export * from "./fromUtf8";
export * from "./toUint8Array";
export * from "./toUtf8";

```

## ./lib/lambda/node_modules/@aws-crypto/sha256-browser/node_modules/@smithy/util-utf8/dist-types/toUint8Array.d.ts

```typescript
export declare const toUint8Array: (data: string | ArrayBuffer | ArrayBufferView) => Uint8Array;

```

## ./lib/lambda/node_modules/@aws-crypto/sha256-browser/node_modules/@smithy/util-utf8/dist-types/toUtf8.browser.d.ts

```typescript
/**
 *
 * This does not convert non-utf8 strings to utf8, it only passes through strings if
 * a string is received instead of a Uint8Array.
 *
 */
export declare const toUtf8: (input: Uint8Array | string) => string;

```

## ./lib/lambda/node_modules/@aws-crypto/sha256-browser/node_modules/@smithy/util-utf8/dist-types/toUtf8.d.ts

```typescript
/**
 *
 * This does not convert non-utf8 strings to utf8, it only passes through strings if
 * a string is received instead of a Uint8Array.
 *
 */
export declare const toUtf8: (input: Uint8Array | string) => string;

```

## ./lib/lambda/node_modules/@aws-crypto/sha256-browser/node_modules/@smithy/util-utf8/dist-types/ts3.4/fromUtf8.browser.d.ts

```typescript
export declare const fromUtf8: (input: string) => Uint8Array;

```

## ./lib/lambda/node_modules/@aws-crypto/sha256-browser/node_modules/@smithy/util-utf8/dist-types/ts3.4/fromUtf8.d.ts

```typescript
export declare const fromUtf8: (input: string) => Uint8Array;

```

## ./lib/lambda/node_modules/@aws-crypto/sha256-browser/node_modules/@smithy/util-utf8/dist-types/ts3.4/index.d.ts

```typescript
export * from "./fromUtf8";
export * from "./toUint8Array";
export * from "./toUtf8";

```

## ./lib/lambda/node_modules/@aws-crypto/sha256-browser/node_modules/@smithy/util-utf8/dist-types/ts3.4/toUint8Array.d.ts

```typescript
export declare const toUint8Array: (data: string | ArrayBuffer | ArrayBufferView) => Uint8Array;

```

## ./lib/lambda/node_modules/@aws-crypto/sha256-browser/node_modules/@smithy/util-utf8/dist-types/ts3.4/toUtf8.browser.d.ts

```typescript
/**
 *
 * This does not convert non-utf8 strings to utf8, it only passes through strings if
 * a string is received instead of a Uint8Array.
 *
 */
export declare const toUtf8: (input: Uint8Array | string) => string;

```

## ./lib/lambda/node_modules/@aws-crypto/sha256-browser/node_modules/@smithy/util-utf8/dist-types/ts3.4/toUtf8.d.ts

```typescript
/**
 *
 * This does not convert non-utf8 strings to utf8, it only passes through strings if
 * a string is received instead of a Uint8Array.
 *
 */
export declare const toUtf8: (input: Uint8Array | string) => string;

```

## ./lib/lambda/node_modules/@aws-crypto/sha256-browser/node_modules/@smithy/util-utf8/package.json

```json
{
  "name": "@smithy/util-utf8",
  "version": "2.3.0",
  "description": "A UTF-8 string <-> UInt8Array converter",
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline util-utf8",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../.prettierignore --write \"**/*.{ts,md,json}\"",
    "test": "yarn g:jest"
  },
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "dependencies": {
    "@smithy/util-buffer-from": "^2.2.0",
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "@tsconfig/recommended": "1.0.1",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "types": "./dist-types/index.d.ts",
  "engines": {
    "node": ">=14.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "browser": {
    "./dist-es/fromUtf8": "./dist-es/fromUtf8.browser",
    "./dist-es/toUtf8": "./dist-es/toUtf8.browser"
  },
  "react-native": {},
  "homepage": "https://github.com/awslabs/smithy-typescript/tree/main/packages/util-utf8",
  "repository": {
    "type": "git",
    "url": "https://github.com/awslabs/smithy-typescript.git",
    "directory": "packages/util-utf8"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  }
}
```

## ./lib/lambda/node_modules/@aws-crypto/sha256-browser/package.json

```json
{
  "name": "@aws-crypto/sha256-browser",
  "version": "5.2.0",
  "scripts": {
    "prepublishOnly": "tsc -p tsconfig.json && tsc -p tsconfig.module.json",
    "pretest": "tsc -p tsconfig.test.json",
    "test": "mocha --require ts-node/register test/**/*test.ts"
  },
  "repository": {
    "type": "git",
    "url": "git@github.com:aws/aws-sdk-js-crypto-helpers.git"
  },
  "author": {
    "name": "AWS Crypto Tools Team",
    "email": "aws-cryptools@amazon.com",
    "url": "https://docs.aws.amazon.com/aws-crypto-tools/index.html?id=docs_gateway#lang/en_us"
  },
  "homepage": "https://github.com/aws/aws-sdk-js-crypto-helpers/tree/master/packages/sha256-browser",
  "license": "Apache-2.0",
  "dependencies": {
    "@aws-crypto/sha256-js": "^5.2.0",
    "@aws-crypto/supports-web-crypto": "^5.2.0",
    "@aws-crypto/util": "^5.2.0",
    "@aws-sdk/types": "^3.222.0",
    "@aws-sdk/util-locate-window": "^3.0.0",
    "@smithy/util-utf8": "^2.0.0",
    "tslib": "^2.6.2"
  },
  "main": "./build/main/index.js",
  "module": "./build/module/index.js",
  "types": "./build/main/index.d.ts",
  "gitHead": "c11b171b35ec5c093364f0e0d8dc4ab1af68e748"
}

```

## ./lib/lambda/node_modules/@aws-crypto/sha256-browser/src/constants.ts

```typescript
export const SHA_256_HASH: { name: "SHA-256" } = { name: "SHA-256" };

export const SHA_256_HMAC_ALGO: { name: "HMAC"; hash: { name: "SHA-256" } } = {
  name: "HMAC",
  hash: SHA_256_HASH
};

export const EMPTY_DATA_SHA_256 = new Uint8Array([
  227,
  176,
  196,
  66,
  152,
  252,
  28,
  20,
  154,
  251,
  244,
  200,
  153,
  111,
  185,
  36,
  39,
  174,
  65,
  228,
  100,
  155,
  147,
  76,
  164,
  149,
  153,
  27,
  120,
  82,
  184,
  85
]);

```

## ./lib/lambda/node_modules/@aws-crypto/sha256-browser/src/crossPlatformSha256.ts

```typescript
import { Sha256 as WebCryptoSha256 } from "./webCryptoSha256";
import { Sha256 as JsSha256 } from "@aws-crypto/sha256-js";
import { Checksum, SourceData } from "@aws-sdk/types";
import { supportsWebCrypto } from "@aws-crypto/supports-web-crypto";
import { locateWindow } from "@aws-sdk/util-locate-window";
import { convertToBuffer } from "@aws-crypto/util";

export class Sha256 implements Checksum {
  private hash: Checksum;

  constructor(secret?: SourceData) {
    if (supportsWebCrypto(locateWindow())) {
      this.hash = new WebCryptoSha256(secret);
    } else {
      this.hash = new JsSha256(secret);
    }
  }

  update(data: SourceData, encoding?: "utf8" | "ascii" | "latin1"): void {
    this.hash.update(convertToBuffer(data));
  }

  digest(): Promise<Uint8Array> {
    return this.hash.digest();
  }

  reset(): void {
    this.hash.reset();
  }
}

```

## ./lib/lambda/node_modules/@aws-crypto/sha256-browser/src/index.ts

```typescript
export * from "./crossPlatformSha256";
export { Sha256 as WebCryptoSha256 } from "./webCryptoSha256";

```

## ./lib/lambda/node_modules/@aws-crypto/sha256-browser/src/isEmptyData.ts

```typescript
import { SourceData } from "@aws-sdk/types";

export function isEmptyData(data: SourceData): boolean {
  if (typeof data === "string") {
    return data.length === 0;
  }

  return data.byteLength === 0;
}

```

## ./lib/lambda/node_modules/@aws-crypto/sha256-browser/src/webCryptoSha256.ts

```typescript
import { Checksum, SourceData } from "@aws-sdk/types";
import { isEmptyData, convertToBuffer } from "@aws-crypto/util";
import {
  EMPTY_DATA_SHA_256,
  SHA_256_HASH,
  SHA_256_HMAC_ALGO,
} from "./constants";
import { locateWindow } from "@aws-sdk/util-locate-window";

export class Sha256 implements Checksum {
  private readonly secret?: SourceData;
  private key: Promise<CryptoKey> | undefined;
  private toHash: Uint8Array = new Uint8Array(0);

  constructor(secret?: SourceData) {
    this.secret = secret;
    this.reset();
  }

  update(data: SourceData): void {
    if (isEmptyData(data)) {
      return;
    }

    const update = convertToBuffer(data);
    const typedArray = new Uint8Array(
      this.toHash.byteLength + update.byteLength
    );
    typedArray.set(this.toHash, 0);
    typedArray.set(update, this.toHash.byteLength);
    this.toHash = typedArray;
  }

  digest(): Promise<Uint8Array> {
    if (this.key) {
      return this.key.then((key) =>
        locateWindow()
          .crypto.subtle.sign(SHA_256_HMAC_ALGO, key, this.toHash)
          .then((data) => new Uint8Array(data))
      );
    }

    if (isEmptyData(this.toHash)) {
      return Promise.resolve(EMPTY_DATA_SHA_256);
    }

    return Promise.resolve()
      .then(() =>
        locateWindow().crypto.subtle.digest(SHA_256_HASH, this.toHash)
      )
      .then((data) => Promise.resolve(new Uint8Array(data)));
  }

  reset(): void {
    this.toHash = new Uint8Array(0);
    if (this.secret && this.secret !== void 0) {
      this.key = new Promise((resolve, reject) => {
        locateWindow()
            .crypto.subtle.importKey(
            "raw",
            convertToBuffer(this.secret as SourceData),
            SHA_256_HMAC_ALGO,
            false,
            ["sign"]
        )
            .then(resolve, reject);
      });
      this.key.catch(() => {});
    }
  }
}

```

## ./lib/lambda/node_modules/@aws-crypto/sha256-browser/tsconfig.json

```json
{
  "extends": "../tsconfig.json",
  "compilerOptions": {
    "rootDir": "./src",
    "outDir": "./build/main",
    "lib": ["dom"],
  },
  "include": ["src/**/*.ts"],
  "exclude": ["node_modules/**"]
}

```

## ./lib/lambda/node_modules/@aws-crypto/sha256-browser/tsconfig.module.json

```json
{
  "extends": "./tsconfig",
  "compilerOptions": {
    "outDir": "build/module",
    "module": "esnext",
  }
}

```

## ./lib/lambda/node_modules/@aws-crypto/sha256-js/build/main/RawSha256.d.ts

```typescript
/**
 * @internal
 */
export declare class RawSha256 {
    private state;
    private temp;
    private buffer;
    private bufferLength;
    private bytesHashed;
    /**
     * @internal
     */
    finished: boolean;
    update(data: Uint8Array): void;
    digest(): Uint8Array;
    private hashBuffer;
}

```

## ./lib/lambda/node_modules/@aws-crypto/sha256-js/build/main/constants.d.ts

```typescript
/**
 * @internal
 */
export declare const BLOCK_SIZE: number;
/**
 * @internal
 */
export declare const DIGEST_LENGTH: number;
/**
 * @internal
 */
export declare const KEY: Uint32Array;
/**
 * @internal
 */
export declare const INIT: number[];
/**
 * @internal
 */
export declare const MAX_HASHABLE_LENGTH: number;

```

## ./lib/lambda/node_modules/@aws-crypto/sha256-js/build/main/index.d.ts

```typescript
export * from "./jsSha256";

```

## ./lib/lambda/node_modules/@aws-crypto/sha256-js/build/main/jsSha256.d.ts

```typescript
import { Checksum, SourceData } from "@aws-sdk/types";
export declare class Sha256 implements Checksum {
    private readonly secret?;
    private hash;
    private outer?;
    private error;
    constructor(secret?: SourceData);
    update(toHash: SourceData): void;
    digestSync(): Uint8Array;
    digest(): Promise<Uint8Array>;
    reset(): void;
}

```

## ./lib/lambda/node_modules/@aws-crypto/sha256-js/build/main/knownHashes.fixture.d.ts

```typescript
export declare const hashTestVectors: Array<[Uint8Array, Uint8Array]>;
/**
 * @see https://tools.ietf.org/html/rfc4231
 */
export declare const hmacTestVectors: Array<[Uint8Array, Uint8Array, Uint8Array]>;

```

## ./lib/lambda/node_modules/@aws-crypto/sha256-js/build/module/RawSha256.d.ts

```typescript
/**
 * @internal
 */
export declare class RawSha256 {
    private state;
    private temp;
    private buffer;
    private bufferLength;
    private bytesHashed;
    /**
     * @internal
     */
    finished: boolean;
    update(data: Uint8Array): void;
    digest(): Uint8Array;
    private hashBuffer;
}

```

## ./lib/lambda/node_modules/@aws-crypto/sha256-js/build/module/constants.d.ts

```typescript
/**
 * @internal
 */
export declare const BLOCK_SIZE: number;
/**
 * @internal
 */
export declare const DIGEST_LENGTH: number;
/**
 * @internal
 */
export declare const KEY: Uint32Array;
/**
 * @internal
 */
export declare const INIT: number[];
/**
 * @internal
 */
export declare const MAX_HASHABLE_LENGTH: number;

```

## ./lib/lambda/node_modules/@aws-crypto/sha256-js/build/module/index.d.ts

```typescript
export * from "./jsSha256";

```

## ./lib/lambda/node_modules/@aws-crypto/sha256-js/build/module/jsSha256.d.ts

```typescript
import { Checksum, SourceData } from "@aws-sdk/types";
export declare class Sha256 implements Checksum {
    private readonly secret?;
    private hash;
    private outer?;
    private error;
    constructor(secret?: SourceData);
    update(toHash: SourceData): void;
    digestSync(): Uint8Array;
    digest(): Promise<Uint8Array>;
    reset(): void;
}

```

## ./lib/lambda/node_modules/@aws-crypto/sha256-js/build/module/knownHashes.fixture.d.ts

```typescript
export declare const hashTestVectors: Array<[Uint8Array, Uint8Array]>;
/**
 * @see https://tools.ietf.org/html/rfc4231
 */
export declare const hmacTestVectors: Array<[Uint8Array, Uint8Array, Uint8Array]>;

```

## ./lib/lambda/node_modules/@aws-crypto/sha256-js/package.json

```json
{
  "name": "@aws-crypto/sha256-js",
  "version": "5.2.0",
  "scripts": {
    "prepublishOnly": "tsc -p tsconfig.json && tsc -p tsconfig.module.json",
    "pretest": "tsc -p tsconfig.test.json",
    "test": "mocha --require ts-node/register test/**/*test.ts"
  },
  "main": "./build/main/index.js",
  "module": "./build/module/index.js",
  "types": "./build/main/index.d.ts",
  "repository": {
    "type": "git",
    "url": "git@github.com:aws/aws-sdk-js-crypto-helpers.git"
  },
  "author": {
    "name": "AWS Crypto Tools Team",
    "email": "aws-cryptools@amazon.com",
    "url": "https://docs.aws.amazon.com/aws-crypto-tools/index.html?id=docs_gateway#lang/en_us"
  },
  "homepage": "https://github.com/aws/aws-sdk-js-crypto-helpers/tree/master/packages/sha256-js",
  "license": "Apache-2.0",
  "dependencies": {
    "@aws-crypto/util": "^5.2.0",
    "@aws-sdk/types": "^3.222.0",
    "tslib": "^2.6.2"
  },
  "engines": {
    "node": ">=16.0.0"
  },
  "gitHead": "c11b171b35ec5c093364f0e0d8dc4ab1af68e748"
}

```

## ./lib/lambda/node_modules/@aws-crypto/sha256-js/src/RawSha256.ts

```typescript
import {
  BLOCK_SIZE,
  DIGEST_LENGTH,
  INIT,
  KEY,
  MAX_HASHABLE_LENGTH
} from "./constants";

/**
 * @internal
 */
export class RawSha256 {
  private state: Int32Array = Int32Array.from(INIT);
  private temp: Int32Array = new Int32Array(64);
  private buffer: Uint8Array = new Uint8Array(64);
  private bufferLength: number = 0;
  private bytesHashed: number = 0;

  /**
   * @internal
   */
  finished: boolean = false;

  update(data: Uint8Array): void {
    if (this.finished) {
      throw new Error("Attempted to update an already finished hash.");
    }

    let position = 0;
    let { byteLength } = data;
    this.bytesHashed += byteLength;

    if (this.bytesHashed * 8 > MAX_HASHABLE_LENGTH) {
      throw new Error("Cannot hash more than 2^53 - 1 bits");
    }

    while (byteLength > 0) {
      this.buffer[this.bufferLength++] = data[position++];
      byteLength--;

      if (this.bufferLength === BLOCK_SIZE) {
        this.hashBuffer();
        this.bufferLength = 0;
      }
    }
  }

  digest(): Uint8Array {
    if (!this.finished) {
      const bitsHashed = this.bytesHashed * 8;
      const bufferView = new DataView(
        this.buffer.buffer,
        this.buffer.byteOffset,
        this.buffer.byteLength
      );

      const undecoratedLength = this.bufferLength;
      bufferView.setUint8(this.bufferLength++, 0x80);

      // Ensure the final block has enough room for the hashed length
      if (undecoratedLength % BLOCK_SIZE >= BLOCK_SIZE - 8) {
        for (let i = this.bufferLength; i < BLOCK_SIZE; i++) {
          bufferView.setUint8(i, 0);
        }
        this.hashBuffer();
        this.bufferLength = 0;
      }

      for (let i = this.bufferLength; i < BLOCK_SIZE - 8; i++) {
        bufferView.setUint8(i, 0);
      }
      bufferView.setUint32(
        BLOCK_SIZE - 8,
        Math.floor(bitsHashed / 0x100000000),
        true
      );
      bufferView.setUint32(BLOCK_SIZE - 4, bitsHashed);

      this.hashBuffer();

      this.finished = true;
    }

    // The value in state is little-endian rather than big-endian, so flip
    // each word into a new Uint8Array
    const out = new Uint8Array(DIGEST_LENGTH);
    for (let i = 0; i < 8; i++) {
      out[i * 4] = (this.state[i] >>> 24) & 0xff;
      out[i * 4 + 1] = (this.state[i] >>> 16) & 0xff;
      out[i * 4 + 2] = (this.state[i] >>> 8) & 0xff;
      out[i * 4 + 3] = (this.state[i] >>> 0) & 0xff;
    }

    return out;
  }

  private hashBuffer(): void {
    const { buffer, state } = this;

    let state0 = state[0],
      state1 = state[1],
      state2 = state[2],
      state3 = state[3],
      state4 = state[4],
      state5 = state[5],
      state6 = state[6],
      state7 = state[7];

    for (let i = 0; i < BLOCK_SIZE; i++) {
      if (i < 16) {
        this.temp[i] =
          ((buffer[i * 4] & 0xff) << 24) |
          ((buffer[i * 4 + 1] & 0xff) << 16) |
          ((buffer[i * 4 + 2] & 0xff) << 8) |
          (buffer[i * 4 + 3] & 0xff);
      } else {
        let u = this.temp[i - 2];
        const t1 =
          ((u >>> 17) | (u << 15)) ^ ((u >>> 19) | (u << 13)) ^ (u >>> 10);

        u = this.temp[i - 15];
        const t2 =
          ((u >>> 7) | (u << 25)) ^ ((u >>> 18) | (u << 14)) ^ (u >>> 3);

        this.temp[i] =
          ((t1 + this.temp[i - 7]) | 0) + ((t2 + this.temp[i - 16]) | 0);
      }

      const t1 =
        ((((((state4 >>> 6) | (state4 << 26)) ^
          ((state4 >>> 11) | (state4 << 21)) ^
          ((state4 >>> 25) | (state4 << 7))) +
          ((state4 & state5) ^ (~state4 & state6))) |
          0) +
          ((state7 + ((KEY[i] + this.temp[i]) | 0)) | 0)) |
        0;

      const t2 =
        ((((state0 >>> 2) | (state0 << 30)) ^
          ((state0 >>> 13) | (state0 << 19)) ^
          ((state0 >>> 22) | (state0 << 10))) +
          ((state0 & state1) ^ (state0 & state2) ^ (state1 & state2))) |
        0;

      state7 = state6;
      state6 = state5;
      state5 = state4;
      state4 = (state3 + t1) | 0;
      state3 = state2;
      state2 = state1;
      state1 = state0;
      state0 = (t1 + t2) | 0;
    }

    state[0] += state0;
    state[1] += state1;
    state[2] += state2;
    state[3] += state3;
    state[4] += state4;
    state[5] += state5;
    state[6] += state6;
    state[7] += state7;
  }
}

```

## ./lib/lambda/node_modules/@aws-crypto/sha256-js/src/constants.ts

```typescript
/**
 * @internal
 */
export const BLOCK_SIZE: number = 64;

/**
 * @internal
 */
export const DIGEST_LENGTH: number = 32;

/**
 * @internal
 */
export const KEY = new Uint32Array([
  0x428a2f98,
  0x71374491,
  0xb5c0fbcf,
  0xe9b5dba5,
  0x3956c25b,
  0x59f111f1,
  0x923f82a4,
  0xab1c5ed5,
  0xd807aa98,
  0x12835b01,
  0x243185be,
  0x550c7dc3,
  0x72be5d74,
  0x80deb1fe,
  0x9bdc06a7,
  0xc19bf174,
  0xe49b69c1,
  0xefbe4786,
  0x0fc19dc6,
  0x240ca1cc,
  0x2de92c6f,
  0x4a7484aa,
  0x5cb0a9dc,
  0x76f988da,
  0x983e5152,
  0xa831c66d,
  0xb00327c8,
  0xbf597fc7,
  0xc6e00bf3,
  0xd5a79147,
  0x06ca6351,
  0x14292967,
  0x27b70a85,
  0x2e1b2138,
  0x4d2c6dfc,
  0x53380d13,
  0x650a7354,
  0x766a0abb,
  0x81c2c92e,
  0x92722c85,
  0xa2bfe8a1,
  0xa81a664b,
  0xc24b8b70,
  0xc76c51a3,
  0xd192e819,
  0xd6990624,
  0xf40e3585,
  0x106aa070,
  0x19a4c116,
  0x1e376c08,
  0x2748774c,
  0x34b0bcb5,
  0x391c0cb3,
  0x4ed8aa4a,
  0x5b9cca4f,
  0x682e6ff3,
  0x748f82ee,
  0x78a5636f,
  0x84c87814,
  0x8cc70208,
  0x90befffa,
  0xa4506ceb,
  0xbef9a3f7,
  0xc67178f2
]);

/**
 * @internal
 */
export const INIT = [
  0x6a09e667,
  0xbb67ae85,
  0x3c6ef372,
  0xa54ff53a,
  0x510e527f,
  0x9b05688c,
  0x1f83d9ab,
  0x5be0cd19
];

/**
 * @internal
 */
export const MAX_HASHABLE_LENGTH = 2 ** 53 - 1;

```

## ./lib/lambda/node_modules/@aws-crypto/sha256-js/src/index.ts

```typescript
export * from "./jsSha256";

```

## ./lib/lambda/node_modules/@aws-crypto/sha256-js/src/jsSha256.ts

```typescript
import { BLOCK_SIZE } from "./constants";
import { RawSha256 } from "./RawSha256";
import { Checksum, SourceData } from "@aws-sdk/types";
import { isEmptyData, convertToBuffer } from "@aws-crypto/util";

export class Sha256 implements Checksum {
  private readonly secret?: SourceData;
  private hash: RawSha256;
  private outer?: RawSha256;
  private error: any;

  constructor(secret?: SourceData) {
    this.secret = secret;
    this.hash = new RawSha256();
    this.reset();
  }

  update(toHash: SourceData): void {
    if (isEmptyData(toHash) || this.error) {
      return;
    }

    try {
      this.hash.update(convertToBuffer(toHash));
    } catch (e) {
      this.error = e;
    }
  }

  /* This synchronous method keeps compatibility
   * with the v2 aws-sdk.
   */
  digestSync(): Uint8Array {
    if (this.error) {
      throw this.error;
    }

    if (this.outer) {
      if (!this.outer.finished) {
        this.outer.update(this.hash.digest());
      }

      return this.outer.digest();
    }

    return this.hash.digest();
  }

  /* The underlying digest method here is synchronous.
   * To keep the same interface with the other hash functions
   * the default is to expose this as an async method.
   * However, it can sometimes be useful to have a sync method.
   */
  async digest(): Promise<Uint8Array> {
    return this.digestSync();
  }

  reset(): void {
    this.hash = new RawSha256();
    if (this.secret) {
      this.outer = new RawSha256();
      const inner = bufferFromSecret(this.secret);
      const outer = new Uint8Array(BLOCK_SIZE);
      outer.set(inner);

      for (let i = 0; i < BLOCK_SIZE; i++) {
        inner[i] ^= 0x36;
        outer[i] ^= 0x5c;
      }

      this.hash.update(inner);
      this.outer.update(outer);

      // overwrite the copied key in memory
      for (let i = 0; i < inner.byteLength; i++) {
        inner[i] = 0;
      }
    }
  }
}

function bufferFromSecret(secret: SourceData): Uint8Array {
  let input = convertToBuffer(secret);

  if (input.byteLength > BLOCK_SIZE) {
    const bufferHash = new RawSha256();
    bufferHash.update(input);
    input = bufferHash.digest();
  }

  const buffer = new Uint8Array(BLOCK_SIZE);
  buffer.set(input);
  return buffer;
}

```

## ./lib/lambda/node_modules/@aws-crypto/sha256-js/src/knownHashes.fixture.ts

```typescript
import { fromHex } from "@aws-sdk/util-hex-encoding";

const millionChars = new Uint8Array(1000000);
for (let i = 0; i < 1000000; i++) {
  millionChars[i] = 97;
}

export const hashTestVectors: Array<[Uint8Array, Uint8Array]> = [
  [
    Uint8Array.from([97, 98, 99]),
    fromHex("ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad")
  ],
  [
    new Uint8Array(0),
    fromHex("e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855")
  ],
  [
    fromHex("61"),
    fromHex("ca978112ca1bbdcafac231b39a23dc4da786eff8147c4e72b9807785afee48bb")
  ],
  [
    fromHex("6161"),
    fromHex("961b6dd3ede3cb8ecbaacbd68de040cd78eb2ed5889130cceb4c49268ea4d506")
  ],
  [
    fromHex("616161"),
    fromHex("9834876dcfb05cb167a5c24953eba58c4ac89b1adf57f28f2f9d09af107ee8f0")
  ],
  [
    fromHex("61616161"),
    fromHex("61be55a8e2f6b4e172338bddf184d6dbee29c98853e0a0485ecee7f27b9af0b4")
  ],
  [
    fromHex("6161616161"),
    fromHex("ed968e840d10d2d313a870bc131a4e2c311d7ad09bdf32b3418147221f51a6e2")
  ],
  [
    fromHex("616161616161"),
    fromHex("ed02457b5c41d964dbd2f2a609d63fe1bb7528dbe55e1abf5b52c249cd735797")
  ],
  [
    fromHex("61616161616161"),
    fromHex("e46240714b5db3a23eee60479a623efba4d633d27fe4f03c904b9e219a7fbe60")
  ],
  [
    fromHex("6161616161616161"),
    fromHex("1f3ce40415a2081fa3eee75fc39fff8e56c22270d1a978a7249b592dcebd20b4")
  ],
  [
    fromHex("616161616161616161"),
    fromHex("f2aca93b80cae681221f0445fa4e2cae8a1f9f8fa1e1741d9639caad222f537d")
  ],
  [
    fromHex("61616161616161616161"),
    fromHex("bf2cb58a68f684d95a3b78ef8f661c9a4e5b09e82cc8f9cc88cce90528caeb27")
  ],
  [
    fromHex("6161616161616161616161"),
    fromHex("28cb017dfc99073aa1b47c1b30f413e3ce774c4991eb4158de50f9dbb36d8043")
  ],
  [
    fromHex("616161616161616161616161"),
    fromHex("f24abc34b13fade76e805799f71187da6cd90b9cac373ae65ed57f143bd664e5")
  ],
  [
    fromHex("61616161616161616161616161"),
    fromHex("a689d786e81340e45511dec6c7ab2d978434e5db123362450fe10cfac70d19d0")
  ],
  [
    fromHex("6161616161616161616161616161"),
    fromHex("82cab7df0abfb9d95dca4e5937ce2968c798c726fea48c016bf9763221efda13")
  ],
  [
    fromHex("616161616161616161616161616161"),
    fromHex("ef2df0b539c6c23de0f4cbe42648c301ae0e22e887340a4599fb4ef4e2678e48")
  ],
  [
    fromHex("61616161616161616161616161616161"),
    fromHex("0c0beacef8877bbf2416eb00f2b5dc96354e26dd1df5517320459b1236860f8c")
  ],
  [
    fromHex("6161616161616161616161616161616161"),
    fromHex("b860666ee2966dd8f903be44ee605c6e1366f926d9f17a8f49937d11624eb99d")
  ],
  [
    fromHex("616161616161616161616161616161616161"),
    fromHex("c926defaaa3d13eda2fc63a553bb7fb7326bece6e7cb67ca5296e4727d89bab4")
  ],
  [
    fromHex("61616161616161616161616161616161616161"),
    fromHex("a0b4aaab8a966e2193ba172d68162c4656860197f256b5f45f0203397ff3f99c")
  ],
  [
    fromHex("6161616161616161616161616161616161616161"),
    fromHex("42492da06234ad0ac76f5d5debdb6d1ae027cffbe746a1c13b89bb8bc0139137")
  ],
  [
    fromHex("616161616161616161616161616161616161616161"),
    fromHex("7df8e299c834de198e264c3e374bc58ecd9382252a705c183beb02f275571e3b")
  ],
  [
    fromHex("61616161616161616161616161616161616161616161"),
    fromHex("ec7c494df6d2a7ea36668d656e6b8979e33641bfea378c15038af3964db057a3")
  ],
  [
    fromHex("6161616161616161616161616161616161616161616161"),
    fromHex("897d3e95b65f26676081f8b9f3a98b6ee4424566303e8d4e7c7522ebae219eab")
  ],
  [
    fromHex("616161616161616161616161616161616161616161616161"),
    fromHex("09f61f8d9cd65e6a0c258087c485b6293541364e42bd97b2d7936580c8aa3c54")
  ],
  [
    fromHex("61616161616161616161616161616161616161616161616161"),
    fromHex("2f521e2a7d0bd812cbc035f4ed6806eb8d851793b04ba147e8f66b72f5d1f20f")
  ],
  [
    fromHex("6161616161616161616161616161616161616161616161616161"),
    fromHex("9976d549a25115dab4e36d0c1fb8f31cb07da87dd83275977360eb7dc09e88de")
  ],
  [
    fromHex("616161616161616161616161616161616161616161616161616161"),
    fromHex("cc0616e61cbd6e8e5e34e9fb2d320f37de915820206f5696c31f1fbd24aa16de")
  ],
  [
    fromHex("61616161616161616161616161616161616161616161616161616161"),
    fromHex("9c547cb8115a44883b9f70ba68f75117cd55359c92611875e386f8af98c172ab")
  ],
  [
    fromHex("6161616161616161616161616161616161616161616161616161616161"),
    fromHex("6913c9c7fd42fe23df8b6bcd4dbaf1c17748948d97f2980b432319c39eddcf6c")
  ],
  [
    fromHex("616161616161616161616161616161616161616161616161616161616161"),
    fromHex("3a54fc0cbc0b0ef48b6507b7788096235d10292dd3ae24e22f5aa062d4f9864a")
  ],
  [
    fromHex("61616161616161616161616161616161616161616161616161616161616161"),
    fromHex("61c60b487d1a921e0bcc9bf853dda0fb159b30bf57b2e2d2c753b00be15b5a09")
  ],
  [
    fromHex("6161616161616161616161616161616161616161616161616161616161616161"),
    fromHex("3ba3f5f43b92602683c19aee62a20342b084dd5971ddd33808d81a328879a547")
  ],
  [
    fromHex(
      "616161616161616161616161616161616161616161616161616161616161616161"
    ),
    fromHex("852785c805c77e71a22340a54e9d95933ed49121e7d2bf3c2d358854bc1359ea")
  ],
  [
    fromHex(
      "61616161616161616161616161616161616161616161616161616161616161616161"
    ),
    fromHex("a27c896c4859204843166af66f0e902b9c3b3ed6d2fd13d435abc020065c526f")
  ],
  [
    fromHex(
      "6161616161616161616161616161616161616161616161616161616161616161616161"
    ),
    fromHex("629362afc62c74497caed2272e30f8125ecd0965f8d8d7cfc4e260f7f8dd319d")
  ],
  [
    fromHex(
      "616161616161616161616161616161616161616161616161616161616161616161616161"
    ),
    fromHex("22c1d24bcd03e9aee9832efccd6da613fc702793178e5f12c945c7b67ddda933")
  ],
  [
    fromHex(
      "61616161616161616161616161616161616161616161616161616161616161616161616161"
    ),
    fromHex("21ec055b38ce759cd4d0f477e9bdec2c5b8199945db4439bae334a964df6246c")
  ],
  [
    fromHex(
      "6161616161616161616161616161616161616161616161616161616161616161616161616161"
    ),
    fromHex("365a9c3e2c2af0a56e47a9dac51c2c5381bf8f41273bad3175e0e619126ad087")
  ],
  [
    fromHex(
      "616161616161616161616161616161616161616161616161616161616161616161616161616161"
    ),
    fromHex("b4d5e56e929ba4cda349e9274e3603d0be246b82016bca20f363963c5f2d6845")
  ],
  [
    fromHex(
      "61616161616161616161616161616161616161616161616161616161616161616161616161616161"
    ),
    fromHex("e33cdf9c7f7120b98e8c78408953e07f2ecd183006b5606df349b4c212acf43e")
  ],
  [
    fromHex(
      "6161616161616161616161616161616161616161616161616161616161616161616161616161616161"
    ),
    fromHex("c0f8bd4dbc2b0c03107c1c37913f2a7501f521467f45dd0fef6958e9a4692719")
  ],
  [
    fromHex(
      "616161616161616161616161616161616161616161616161616161616161616161616161616161616161"
    ),
    fromHex("7a538607fdaab9296995929f451565bbb8142e1844117322aafd2b3d76b01aff")
  ],
  [
    fromHex(
      "61616161616161616161616161616161616161616161616161616161616161616161616161616161616161"
    ),
    fromHex("66d34fba71f8f450f7e45598853e53bfc23bbd129027cbb131a2f4ffd7878cd0")
  ],
  [
    fromHex(
      "6161616161616161616161616161616161616161616161616161616161616161616161616161616161616161"
    ),
    fromHex("16849877c6c21ef0bfa68e4f6747300ddb171b170b9f00e189edc4c2fc4db93e")
  ],
  [
    fromHex(
      "616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161"
    ),
    fromHex("52789e3423b72beeb898456a4f49662e46b0cbb960784c5ef4b1399d327e7c27")
  ],
  [
    fromHex(
      "61616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161"
    ),
    fromHex("6643110c5628fff59edf76d82d5bf573bf800f16a4d65dfb1e5d6f1a46296d0b")
  ],
  [
    fromHex(
      "6161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161"
    ),
    fromHex("11eaed932c6c6fddfc2efc394e609facf4abe814fc6180d03b14fce13a07d0e5")
  ],
  [
    fromHex(
      "616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161"
    ),
    fromHex("97daac0ee9998dfcad6c9c0970da5ca411c86233a944c25b47566f6a7bc1ddd5")
  ],
  [
    fromHex(
      "61616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161"
    ),
    fromHex("8f9bec6a62dd28ebd36d1227745592de6658b36974a3bb98a4c582f683ea6c42")
  ],
  [
    fromHex(
      "6161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161"
    ),
    fromHex("160b4e433e384e05e537dc59b467f7cb2403f0214db15c5db58862a3f1156d2e")
  ],
  [
    fromHex(
      "616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161"
    ),
    fromHex("bfc5fe0e360152ca98c50fab4ed7e3078c17debc2917740d5000913b686ca129")
  ],
  [
    fromHex(
      "61616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161"
    ),
    fromHex("6c1b3dc7a706b9dc81352a6716b9c666c608d8626272c64b914ab05572fc6e84")
  ],
  [
    fromHex(
      "6161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161"
    ),
    fromHex("abe346a7259fc90b4c27185419628e5e6af6466b1ae9b5446cac4bfc26cf05c4")
  ],
  [
    fromHex(
      "616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161"
    ),
    fromHex("a3f01b6939256127582ac8ae9fb47a382a244680806a3f613a118851c1ca1d47")
  ],
  [
    fromHex(
      "61616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161"
    ),
    fromHex("9f4390f8d30c2dd92ec9f095b65e2b9ae9b0a925a5258e241c9f1e910f734318")
  ],
  [
    fromHex(
      "6161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161"
    ),
    fromHex("b35439a4ac6f0948b6d6f9e3c6af0f5f590ce20f1bde7090ef7970686ec6738a")
  ],
  [
    fromHex(
      "616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161"
    ),
    fromHex("f13b2d724659eb3bf47f2dd6af1accc87b81f09f59f2b75e5c0bed6589dfe8c6")
  ],
  [
    fromHex(
      "61616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161"
    ),
    fromHex("d5c039b748aa64665782974ec3dc3025c042edf54dcdc2b5de31385b094cb678")
  ],
  [
    fromHex(
      "6161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161"
    ),
    fromHex("111bb261277afd65f0744b247cd3e47d386d71563d0ed995517807d5ebd4fba3")
  ],
  [
    fromHex(
      "616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161"
    ),
    fromHex("11ee391211c6256460b6ed375957fadd8061cafbb31daf967db875aebd5aaad4")
  ],
  [
    fromHex(
      "61616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161"
    ),
    fromHex("35d5fc17cfbbadd00f5e710ada39f194c5ad7c766ad67072245f1fad45f0f530")
  ],
  [
    fromHex(
      "6161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161"
    ),
    fromHex("f506898cc7c2e092f9eb9fadae7ba50383f5b46a2a4fe5597dbb553a78981268")
  ],
  [
    fromHex(
      "616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161"
    ),
    fromHex("7d3e74a05d7db15bce4ad9ec0658ea98e3f06eeecf16b4c6fff2da457ddc2f34")
  ],
  [
    fromHex(
      "61616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161616161"
    ),
    fromHex("ffe054fe7ae0cb6dc65c3af9b61d5209f439851db43d0ba5997337df154668eb")
  ],
  [
    fromHex(
      "de188941a3375d3a8a061e67576e926dc71a7fa3f0cceb97452b4d3227965f9ea8cc75076d9fb9c5417aa5cb30fc22198b34982dbb629e"
    ),
    fromHex("038051e9c324393bd1ca1978dd0952c2aa3742ca4f1bd5cd4611cea83892d382")
  ],
  [
    millionChars,
    fromHex("cdc76e5c9914fb9281a1c7e284d73e67f1809a48a497200e046d39ccc7112cd0")
  ],
  [
    fromHex(
      "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
    ),
    fromHex("45ad4b37c6e2fc0a2cfcc1b5da524132ec707615c2cae1dbbc43c97aa521db81")
  ]
];

/**
 * @see https://tools.ietf.org/html/rfc4231
 */
export const hmacTestVectors: Array<[Uint8Array, Uint8Array, Uint8Array]> = [
  [
    fromHex("0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b"),
    fromHex("4869205468657265"),
    fromHex("b0344c61d8db38535ca8afceaf0bf12b881dc200c9833da726e9376c2e32cff7")
  ],
  [
    fromHex("4a656665"),
    fromHex("7768617420646f2079612077616e7420666f72206e6f7468696e673f"),
    fromHex("5bdcc146bf60754e6a042426089575c75a003f089d2739839dec58b964ec3843")
  ],
  [
    fromHex("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"),
    fromHex(
      "dddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd"
    ),
    fromHex("773ea91e36800e46854db8ebd09181a72959098b3ef8c122d9635514ced565fe")
  ],
  [
    fromHex("0102030405060708090a0b0c0d0e0f10111213141516171819"),
    fromHex(
      "cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd"
    ),
    fromHex("82558a389a443c0ea4cc819899f2083a85f0faa3e578f8077a2e3ff46729665b")
  ],
  [
    fromHex(
      "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
    ),
    fromHex(
      "54657374205573696e67204c6172676572205468616e20426c6f636b2d53697a65204b6579202d2048617368204b6579204669727374"
    ),
    fromHex("60e431591ee0b67f0d8a26aacbf5b77f8e0bc6213728c5140546040f0ee37f54")
  ],
  [
    fromHex(
      "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
    ),
    fromHex(
      "5468697320697320612074657374207573696e672061206c6172676572207468616e20626c6f636b2d73697a65206b657920616e642061206c6172676572207468616e20626c6f636b2d73697a6520646174612e20546865206b6579206e6565647320746f20626520686173686564206265666f7265206265696e6720757365642062792074686520484d414320616c676f726974686d2e"
    ),
    fromHex("9b09ffa71b942fcb27635fbcd5b0e944bfdc63644f0713938a7f51535c3a35e2")
  ]
];

```

## ./lib/lambda/node_modules/@aws-crypto/sha256-js/tsconfig.json

```json
{
  "extends": "../tsconfig.json",
  "compilerOptions": {
    "rootDir": "./src",
    "outDir": "./build/main",
    "lib": ["dom"],
  },
  "include": ["src/**/*.ts"],
  "exclude": ["node_modules/**"]
}

```

## ./lib/lambda/node_modules/@aws-crypto/sha256-js/tsconfig.module.json

```json
{
  "extends": "./tsconfig",
  "compilerOptions": {
    "outDir": "build/module",
    "module": "esnext",
  }
}

```

## ./lib/lambda/node_modules/@aws-crypto/supports-web-crypto/build/main/index.d.ts

```typescript
export * from "./supportsWebCrypto";

```

## ./lib/lambda/node_modules/@aws-crypto/supports-web-crypto/build/main/supportsWebCrypto.d.ts

```typescript
export declare function supportsWebCrypto(window: Window): boolean;
export declare function supportsSecureRandom(window: Window): boolean;
export declare function supportsSubtleCrypto(subtle: SubtleCrypto): boolean;
export declare function supportsZeroByteGCM(subtle: SubtleCrypto): Promise<boolean>;

```

## ./lib/lambda/node_modules/@aws-crypto/supports-web-crypto/build/module/index.d.ts

```typescript
export * from "./supportsWebCrypto";

```

## ./lib/lambda/node_modules/@aws-crypto/supports-web-crypto/build/module/supportsWebCrypto.d.ts

```typescript
export declare function supportsWebCrypto(window: Window): boolean;
export declare function supportsSecureRandom(window: Window): boolean;
export declare function supportsSubtleCrypto(subtle: SubtleCrypto): boolean;
export declare function supportsZeroByteGCM(subtle: SubtleCrypto): Promise<boolean>;

```

## ./lib/lambda/node_modules/@aws-crypto/supports-web-crypto/package.json

```json
{
  "name": "@aws-crypto/supports-web-crypto",
  "version": "5.2.0",
  "description": "Provides functions for detecting if the host environment supports the WebCrypto API",
  "scripts": {
    "prepublishOnly": "tsc -p tsconfig.json && tsc -p tsconfig.module.json",
    "pretest": "tsc -p tsconfig.test.json",
    "test": "mocha --require ts-node/register test/**/*test.ts"
  },
  "repository": {
    "type": "git",
    "url": "git@github.com:aws/aws-sdk-js-crypto-helpers.git"
  },
  "author": {
    "name": "AWS Crypto Tools Team",
    "email": "aws-cryptools@amazon.com",
    "url": "https://docs.aws.amazon.com/aws-crypto-tools/index.html?id=docs_gateway#lang/en_us"
  },
  "homepage": "https://github.com/aws/aws-sdk-js-crypto-helpers/tree/master/packages/supports-web-crypto",
  "license": "Apache-2.0",
  "main": "./build/main/index.js",
  "module": "./build/module/index.js",
  "types": "./build/main/index.d.ts",
  "dependencies": {
    "tslib": "^2.6.2"
  },
  "gitHead": "c11b171b35ec5c093364f0e0d8dc4ab1af68e748"
}

```

## ./lib/lambda/node_modules/@aws-crypto/supports-web-crypto/src/index.ts

```typescript
export * from "./supportsWebCrypto";

```

## ./lib/lambda/node_modules/@aws-crypto/supports-web-crypto/src/supportsWebCrypto.ts

```typescript
type SubtleCryptoMethod =
  | "decrypt"
  | "digest"
  | "encrypt"
  | "exportKey"
  | "generateKey"
  | "importKey"
  | "sign"
  | "verify";

const subtleCryptoMethods: Array<SubtleCryptoMethod> = [
  "decrypt",
  "digest",
  "encrypt",
  "exportKey",
  "generateKey",
  "importKey",
  "sign",
  "verify"
];

export function supportsWebCrypto(window: Window): boolean {
  if (
    supportsSecureRandom(window) &&
    typeof window.crypto.subtle === "object"
  ) {
    const { subtle } = window.crypto;

    return supportsSubtleCrypto(subtle);
  }

  return false;
}

export function supportsSecureRandom(window: Window): boolean {
  if (typeof window === "object" && typeof window.crypto === "object") {
    const { getRandomValues } = window.crypto;

    return typeof getRandomValues === "function";
  }

  return false;
}

export function supportsSubtleCrypto(subtle: SubtleCrypto) {
  return (
    subtle &&
    subtleCryptoMethods.every(
      methodName => typeof subtle[methodName] === "function"
    )
  );
}

export async function supportsZeroByteGCM(subtle: SubtleCrypto) {
  if (!supportsSubtleCrypto(subtle)) return false;
  try {
    const key = await subtle.generateKey(
      { name: "AES-GCM", length: 128 },
      false,
      ["encrypt"]
    );
    const zeroByteAuthTag = await subtle.encrypt(
      {
        name: "AES-GCM",
        iv: new Uint8Array(Array(12)),
        additionalData: new Uint8Array(Array(16)),
        tagLength: 128
      },
      key,
      new Uint8Array(0)
    );
    return zeroByteAuthTag.byteLength === 16;
  } catch {
    return false;
  }
}

```

## ./lib/lambda/node_modules/@aws-crypto/supports-web-crypto/tsconfig.json

```json
{
  "extends": "../tsconfig.json",
  "compilerOptions": {
    "lib": ["dom"],
    "rootDir": "./src",
    "outDir": "./build/main",
  },
  "include": ["src/**/*.ts"],
  "exclude": ["node_modules/**"]
}

```

## ./lib/lambda/node_modules/@aws-crypto/supports-web-crypto/tsconfig.module.json

```json
{
  "extends": "./tsconfig",
  "compilerOptions": {
    "outDir": "build/module",
    "module": "esnext",
  }
}

```

## ./lib/lambda/node_modules/@aws-crypto/util/build/main/convertToBuffer.d.ts

```typescript
import { SourceData } from "@aws-sdk/types";
export declare function convertToBuffer(data: SourceData): Uint8Array;

```

## ./lib/lambda/node_modules/@aws-crypto/util/build/main/index.d.ts

```typescript
export { convertToBuffer } from "./convertToBuffer";
export { isEmptyData } from "./isEmptyData";
export { numToUint8 } from "./numToUint8";
export { uint32ArrayFrom } from './uint32ArrayFrom';

```

## ./lib/lambda/node_modules/@aws-crypto/util/build/main/isEmptyData.d.ts

```typescript
import { SourceData } from "@aws-sdk/types";
export declare function isEmptyData(data: SourceData): boolean;

```

## ./lib/lambda/node_modules/@aws-crypto/util/build/main/numToUint8.d.ts

```typescript
export declare function numToUint8(num: number): Uint8Array;

```

## ./lib/lambda/node_modules/@aws-crypto/util/build/main/uint32ArrayFrom.d.ts

```typescript
export declare function uint32ArrayFrom(a_lookUpTable: Array<number>): Uint32Array;

```

## ./lib/lambda/node_modules/@aws-crypto/util/build/module/convertToBuffer.d.ts

```typescript
import { SourceData } from "@aws-sdk/types";
export declare function convertToBuffer(data: SourceData): Uint8Array;

```

## ./lib/lambda/node_modules/@aws-crypto/util/build/module/index.d.ts

```typescript
export { convertToBuffer } from "./convertToBuffer";
export { isEmptyData } from "./isEmptyData";
export { numToUint8 } from "./numToUint8";
export { uint32ArrayFrom } from './uint32ArrayFrom';

```

## ./lib/lambda/node_modules/@aws-crypto/util/build/module/isEmptyData.d.ts

```typescript
import { SourceData } from "@aws-sdk/types";
export declare function isEmptyData(data: SourceData): boolean;

```

## ./lib/lambda/node_modules/@aws-crypto/util/build/module/numToUint8.d.ts

```typescript
export declare function numToUint8(num: number): Uint8Array;

```

## ./lib/lambda/node_modules/@aws-crypto/util/build/module/uint32ArrayFrom.d.ts

```typescript
export declare function uint32ArrayFrom(a_lookUpTable: Array<number>): Uint32Array;

```

## ./lib/lambda/node_modules/@aws-crypto/util/node_modules/@smithy/is-array-buffer/dist-types/index.d.ts

```typescript
/**
 * @internal
 */
export declare const isArrayBuffer: (arg: any) => arg is ArrayBuffer;

```

## ./lib/lambda/node_modules/@aws-crypto/util/node_modules/@smithy/is-array-buffer/dist-types/ts3.4/index.d.ts

```typescript
/**
 * @internal
 */
export declare const isArrayBuffer: (arg: any) => arg is ArrayBuffer;

```

## ./lib/lambda/node_modules/@aws-crypto/util/node_modules/@smithy/is-array-buffer/package.json

```json
{
  "name": "@smithy/is-array-buffer",
  "version": "2.2.0",
  "description": "Provides a function for detecting if an argument is an ArrayBuffer",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline is-array-buffer",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../.prettierignore --write \"**/*.{ts,md,json}\"",
    "test": "yarn g:jest"
  },
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "dependencies": {
    "tslib": "^2.6.2"
  },
  "engines": {
    "node": ">=14.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/awslabs/smithy-typescript/tree/main/packages/is-array-buffer",
  "repository": {
    "type": "git",
    "url": "https://github.com/awslabs/smithy-typescript.git",
    "directory": "packages/is-array-buffer"
  },
  "devDependencies": {
    "@tsconfig/recommended": "1.0.1",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  }
}
```

## ./lib/lambda/node_modules/@aws-crypto/util/node_modules/@smithy/util-buffer-from/dist-types/index.d.ts

```typescript
import { Buffer } from "buffer";
/**
 * @internal
 */
export declare const fromArrayBuffer: (input: ArrayBuffer, offset?: number, length?: number) => Buffer;
/**
 * @internal
 */
export type StringEncoding = "ascii" | "utf8" | "utf16le" | "ucs2" | "base64" | "latin1" | "binary" | "hex";
/**
 * @internal
 */
export declare const fromString: (input: string, encoding?: StringEncoding) => Buffer;

```

## ./lib/lambda/node_modules/@aws-crypto/util/node_modules/@smithy/util-buffer-from/dist-types/ts3.4/index.d.ts

```typescript
import { Buffer } from "buffer";
/**
 * @internal
 */
export declare const fromArrayBuffer: (input: ArrayBuffer, offset?: number, length?: number) => Buffer;
/**
 * @internal
 */
export type StringEncoding = "ascii" | "utf8" | "utf16le" | "ucs2" | "base64" | "latin1" | "binary" | "hex";
/**
 * @internal
 */
export declare const fromString: (input: string, encoding?: StringEncoding) => Buffer;

```

## ./lib/lambda/node_modules/@aws-crypto/util/node_modules/@smithy/util-buffer-from/package.json

```json
{
  "name": "@smithy/util-buffer-from",
  "version": "2.2.0",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline util-buffer-from",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../.prettierignore --write \"**/*.{ts,md,json}\"",
    "test": "yarn g:jest"
  },
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "dependencies": {
    "@smithy/is-array-buffer": "^2.2.0",
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "@tsconfig/recommended": "1.0.1",
    "@types/node": "^14.14.31",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "engines": {
    "node": ">=14.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/awslabs/smithy-typescript/tree/main/packages/util-buffer-from",
  "repository": {
    "type": "git",
    "url": "https://github.com/awslabs/smithy-typescript.git",
    "directory": "packages/util-buffer-from"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  }
}
```

## ./lib/lambda/node_modules/@aws-crypto/util/node_modules/@smithy/util-utf8/dist-types/fromUtf8.browser.d.ts

```typescript
export declare const fromUtf8: (input: string) => Uint8Array;

```

## ./lib/lambda/node_modules/@aws-crypto/util/node_modules/@smithy/util-utf8/dist-types/fromUtf8.d.ts

```typescript
export declare const fromUtf8: (input: string) => Uint8Array;

```

## ./lib/lambda/node_modules/@aws-crypto/util/node_modules/@smithy/util-utf8/dist-types/index.d.ts

```typescript
export * from "./fromUtf8";
export * from "./toUint8Array";
export * from "./toUtf8";

```

## ./lib/lambda/node_modules/@aws-crypto/util/node_modules/@smithy/util-utf8/dist-types/toUint8Array.d.ts

```typescript
export declare const toUint8Array: (data: string | ArrayBuffer | ArrayBufferView) => Uint8Array;

```

## ./lib/lambda/node_modules/@aws-crypto/util/node_modules/@smithy/util-utf8/dist-types/toUtf8.browser.d.ts

```typescript
/**
 *
 * This does not convert non-utf8 strings to utf8, it only passes through strings if
 * a string is received instead of a Uint8Array.
 *
 */
export declare const toUtf8: (input: Uint8Array | string) => string;

```

## ./lib/lambda/node_modules/@aws-crypto/util/node_modules/@smithy/util-utf8/dist-types/toUtf8.d.ts

```typescript
/**
 *
 * This does not convert non-utf8 strings to utf8, it only passes through strings if
 * a string is received instead of a Uint8Array.
 *
 */
export declare const toUtf8: (input: Uint8Array | string) => string;

```

## ./lib/lambda/node_modules/@aws-crypto/util/node_modules/@smithy/util-utf8/dist-types/ts3.4/fromUtf8.browser.d.ts

```typescript
export declare const fromUtf8: (input: string) => Uint8Array;

```

## ./lib/lambda/node_modules/@aws-crypto/util/node_modules/@smithy/util-utf8/dist-types/ts3.4/fromUtf8.d.ts

```typescript
export declare const fromUtf8: (input: string) => Uint8Array;

```

## ./lib/lambda/node_modules/@aws-crypto/util/node_modules/@smithy/util-utf8/dist-types/ts3.4/index.d.ts

```typescript
export * from "./fromUtf8";
export * from "./toUint8Array";
export * from "./toUtf8";

```

## ./lib/lambda/node_modules/@aws-crypto/util/node_modules/@smithy/util-utf8/dist-types/ts3.4/toUint8Array.d.ts

```typescript
export declare const toUint8Array: (data: string | ArrayBuffer | ArrayBufferView) => Uint8Array;

```

## ./lib/lambda/node_modules/@aws-crypto/util/node_modules/@smithy/util-utf8/dist-types/ts3.4/toUtf8.browser.d.ts

```typescript
/**
 *
 * This does not convert non-utf8 strings to utf8, it only passes through strings if
 * a string is received instead of a Uint8Array.
 *
 */
export declare const toUtf8: (input: Uint8Array | string) => string;

```

## ./lib/lambda/node_modules/@aws-crypto/util/node_modules/@smithy/util-utf8/dist-types/ts3.4/toUtf8.d.ts

```typescript
/**
 *
 * This does not convert non-utf8 strings to utf8, it only passes through strings if
 * a string is received instead of a Uint8Array.
 *
 */
export declare const toUtf8: (input: Uint8Array | string) => string;

```

## ./lib/lambda/node_modules/@aws-crypto/util/node_modules/@smithy/util-utf8/package.json

```json
{
  "name": "@smithy/util-utf8",
  "version": "2.3.0",
  "description": "A UTF-8 string <-> UInt8Array converter",
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline util-utf8",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../.prettierignore --write \"**/*.{ts,md,json}\"",
    "test": "yarn g:jest"
  },
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "dependencies": {
    "@smithy/util-buffer-from": "^2.2.0",
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "@tsconfig/recommended": "1.0.1",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "types": "./dist-types/index.d.ts",
  "engines": {
    "node": ">=14.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "browser": {
    "./dist-es/fromUtf8": "./dist-es/fromUtf8.browser",
    "./dist-es/toUtf8": "./dist-es/toUtf8.browser"
  },
  "react-native": {},
  "homepage": "https://github.com/awslabs/smithy-typescript/tree/main/packages/util-utf8",
  "repository": {
    "type": "git",
    "url": "https://github.com/awslabs/smithy-typescript.git",
    "directory": "packages/util-utf8"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  }
}
```

## ./lib/lambda/node_modules/@aws-crypto/util/package.json

```json
{
  "name": "@aws-crypto/util",
  "version": "5.2.0",
  "scripts": {
    "prepublishOnly": "tsc -p tsconfig.json && tsc -p tsconfig.module.json",
    "pretest": "tsc -p tsconfig.test.json",
    "test": "mocha --require ts-node/register test/**/*test.ts"
  },
  "main": "./build/main/index.js",
  "module": "./build/module/index.js",
  "types": "./build/main/index.d.ts",
  "repository": {
    "type": "git",
    "url": "git@github.com:aws/aws-sdk-js-crypto-helpers.git"
  },
  "author": {
    "name": "AWS Crypto Tools Team",
    "email": "aws-cryptools@amazon.com",
    "url": "https://docs.aws.amazon.com/aws-crypto-tools/index.html?id=docs_gateway#lang/en_us"
  },
  "homepage": "https://github.com/aws/aws-sdk-js-crypto-helpers/tree/master/packages/util",
  "license": "Apache-2.0",
  "dependencies": {
    "@aws-sdk/types": "^3.222.0",
    "@smithy/util-utf8": "^2.0.0",
    "tslib": "^2.6.2"
  },
  "publishConfig": {
    "access": "public"
  },
  "gitHead": "c11b171b35ec5c093364f0e0d8dc4ab1af68e748"
}

```

## ./lib/lambda/node_modules/@aws-crypto/util/src/convertToBuffer.ts

```typescript
// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

import { SourceData } from "@aws-sdk/types";
import { fromUtf8 as fromUtf8Browser } from "@smithy/util-utf8";

// Quick polyfill
const fromUtf8 =
  typeof Buffer !== "undefined" && Buffer.from
    ? (input: string) => Buffer.from(input, "utf8")
    : fromUtf8Browser;

export function convertToBuffer(data: SourceData): Uint8Array {
  // Already a Uint8, do nothing
  if (data instanceof Uint8Array) return data;

  if (typeof data === "string") {
    return fromUtf8(data);
  }

  if (ArrayBuffer.isView(data)) {
    return new Uint8Array(
      data.buffer,
      data.byteOffset,
      data.byteLength / Uint8Array.BYTES_PER_ELEMENT
    );
  }

  return new Uint8Array(data);
}

```

## ./lib/lambda/node_modules/@aws-crypto/util/src/index.ts

```typescript
// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

export { convertToBuffer } from "./convertToBuffer";
export { isEmptyData } from "./isEmptyData";
export { numToUint8 } from "./numToUint8";
export {uint32ArrayFrom} from './uint32ArrayFrom';

```

## ./lib/lambda/node_modules/@aws-crypto/util/src/isEmptyData.ts

```typescript
// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

import { SourceData } from "@aws-sdk/types";

export function isEmptyData(data: SourceData): boolean {
  if (typeof data === "string") {
    return data.length === 0;
  }

  return data.byteLength === 0;
}

```

## ./lib/lambda/node_modules/@aws-crypto/util/src/numToUint8.ts

```typescript
// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

export function numToUint8(num: number) {
  return new Uint8Array([
    (num & 0xff000000) >> 24,
    (num & 0x00ff0000) >> 16,
    (num & 0x0000ff00) >> 8,
    num & 0x000000ff,
  ]);
}

```

## ./lib/lambda/node_modules/@aws-crypto/util/src/uint32ArrayFrom.ts

```typescript
// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

// IE 11 does not support Array.from, so we do it manually
export function uint32ArrayFrom(a_lookUpTable: Array<number>): Uint32Array {
  if (!Uint32Array.from) {
    const return_array = new Uint32Array(a_lookUpTable.length)
    let a_index = 0
    while (a_index < a_lookUpTable.length) {
      return_array[a_index] = a_lookUpTable[a_index]
      a_index += 1
    }
    return return_array
  }
  return Uint32Array.from(a_lookUpTable)
}

```

## ./lib/lambda/node_modules/@aws-crypto/util/tsconfig.json

```json
{
  "extends": "../tsconfig.json",
  "compilerOptions": {
    "rootDir": "./src",
    "outDir": "./build/main",
  },
  "include": ["src/**/*.ts"],
  "exclude": ["node_modules/**"]
}

```

## ./lib/lambda/node_modules/@aws-crypto/util/tsconfig.module.json

```json
{
  "extends": "./tsconfig",
  "compilerOptions": {
    "outDir": "build/module",
    "module": "esnext",
  }
}

```

## ./lib/lambda/node_modules/@aws-sdk/client-secrets-manager/dist-types/commands/BatchGetSecretValueCommand.d.ts

```typescript
import { Command as $Command } from "@smithy/smithy-client";
import { MetadataBearer as __MetadataBearer } from "@smithy/types";
import { BatchGetSecretValueRequest, BatchGetSecretValueResponse } from "../models/models_0";
import { SecretsManagerClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "../SecretsManagerClient";
/**
 * @public
 */
export type { __MetadataBearer };
export { $Command };
/**
 * @public
 *
 * The input for {@link BatchGetSecretValueCommand}.
 */
export interface BatchGetSecretValueCommandInput extends BatchGetSecretValueRequest {
}
/**
 * @public
 *
 * The output of {@link BatchGetSecretValueCommand}.
 */
export interface BatchGetSecretValueCommandOutput extends BatchGetSecretValueResponse, __MetadataBearer {
}
declare const BatchGetSecretValueCommand_base: {
    new (input: BatchGetSecretValueCommandInput): import("@smithy/smithy-client").CommandImpl<BatchGetSecretValueCommandInput, BatchGetSecretValueCommandOutput, SecretsManagerClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes>;
    new (...[input]: [] | [BatchGetSecretValueCommandInput]): import("@smithy/smithy-client").CommandImpl<BatchGetSecretValueCommandInput, BatchGetSecretValueCommandOutput, SecretsManagerClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes>;
    getEndpointParameterInstructions(): import("@smithy/middleware-endpoint").EndpointParameterInstructions;
};
/**
 * <p>Retrieves the contents of the encrypted fields <code>SecretString</code> or <code>SecretBinary</code> for up to 20 secrets.  To retrieve a single secret, call <a>GetSecretValue</a>. </p>
 *          <p>To choose which secrets to retrieve, you can specify a list of secrets by name or ARN, or you can use filters. If Secrets Manager encounters errors such as <code>AccessDeniedException</code> while attempting to retrieve any of the secrets, you can see the errors in <code>Errors</code> in the response.</p>
 *          <p>Secrets Manager generates CloudTrail <code>GetSecretValue</code> log entries for each secret you request when you call this action. Do not include sensitive information in request parameters because it might be logged. For more information, see <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/retrieve-ct-entries.html">Logging Secrets Manager events with CloudTrail</a>.</p>
 *          <p>
 *             <b>Required permissions: </b>
 *             <code>secretsmanager:BatchGetSecretValue</code>, and you must have <code>secretsmanager:GetSecretValue</code> for each secret. If you use filters, you must also have <code>secretsmanager:ListSecrets</code>. If the secrets are encrypted using customer-managed keys instead of the Amazon Web Services managed key
 *       <code>aws/secretsmanager</code>, then you also need <code>kms:Decrypt</code> permissions for the keys.
 *       For more information, see <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/reference_iam-permissions.html#reference_iam-permissions_actions">
 *       IAM policy actions for Secrets Manager</a> and <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/auth-and-access.html">Authentication
 *       and access control in Secrets Manager</a>. </p>
 * @example
 * Use a bare-bones client and the command you need to make an API call.
 * ```javascript
 * import { SecretsManagerClient, BatchGetSecretValueCommand } from "@aws-sdk/client-secrets-manager"; // ES Modules import
 * // const { SecretsManagerClient, BatchGetSecretValueCommand } = require("@aws-sdk/client-secrets-manager"); // CommonJS import
 * // import type { SecretsManagerClientConfig } from "@aws-sdk/client-secrets-manager";
 * const config = {}; // type is SecretsManagerClientConfig
 * const client = new SecretsManagerClient(config);
 * const input = { // BatchGetSecretValueRequest
 *   SecretIdList: [ // SecretIdListType
 *     "STRING_VALUE",
 *   ],
 *   Filters: [ // FiltersListType
 *     { // Filter
 *       Key: "description" || "name" || "tag-key" || "tag-value" || "primary-region" || "owning-service" || "all",
 *       Values: [ // FilterValuesStringList
 *         "STRING_VALUE",
 *       ],
 *     },
 *   ],
 *   MaxResults: Number("int"),
 *   NextToken: "STRING_VALUE",
 * };
 * const command = new BatchGetSecretValueCommand(input);
 * const response = await client.send(command);
 * // { // BatchGetSecretValueResponse
 * //   SecretValues: [ // SecretValuesType
 * //     { // SecretValueEntry
 * //       ARN: "STRING_VALUE",
 * //       Name: "STRING_VALUE",
 * //       VersionId: "STRING_VALUE",
 * //       SecretBinary: new Uint8Array(),
 * //       SecretString: "STRING_VALUE",
 * //       VersionStages: [ // SecretVersionStagesType
 * //         "STRING_VALUE",
 * //       ],
 * //       CreatedDate: new Date("TIMESTAMP"),
 * //     },
 * //   ],
 * //   NextToken: "STRING_VALUE",
 * //   Errors: [ // APIErrorListType
 * //     { // APIErrorType
 * //       SecretId: "STRING_VALUE",
 * //       ErrorCode: "STRING_VALUE",
 * //       Message: "STRING_VALUE",
 * //     },
 * //   ],
 * // };
 *
 * ```
 *
 * @param BatchGetSecretValueCommandInput - {@link BatchGetSecretValueCommandInput}
 * @returns {@link BatchGetSecretValueCommandOutput}
 * @see {@link BatchGetSecretValueCommandInput} for command's `input` shape.
 * @see {@link BatchGetSecretValueCommandOutput} for command's `response` shape.
 * @see {@link SecretsManagerClientResolvedConfig | config} for SecretsManagerClient's `config` shape.
 *
 * @throws {@link DecryptionFailure} (client fault)
 *  <p>Secrets Manager can't decrypt the protected secret text using the provided KMS key. </p>
 *
 * @throws {@link InternalServiceError} (server fault)
 *  <p>An error occurred on the server side.</p>
 *
 * @throws {@link InvalidNextTokenException} (client fault)
 *  <p>The <code>NextToken</code> value is invalid.</p>
 *
 * @throws {@link InvalidParameterException} (client fault)
 *  <p>The parameter name or value is invalid.</p>
 *
 * @throws {@link InvalidRequestException} (client fault)
 *  <p>A parameter value is not valid for the current state of the
 *       resource.</p>
 *          <p>Possible causes:</p>
 *          <ul>
 *             <li>
 *                <p>The secret is scheduled for deletion.</p>
 *             </li>
 *             <li>
 *                <p>You tried to enable rotation on a secret that doesn't already have a Lambda function
 *           ARN configured and you didn't include such an ARN as a parameter in this call. </p>
 *             </li>
 *             <li>
 *                <p>The secret is managed by another service, and you must use that service to update it.
 *           For more information, see <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/service-linked-secrets.html">Secrets managed by other Amazon Web Services services</a>.</p>
 *             </li>
 *          </ul>
 *
 * @throws {@link ResourceNotFoundException} (client fault)
 *  <p>Secrets Manager can't find the resource that you asked for.</p>
 *
 * @throws {@link SecretsManagerServiceException}
 * <p>Base exception class for all service exceptions from SecretsManager service.</p>
 *
 *
 * @example To retrieve the secret values for a group of secrets listed by name
 * ```javascript
 * // The following example gets the values for three secrets.
 * const input = {
 *   SecretIdList: [
 *     "MySecret1",
 *     "MySecret2",
 *     "MySecret3"
 *   ]
 * };
 * const command = new BatchGetSecretValueCommand(input);
 * const response = await client.send(command);
 * /* response is
 * {
 *   Errors:   [],
 *   SecretValues: [
 *     {
 *       ARN: "&region-arn;&asm-service-name;:us-west-2:&ExampleAccountId;:secret:MySecret1-a1b2c3",
 *       CreatedDate: 1.700591229801E9,
 *       Name: "MySecret1",
 *       SecretString: `{"username":"diego_ramirez","password":"EXAMPLE-PASSWORD","engine":"mysql","host":"secretsmanagertutorial.cluster.us-west-2.rds.amazonaws.com","port":3306,"dbClusterIdentifier":"secretsmanagertutorial"}`,
 *       VersionId: "a1b2c3d4-5678-90ab-cdef-EXAMPLEaaaaa",
 *       VersionStages: [
 *         "AWSCURRENT"
 *       ]
 *     },
 *     {
 *       ARN: "&region-arn;&asm-service-name;:us-west-2:&ExampleAccountId;:secret:MySecret2-a1b2c3",
 *       CreatedDate: 1.699911394105E9,
 *       Name: "MySecret2",
 *       SecretString: `{"username":"akua_mansa","password":"EXAMPLE-PASSWORD"`,
 *       VersionId: "a1b2c3d4-5678-90ab-cdef-EXAMPLEbbbbb",
 *       VersionStages: [
 *         "AWSCURRENT"
 *       ]
 *     },
 *     {
 *       ARN: "&region-arn;&asm-service-name;:us-west-2:&ExampleAccountId;:secret:MySecret3-a1b2c3",
 *       CreatedDate: 1.699911394105E9,
 *       Name: "MySecret3",
 *       SecretString: `{"username":"jie_liu","password":"EXAMPLE-PASSWORD"`,
 *       VersionId: "a1b2c3d4-5678-90ab-cdef-EXAMPLEccccc",
 *       VersionStages: [
 *         "AWSCURRENT"
 *       ]
 *     }
 *   ]
 * }
 * *\/
 * ```
 *
 * @public
 */
export declare class BatchGetSecretValueCommand extends BatchGetSecretValueCommand_base {
    /** @internal type navigation helper, not in runtime. */
    protected static __types: {
        api: {
            input: BatchGetSecretValueRequest;
            output: BatchGetSecretValueResponse;
        };
        sdk: {
            input: BatchGetSecretValueCommandInput;
            output: BatchGetSecretValueCommandOutput;
        };
    };
}

```

## ./lib/lambda/node_modules/@aws-sdk/client-secrets-manager/dist-types/commands/CancelRotateSecretCommand.d.ts

```typescript
import { Command as $Command } from "@smithy/smithy-client";
import { MetadataBearer as __MetadataBearer } from "@smithy/types";
import { CancelRotateSecretRequest, CancelRotateSecretResponse } from "../models/models_0";
import { SecretsManagerClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "../SecretsManagerClient";
/**
 * @public
 */
export type { __MetadataBearer };
export { $Command };
/**
 * @public
 *
 * The input for {@link CancelRotateSecretCommand}.
 */
export interface CancelRotateSecretCommandInput extends CancelRotateSecretRequest {
}
/**
 * @public
 *
 * The output of {@link CancelRotateSecretCommand}.
 */
export interface CancelRotateSecretCommandOutput extends CancelRotateSecretResponse, __MetadataBearer {
}
declare const CancelRotateSecretCommand_base: {
    new (input: CancelRotateSecretCommandInput): import("@smithy/smithy-client").CommandImpl<CancelRotateSecretCommandInput, CancelRotateSecretCommandOutput, SecretsManagerClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes>;
    new (input: CancelRotateSecretCommandInput): import("@smithy/smithy-client").CommandImpl<CancelRotateSecretCommandInput, CancelRotateSecretCommandOutput, SecretsManagerClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes>;
    getEndpointParameterInstructions(): import("@smithy/middleware-endpoint").EndpointParameterInstructions;
};
/**
 * <p>Turns off automatic rotation, and if a rotation is currently in
 *       progress, cancels the rotation.</p>
 *          <p>If you cancel a rotation in progress, it can leave the <code>VersionStage</code>
 *       labels in an unexpected state. You might
 *       need to remove the staging label <code>AWSPENDING</code> from the partially created version.
 *       You also need to determine whether to roll back to the previous version of the secret
 *       by moving the staging label <code>AWSCURRENT</code> to the version that has <code>AWSPENDING</code>.
 *       To determine
 *       which version has a specific staging label, call <a>ListSecretVersionIds</a>. Then use
 *      <a>UpdateSecretVersionStage</a> to change staging labels.
 *      For more information, see <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/rotate-secrets_how.html">How rotation works</a>.</p>
 *          <p>To turn on automatic rotation again, call <a>RotateSecret</a>.</p>
 *          <p>Secrets Manager generates a CloudTrail log entry when you call this action. Do not include sensitive information in request parameters because it might be logged. For more information, see <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/retrieve-ct-entries.html">Logging Secrets Manager events with CloudTrail</a>.</p>
 *          <p>
 *             <b>Required permissions: </b>
 *             <code>secretsmanager:CancelRotateSecret</code>.
 *       For more information, see <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/reference_iam-permissions.html#reference_iam-permissions_actions">
 *       IAM policy actions for Secrets Manager</a> and <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/auth-and-access.html">Authentication
 *       and access control in Secrets Manager</a>. </p>
 * @example
 * Use a bare-bones client and the command you need to make an API call.
 * ```javascript
 * import { SecretsManagerClient, CancelRotateSecretCommand } from "@aws-sdk/client-secrets-manager"; // ES Modules import
 * // const { SecretsManagerClient, CancelRotateSecretCommand } = require("@aws-sdk/client-secrets-manager"); // CommonJS import
 * // import type { SecretsManagerClientConfig } from "@aws-sdk/client-secrets-manager";
 * const config = {}; // type is SecretsManagerClientConfig
 * const client = new SecretsManagerClient(config);
 * const input = { // CancelRotateSecretRequest
 *   SecretId: "STRING_VALUE", // required
 * };
 * const command = new CancelRotateSecretCommand(input);
 * const response = await client.send(command);
 * // { // CancelRotateSecretResponse
 * //   ARN: "STRING_VALUE",
 * //   Name: "STRING_VALUE",
 * //   VersionId: "STRING_VALUE",
 * // };
 *
 * ```
 *
 * @param CancelRotateSecretCommandInput - {@link CancelRotateSecretCommandInput}
 * @returns {@link CancelRotateSecretCommandOutput}
 * @see {@link CancelRotateSecretCommandInput} for command's `input` shape.
 * @see {@link CancelRotateSecretCommandOutput} for command's `response` shape.
 * @see {@link SecretsManagerClientResolvedConfig | config} for SecretsManagerClient's `config` shape.
 *
 * @throws {@link InternalServiceError} (server fault)
 *  <p>An error occurred on the server side.</p>
 *
 * @throws {@link InvalidParameterException} (client fault)
 *  <p>The parameter name or value is invalid.</p>
 *
 * @throws {@link InvalidRequestException} (client fault)
 *  <p>A parameter value is not valid for the current state of the
 *       resource.</p>
 *          <p>Possible causes:</p>
 *          <ul>
 *             <li>
 *                <p>The secret is scheduled for deletion.</p>
 *             </li>
 *             <li>
 *                <p>You tried to enable rotation on a secret that doesn't already have a Lambda function
 *           ARN configured and you didn't include such an ARN as a parameter in this call. </p>
 *             </li>
 *             <li>
 *                <p>The secret is managed by another service, and you must use that service to update it.
 *           For more information, see <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/service-linked-secrets.html">Secrets managed by other Amazon Web Services services</a>.</p>
 *             </li>
 *          </ul>
 *
 * @throws {@link ResourceNotFoundException} (client fault)
 *  <p>Secrets Manager can't find the resource that you asked for.</p>
 *
 * @throws {@link SecretsManagerServiceException}
 * <p>Base exception class for all service exceptions from SecretsManager service.</p>
 *
 *
 * @example To cancel scheduled rotation for a secret
 * ```javascript
 * // The following example shows how to cancel rotation for a secret. The operation sets the RotationEnabled field to false and cancels all scheduled rotations. To resume scheduled rotations, you must re-enable rotation by calling the rotate-secret operation.
 * const input = {
 *   SecretId: "MyTestDatabaseSecret"
 * };
 * const command = new CancelRotateSecretCommand(input);
 * const response = await client.send(command);
 * /* response is
 * {
 *   ARN: "arn:aws:secretsmanager:us-west-2:123456789012:secret:MyTestDatabaseSecret-a1b2c3",
 *   Name: "Name"
 * }
 * *\/
 * ```
 *
 * @public
 */
export declare class CancelRotateSecretCommand extends CancelRotateSecretCommand_base {
    /** @internal type navigation helper, not in runtime. */
    protected static __types: {
        api: {
            input: CancelRotateSecretRequest;
            output: CancelRotateSecretResponse;
        };
        sdk: {
            input: CancelRotateSecretCommandInput;
            output: CancelRotateSecretCommandOutput;
        };
    };
}

```

## ./lib/lambda/node_modules/@aws-sdk/client-secrets-manager/dist-types/commands/CreateSecretCommand.d.ts

```typescript
import { Command as $Command } from "@smithy/smithy-client";
import { MetadataBearer as __MetadataBearer } from "@smithy/types";
import { CreateSecretRequest, CreateSecretResponse } from "../models/models_0";
import { SecretsManagerClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "../SecretsManagerClient";
/**
 * @public
 */
export type { __MetadataBearer };
export { $Command };
/**
 * @public
 *
 * The input for {@link CreateSecretCommand}.
 */
export interface CreateSecretCommandInput extends CreateSecretRequest {
}
/**
 * @public
 *
 * The output of {@link CreateSecretCommand}.
 */
export interface CreateSecretCommandOutput extends CreateSecretResponse, __MetadataBearer {
}
declare const CreateSecretCommand_base: {
    new (input: CreateSecretCommandInput): import("@smithy/smithy-client").CommandImpl<CreateSecretCommandInput, CreateSecretCommandOutput, SecretsManagerClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes>;
    new (input: CreateSecretCommandInput): import("@smithy/smithy-client").CommandImpl<CreateSecretCommandInput, CreateSecretCommandOutput, SecretsManagerClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes>;
    getEndpointParameterInstructions(): import("@smithy/middleware-endpoint").EndpointParameterInstructions;
};
/**
 * <p>Creates a new secret. A <i>secret</i> can be a password, a set of
 *       credentials such as a user name and password, an OAuth token, or other secret information
 *       that you store in an encrypted form in Secrets Manager. The secret also
 *       includes the connection information to access a database or other service, which Secrets Manager
 *       doesn't encrypt. A secret in Secrets Manager consists of both the protected secret data and the
 *       important information needed to manage the secret.</p>
 *          <p>For secrets that use <i>managed rotation</i>, you need to create the secret through the managing service. For more information, see <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/service-linked-secrets.html">Secrets Manager secrets managed by other Amazon Web Services services</a>.
 *
 *     </p>
 *          <p>For information about creating a secret in the console, see <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/manage_create-basic-secret.html">Create a secret</a>.</p>
 *          <p>To create a secret, you can provide the secret value to be encrypted in either the
 *       <code>SecretString</code> parameter or the <code>SecretBinary</code> parameter, but not both.
 *       If you include <code>SecretString</code> or <code>SecretBinary</code>
 *       then Secrets Manager creates an initial secret version and automatically attaches the staging
 *       label <code>AWSCURRENT</code> to it.</p>
 *          <p>For database credentials you want to rotate, for Secrets Manager to be able to rotate the secret,
 *       you must make sure the JSON you store in the <code>SecretString</code> matches the <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/reference_secret_json_structure.html">JSON structure of
 *         a database secret</a>.</p>
 *          <p>If you don't specify an KMS encryption key, Secrets Manager uses the Amazon Web Services managed key
 *       <code>aws/secretsmanager</code>. If this key
 *       doesn't already exist in your account, then Secrets Manager creates it for you automatically. All
 *       users and roles in the Amazon Web Services account automatically have access to use <code>aws/secretsmanager</code>.
 *       Creating <code>aws/secretsmanager</code> can result in a one-time significant delay in returning the
 *       result.</p>
 *          <p>If the secret is in a different Amazon Web Services account from the credentials calling the API, then
 *       you can't use <code>aws/secretsmanager</code> to encrypt the secret, and you must create
 *       and use a customer managed KMS key. </p>
 *          <p>Secrets Manager generates a CloudTrail log entry when you call this action. Do not include sensitive information in request parameters except <code>SecretBinary</code> or <code>SecretString</code> because it might be logged. For more information, see <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/retrieve-ct-entries.html">Logging Secrets Manager events with CloudTrail</a>.</p>
 *          <p>
 *             <b>Required permissions: </b>
 *             <code>secretsmanager:CreateSecret</code>. If you
 *       include tags in the secret, you also need <code>secretsmanager:TagResource</code>. To add replica Regions, you must also have <code>secretsmanager:ReplicateSecretToRegions</code>.
 *       For more information, see <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/reference_iam-permissions.html#reference_iam-permissions_actions">
 *       IAM policy actions for Secrets Manager</a> and <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/auth-and-access.html">Authentication
 *       and access control in Secrets Manager</a>. </p>
 *          <p>To encrypt the secret with a KMS key other than <code>aws/secretsmanager</code>, you need <code>kms:GenerateDataKey</code> and <code>kms:Decrypt</code> permission to the key. </p>
 *          <important>
 *             <p>When you enter commands in a command shell, there is a risk of the command history being accessed or utilities having access to your command parameters. This is a concern if the command includes the value of a secret. Learn how to <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/security_cli-exposure-risks.html">Mitigate the risks of using command-line tools to store Secrets Manager secrets</a>.</p>
 *          </important>
 * @example
 * Use a bare-bones client and the command you need to make an API call.
 * ```javascript
 * import { SecretsManagerClient, CreateSecretCommand } from "@aws-sdk/client-secrets-manager"; // ES Modules import
 * // const { SecretsManagerClient, CreateSecretCommand } = require("@aws-sdk/client-secrets-manager"); // CommonJS import
 * // import type { SecretsManagerClientConfig } from "@aws-sdk/client-secrets-manager";
 * const config = {}; // type is SecretsManagerClientConfig
 * const client = new SecretsManagerClient(config);
 * const input = { // CreateSecretRequest
 *   Name: "STRING_VALUE", // required
 *   ClientRequestToken: "STRING_VALUE",
 *   Description: "STRING_VALUE",
 *   KmsKeyId: "STRING_VALUE",
 *   SecretBinary: new Uint8Array(), // e.g. Buffer.from("") or new TextEncoder().encode("")
 *   SecretString: "STRING_VALUE",
 *   Tags: [ // TagListType
 *     { // Tag
 *       Key: "STRING_VALUE",
 *       Value: "STRING_VALUE",
 *     },
 *   ],
 *   AddReplicaRegions: [ // AddReplicaRegionListType
 *     { // ReplicaRegionType
 *       Region: "STRING_VALUE",
 *       KmsKeyId: "STRING_VALUE",
 *     },
 *   ],
 *   ForceOverwriteReplicaSecret: true || false,
 * };
 * const command = new CreateSecretCommand(input);
 * const response = await client.send(command);
 * // { // CreateSecretResponse
 * //   ARN: "STRING_VALUE",
 * //   Name: "STRING_VALUE",
 * //   VersionId: "STRING_VALUE",
 * //   ReplicationStatus: [ // ReplicationStatusListType
 * //     { // ReplicationStatusType
 * //       Region: "STRING_VALUE",
 * //       KmsKeyId: "STRING_VALUE",
 * //       Status: "InSync" || "Failed" || "InProgress",
 * //       StatusMessage: "STRING_VALUE",
 * //       LastAccessedDate: new Date("TIMESTAMP"),
 * //     },
 * //   ],
 * // };
 *
 * ```
 *
 * @param CreateSecretCommandInput - {@link CreateSecretCommandInput}
 * @returns {@link CreateSecretCommandOutput}
 * @see {@link CreateSecretCommandInput} for command's `input` shape.
 * @see {@link CreateSecretCommandOutput} for command's `response` shape.
 * @see {@link SecretsManagerClientResolvedConfig | config} for SecretsManagerClient's `config` shape.
 *
 * @throws {@link DecryptionFailure} (client fault)
 *  <p>Secrets Manager can't decrypt the protected secret text using the provided KMS key. </p>
 *
 * @throws {@link EncryptionFailure} (client fault)
 *  <p>Secrets Manager can't encrypt the protected secret text using the provided KMS key. Check that the
 *       KMS key is available, enabled, and not in an invalid state. For more
 *       information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/key-state.html">Key state: Effect on your KMS key</a>.</p>
 *
 * @throws {@link InternalServiceError} (server fault)
 *  <p>An error occurred on the server side.</p>
 *
 * @throws {@link InvalidParameterException} (client fault)
 *  <p>The parameter name or value is invalid.</p>
 *
 * @throws {@link InvalidRequestException} (client fault)
 *  <p>A parameter value is not valid for the current state of the
 *       resource.</p>
 *          <p>Possible causes:</p>
 *          <ul>
 *             <li>
 *                <p>The secret is scheduled for deletion.</p>
 *             </li>
 *             <li>
 *                <p>You tried to enable rotation on a secret that doesn't already have a Lambda function
 *           ARN configured and you didn't include such an ARN as a parameter in this call. </p>
 *             </li>
 *             <li>
 *                <p>The secret is managed by another service, and you must use that service to update it.
 *           For more information, see <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/service-linked-secrets.html">Secrets managed by other Amazon Web Services services</a>.</p>
 *             </li>
 *          </ul>
 *
 * @throws {@link LimitExceededException} (client fault)
 *  <p>The request failed because it would exceed one of the Secrets Manager quotas.</p>
 *
 * @throws {@link MalformedPolicyDocumentException} (client fault)
 *  <p>The resource policy has syntax errors.</p>
 *
 * @throws {@link PreconditionNotMetException} (client fault)
 *  <p>The request failed because you did not complete all the prerequisite steps.</p>
 *
 * @throws {@link ResourceExistsException} (client fault)
 *  <p>A resource with the ID you requested already exists.</p>
 *
 * @throws {@link ResourceNotFoundException} (client fault)
 *  <p>Secrets Manager can't find the resource that you asked for.</p>
 *
 * @throws {@link SecretsManagerServiceException}
 * <p>Base exception class for all service exceptions from SecretsManager service.</p>
 *
 *
 * @example To create a basic secret
 * ```javascript
 * // The following example shows how to create a secret. The credentials stored in the encrypted secret value are retrieved from a file on disk named mycreds.json.
 * const input = {
 *   ClientRequestToken: "EXAMPLE1-90ab-cdef-fedc-ba987SECRET1",
 *   Description: "My test database secret created with the CLI",
 *   Name: "MyTestDatabaseSecret",
 *   SecretString: `{"username":"david","password":"EXAMPLE-PASSWORD"}`
 * };
 * const command = new CreateSecretCommand(input);
 * const response = await client.send(command);
 * /* response is
 * {
 *   ARN: "arn:aws:secretsmanager:us-west-2:123456789012:secret:MyTestDatabaseSecret-a1b2c3",
 *   Name: "MyTestDatabaseSecret",
 *   VersionId: "EXAMPLE1-90ab-cdef-fedc-ba987SECRET1"
 * }
 * *\/
 * ```
 *
 * @public
 */
export declare class CreateSecretCommand extends CreateSecretCommand_base {
    /** @internal type navigation helper, not in runtime. */
    protected static __types: {
        api: {
            input: CreateSecretRequest;
            output: CreateSecretResponse;
        };
        sdk: {
            input: CreateSecretCommandInput;
            output: CreateSecretCommandOutput;
        };
    };
}

```

## ./lib/lambda/node_modules/@aws-sdk/client-secrets-manager/dist-types/commands/DeleteResourcePolicyCommand.d.ts

```typescript
import { Command as $Command } from "@smithy/smithy-client";
import { MetadataBearer as __MetadataBearer } from "@smithy/types";
import { DeleteResourcePolicyRequest, DeleteResourcePolicyResponse } from "../models/models_0";
import { SecretsManagerClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "../SecretsManagerClient";
/**
 * @public
 */
export type { __MetadataBearer };
export { $Command };
/**
 * @public
 *
 * The input for {@link DeleteResourcePolicyCommand}.
 */
export interface DeleteResourcePolicyCommandInput extends DeleteResourcePolicyRequest {
}
/**
 * @public
 *
 * The output of {@link DeleteResourcePolicyCommand}.
 */
export interface DeleteResourcePolicyCommandOutput extends DeleteResourcePolicyResponse, __MetadataBearer {
}
declare const DeleteResourcePolicyCommand_base: {
    new (input: DeleteResourcePolicyCommandInput): import("@smithy/smithy-client").CommandImpl<DeleteResourcePolicyCommandInput, DeleteResourcePolicyCommandOutput, SecretsManagerClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes>;
    new (input: DeleteResourcePolicyCommandInput): import("@smithy/smithy-client").CommandImpl<DeleteResourcePolicyCommandInput, DeleteResourcePolicyCommandOutput, SecretsManagerClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes>;
    getEndpointParameterInstructions(): import("@smithy/middleware-endpoint").EndpointParameterInstructions;
};
/**
 * <p>Deletes the resource-based permission policy attached to the secret. To attach a policy to
 *       a secret, use <a>PutResourcePolicy</a>.</p>
 *          <p>Secrets Manager generates a CloudTrail log entry when you call this action. Do not include sensitive information in request parameters because it might be logged. For more information, see <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/retrieve-ct-entries.html">Logging Secrets Manager events with CloudTrail</a>.</p>
 *          <p>
 *             <b>Required permissions: </b>
 *             <code>secretsmanager:DeleteResourcePolicy</code>.
 *       For more information, see <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/reference_iam-permissions.html#reference_iam-permissions_actions">
 *       IAM policy actions for Secrets Manager</a> and <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/auth-and-access.html">Authentication
 *       and access control in Secrets Manager</a>. </p>
 * @example
 * Use a bare-bones client and the command you need to make an API call.
 * ```javascript
 * import { SecretsManagerClient, DeleteResourcePolicyCommand } from "@aws-sdk/client-secrets-manager"; // ES Modules import
 * // const { SecretsManagerClient, DeleteResourcePolicyCommand } = require("@aws-sdk/client-secrets-manager"); // CommonJS import
 * // import type { SecretsManagerClientConfig } from "@aws-sdk/client-secrets-manager";
 * const config = {}; // type is SecretsManagerClientConfig
 * const client = new SecretsManagerClient(config);
 * const input = { // DeleteResourcePolicyRequest
 *   SecretId: "STRING_VALUE", // required
 * };
 * const command = new DeleteResourcePolicyCommand(input);
 * const response = await client.send(command);
 * // { // DeleteResourcePolicyResponse
 * //   ARN: "STRING_VALUE",
 * //   Name: "STRING_VALUE",
 * // };
 *
 * ```
 *
 * @param DeleteResourcePolicyCommandInput - {@link DeleteResourcePolicyCommandInput}
 * @returns {@link DeleteResourcePolicyCommandOutput}
 * @see {@link DeleteResourcePolicyCommandInput} for command's `input` shape.
 * @see {@link DeleteResourcePolicyCommandOutput} for command's `response` shape.
 * @see {@link SecretsManagerClientResolvedConfig | config} for SecretsManagerClient's `config` shape.
 *
 * @throws {@link InternalServiceError} (server fault)
 *  <p>An error occurred on the server side.</p>
 *
 * @throws {@link InvalidParameterException} (client fault)
 *  <p>The parameter name or value is invalid.</p>
 *
 * @throws {@link InvalidRequestException} (client fault)
 *  <p>A parameter value is not valid for the current state of the
 *       resource.</p>
 *          <p>Possible causes:</p>
 *          <ul>
 *             <li>
 *                <p>The secret is scheduled for deletion.</p>
 *             </li>
 *             <li>
 *                <p>You tried to enable rotation on a secret that doesn't already have a Lambda function
 *           ARN configured and you didn't include such an ARN as a parameter in this call. </p>
 *             </li>
 *             <li>
 *                <p>The secret is managed by another service, and you must use that service to update it.
 *           For more information, see <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/service-linked-secrets.html">Secrets managed by other Amazon Web Services services</a>.</p>
 *             </li>
 *          </ul>
 *
 * @throws {@link ResourceNotFoundException} (client fault)
 *  <p>Secrets Manager can't find the resource that you asked for.</p>
 *
 * @throws {@link SecretsManagerServiceException}
 * <p>Base exception class for all service exceptions from SecretsManager service.</p>
 *
 *
 * @example To delete the resource-based policy attached to a secret
 * ```javascript
 * // The following example shows how to delete the resource-based policy that is attached to a secret.
 * const input = {
 *   SecretId: "MyTestDatabaseSecret"
 * };
 * const command = new DeleteResourcePolicyCommand(input);
 * const response = await client.send(command);
 * /* response is
 * {
 *   ARN: "arn:aws:secretsmanager:us-west-2:123456789012:secret:MyTestDatabaseSecret-a1b2c3",
 *   Name: "MyTestDatabaseSecret"
 * }
 * *\/
 * ```
 *
 * @public
 */
export declare class DeleteResourcePolicyCommand extends DeleteResourcePolicyCommand_base {
    /** @internal type navigation helper, not in runtime. */
    protected static __types: {
        api: {
            input: DeleteResourcePolicyRequest;
            output: DeleteResourcePolicyResponse;
        };
        sdk: {
            input: DeleteResourcePolicyCommandInput;
            output: DeleteResourcePolicyCommandOutput;
        };
    };
}

```

## ./lib/lambda/node_modules/@aws-sdk/client-secrets-manager/dist-types/commands/DeleteSecretCommand.d.ts

```typescript
import { Command as $Command } from "@smithy/smithy-client";
import { MetadataBearer as __MetadataBearer } from "@smithy/types";
import { DeleteSecretRequest, DeleteSecretResponse } from "../models/models_0";
import { SecretsManagerClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "../SecretsManagerClient";
/**
 * @public
 */
export type { __MetadataBearer };
export { $Command };
/**
 * @public
 *
 * The input for {@link DeleteSecretCommand}.
 */
export interface DeleteSecretCommandInput extends DeleteSecretRequest {
}
/**
 * @public
 *
 * The output of {@link DeleteSecretCommand}.
 */
export interface DeleteSecretCommandOutput extends DeleteSecretResponse, __MetadataBearer {
}
declare const DeleteSecretCommand_base: {
    new (input: DeleteSecretCommandInput): import("@smithy/smithy-client").CommandImpl<DeleteSecretCommandInput, DeleteSecretCommandOutput, SecretsManagerClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes>;
    new (input: DeleteSecretCommandInput): import("@smithy/smithy-client").CommandImpl<DeleteSecretCommandInput, DeleteSecretCommandOutput, SecretsManagerClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes>;
    getEndpointParameterInstructions(): import("@smithy/middleware-endpoint").EndpointParameterInstructions;
};
/**
 * <p>Deletes a secret and all of its versions. You can specify a recovery
 *       window during which you can restore the secret. The minimum recovery window is 7 days.
 *       The default recovery window is 30 days. Secrets Manager attaches a <code>DeletionDate</code> stamp to
 *       the secret that specifies the end of the recovery window. At the end of the recovery window,
 *       Secrets Manager deletes the secret permanently.</p>
 *          <p>You can't delete a primary secret that is replicated to other Regions. You must first delete the
 *     replicas using <a>RemoveRegionsFromReplication</a>, and then delete the primary secret.
 *     When you delete a replica, it is deleted immediately.</p>
 *          <p>You can't directly delete a version of a secret. Instead, you remove all staging labels
 *     from the version using <a>UpdateSecretVersionStage</a>. This marks the version as deprecated,
 *     and then Secrets Manager can automatically delete the version in the background.</p>
 *          <p>To determine whether an application still uses a secret, you can create an Amazon CloudWatch alarm
 *     to alert you to any attempts to access a secret during the recovery window. For more information,
 *     see <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/monitoring_cloudwatch_deleted-secrets.html">
 *     Monitor secrets scheduled for deletion</a>.</p>
 *          <p>Secrets Manager performs the permanent secret deletion at the end of the waiting period as a
 *         background task with low priority. There is no guarantee of a specific time after the
 *         recovery window for the permanent delete to occur.</p>
 *          <p>At any time before recovery window ends, you can use <a>RestoreSecret</a> to
 *       remove the <code>DeletionDate</code> and cancel the deletion of the secret.</p>
 *          <p>When a secret is scheduled for deletion, you cannot retrieve the secret value.
 *       You must first cancel the deletion with <a>RestoreSecret</a> and then you can retrieve the secret.</p>
 *          <p>Secrets Manager generates a CloudTrail log entry when you call this action. Do not include sensitive information in request parameters because it might be logged. For more information, see <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/retrieve-ct-entries.html">Logging Secrets Manager events with CloudTrail</a>.</p>
 *          <p>
 *             <b>Required permissions: </b>
 *             <code>secretsmanager:DeleteSecret</code>.
 *       For more information, see <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/reference_iam-permissions.html#reference_iam-permissions_actions">
 *       IAM policy actions for Secrets Manager</a> and <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/auth-and-access.html">Authentication
 *       and access control in Secrets Manager</a>. </p>
 * @example
 * Use a bare-bones client and the command you need to make an API call.
 * ```javascript
 * import { SecretsManagerClient, DeleteSecretCommand } from "@aws-sdk/client-secrets-manager"; // ES Modules import
 * // const { SecretsManagerClient, DeleteSecretCommand } = require("@aws-sdk/client-secrets-manager"); // CommonJS import
 * // import type { SecretsManagerClientConfig } from "@aws-sdk/client-secrets-manager";
 * const config = {}; // type is SecretsManagerClientConfig
 * const client = new SecretsManagerClient(config);
 * const input = { // DeleteSecretRequest
 *   SecretId: "STRING_VALUE", // required
 *   RecoveryWindowInDays: Number("long"),
 *   ForceDeleteWithoutRecovery: true || false,
 * };
 * const command = new DeleteSecretCommand(input);
 * const response = await client.send(command);
 * // { // DeleteSecretResponse
 * //   ARN: "STRING_VALUE",
 * //   Name: "STRING_VALUE",
 * //   DeletionDate: new Date("TIMESTAMP"),
 * // };
 *
 * ```
 *
 * @param DeleteSecretCommandInput - {@link DeleteSecretCommandInput}
 * @returns {@link DeleteSecretCommandOutput}
 * @see {@link DeleteSecretCommandInput} for command's `input` shape.
 * @see {@link DeleteSecretCommandOutput} for command's `response` shape.
 * @see {@link SecretsManagerClientResolvedConfig | config} for SecretsManagerClient's `config` shape.
 *
 * @throws {@link InternalServiceError} (server fault)
 *  <p>An error occurred on the server side.</p>
 *
 * @throws {@link InvalidParameterException} (client fault)
 *  <p>The parameter name or value is invalid.</p>
 *
 * @throws {@link InvalidRequestException} (client fault)
 *  <p>A parameter value is not valid for the current state of the
 *       resource.</p>
 *          <p>Possible causes:</p>
 *          <ul>
 *             <li>
 *                <p>The secret is scheduled for deletion.</p>
 *             </li>
 *             <li>
 *                <p>You tried to enable rotation on a secret that doesn't already have a Lambda function
 *           ARN configured and you didn't include such an ARN as a parameter in this call. </p>
 *             </li>
 *             <li>
 *                <p>The secret is managed by another service, and you must use that service to update it.
 *           For more information, see <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/service-linked-secrets.html">Secrets managed by other Amazon Web Services services</a>.</p>
 *             </li>
 *          </ul>
 *
 * @throws {@link ResourceNotFoundException} (client fault)
 *  <p>Secrets Manager can't find the resource that you asked for.</p>
 *
 * @throws {@link SecretsManagerServiceException}
 * <p>Base exception class for all service exceptions from SecretsManager service.</p>
 *
 *
 * @public
 */
export declare class DeleteSecretCommand extends DeleteSecretCommand_base {
    /** @internal type navigation helper, not in runtime. */
    protected static __types: {
        api: {
            input: DeleteSecretRequest;
            output: DeleteSecretResponse;
        };
        sdk: {
            input: DeleteSecretCommandInput;
            output: DeleteSecretCommandOutput;
        };
    };
}

```

## ./lib/lambda/node_modules/@aws-sdk/client-secrets-manager/dist-types/commands/DescribeSecretCommand.d.ts

```typescript
import { Command as $Command } from "@smithy/smithy-client";
import { MetadataBearer as __MetadataBearer } from "@smithy/types";
import { DescribeSecretRequest, DescribeSecretResponse } from "../models/models_0";
import { SecretsManagerClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "../SecretsManagerClient";
/**
 * @public
 */
export type { __MetadataBearer };
export { $Command };
/**
 * @public
 *
 * The input for {@link DescribeSecretCommand}.
 */
export interface DescribeSecretCommandInput extends DescribeSecretRequest {
}
/**
 * @public
 *
 * The output of {@link DescribeSecretCommand}.
 */
export interface DescribeSecretCommandOutput extends DescribeSecretResponse, __MetadataBearer {
}
declare const DescribeSecretCommand_base: {
    new (input: DescribeSecretCommandInput): import("@smithy/smithy-client").CommandImpl<DescribeSecretCommandInput, DescribeSecretCommandOutput, SecretsManagerClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes>;
    new (input: DescribeSecretCommandInput): import("@smithy/smithy-client").CommandImpl<DescribeSecretCommandInput, DescribeSecretCommandOutput, SecretsManagerClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes>;
    getEndpointParameterInstructions(): import("@smithy/middleware-endpoint").EndpointParameterInstructions;
};
/**
 * <p>Retrieves the details of a secret. It does not include the encrypted secret value. Secrets Manager
 *       only returns fields that have a value in the response. </p>
 *          <p>Secrets Manager generates a CloudTrail log entry when you call this action. Do not include sensitive information in request parameters because it might be logged. For more information, see <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/retrieve-ct-entries.html">Logging Secrets Manager events with CloudTrail</a>.</p>
 *          <p>
 *             <b>Required permissions: </b>
 *             <code>secretsmanager:DescribeSecret</code>.
 *       For more information, see <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/reference_iam-permissions.html#reference_iam-permissions_actions">
 *       IAM policy actions for Secrets Manager</a> and <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/auth-and-access.html">Authentication
 *       and access control in Secrets Manager</a>. </p>
 * @example
 * Use a bare-bones client and the command you need to make an API call.
 * ```javascript
 * import { SecretsManagerClient, DescribeSecretCommand } from "@aws-sdk/client-secrets-manager"; // ES Modules import
 * // const { SecretsManagerClient, DescribeSecretCommand } = require("@aws-sdk/client-secrets-manager"); // CommonJS import
 * // import type { SecretsManagerClientConfig } from "@aws-sdk/client-secrets-manager";
 * const config = {}; // type is SecretsManagerClientConfig
 * const client = new SecretsManagerClient(config);
 * const input = { // DescribeSecretRequest
 *   SecretId: "STRING_VALUE", // required
 * };
 * const command = new DescribeSecretCommand(input);
 * const response = await client.send(command);
 * // { // DescribeSecretResponse
 * //   ARN: "STRING_VALUE",
 * //   Name: "STRING_VALUE",
 * //   Description: "STRING_VALUE",
 * //   KmsKeyId: "STRING_VALUE",
 * //   RotationEnabled: true || false,
 * //   RotationLambdaARN: "STRING_VALUE",
 * //   RotationRules: { // RotationRulesType
 * //     AutomaticallyAfterDays: Number("long"),
 * //     Duration: "STRING_VALUE",
 * //     ScheduleExpression: "STRING_VALUE",
 * //   },
 * //   LastRotatedDate: new Date("TIMESTAMP"),
 * //   LastChangedDate: new Date("TIMESTAMP"),
 * //   LastAccessedDate: new Date("TIMESTAMP"),
 * //   DeletedDate: new Date("TIMESTAMP"),
 * //   NextRotationDate: new Date("TIMESTAMP"),
 * //   Tags: [ // TagListType
 * //     { // Tag
 * //       Key: "STRING_VALUE",
 * //       Value: "STRING_VALUE",
 * //     },
 * //   ],
 * //   VersionIdsToStages: { // SecretVersionsToStagesMapType
 * //     "<keys>": [ // SecretVersionStagesType
 * //       "STRING_VALUE",
 * //     ],
 * //   },
 * //   OwningService: "STRING_VALUE",
 * //   CreatedDate: new Date("TIMESTAMP"),
 * //   PrimaryRegion: "STRING_VALUE",
 * //   ReplicationStatus: [ // ReplicationStatusListType
 * //     { // ReplicationStatusType
 * //       Region: "STRING_VALUE",
 * //       KmsKeyId: "STRING_VALUE",
 * //       Status: "InSync" || "Failed" || "InProgress",
 * //       StatusMessage: "STRING_VALUE",
 * //       LastAccessedDate: new Date("TIMESTAMP"),
 * //     },
 * //   ],
 * // };
 *
 * ```
 *
 * @param DescribeSecretCommandInput - {@link DescribeSecretCommandInput}
 * @returns {@link DescribeSecretCommandOutput}
 * @see {@link DescribeSecretCommandInput} for command's `input` shape.
 * @see {@link DescribeSecretCommandOutput} for command's `response` shape.
 * @see {@link SecretsManagerClientResolvedConfig | config} for SecretsManagerClient's `config` shape.
 *
 * @throws {@link InternalServiceError} (server fault)
 *  <p>An error occurred on the server side.</p>
 *
 * @throws {@link InvalidParameterException} (client fault)
 *  <p>The parameter name or value is invalid.</p>
 *
 * @throws {@link ResourceNotFoundException} (client fault)
 *  <p>Secrets Manager can't find the resource that you asked for.</p>
 *
 * @throws {@link SecretsManagerServiceException}
 * <p>Base exception class for all service exceptions from SecretsManager service.</p>
 *
 *
 * @public
 */
export declare class DescribeSecretCommand extends DescribeSecretCommand_base {
    /** @internal type navigation helper, not in runtime. */
    protected static __types: {
        api: {
            input: DescribeSecretRequest;
            output: DescribeSecretResponse;
        };
        sdk: {
            input: DescribeSecretCommandInput;
            output: DescribeSecretCommandOutput;
        };
    };
}

```

## ./lib/lambda/node_modules/@aws-sdk/client-secrets-manager/dist-types/endpoint/EndpointParameters.d.ts

```typescript
import { Endpoint, EndpointParameters as __EndpointParameters, EndpointV2, Provider } from "@smithy/types";
/**
 * @public
 */
export interface ClientInputEndpointParameters {
    region?: string | undefined | Provider<string | undefined>;
    useDualstackEndpoint?: boolean | undefined | Provider<boolean | undefined>;
    useFipsEndpoint?: boolean | undefined | Provider<boolean | undefined>;
    endpoint?: string | Provider<string> | Endpoint | Provider<Endpoint> | EndpointV2 | Provider<EndpointV2>;
}
export type ClientResolvedEndpointParameters = Omit<ClientInputEndpointParameters, "endpoint"> & {
    defaultSigningName: string;
};
export declare const resolveClientEndpointParameters: <T>(options: T & ClientInputEndpointParameters) => T & ClientResolvedEndpointParameters;
export declare const commonParams: {
    readonly UseFIPS: {
        readonly type: "builtInParams";
        readonly name: "useFipsEndpoint";
    };
    readonly Endpoint: {
        readonly type: "builtInParams";
        readonly name: "endpoint";
    };
    readonly Region: {
        readonly type: "builtInParams";
        readonly name: "region";
    };
    readonly UseDualStack: {
        readonly type: "builtInParams";
        readonly name: "useDualstackEndpoint";
    };
};
export interface EndpointParameters extends __EndpointParameters {
    Region?: string | undefined;
    UseDualStack?: boolean | undefined;
    UseFIPS?: boolean | undefined;
    Endpoint?: string | undefined;
}

```

## ./lib/lambda/node_modules/@aws-sdk/client-secrets-manager/dist-types/endpoint/endpointResolver.d.ts

```typescript
import { EndpointV2, Logger } from "@smithy/types";
import { EndpointParameters } from "./EndpointParameters";
export declare const defaultEndpointResolver: (endpointParams: EndpointParameters, context?: {
    logger?: Logger;
}) => EndpointV2;

```

## ./lib/lambda/node_modules/@aws-sdk/client-secrets-manager/dist-types/pagination/BatchGetSecretValuePaginator.d.ts

```typescript
import { Paginator } from "@smithy/types";
import { BatchGetSecretValueCommandInput, BatchGetSecretValueCommandOutput } from "../commands/BatchGetSecretValueCommand";
import { SecretsManagerPaginationConfiguration } from "./Interfaces";
/**
 * @public
 */
export declare const paginateBatchGetSecretValue: (config: SecretsManagerPaginationConfiguration, input: BatchGetSecretValueCommandInput, ...rest: any[]) => Paginator<BatchGetSecretValueCommandOutput>;

```

## ./lib/lambda/node_modules/@aws-sdk/client-secrets-manager/dist-types/protocols/Aws_json1_1.d.ts

```typescript
import { HttpRequest as __HttpRequest, HttpResponse as __HttpResponse } from "@smithy/protocol-http";
import { SerdeContext as __SerdeContext } from "@smithy/types";
import { BatchGetSecretValueCommandInput, BatchGetSecretValueCommandOutput } from "../commands/BatchGetSecretValueCommand";
import { CancelRotateSecretCommandInput, CancelRotateSecretCommandOutput } from "../commands/CancelRotateSecretCommand";
import { CreateSecretCommandInput, CreateSecretCommandOutput } from "../commands/CreateSecretCommand";
import { DeleteResourcePolicyCommandInput, DeleteResourcePolicyCommandOutput } from "../commands/DeleteResourcePolicyCommand";
import { DeleteSecretCommandInput, DeleteSecretCommandOutput } from "../commands/DeleteSecretCommand";
import { DescribeSecretCommandInput, DescribeSecretCommandOutput } from "../commands/DescribeSecretCommand";
import { GetRandomPasswordCommandInput, GetRandomPasswordCommandOutput } from "../commands/GetRandomPasswordCommand";
import { GetResourcePolicyCommandInput, GetResourcePolicyCommandOutput } from "../commands/GetResourcePolicyCommand";
import { GetSecretValueCommandInput, GetSecretValueCommandOutput } from "../commands/GetSecretValueCommand";
import { ListSecretsCommandInput, ListSecretsCommandOutput } from "../commands/ListSecretsCommand";
import { ListSecretVersionIdsCommandInput, ListSecretVersionIdsCommandOutput } from "../commands/ListSecretVersionIdsCommand";
import { PutResourcePolicyCommandInput, PutResourcePolicyCommandOutput } from "../commands/PutResourcePolicyCommand";
import { PutSecretValueCommandInput, PutSecretValueCommandOutput } from "../commands/PutSecretValueCommand";
import { RemoveRegionsFromReplicationCommandInput, RemoveRegionsFromReplicationCommandOutput } from "../commands/RemoveRegionsFromReplicationCommand";
import { ReplicateSecretToRegionsCommandInput, ReplicateSecretToRegionsCommandOutput } from "../commands/ReplicateSecretToRegionsCommand";
import { RestoreSecretCommandInput, RestoreSecretCommandOutput } from "../commands/RestoreSecretCommand";
import { RotateSecretCommandInput, RotateSecretCommandOutput } from "../commands/RotateSecretCommand";
import { StopReplicationToReplicaCommandInput, StopReplicationToReplicaCommandOutput } from "../commands/StopReplicationToReplicaCommand";
import { TagResourceCommandInput, TagResourceCommandOutput } from "../commands/TagResourceCommand";
import { UntagResourceCommandInput, UntagResourceCommandOutput } from "../commands/UntagResourceCommand";
import { UpdateSecretCommandInput, UpdateSecretCommandOutput } from "../commands/UpdateSecretCommand";
import { UpdateSecretVersionStageCommandInput, UpdateSecretVersionStageCommandOutput } from "../commands/UpdateSecretVersionStageCommand";
import { ValidateResourcePolicyCommandInput, ValidateResourcePolicyCommandOutput } from "../commands/ValidateResourcePolicyCommand";
/**
 * serializeAws_json1_1BatchGetSecretValueCommand
 */
export declare const se_BatchGetSecretValueCommand: (input: BatchGetSecretValueCommandInput, context: __SerdeContext) => Promise<__HttpRequest>;
/**
 * serializeAws_json1_1CancelRotateSecretCommand
 */
export declare const se_CancelRotateSecretCommand: (input: CancelRotateSecretCommandInput, context: __SerdeContext) => Promise<__HttpRequest>;
/**
 * serializeAws_json1_1CreateSecretCommand
 */
export declare const se_CreateSecretCommand: (input: CreateSecretCommandInput, context: __SerdeContext) => Promise<__HttpRequest>;
/**
 * serializeAws_json1_1DeleteResourcePolicyCommand
 */
export declare const se_DeleteResourcePolicyCommand: (input: DeleteResourcePolicyCommandInput, context: __SerdeContext) => Promise<__HttpRequest>;
/**
 * serializeAws_json1_1DeleteSecretCommand
 */
export declare const se_DeleteSecretCommand: (input: DeleteSecretCommandInput, context: __SerdeContext) => Promise<__HttpRequest>;
/**
 * serializeAws_json1_1DescribeSecretCommand
 */
export declare const se_DescribeSecretCommand: (input: DescribeSecretCommandInput, context: __SerdeContext) => Promise<__HttpRequest>;
/**
 * serializeAws_json1_1GetRandomPasswordCommand
 */
export declare const se_GetRandomPasswordCommand: (input: GetRandomPasswordCommandInput, context: __SerdeContext) => Promise<__HttpRequest>;
/**
 * serializeAws_json1_1GetResourcePolicyCommand
 */
export declare const se_GetResourcePolicyCommand: (input: GetResourcePolicyCommandInput, context: __SerdeContext) => Promise<__HttpRequest>;
/**
 * serializeAws_json1_1GetSecretValueCommand
 */
export declare const se_GetSecretValueCommand: (input: GetSecretValueCommandInput, context: __SerdeContext) => Promise<__HttpRequest>;
/**
 * serializeAws_json1_1ListSecretsCommand
 */
export declare const se_ListSecretsCommand: (input: ListSecretsCommandInput, context: __SerdeContext) => Promise<__HttpRequest>;
/**
 * serializeAws_json1_1ListSecretVersionIdsCommand
 */
export declare const se_ListSecretVersionIdsCommand: (input: ListSecretVersionIdsCommandInput, context: __SerdeContext) => Promise<__HttpRequest>;
/**
 * serializeAws_json1_1PutResourcePolicyCommand
 */
export declare const se_PutResourcePolicyCommand: (input: PutResourcePolicyCommandInput, context: __SerdeContext) => Promise<__HttpRequest>;
/**
 * serializeAws_json1_1PutSecretValueCommand
 */
export declare const se_PutSecretValueCommand: (input: PutSecretValueCommandInput, context: __SerdeContext) => Promise<__HttpRequest>;
/**
 * serializeAws_json1_1RemoveRegionsFromReplicationCommand
 */
export declare const se_RemoveRegionsFromReplicationCommand: (input: RemoveRegionsFromReplicationCommandInput, context: __SerdeContext) => Promise<__HttpRequest>;
/**
 * serializeAws_json1_1ReplicateSecretToRegionsCommand
 */
export declare const se_ReplicateSecretToRegionsCommand: (input: ReplicateSecretToRegionsCommandInput, context: __SerdeContext) => Promise<__HttpRequest>;
/**
 * serializeAws_json1_1RestoreSecretCommand
 */
export declare const se_RestoreSecretCommand: (input: RestoreSecretCommandInput, context: __SerdeContext) => Promise<__HttpRequest>;
/**
 * serializeAws_json1_1RotateSecretCommand
 */
export declare const se_RotateSecretCommand: (input: RotateSecretCommandInput, context: __SerdeContext) => Promise<__HttpRequest>;
/**
 * serializeAws_json1_1StopReplicationToReplicaCommand
 */
export declare const se_StopReplicationToReplicaCommand: (input: StopReplicationToReplicaCommandInput, context: __SerdeContext) => Promise<__HttpRequest>;
/**
 * serializeAws_json1_1TagResourceCommand
 */
export declare const se_TagResourceCommand: (input: TagResourceCommandInput, context: __SerdeContext) => Promise<__HttpRequest>;
/**
 * serializeAws_json1_1UntagResourceCommand
 */
export declare const se_UntagResourceCommand: (input: UntagResourceCommandInput, context: __SerdeContext) => Promise<__HttpRequest>;
/**
 * serializeAws_json1_1UpdateSecretCommand
 */
export declare const se_UpdateSecretCommand: (input: UpdateSecretCommandInput, context: __SerdeContext) => Promise<__HttpRequest>;
/**
 * serializeAws_json1_1UpdateSecretVersionStageCommand
 */
export declare const se_UpdateSecretVersionStageCommand: (input: UpdateSecretVersionStageCommandInput, context: __SerdeContext) => Promise<__HttpRequest>;
/**
 * serializeAws_json1_1ValidateResourcePolicyCommand
 */
export declare const se_ValidateResourcePolicyCommand: (input: ValidateResourcePolicyCommandInput, context: __SerdeContext) => Promise<__HttpRequest>;
/**
 * deserializeAws_json1_1BatchGetSecretValueCommand
 */
export declare const de_BatchGetSecretValueCommand: (output: __HttpResponse, context: __SerdeContext) => Promise<BatchGetSecretValueCommandOutput>;
/**
 * deserializeAws_json1_1CancelRotateSecretCommand
 */
export declare const de_CancelRotateSecretCommand: (output: __HttpResponse, context: __SerdeContext) => Promise<CancelRotateSecretCommandOutput>;
/**
 * deserializeAws_json1_1CreateSecretCommand
 */
export declare const de_CreateSecretCommand: (output: __HttpResponse, context: __SerdeContext) => Promise<CreateSecretCommandOutput>;
/**
 * deserializeAws_json1_1DeleteResourcePolicyCommand
 */
export declare const de_DeleteResourcePolicyCommand: (output: __HttpResponse, context: __SerdeContext) => Promise<DeleteResourcePolicyCommandOutput>;
/**
 * deserializeAws_json1_1DeleteSecretCommand
 */
export declare const de_DeleteSecretCommand: (output: __HttpResponse, context: __SerdeContext) => Promise<DeleteSecretCommandOutput>;
/**
 * deserializeAws_json1_1DescribeSecretCommand
 */
export declare const de_DescribeSecretCommand: (output: __HttpResponse, context: __SerdeContext) => Promise<DescribeSecretCommandOutput>;
/**
 * deserializeAws_json1_1GetRandomPasswordCommand
 */
export declare const de_GetRandomPasswordCommand: (output: __HttpResponse, context: __SerdeContext) => Promise<GetRandomPasswordCommandOutput>;
/**
 * deserializeAws_json1_1GetResourcePolicyCommand
 */
export declare const de_GetResourcePolicyCommand: (output: __HttpResponse, context: __SerdeContext) => Promise<GetResourcePolicyCommandOutput>;
/**
 * deserializeAws_json1_1GetSecretValueCommand
 */
export declare const de_GetSecretValueCommand: (output: __HttpResponse, context: __SerdeContext) => Promise<GetSecretValueCommandOutput>;
/**
 * deserializeAws_json1_1ListSecretsCommand
 */
export declare const de_ListSecretsCommand: (output: __HttpResponse, context: __SerdeContext) => Promise<ListSecretsCommandOutput>;
/**
 * deserializeAws_json1_1ListSecretVersionIdsCommand
 */
export declare const de_ListSecretVersionIdsCommand: (output: __HttpResponse, context: __SerdeContext) => Promise<ListSecretVersionIdsCommandOutput>;
/**
 * deserializeAws_json1_1PutResourcePolicyCommand
 */
export declare const de_PutResourcePolicyCommand: (output: __HttpResponse, context: __SerdeContext) => Promise<PutResourcePolicyCommandOutput>;
/**
 * deserializeAws_json1_1PutSecretValueCommand
 */
export declare const de_PutSecretValueCommand: (output: __HttpResponse, context: __SerdeContext) => Promise<PutSecretValueCommandOutput>;
/**
 * deserializeAws_json1_1RemoveRegionsFromReplicationCommand
 */
export declare const de_RemoveRegionsFromReplicationCommand: (output: __HttpResponse, context: __SerdeContext) => Promise<RemoveRegionsFromReplicationCommandOutput>;
/**
 * deserializeAws_json1_1ReplicateSecretToRegionsCommand
 */
export declare const de_ReplicateSecretToRegionsCommand: (output: __HttpResponse, context: __SerdeContext) => Promise<ReplicateSecretToRegionsCommandOutput>;
/**
 * deserializeAws_json1_1RestoreSecretCommand
 */
export declare const de_RestoreSecretCommand: (output: __HttpResponse, context: __SerdeContext) => Promise<RestoreSecretCommandOutput>;
/**
 * deserializeAws_json1_1RotateSecretCommand
 */
export declare const de_RotateSecretCommand: (output: __HttpResponse, context: __SerdeContext) => Promise<RotateSecretCommandOutput>;
/**
 * deserializeAws_json1_1StopReplicationToReplicaCommand
 */
export declare const de_StopReplicationToReplicaCommand: (output: __HttpResponse, context: __SerdeContext) => Promise<StopReplicationToReplicaCommandOutput>;
/**
 * deserializeAws_json1_1TagResourceCommand
 */
export declare const de_TagResourceCommand: (output: __HttpResponse, context: __SerdeContext) => Promise<TagResourceCommandOutput>;
/**
 * deserializeAws_json1_1UntagResourceCommand
 */
export declare const de_UntagResourceCommand: (output: __HttpResponse, context: __SerdeContext) => Promise<UntagResourceCommandOutput>;
/**
 * deserializeAws_json1_1UpdateSecretCommand
 */
export declare const de_UpdateSecretCommand: (output: __HttpResponse, context: __SerdeContext) => Promise<UpdateSecretCommandOutput>;
/**
 * deserializeAws_json1_1UpdateSecretVersionStageCommand
 */
export declare const de_UpdateSecretVersionStageCommand: (output: __HttpResponse, context: __SerdeContext) => Promise<UpdateSecretVersionStageCommandOutput>;
/**
 * deserializeAws_json1_1ValidateResourcePolicyCommand
 */
export declare const de_ValidateResourcePolicyCommand: (output: __HttpResponse, context: __SerdeContext) => Promise<ValidateResourcePolicyCommandOutput>;

```

## ./lib/lambda/node_modules/@aws-sdk/client-secrets-manager/dist-types/ts3.4/commands/BatchGetSecretValueCommand.d.ts

```typescript
import { Command as $Command } from "@smithy/smithy-client";
import { MetadataBearer as __MetadataBearer } from "@smithy/types";
import {
  BatchGetSecretValueRequest,
  BatchGetSecretValueResponse,
} from "../models/models_0";
import {
  SecretsManagerClientResolvedConfig,
  ServiceInputTypes,
  ServiceOutputTypes,
} from "../SecretsManagerClient";
export { __MetadataBearer };
export { $Command };
export interface BatchGetSecretValueCommandInput
  extends BatchGetSecretValueRequest {}
export interface BatchGetSecretValueCommandOutput
  extends BatchGetSecretValueResponse,
    __MetadataBearer {}
declare const BatchGetSecretValueCommand_base: {
  new (
    input: BatchGetSecretValueCommandInput
  ): import("@smithy/smithy-client").CommandImpl<
    BatchGetSecretValueCommandInput,
    BatchGetSecretValueCommandOutput,
    SecretsManagerClientResolvedConfig,
    ServiceInputTypes,
    ServiceOutputTypes
  >;
  new (
    ...[input]: [] | [BatchGetSecretValueCommandInput]
  ): import("@smithy/smithy-client").CommandImpl<
    BatchGetSecretValueCommandInput,
    BatchGetSecretValueCommandOutput,
    SecretsManagerClientResolvedConfig,
    ServiceInputTypes,
    ServiceOutputTypes
  >;
  getEndpointParameterInstructions(): import("@smithy/middleware-endpoint").EndpointParameterInstructions;
};
export declare class BatchGetSecretValueCommand extends BatchGetSecretValueCommand_base {
  protected static __types: {
    api: {
      input: BatchGetSecretValueRequest;
      output: BatchGetSecretValueResponse;
    };
    sdk: {
      input: BatchGetSecretValueCommandInput;
      output: BatchGetSecretValueCommandOutput;
    };
  };
}

```

## ./lib/lambda/node_modules/@aws-sdk/client-secrets-manager/dist-types/ts3.4/commands/CancelRotateSecretCommand.d.ts

```typescript
import { Command as $Command } from "@smithy/smithy-client";
import { MetadataBearer as __MetadataBearer } from "@smithy/types";
import {
  CancelRotateSecretRequest,
  CancelRotateSecretResponse,
} from "../models/models_0";
import {
  SecretsManagerClientResolvedConfig,
  ServiceInputTypes,
  ServiceOutputTypes,
} from "../SecretsManagerClient";
export { __MetadataBearer };
export { $Command };
export interface CancelRotateSecretCommandInput
  extends CancelRotateSecretRequest {}
export interface CancelRotateSecretCommandOutput
  extends CancelRotateSecretResponse,
    __MetadataBearer {}
declare const CancelRotateSecretCommand_base: {
  new (
    input: CancelRotateSecretCommandInput
  ): import("@smithy/smithy-client").CommandImpl<
    CancelRotateSecretCommandInput,
    CancelRotateSecretCommandOutput,
    SecretsManagerClientResolvedConfig,
    ServiceInputTypes,
    ServiceOutputTypes
  >;
  new (
    input: CancelRotateSecretCommandInput
  ): import("@smithy/smithy-client").CommandImpl<
    CancelRotateSecretCommandInput,
    CancelRotateSecretCommandOutput,
    SecretsManagerClientResolvedConfig,
    ServiceInputTypes,
    ServiceOutputTypes
  >;
  getEndpointParameterInstructions(): import("@smithy/middleware-endpoint").EndpointParameterInstructions;
};
export declare class CancelRotateSecretCommand extends CancelRotateSecretCommand_base {
  protected static __types: {
    api: {
      input: CancelRotateSecretRequest;
      output: CancelRotateSecretResponse;
    };
    sdk: {
      input: CancelRotateSecretCommandInput;
      output: CancelRotateSecretCommandOutput;
    };
  };
}

```

## ./lib/lambda/node_modules/@aws-sdk/client-secrets-manager/dist-types/ts3.4/commands/CreateSecretCommand.d.ts

```typescript
import { Command as $Command } from "@smithy/smithy-client";
import { MetadataBearer as __MetadataBearer } from "@smithy/types";
import { CreateSecretRequest, CreateSecretResponse } from "../models/models_0";
import {
  SecretsManagerClientResolvedConfig,
  ServiceInputTypes,
  ServiceOutputTypes,
} from "../SecretsManagerClient";
export { __MetadataBearer };
export { $Command };
export interface CreateSecretCommandInput extends CreateSecretRequest {}
export interface CreateSecretCommandOutput
  extends CreateSecretResponse,
    __MetadataBearer {}
declare const CreateSecretCommand_base: {
  new (
    input: CreateSecretCommandInput
  ): import("@smithy/smithy-client").CommandImpl<
    CreateSecretCommandInput,
    CreateSecretCommandOutput,
    SecretsManagerClientResolvedConfig,
    ServiceInputTypes,
    ServiceOutputTypes
  >;
  new (
    input: CreateSecretCommandInput
  ): import("@smithy/smithy-client").CommandImpl<
    CreateSecretCommandInput,
    CreateSecretCommandOutput,
    SecretsManagerClientResolvedConfig,
    ServiceInputTypes,
    ServiceOutputTypes
  >;
  getEndpointParameterInstructions(): import("@smithy/middleware-endpoint").EndpointParameterInstructions;
};
export declare class CreateSecretCommand extends CreateSecretCommand_base {
  protected static __types: {
    api: {
      input: CreateSecretRequest;
      output: CreateSecretResponse;
    };
    sdk: {
      input: CreateSecretCommandInput;
      output: CreateSecretCommandOutput;
    };
  };
}

```

## ./lib/lambda/node_modules/@aws-sdk/client-secrets-manager/dist-types/ts3.4/commands/DeleteResourcePolicyCommand.d.ts

```typescript
import { Command as $Command } from "@smithy/smithy-client";
import { MetadataBearer as __MetadataBearer } from "@smithy/types";
import {
  DeleteResourcePolicyRequest,
  DeleteResourcePolicyResponse,
} from "../models/models_0";
import {
  SecretsManagerClientResolvedConfig,
  ServiceInputTypes,
  ServiceOutputTypes,
} from "../SecretsManagerClient";
export { __MetadataBearer };
export { $Command };
export interface DeleteResourcePolicyCommandInput
  extends DeleteResourcePolicyRequest {}
export interface DeleteResourcePolicyCommandOutput
  extends DeleteResourcePolicyResponse,
    __MetadataBearer {}
declare const DeleteResourcePolicyCommand_base: {
  new (
    input: DeleteResourcePolicyCommandInput
  ): import("@smithy/smithy-client").CommandImpl<
    DeleteResourcePolicyCommandInput,
    DeleteResourcePolicyCommandOutput,
    SecretsManagerClientResolvedConfig,
    ServiceInputTypes,
    ServiceOutputTypes
  >;
  new (
    input: DeleteResourcePolicyCommandInput
  ): import("@smithy/smithy-client").CommandImpl<
    DeleteResourcePolicyCommandInput,
    DeleteResourcePolicyCommandOutput,
    SecretsManagerClientResolvedConfig,
    ServiceInputTypes,
    ServiceOutputTypes
  >;
  getEndpointParameterInstructions(): import("@smithy/middleware-endpoint").EndpointParameterInstructions;
};
export declare class DeleteResourcePolicyCommand extends DeleteResourcePolicyCommand_base {
  protected static __types: {
    api: {
      input: DeleteResourcePolicyRequest;
      output: DeleteResourcePolicyResponse;
    };
    sdk: {
      input: DeleteResourcePolicyCommandInput;
      output: DeleteResourcePolicyCommandOutput;
    };
  };
}

```

## ./lib/lambda/node_modules/@aws-sdk/client-secrets-manager/dist-types/ts3.4/commands/DeleteSecretCommand.d.ts

```typescript
import { Command as $Command } from "@smithy/smithy-client";
import { MetadataBearer as __MetadataBearer } from "@smithy/types";
import { DeleteSecretRequest, DeleteSecretResponse } from "../models/models_0";
import {
  SecretsManagerClientResolvedConfig,
  ServiceInputTypes,
  ServiceOutputTypes,
} from "../SecretsManagerClient";
export { __MetadataBearer };
export { $Command };
export interface DeleteSecretCommandInput extends DeleteSecretRequest {}
export interface DeleteSecretCommandOutput
  extends DeleteSecretResponse,
    __MetadataBearer {}
declare const DeleteSecretCommand_base: {
  new (
    input: DeleteSecretCommandInput
  ): import("@smithy/smithy-client").CommandImpl<
    DeleteSecretCommandInput,
    DeleteSecretCommandOutput,
    SecretsManagerClientResolvedConfig,
    ServiceInputTypes,
    ServiceOutputTypes
  >;
  new (
    input: DeleteSecretCommandInput
  ): import("@smithy/smithy-client").CommandImpl<
    DeleteSecretCommandInput,
    DeleteSecretCommandOutput,
    SecretsManagerClientResolvedConfig,
    ServiceInputTypes,
    ServiceOutputTypes
  >;
  getEndpointParameterInstructions(): import("@smithy/middleware-endpoint").EndpointParameterInstructions;
};
export declare class DeleteSecretCommand extends DeleteSecretCommand_base {
  protected static __types: {
    api: {
      input: DeleteSecretRequest;
      output: DeleteSecretResponse;
    };
    sdk: {
      input: DeleteSecretCommandInput;
      output: DeleteSecretCommandOutput;
    };
  };
}

```

## ./lib/lambda/node_modules/@aws-sdk/client-secrets-manager/dist-types/ts3.4/commands/DescribeSecretCommand.d.ts

```typescript
import { Command as $Command } from "@smithy/smithy-client";
import { MetadataBearer as __MetadataBearer } from "@smithy/types";
import {
  DescribeSecretRequest,
  DescribeSecretResponse,
} from "../models/models_0";
import {
  SecretsManagerClientResolvedConfig,
  ServiceInputTypes,
  ServiceOutputTypes,
} from "../SecretsManagerClient";
export { __MetadataBearer };
export { $Command };
export interface DescribeSecretCommandInput extends DescribeSecretRequest {}
export interface DescribeSecretCommandOutput
  extends DescribeSecretResponse,
    __MetadataBearer {}
declare const DescribeSecretCommand_base: {
  new (
    input: DescribeSecretCommandInput
  ): import("@smithy/smithy-client").CommandImpl<
    DescribeSecretCommandInput,
    DescribeSecretCommandOutput,
    SecretsManagerClientResolvedConfig,
    ServiceInputTypes,
    ServiceOutputTypes
  >;
  new (
    input: DescribeSecretCommandInput
  ): import("@smithy/smithy-client").CommandImpl<
    DescribeSecretCommandInput,
    DescribeSecretCommandOutput,
    SecretsManagerClientResolvedConfig,
    ServiceInputTypes,
    ServiceOutputTypes
  >;
  getEndpointParameterInstructions(): import("@smithy/middleware-endpoint").EndpointParameterInstructions;
};
export declare class DescribeSecretCommand extends DescribeSecretCommand_base {
  protected static __types: {
    api: {
      input: DescribeSecretRequest;
      output: DescribeSecretResponse;
    };
    sdk: {
      input: DescribeSecretCommandInput;
      output: DescribeSecretCommandOutput;
    };
  };
}

```

## ./lib/lambda/node_modules/@aws-sdk/client-secrets-manager/dist-types/ts3.4/endpoint/EndpointParameters.d.ts

```typescript
import {
  Endpoint,
  EndpointParameters as __EndpointParameters,
  EndpointV2,
  Provider,
} from "@smithy/types";
export interface ClientInputEndpointParameters {
  region?: string | undefined | Provider<string | undefined>;
  useDualstackEndpoint?: boolean | undefined | Provider<boolean | undefined>;
  useFipsEndpoint?: boolean | undefined | Provider<boolean | undefined>;
  endpoint?:
    | string
    | Provider<string>
    | Endpoint
    | Provider<Endpoint>
    | EndpointV2
    | Provider<EndpointV2>;
}
export type ClientResolvedEndpointParameters = Pick<
  ClientInputEndpointParameters,
  Exclude<keyof ClientInputEndpointParameters, "endpoint">
> & {
  defaultSigningName: string;
};
export declare const resolveClientEndpointParameters: <T>(
  options: T & ClientInputEndpointParameters
) => T & ClientResolvedEndpointParameters;
export declare const commonParams: {
  readonly UseFIPS: {
    readonly type: "builtInParams";
    readonly name: "useFipsEndpoint";
  };
  readonly Endpoint: {
    readonly type: "builtInParams";
    readonly name: "endpoint";
  };
  readonly Region: {
    readonly type: "builtInParams";
    readonly name: "region";
  };
  readonly UseDualStack: {
    readonly type: "builtInParams";
    readonly name: "useDualstackEndpoint";
  };
};
export interface EndpointParameters extends __EndpointParameters {
  Region?: string | undefined;
  UseDualStack?: boolean | undefined;
  UseFIPS?: boolean | undefined;
  Endpoint?: string | undefined;
}

```

## ./lib/lambda/node_modules/@aws-sdk/client-secrets-manager/dist-types/ts3.4/endpoint/endpointResolver.d.ts

```typescript

```

## ./lib/lambda/node_modules/@aws-sdk/client-secrets-manager/dist-types/ts3.4/pagination/BatchGetSecretValuePaginator.d.ts

```typescript
import { Paginator } from "@smithy/types";
import {
  BatchGetSecretValueCommandInput,
  BatchGetSecretValueCommandOutput,
} from "../commands/BatchGetSecretValueCommand";
import { SecretsManagerPaginationConfiguration } from "./Interfaces";
export declare const paginateBatchGetSecretValue: (
  config: SecretsManagerPaginationConfiguration,
  input: BatchGetSecretValueCommandInput,
  ...rest: any[]
) => Paginator<BatchGetSecretValueCommandOutput>;

```

## ./lib/lambda/node_modules/@aws-sdk/client-secrets-manager/dist-types/ts3.4/protocols/Aws_json1_1.d.ts

```typescript
import {
  HttpRequest as __HttpRequest,
  HttpResponse as __HttpResponse,
} from "@smithy/protocol-http";
import { SerdeContext as __SerdeContext } from "@smithy/types";
import {
  BatchGetSecretValueCommandInput,
  BatchGetSecretValueCommandOutput,
} from "../commands/BatchGetSecretValueCommand";
import {
  CancelRotateSecretCommandInput,
  CancelRotateSecretCommandOutput,
} from "../commands/CancelRotateSecretCommand";
import {
  CreateSecretCommandInput,
  CreateSecretCommandOutput,
} from "../commands/CreateSecretCommand";
import {
  DeleteResourcePolicyCommandInput,
  DeleteResourcePolicyCommandOutput,
} from "../commands/DeleteResourcePolicyCommand";
import {
  DeleteSecretCommandInput,
  DeleteSecretCommandOutput,
} from "../commands/DeleteSecretCommand";
import {
  DescribeSecretCommandInput,
  DescribeSecretCommandOutput,
} from "../commands/DescribeSecretCommand";
import {
  GetRandomPasswordCommandInput,
  GetRandomPasswordCommandOutput,
} from "../commands/GetRandomPasswordCommand";
import {
  GetResourcePolicyCommandInput,
  GetResourcePolicyCommandOutput,
} from "../commands/GetResourcePolicyCommand";
import {
  GetSecretValueCommandInput,
  GetSecretValueCommandOutput,
} from "../commands/GetSecretValueCommand";
import {
  ListSecretsCommandInput,
  ListSecretsCommandOutput,
} from "../commands/ListSecretsCommand";
import {
  ListSecretVersionIdsCommandInput,
  ListSecretVersionIdsCommandOutput,
} from "../commands/ListSecretVersionIdsCommand";
import {
  PutResourcePolicyCommandInput,
  PutResourcePolicyCommandOutput,
} from "../commands/PutResourcePolicyCommand";
import {
  PutSecretValueCommandInput,
  PutSecretValueCommandOutput,
} from "../commands/PutSecretValueCommand";
import {
  RemoveRegionsFromReplicationCommandInput,
  RemoveRegionsFromReplicationCommandOutput,
} from "../commands/RemoveRegionsFromReplicationCommand";
import {
  ReplicateSecretToRegionsCommandInput,
  ReplicateSecretToRegionsCommandOutput,
} from "../commands/ReplicateSecretToRegionsCommand";
import {
  RestoreSecretCommandInput,
  RestoreSecretCommandOutput,
} from "../commands/RestoreSecretCommand";
import {
  RotateSecretCommandInput,
  RotateSecretCommandOutput,
} from "../commands/RotateSecretCommand";
import {
  StopReplicationToReplicaCommandInput,
  StopReplicationToReplicaCommandOutput,
} from "../commands/StopReplicationToReplicaCommand";
import {
  TagResourceCommandInput,
  TagResourceCommandOutput,
} from "../commands/TagResourceCommand";
import {
  UntagResourceCommandInput,
  UntagResourceCommandOutput,
} from "../commands/UntagResourceCommand";
import {
  UpdateSecretCommandInput,
  UpdateSecretCommandOutput,
} from "../commands/UpdateSecretCommand";
import {
  UpdateSecretVersionStageCommandInput,
  UpdateSecretVersionStageCommandOutput,
} from "../commands/UpdateSecretVersionStageCommand";
import {
  ValidateResourcePolicyCommandInput,
  ValidateResourcePolicyCommandOutput,
} from "../commands/ValidateResourcePolicyCommand";
export declare const se_BatchGetSecretValueCommand: (
  input: BatchGetSecretValueCommandInput,
  context: __SerdeContext
) => Promise<__HttpRequest>;
export declare const se_CancelRotateSecretCommand: (
  input: CancelRotateSecretCommandInput,
  context: __SerdeContext
) => Promise<__HttpRequest>;
export declare const se_CreateSecretCommand: (
  input: CreateSecretCommandInput,
  context: __SerdeContext
) => Promise<__HttpRequest>;
export declare const se_DeleteResourcePolicyCommand: (
  input: DeleteResourcePolicyCommandInput,
  context: __SerdeContext
) => Promise<__HttpRequest>;
export declare const se_DeleteSecretCommand: (
  input: DeleteSecretCommandInput,
  context: __SerdeContext
) => Promise<__HttpRequest>;
export declare const se_DescribeSecretCommand: (
  input: DescribeSecretCommandInput,
  context: __SerdeContext
) => Promise<__HttpRequest>;
export declare const se_GetRandomPasswordCommand: (
  input: GetRandomPasswordCommandInput,
  context: __SerdeContext
) => Promise<__HttpRequest>;
export declare const se_GetResourcePolicyCommand: (
  input: GetResourcePolicyCommandInput,
  context: __SerdeContext
) => Promise<__HttpRequest>;
export declare const se_GetSecretValueCommand: (
  input: GetSecretValueCommandInput,
  context: __SerdeContext
) => Promise<__HttpRequest>;
export declare const se_ListSecretsCommand: (
  input: ListSecretsCommandInput,
  context: __SerdeContext
) => Promise<__HttpRequest>;
export declare const se_ListSecretVersionIdsCommand: (
  input: ListSecretVersionIdsCommandInput,
  context: __SerdeContext
) => Promise<__HttpRequest>;
export declare const se_PutResourcePolicyCommand: (
  input: PutResourcePolicyCommandInput,
  context: __SerdeContext
) => Promise<__HttpRequest>;
export declare const se_PutSecretValueCommand: (
  input: PutSecretValueCommandInput,
  context: __SerdeContext
) => Promise<__HttpRequest>;
export declare const se_RemoveRegionsFromReplicationCommand: (
  input: RemoveRegionsFromReplicationCommandInput,
  context: __SerdeContext
) => Promise<__HttpRequest>;
export declare const se_ReplicateSecretToRegionsCommand: (
  input: ReplicateSecretToRegionsCommandInput,
  context: __SerdeContext
) => Promise<__HttpRequest>;
export declare const se_RestoreSecretCommand: (
  input: RestoreSecretCommandInput,
  context: __SerdeContext
) => Promise<__HttpRequest>;
export declare const se_RotateSecretCommand: (
  input: RotateSecretCommandInput,
  context: __SerdeContext
) => Promise<__HttpRequest>;
export declare const se_StopReplicationToReplicaCommand: (
  input: StopReplicationToReplicaCommandInput,
  context: __SerdeContext
) => Promise<__HttpRequest>;
export declare const se_TagResourceCommand: (
  input: TagResourceCommandInput,
  context: __SerdeContext
) => Promise<__HttpRequest>;
export declare const se_UntagResourceCommand: (
  input: UntagResourceCommandInput,
  context: __SerdeContext
) => Promise<__HttpRequest>;
export declare const se_UpdateSecretCommand: (
  input: UpdateSecretCommandInput,
  context: __SerdeContext
) => Promise<__HttpRequest>;
export declare const se_UpdateSecretVersionStageCommand: (
  input: UpdateSecretVersionStageCommandInput,
  context: __SerdeContext
) => Promise<__HttpRequest>;
export declare const se_ValidateResourcePolicyCommand: (
  input: ValidateResourcePolicyCommandInput,
  context: __SerdeContext
) => Promise<__HttpRequest>;
export declare const de_BatchGetSecretValueCommand: (
  output: __HttpResponse,
  context: __SerdeContext
) => Promise<BatchGetSecretValueCommandOutput>;
export declare const de_CancelRotateSecretCommand: (
  output: __HttpResponse,
  context: __SerdeContext
) => Promise<CancelRotateSecretCommandOutput>;
export declare const de_CreateSecretCommand: (
  output: __HttpResponse,
  context: __SerdeContext
) => Promise<CreateSecretCommandOutput>;
export declare const de_DeleteResourcePolicyCommand: (
  output: __HttpResponse,
  context: __SerdeContext
) => Promise<DeleteResourcePolicyCommandOutput>;
export declare const de_DeleteSecretCommand: (
  output: __HttpResponse,
  context: __SerdeContext
) => Promise<DeleteSecretCommandOutput>;
export declare const de_DescribeSecretCommand: (
  output: __HttpResponse,
  context: __SerdeContext
) => Promise<DescribeSecretCommandOutput>;
export declare const de_GetRandomPasswordCommand: (
  output: __HttpResponse,
  context: __SerdeContext
) => Promise<GetRandomPasswordCommandOutput>;
export declare const de_GetResourcePolicyCommand: (
  output: __HttpResponse,
  context: __SerdeContext
) => Promise<GetResourcePolicyCommandOutput>;
export declare const de_GetSecretValueCommand: (
  output: __HttpResponse,
  context: __SerdeContext
) => Promise<GetSecretValueCommandOutput>;
export declare const de_ListSecretsCommand: (
  output: __HttpResponse,
  context: __SerdeContext
) => Promise<ListSecretsCommandOutput>;
export declare const de_ListSecretVersionIdsCommand: (
  output: __HttpResponse,
  context: __SerdeContext
) => Promise<ListSecretVersionIdsCommandOutput>;
export declare const de_PutResourcePolicyCommand: (
  output: __HttpResponse,
  context: __SerdeContext
) => Promise<PutResourcePolicyCommandOutput>;
export declare const de_PutSecretValueCommand: (
  output: __HttpResponse,
  context: __SerdeContext
) => Promise<PutSecretValueCommandOutput>;
export declare const de_RemoveRegionsFromReplicationCommand: (
  output: __HttpResponse,
  context: __SerdeContext
) => Promise<RemoveRegionsFromReplicationCommandOutput>;
export declare const de_ReplicateSecretToRegionsCommand: (
  output: __HttpResponse,
  context: __SerdeContext
) => Promise<ReplicateSecretToRegionsCommandOutput>;
export declare const de_RestoreSecretCommand: (
  output: __HttpResponse,
  context: __SerdeContext
) => Promise<RestoreSecretCommandOutput>;
export declare const de_RotateSecretCommand: (
  output: __HttpResponse,
  context: __SerdeContext
) => Promise<RotateSecretCommandOutput>;
export declare const de_StopReplicationToReplicaCommand: (
  output: __HttpResponse,
  context: __SerdeContext
) => Promise<StopReplicationToReplicaCommandOutput>;
export declare const de_TagResourceCommand: (
  output: __HttpResponse,
  context: __SerdeContext
) => Promise<TagResourceCommandOutput>;
export declare const de_UntagResourceCommand: (
  output: __HttpResponse,
  context: __SerdeContext
) => Promise<UntagResourceCommandOutput>;
export declare const de_UpdateSecretCommand: (
  output: __HttpResponse,
  context: __SerdeContext
) => Promise<UpdateSecretCommandOutput>;
export declare const de_UpdateSecretVersionStageCommand: (
  output: __HttpResponse,
  context: __SerdeContext
) => Promise<UpdateSecretVersionStageCommandOutput>;
export declare const de_ValidateResourcePolicyCommand: (
  output: __HttpResponse,
  context: __SerdeContext
) => Promise<ValidateResourcePolicyCommandOutput>;

```

## ./lib/lambda/node_modules/@aws-sdk/client-secrets-manager/package.json

```json
{
  "name": "@aws-sdk/client-secrets-manager",
  "description": "AWS SDK for JavaScript Secrets Manager Client for Node.js, Browser and React Native",
  "version": "3.911.0",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "node ../../scripts/compilation/inline client-secrets-manager",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "extract:docs": "api-extractor run --local",
    "generate:client": "node ../../scripts/generate-clients/single-service --solo secrets-manager"
  },
  "main": "./dist-cjs/index.js",
  "types": "./dist-types/index.d.ts",
  "module": "./dist-es/index.js",
  "sideEffects": false,
  "dependencies": {
    "@aws-crypto/sha256-browser": "5.2.0",
    "@aws-crypto/sha256-js": "5.2.0",
    "@aws-sdk/core": "3.911.0",
    "@aws-sdk/credential-provider-node": "3.911.0",
    "@aws-sdk/middleware-host-header": "3.910.0",
    "@aws-sdk/middleware-logger": "3.910.0",
    "@aws-sdk/middleware-recursion-detection": "3.910.0",
    "@aws-sdk/middleware-user-agent": "3.911.0",
    "@aws-sdk/region-config-resolver": "3.910.0",
    "@aws-sdk/types": "3.910.0",
    "@aws-sdk/util-endpoints": "3.910.0",
    "@aws-sdk/util-user-agent-browser": "3.910.0",
    "@aws-sdk/util-user-agent-node": "3.911.0",
    "@smithy/config-resolver": "^4.3.2",
    "@smithy/core": "^3.16.1",
    "@smithy/fetch-http-handler": "^5.3.3",
    "@smithy/hash-node": "^4.2.2",
    "@smithy/invalid-dependency": "^4.2.2",
    "@smithy/middleware-content-length": "^4.2.2",
    "@smithy/middleware-endpoint": "^4.3.3",
    "@smithy/middleware-retry": "^4.4.3",
    "@smithy/middleware-serde": "^4.2.2",
    "@smithy/middleware-stack": "^4.2.2",
    "@smithy/node-config-provider": "^4.3.2",
    "@smithy/node-http-handler": "^4.4.1",
    "@smithy/protocol-http": "^5.3.2",
    "@smithy/smithy-client": "^4.8.1",
    "@smithy/types": "^4.7.1",
    "@smithy/url-parser": "^4.2.2",
    "@smithy/util-base64": "^4.3.0",
    "@smithy/util-body-length-browser": "^4.2.0",
    "@smithy/util-body-length-node": "^4.2.1",
    "@smithy/util-defaults-mode-browser": "^4.3.2",
    "@smithy/util-defaults-mode-node": "^4.2.3",
    "@smithy/util-endpoints": "^3.2.2",
    "@smithy/util-middleware": "^4.2.2",
    "@smithy/util-retry": "^4.2.2",
    "@smithy/util-utf8": "^4.2.0",
    "@smithy/uuid": "^1.1.0",
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "@tsconfig/node18": "18.2.4",
    "@types/node": "^18.19.69",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typescript": "~5.8.3"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "browser": {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
  },
  "react-native": {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
  },
  "homepage": "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-secrets-manager",
  "repository": {
    "type": "git",
    "url": "https://github.com/aws/aws-sdk-js-v3.git",
    "directory": "clients/client-secrets-manager"
  }
}

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/dist-types/SSO.d.ts

```typescript
import { HttpHandlerOptions as __HttpHandlerOptions } from "@smithy/types";
import { GetRoleCredentialsCommandInput, GetRoleCredentialsCommandOutput } from "./commands/GetRoleCredentialsCommand";
import { ListAccountRolesCommandInput, ListAccountRolesCommandOutput } from "./commands/ListAccountRolesCommand";
import { ListAccountsCommandInput, ListAccountsCommandOutput } from "./commands/ListAccountsCommand";
import { LogoutCommandInput, LogoutCommandOutput } from "./commands/LogoutCommand";
import { SSOClient } from "./SSOClient";
export interface SSO {
    /**
     * @see {@link GetRoleCredentialsCommand}
     */
    getRoleCredentials(args: GetRoleCredentialsCommandInput, options?: __HttpHandlerOptions): Promise<GetRoleCredentialsCommandOutput>;
    getRoleCredentials(args: GetRoleCredentialsCommandInput, cb: (err: any, data?: GetRoleCredentialsCommandOutput) => void): void;
    getRoleCredentials(args: GetRoleCredentialsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetRoleCredentialsCommandOutput) => void): void;
    /**
     * @see {@link ListAccountRolesCommand}
     */
    listAccountRoles(args: ListAccountRolesCommandInput, options?: __HttpHandlerOptions): Promise<ListAccountRolesCommandOutput>;
    listAccountRoles(args: ListAccountRolesCommandInput, cb: (err: any, data?: ListAccountRolesCommandOutput) => void): void;
    listAccountRoles(args: ListAccountRolesCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListAccountRolesCommandOutput) => void): void;
    /**
     * @see {@link ListAccountsCommand}
     */
    listAccounts(args: ListAccountsCommandInput, options?: __HttpHandlerOptions): Promise<ListAccountsCommandOutput>;
    listAccounts(args: ListAccountsCommandInput, cb: (err: any, data?: ListAccountsCommandOutput) => void): void;
    listAccounts(args: ListAccountsCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ListAccountsCommandOutput) => void): void;
    /**
     * @see {@link LogoutCommand}
     */
    logout(args: LogoutCommandInput, options?: __HttpHandlerOptions): Promise<LogoutCommandOutput>;
    logout(args: LogoutCommandInput, cb: (err: any, data?: LogoutCommandOutput) => void): void;
    logout(args: LogoutCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: LogoutCommandOutput) => void): void;
}
/**
 * <p>AWS IAM Identity Center (successor to AWS Single Sign-On) Portal is a web service that makes it easy for you to assign user access to
 *       IAM Identity Center resources such as the AWS access portal. Users can get AWS account applications and roles
 *       assigned to them and get federated into the application.</p>
 *          <note>
 *             <p>Although AWS Single Sign-On was renamed, the <code>sso</code> and
 *           <code>identitystore</code> API namespaces will continue to retain their original name for
 *         backward compatibility purposes. For more information, see <a href="https://docs.aws.amazon.com/singlesignon/latest/userguide/what-is.html#renamed">IAM Identity Center rename</a>.</p>
 *          </note>
 *          <p>This reference guide describes the IAM Identity Center Portal operations that you can call
 *       programatically and includes detailed information on data types and errors.</p>
 *          <note>
 *             <p>AWS provides SDKs that consist of libraries and sample code for various programming
 *         languages and platforms, such as Java, Ruby, .Net, iOS, or Android. The SDKs provide a
 *         convenient way to create programmatic access to IAM Identity Center and other AWS services. For more
 *         information about the AWS SDKs, including how to download and install them, see <a href="http://aws.amazon.com/tools/">Tools for Amazon Web Services</a>.</p>
 *          </note>
 * @public
 */
export declare class SSO extends SSOClient implements SSO {
}

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/dist-types/SSOClient.d.ts

```typescript
import { HostHeaderInputConfig, HostHeaderResolvedConfig } from "@aws-sdk/middleware-host-header";
import { UserAgentInputConfig, UserAgentResolvedConfig } from "@aws-sdk/middleware-user-agent";
import { RegionInputConfig, RegionResolvedConfig } from "@smithy/config-resolver";
import { EndpointInputConfig, EndpointResolvedConfig } from "@smithy/middleware-endpoint";
import { RetryInputConfig, RetryResolvedConfig } from "@smithy/middleware-retry";
import { HttpHandlerUserInput as __HttpHandlerUserInput } from "@smithy/protocol-http";
import { Client as __Client, DefaultsMode as __DefaultsMode, SmithyConfiguration as __SmithyConfiguration, SmithyResolvedConfiguration as __SmithyResolvedConfiguration } from "@smithy/smithy-client";
import { BodyLengthCalculator as __BodyLengthCalculator, CheckOptionalClientConfig as __CheckOptionalClientConfig, ChecksumConstructor as __ChecksumConstructor, Decoder as __Decoder, Encoder as __Encoder, HashConstructor as __HashConstructor, HttpHandlerOptions as __HttpHandlerOptions, Logger as __Logger, Provider as __Provider, Provider, StreamCollector as __StreamCollector, UrlParser as __UrlParser, UserAgent as __UserAgent } from "@smithy/types";
import { HttpAuthSchemeInputConfig, HttpAuthSchemeResolvedConfig } from "./auth/httpAuthSchemeProvider";
import { GetRoleCredentialsCommandInput, GetRoleCredentialsCommandOutput } from "./commands/GetRoleCredentialsCommand";
import { ListAccountRolesCommandInput, ListAccountRolesCommandOutput } from "./commands/ListAccountRolesCommand";
import { ListAccountsCommandInput, ListAccountsCommandOutput } from "./commands/ListAccountsCommand";
import { LogoutCommandInput, LogoutCommandOutput } from "./commands/LogoutCommand";
import { ClientInputEndpointParameters, ClientResolvedEndpointParameters, EndpointParameters } from "./endpoint/EndpointParameters";
import { RuntimeExtension, RuntimeExtensionsConfig } from "./runtimeExtensions";
export { __Client };
/**
 * @public
 */
export type ServiceInputTypes = GetRoleCredentialsCommandInput | ListAccountRolesCommandInput | ListAccountsCommandInput | LogoutCommandInput;
/**
 * @public
 */
export type ServiceOutputTypes = GetRoleCredentialsCommandOutput | ListAccountRolesCommandOutput | ListAccountsCommandOutput | LogoutCommandOutput;
/**
 * @public
 */
export interface ClientDefaults extends Partial<__SmithyConfiguration<__HttpHandlerOptions>> {
    /**
     * The HTTP handler to use or its constructor options. Fetch in browser and Https in Nodejs.
     */
    requestHandler?: __HttpHandlerUserInput;
    /**
     * A constructor for a class implementing the {@link @smithy/types#ChecksumConstructor} interface
     * that computes the SHA-256 HMAC or checksum of a string or binary buffer.
     * @internal
     */
    sha256?: __ChecksumConstructor | __HashConstructor;
    /**
     * The function that will be used to convert strings into HTTP endpoints.
     * @internal
     */
    urlParser?: __UrlParser;
    /**
     * A function that can calculate the length of a request body.
     * @internal
     */
    bodyLengthChecker?: __BodyLengthCalculator;
    /**
     * A function that converts a stream into an array of bytes.
     * @internal
     */
    streamCollector?: __StreamCollector;
    /**
     * The function that will be used to convert a base64-encoded string to a byte array.
     * @internal
     */
    base64Decoder?: __Decoder;
    /**
     * The function that will be used to convert binary data to a base64-encoded string.
     * @internal
     */
    base64Encoder?: __Encoder;
    /**
     * The function that will be used to convert a UTF8-encoded string to a byte array.
     * @internal
     */
    utf8Decoder?: __Decoder;
    /**
     * The function that will be used to convert binary data to a UTF-8 encoded string.
     * @internal
     */
    utf8Encoder?: __Encoder;
    /**
     * The runtime environment.
     * @internal
     */
    runtime?: string;
    /**
     * Disable dynamically changing the endpoint of the client based on the hostPrefix
     * trait of an operation.
     */
    disableHostPrefix?: boolean;
    /**
     * Unique service identifier.
     * @internal
     */
    serviceId?: string;
    /**
     * Enables IPv6/IPv4 dualstack endpoint.
     */
    useDualstackEndpoint?: boolean | __Provider<boolean>;
    /**
     * Enables FIPS compatible endpoints.
     */
    useFipsEndpoint?: boolean | __Provider<boolean>;
    /**
     * The AWS region to which this client will send requests
     */
    region?: string | __Provider<string>;
    /**
     * Setting a client profile is similar to setting a value for the
     * AWS_PROFILE environment variable. Setting a profile on a client
     * in code only affects the single client instance, unlike AWS_PROFILE.
     *
     * When set, and only for environments where an AWS configuration
     * file exists, fields configurable by this file will be retrieved
     * from the specified profile within that file.
     * Conflicting code configuration and environment variables will
     * still have higher priority.
     *
     * For client credential resolution that involves checking the AWS
     * configuration file, the client's profile (this value) will be
     * used unless a different profile is set in the credential
     * provider options.
     *
     */
    profile?: string;
    /**
     * The provider populating default tracking information to be sent with `user-agent`, `x-amz-user-agent` header
     * @internal
     */
    defaultUserAgentProvider?: Provider<__UserAgent>;
    /**
     * Value for how many times a request will be made at most in case of retry.
     */
    maxAttempts?: number | __Provider<number>;
    /**
     * Specifies which retry algorithm to use.
     * @see https://docs.aws.amazon.com/AWSJavaScriptSDK/v3/latest/Package/-smithy-util-retry/Enum/RETRY_MODES/
     *
     */
    retryMode?: string | __Provider<string>;
    /**
     * Optional logger for logging debug/info/warn/error.
     */
    logger?: __Logger;
    /**
     * Optional extensions
     */
    extensions?: RuntimeExtension[];
    /**
     * The {@link @smithy/smithy-client#DefaultsMode} that will be used to determine how certain default configuration options are resolved in the SDK.
     */
    defaultsMode?: __DefaultsMode | __Provider<__DefaultsMode>;
}
/**
 * @public
 */
export type SSOClientConfigType = Partial<__SmithyConfiguration<__HttpHandlerOptions>> & ClientDefaults & UserAgentInputConfig & RetryInputConfig & RegionInputConfig & HostHeaderInputConfig & EndpointInputConfig<EndpointParameters> & HttpAuthSchemeInputConfig & ClientInputEndpointParameters;
/**
 * @public
 *
 *  The configuration interface of SSOClient class constructor that set the region, credentials and other options.
 */
export interface SSOClientConfig extends SSOClientConfigType {
}
/**
 * @public
 */
export type SSOClientResolvedConfigType = __SmithyResolvedConfiguration<__HttpHandlerOptions> & Required<ClientDefaults> & RuntimeExtensionsConfig & UserAgentResolvedConfig & RetryResolvedConfig & RegionResolvedConfig & HostHeaderResolvedConfig & EndpointResolvedConfig<EndpointParameters> & HttpAuthSchemeResolvedConfig & ClientResolvedEndpointParameters;
/**
 * @public
 *
 *  The resolved configuration interface of SSOClient class. This is resolved and normalized from the {@link SSOClientConfig | constructor configuration interface}.
 */
export interface SSOClientResolvedConfig extends SSOClientResolvedConfigType {
}
/**
 * <p>AWS IAM Identity Center (successor to AWS Single Sign-On) Portal is a web service that makes it easy for you to assign user access to
 *       IAM Identity Center resources such as the AWS access portal. Users can get AWS account applications and roles
 *       assigned to them and get federated into the application.</p>
 *          <note>
 *             <p>Although AWS Single Sign-On was renamed, the <code>sso</code> and
 *           <code>identitystore</code> API namespaces will continue to retain their original name for
 *         backward compatibility purposes. For more information, see <a href="https://docs.aws.amazon.com/singlesignon/latest/userguide/what-is.html#renamed">IAM Identity Center rename</a>.</p>
 *          </note>
 *          <p>This reference guide describes the IAM Identity Center Portal operations that you can call
 *       programatically and includes detailed information on data types and errors.</p>
 *          <note>
 *             <p>AWS provides SDKs that consist of libraries and sample code for various programming
 *         languages and platforms, such as Java, Ruby, .Net, iOS, or Android. The SDKs provide a
 *         convenient way to create programmatic access to IAM Identity Center and other AWS services. For more
 *         information about the AWS SDKs, including how to download and install them, see <a href="http://aws.amazon.com/tools/">Tools for Amazon Web Services</a>.</p>
 *          </note>
 * @public
 */
export declare class SSOClient extends __Client<__HttpHandlerOptions, ServiceInputTypes, ServiceOutputTypes, SSOClientResolvedConfig> {
    /**
     * The resolved configuration of SSOClient class. This is resolved and normalized from the {@link SSOClientConfig | constructor configuration interface}.
     */
    readonly config: SSOClientResolvedConfig;
    constructor(...[configuration]: __CheckOptionalClientConfig<SSOClientConfig>);
    /**
     * Destroy underlying resources, like sockets. It's usually not necessary to do this.
     * However in Node.js, it's best to explicitly shut down the client's agent when it is no longer needed.
     * Otherwise, sockets might stay open for quite a long time before the server terminates them.
     */
    destroy(): void;
}

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/dist-types/auth/httpAuthExtensionConfiguration.d.ts

```typescript
import { AwsCredentialIdentity, AwsCredentialIdentityProvider, HttpAuthScheme } from "@smithy/types";
import { SSOHttpAuthSchemeProvider } from "./httpAuthSchemeProvider";
/**
 * @internal
 */
export interface HttpAuthExtensionConfiguration {
    setHttpAuthScheme(httpAuthScheme: HttpAuthScheme): void;
    httpAuthSchemes(): HttpAuthScheme[];
    setHttpAuthSchemeProvider(httpAuthSchemeProvider: SSOHttpAuthSchemeProvider): void;
    httpAuthSchemeProvider(): SSOHttpAuthSchemeProvider;
    setCredentials(credentials: AwsCredentialIdentity | AwsCredentialIdentityProvider): void;
    credentials(): AwsCredentialIdentity | AwsCredentialIdentityProvider | undefined;
}
/**
 * @internal
 */
export type HttpAuthRuntimeConfig = Partial<{
    httpAuthSchemes: HttpAuthScheme[];
    httpAuthSchemeProvider: SSOHttpAuthSchemeProvider;
    credentials: AwsCredentialIdentity | AwsCredentialIdentityProvider;
}>;
/**
 * @internal
 */
export declare const getHttpAuthExtensionConfiguration: (runtimeConfig: HttpAuthRuntimeConfig) => HttpAuthExtensionConfiguration;
/**
 * @internal
 */
export declare const resolveHttpAuthRuntimeConfig: (config: HttpAuthExtensionConfiguration) => HttpAuthRuntimeConfig;

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/dist-types/auth/httpAuthSchemeProvider.d.ts

```typescript
import { AwsSdkSigV4AuthInputConfig, AwsSdkSigV4AuthResolvedConfig, AwsSdkSigV4PreviouslyResolved } from "@aws-sdk/core";
import { HandlerExecutionContext, HttpAuthScheme, HttpAuthSchemeParameters, HttpAuthSchemeParametersProvider, HttpAuthSchemeProvider, Provider } from "@smithy/types";
import { SSOClientResolvedConfig } from "../SSOClient";
/**
 * @internal
 */
export interface SSOHttpAuthSchemeParameters extends HttpAuthSchemeParameters {
    region?: string;
}
/**
 * @internal
 */
export interface SSOHttpAuthSchemeParametersProvider extends HttpAuthSchemeParametersProvider<SSOClientResolvedConfig, HandlerExecutionContext, SSOHttpAuthSchemeParameters, object> {
}
/**
 * @internal
 */
export declare const defaultSSOHttpAuthSchemeParametersProvider: (config: SSOClientResolvedConfig, context: HandlerExecutionContext, input: object) => Promise<SSOHttpAuthSchemeParameters>;
/**
 * @internal
 */
export interface SSOHttpAuthSchemeProvider extends HttpAuthSchemeProvider<SSOHttpAuthSchemeParameters> {
}
/**
 * @internal
 */
export declare const defaultSSOHttpAuthSchemeProvider: SSOHttpAuthSchemeProvider;
/**
 * @internal
 */
export interface HttpAuthSchemeInputConfig extends AwsSdkSigV4AuthInputConfig {
    /**
     * A comma-separated list of case-sensitive auth scheme names.
     * An auth scheme name is a fully qualified auth scheme ID with the namespace prefix trimmed.
     * For example, the auth scheme with ID aws.auth#sigv4 is named sigv4.
     * @public
     */
    authSchemePreference?: string[] | Provider<string[]>;
    /**
     * Configuration of HttpAuthSchemes for a client which provides default identity providers and signers per auth scheme.
     * @internal
     */
    httpAuthSchemes?: HttpAuthScheme[];
    /**
     * Configuration of an HttpAuthSchemeProvider for a client which resolves which HttpAuthScheme to use.
     * @internal
     */
    httpAuthSchemeProvider?: SSOHttpAuthSchemeProvider;
}
/**
 * @internal
 */
export interface HttpAuthSchemeResolvedConfig extends AwsSdkSigV4AuthResolvedConfig {
    /**
     * A comma-separated list of case-sensitive auth scheme names.
     * An auth scheme name is a fully qualified auth scheme ID with the namespace prefix trimmed.
     * For example, the auth scheme with ID aws.auth#sigv4 is named sigv4.
     * @public
     */
    readonly authSchemePreference: Provider<string[]>;
    /**
     * Configuration of HttpAuthSchemes for a client which provides default identity providers and signers per auth scheme.
     * @internal
     */
    readonly httpAuthSchemes: HttpAuthScheme[];
    /**
     * Configuration of an HttpAuthSchemeProvider for a client which resolves which HttpAuthScheme to use.
     * @internal
     */
    readonly httpAuthSchemeProvider: SSOHttpAuthSchemeProvider;
}
/**
 * @internal
 */
export declare const resolveHttpAuthSchemeConfig: <T>(config: T & HttpAuthSchemeInputConfig & AwsSdkSigV4PreviouslyResolved) => T & HttpAuthSchemeResolvedConfig;

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/dist-types/commands/GetRoleCredentialsCommand.d.ts

```typescript
import { Command as $Command } from "@smithy/smithy-client";
import { MetadataBearer as __MetadataBearer } from "@smithy/types";
import { GetRoleCredentialsRequest, GetRoleCredentialsResponse } from "../models/models_0";
import { ServiceInputTypes, ServiceOutputTypes, SSOClientResolvedConfig } from "../SSOClient";
/**
 * @public
 */
export type { __MetadataBearer };
export { $Command };
/**
 * @public
 *
 * The input for {@link GetRoleCredentialsCommand}.
 */
export interface GetRoleCredentialsCommandInput extends GetRoleCredentialsRequest {
}
/**
 * @public
 *
 * The output of {@link GetRoleCredentialsCommand}.
 */
export interface GetRoleCredentialsCommandOutput extends GetRoleCredentialsResponse, __MetadataBearer {
}
declare const GetRoleCredentialsCommand_base: {
    new (input: GetRoleCredentialsCommandInput): import("@smithy/smithy-client").CommandImpl<GetRoleCredentialsCommandInput, GetRoleCredentialsCommandOutput, SSOClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes>;
    new (input: GetRoleCredentialsCommandInput): import("@smithy/smithy-client").CommandImpl<GetRoleCredentialsCommandInput, GetRoleCredentialsCommandOutput, SSOClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes>;
    getEndpointParameterInstructions(): import("@smithy/middleware-endpoint").EndpointParameterInstructions;
};
/**
 * <p>Returns the STS short-term credentials for a given role name that is assigned to the
 *       user.</p>
 * @example
 * Use a bare-bones client and the command you need to make an API call.
 * ```javascript
 * import { SSOClient, GetRoleCredentialsCommand } from "@aws-sdk/client-sso"; // ES Modules import
 * // const { SSOClient, GetRoleCredentialsCommand } = require("@aws-sdk/client-sso"); // CommonJS import
 * // import type { SSOClientConfig } from "@aws-sdk/client-sso";
 * const config = {}; // type is SSOClientConfig
 * const client = new SSOClient(config);
 * const input = { // GetRoleCredentialsRequest
 *   roleName: "STRING_VALUE", // required
 *   accountId: "STRING_VALUE", // required
 *   accessToken: "STRING_VALUE", // required
 * };
 * const command = new GetRoleCredentialsCommand(input);
 * const response = await client.send(command);
 * // { // GetRoleCredentialsResponse
 * //   roleCredentials: { // RoleCredentials
 * //     accessKeyId: "STRING_VALUE",
 * //     secretAccessKey: "STRING_VALUE",
 * //     sessionToken: "STRING_VALUE",
 * //     expiration: Number("long"),
 * //   },
 * // };
 *
 * ```
 *
 * @param GetRoleCredentialsCommandInput - {@link GetRoleCredentialsCommandInput}
 * @returns {@link GetRoleCredentialsCommandOutput}
 * @see {@link GetRoleCredentialsCommandInput} for command's `input` shape.
 * @see {@link GetRoleCredentialsCommandOutput} for command's `response` shape.
 * @see {@link SSOClientResolvedConfig | config} for SSOClient's `config` shape.
 *
 * @throws {@link InvalidRequestException} (client fault)
 *  <p>Indicates that a problem occurred with the input to the request. For example, a required
 *       parameter might be missing or out of range.</p>
 *
 * @throws {@link ResourceNotFoundException} (client fault)
 *  <p>The specified resource doesn't exist.</p>
 *
 * @throws {@link TooManyRequestsException} (client fault)
 *  <p>Indicates that the request is being made too frequently and is more than what the server
 *       can handle.</p>
 *
 * @throws {@link UnauthorizedException} (client fault)
 *  <p>Indicates that the request is not authorized. This can happen due to an invalid access
 *       token in the request.</p>
 *
 * @throws {@link SSOServiceException}
 * <p>Base exception class for all service exceptions from SSO service.</p>
 *
 *
 * @public
 */
export declare class GetRoleCredentialsCommand extends GetRoleCredentialsCommand_base {
    /** @internal type navigation helper, not in runtime. */
    protected static __types: {
        api: {
            input: GetRoleCredentialsRequest;
            output: GetRoleCredentialsResponse;
        };
        sdk: {
            input: GetRoleCredentialsCommandInput;
            output: GetRoleCredentialsCommandOutput;
        };
    };
}

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/dist-types/commands/ListAccountRolesCommand.d.ts

```typescript
import { Command as $Command } from "@smithy/smithy-client";
import { MetadataBearer as __MetadataBearer } from "@smithy/types";
import { ListAccountRolesRequest, ListAccountRolesResponse } from "../models/models_0";
import { ServiceInputTypes, ServiceOutputTypes, SSOClientResolvedConfig } from "../SSOClient";
/**
 * @public
 */
export type { __MetadataBearer };
export { $Command };
/**
 * @public
 *
 * The input for {@link ListAccountRolesCommand}.
 */
export interface ListAccountRolesCommandInput extends ListAccountRolesRequest {
}
/**
 * @public
 *
 * The output of {@link ListAccountRolesCommand}.
 */
export interface ListAccountRolesCommandOutput extends ListAccountRolesResponse, __MetadataBearer {
}
declare const ListAccountRolesCommand_base: {
    new (input: ListAccountRolesCommandInput): import("@smithy/smithy-client").CommandImpl<ListAccountRolesCommandInput, ListAccountRolesCommandOutput, SSOClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes>;
    new (input: ListAccountRolesCommandInput): import("@smithy/smithy-client").CommandImpl<ListAccountRolesCommandInput, ListAccountRolesCommandOutput, SSOClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes>;
    getEndpointParameterInstructions(): import("@smithy/middleware-endpoint").EndpointParameterInstructions;
};
/**
 * <p>Lists all roles that are assigned to the user for a given AWS account.</p>
 * @example
 * Use a bare-bones client and the command you need to make an API call.
 * ```javascript
 * import { SSOClient, ListAccountRolesCommand } from "@aws-sdk/client-sso"; // ES Modules import
 * // const { SSOClient, ListAccountRolesCommand } = require("@aws-sdk/client-sso"); // CommonJS import
 * // import type { SSOClientConfig } from "@aws-sdk/client-sso";
 * const config = {}; // type is SSOClientConfig
 * const client = new SSOClient(config);
 * const input = { // ListAccountRolesRequest
 *   nextToken: "STRING_VALUE",
 *   maxResults: Number("int"),
 *   accessToken: "STRING_VALUE", // required
 *   accountId: "STRING_VALUE", // required
 * };
 * const command = new ListAccountRolesCommand(input);
 * const response = await client.send(command);
 * // { // ListAccountRolesResponse
 * //   nextToken: "STRING_VALUE",
 * //   roleList: [ // RoleListType
 * //     { // RoleInfo
 * //       roleName: "STRING_VALUE",
 * //       accountId: "STRING_VALUE",
 * //     },
 * //   ],
 * // };
 *
 * ```
 *
 * @param ListAccountRolesCommandInput - {@link ListAccountRolesCommandInput}
 * @returns {@link ListAccountRolesCommandOutput}
 * @see {@link ListAccountRolesCommandInput} for command's `input` shape.
 * @see {@link ListAccountRolesCommandOutput} for command's `response` shape.
 * @see {@link SSOClientResolvedConfig | config} for SSOClient's `config` shape.
 *
 * @throws {@link InvalidRequestException} (client fault)
 *  <p>Indicates that a problem occurred with the input to the request. For example, a required
 *       parameter might be missing or out of range.</p>
 *
 * @throws {@link ResourceNotFoundException} (client fault)
 *  <p>The specified resource doesn't exist.</p>
 *
 * @throws {@link TooManyRequestsException} (client fault)
 *  <p>Indicates that the request is being made too frequently and is more than what the server
 *       can handle.</p>
 *
 * @throws {@link UnauthorizedException} (client fault)
 *  <p>Indicates that the request is not authorized. This can happen due to an invalid access
 *       token in the request.</p>
 *
 * @throws {@link SSOServiceException}
 * <p>Base exception class for all service exceptions from SSO service.</p>
 *
 *
 * @public
 */
export declare class ListAccountRolesCommand extends ListAccountRolesCommand_base {
    /** @internal type navigation helper, not in runtime. */
    protected static __types: {
        api: {
            input: ListAccountRolesRequest;
            output: ListAccountRolesResponse;
        };
        sdk: {
            input: ListAccountRolesCommandInput;
            output: ListAccountRolesCommandOutput;
        };
    };
}

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/dist-types/commands/ListAccountsCommand.d.ts

```typescript
import { Command as $Command } from "@smithy/smithy-client";
import { MetadataBearer as __MetadataBearer } from "@smithy/types";
import { ListAccountsRequest, ListAccountsResponse } from "../models/models_0";
import { ServiceInputTypes, ServiceOutputTypes, SSOClientResolvedConfig } from "../SSOClient";
/**
 * @public
 */
export type { __MetadataBearer };
export { $Command };
/**
 * @public
 *
 * The input for {@link ListAccountsCommand}.
 */
export interface ListAccountsCommandInput extends ListAccountsRequest {
}
/**
 * @public
 *
 * The output of {@link ListAccountsCommand}.
 */
export interface ListAccountsCommandOutput extends ListAccountsResponse, __MetadataBearer {
}
declare const ListAccountsCommand_base: {
    new (input: ListAccountsCommandInput): import("@smithy/smithy-client").CommandImpl<ListAccountsCommandInput, ListAccountsCommandOutput, SSOClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes>;
    new (input: ListAccountsCommandInput): import("@smithy/smithy-client").CommandImpl<ListAccountsCommandInput, ListAccountsCommandOutput, SSOClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes>;
    getEndpointParameterInstructions(): import("@smithy/middleware-endpoint").EndpointParameterInstructions;
};
/**
 * <p>Lists all AWS accounts assigned to the user. These AWS accounts are assigned by the
 *       administrator of the account. For more information, see <a href="https://docs.aws.amazon.com/singlesignon/latest/userguide/useraccess.html#assignusers">Assign User Access</a> in the <i>IAM Identity Center User Guide</i>. This operation
 *       returns a paginated response.</p>
 * @example
 * Use a bare-bones client and the command you need to make an API call.
 * ```javascript
 * import { SSOClient, ListAccountsCommand } from "@aws-sdk/client-sso"; // ES Modules import
 * // const { SSOClient, ListAccountsCommand } = require("@aws-sdk/client-sso"); // CommonJS import
 * // import type { SSOClientConfig } from "@aws-sdk/client-sso";
 * const config = {}; // type is SSOClientConfig
 * const client = new SSOClient(config);
 * const input = { // ListAccountsRequest
 *   nextToken: "STRING_VALUE",
 *   maxResults: Number("int"),
 *   accessToken: "STRING_VALUE", // required
 * };
 * const command = new ListAccountsCommand(input);
 * const response = await client.send(command);
 * // { // ListAccountsResponse
 * //   nextToken: "STRING_VALUE",
 * //   accountList: [ // AccountListType
 * //     { // AccountInfo
 * //       accountId: "STRING_VALUE",
 * //       accountName: "STRING_VALUE",
 * //       emailAddress: "STRING_VALUE",
 * //     },
 * //   ],
 * // };
 *
 * ```
 *
 * @param ListAccountsCommandInput - {@link ListAccountsCommandInput}
 * @returns {@link ListAccountsCommandOutput}
 * @see {@link ListAccountsCommandInput} for command's `input` shape.
 * @see {@link ListAccountsCommandOutput} for command's `response` shape.
 * @see {@link SSOClientResolvedConfig | config} for SSOClient's `config` shape.
 *
 * @throws {@link InvalidRequestException} (client fault)
 *  <p>Indicates that a problem occurred with the input to the request. For example, a required
 *       parameter might be missing or out of range.</p>
 *
 * @throws {@link ResourceNotFoundException} (client fault)
 *  <p>The specified resource doesn't exist.</p>
 *
 * @throws {@link TooManyRequestsException} (client fault)
 *  <p>Indicates that the request is being made too frequently and is more than what the server
 *       can handle.</p>
 *
 * @throws {@link UnauthorizedException} (client fault)
 *  <p>Indicates that the request is not authorized. This can happen due to an invalid access
 *       token in the request.</p>
 *
 * @throws {@link SSOServiceException}
 * <p>Base exception class for all service exceptions from SSO service.</p>
 *
 *
 * @public
 */
export declare class ListAccountsCommand extends ListAccountsCommand_base {
    /** @internal type navigation helper, not in runtime. */
    protected static __types: {
        api: {
            input: ListAccountsRequest;
            output: ListAccountsResponse;
        };
        sdk: {
            input: ListAccountsCommandInput;
            output: ListAccountsCommandOutput;
        };
    };
}

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/dist-types/commands/LogoutCommand.d.ts

```typescript
import { Command as $Command } from "@smithy/smithy-client";
import { MetadataBearer as __MetadataBearer } from "@smithy/types";
import { LogoutRequest } from "../models/models_0";
import { ServiceInputTypes, ServiceOutputTypes, SSOClientResolvedConfig } from "../SSOClient";
/**
 * @public
 */
export type { __MetadataBearer };
export { $Command };
/**
 * @public
 *
 * The input for {@link LogoutCommand}.
 */
export interface LogoutCommandInput extends LogoutRequest {
}
/**
 * @public
 *
 * The output of {@link LogoutCommand}.
 */
export interface LogoutCommandOutput extends __MetadataBearer {
}
declare const LogoutCommand_base: {
    new (input: LogoutCommandInput): import("@smithy/smithy-client").CommandImpl<LogoutCommandInput, LogoutCommandOutput, SSOClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes>;
    new (input: LogoutCommandInput): import("@smithy/smithy-client").CommandImpl<LogoutCommandInput, LogoutCommandOutput, SSOClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes>;
    getEndpointParameterInstructions(): import("@smithy/middleware-endpoint").EndpointParameterInstructions;
};
/**
 * <p>Removes the locally stored SSO tokens from the client-side cache and sends an API call to
 *       the IAM Identity Center service to invalidate the corresponding server-side IAM Identity Center sign in
 *       session.</p>
 *          <note>
 *             <p>If a user uses IAM Identity Center to access the AWS CLI, the users IAM Identity Center sign in session is
 *         used to obtain an IAM session, as specified in the corresponding IAM Identity Center permission set.
 *         More specifically, IAM Identity Center assumes an IAM role in the target account on behalf of the user,
 *         and the corresponding temporary AWS credentials are returned to the client.</p>
 *             <p>After user logout, any existing IAM role sessions that were created by using IAM Identity Center
 *         permission sets continue based on the duration configured in the permission set.
 *         For more information, see <a href="https://docs.aws.amazon.com/singlesignon/latest/userguide/authconcept.html">User
 *           authentications</a> in the <i>IAM Identity Center User
 *         Guide</i>.</p>
 *          </note>
 * @example
 * Use a bare-bones client and the command you need to make an API call.
 * ```javascript
 * import { SSOClient, LogoutCommand } from "@aws-sdk/client-sso"; // ES Modules import
 * // const { SSOClient, LogoutCommand } = require("@aws-sdk/client-sso"); // CommonJS import
 * // import type { SSOClientConfig } from "@aws-sdk/client-sso";
 * const config = {}; // type is SSOClientConfig
 * const client = new SSOClient(config);
 * const input = { // LogoutRequest
 *   accessToken: "STRING_VALUE", // required
 * };
 * const command = new LogoutCommand(input);
 * const response = await client.send(command);
 * // {};
 *
 * ```
 *
 * @param LogoutCommandInput - {@link LogoutCommandInput}
 * @returns {@link LogoutCommandOutput}
 * @see {@link LogoutCommandInput} for command's `input` shape.
 * @see {@link LogoutCommandOutput} for command's `response` shape.
 * @see {@link SSOClientResolvedConfig | config} for SSOClient's `config` shape.
 *
 * @throws {@link InvalidRequestException} (client fault)
 *  <p>Indicates that a problem occurred with the input to the request. For example, a required
 *       parameter might be missing or out of range.</p>
 *
 * @throws {@link TooManyRequestsException} (client fault)
 *  <p>Indicates that the request is being made too frequently and is more than what the server
 *       can handle.</p>
 *
 * @throws {@link UnauthorizedException} (client fault)
 *  <p>Indicates that the request is not authorized. This can happen due to an invalid access
 *       token in the request.</p>
 *
 * @throws {@link SSOServiceException}
 * <p>Base exception class for all service exceptions from SSO service.</p>
 *
 *
 * @public
 */
export declare class LogoutCommand extends LogoutCommand_base {
    /** @internal type navigation helper, not in runtime. */
    protected static __types: {
        api: {
            input: LogoutRequest;
            output: {};
        };
        sdk: {
            input: LogoutCommandInput;
            output: LogoutCommandOutput;
        };
    };
}

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/dist-types/commands/index.d.ts

```typescript
export * from "./GetRoleCredentialsCommand";
export * from "./ListAccountRolesCommand";
export * from "./ListAccountsCommand";
export * from "./LogoutCommand";

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/dist-types/endpoint/EndpointParameters.d.ts

```typescript
import { Endpoint, EndpointParameters as __EndpointParameters, EndpointV2, Provider } from "@smithy/types";
/**
 * @public
 */
export interface ClientInputEndpointParameters {
    region?: string | undefined | Provider<string | undefined>;
    useDualstackEndpoint?: boolean | undefined | Provider<boolean | undefined>;
    useFipsEndpoint?: boolean | undefined | Provider<boolean | undefined>;
    endpoint?: string | Provider<string> | Endpoint | Provider<Endpoint> | EndpointV2 | Provider<EndpointV2>;
}
export type ClientResolvedEndpointParameters = Omit<ClientInputEndpointParameters, "endpoint"> & {
    defaultSigningName: string;
};
export declare const resolveClientEndpointParameters: <T>(options: T & ClientInputEndpointParameters) => T & ClientResolvedEndpointParameters;
export declare const commonParams: {
    readonly UseFIPS: {
        readonly type: "builtInParams";
        readonly name: "useFipsEndpoint";
    };
    readonly Endpoint: {
        readonly type: "builtInParams";
        readonly name: "endpoint";
    };
    readonly Region: {
        readonly type: "builtInParams";
        readonly name: "region";
    };
    readonly UseDualStack: {
        readonly type: "builtInParams";
        readonly name: "useDualstackEndpoint";
    };
};
export interface EndpointParameters extends __EndpointParameters {
    Region?: string | undefined;
    UseDualStack?: boolean | undefined;
    UseFIPS?: boolean | undefined;
    Endpoint?: string | undefined;
}

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/dist-types/endpoint/endpointResolver.d.ts

```typescript
import { EndpointV2, Logger } from "@smithy/types";
import { EndpointParameters } from "./EndpointParameters";
export declare const defaultEndpointResolver: (endpointParams: EndpointParameters, context?: {
    logger?: Logger;
}) => EndpointV2;

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/dist-types/endpoint/ruleset.d.ts

```typescript
import { RuleSetObject } from "@smithy/types";
export declare const ruleSet: RuleSetObject;

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/dist-types/extensionConfiguration.d.ts

```typescript
import { AwsRegionExtensionConfiguration } from "@aws-sdk/types";
import { HttpHandlerExtensionConfiguration } from "@smithy/protocol-http";
import { DefaultExtensionConfiguration } from "@smithy/types";
import { HttpAuthExtensionConfiguration } from "./auth/httpAuthExtensionConfiguration";
/**
 * @internal
 */
export interface SSOExtensionConfiguration extends HttpHandlerExtensionConfiguration, DefaultExtensionConfiguration, AwsRegionExtensionConfiguration, HttpAuthExtensionConfiguration {
}

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/dist-types/index.d.ts

```typescript
/**
 * <p>AWS IAM Identity Center (successor to AWS Single Sign-On) Portal is a web service that makes it easy for you to assign user access to
 *       IAM Identity Center resources such as the AWS access portal. Users can get AWS account applications and roles
 *       assigned to them and get federated into the application.</p>
 *          <note>
 *             <p>Although AWS Single Sign-On was renamed, the <code>sso</code> and
 *           <code>identitystore</code> API namespaces will continue to retain their original name for
 *         backward compatibility purposes. For more information, see <a href="https://docs.aws.amazon.com/singlesignon/latest/userguide/what-is.html#renamed">IAM Identity Center rename</a>.</p>
 *          </note>
 *          <p>This reference guide describes the IAM Identity Center Portal operations that you can call
 *       programatically and includes detailed information on data types and errors.</p>
 *          <note>
 *             <p>AWS provides SDKs that consist of libraries and sample code for various programming
 *         languages and platforms, such as Java, Ruby, .Net, iOS, or Android. The SDKs provide a
 *         convenient way to create programmatic access to IAM Identity Center and other AWS services. For more
 *         information about the AWS SDKs, including how to download and install them, see <a href="http://aws.amazon.com/tools/">Tools for Amazon Web Services</a>.</p>
 *          </note>
 *
 * @packageDocumentation
 */
export * from "./SSOClient";
export * from "./SSO";
export { ClientInputEndpointParameters } from "./endpoint/EndpointParameters";
export type { RuntimeExtension } from "./runtimeExtensions";
export type { SSOExtensionConfiguration } from "./extensionConfiguration";
export * from "./commands";
export * from "./pagination";
export * from "./models";
export { SSOServiceException } from "./models/SSOServiceException";

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/dist-types/models/SSOServiceException.d.ts

```typescript
import { ServiceException as __ServiceException, ServiceExceptionOptions as __ServiceExceptionOptions } from "@smithy/smithy-client";
export type { __ServiceExceptionOptions };
export { __ServiceException };
/**
 * @public
 *
 * Base exception class for all service exceptions from SSO service.
 */
export declare class SSOServiceException extends __ServiceException {
    /**
     * @internal
     */
    constructor(options: __ServiceExceptionOptions);
}

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/dist-types/models/index.d.ts

```typescript
export * from "./models_0";

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/dist-types/models/models_0.d.ts

```typescript
import { ExceptionOptionType as __ExceptionOptionType } from "@smithy/smithy-client";
import { SSOServiceException as __BaseException } from "./SSOServiceException";
/**
 * <p>Provides information about your AWS account.</p>
 * @public
 */
export interface AccountInfo {
    /**
     * <p>The identifier of the AWS account that is assigned to the user.</p>
     * @public
     */
    accountId?: string | undefined;
    /**
     * <p>The display name of the AWS account that is assigned to the user.</p>
     * @public
     */
    accountName?: string | undefined;
    /**
     * <p>The email address of the AWS account that is assigned to the user.</p>
     * @public
     */
    emailAddress?: string | undefined;
}
/**
 * @public
 */
export interface GetRoleCredentialsRequest {
    /**
     * <p>The friendly name of the role that is assigned to the user.</p>
     * @public
     */
    roleName: string | undefined;
    /**
     * <p>The identifier for the AWS account that is assigned to the user.</p>
     * @public
     */
    accountId: string | undefined;
    /**
     * <p>The token issued by the <code>CreateToken</code> API call. For more information, see
     *         <a href="https://docs.aws.amazon.com/singlesignon/latest/OIDCAPIReference/API_CreateToken.html">CreateToken</a> in the <i>IAM Identity Center OIDC API Reference Guide</i>.</p>
     * @public
     */
    accessToken: string | undefined;
}
/**
 * <p>Provides information about the role credentials that are assigned to the user.</p>
 * @public
 */
export interface RoleCredentials {
    /**
     * <p>The identifier used for the temporary security credentials. For more information, see
     *         <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html">Using Temporary Security Credentials to Request Access to AWS Resources</a> in the
     *         <i>AWS IAM User Guide</i>.</p>
     * @public
     */
    accessKeyId?: string | undefined;
    /**
     * <p>The key that is used to sign the request. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html">Using Temporary Security Credentials to Request Access to AWS Resources</a> in the
     *         <i>AWS IAM User Guide</i>.</p>
     * @public
     */
    secretAccessKey?: string | undefined;
    /**
     * <p>The token used for temporary credentials. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html">Using Temporary Security Credentials to Request Access to AWS Resources</a> in the
     *         <i>AWS IAM User Guide</i>.</p>
     * @public
     */
    sessionToken?: string | undefined;
    /**
     * <p>The date on which temporary security credentials expire.</p>
     * @public
     */
    expiration?: number | undefined;
}
/**
 * @public
 */
export interface GetRoleCredentialsResponse {
    /**
     * <p>The credentials for the role that is assigned to the user.</p>
     * @public
     */
    roleCredentials?: RoleCredentials | undefined;
}
/**
 * <p>Indicates that a problem occurred with the input to the request. For example, a required
 *       parameter might be missing or out of range.</p>
 * @public
 */
export declare class InvalidRequestException extends __BaseException {
    readonly name: "InvalidRequestException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<InvalidRequestException, __BaseException>);
}
/**
 * <p>The specified resource doesn't exist.</p>
 * @public
 */
export declare class ResourceNotFoundException extends __BaseException {
    readonly name: "ResourceNotFoundException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<ResourceNotFoundException, __BaseException>);
}
/**
 * <p>Indicates that the request is being made too frequently and is more than what the server
 *       can handle.</p>
 * @public
 */
export declare class TooManyRequestsException extends __BaseException {
    readonly name: "TooManyRequestsException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<TooManyRequestsException, __BaseException>);
}
/**
 * <p>Indicates that the request is not authorized. This can happen due to an invalid access
 *       token in the request.</p>
 * @public
 */
export declare class UnauthorizedException extends __BaseException {
    readonly name: "UnauthorizedException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<UnauthorizedException, __BaseException>);
}
/**
 * @public
 */
export interface ListAccountRolesRequest {
    /**
     * <p>The page token from the previous response output when you request subsequent pages.</p>
     * @public
     */
    nextToken?: string | undefined;
    /**
     * <p>The number of items that clients can request per page.</p>
     * @public
     */
    maxResults?: number | undefined;
    /**
     * <p>The token issued by the <code>CreateToken</code> API call. For more information, see
     *         <a href="https://docs.aws.amazon.com/singlesignon/latest/OIDCAPIReference/API_CreateToken.html">CreateToken</a> in the <i>IAM Identity Center OIDC API Reference Guide</i>.</p>
     * @public
     */
    accessToken: string | undefined;
    /**
     * <p>The identifier for the AWS account that is assigned to the user.</p>
     * @public
     */
    accountId: string | undefined;
}
/**
 * <p>Provides information about the role that is assigned to the user.</p>
 * @public
 */
export interface RoleInfo {
    /**
     * <p>The friendly name of the role that is assigned to the user.</p>
     * @public
     */
    roleName?: string | undefined;
    /**
     * <p>The identifier of the AWS account assigned to the user.</p>
     * @public
     */
    accountId?: string | undefined;
}
/**
 * @public
 */
export interface ListAccountRolesResponse {
    /**
     * <p>The page token client that is used to retrieve the list of accounts.</p>
     * @public
     */
    nextToken?: string | undefined;
    /**
     * <p>A paginated response with the list of roles and the next token if more results are
     *       available.</p>
     * @public
     */
    roleList?: RoleInfo[] | undefined;
}
/**
 * @public
 */
export interface ListAccountsRequest {
    /**
     * <p>(Optional) When requesting subsequent pages, this is the page token from the previous
     *       response output.</p>
     * @public
     */
    nextToken?: string | undefined;
    /**
     * <p>This is the number of items clients can request per page.</p>
     * @public
     */
    maxResults?: number | undefined;
    /**
     * <p>The token issued by the <code>CreateToken</code> API call. For more information, see
     *         <a href="https://docs.aws.amazon.com/singlesignon/latest/OIDCAPIReference/API_CreateToken.html">CreateToken</a> in the <i>IAM Identity Center OIDC API Reference Guide</i>.</p>
     * @public
     */
    accessToken: string | undefined;
}
/**
 * @public
 */
export interface ListAccountsResponse {
    /**
     * <p>The page token client that is used to retrieve the list of accounts.</p>
     * @public
     */
    nextToken?: string | undefined;
    /**
     * <p>A paginated response with the list of account information and the next token if more
     *       results are available.</p>
     * @public
     */
    accountList?: AccountInfo[] | undefined;
}
/**
 * @public
 */
export interface LogoutRequest {
    /**
     * <p>The token issued by the <code>CreateToken</code> API call. For more information, see
     *         <a href="https://docs.aws.amazon.com/singlesignon/latest/OIDCAPIReference/API_CreateToken.html">CreateToken</a> in the <i>IAM Identity Center OIDC API Reference Guide</i>.</p>
     * @public
     */
    accessToken: string | undefined;
}
/**
 * @internal
 */
export declare const GetRoleCredentialsRequestFilterSensitiveLog: (obj: GetRoleCredentialsRequest) => any;
/**
 * @internal
 */
export declare const RoleCredentialsFilterSensitiveLog: (obj: RoleCredentials) => any;
/**
 * @internal
 */
export declare const GetRoleCredentialsResponseFilterSensitiveLog: (obj: GetRoleCredentialsResponse) => any;
/**
 * @internal
 */
export declare const ListAccountRolesRequestFilterSensitiveLog: (obj: ListAccountRolesRequest) => any;
/**
 * @internal
 */
export declare const ListAccountsRequestFilterSensitiveLog: (obj: ListAccountsRequest) => any;
/**
 * @internal
 */
export declare const LogoutRequestFilterSensitiveLog: (obj: LogoutRequest) => any;

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/dist-types/pagination/Interfaces.d.ts

```typescript
import { PaginationConfiguration } from "@smithy/types";
import { SSOClient } from "../SSOClient";
/**
 * @public
 */
export interface SSOPaginationConfiguration extends PaginationConfiguration {
    client: SSOClient;
}

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/dist-types/pagination/ListAccountRolesPaginator.d.ts

```typescript
import { Paginator } from "@smithy/types";
import { ListAccountRolesCommandInput, ListAccountRolesCommandOutput } from "../commands/ListAccountRolesCommand";
import { SSOPaginationConfiguration } from "./Interfaces";
/**
 * @public
 */
export declare const paginateListAccountRoles: (config: SSOPaginationConfiguration, input: ListAccountRolesCommandInput, ...rest: any[]) => Paginator<ListAccountRolesCommandOutput>;

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/dist-types/pagination/ListAccountsPaginator.d.ts

```typescript
import { Paginator } from "@smithy/types";
import { ListAccountsCommandInput, ListAccountsCommandOutput } from "../commands/ListAccountsCommand";
import { SSOPaginationConfiguration } from "./Interfaces";
/**
 * @public
 */
export declare const paginateListAccounts: (config: SSOPaginationConfiguration, input: ListAccountsCommandInput, ...rest: any[]) => Paginator<ListAccountsCommandOutput>;

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/dist-types/pagination/index.d.ts

```typescript
export * from "./Interfaces";
export * from "./ListAccountRolesPaginator";
export * from "./ListAccountsPaginator";

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/dist-types/protocols/Aws_restJson1.d.ts

```typescript
import { HttpRequest as __HttpRequest, HttpResponse as __HttpResponse } from "@smithy/protocol-http";
import { SerdeContext as __SerdeContext } from "@smithy/types";
import { GetRoleCredentialsCommandInput, GetRoleCredentialsCommandOutput } from "../commands/GetRoleCredentialsCommand";
import { ListAccountRolesCommandInput, ListAccountRolesCommandOutput } from "../commands/ListAccountRolesCommand";
import { ListAccountsCommandInput, ListAccountsCommandOutput } from "../commands/ListAccountsCommand";
import { LogoutCommandInput, LogoutCommandOutput } from "../commands/LogoutCommand";
/**
 * serializeAws_restJson1GetRoleCredentialsCommand
 */
export declare const se_GetRoleCredentialsCommand: (input: GetRoleCredentialsCommandInput, context: __SerdeContext) => Promise<__HttpRequest>;
/**
 * serializeAws_restJson1ListAccountRolesCommand
 */
export declare const se_ListAccountRolesCommand: (input: ListAccountRolesCommandInput, context: __SerdeContext) => Promise<__HttpRequest>;
/**
 * serializeAws_restJson1ListAccountsCommand
 */
export declare const se_ListAccountsCommand: (input: ListAccountsCommandInput, context: __SerdeContext) => Promise<__HttpRequest>;
/**
 * serializeAws_restJson1LogoutCommand
 */
export declare const se_LogoutCommand: (input: LogoutCommandInput, context: __SerdeContext) => Promise<__HttpRequest>;
/**
 * deserializeAws_restJson1GetRoleCredentialsCommand
 */
export declare const de_GetRoleCredentialsCommand: (output: __HttpResponse, context: __SerdeContext) => Promise<GetRoleCredentialsCommandOutput>;
/**
 * deserializeAws_restJson1ListAccountRolesCommand
 */
export declare const de_ListAccountRolesCommand: (output: __HttpResponse, context: __SerdeContext) => Promise<ListAccountRolesCommandOutput>;
/**
 * deserializeAws_restJson1ListAccountsCommand
 */
export declare const de_ListAccountsCommand: (output: __HttpResponse, context: __SerdeContext) => Promise<ListAccountsCommandOutput>;
/**
 * deserializeAws_restJson1LogoutCommand
 */
export declare const de_LogoutCommand: (output: __HttpResponse, context: __SerdeContext) => Promise<LogoutCommandOutput>;

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/dist-types/runtimeConfig.browser.d.ts

```typescript
import { FetchHttpHandler as RequestHandler } from "@smithy/fetch-http-handler";
import { SSOClientConfig } from "./SSOClient";
/**
 * @internal
 */
export declare const getRuntimeConfig: (config: SSOClientConfig) => {
    runtime: string;
    defaultsMode: import("@smithy/types").Provider<import("@smithy/smithy-client").ResolvedDefaultsMode>;
    bodyLengthChecker: import("@smithy/types").BodyLengthCalculator;
    defaultUserAgentProvider: (config?: import("@aws-sdk/util-user-agent-browser").PreviouslyResolved) => Promise<import("@smithy/types").UserAgent>;
    maxAttempts: number | import("@smithy/types").Provider<number>;
    region: string | import("@smithy/types").Provider<any>;
    requestHandler: import("@smithy/protocol-http").HttpHandler<any> | RequestHandler;
    retryMode: string | import("@smithy/types").Provider<string>;
    sha256: import("@smithy/types").HashConstructor;
    streamCollector: import("@smithy/types").StreamCollector;
    useDualstackEndpoint: (boolean | import("@smithy/types").Provider<boolean>) & (boolean | import("@smithy/types").Provider<boolean | undefined>);
    useFipsEndpoint: (boolean | import("@smithy/types").Provider<boolean>) & (boolean | import("@smithy/types").Provider<boolean | undefined>);
    apiVersion: string;
    cacheMiddleware?: boolean | undefined;
    urlParser: import("@smithy/types").UrlParser;
    base64Decoder: import("@smithy/types").Decoder;
    base64Encoder: (_input: Uint8Array | string) => string;
    utf8Decoder: import("@smithy/types").Decoder;
    utf8Encoder: (input: Uint8Array | string) => string;
    disableHostPrefix: boolean;
    serviceId: string;
    profile?: string;
    logger: import("@smithy/types").Logger;
    extensions: import("./runtimeExtensions").RuntimeExtension[];
    customUserAgent?: string | import("@smithy/types").UserAgent;
    userAgentAppId?: string | undefined | import("@smithy/types").Provider<string | undefined>;
    retryStrategy?: import("@smithy/types").RetryStrategy | import("@smithy/types").RetryStrategyV2;
    endpoint?: ((string | import("@smithy/types").Endpoint | import("@smithy/types").Provider<import("@smithy/types").Endpoint> | import("@smithy/types").EndpointV2 | import("@smithy/types").Provider<import("@smithy/types").EndpointV2>) & (string | import("@smithy/types").Provider<string> | import("@smithy/types").Endpoint | import("@smithy/types").Provider<import("@smithy/types").Endpoint> | import("@smithy/types").EndpointV2 | import("@smithy/types").Provider<import("@smithy/types").EndpointV2>)) | undefined;
    endpointProvider: (endpointParams: import("./endpoint/EndpointParameters").EndpointParameters, context?: {
        logger?: import("@smithy/types").Logger;
    }) => import("@smithy/types").EndpointV2;
    tls?: boolean;
    serviceConfiguredEndpoint?: never;
    authSchemePreference?: string[] | import("@smithy/types").Provider<string[]>;
    httpAuthSchemes: import("@smithy/types").HttpAuthScheme[] | ({
        schemeId: string;
        identityProvider: (ipc: import("@smithy/types").IdentityProviderConfig) => import("@smithy/types").IdentityProvider<import("@smithy/types").Identity> | undefined;
        signer: import("@aws-sdk/core").AwsSdkSigV4Signer;
    } | {
        schemeId: string;
        identityProvider: (ipc: import("@smithy/types").IdentityProviderConfig) => import("@smithy/types").IdentityProvider<import("@smithy/types").Identity> | (() => Promise<{}>);
        signer: import("@smithy/core").NoAuthSigner;
    })[];
    httpAuthSchemeProvider: import("./auth/httpAuthSchemeProvider").SSOHttpAuthSchemeProvider;
    credentials?: import("@smithy/types").AwsCredentialIdentity | import("@smithy/types").AwsCredentialIdentityProvider;
    signer?: import("@smithy/types").RequestSigner | ((authScheme?: import("@smithy/types").AuthScheme) => Promise<import("@smithy/types").RequestSigner>);
    signingEscapePath?: boolean;
    systemClockOffset?: number;
    signingRegion?: string;
    signerConstructor?: new (options: import("@smithy/signature-v4").SignatureV4Init & import("@smithy/signature-v4").SignatureV4CryptoInit) => import("@smithy/types").RequestSigner;
};

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/dist-types/runtimeConfig.d.ts

```typescript
import { NodeHttpHandler as RequestHandler } from "@smithy/node-http-handler";
import { SSOClientConfig } from "./SSOClient";
/**
 * @internal
 */
export declare const getRuntimeConfig: (config: SSOClientConfig) => {
    runtime: string;
    defaultsMode: import("@smithy/types").Provider<import("@smithy/smithy-client").ResolvedDefaultsMode>;
    authSchemePreference: string[] | import("@smithy/types").Provider<string[]>;
    bodyLengthChecker: import("@smithy/types").BodyLengthCalculator;
    defaultUserAgentProvider: (config?: import("@aws-sdk/util-user-agent-node").PreviouslyResolved) => Promise<import("@smithy/types").UserAgent>;
    maxAttempts: number | import("@smithy/types").Provider<number>;
    region: string | import("@smithy/types").Provider<string>;
    requestHandler: RequestHandler | import("@smithy/protocol-http").HttpHandler<any>;
    retryMode: string | import("@smithy/types").Provider<string>;
    sha256: import("@smithy/types").HashConstructor;
    streamCollector: import("@smithy/types").StreamCollector;
    useDualstackEndpoint: boolean | import("@smithy/types").Provider<boolean>;
    useFipsEndpoint: boolean | import("@smithy/types").Provider<boolean>;
    userAgentAppId: string | import("@smithy/types").Provider<string | undefined>;
    apiVersion: string;
    cacheMiddleware?: boolean | undefined;
    urlParser: import("@smithy/types").UrlParser;
    base64Decoder: import("@smithy/types").Decoder;
    base64Encoder: (_input: Uint8Array | string) => string;
    utf8Decoder: import("@smithy/types").Decoder;
    utf8Encoder: (input: Uint8Array | string) => string;
    disableHostPrefix: boolean;
    serviceId: string;
    profile?: string;
    logger: import("@smithy/types").Logger;
    extensions: import("./runtimeExtensions").RuntimeExtension[];
    customUserAgent?: string | import("@smithy/types").UserAgent;
    retryStrategy?: import("@smithy/types").RetryStrategy | import("@smithy/types").RetryStrategyV2;
    endpoint?: ((string | import("@smithy/types").Endpoint | import("@smithy/types").Provider<import("@smithy/types").Endpoint> | import("@smithy/types").EndpointV2 | import("@smithy/types").Provider<import("@smithy/types").EndpointV2>) & (string | import("@smithy/types").Provider<string> | import("@smithy/types").Endpoint | import("@smithy/types").Provider<import("@smithy/types").Endpoint> | import("@smithy/types").EndpointV2 | import("@smithy/types").Provider<import("@smithy/types").EndpointV2>)) | undefined;
    endpointProvider: (endpointParams: import("./endpoint/EndpointParameters").EndpointParameters, context?: {
        logger?: import("@smithy/types").Logger;
    }) => import("@smithy/types").EndpointV2;
    tls?: boolean;
    serviceConfiguredEndpoint?: never;
    httpAuthSchemes: import("@smithy/types").HttpAuthScheme[] | ({
        schemeId: string;
        identityProvider: (ipc: import("@smithy/types").IdentityProviderConfig) => import("@smithy/types").IdentityProvider<import("@smithy/types").Identity> | undefined;
        signer: import("@aws-sdk/core").AwsSdkSigV4Signer;
    } | {
        schemeId: string;
        identityProvider: (ipc: import("@smithy/types").IdentityProviderConfig) => import("@smithy/types").IdentityProvider<import("@smithy/types").Identity> | (() => Promise<{}>);
        signer: import("@smithy/core").NoAuthSigner;
    })[];
    httpAuthSchemeProvider: import("./auth/httpAuthSchemeProvider").SSOHttpAuthSchemeProvider;
    credentials?: import("@smithy/types").AwsCredentialIdentity | import("@smithy/types").AwsCredentialIdentityProvider;
    signer?: import("@smithy/types").RequestSigner | ((authScheme?: import("@smithy/types").AuthScheme) => Promise<import("@smithy/types").RequestSigner>);
    signingEscapePath?: boolean;
    systemClockOffset?: number;
    signingRegion?: string;
    signerConstructor?: new (options: import("@smithy/signature-v4").SignatureV4Init & import("@smithy/signature-v4").SignatureV4CryptoInit) => import("@smithy/types").RequestSigner;
};

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/dist-types/runtimeConfig.native.d.ts

```typescript
import { SSOClientConfig } from "./SSOClient";
/**
 * @internal
 */
export declare const getRuntimeConfig: (config: SSOClientConfig) => {
    runtime: string;
    sha256: import("@smithy/types").HashConstructor;
    requestHandler: import("@smithy/types").NodeHttpHandlerOptions | import("@smithy/types").FetchHttpHandlerOptions | Record<string, unknown> | import("@smithy/protocol-http").HttpHandler<any> | import("@smithy/fetch-http-handler").FetchHttpHandler;
    apiVersion: string;
    cacheMiddleware?: boolean;
    urlParser: import("@smithy/types").UrlParser;
    bodyLengthChecker: import("@smithy/types").BodyLengthCalculator;
    streamCollector: import("@smithy/types").StreamCollector;
    base64Decoder: import("@smithy/types").Decoder;
    base64Encoder: (_input: Uint8Array | string) => string;
    utf8Decoder: import("@smithy/types").Decoder;
    utf8Encoder: (input: Uint8Array | string) => string;
    disableHostPrefix: boolean;
    serviceId: string;
    useDualstackEndpoint: (boolean | import("@smithy/types").Provider<boolean>) & (boolean | import("@smithy/types").Provider<boolean | undefined>);
    useFipsEndpoint: (boolean | import("@smithy/types").Provider<boolean>) & (boolean | import("@smithy/types").Provider<boolean | undefined>);
    region: string | import("@smithy/types").Provider<any>;
    profile?: string;
    defaultUserAgentProvider: (config?: import("@aws-sdk/util-user-agent-browser").PreviouslyResolved) => Promise<import("@smithy/types").UserAgent>;
    maxAttempts: number | import("@smithy/types").Provider<number>;
    retryMode: string | import("@smithy/types").Provider<string>;
    logger: import("@smithy/types").Logger;
    extensions: import("./runtimeExtensions").RuntimeExtension[];
    defaultsMode: import("@smithy/smithy-client").DefaultsMode | import("@smithy/types").Provider<import("@smithy/smithy-client").DefaultsMode>;
    customUserAgent?: string | import("@smithy/types").UserAgent;
    userAgentAppId?: string | undefined | import("@smithy/types").Provider<string | undefined>;
    retryStrategy?: import("@smithy/types").RetryStrategy | import("@smithy/types").RetryStrategyV2;
    endpoint?: ((string | import("@smithy/types").Endpoint | import("@smithy/types").Provider<import("@smithy/types").Endpoint> | import("@smithy/types").EndpointV2 | import("@smithy/types").Provider<import("@smithy/types").EndpointV2>) & (string | import("@smithy/types").Provider<string> | import("@smithy/types").Endpoint | import("@smithy/types").Provider<import("@smithy/types").Endpoint> | import("@smithy/types").EndpointV2 | import("@smithy/types").Provider<import("@smithy/types").EndpointV2>)) | undefined;
    endpointProvider: (endpointParams: import("./endpoint/EndpointParameters").EndpointParameters, context?: {
        logger?: import("@smithy/types").Logger;
    }) => import("@smithy/types").EndpointV2;
    tls?: boolean;
    serviceConfiguredEndpoint?: never;
    authSchemePreference?: string[] | import("@smithy/types").Provider<string[]>;
    httpAuthSchemes: import("@smithy/types").HttpAuthScheme[] | ({
        schemeId: string;
        identityProvider: (ipc: import("@smithy/types").IdentityProviderConfig) => import("@smithy/types").IdentityProvider<import("@smithy/types").Identity> | undefined;
        signer: import("@aws-sdk/core").AwsSdkSigV4Signer;
    } | {
        schemeId: string;
        identityProvider: (ipc: import("@smithy/types").IdentityProviderConfig) => import("@smithy/types").IdentityProvider<import("@smithy/types").Identity> | (() => Promise<{}>);
        signer: import("@smithy/core").NoAuthSigner;
    })[];
    httpAuthSchemeProvider: import("./auth/httpAuthSchemeProvider").SSOHttpAuthSchemeProvider;
    credentials?: import("@smithy/types").AwsCredentialIdentity | import("@smithy/types").AwsCredentialIdentityProvider;
    signer?: import("@smithy/types").RequestSigner | ((authScheme?: import("@smithy/types").AuthScheme) => Promise<import("@smithy/types").RequestSigner>);
    signingEscapePath?: boolean;
    systemClockOffset?: number;
    signingRegion?: string;
    signerConstructor?: new (options: import("@smithy/signature-v4").SignatureV4Init & import("@smithy/signature-v4").SignatureV4CryptoInit) => import("@smithy/types").RequestSigner;
};

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/dist-types/runtimeConfig.shared.d.ts

```typescript
import { AwsSdkSigV4Signer } from "@aws-sdk/core";
import { NoAuthSigner } from "@smithy/core";
import { IdentityProviderConfig } from "@smithy/types";
import { SSOClientConfig } from "./SSOClient";
/**
 * @internal
 */
export declare const getRuntimeConfig: (config: SSOClientConfig) => {
    apiVersion: string;
    base64Decoder: import("@smithy/types").Decoder;
    base64Encoder: (_input: Uint8Array | string) => string;
    disableHostPrefix: boolean;
    endpointProvider: (endpointParams: import("./endpoint/EndpointParameters").EndpointParameters, context?: {
        logger?: import("@smithy/types").Logger;
    }) => import("@smithy/types").EndpointV2;
    extensions: import("./runtimeExtensions").RuntimeExtension[];
    httpAuthSchemeProvider: import("./auth/httpAuthSchemeProvider").SSOHttpAuthSchemeProvider;
    httpAuthSchemes: import("@smithy/types").HttpAuthScheme[] | ({
        schemeId: string;
        identityProvider: (ipc: IdentityProviderConfig) => import("@smithy/types").IdentityProvider<import("@smithy/types").Identity> | undefined;
        signer: AwsSdkSigV4Signer;
    } | {
        schemeId: string;
        identityProvider: (ipc: IdentityProviderConfig) => import("@smithy/types").IdentityProvider<import("@smithy/types").Identity> | (() => Promise<{}>);
        signer: NoAuthSigner;
    })[];
    logger: import("@smithy/types").Logger;
    serviceId: string;
    urlParser: import("@smithy/types").UrlParser;
    utf8Decoder: import("@smithy/types").Decoder;
    utf8Encoder: (input: Uint8Array | string) => string;
};

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/dist-types/runtimeExtensions.d.ts

```typescript
import { SSOExtensionConfiguration } from "./extensionConfiguration";
/**
 * @public
 */
export interface RuntimeExtension {
    configure(extensionConfiguration: SSOExtensionConfiguration): void;
}
/**
 * @public
 */
export interface RuntimeExtensionsConfig {
    extensions: RuntimeExtension[];
}
/**
 * @internal
 */
export declare const resolveRuntimeExtensions: (runtimeConfig: any, extensions: RuntimeExtension[]) => any;

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/dist-types/ts3.4/SSO.d.ts

```typescript
import { HttpHandlerOptions as __HttpHandlerOptions } from "@smithy/types";
import {
  GetRoleCredentialsCommandInput,
  GetRoleCredentialsCommandOutput,
} from "./commands/GetRoleCredentialsCommand";
import {
  ListAccountRolesCommandInput,
  ListAccountRolesCommandOutput,
} from "./commands/ListAccountRolesCommand";
import {
  ListAccountsCommandInput,
  ListAccountsCommandOutput,
} from "./commands/ListAccountsCommand";
import {
  LogoutCommandInput,
  LogoutCommandOutput,
} from "./commands/LogoutCommand";
import { SSOClient } from "./SSOClient";
export interface SSO {
  getRoleCredentials(
    args: GetRoleCredentialsCommandInput,
    options?: __HttpHandlerOptions
  ): Promise<GetRoleCredentialsCommandOutput>;
  getRoleCredentials(
    args: GetRoleCredentialsCommandInput,
    cb: (err: any, data?: GetRoleCredentialsCommandOutput) => void
  ): void;
  getRoleCredentials(
    args: GetRoleCredentialsCommandInput,
    options: __HttpHandlerOptions,
    cb: (err: any, data?: GetRoleCredentialsCommandOutput) => void
  ): void;
  listAccountRoles(
    args: ListAccountRolesCommandInput,
    options?: __HttpHandlerOptions
  ): Promise<ListAccountRolesCommandOutput>;
  listAccountRoles(
    args: ListAccountRolesCommandInput,
    cb: (err: any, data?: ListAccountRolesCommandOutput) => void
  ): void;
  listAccountRoles(
    args: ListAccountRolesCommandInput,
    options: __HttpHandlerOptions,
    cb: (err: any, data?: ListAccountRolesCommandOutput) => void
  ): void;
  listAccounts(
    args: ListAccountsCommandInput,
    options?: __HttpHandlerOptions
  ): Promise<ListAccountsCommandOutput>;
  listAccounts(
    args: ListAccountsCommandInput,
    cb: (err: any, data?: ListAccountsCommandOutput) => void
  ): void;
  listAccounts(
    args: ListAccountsCommandInput,
    options: __HttpHandlerOptions,
    cb: (err: any, data?: ListAccountsCommandOutput) => void
  ): void;
  logout(
    args: LogoutCommandInput,
    options?: __HttpHandlerOptions
  ): Promise<LogoutCommandOutput>;
  logout(
    args: LogoutCommandInput,
    cb: (err: any, data?: LogoutCommandOutput) => void
  ): void;
  logout(
    args: LogoutCommandInput,
    options: __HttpHandlerOptions,
    cb: (err: any, data?: LogoutCommandOutput) => void
  ): void;
}
export declare class SSO extends SSOClient implements SSO {}

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/dist-types/ts3.4/SSOClient.d.ts

```typescript
import {
  HostHeaderInputConfig,
  HostHeaderResolvedConfig,
} from "@aws-sdk/middleware-host-header";
import {
  UserAgentInputConfig,
  UserAgentResolvedConfig,
} from "@aws-sdk/middleware-user-agent";
import {
  RegionInputConfig,
  RegionResolvedConfig,
} from "@smithy/config-resolver";
import {
  EndpointInputConfig,
  EndpointResolvedConfig,
} from "@smithy/middleware-endpoint";
import {
  RetryInputConfig,
  RetryResolvedConfig,
} from "@smithy/middleware-retry";
import { HttpHandlerUserInput as __HttpHandlerUserInput } from "@smithy/protocol-http";
import {
  Client as __Client,
  DefaultsMode as __DefaultsMode,
  SmithyConfiguration as __SmithyConfiguration,
  SmithyResolvedConfiguration as __SmithyResolvedConfiguration,
} from "@smithy/smithy-client";
import {
  BodyLengthCalculator as __BodyLengthCalculator,
  CheckOptionalClientConfig as __CheckOptionalClientConfig,
  ChecksumConstructor as __ChecksumConstructor,
  Decoder as __Decoder,
  Encoder as __Encoder,
  HashConstructor as __HashConstructor,
  HttpHandlerOptions as __HttpHandlerOptions,
  Logger as __Logger,
  Provider as __Provider,
  Provider,
  StreamCollector as __StreamCollector,
  UrlParser as __UrlParser,
  UserAgent as __UserAgent,
} from "@smithy/types";
import {
  HttpAuthSchemeInputConfig,
  HttpAuthSchemeResolvedConfig,
} from "./auth/httpAuthSchemeProvider";
import {
  GetRoleCredentialsCommandInput,
  GetRoleCredentialsCommandOutput,
} from "./commands/GetRoleCredentialsCommand";
import {
  ListAccountRolesCommandInput,
  ListAccountRolesCommandOutput,
} from "./commands/ListAccountRolesCommand";
import {
  ListAccountsCommandInput,
  ListAccountsCommandOutput,
} from "./commands/ListAccountsCommand";
import {
  LogoutCommandInput,
  LogoutCommandOutput,
} from "./commands/LogoutCommand";
import {
  ClientInputEndpointParameters,
  ClientResolvedEndpointParameters,
  EndpointParameters,
} from "./endpoint/EndpointParameters";
import { RuntimeExtension, RuntimeExtensionsConfig } from "./runtimeExtensions";
export { __Client };
export type ServiceInputTypes =
  | GetRoleCredentialsCommandInput
  | ListAccountRolesCommandInput
  | ListAccountsCommandInput
  | LogoutCommandInput;
export type ServiceOutputTypes =
  | GetRoleCredentialsCommandOutput
  | ListAccountRolesCommandOutput
  | ListAccountsCommandOutput
  | LogoutCommandOutput;
export interface ClientDefaults
  extends Partial<__SmithyConfiguration<__HttpHandlerOptions>> {
  requestHandler?: __HttpHandlerUserInput;
  sha256?: __ChecksumConstructor | __HashConstructor;
  urlParser?: __UrlParser;
  bodyLengthChecker?: __BodyLengthCalculator;
  streamCollector?: __StreamCollector;
  base64Decoder?: __Decoder;
  base64Encoder?: __Encoder;
  utf8Decoder?: __Decoder;
  utf8Encoder?: __Encoder;
  runtime?: string;
  disableHostPrefix?: boolean;
  serviceId?: string;
  useDualstackEndpoint?: boolean | __Provider<boolean>;
  useFipsEndpoint?: boolean | __Provider<boolean>;
  region?: string | __Provider<string>;
  profile?: string;
  defaultUserAgentProvider?: Provider<__UserAgent>;
  maxAttempts?: number | __Provider<number>;
  retryMode?: string | __Provider<string>;
  logger?: __Logger;
  extensions?: RuntimeExtension[];
  defaultsMode?: __DefaultsMode | __Provider<__DefaultsMode>;
}
export type SSOClientConfigType = Partial<
  __SmithyConfiguration<__HttpHandlerOptions>
> &
  ClientDefaults &
  UserAgentInputConfig &
  RetryInputConfig &
  RegionInputConfig &
  HostHeaderInputConfig &
  EndpointInputConfig<EndpointParameters> &
  HttpAuthSchemeInputConfig &
  ClientInputEndpointParameters;
export interface SSOClientConfig extends SSOClientConfigType {}
export type SSOClientResolvedConfigType =
  __SmithyResolvedConfiguration<__HttpHandlerOptions> &
    Required<ClientDefaults> &
    RuntimeExtensionsConfig &
    UserAgentResolvedConfig &
    RetryResolvedConfig &
    RegionResolvedConfig &
    HostHeaderResolvedConfig &
    EndpointResolvedConfig<EndpointParameters> &
    HttpAuthSchemeResolvedConfig &
    ClientResolvedEndpointParameters;
export interface SSOClientResolvedConfig extends SSOClientResolvedConfigType {}
export declare class SSOClient extends __Client<
  __HttpHandlerOptions,
  ServiceInputTypes,
  ServiceOutputTypes,
  SSOClientResolvedConfig
> {
  readonly config: SSOClientResolvedConfig;
  constructor(...[configuration]: __CheckOptionalClientConfig<SSOClientConfig>);
  destroy(): void;
}

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/dist-types/ts3.4/auth/httpAuthExtensionConfiguration.d.ts

```typescript
import {
  AwsCredentialIdentity,
  AwsCredentialIdentityProvider,
  HttpAuthScheme,
} from "@smithy/types";
import { SSOHttpAuthSchemeProvider } from "./httpAuthSchemeProvider";
export interface HttpAuthExtensionConfiguration {
  setHttpAuthScheme(httpAuthScheme: HttpAuthScheme): void;
  httpAuthSchemes(): HttpAuthScheme[];
  setHttpAuthSchemeProvider(
    httpAuthSchemeProvider: SSOHttpAuthSchemeProvider
  ): void;
  httpAuthSchemeProvider(): SSOHttpAuthSchemeProvider;
  setCredentials(
    credentials: AwsCredentialIdentity | AwsCredentialIdentityProvider
  ): void;
  credentials():
    | AwsCredentialIdentity
    | AwsCredentialIdentityProvider
    | undefined;
}
export type HttpAuthRuntimeConfig = Partial<{
  httpAuthSchemes: HttpAuthScheme[];
  httpAuthSchemeProvider: SSOHttpAuthSchemeProvider;
  credentials: AwsCredentialIdentity | AwsCredentialIdentityProvider;
}>;
export declare const getHttpAuthExtensionConfiguration: (
  runtimeConfig: HttpAuthRuntimeConfig
) => HttpAuthExtensionConfiguration;
export declare const resolveHttpAuthRuntimeConfig: (
  config: HttpAuthExtensionConfiguration
) => HttpAuthRuntimeConfig;

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/dist-types/ts3.4/auth/httpAuthSchemeProvider.d.ts

```typescript
import {
  AwsSdkSigV4AuthInputConfig,
  AwsSdkSigV4AuthResolvedConfig,
  AwsSdkSigV4PreviouslyResolved,
} from "@aws-sdk/core";
import {
  HandlerExecutionContext,
  HttpAuthScheme,
  HttpAuthSchemeParameters,
  HttpAuthSchemeParametersProvider,
  HttpAuthSchemeProvider,
  Provider,
} from "@smithy/types";
import { SSOClientResolvedConfig } from "../SSOClient";
export interface SSOHttpAuthSchemeParameters extends HttpAuthSchemeParameters {
  region?: string;
}
export interface SSOHttpAuthSchemeParametersProvider
  extends HttpAuthSchemeParametersProvider<
    SSOClientResolvedConfig,
    HandlerExecutionContext,
    SSOHttpAuthSchemeParameters,
    object
  > {}
export declare const defaultSSOHttpAuthSchemeParametersProvider: (
  config: SSOClientResolvedConfig,
  context: HandlerExecutionContext,
  input: object
) => Promise<SSOHttpAuthSchemeParameters>;
export interface SSOHttpAuthSchemeProvider
  extends HttpAuthSchemeProvider<SSOHttpAuthSchemeParameters> {}
export declare const defaultSSOHttpAuthSchemeProvider: SSOHttpAuthSchemeProvider;
export interface HttpAuthSchemeInputConfig extends AwsSdkSigV4AuthInputConfig {
  authSchemePreference?: string[] | Provider<string[]>;
  httpAuthSchemes?: HttpAuthScheme[];
  httpAuthSchemeProvider?: SSOHttpAuthSchemeProvider;
}
export interface HttpAuthSchemeResolvedConfig
  extends AwsSdkSigV4AuthResolvedConfig {
  readonly authSchemePreference: Provider<string[]>;
  readonly httpAuthSchemes: HttpAuthScheme[];
  readonly httpAuthSchemeProvider: SSOHttpAuthSchemeProvider;
}
export declare const resolveHttpAuthSchemeConfig: <T>(
  config: T & HttpAuthSchemeInputConfig & AwsSdkSigV4PreviouslyResolved
) => T & HttpAuthSchemeResolvedConfig;

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/dist-types/ts3.4/commands/GetRoleCredentialsCommand.d.ts

```typescript
import { Command as $Command } from "@smithy/smithy-client";
import { MetadataBearer as __MetadataBearer } from "@smithy/types";
import {
  GetRoleCredentialsRequest,
  GetRoleCredentialsResponse,
} from "../models/models_0";
import {
  ServiceInputTypes,
  ServiceOutputTypes,
  SSOClientResolvedConfig,
} from "../SSOClient";
export { __MetadataBearer };
export { $Command };
export interface GetRoleCredentialsCommandInput
  extends GetRoleCredentialsRequest {}
export interface GetRoleCredentialsCommandOutput
  extends GetRoleCredentialsResponse,
    __MetadataBearer {}
declare const GetRoleCredentialsCommand_base: {
  new (
    input: GetRoleCredentialsCommandInput
  ): import("@smithy/smithy-client").CommandImpl<
    GetRoleCredentialsCommandInput,
    GetRoleCredentialsCommandOutput,
    SSOClientResolvedConfig,
    ServiceInputTypes,
    ServiceOutputTypes
  >;
  new (
    input: GetRoleCredentialsCommandInput
  ): import("@smithy/smithy-client").CommandImpl<
    GetRoleCredentialsCommandInput,
    GetRoleCredentialsCommandOutput,
    SSOClientResolvedConfig,
    ServiceInputTypes,
    ServiceOutputTypes
  >;
  getEndpointParameterInstructions(): import("@smithy/middleware-endpoint").EndpointParameterInstructions;
};
export declare class GetRoleCredentialsCommand extends GetRoleCredentialsCommand_base {
  protected static __types: {
    api: {
      input: GetRoleCredentialsRequest;
      output: GetRoleCredentialsResponse;
    };
    sdk: {
      input: GetRoleCredentialsCommandInput;
      output: GetRoleCredentialsCommandOutput;
    };
  };
}

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/dist-types/ts3.4/commands/ListAccountRolesCommand.d.ts

```typescript
import { Command as $Command } from "@smithy/smithy-client";
import { MetadataBearer as __MetadataBearer } from "@smithy/types";
import {
  ListAccountRolesRequest,
  ListAccountRolesResponse,
} from "../models/models_0";
import {
  ServiceInputTypes,
  ServiceOutputTypes,
  SSOClientResolvedConfig,
} from "../SSOClient";
export { __MetadataBearer };
export { $Command };
export interface ListAccountRolesCommandInput extends ListAccountRolesRequest {}
export interface ListAccountRolesCommandOutput
  extends ListAccountRolesResponse,
    __MetadataBearer {}
declare const ListAccountRolesCommand_base: {
  new (
    input: ListAccountRolesCommandInput
  ): import("@smithy/smithy-client").CommandImpl<
    ListAccountRolesCommandInput,
    ListAccountRolesCommandOutput,
    SSOClientResolvedConfig,
    ServiceInputTypes,
    ServiceOutputTypes
  >;
  new (
    input: ListAccountRolesCommandInput
  ): import("@smithy/smithy-client").CommandImpl<
    ListAccountRolesCommandInput,
    ListAccountRolesCommandOutput,
    SSOClientResolvedConfig,
    ServiceInputTypes,
    ServiceOutputTypes
  >;
  getEndpointParameterInstructions(): import("@smithy/middleware-endpoint").EndpointParameterInstructions;
};
export declare class ListAccountRolesCommand extends ListAccountRolesCommand_base {
  protected static __types: {
    api: {
      input: ListAccountRolesRequest;
      output: ListAccountRolesResponse;
    };
    sdk: {
      input: ListAccountRolesCommandInput;
      output: ListAccountRolesCommandOutput;
    };
  };
}

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/dist-types/ts3.4/commands/ListAccountsCommand.d.ts

```typescript
import { Command as $Command } from "@smithy/smithy-client";
import { MetadataBearer as __MetadataBearer } from "@smithy/types";
import { ListAccountsRequest, ListAccountsResponse } from "../models/models_0";
import {
  ServiceInputTypes,
  ServiceOutputTypes,
  SSOClientResolvedConfig,
} from "../SSOClient";
export { __MetadataBearer };
export { $Command };
export interface ListAccountsCommandInput extends ListAccountsRequest {}
export interface ListAccountsCommandOutput
  extends ListAccountsResponse,
    __MetadataBearer {}
declare const ListAccountsCommand_base: {
  new (
    input: ListAccountsCommandInput
  ): import("@smithy/smithy-client").CommandImpl<
    ListAccountsCommandInput,
    ListAccountsCommandOutput,
    SSOClientResolvedConfig,
    ServiceInputTypes,
    ServiceOutputTypes
  >;
  new (
    input: ListAccountsCommandInput
  ): import("@smithy/smithy-client").CommandImpl<
    ListAccountsCommandInput,
    ListAccountsCommandOutput,
    SSOClientResolvedConfig,
    ServiceInputTypes,
    ServiceOutputTypes
  >;
  getEndpointParameterInstructions(): import("@smithy/middleware-endpoint").EndpointParameterInstructions;
};
export declare class ListAccountsCommand extends ListAccountsCommand_base {
  protected static __types: {
    api: {
      input: ListAccountsRequest;
      output: ListAccountsResponse;
    };
    sdk: {
      input: ListAccountsCommandInput;
      output: ListAccountsCommandOutput;
    };
  };
}

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/dist-types/ts3.4/commands/LogoutCommand.d.ts

```typescript
import { Command as $Command } from "@smithy/smithy-client";
import { MetadataBearer as __MetadataBearer } from "@smithy/types";
import { LogoutRequest } from "../models/models_0";
import {
  ServiceInputTypes,
  ServiceOutputTypes,
  SSOClientResolvedConfig,
} from "../SSOClient";
export { __MetadataBearer };
export { $Command };
export interface LogoutCommandInput extends LogoutRequest {}
export interface LogoutCommandOutput extends __MetadataBearer {}
declare const LogoutCommand_base: {
  new (input: LogoutCommandInput): import("@smithy/smithy-client").CommandImpl<
    LogoutCommandInput,
    LogoutCommandOutput,
    SSOClientResolvedConfig,
    ServiceInputTypes,
    ServiceOutputTypes
  >;
  new (input: LogoutCommandInput): import("@smithy/smithy-client").CommandImpl<
    LogoutCommandInput,
    LogoutCommandOutput,
    SSOClientResolvedConfig,
    ServiceInputTypes,
    ServiceOutputTypes
  >;
  getEndpointParameterInstructions(): import("@smithy/middleware-endpoint").EndpointParameterInstructions;
};
export declare class LogoutCommand extends LogoutCommand_base {
  protected static __types: {
    api: {
      input: LogoutRequest;
      output: {};
    };
    sdk: {
      input: LogoutCommandInput;
      output: LogoutCommandOutput;
    };
  };
}

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/dist-types/ts3.4/commands/index.d.ts

```typescript
export * from "./GetRoleCredentialsCommand";
export * from "./ListAccountRolesCommand";
export * from "./ListAccountsCommand";
export * from "./LogoutCommand";

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/dist-types/ts3.4/endpoint/EndpointParameters.d.ts

```typescript
import {
  Endpoint,
  EndpointParameters as __EndpointParameters,
  EndpointV2,
  Provider,
} from "@smithy/types";
export interface ClientInputEndpointParameters {
  region?: string | undefined | Provider<string | undefined>;
  useDualstackEndpoint?: boolean | undefined | Provider<boolean | undefined>;
  useFipsEndpoint?: boolean | undefined | Provider<boolean | undefined>;
  endpoint?:
    | string
    | Provider<string>
    | Endpoint
    | Provider<Endpoint>
    | EndpointV2
    | Provider<EndpointV2>;
}
export type ClientResolvedEndpointParameters = Pick<
  ClientInputEndpointParameters,
  Exclude<keyof ClientInputEndpointParameters, "endpoint">
> & {
  defaultSigningName: string;
};
export declare const resolveClientEndpointParameters: <T>(
  options: T & ClientInputEndpointParameters
) => T & ClientResolvedEndpointParameters;
export declare const commonParams: {
  readonly UseFIPS: {
    readonly type: "builtInParams";
    readonly name: "useFipsEndpoint";
  };
  readonly Endpoint: {
    readonly type: "builtInParams";
    readonly name: "endpoint";
  };
  readonly Region: {
    readonly type: "builtInParams";
    readonly name: "region";
  };
  readonly UseDualStack: {
    readonly type: "builtInParams";
    readonly name: "useDualstackEndpoint";
  };
};
export interface EndpointParameters extends __EndpointParameters {
  Region?: string | undefined;
  UseDualStack?: boolean | undefined;
  UseFIPS?: boolean | undefined;
  Endpoint?: string | undefined;
}

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/dist-types/ts3.4/endpoint/endpointResolver.d.ts

```typescript
import { EndpointV2, Logger } from "@smithy/types";
import { EndpointParameters } from "./EndpointParameters";
export declare const defaultEndpointResolver: (
  endpointParams: EndpointParameters,
  context?: {
    logger?: Logger;
  }
) => EndpointV2;

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/dist-types/ts3.4/endpoint/ruleset.d.ts

```typescript
import { RuleSetObject } from "@smithy/types";
export declare const ruleSet: RuleSetObject;

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/dist-types/ts3.4/extensionConfiguration.d.ts

```typescript
import { AwsRegionExtensionConfiguration } from "@aws-sdk/types";
import { HttpHandlerExtensionConfiguration } from "@smithy/protocol-http";
import { DefaultExtensionConfiguration } from "@smithy/types";
import { HttpAuthExtensionConfiguration } from "./auth/httpAuthExtensionConfiguration";
export interface SSOExtensionConfiguration
  extends HttpHandlerExtensionConfiguration,
    DefaultExtensionConfiguration,
    AwsRegionExtensionConfiguration,
    HttpAuthExtensionConfiguration {}

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/dist-types/ts3.4/index.d.ts

```typescript
export * from "./SSOClient";
export * from "./SSO";
export { ClientInputEndpointParameters } from "./endpoint/EndpointParameters";
export { RuntimeExtension } from "./runtimeExtensions";
export { SSOExtensionConfiguration } from "./extensionConfiguration";
export * from "./commands";
export * from "./pagination";
export * from "./models";
export { SSOServiceException } from "./models/SSOServiceException";

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/dist-types/ts3.4/models/SSOServiceException.d.ts

```typescript
import {
  ServiceException as __ServiceException,
  ServiceExceptionOptions as __ServiceExceptionOptions,
} from "@smithy/smithy-client";
export { __ServiceExceptionOptions };
export { __ServiceException };
export declare class SSOServiceException extends __ServiceException {
  constructor(options: __ServiceExceptionOptions);
}

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/dist-types/ts3.4/models/index.d.ts

```typescript
export * from "./models_0";

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/dist-types/ts3.4/models/models_0.d.ts

```typescript
import { ExceptionOptionType as __ExceptionOptionType } from "@smithy/smithy-client";
import { SSOServiceException as __BaseException } from "./SSOServiceException";
export interface AccountInfo {
  accountId?: string | undefined;
  accountName?: string | undefined;
  emailAddress?: string | undefined;
}
export interface GetRoleCredentialsRequest {
  roleName: string | undefined;
  accountId: string | undefined;
  accessToken: string | undefined;
}
export interface RoleCredentials {
  accessKeyId?: string | undefined;
  secretAccessKey?: string | undefined;
  sessionToken?: string | undefined;
  expiration?: number | undefined;
}
export interface GetRoleCredentialsResponse {
  roleCredentials?: RoleCredentials | undefined;
}
export declare class InvalidRequestException extends __BaseException {
  readonly name: "InvalidRequestException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidRequestException, __BaseException>
  );
}
export declare class ResourceNotFoundException extends __BaseException {
  readonly name: "ResourceNotFoundException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ResourceNotFoundException, __BaseException>
  );
}
export declare class TooManyRequestsException extends __BaseException {
  readonly name: "TooManyRequestsException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<TooManyRequestsException, __BaseException>
  );
}
export declare class UnauthorizedException extends __BaseException {
  readonly name: "UnauthorizedException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<UnauthorizedException, __BaseException>
  );
}
export interface ListAccountRolesRequest {
  nextToken?: string | undefined;
  maxResults?: number | undefined;
  accessToken: string | undefined;
  accountId: string | undefined;
}
export interface RoleInfo {
  roleName?: string | undefined;
  accountId?: string | undefined;
}
export interface ListAccountRolesResponse {
  nextToken?: string | undefined;
  roleList?: RoleInfo[] | undefined;
}
export interface ListAccountsRequest {
  nextToken?: string | undefined;
  maxResults?: number | undefined;
  accessToken: string | undefined;
}
export interface ListAccountsResponse {
  nextToken?: string | undefined;
  accountList?: AccountInfo[] | undefined;
}
export interface LogoutRequest {
  accessToken: string | undefined;
}
export declare const GetRoleCredentialsRequestFilterSensitiveLog: (
  obj: GetRoleCredentialsRequest
) => any;
export declare const RoleCredentialsFilterSensitiveLog: (
  obj: RoleCredentials
) => any;
export declare const GetRoleCredentialsResponseFilterSensitiveLog: (
  obj: GetRoleCredentialsResponse
) => any;
export declare const ListAccountRolesRequestFilterSensitiveLog: (
  obj: ListAccountRolesRequest
) => any;
export declare const ListAccountsRequestFilterSensitiveLog: (
  obj: ListAccountsRequest
) => any;
export declare const LogoutRequestFilterSensitiveLog: (
  obj: LogoutRequest
) => any;

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/dist-types/ts3.4/pagination/Interfaces.d.ts

```typescript
import { PaginationConfiguration } from "@smithy/types";
import { SSOClient } from "../SSOClient";
export interface SSOPaginationConfiguration extends PaginationConfiguration {
  client: SSOClient;
}

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/dist-types/ts3.4/pagination/ListAccountRolesPaginator.d.ts

```typescript
import { Paginator } from "@smithy/types";
import {
  ListAccountRolesCommandInput,
  ListAccountRolesCommandOutput,
} from "../commands/ListAccountRolesCommand";
import { SSOPaginationConfiguration } from "./Interfaces";
export declare const paginateListAccountRoles: (
  config: SSOPaginationConfiguration,
  input: ListAccountRolesCommandInput,
  ...rest: any[]
) => Paginator<ListAccountRolesCommandOutput>;

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/dist-types/ts3.4/pagination/ListAccountsPaginator.d.ts

```typescript
import { Paginator } from "@smithy/types";
import {
  ListAccountsCommandInput,
  ListAccountsCommandOutput,
} from "../commands/ListAccountsCommand";
import { SSOPaginationConfiguration } from "./Interfaces";
export declare const paginateListAccounts: (
  config: SSOPaginationConfiguration,
  input: ListAccountsCommandInput,
  ...rest: any[]
) => Paginator<ListAccountsCommandOutput>;

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/dist-types/ts3.4/pagination/index.d.ts

```typescript
export * from "./Interfaces";
export * from "./ListAccountRolesPaginator";
export * from "./ListAccountsPaginator";

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/dist-types/ts3.4/protocols/Aws_restJson1.d.ts

```typescript
import {
  HttpRequest as __HttpRequest,
  HttpResponse as __HttpResponse,
} from "@smithy/protocol-http";
import { SerdeContext as __SerdeContext } from "@smithy/types";
import {
  GetRoleCredentialsCommandInput,
  GetRoleCredentialsCommandOutput,
} from "../commands/GetRoleCredentialsCommand";
import {
  ListAccountRolesCommandInput,
  ListAccountRolesCommandOutput,
} from "../commands/ListAccountRolesCommand";
import {
  ListAccountsCommandInput,
  ListAccountsCommandOutput,
} from "../commands/ListAccountsCommand";
import {
  LogoutCommandInput,
  LogoutCommandOutput,
} from "../commands/LogoutCommand";
export declare const se_GetRoleCredentialsCommand: (
  input: GetRoleCredentialsCommandInput,
  context: __SerdeContext
) => Promise<__HttpRequest>;
export declare const se_ListAccountRolesCommand: (
  input: ListAccountRolesCommandInput,
  context: __SerdeContext
) => Promise<__HttpRequest>;
export declare const se_ListAccountsCommand: (
  input: ListAccountsCommandInput,
  context: __SerdeContext
) => Promise<__HttpRequest>;
export declare const se_LogoutCommand: (
  input: LogoutCommandInput,
  context: __SerdeContext
) => Promise<__HttpRequest>;
export declare const de_GetRoleCredentialsCommand: (
  output: __HttpResponse,
  context: __SerdeContext
) => Promise<GetRoleCredentialsCommandOutput>;
export declare const de_ListAccountRolesCommand: (
  output: __HttpResponse,
  context: __SerdeContext
) => Promise<ListAccountRolesCommandOutput>;
export declare const de_ListAccountsCommand: (
  output: __HttpResponse,
  context: __SerdeContext
) => Promise<ListAccountsCommandOutput>;
export declare const de_LogoutCommand: (
  output: __HttpResponse,
  context: __SerdeContext
) => Promise<LogoutCommandOutput>;

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/dist-types/ts3.4/runtimeConfig.browser.d.ts

```typescript
import { FetchHttpHandler as RequestHandler } from "@smithy/fetch-http-handler";
import { SSOClientConfig } from "./SSOClient";
export declare const getRuntimeConfig: (config: SSOClientConfig) => {
  runtime: string;
  defaultsMode: import("@smithy/types").Provider<
    import("@smithy/smithy-client").ResolvedDefaultsMode
  >;
  bodyLengthChecker: import("@smithy/types").BodyLengthCalculator;
  defaultUserAgentProvider: (
    config?: import("@aws-sdk/util-user-agent-browser").PreviouslyResolved
  ) => Promise<import("@smithy/types").UserAgent>;
  maxAttempts: number | import("@smithy/types").Provider<number>;
  region: string | import("@smithy/types").Provider<any>;
  requestHandler:
    | import("@smithy/protocol-http").HttpHandler<any>
    | RequestHandler;
  retryMode: string | import("@smithy/types").Provider<string>;
  sha256: import("@smithy/types").HashConstructor;
  streamCollector: import("@smithy/types").StreamCollector;
  useDualstackEndpoint: (boolean | import("@smithy/types").Provider<boolean>) &
    (boolean | import("@smithy/types").Provider<boolean | undefined>);
  useFipsEndpoint: (boolean | import("@smithy/types").Provider<boolean>) &
    (boolean | import("@smithy/types").Provider<boolean | undefined>);
  apiVersion: string;
  cacheMiddleware?: boolean | undefined;
  urlParser: import("@smithy/types").UrlParser;
  base64Decoder: import("@smithy/types").Decoder;
  base64Encoder: (_input: Uint8Array | string) => string;
  utf8Decoder: import("@smithy/types").Decoder;
  utf8Encoder: (input: Uint8Array | string) => string;
  disableHostPrefix: boolean;
  serviceId: string;
  profile?: string;
  logger: import("@smithy/types").Logger;
  extensions: import("./runtimeExtensions").RuntimeExtension[];
  customUserAgent?: string | import("@smithy/types").UserAgent;
  userAgentAppId?:
    | string
    | undefined
    | import("@smithy/types").Provider<string | undefined>;
  retryStrategy?:
    | import("@smithy/types").RetryStrategy
    | import("@smithy/types").RetryStrategyV2;
  endpoint?:
    | ((
        | string
        | import("@smithy/types").Endpoint
        | import("@smithy/types").Provider<import("@smithy/types").Endpoint>
        | import("@smithy/types").EndpointV2
        | import("@smithy/types").Provider<import("@smithy/types").EndpointV2>
      ) &
        (
          | string
          | import("@smithy/types").Provider<string>
          | import("@smithy/types").Endpoint
          | import("@smithy/types").Provider<import("@smithy/types").Endpoint>
          | import("@smithy/types").EndpointV2
          | import("@smithy/types").Provider<import("@smithy/types").EndpointV2>
        ))
    | undefined;
  endpointProvider: (
    endpointParams: import("./endpoint/EndpointParameters").EndpointParameters,
    context?: {
      logger?: import("@smithy/types").Logger;
    }
  ) => import("@smithy/types").EndpointV2;
  tls?: boolean;
  serviceConfiguredEndpoint?: never;
  authSchemePreference?: string[] | import("@smithy/types").Provider<string[]>;
  httpAuthSchemes:
    | import("@smithy/types").HttpAuthScheme[]
    | (
        | {
            schemeId: string;
            identityProvider: (
              ipc: import("@smithy/types").IdentityProviderConfig
            ) =>
              | import("@smithy/types").IdentityProvider<
                  import("@smithy/types").Identity
                >
              | undefined;
            signer: import("@aws-sdk/core").AwsSdkSigV4Signer;
          }
        | {
            schemeId: string;
            identityProvider: (
              ipc: import("@smithy/types").IdentityProviderConfig
            ) =>
              | import("@smithy/types").IdentityProvider<
                  import("@smithy/types").Identity
                >
              | (() => Promise<{}>);
            signer: import("@smithy/core").NoAuthSigner;
          }
      )[];
  httpAuthSchemeProvider: import("./auth/httpAuthSchemeProvider").SSOHttpAuthSchemeProvider;
  credentials?:
    | import("@smithy/types").AwsCredentialIdentity
    | import("@smithy/types").AwsCredentialIdentityProvider;
  signer?:
    | import("@smithy/types").RequestSigner
    | ((
        authScheme?: import("@smithy/types").AuthScheme
      ) => Promise<import("@smithy/types").RequestSigner>);
  signingEscapePath?: boolean;
  systemClockOffset?: number;
  signingRegion?: string;
  signerConstructor?: new (
    options: import("@smithy/signature-v4").SignatureV4Init &
      import("@smithy/signature-v4").SignatureV4CryptoInit
  ) => import("@smithy/types").RequestSigner;
};

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/dist-types/ts3.4/runtimeConfig.d.ts

```typescript
import { NodeHttpHandler as RequestHandler } from "@smithy/node-http-handler";
import { SSOClientConfig } from "./SSOClient";
export declare const getRuntimeConfig: (config: SSOClientConfig) => {
  runtime: string;
  defaultsMode: import("@smithy/types").Provider<
    import("@smithy/smithy-client").ResolvedDefaultsMode
  >;
  authSchemePreference: string[] | import("@smithy/types").Provider<string[]>;
  bodyLengthChecker: import("@smithy/types").BodyLengthCalculator;
  defaultUserAgentProvider: (
    config?: import("@aws-sdk/util-user-agent-node").PreviouslyResolved
  ) => Promise<import("@smithy/types").UserAgent>;
  maxAttempts: number | import("@smithy/types").Provider<number>;
  region: string | import("@smithy/types").Provider<string>;
  requestHandler:
    | RequestHandler
    | import("@smithy/protocol-http").HttpHandler<any>;
  retryMode: string | import("@smithy/types").Provider<string>;
  sha256: import("@smithy/types").HashConstructor;
  streamCollector: import("@smithy/types").StreamCollector;
  useDualstackEndpoint: boolean | import("@smithy/types").Provider<boolean>;
  useFipsEndpoint: boolean | import("@smithy/types").Provider<boolean>;
  userAgentAppId: string | import("@smithy/types").Provider<string | undefined>;
  apiVersion: string;
  cacheMiddleware?: boolean | undefined;
  urlParser: import("@smithy/types").UrlParser;
  base64Decoder: import("@smithy/types").Decoder;
  base64Encoder: (_input: Uint8Array | string) => string;
  utf8Decoder: import("@smithy/types").Decoder;
  utf8Encoder: (input: Uint8Array | string) => string;
  disableHostPrefix: boolean;
  serviceId: string;
  profile?: string;
  logger: import("@smithy/types").Logger;
  extensions: import("./runtimeExtensions").RuntimeExtension[];
  customUserAgent?: string | import("@smithy/types").UserAgent;
  retryStrategy?:
    | import("@smithy/types").RetryStrategy
    | import("@smithy/types").RetryStrategyV2;
  endpoint?:
    | ((
        | string
        | import("@smithy/types").Endpoint
        | import("@smithy/types").Provider<import("@smithy/types").Endpoint>
        | import("@smithy/types").EndpointV2
        | import("@smithy/types").Provider<import("@smithy/types").EndpointV2>
      ) &
        (
          | string
          | import("@smithy/types").Provider<string>
          | import("@smithy/types").Endpoint
          | import("@smithy/types").Provider<import("@smithy/types").Endpoint>
          | import("@smithy/types").EndpointV2
          | import("@smithy/types").Provider<import("@smithy/types").EndpointV2>
        ))
    | undefined;
  endpointProvider: (
    endpointParams: import("./endpoint/EndpointParameters").EndpointParameters,
    context?: {
      logger?: import("@smithy/types").Logger;
    }
  ) => import("@smithy/types").EndpointV2;
  tls?: boolean;
  serviceConfiguredEndpoint?: never;
  httpAuthSchemes:
    | import("@smithy/types").HttpAuthScheme[]
    | (
        | {
            schemeId: string;
            identityProvider: (
              ipc: import("@smithy/types").IdentityProviderConfig
            ) =>
              | import("@smithy/types").IdentityProvider<
                  import("@smithy/types").Identity
                >
              | undefined;
            signer: import("@aws-sdk/core").AwsSdkSigV4Signer;
          }
        | {
            schemeId: string;
            identityProvider: (
              ipc: import("@smithy/types").IdentityProviderConfig
            ) =>
              | import("@smithy/types").IdentityProvider<
                  import("@smithy/types").Identity
                >
              | (() => Promise<{}>);
            signer: import("@smithy/core").NoAuthSigner;
          }
      )[];
  httpAuthSchemeProvider: import("./auth/httpAuthSchemeProvider").SSOHttpAuthSchemeProvider;
  credentials?:
    | import("@smithy/types").AwsCredentialIdentity
    | import("@smithy/types").AwsCredentialIdentityProvider;
  signer?:
    | import("@smithy/types").RequestSigner
    | ((
        authScheme?: import("@smithy/types").AuthScheme
      ) => Promise<import("@smithy/types").RequestSigner>);
  signingEscapePath?: boolean;
  systemClockOffset?: number;
  signingRegion?: string;
  signerConstructor?: new (
    options: import("@smithy/signature-v4").SignatureV4Init &
      import("@smithy/signature-v4").SignatureV4CryptoInit
  ) => import("@smithy/types").RequestSigner;
};

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/dist-types/ts3.4/runtimeConfig.native.d.ts

```typescript
import { SSOClientConfig } from "./SSOClient";
export declare const getRuntimeConfig: (config: SSOClientConfig) => {
  runtime: string;
  sha256: import("@smithy/types").HashConstructor;
  requestHandler:
    | import("@smithy/types").NodeHttpHandlerOptions
    | import("@smithy/types").FetchHttpHandlerOptions
    | Record<string, unknown>
    | import("@smithy/protocol-http").HttpHandler<any>
    | import("@smithy/fetch-http-handler").FetchHttpHandler;
  apiVersion: string;
  cacheMiddleware?: boolean;
  urlParser: import("@smithy/types").UrlParser;
  bodyLengthChecker: import("@smithy/types").BodyLengthCalculator;
  streamCollector: import("@smithy/types").StreamCollector;
  base64Decoder: import("@smithy/types").Decoder;
  base64Encoder: (_input: Uint8Array | string) => string;
  utf8Decoder: import("@smithy/types").Decoder;
  utf8Encoder: (input: Uint8Array | string) => string;
  disableHostPrefix: boolean;
  serviceId: string;
  useDualstackEndpoint: (boolean | import("@smithy/types").Provider<boolean>) &
    (boolean | import("@smithy/types").Provider<boolean | undefined>);
  useFipsEndpoint: (boolean | import("@smithy/types").Provider<boolean>) &
    (boolean | import("@smithy/types").Provider<boolean | undefined>);
  region: string | import("@smithy/types").Provider<any>;
  profile?: string;
  defaultUserAgentProvider: (
    config?: import("@aws-sdk/util-user-agent-browser").PreviouslyResolved
  ) => Promise<import("@smithy/types").UserAgent>;
  maxAttempts: number | import("@smithy/types").Provider<number>;
  retryMode: string | import("@smithy/types").Provider<string>;
  logger: import("@smithy/types").Logger;
  extensions: import("./runtimeExtensions").RuntimeExtension[];
  defaultsMode:
    | import("@smithy/smithy-client").DefaultsMode
    | import("@smithy/types").Provider<
        import("@smithy/smithy-client").DefaultsMode
      >;
  customUserAgent?: string | import("@smithy/types").UserAgent;
  userAgentAppId?:
    | string
    | undefined
    | import("@smithy/types").Provider<string | undefined>;
  retryStrategy?:
    | import("@smithy/types").RetryStrategy
    | import("@smithy/types").RetryStrategyV2;
  endpoint?:
    | ((
        | string
        | import("@smithy/types").Endpoint
        | import("@smithy/types").Provider<import("@smithy/types").Endpoint>
        | import("@smithy/types").EndpointV2
        | import("@smithy/types").Provider<import("@smithy/types").EndpointV2>
      ) &
        (
          | string
          | import("@smithy/types").Provider<string>
          | import("@smithy/types").Endpoint
          | import("@smithy/types").Provider<import("@smithy/types").Endpoint>
          | import("@smithy/types").EndpointV2
          | import("@smithy/types").Provider<import("@smithy/types").EndpointV2>
        ))
    | undefined;
  endpointProvider: (
    endpointParams: import("./endpoint/EndpointParameters").EndpointParameters,
    context?: {
      logger?: import("@smithy/types").Logger;
    }
  ) => import("@smithy/types").EndpointV2;
  tls?: boolean;
  serviceConfiguredEndpoint?: never;
  authSchemePreference?: string[] | import("@smithy/types").Provider<string[]>;
  httpAuthSchemes:
    | import("@smithy/types").HttpAuthScheme[]
    | (
        | {
            schemeId: string;
            identityProvider: (
              ipc: import("@smithy/types").IdentityProviderConfig
            ) =>
              | import("@smithy/types").IdentityProvider<
                  import("@smithy/types").Identity
                >
              | undefined;
            signer: import("@aws-sdk/core").AwsSdkSigV4Signer;
          }
        | {
            schemeId: string;
            identityProvider: (
              ipc: import("@smithy/types").IdentityProviderConfig
            ) =>
              | import("@smithy/types").IdentityProvider<
                  import("@smithy/types").Identity
                >
              | (() => Promise<{}>);
            signer: import("@smithy/core").NoAuthSigner;
          }
      )[];
  httpAuthSchemeProvider: import("./auth/httpAuthSchemeProvider").SSOHttpAuthSchemeProvider;
  credentials?:
    | import("@smithy/types").AwsCredentialIdentity
    | import("@smithy/types").AwsCredentialIdentityProvider;
  signer?:
    | import("@smithy/types").RequestSigner
    | ((
        authScheme?: import("@smithy/types").AuthScheme
      ) => Promise<import("@smithy/types").RequestSigner>);
  signingEscapePath?: boolean;
  systemClockOffset?: number;
  signingRegion?: string;
  signerConstructor?: new (
    options: import("@smithy/signature-v4").SignatureV4Init &
      import("@smithy/signature-v4").SignatureV4CryptoInit
  ) => import("@smithy/types").RequestSigner;
};

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/dist-types/ts3.4/runtimeConfig.shared.d.ts

```typescript
import { AwsSdkSigV4Signer } from "@aws-sdk/core";
import { NoAuthSigner } from "@smithy/core";
import { IdentityProviderConfig } from "@smithy/types";
import { SSOClientConfig } from "./SSOClient";
export declare const getRuntimeConfig: (config: SSOClientConfig) => {
  apiVersion: string;
  base64Decoder: import("@smithy/types").Decoder;
  base64Encoder: (_input: Uint8Array | string) => string;
  disableHostPrefix: boolean;
  endpointProvider: (
    endpointParams: import("./endpoint/EndpointParameters").EndpointParameters,
    context?: {
      logger?: import("@smithy/types").Logger;
    }
  ) => import("@smithy/types").EndpointV2;
  extensions: import("./runtimeExtensions").RuntimeExtension[];
  httpAuthSchemeProvider: import("./auth/httpAuthSchemeProvider").SSOHttpAuthSchemeProvider;
  httpAuthSchemes:
    | import("@smithy/types").HttpAuthScheme[]
    | (
        | {
            schemeId: string;
            identityProvider: (
              ipc: IdentityProviderConfig
            ) =>
              | import("@smithy/types").IdentityProvider<
                  import("@smithy/types").Identity
                >
              | undefined;
            signer: AwsSdkSigV4Signer;
          }
        | {
            schemeId: string;
            identityProvider: (
              ipc: IdentityProviderConfig
            ) =>
              | import("@smithy/types").IdentityProvider<
                  import("@smithy/types").Identity
                >
              | (() => Promise<{}>);
            signer: NoAuthSigner;
          }
      )[];
  logger: import("@smithy/types").Logger;
  serviceId: string;
  urlParser: import("@smithy/types").UrlParser;
  utf8Decoder: import("@smithy/types").Decoder;
  utf8Encoder: (input: Uint8Array | string) => string;
};

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/dist-types/ts3.4/runtimeExtensions.d.ts

```typescript
import { SSOExtensionConfiguration } from "./extensionConfiguration";
export interface RuntimeExtension {
  configure(extensionConfiguration: SSOExtensionConfiguration): void;
}
export interface RuntimeExtensionsConfig {
  extensions: RuntimeExtension[];
}
export declare const resolveRuntimeExtensions: (
  runtimeConfig: any,
  extensions: RuntimeExtension[]
) => any;

```

## ./lib/lambda/node_modules/@aws-sdk/client-sso/package.json

```json
{
  "name": "@aws-sdk/client-sso",
  "description": "AWS SDK for JavaScript Sso Client for Node.js, Browser and React Native",
  "version": "3.911.0",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "node ../../scripts/compilation/inline client-sso",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "extract:docs": "api-extractor run --local",
    "generate:client": "node ../../scripts/generate-clients/single-service --solo sso"
  },
  "main": "./dist-cjs/index.js",
  "types": "./dist-types/index.d.ts",
  "module": "./dist-es/index.js",
  "sideEffects": false,
  "dependencies": {
    "@aws-crypto/sha256-browser": "5.2.0",
    "@aws-crypto/sha256-js": "5.2.0",
    "@aws-sdk/core": "3.911.0",
    "@aws-sdk/middleware-host-header": "3.910.0",
    "@aws-sdk/middleware-logger": "3.910.0",
    "@aws-sdk/middleware-recursion-detection": "3.910.0",
    "@aws-sdk/middleware-user-agent": "3.911.0",
    "@aws-sdk/region-config-resolver": "3.910.0",
    "@aws-sdk/types": "3.910.0",
    "@aws-sdk/util-endpoints": "3.910.0",
    "@aws-sdk/util-user-agent-browser": "3.910.0",
    "@aws-sdk/util-user-agent-node": "3.911.0",
    "@smithy/config-resolver": "^4.3.2",
    "@smithy/core": "^3.16.1",
    "@smithy/fetch-http-handler": "^5.3.3",
    "@smithy/hash-node": "^4.2.2",
    "@smithy/invalid-dependency": "^4.2.2",
    "@smithy/middleware-content-length": "^4.2.2",
    "@smithy/middleware-endpoint": "^4.3.3",
    "@smithy/middleware-retry": "^4.4.3",
    "@smithy/middleware-serde": "^4.2.2",
    "@smithy/middleware-stack": "^4.2.2",
    "@smithy/node-config-provider": "^4.3.2",
    "@smithy/node-http-handler": "^4.4.1",
    "@smithy/protocol-http": "^5.3.2",
    "@smithy/smithy-client": "^4.8.1",
    "@smithy/types": "^4.7.1",
    "@smithy/url-parser": "^4.2.2",
    "@smithy/util-base64": "^4.3.0",
    "@smithy/util-body-length-browser": "^4.2.0",
    "@smithy/util-body-length-node": "^4.2.1",
    "@smithy/util-defaults-mode-browser": "^4.3.2",
    "@smithy/util-defaults-mode-node": "^4.2.3",
    "@smithy/util-endpoints": "^3.2.2",
    "@smithy/util-middleware": "^4.2.2",
    "@smithy/util-retry": "^4.2.2",
    "@smithy/util-utf8": "^4.2.0",
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "@tsconfig/node18": "18.2.4",
    "@types/node": "^18.19.69",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typescript": "~5.8.3"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "browser": {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
  },
  "react-native": {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
  },
  "homepage": "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sso",
  "repository": {
    "type": "git",
    "url": "https://github.com/aws/aws-sdk-js-v3.git",
    "directory": "clients/client-sso"
  }
}

```

## ./lib/lambda/node_modules/@aws-sdk/core/account-id-endpoint.d.ts

```typescript
/**
 * Do not edit:
 * This is a compatibility redirect for contexts that do not understand package.json exports field.
 */
declare module "@aws-sdk/core/account-id-endpoint" {
  export * from "@aws-sdk/core/dist-types/submodules/account-id-endpoint/index.d";
}

```

## ./lib/lambda/node_modules/@aws-sdk/core/dist-types/api-extractor-type-index.d.ts

```typescript
export * from "./index";
export * from "./submodules/account-id-endpoint/index";
export * from "./submodules/client/index";
export * from "./submodules/httpAuthSchemes/index";
export * from "./submodules/protocols/index";

```

## ./lib/lambda/node_modules/@aws-sdk/core/dist-types/submodules/account-id-endpoint/AccountIdEndpointModeConfigResolver.d.ts

```typescript
import type { Provider } from "@smithy/types";
import { AccountIdEndpointMode } from "./AccountIdEndpointModeConstants";
/**
 * @public
 */
export interface AccountIdEndpointModeInputConfig {
    /**
     * The account ID endpoint mode to use.
     */
    accountIdEndpointMode?: AccountIdEndpointMode | Provider<AccountIdEndpointMode>;
}
/**
 * @internal
 */
interface PreviouslyResolved {
}
/**
 * @internal
 */
export interface AccountIdEndpointModeResolvedConfig {
    accountIdEndpointMode: Provider<AccountIdEndpointMode>;
}
/**
 * @internal
 */
export declare const resolveAccountIdEndpointModeConfig: <T>(input: T & AccountIdEndpointModeInputConfig & PreviouslyResolved) => T & AccountIdEndpointModeResolvedConfig;
export {};

```

## ./lib/lambda/node_modules/@aws-sdk/core/dist-types/submodules/account-id-endpoint/AccountIdEndpointModeConstants.d.ts

```typescript
/**
 * @public
 */
export type AccountIdEndpointMode = "disabled" | "preferred" | "required";
/**
 * @internal
 */
export declare const DEFAULT_ACCOUNT_ID_ENDPOINT_MODE = "preferred";
/**
 * @internal
 */
export declare const ACCOUNT_ID_ENDPOINT_MODE_VALUES: AccountIdEndpointMode[];
/**
 * @internal
 */
export declare function validateAccountIdEndpointMode(value: any): value is AccountIdEndpointMode;

```

## ./lib/lambda/node_modules/@aws-sdk/core/dist-types/submodules/httpAuthSchemes/aws_sdk/AwsSdkSigV4ASigner.d.ts

```typescript
import type { AwsCredentialIdentity, HttpRequest as IHttpRequest } from "@smithy/types";
import { AwsSdkSigV4Signer } from "./AwsSdkSigV4Signer";
/**
 * @internal
 * Note: this is not a signing algorithm implementation. The sign method
 * accepts the real signer as an input parameter.
 */
export declare class AwsSdkSigV4ASigner extends AwsSdkSigV4Signer {
    sign(httpRequest: IHttpRequest, identity: AwsCredentialIdentity, signingProperties: Record<string, unknown>): Promise<IHttpRequest>;
}

```

## ./lib/lambda/node_modules/@aws-sdk/core/dist-types/submodules/httpAuthSchemes/aws_sdk/AwsSdkSigV4Signer.d.ts

```typescript
import type { AuthScheme, AwsCredentialIdentity, HttpRequest as IHttpRequest, HttpResponse, HttpSigner, RequestSigner } from "@smithy/types";
import { AwsSdkSigV4AAuthResolvedConfig } from "./resolveAwsSdkSigV4AConfig";
/**
 * @internal
 */
interface AwsSdkSigV4Config extends AwsSdkSigV4AAuthResolvedConfig {
    systemClockOffset: number;
    signer: (authScheme?: AuthScheme) => Promise<RequestSigner>;
}
/**
 * @internal
 */
interface AwsSdkSigV4AuthSigningProperties {
    config: AwsSdkSigV4Config;
    signer: RequestSigner;
    signingRegion?: string;
    signingRegionSet?: string[];
    signingName?: string;
}
/**
 * @internal
 */
export declare const validateSigningProperties: (signingProperties: Record<string, unknown>) => Promise<AwsSdkSigV4AuthSigningProperties>;
/**
 * Note: this is not a signing algorithm implementation. The sign method
 * accepts the real signer as an input parameter.
 * @internal
 */
export declare class AwsSdkSigV4Signer implements HttpSigner {
    sign(httpRequest: IHttpRequest, 
    /**
     * `identity` is bound in {@link resolveAWSSDKSigV4Config}
     */
    identity: AwsCredentialIdentity, signingProperties: Record<string, unknown>): Promise<IHttpRequest>;
    errorHandler(signingProperties: Record<string, unknown>): (error: Error) => never;
    successHandler(httpResponse: HttpResponse | unknown, signingProperties: Record<string, unknown>): void;
}
/**
 * @internal
 * @deprecated renamed to {@link AwsSdkSigV4Signer}
 */
export declare const AWSSDKSigV4Signer: typeof AwsSdkSigV4Signer;
export {};

```

## ./lib/lambda/node_modules/@aws-sdk/core/dist-types/submodules/protocols/json/AwsJson1_0Protocol.d.ts

```typescript
import { AwsJsonRpcProtocol } from "./AwsJsonRpcProtocol";
/**
 * @alpha
 * @see https://smithy.io/2.0/aws/protocols/aws-json-1_1-protocol.html#differences-between-awsjson1-0-and-awsjson1-1
 */
export declare class AwsJson1_0Protocol extends AwsJsonRpcProtocol {
    constructor({ defaultNamespace, serviceTarget, awsQueryCompatible, }: {
        defaultNamespace: string;
        serviceTarget: string;
        awsQueryCompatible?: boolean;
    });
    getShapeId(): string;
    protected getJsonRpcVersion(): "1.0";
    /**
     * @override
     */
    protected getDefaultContentType(): string;
}

```

## ./lib/lambda/node_modules/@aws-sdk/core/dist-types/submodules/protocols/json/AwsJson1_1Protocol.d.ts

```typescript
import { AwsJsonRpcProtocol } from "./AwsJsonRpcProtocol";
/**
 * @alpha
 * @see https://smithy.io/2.0/aws/protocols/aws-json-1_1-protocol.html#differences-between-awsjson1-0-and-awsjson1-1
 */
export declare class AwsJson1_1Protocol extends AwsJsonRpcProtocol {
    constructor({ defaultNamespace, serviceTarget, awsQueryCompatible, }: {
        defaultNamespace: string;
        serviceTarget: string;
        awsQueryCompatible?: boolean;
    });
    getShapeId(): string;
    protected getJsonRpcVersion(): "1.1";
    /**
     * @override
     */
    protected getDefaultContentType(): string;
}

```

## ./lib/lambda/node_modules/@aws-sdk/core/dist-types/submodules/protocols/json/AwsJsonRpcProtocol.d.ts

```typescript
import { RpcProtocol } from "@smithy/core/protocols";
import type { EndpointBearer, HandlerExecutionContext, HttpRequest, HttpResponse, OperationSchema, ResponseMetadata, SerdeFunctions, ShapeDeserializer, ShapeSerializer } from "@smithy/types";
import { JsonCodec } from "./JsonCodec";
/**
 * @alpha
 */
export declare abstract class AwsJsonRpcProtocol extends RpcProtocol {
    protected serializer: ShapeSerializer<string | Uint8Array>;
    protected deserializer: ShapeDeserializer<string | Uint8Array>;
    protected serviceTarget: string;
    private readonly codec;
    private readonly mixin;
    private readonly awsQueryCompatible;
    protected constructor({ defaultNamespace, serviceTarget, awsQueryCompatible, }: {
        defaultNamespace: string;
        serviceTarget: string;
        awsQueryCompatible?: boolean;
    });
    serializeRequest<Input extends object>(operationSchema: OperationSchema, input: Input, context: HandlerExecutionContext & SerdeFunctions & EndpointBearer): Promise<HttpRequest>;
    getPayloadCodec(): JsonCodec;
    protected abstract getJsonRpcVersion(): "1.1" | "1.0";
    protected handleError(operationSchema: OperationSchema, context: HandlerExecutionContext & SerdeFunctions, response: HttpResponse, dataObject: any, metadata: ResponseMetadata): Promise<never>;
}

```

## ./lib/lambda/node_modules/@aws-sdk/core/dist-types/submodules/protocols/json/AwsRestJsonProtocol.d.ts

```typescript
import { HttpBindingProtocol } from "@smithy/core/protocols";
import type { EndpointBearer, HandlerExecutionContext, HttpRequest, HttpResponse, OperationSchema, ResponseMetadata, SerdeFunctions, ShapeDeserializer, ShapeSerializer } from "@smithy/types";
import { JsonCodec } from "./JsonCodec";
/**
 * @alpha
 */
export declare class AwsRestJsonProtocol extends HttpBindingProtocol {
    protected serializer: ShapeSerializer<string | Uint8Array>;
    protected deserializer: ShapeDeserializer<string | Uint8Array>;
    private readonly codec;
    private readonly mixin;
    constructor({ defaultNamespace }: {
        defaultNamespace: string;
    });
    getShapeId(): string;
    getPayloadCodec(): JsonCodec;
    setSerdeContext(serdeContext: SerdeFunctions): void;
    serializeRequest<Input extends object>(operationSchema: OperationSchema, input: Input, context: HandlerExecutionContext & SerdeFunctions & EndpointBearer): Promise<HttpRequest>;
    protected handleError(operationSchema: OperationSchema, context: HandlerExecutionContext & SerdeFunctions, response: HttpResponse, dataObject: any, metadata: ResponseMetadata): Promise<never>;
    /**
     * @override
     */
    protected getDefaultContentType(): string;
}

```

## ./lib/lambda/node_modules/@aws-sdk/core/dist-types/submodules/protocols/json/awsExpectUnion.d.ts

```typescript
/**
 * @internal
 *
 * Forwards to Smithy's expectUnion function, but also ignores
 * the `__type` field if it is present.
 */
export declare const awsExpectUnion: (value: unknown) => Record<string, any> | undefined;

```

## ./lib/lambda/node_modules/@aws-sdk/core/dist-types/submodules/protocols/query/AwsEc2QueryProtocol.d.ts

```typescript
import { AwsQueryProtocol } from "./AwsQueryProtocol";
/**
 * @alpha
 */
export declare class AwsEc2QueryProtocol extends AwsQueryProtocol {
    options: {
        defaultNamespace: string;
        xmlNamespace: string;
        version: string;
    };
    constructor(options: {
        defaultNamespace: string;
        xmlNamespace: string;
        version: string;
    });
    /**
     * EC2 Query reads XResponse.XResult instead of XResponse directly.
     */
    protected useNestedResult(): boolean;
}

```

## ./lib/lambda/node_modules/@aws-sdk/core/dist-types/submodules/protocols/query/AwsQueryProtocol.d.ts

```typescript
import { RpcProtocol } from "@smithy/core/protocols";
import type { Codec, EndpointBearer, HandlerExecutionContext, HttpRequest, HttpResponse as IHttpResponse, MetadataBearer, OperationSchema, ResponseMetadata, SerdeFunctions } from "@smithy/types";
import { XmlShapeDeserializer } from "../xml/XmlShapeDeserializer";
import { QueryShapeSerializer } from "./QueryShapeSerializer";
/**
 * @alpha
 */
export declare class AwsQueryProtocol extends RpcProtocol {
    options: {
        defaultNamespace: string;
        xmlNamespace: string;
        version: string;
    };
    protected serializer: QueryShapeSerializer;
    protected deserializer: XmlShapeDeserializer;
    private readonly mixin;
    constructor(options: {
        defaultNamespace: string;
        xmlNamespace: string;
        version: string;
    });
    getShapeId(): string;
    setSerdeContext(serdeContext: SerdeFunctions): void;
    getPayloadCodec(): Codec<any, any>;
    serializeRequest<Input extends object>(operationSchema: OperationSchema, input: Input, context: HandlerExecutionContext & SerdeFunctions & EndpointBearer): Promise<HttpRequest>;
    deserializeResponse<Output extends MetadataBearer>(operationSchema: OperationSchema, context: HandlerExecutionContext & SerdeFunctions, response: IHttpResponse): Promise<Output>;
    /**
     * EC2 Query overrides this.
     */
    protected useNestedResult(): boolean;
    protected handleError(operationSchema: OperationSchema, context: HandlerExecutionContext & SerdeFunctions, response: IHttpResponse, dataObject: any, metadata: ResponseMetadata): Promise<never>;
    /**
     * The variations in the error and error message locations are attributed to
     * divergence between AWS Query and EC2 Query behavior.
     */
    protected loadQueryErrorCode(output: IHttpResponse, data: any): string | undefined;
    protected loadQueryError(data: any): any | undefined;
    protected loadQueryErrorMessage(data: any): string;
    /**
     * @override
     */
    protected getDefaultContentType(): string;
}

```

## ./lib/lambda/node_modules/@aws-sdk/core/dist-types/submodules/protocols/xml/AwsRestXmlProtocol.d.ts

```typescript
import { HttpBindingProtocol } from "@smithy/core/protocols";
import type { EndpointBearer, HandlerExecutionContext, HttpRequest as IHttpRequest, HttpResponse as IHttpResponse, MetadataBearer, OperationSchema, ResponseMetadata, SerdeFunctions, ShapeDeserializer, ShapeSerializer } from "@smithy/types";
import { XmlCodec } from "./XmlCodec";
/**
 * @alpha
 */
export declare class AwsRestXmlProtocol extends HttpBindingProtocol {
    private readonly codec;
    protected serializer: ShapeSerializer<string | Uint8Array>;
    protected deserializer: ShapeDeserializer<string | Uint8Array>;
    private readonly mixin;
    constructor(options: {
        defaultNamespace: string;
        xmlNamespace: string;
    });
    getPayloadCodec(): XmlCodec;
    getShapeId(): string;
    serializeRequest<Input extends object>(operationSchema: OperationSchema, input: Input, context: HandlerExecutionContext & SerdeFunctions & EndpointBearer): Promise<IHttpRequest>;
    deserializeResponse<Output extends MetadataBearer>(operationSchema: OperationSchema, context: HandlerExecutionContext & SerdeFunctions, response: IHttpResponse): Promise<Output>;
    protected handleError(operationSchema: OperationSchema, context: HandlerExecutionContext & SerdeFunctions, response: IHttpResponse, dataObject: any, metadata: ResponseMetadata): Promise<never>;
    /**
     * @override
     */
    protected getDefaultContentType(): string;
}

```

## ./lib/lambda/node_modules/@aws-sdk/core/dist-types/ts3.4/api-extractor-type-index.d.ts

```typescript
export * from "./index";
export * from "./submodules/account-id-endpoint/index";
export * from "./submodules/client/index";
export * from "./submodules/httpAuthSchemes/index";
export * from "./submodules/protocols/index";

```

## ./lib/lambda/node_modules/@aws-sdk/core/dist-types/ts3.4/submodules/account-id-endpoint/AccountIdEndpointModeConfigResolver.d.ts

```typescript
import { Provider } from "@smithy/types";
import { AccountIdEndpointMode } from "./AccountIdEndpointModeConstants";
export interface AccountIdEndpointModeInputConfig {
  accountIdEndpointMode?:
    | AccountIdEndpointMode
    | Provider<AccountIdEndpointMode>;
}
interface PreviouslyResolved {}
export interface AccountIdEndpointModeResolvedConfig {
  accountIdEndpointMode: Provider<AccountIdEndpointMode>;
}
export declare const resolveAccountIdEndpointModeConfig: <T>(
  input: T & AccountIdEndpointModeInputConfig & PreviouslyResolved
) => T & AccountIdEndpointModeResolvedConfig;
export {};

```

## ./lib/lambda/node_modules/@aws-sdk/core/dist-types/ts3.4/submodules/account-id-endpoint/AccountIdEndpointModeConstants.d.ts

```typescript
export type AccountIdEndpointMode = "disabled" | "preferred" | "required";
export declare const DEFAULT_ACCOUNT_ID_ENDPOINT_MODE = "preferred";
export declare const ACCOUNT_ID_ENDPOINT_MODE_VALUES: AccountIdEndpointMode[];
export declare function validateAccountIdEndpointMode(
  value: any
): value is AccountIdEndpointMode;

```

## ./lib/lambda/node_modules/@aws-sdk/core/dist-types/ts3.4/submodules/httpAuthSchemes/aws_sdk/AwsSdkSigV4ASigner.d.ts

```typescript
import {
  AwsCredentialIdentity,
  HttpRequest as IHttpRequest,
} from "@smithy/types";
import { AwsSdkSigV4Signer } from "./AwsSdkSigV4Signer";
export declare class AwsSdkSigV4ASigner extends AwsSdkSigV4Signer {
  sign(
    httpRequest: IHttpRequest,
    identity: AwsCredentialIdentity,
    signingProperties: Record<string, unknown>
  ): Promise<IHttpRequest>;
}

```

## ./lib/lambda/node_modules/@aws-sdk/core/dist-types/ts3.4/submodules/httpAuthSchemes/aws_sdk/AwsSdkSigV4Signer.d.ts

```typescript
import {
  AuthScheme,
  AwsCredentialIdentity,
  HttpRequest as IHttpRequest,
  HttpResponse,
  HttpSigner,
  RequestSigner,
} from "@smithy/types";
import { AwsSdkSigV4AAuthResolvedConfig } from "./resolveAwsSdkSigV4AConfig";
interface AwsSdkSigV4Config extends AwsSdkSigV4AAuthResolvedConfig {
  systemClockOffset: number;
  signer: (authScheme?: AuthScheme) => Promise<RequestSigner>;
}
interface AwsSdkSigV4AuthSigningProperties {
  config: AwsSdkSigV4Config;
  signer: RequestSigner;
  signingRegion?: string;
  signingRegionSet?: string[];
  signingName?: string;
}
export declare const validateSigningProperties: (
  signingProperties: Record<string, unknown>
) => Promise<AwsSdkSigV4AuthSigningProperties>;
export declare class AwsSdkSigV4Signer implements HttpSigner {
  sign(
    httpRequest: IHttpRequest,
    identity: AwsCredentialIdentity,
    signingProperties: Record<string, unknown>
  ): Promise<IHttpRequest>;
  errorHandler(
    signingProperties: Record<string, unknown>
  ): (error: Error) => never;
  successHandler(
    httpResponse: HttpResponse | unknown,
    signingProperties: Record<string, unknown>
  ): void;
}
export declare const AWSSDKSigV4Signer: typeof AwsSdkSigV4Signer;
export {};

```

## ./lib/lambda/node_modules/@aws-sdk/core/dist-types/ts3.4/submodules/protocols/json/AwsJson1_0Protocol.d.ts

```typescript
import { AwsJsonRpcProtocol } from "./AwsJsonRpcProtocol";
export declare class AwsJson1_0Protocol extends AwsJsonRpcProtocol {
  constructor({
    defaultNamespace,
    serviceTarget,
    awsQueryCompatible,
  }: {
    defaultNamespace: string;
    serviceTarget: string;
    awsQueryCompatible?: boolean;
  });
  getShapeId(): string;
  protected getJsonRpcVersion(): "1.0";
  protected getDefaultContentType(): string;
}

```

## ./lib/lambda/node_modules/@aws-sdk/core/dist-types/ts3.4/submodules/protocols/json/AwsJson1_1Protocol.d.ts

```typescript
import { AwsJsonRpcProtocol } from "./AwsJsonRpcProtocol";
export declare class AwsJson1_1Protocol extends AwsJsonRpcProtocol {
  constructor({
    defaultNamespace,
    serviceTarget,
    awsQueryCompatible,
  }: {
    defaultNamespace: string;
    serviceTarget: string;
    awsQueryCompatible?: boolean;
  });
  getShapeId(): string;
  protected getJsonRpcVersion(): "1.1";
  protected getDefaultContentType(): string;
}

```

## ./lib/lambda/node_modules/@aws-sdk/core/dist-types/ts3.4/submodules/protocols/json/AwsJsonRpcProtocol.d.ts

```typescript
import { RpcProtocol } from "@smithy/core/protocols";
import {
  EndpointBearer,
  HandlerExecutionContext,
  HttpRequest,
  HttpResponse,
  OperationSchema,
  ResponseMetadata,
  SerdeFunctions,
  ShapeDeserializer,
  ShapeSerializer,
} from "@smithy/types";
import { JsonCodec } from "./JsonCodec";
export declare abstract class AwsJsonRpcProtocol extends RpcProtocol {
  protected serializer: ShapeSerializer<string | Uint8Array>;
  protected deserializer: ShapeDeserializer<string | Uint8Array>;
  protected serviceTarget: string;
  private readonly codec;
  private readonly mixin;
  private readonly awsQueryCompatible;
  protected constructor({
    defaultNamespace,
    serviceTarget,
    awsQueryCompatible,
  }: {
    defaultNamespace: string;
    serviceTarget: string;
    awsQueryCompatible?: boolean;
  });
  serializeRequest<Input extends object>(
    operationSchema: OperationSchema,
    input: Input,
    context: HandlerExecutionContext & SerdeFunctions & EndpointBearer
  ): Promise<HttpRequest>;
  getPayloadCodec(): JsonCodec;
  protected abstract getJsonRpcVersion(): "1.1" | "1.0";
  protected handleError(
    operationSchema: OperationSchema,
    context: HandlerExecutionContext & SerdeFunctions,
    response: HttpResponse,
    dataObject: any,
    metadata: ResponseMetadata
  ): Promise<never>;
}

```

## ./lib/lambda/node_modules/@aws-sdk/core/dist-types/ts3.4/submodules/protocols/json/AwsRestJsonProtocol.d.ts

```typescript
import { HttpBindingProtocol } from "@smithy/core/protocols";
import {
  EndpointBearer,
  HandlerExecutionContext,
  HttpRequest,
  HttpResponse,
  OperationSchema,
  ResponseMetadata,
  SerdeFunctions,
  ShapeDeserializer,
  ShapeSerializer,
} from "@smithy/types";
import { JsonCodec } from "./JsonCodec";
export declare class AwsRestJsonProtocol extends HttpBindingProtocol {
  protected serializer: ShapeSerializer<string | Uint8Array>;
  protected deserializer: ShapeDeserializer<string | Uint8Array>;
  private readonly codec;
  private readonly mixin;
  constructor({ defaultNamespace }: { defaultNamespace: string });
  getShapeId(): string;
  getPayloadCodec(): JsonCodec;
  setSerdeContext(serdeContext: SerdeFunctions): void;
  serializeRequest<Input extends object>(
    operationSchema: OperationSchema,
    input: Input,
    context: HandlerExecutionContext & SerdeFunctions & EndpointBearer
  ): Promise<HttpRequest>;
  protected handleError(
    operationSchema: OperationSchema,
    context: HandlerExecutionContext & SerdeFunctions,
    response: HttpResponse,
    dataObject: any,
    metadata: ResponseMetadata
  ): Promise<never>;
  protected getDefaultContentType(): string;
}

```

## ./lib/lambda/node_modules/@aws-sdk/core/dist-types/ts3.4/submodules/protocols/json/awsExpectUnion.d.ts

```typescript
export declare const awsExpectUnion: (
  value: unknown
) => Record<string, any> | undefined;

```

## ./lib/lambda/node_modules/@aws-sdk/core/dist-types/ts3.4/submodules/protocols/query/AwsEc2QueryProtocol.d.ts

```typescript
import { AwsQueryProtocol } from "./AwsQueryProtocol";
export declare class AwsEc2QueryProtocol extends AwsQueryProtocol {
  options: {
    defaultNamespace: string;
    xmlNamespace: string;
    version: string;
  };
  constructor(options: {
    defaultNamespace: string;
    xmlNamespace: string;
    version: string;
  });
  protected useNestedResult(): boolean;
}

```

## ./lib/lambda/node_modules/@aws-sdk/core/dist-types/ts3.4/submodules/protocols/query/AwsQueryProtocol.d.ts

```typescript
import { RpcProtocol } from "@smithy/core/protocols";
import {
  Codec,
  EndpointBearer,
  HandlerExecutionContext,
  HttpRequest,
  HttpResponse as IHttpResponse,
  MetadataBearer,
  OperationSchema,
  ResponseMetadata,
  SerdeFunctions,
} from "@smithy/types";
import { XmlShapeDeserializer } from "../xml/XmlShapeDeserializer";
import { QueryShapeSerializer } from "./QueryShapeSerializer";
export declare class AwsQueryProtocol extends RpcProtocol {
  options: {
    defaultNamespace: string;
    xmlNamespace: string;
    version: string;
  };
  protected serializer: QueryShapeSerializer;
  protected deserializer: XmlShapeDeserializer;
  private readonly mixin;
  constructor(options: {
    defaultNamespace: string;
    xmlNamespace: string;
    version: string;
  });
  getShapeId(): string;
  setSerdeContext(serdeContext: SerdeFunctions): void;
  getPayloadCodec(): Codec<any, any>;
  serializeRequest<Input extends object>(
    operationSchema: OperationSchema,
    input: Input,
    context: HandlerExecutionContext & SerdeFunctions & EndpointBearer
  ): Promise<HttpRequest>;
  deserializeResponse<Output extends MetadataBearer>(
    operationSchema: OperationSchema,
    context: HandlerExecutionContext & SerdeFunctions,
    response: IHttpResponse
  ): Promise<Output>;
  protected useNestedResult(): boolean;
  protected handleError(
    operationSchema: OperationSchema,
    context: HandlerExecutionContext & SerdeFunctions,
    response: IHttpResponse,
    dataObject: any,
    metadata: ResponseMetadata
  ): Promise<never>;
  protected loadQueryErrorCode(
    output: IHttpResponse,
    data: any
  ): string | undefined;
  protected loadQueryError(data: any): any | undefined;
  protected loadQueryErrorMessage(data: any): string;
  protected getDefaultContentType(): string;
}

```

## ./lib/lambda/node_modules/@aws-sdk/core/dist-types/ts3.4/submodules/protocols/xml/AwsRestXmlProtocol.d.ts

```typescript
import { HttpBindingProtocol } from "@smithy/core/protocols";
import {
  EndpointBearer,
  HandlerExecutionContext,
  HttpRequest as IHttpRequest,
  HttpResponse as IHttpResponse,
  MetadataBearer,
  OperationSchema,
  ResponseMetadata,
  SerdeFunctions,
  ShapeDeserializer,
  ShapeSerializer,
} from "@smithy/types";
import { XmlCodec } from "./XmlCodec";
export declare class AwsRestXmlProtocol extends HttpBindingProtocol {
  private readonly codec;
  protected serializer: ShapeSerializer<string | Uint8Array>;
  protected deserializer: ShapeDeserializer<string | Uint8Array>;
  private readonly mixin;
  constructor(options: { defaultNamespace: string; xmlNamespace: string });
  getPayloadCodec(): XmlCodec;
  getShapeId(): string;
  serializeRequest<Input extends object>(
    operationSchema: OperationSchema,
    input: Input,
    context: HandlerExecutionContext & SerdeFunctions & EndpointBearer
  ): Promise<IHttpRequest>;
  deserializeResponse<Output extends MetadataBearer>(
    operationSchema: OperationSchema,
    context: HandlerExecutionContext & SerdeFunctions,
    response: IHttpResponse
  ): Promise<Output>;
  protected handleError(
    operationSchema: OperationSchema,
    context: HandlerExecutionContext & SerdeFunctions,
    response: IHttpResponse,
    dataObject: any,
    metadata: ResponseMetadata
  ): Promise<never>;
  protected getDefaultContentType(): string;
}

```

## ./lib/lambda/node_modules/@aws-sdk/core/package.json

```json
{
  "name": "@aws-sdk/core",
  "version": "3.911.0",
  "description": "Core functions & classes shared by multiple AWS SDK clients.",
  "scripts": {
    "build": "yarn lint && concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "node ../../scripts/compilation/inline core && rimraf ./dist-cjs/api-extractor-type-index.js",
    "build:es": "tsc -p tsconfig.es.json && rimraf ./dist-es/api-extractor-type-index.js",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    "lint": "node ../../scripts/validation/submodules-linter.js --pkg core",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "extract:docs": "api-extractor run --local",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch",
    "test:integration": "yarn g:vitest run -c vitest.config.integ.mts",
    "test:integration:watch": "yarn g:vitest watch -c vitest.config.integ.mts"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "exports": {
    ".": {
      "types": "./dist-types/index.d.ts",
      "module": "./dist-es/index.js",
      "node": "./dist-cjs/index.js",
      "import": "./dist-es/index.js",
      "require": "./dist-cjs/index.js"
    },
    "./package.json": {
      "module": "./package.json",
      "node": "./package.json",
      "import": "./package.json",
      "require": "./package.json"
    },
    "./client": {
      "types": "./dist-types/submodules/client/index.d.ts",
      "module": "./dist-es/submodules/client/index.js",
      "node": "./dist-cjs/submodules/client/index.js",
      "import": "./dist-es/submodules/client/index.js",
      "require": "./dist-cjs/submodules/client/index.js"
    },
    "./httpAuthSchemes": {
      "types": "./dist-types/submodules/httpAuthSchemes/index.d.ts",
      "module": "./dist-es/submodules/httpAuthSchemes/index.js",
      "node": "./dist-cjs/submodules/httpAuthSchemes/index.js",
      "import": "./dist-es/submodules/httpAuthSchemes/index.js",
      "require": "./dist-cjs/submodules/httpAuthSchemes/index.js"
    },
    "./account-id-endpoint": {
      "types": "./dist-types/submodules/account-id-endpoint/index.d.ts",
      "module": "./dist-es/submodules/account-id-endpoint/index.js",
      "node": "./dist-cjs/submodules/account-id-endpoint/index.js",
      "import": "./dist-es/submodules/account-id-endpoint/index.js",
      "require": "./dist-cjs/submodules/account-id-endpoint/index.js"
    },
    "./protocols": {
      "types": "./dist-types/submodules/protocols/index.d.ts",
      "module": "./dist-es/submodules/protocols/index.js",
      "node": "./dist-cjs/submodules/protocols/index.js",
      "import": "./dist-es/submodules/protocols/index.js",
      "require": "./dist-cjs/submodules/protocols/index.js"
    }
  },
  "files": [
    "./account-id-endpoint.d.ts",
    "./account-id-endpoint.js",
    "./client.d.ts",
    "./client.js",
    "./httpAuthSchemes.d.ts",
    "./httpAuthSchemes.js",
    "./protocols.d.ts",
    "./protocols.js",
    "dist-*/**"
  ],
  "sideEffects": false,
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "dependencies": {
    "@aws-sdk/types": "3.910.0",
    "@aws-sdk/xml-builder": "3.911.0",
    "@smithy/core": "^3.16.1",
    "@smithy/node-config-provider": "^4.3.2",
    "@smithy/property-provider": "^4.2.2",
    "@smithy/protocol-http": "^5.3.2",
    "@smithy/signature-v4": "^5.3.2",
    "@smithy/smithy-client": "^4.8.1",
    "@smithy/types": "^4.7.1",
    "@smithy/util-base64": "^4.3.0",
    "@smithy/util-middleware": "^4.2.2",
    "@smithy/util-utf8": "^4.2.0",
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "@tsconfig/recommended": "1.0.1",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typescript": "~5.8.3"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "homepage": "https://github.com/aws/aws-sdk-js-v3/tree/main/packages/core",
  "repository": {
    "type": "git",
    "url": "https://github.com/aws/aws-sdk-js-v3.git",
    "directory": "packages/core"
  }
}

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-env/dist-types/fromEnv.d.ts

```typescript
import type { CredentialProviderOptions } from "@aws-sdk/types";
import { AwsCredentialIdentityProvider } from "@smithy/types";
export interface FromEnvInit extends CredentialProviderOptions {
}
/**
 * @internal
 */
export declare const ENV_KEY = "AWS_ACCESS_KEY_ID";
/**
 * @internal
 */
export declare const ENV_SECRET = "AWS_SECRET_ACCESS_KEY";
/**
 * @internal
 */
export declare const ENV_SESSION = "AWS_SESSION_TOKEN";
/**
 * @internal
 */
export declare const ENV_EXPIRATION = "AWS_CREDENTIAL_EXPIRATION";
/**
 * @internal
 */
export declare const ENV_CREDENTIAL_SCOPE = "AWS_CREDENTIAL_SCOPE";
/**
 * @internal
 */
export declare const ENV_ACCOUNT_ID = "AWS_ACCOUNT_ID";
/**
 * @internal
 *
 * Source AWS credentials from known environment variables. If either the
 * `AWS_ACCESS_KEY_ID` or `AWS_SECRET_ACCESS_KEY` environment variable is not
 * set in this process, the provider will return a rejected promise.
 */
export declare const fromEnv: (init?: FromEnvInit) => AwsCredentialIdentityProvider;

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-env/dist-types/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./fromEnv";

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-env/dist-types/ts3.4/fromEnv.d.ts

```typescript
import { CredentialProviderOptions } from "@aws-sdk/types";
import { AwsCredentialIdentityProvider } from "@smithy/types";
export interface FromEnvInit extends CredentialProviderOptions {}
export declare const ENV_KEY = "AWS_ACCESS_KEY_ID";
export declare const ENV_SECRET = "AWS_SECRET_ACCESS_KEY";
export declare const ENV_SESSION = "AWS_SESSION_TOKEN";
export declare const ENV_EXPIRATION = "AWS_CREDENTIAL_EXPIRATION";
export declare const ENV_CREDENTIAL_SCOPE = "AWS_CREDENTIAL_SCOPE";
export declare const ENV_ACCOUNT_ID = "AWS_ACCOUNT_ID";
export declare const fromEnv: (
  init?: FromEnvInit
) => AwsCredentialIdentityProvider;

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-env/dist-types/ts3.4/index.d.ts

```typescript
export * from "./fromEnv";

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-env/package.json

```json
{
  "name": "@aws-sdk/credential-provider-env",
  "version": "3.911.0",
  "description": "AWS credential provider that sources credentials from known environment variables",
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "node ../../scripts/compilation/inline credential-provider-env",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch"
  },
  "keywords": [
    "aws",
    "credentials"
  ],
  "sideEffects": false,
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "dependencies": {
    "@aws-sdk/core": "3.911.0",
    "@aws-sdk/types": "3.910.0",
    "@smithy/property-provider": "^4.2.2",
    "@smithy/types": "^4.7.1",
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "@tsconfig/recommended": "1.0.1",
    "@types/node": "^18.19.69",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typescript": "~5.8.3"
  },
  "types": "./dist-types/index.d.ts",
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/aws/aws-sdk-js-v3/tree/main/packages/credential-provider-env",
  "repository": {
    "type": "git",
    "url": "https://github.com/aws/aws-sdk-js-v3.git",
    "directory": "packages/credential-provider-env"
  }
}

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-http/dist-types/fromHttp/checkUrl.d.ts

```typescript
import { Logger } from "@smithy/types";
/**
 * @internal
 *
 * @param url - to be validated.
 * @param logger - passed to CredentialsProviderError.
 * @throws if not acceptable to this provider.
 */
export declare const checkUrl: (url: URL, logger?: Logger) => void;

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-http/dist-types/fromHttp/fromHttp.browser.d.ts

```typescript
import { AwsCredentialIdentityProvider } from "@smithy/types";
import type { FromHttpOptions } from "./fromHttpTypes";
/**
 * Creates a provider that gets credentials via HTTP request.
 */
export declare const fromHttp: (options?: FromHttpOptions) => AwsCredentialIdentityProvider;

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-http/dist-types/fromHttp/fromHttp.d.ts

```typescript
import { AwsCredentialIdentityProvider } from "@smithy/types";
import type { FromHttpOptions } from "./fromHttpTypes";
/**
 * Creates a provider that gets credentials via HTTP request.
 */
export declare const fromHttp: (options?: FromHttpOptions) => AwsCredentialIdentityProvider;

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-http/dist-types/fromHttp/fromHttpTypes.d.ts

```typescript
import type { CredentialProviderOptions } from "@aws-sdk/types";
/**
 * @public
 *
 * Input for the fromHttp function in the HTTP Credentials Provider for Node.js.
 */
export interface FromHttpOptions extends CredentialProviderOptions {
    /**
     * If this value is provided, it will be used as-is.
     *
     * For browser environments, use instead {@link credentialsFullUri}.
     */
    awsContainerCredentialsFullUri?: string;
    /**
     * If this value is provided instead of the full URI, it
     * will be appended to the default link local host of 169.254.170.2.
     *
     * Not supported in browsers.
     */
    awsContainerCredentialsRelativeUri?: string;
    /**
     * Will be read on each credentials request to
     * add an Authorization request header value.
     *
     * Not supported in browsers.
     */
    awsContainerAuthorizationTokenFile?: string;
    /**
     * An alternative to awsContainerAuthorizationTokenFile,
     * this is the token value itself.
     *
     * For browser environments, use instead {@link authorizationToken}.
     */
    awsContainerAuthorizationToken?: string;
    /**
     * BROWSER ONLY.
     *
     * In browsers, a relative URI is not allowed, and a full URI must be provided.
     * HTTPS is required.
     *
     * This value is required for the browser environment.
     */
    credentialsFullUri?: string;
    /**
     * BROWSER ONLY.
     *
     * Providing this value will set an "Authorization" request
     * header value on the GET request.
     */
    authorizationToken?: string;
    /**
     * Default is 3 retry attempts or 4 total attempts.
     */
    maxRetries?: number;
    /**
     * Default is 1000ms. Time in milliseconds to spend waiting between retry attempts.
     */
    timeout?: number;
}
/**
 * @public
 */
export type HttpProviderCredentials = {
    AccessKeyId: string;
    SecretAccessKey: string;
    Token: string;
    AccountId?: string;
    Expiration: string;
};

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-http/dist-types/fromHttp/requestHelpers.d.ts

```typescript
import { AwsCredentialIdentity } from "@aws-sdk/types";
import { HttpRequest } from "@smithy/protocol-http";
import { HttpResponse, Logger } from "@smithy/types";
/**
 * @internal
 */
export declare function createGetRequest(url: URL): HttpRequest;
/**
 * @internal
 */
export declare function getCredentials(response: HttpResponse, logger?: Logger): Promise<AwsCredentialIdentity>;

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-http/dist-types/fromHttp/retry-wrapper.d.ts

```typescript
/**
 * @internal
 */
export interface RetryableProvider<T> {
    (): Promise<T>;
}
/**
 * @internal
 */
export declare const retryWrapper: <T>(toRetry: RetryableProvider<T>, maxRetries: number, delayMs: number) => RetryableProvider<T>;

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-http/dist-types/index.browser.d.ts

```typescript
export { fromHttp } from "./fromHttp/fromHttp.browser";
export type { FromHttpOptions, HttpProviderCredentials } from "./fromHttp/fromHttpTypes";

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-http/dist-types/index.d.ts

```typescript
export { fromHttp } from "./fromHttp/fromHttp";
export type { FromHttpOptions, HttpProviderCredentials } from "./fromHttp/fromHttpTypes";

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-http/dist-types/ts3.4/fromHttp/checkUrl.d.ts

```typescript
import { Logger } from "@smithy/types";
export declare const checkUrl: (url: URL, logger?: Logger) => void;

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-http/dist-types/ts3.4/fromHttp/fromHttp.browser.d.ts

```typescript
import { AwsCredentialIdentityProvider } from "@smithy/types";
import { FromHttpOptions } from "./fromHttpTypes";
export declare const fromHttp: (
  options?: FromHttpOptions
) => AwsCredentialIdentityProvider;

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-http/dist-types/ts3.4/fromHttp/fromHttp.d.ts

```typescript
import { AwsCredentialIdentityProvider } from "@smithy/types";
import { FromHttpOptions } from "./fromHttpTypes";
export declare const fromHttp: (
  options?: FromHttpOptions
) => AwsCredentialIdentityProvider;

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-http/dist-types/ts3.4/fromHttp/fromHttpTypes.d.ts

```typescript
import { CredentialProviderOptions } from "@aws-sdk/types";
export interface FromHttpOptions extends CredentialProviderOptions {
  awsContainerCredentialsFullUri?: string;
  awsContainerCredentialsRelativeUri?: string;
  awsContainerAuthorizationTokenFile?: string;
  awsContainerAuthorizationToken?: string;
  credentialsFullUri?: string;
  authorizationToken?: string;
  maxRetries?: number;
  timeout?: number;
}
export type HttpProviderCredentials = {
  AccessKeyId: string;
  SecretAccessKey: string;
  Token: string;
  AccountId?: string;
  Expiration: string;
};

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-http/dist-types/ts3.4/fromHttp/requestHelpers.d.ts

```typescript
import { AwsCredentialIdentity } from "@aws-sdk/types";
import { HttpRequest } from "@smithy/protocol-http";
import { HttpResponse, Logger } from "@smithy/types";
export declare function createGetRequest(url: URL): HttpRequest;
export declare function getCredentials(
  response: HttpResponse,
  logger?: Logger
): Promise<AwsCredentialIdentity>;

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-http/dist-types/ts3.4/fromHttp/retry-wrapper.d.ts

```typescript
export interface RetryableProvider<T> {
  (): Promise<T>;
}
export declare const retryWrapper: <T>(
  toRetry: RetryableProvider<T>,
  maxRetries: number,
  delayMs: number
) => RetryableProvider<T>;

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-http/dist-types/ts3.4/index.browser.d.ts

```typescript
export { fromHttp } from "./fromHttp/fromHttp.browser";
export {
  FromHttpOptions,
  HttpProviderCredentials,
} from "./fromHttp/fromHttpTypes";

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-http/dist-types/ts3.4/index.d.ts

```typescript
export { fromHttp } from "./fromHttp/fromHttp";
export {
  FromHttpOptions,
  HttpProviderCredentials,
} from "./fromHttp/fromHttpTypes";

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-http/package.json

```json
{
  "name": "@aws-sdk/credential-provider-http",
  "version": "3.911.0",
  "description": "AWS credential provider for containers and HTTP sources",
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "browser": "./dist-es/index.browser.js",
  "react-native": "./dist-es/index.browser.js",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "node ../../scripts/compilation/inline credential-provider-http",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch"
  },
  "keywords": [
    "aws",
    "credentials"
  ],
  "sideEffects": false,
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "dependencies": {
    "@aws-sdk/core": "3.911.0",
    "@aws-sdk/types": "3.910.0",
    "@smithy/fetch-http-handler": "^5.3.3",
    "@smithy/node-http-handler": "^4.4.1",
    "@smithy/property-provider": "^4.2.2",
    "@smithy/protocol-http": "^5.3.2",
    "@smithy/smithy-client": "^4.8.1",
    "@smithy/types": "^4.7.1",
    "@smithy/util-stream": "^4.5.2",
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "@tsconfig/recommended": "1.0.1",
    "@types/node": "^18.19.69",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typescript": "~5.8.3"
  },
  "types": "./dist-types/index.d.ts",
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/aws/aws-sdk-js-v3/tree/main/packages/credential-provider-http",
  "repository": {
    "type": "git",
    "url": "https://github.com/aws/aws-sdk-js-v3.git",
    "directory": "packages/credential-provider-http"
  }
}

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-ini/dist-types/fromIni.d.ts

```typescript
import type { AssumeRoleWithWebIdentityParams } from "@aws-sdk/credential-provider-web-identity";
import type { CredentialProviderOptions } from "@aws-sdk/types";
import type { RuntimeConfigAwsCredentialIdentityProvider } from "@aws-sdk/types";
import { SourceProfileInit } from "@smithy/shared-ini-file-loader";
import type { AwsCredentialIdentity, Pluggable } from "@smithy/types";
import { AssumeRoleParams } from "./resolveAssumeRoleCredentials";
/**
 * @public
 */
export interface FromIniInit extends SourceProfileInit, CredentialProviderOptions {
    /**
     * A function that returns a promise fulfilled with an MFA token code for
     * the provided MFA Serial code. If a profile requires an MFA code and
     * `mfaCodeProvider` is not a valid function, the credential provider
     * promise will be rejected.
     *
     * @param mfaSerial The serial code of the MFA device specified.
     */
    mfaCodeProvider?: (mfaSerial: string) => Promise<string>;
    /**
     * A function that assumes a role and returns a promise fulfilled with
     * credentials for the assumed role.
     *
     * @param sourceCreds The credentials with which to assume a role.
     * @param params
     */
    roleAssumer?: (sourceCreds: AwsCredentialIdentity, params: AssumeRoleParams) => Promise<AwsCredentialIdentity>;
    /**
     * A function that assumes a role with web identity and returns a promise fulfilled with
     * credentials for the assumed role.
     *
     * @param sourceCreds The credentials with which to assume a role.
     * @param params
     */
    roleAssumerWithWebIdentity?: (params: AssumeRoleWithWebIdentityParams) => Promise<AwsCredentialIdentity>;
    /**
     * STSClientConfig or SSOClientConfig to be used for creating inner client
     * for auth operations.
     * @internal
     */
    clientConfig?: any;
    clientPlugins?: Pluggable<any, any>[];
    /**
     * When true, always reload credentials from the file system instead of using cached values.
     * This is useful when you need to detect changes to the credentials file.
     */
    ignoreCache?: boolean;
}
/**
 * @internal
 *
 * Creates a credential provider that will read from ini files and supports
 * role assumption and multi-factor authentication.
 */
export declare const fromIni: (_init?: FromIniInit) => RuntimeConfigAwsCredentialIdentityProvider;

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-ini/dist-types/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./fromIni";

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-ini/dist-types/resolveAssumeRoleCredentials.d.ts

```typescript
import { Logger, ParsedIniData } from "@smithy/types";
import { FromIniInit } from "./fromIni";
/**
 * @internal
 *
 * @see http://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/STS.html#assumeRole-property
 * TODO update the above to link to V3 docs
 */
export interface AssumeRoleParams {
    /**
     * The identifier of the role to be assumed.
     */
    RoleArn: string;
    /**
     * A name for the assumed role session.
     */
    RoleSessionName: string;
    /**
     * A unique identifier that is used by third parties when assuming roles in
     * their customers' accounts.
     */
    ExternalId?: string;
    /**
     * The identification number of the MFA device that is associated with the
     * user who is making the `AssumeRole` call.
     */
    SerialNumber?: string;
    /**
     * The value provided by the MFA device.
     */
    TokenCode?: string;
    /**
     * The duration, in seconds, of the role session.
     */
    DurationSeconds?: number;
}
/**
 * @internal
 */
export declare const isAssumeRoleProfile: (arg: any, { profile, logger }?: {
    profile?: string;
    logger?: Logger;
}) => boolean;
/**
 * @internal
 */
export declare const resolveAssumeRoleCredentials: (profileName: string, profiles: ParsedIniData, options: FromIniInit, visitedProfiles?: Record<string, true>) => Promise<import("@aws-sdk/types").AttributedAwsCredentialIdentity>;

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-ini/dist-types/resolveCredentialSource.d.ts

```typescript
import type { CredentialProviderOptions } from "@aws-sdk/types";
import { AwsCredentialIdentityProvider, Logger } from "@smithy/types";
/**
 * @internal
 *
 * Resolve the `credential_source` entry from the profile, and return the
 * credential providers respectively. No memoization is needed for the
 * credential source providers because memoization should be added outside the
 * fromIni() provider. The source credential needs to be refreshed every time
 * fromIni() is called.
 */
export declare const resolveCredentialSource: (credentialSource: string, profileName: string, logger?: Logger) => ((options?: CredentialProviderOptions) => Promise<AwsCredentialIdentityProvider>);

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-ini/dist-types/resolveProcessCredentials.d.ts

```typescript
import { Credentials, Profile } from "@aws-sdk/types";
import { FromIniInit } from "./fromIni";
/**
 * @internal
 */
export interface ProcessProfile extends Profile {
    credential_process: string;
}
/**
 * @internal
 */
export declare const isProcessProfile: (arg: any) => arg is ProcessProfile;
/**
 * @internal
 */
export declare const resolveProcessCredentials: (options: FromIniInit, profile: string) => Promise<Credentials>;

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-ini/dist-types/resolveProfileData.d.ts

```typescript
import type { AwsCredentialIdentity, ParsedIniData } from "@smithy/types";
import { FromIniInit } from "./fromIni";
/**
 * @internal
 */
export declare const resolveProfileData: (profileName: string, profiles: ParsedIniData, options: FromIniInit, visitedProfiles?: Record<string, true>, 
/**
 * This override comes from recursive calls only.
 * It is used to flag a recursive profile section
 * that does not have a role_arn, e.g. a credential_source
 * with no role_arn, as part of a larger recursive assume-role
 * call stack, and to re-enter the assume-role resolver function.
 */
isAssumeRoleRecursiveCall?: boolean) => Promise<AwsCredentialIdentity>;

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-ini/dist-types/resolveSsoCredentials.d.ts

```typescript
import type { SsoProfile } from "@aws-sdk/credential-provider-sso";
import type { IniSection, Profile } from "@smithy/types";
import type { FromIniInit } from "./fromIni";
/**
 * @internal
 */
export declare const resolveSsoCredentials: (profile: string, profileData: IniSection, options?: FromIniInit) => Promise<import("@aws-sdk/types").AttributedAwsCredentialIdentity>;
/**
 * @internal
 * duplicated from \@aws-sdk/credential-provider-sso to defer import.
 */
export declare const isSsoProfile: (arg: Profile) => arg is Partial<SsoProfile>;

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-ini/dist-types/resolveStaticCredentials.d.ts

```typescript
import { AwsCredentialIdentity, Profile } from "@smithy/types";
import { FromIniInit } from "./fromIni";
/**
 * @internal
 */
export interface StaticCredsProfile extends Profile {
    aws_access_key_id: string;
    aws_secret_access_key: string;
    aws_session_token?: string;
    aws_credential_scope?: string;
    aws_account_id?: string;
}
/**
 * @internal
 */
export declare const isStaticCredsProfile: (arg: any) => arg is StaticCredsProfile;
/**
 * @internal
 */
export declare const resolveStaticCredentials: (profile: StaticCredsProfile, options?: FromIniInit) => Promise<AwsCredentialIdentity>;

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-ini/dist-types/resolveWebIdentityCredentials.d.ts

```typescript
import { AwsCredentialIdentity, Profile } from "@smithy/types";
import { FromIniInit } from "./fromIni";
/**
 * @internal
 */
export interface WebIdentityProfile extends Profile {
    web_identity_token_file: string;
    role_arn: string;
    role_session_name?: string;
}
/**
 * @internal
 */
export declare const isWebIdentityProfile: (arg: any) => arg is WebIdentityProfile;
/**
 * @internal
 */
export declare const resolveWebIdentityCredentials: (profile: WebIdentityProfile, options: FromIniInit) => Promise<AwsCredentialIdentity>;

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-ini/dist-types/ts3.4/fromIni.d.ts

```typescript
import { AssumeRoleWithWebIdentityParams } from "@aws-sdk/credential-provider-web-identity";
import { CredentialProviderOptions } from "@aws-sdk/types";
import { RuntimeConfigAwsCredentialIdentityProvider } from "@aws-sdk/types";
import { SourceProfileInit } from "@smithy/shared-ini-file-loader";
import { AwsCredentialIdentity, Pluggable } from "@smithy/types";
import { AssumeRoleParams } from "./resolveAssumeRoleCredentials";
export interface FromIniInit
  extends SourceProfileInit,
    CredentialProviderOptions {
  mfaCodeProvider?: (mfaSerial: string) => Promise<string>;
  roleAssumer?: (
    sourceCreds: AwsCredentialIdentity,
    params: AssumeRoleParams
  ) => Promise<AwsCredentialIdentity>;
  roleAssumerWithWebIdentity?: (
    params: AssumeRoleWithWebIdentityParams
  ) => Promise<AwsCredentialIdentity>;
  clientConfig?: any;
  clientPlugins?: Pluggable<any, any>[];
  ignoreCache?: boolean;
}
export declare const fromIni: (
  _init?: FromIniInit
) => RuntimeConfigAwsCredentialIdentityProvider;

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-ini/dist-types/ts3.4/index.d.ts

```typescript
export * from "./fromIni";

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-ini/dist-types/ts3.4/resolveAssumeRoleCredentials.d.ts

```typescript
import { Logger, ParsedIniData } from "@smithy/types";
import { FromIniInit } from "./fromIni";
export interface AssumeRoleParams {
  RoleArn: string;
  RoleSessionName: string;
  ExternalId?: string;
  SerialNumber?: string;
  TokenCode?: string;
  DurationSeconds?: number;
}
export declare const isAssumeRoleProfile: (
  arg: any,
  {
    profile,
    logger,
  }?: {
    profile?: string;
    logger?: Logger;
  }
) => boolean;
export declare const resolveAssumeRoleCredentials: (
  profileName: string,
  profiles: ParsedIniData,
  options: FromIniInit,
  visitedProfiles?: Record<string, true>
) => Promise<import("@aws-sdk/types").AttributedAwsCredentialIdentity>;

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-ini/dist-types/ts3.4/resolveCredentialSource.d.ts

```typescript
import { CredentialProviderOptions } from "@aws-sdk/types";
import { AwsCredentialIdentityProvider, Logger } from "@smithy/types";
export declare const resolveCredentialSource: (
  credentialSource: string,
  profileName: string,
  logger?: Logger
) => (
  options?: CredentialProviderOptions
) => Promise<AwsCredentialIdentityProvider>;

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-ini/dist-types/ts3.4/resolveProcessCredentials.d.ts

```typescript
import { Credentials, Profile } from "@aws-sdk/types";
import { FromIniInit } from "./fromIni";
export interface ProcessProfile extends Profile {
  credential_process: string;
}
export declare const isProcessProfile: (arg: any) => arg is ProcessProfile;
export declare const resolveProcessCredentials: (
  options: FromIniInit,
  profile: string
) => Promise<Credentials>;

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-ini/dist-types/ts3.4/resolveProfileData.d.ts

```typescript
import { AwsCredentialIdentity, ParsedIniData } from "@smithy/types";
import { FromIniInit } from "./fromIni";
export declare const resolveProfileData: (
  profileName: string,
  profiles: ParsedIniData,
  options: FromIniInit,
  visitedProfiles?: Record<string, true>,
  isAssumeRoleRecursiveCall?: boolean
) => Promise<AwsCredentialIdentity>;

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-ini/dist-types/ts3.4/resolveSsoCredentials.d.ts

```typescript
import { SsoProfile } from "@aws-sdk/credential-provider-sso";
import { IniSection, Profile } from "@smithy/types";
import { FromIniInit } from "./fromIni";
export declare const resolveSsoCredentials: (
  profile: string,
  profileData: IniSection,
  options?: FromIniInit
) => Promise<import("@aws-sdk/types").AttributedAwsCredentialIdentity>;
export declare const isSsoProfile: (arg: Profile) => arg is Partial<SsoProfile>;

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-ini/dist-types/ts3.4/resolveStaticCredentials.d.ts

```typescript
import { AwsCredentialIdentity, Profile } from "@smithy/types";
import { FromIniInit } from "./fromIni";
export interface StaticCredsProfile extends Profile {
  aws_access_key_id: string;
  aws_secret_access_key: string;
  aws_session_token?: string;
  aws_credential_scope?: string;
  aws_account_id?: string;
}
export declare const isStaticCredsProfile: (
  arg: any
) => arg is StaticCredsProfile;
export declare const resolveStaticCredentials: (
  profile: StaticCredsProfile,
  options?: FromIniInit
) => Promise<AwsCredentialIdentity>;

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-ini/dist-types/ts3.4/resolveWebIdentityCredentials.d.ts

```typescript
import { AwsCredentialIdentity, Profile } from "@smithy/types";
import { FromIniInit } from "./fromIni";
export interface WebIdentityProfile extends Profile {
  web_identity_token_file: string;
  role_arn: string;
  role_session_name?: string;
}
export declare const isWebIdentityProfile: (
  arg: any
) => arg is WebIdentityProfile;
export declare const resolveWebIdentityCredentials: (
  profile: WebIdentityProfile,
  options: FromIniInit
) => Promise<AwsCredentialIdentity>;

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-ini/package.json

```json
{
  "name": "@aws-sdk/credential-provider-ini",
  "version": "3.911.0",
  "description": "AWS credential provider that sources credentials from ~/.aws/credentials and ~/.aws/config",
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "node ../../scripts/compilation/inline credential-provider-ini",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch",
    "test:integration": "yarn g:vitest run -c vitest.config.integ.mts",
    "test:integration:watch": "yarn g:vitest watch -c vitest.config.integ.mts"
  },
  "keywords": [
    "aws",
    "credentials"
  ],
  "sideEffects": false,
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "dependencies": {
    "@aws-sdk/core": "3.911.0",
    "@aws-sdk/credential-provider-env": "3.911.0",
    "@aws-sdk/credential-provider-http": "3.911.0",
    "@aws-sdk/credential-provider-process": "3.911.0",
    "@aws-sdk/credential-provider-sso": "3.911.0",
    "@aws-sdk/credential-provider-web-identity": "3.911.0",
    "@aws-sdk/nested-clients": "3.911.0",
    "@aws-sdk/types": "3.910.0",
    "@smithy/credential-provider-imds": "^4.2.2",
    "@smithy/property-provider": "^4.2.2",
    "@smithy/shared-ini-file-loader": "^4.3.2",
    "@smithy/types": "^4.7.1",
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "@tsconfig/recommended": "1.0.1",
    "@types/node": "^18.19.69",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typescript": "~5.8.3"
  },
  "types": "./dist-types/index.d.ts",
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/aws/aws-sdk-js-v3/tree/main/packages/credential-provider-ini",
  "repository": {
    "type": "git",
    "url": "https://github.com/aws/aws-sdk-js-v3.git",
    "directory": "packages/credential-provider-ini"
  }
}

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-node/dist-types/defaultProvider.d.ts

```typescript
import type { FromHttpOptions } from "@aws-sdk/credential-provider-http";
import type { FromIniInit } from "@aws-sdk/credential-provider-ini";
import type { FromProcessInit } from "@aws-sdk/credential-provider-process";
import type { FromSSOInit, SsoCredentialsParameters } from "@aws-sdk/credential-provider-sso";
import type { FromTokenFileInit } from "@aws-sdk/credential-provider-web-identity";
import type { RemoteProviderInit } from "@smithy/credential-provider-imds";
import { AwsCredentialIdentity, MemoizedProvider } from "@smithy/types";
/**
 * @public
 */
export type DefaultProviderInit = FromIniInit & FromHttpOptions & RemoteProviderInit & FromProcessInit & (FromSSOInit & Partial<SsoCredentialsParameters>) & FromTokenFileInit;
/**
 * Creates a credential provider that will attempt to find credentials from the
 * following sources (listed in order of precedence):
 *   * Environment variables exposed via `process.env`
 *   * SSO credentials from token cache
 *   * Web identity token credentials
 *   * Shared credentials and config ini files
 *   * The EC2/ECS Instance Metadata Service
 *
 * The default credential provider will invoke one provider at a time and only
 * continue to the next if no credentials have been located. For example, if
 * the process finds values defined via the `AWS_ACCESS_KEY_ID` and
 * `AWS_SECRET_ACCESS_KEY` environment variables, the files at
 * `~/.aws/credentials` and `~/.aws/config` will not be read, nor will any
 * messages be sent to the Instance Metadata Service.
 *
 * @param init                  Configuration that is passed to each individual
 *                              provider
 *
 * @see {@link fromEnv}         The function used to source credentials from
 *                              environment variables.
 * @see {@link fromSSO}         The function used to source credentials from
 *                              resolved SSO token cache.
 * @see {@link fromTokenFile}   The function used to source credentials from
 *                              token file.
 * @see {@link fromIni}         The function used to source credentials from INI
 *                              files.
 * @see {@link fromProcess}     The function used to sources credentials from
 *                              credential_process in INI files.
 * @see {@link fromInstanceMetadata}    The function used to source credentials from the
 *                                      EC2 Instance Metadata Service.
 * @see {@link fromContainerMetadata}   The function used to source credentials from the
 *                                      ECS Container Metadata Service.
 */
export declare const defaultProvider: (init?: DefaultProviderInit) => MemoizedProvider<AwsCredentialIdentity>;
/**
 * @internal
 *
 * @returns credentials have expiration.
 */
export declare const credentialsWillNeedRefresh: (credentials: AwsCredentialIdentity) => boolean;
/**
 * @internal
 *
 * @returns credentials with less than 5 minutes left.
 */
export declare const credentialsTreatedAsExpired: (credentials: AwsCredentialIdentity) => boolean;

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-node/dist-types/index.d.ts

```typescript
export * from "./defaultProvider";

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-node/dist-types/remoteProvider.d.ts

```typescript
import type { FromHttpOptions } from "@aws-sdk/credential-provider-http";
import type { RemoteProviderInit } from "@smithy/credential-provider-imds";
import type { AwsCredentialIdentityProvider } from "@smithy/types";
/**
 * @internal
 */
export declare const ENV_IMDS_DISABLED = "AWS_EC2_METADATA_DISABLED";
/**
 * @internal
 */
export declare const remoteProvider: (init: RemoteProviderInit | FromHttpOptions) => Promise<AwsCredentialIdentityProvider>;

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-node/dist-types/ts3.4/defaultProvider.d.ts

```typescript
import { FromHttpOptions } from "@aws-sdk/credential-provider-http";
import { FromIniInit } from "@aws-sdk/credential-provider-ini";
import { FromProcessInit } from "@aws-sdk/credential-provider-process";
import {
  FromSSOInit,
  SsoCredentialsParameters,
} from "@aws-sdk/credential-provider-sso";
import { FromTokenFileInit } from "@aws-sdk/credential-provider-web-identity";
import { RemoteProviderInit } from "@smithy/credential-provider-imds";
import { AwsCredentialIdentity, MemoizedProvider } from "@smithy/types";
export type DefaultProviderInit = FromIniInit &
  FromHttpOptions &
  RemoteProviderInit &
  FromProcessInit &
  (FromSSOInit & Partial<SsoCredentialsParameters>) &
  FromTokenFileInit;
export declare const defaultProvider: (
  init?: DefaultProviderInit
) => MemoizedProvider<AwsCredentialIdentity>;
export declare const credentialsWillNeedRefresh: (
  credentials: AwsCredentialIdentity
) => boolean;
export declare const credentialsTreatedAsExpired: (
  credentials: AwsCredentialIdentity
) => boolean;

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-node/dist-types/ts3.4/index.d.ts

```typescript
export * from "./defaultProvider";

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-node/dist-types/ts3.4/remoteProvider.d.ts

```typescript
import { FromHttpOptions } from "@aws-sdk/credential-provider-http";
import { RemoteProviderInit } from "@smithy/credential-provider-imds";
import { AwsCredentialIdentityProvider } from "@smithy/types";
export declare const ENV_IMDS_DISABLED = "AWS_EC2_METADATA_DISABLED";
export declare const remoteProvider: (
  init: RemoteProviderInit | FromHttpOptions
) => Promise<AwsCredentialIdentityProvider>;

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-node/package.json

```json
{
  "name": "@aws-sdk/credential-provider-node",
  "version": "3.911.0",
  "description": "AWS credential provider that sources credentials from a Node.JS environment. ",
  "engines": {
    "node": ">=18.0.0"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "node ../../scripts/compilation/inline credential-provider-node",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch",
    "test:integration": "yarn g:vitest run -c vitest.config.integ.mts",
    "test:integration:watch": "yarn g:vitest watch -c vitest.config.integ.mts"
  },
  "keywords": [
    "aws",
    "credentials"
  ],
  "sideEffects": false,
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "dependencies": {
    "@aws-sdk/credential-provider-env": "3.911.0",
    "@aws-sdk/credential-provider-http": "3.911.0",
    "@aws-sdk/credential-provider-ini": "3.911.0",
    "@aws-sdk/credential-provider-process": "3.911.0",
    "@aws-sdk/credential-provider-sso": "3.911.0",
    "@aws-sdk/credential-provider-web-identity": "3.911.0",
    "@aws-sdk/types": "3.910.0",
    "@smithy/credential-provider-imds": "^4.2.2",
    "@smithy/property-provider": "^4.2.2",
    "@smithy/shared-ini-file-loader": "^4.3.2",
    "@smithy/types": "^4.7.1",
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "@tsconfig/recommended": "1.0.1",
    "@types/node": "^18.19.69",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typescript": "~5.8.3"
  },
  "types": "./dist-types/index.d.ts",
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/aws/aws-sdk-js-v3/tree/main/packages/credential-provider-node",
  "repository": {
    "type": "git",
    "url": "https://github.com/aws/aws-sdk-js-v3.git",
    "directory": "packages/credential-provider-node"
  }
}

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-process/dist-types/ProcessCredentials.d.ts

```typescript
/**
 * @internal
 */
export type ProcessCredentials = {
    Version: number;
    AccessKeyId: string;
    SecretAccessKey: string;
    SessionToken?: string;
    Expiration?: number;
    CredentialScope?: string;
    AccountId?: string;
};

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-process/dist-types/fromProcess.d.ts

```typescript
import type { CredentialProviderOptions, RuntimeConfigAwsCredentialIdentityProvider } from "@aws-sdk/types";
import { SourceProfileInit } from "@smithy/shared-ini-file-loader";
/**
 * @internal
 */
export interface FromProcessInit extends SourceProfileInit, CredentialProviderOptions {
}
/**
 * @internal
 *
 * Creates a credential provider that will read from a credential_process specified
 * in ini files.
 */
export declare const fromProcess: (init?: FromProcessInit) => RuntimeConfigAwsCredentialIdentityProvider;

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-process/dist-types/getValidatedProcessCredentials.d.ts

```typescript
import { AwsCredentialIdentity, ParsedIniData } from "@smithy/types";
import { ProcessCredentials } from "./ProcessCredentials";
/**
 * @internal
 */
export declare const getValidatedProcessCredentials: (profileName: string, data: ProcessCredentials, profiles: ParsedIniData) => AwsCredentialIdentity;

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-process/dist-types/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./fromProcess";

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-process/dist-types/resolveProcessCredentials.d.ts

```typescript
import { AwsCredentialIdentity, Logger, ParsedIniData } from "@smithy/types";
/**
 * @internal
 */
export declare const resolveProcessCredentials: (profileName: string, profiles: ParsedIniData, logger?: Logger) => Promise<AwsCredentialIdentity>;

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-process/dist-types/ts3.4/ProcessCredentials.d.ts

```typescript
export type ProcessCredentials = {
  Version: number;
  AccessKeyId: string;
  SecretAccessKey: string;
  SessionToken?: string;
  Expiration?: number;
  CredentialScope?: string;
  AccountId?: string;
};

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-process/dist-types/ts3.4/fromProcess.d.ts

```typescript
import {
  CredentialProviderOptions,
  RuntimeConfigAwsCredentialIdentityProvider,
} from "@aws-sdk/types";
import { SourceProfileInit } from "@smithy/shared-ini-file-loader";
export interface FromProcessInit
  extends SourceProfileInit,
    CredentialProviderOptions {}
export declare const fromProcess: (
  init?: FromProcessInit
) => RuntimeConfigAwsCredentialIdentityProvider;

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-process/dist-types/ts3.4/getValidatedProcessCredentials.d.ts

```typescript
import { AwsCredentialIdentity, ParsedIniData } from "@smithy/types";
import { ProcessCredentials } from "./ProcessCredentials";
export declare const getValidatedProcessCredentials: (
  profileName: string,
  data: ProcessCredentials,
  profiles: ParsedIniData
) => AwsCredentialIdentity;

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-process/dist-types/ts3.4/index.d.ts

```typescript
export * from "./fromProcess";

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-process/dist-types/ts3.4/resolveProcessCredentials.d.ts

```typescript
import { AwsCredentialIdentity, Logger, ParsedIniData } from "@smithy/types";
export declare const resolveProcessCredentials: (
  profileName: string,
  profiles: ParsedIniData,
  logger?: Logger
) => Promise<AwsCredentialIdentity>;

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-process/package.json

```json
{
  "name": "@aws-sdk/credential-provider-process",
  "version": "3.911.0",
  "description": "AWS credential provider that sources credential_process from ~/.aws/credentials and ~/.aws/config",
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "node ../../scripts/compilation/inline credential-provider-process",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch"
  },
  "keywords": [
    "aws",
    "credentials"
  ],
  "sideEffects": false,
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "dependencies": {
    "@aws-sdk/core": "3.911.0",
    "@aws-sdk/types": "3.910.0",
    "@smithy/property-provider": "^4.2.2",
    "@smithy/shared-ini-file-loader": "^4.3.2",
    "@smithy/types": "^4.7.1",
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "@tsconfig/recommended": "1.0.1",
    "@types/node": "^18.19.69",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typescript": "~5.8.3"
  },
  "types": "./dist-types/index.d.ts",
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/aws/aws-sdk-js-v3/tree/main/packages/credential-provider-process",
  "repository": {
    "type": "git",
    "url": "https://github.com/aws/aws-sdk-js-v3.git",
    "directory": "packages/credential-provider-process"
  }
}

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-sso/dist-types/fromSSO.d.ts

```typescript
import type { CredentialProviderOptions, RuntimeConfigAwsCredentialIdentityProvider } from "@aws-sdk/types";
import { SourceProfileInit } from "@smithy/shared-ini-file-loader";
import type { SSOClient, SSOClientConfig } from "./loadSso";
/**
 * @internal
 */
export interface SsoCredentialsParameters {
    /**
     * The URL to the AWS SSO service.
     */
    ssoStartUrl: string;
    /**
     * SSO session identifier.
     * Presence implies usage of the SSOTokenProvider.
     */
    ssoSession?: string;
    /**
     * The ID of the AWS account to use for temporary credentials.
     */
    ssoAccountId: string;
    /**
     * The AWS region to use for temporary credentials.
     */
    ssoRegion: string;
    /**
     * The name of the AWS role to assume.
     */
    ssoRoleName: string;
}
/**
 * @internal
 */
export interface FromSSOInit extends SourceProfileInit, CredentialProviderOptions {
    ssoClient?: SSOClient;
    clientConfig?: SSOClientConfig;
}
/**
 * @internal
 *
 * Creates a credential provider that will read from a credential_process specified
 * in ini files.
 *
 * The SSO credential provider must support both
 *
 * 1. the legacy profile format,
 * @example
 * ```
 * [profile sample-profile]
 * sso_account_id = 012345678901
 * sso_region = us-east-1
 * sso_role_name = SampleRole
 * sso_start_url = https://www.....com/start
 * ```
 *
 * 2. and the profile format for SSO Token Providers.
 * @example
 * ```
 * [profile sso-profile]
 * sso_session = dev
 * sso_account_id = 012345678901
 * sso_role_name = SampleRole
 *
 * [sso-session dev]
 * sso_region = us-east-1
 * sso_start_url = https://www.....com/start
 * ```
 */
export declare const fromSSO: (init?: FromSSOInit & Partial<SsoCredentialsParameters>) => RuntimeConfigAwsCredentialIdentityProvider;

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-sso/dist-types/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./fromSSO";
/**
 * @internal
 */
export * from "./isSsoProfile";
/**
 * @internal
 */
export * from "./types";
/**
 * @internal
 */
export * from "./validateSsoProfile";

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-sso/dist-types/isSsoProfile.d.ts

```typescript
import { Profile } from "@smithy/types";
import { SsoProfile } from "./types";
/**
 * @internal
 */
export declare const isSsoProfile: (arg: Profile) => arg is Partial<SsoProfile>;

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-sso/dist-types/loadSso.d.ts

```typescript
import { GetRoleCredentialsCommand, SSOClient } from "@aws-sdk/client-sso";
export { GetRoleCredentialsCommand, SSOClient };
export type { SSOClientConfig, GetRoleCredentialsCommandOutput } from "@aws-sdk/client-sso";

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-sso/dist-types/resolveSSOCredentials.d.ts

```typescript
import { AwsCredentialIdentity } from "@smithy/types";
import { FromSSOInit, SsoCredentialsParameters } from "./fromSSO";
/**
 * @internal
 */
export declare const resolveSSOCredentials: ({ ssoStartUrl, ssoSession, ssoAccountId, ssoRegion, ssoRoleName, ssoClient, clientConfig, parentClientConfig, profile, filepath, configFilepath, ignoreCache, logger, }: FromSSOInit & SsoCredentialsParameters) => Promise<AwsCredentialIdentity>;

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-sso/dist-types/ts3.4/fromSSO.d.ts

```typescript
import {
  CredentialProviderOptions,
  RuntimeConfigAwsCredentialIdentityProvider,
} from "@aws-sdk/types";
import { SourceProfileInit } from "@smithy/shared-ini-file-loader";
import { SSOClient, SSOClientConfig } from "./loadSso";
export interface SsoCredentialsParameters {
  ssoStartUrl: string;
  ssoSession?: string;
  ssoAccountId: string;
  ssoRegion: string;
  ssoRoleName: string;
}
export interface FromSSOInit
  extends SourceProfileInit,
    CredentialProviderOptions {
  ssoClient?: SSOClient;
  clientConfig?: SSOClientConfig;
}
export declare const fromSSO: (
  init?: FromSSOInit & Partial<SsoCredentialsParameters>
) => RuntimeConfigAwsCredentialIdentityProvider;

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-sso/dist-types/ts3.4/index.d.ts

```typescript
export * from "./fromSSO";
export * from "./isSsoProfile";
export * from "./types";
export * from "./validateSsoProfile";

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-sso/dist-types/ts3.4/isSsoProfile.d.ts

```typescript
import { Profile } from "@smithy/types";
import { SsoProfile } from "./types";
export declare const isSsoProfile: (arg: Profile) => arg is Partial<SsoProfile>;

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-sso/dist-types/ts3.4/loadSso.d.ts

```typescript
import { GetRoleCredentialsCommand, SSOClient } from "@aws-sdk/client-sso";
export { GetRoleCredentialsCommand, SSOClient };
export {
  SSOClientConfig,
  GetRoleCredentialsCommandOutput,
} from "@aws-sdk/client-sso";

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-sso/dist-types/ts3.4/resolveSSOCredentials.d.ts

```typescript
import { AwsCredentialIdentity } from "@smithy/types";
import { FromSSOInit, SsoCredentialsParameters } from "./fromSSO";
export declare const resolveSSOCredentials: ({
  ssoStartUrl,
  ssoSession,
  ssoAccountId,
  ssoRegion,
  ssoRoleName,
  ssoClient,
  clientConfig,
  parentClientConfig,
  profile,
  filepath,
  configFilepath,
  ignoreCache,
  logger,
}: FromSSOInit & SsoCredentialsParameters) => Promise<AwsCredentialIdentity>;

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-sso/dist-types/ts3.4/types.d.ts

```typescript
import { Profile } from "@smithy/types";
export interface SSOToken {
  accessToken: string;
  expiresAt: string;
  region?: string;
  startUrl?: string;
}
export interface SsoProfile extends Profile {
  sso_start_url: string;
  sso_session?: string;
  sso_account_id: string;
  sso_region: string;
  sso_role_name: string;
}

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-sso/dist-types/ts3.4/validateSsoProfile.d.ts

```typescript
import { Logger } from "@smithy/types";
import { SsoProfile } from "./types";
export declare const validateSsoProfile: (
  profile: Partial<SsoProfile>,
  logger?: Logger
) => SsoProfile;

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-sso/dist-types/types.d.ts

```typescript
import { Profile } from "@smithy/types";
/**
 * @internal
 *
 * Cached SSO token retrieved from SSO login flow.
 */
export interface SSOToken {
    accessToken: string;
    expiresAt: string;
    region?: string;
    startUrl?: string;
}
/**
 * @internal
 */
export interface SsoProfile extends Profile {
    sso_start_url: string;
    sso_session?: string;
    sso_account_id: string;
    sso_region: string;
    sso_role_name: string;
}

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-sso/dist-types/validateSsoProfile.d.ts

```typescript
import { Logger } from "@smithy/types";
import { SsoProfile } from "./types";
/**
 * @internal
 */
export declare const validateSsoProfile: (profile: Partial<SsoProfile>, logger?: Logger) => SsoProfile;

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-sso/package.json

```json
{
  "name": "@aws-sdk/credential-provider-sso",
  "version": "3.911.0",
  "description": "AWS credential provider that exchanges a resolved SSO login token file for temporary AWS credentials",
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "node ../../scripts/compilation/inline credential-provider-sso",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch"
  },
  "keywords": [
    "aws",
    "credentials"
  ],
  "sideEffects": false,
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "dependencies": {
    "@aws-sdk/client-sso": "3.911.0",
    "@aws-sdk/core": "3.911.0",
    "@aws-sdk/token-providers": "3.911.0",
    "@aws-sdk/types": "3.910.0",
    "@smithy/property-provider": "^4.2.2",
    "@smithy/shared-ini-file-loader": "^4.3.2",
    "@smithy/types": "^4.7.1",
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "@tsconfig/recommended": "1.0.1",
    "@types/node": "^18.19.69",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typescript": "~5.8.3"
  },
  "types": "./dist-types/index.d.ts",
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/aws/aws-sdk-js-v3/tree/main/packages/credential-provider-sso",
  "repository": {
    "type": "git",
    "url": "https://github.com/aws/aws-sdk-js-v3.git",
    "directory": "packages/credential-provider-sso"
  }
}

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-web-identity/dist-types/fromTokenFile.d.ts

```typescript
import { CredentialProviderOptions } from "@aws-sdk/types";
import type { AwsCredentialIdentityProvider } from "@smithy/types";
import { FromWebTokenInit } from "./fromWebToken";
/**
 * @public
 */
export interface FromTokenFileInit extends Partial<Omit<FromWebTokenInit, "webIdentityToken">>, CredentialProviderOptions {
    /**
     * File location of where the `OIDC` token is stored.
     */
    webIdentityTokenFile?: string;
}
/**
 * @internal
 *
 * Represents OIDC credentials from a file on disk.
 */
export declare const fromTokenFile: (init?: FromTokenFileInit) => AwsCredentialIdentityProvider;

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-web-identity/dist-types/fromWebToken.d.ts

```typescript
import type { CredentialProviderOptions, RuntimeConfigAwsCredentialIdentityProvider } from "@aws-sdk/types";
import type { AwsCredentialIdentity, Pluggable } from "@smithy/types";
/**
 * @public
 */
export interface AssumeRoleWithWebIdentityParams {
    /**
     * <p>The Amazon Resource Name (ARN) of the role that the caller is assuming.</p>
     */
    RoleArn: string;
    /**
     * <p>An identifier for the assumed role session. Typically, you pass the name or identifier
     *          that is associated with the user who is using your application. That way, the temporary
     *          security credentials that your application will use are associated with that user. This
     *          session name is included as part of the ARN and assumed role ID in the
     *             <code>AssumedRoleUser</code> response element.</p>
     *          <p>The regex used to validate this parameter is a string of characters
     *     consisting of upper- and lower-case alphanumeric characters with no spaces. You can
     *     also include underscores or any of the following characters: =,.@-</p>
     */
    RoleSessionName: string;
    /**
     * <p>The OAuth 2.0 access token or OpenID Connect ID token that is provided by the identity
     *          provider. Your application must get this token by authenticating the user who is using your
     *          application with a web identity provider before the application makes an
     *             <code>AssumeRoleWithWebIdentity</code> call. </p>
     */
    WebIdentityToken: string;
    /**
     * <p>The fully qualified host component of the domain name of the identity provider.</p>
     *          <p>Specify this value only for OAuth 2.0 access tokens. Currently
     *             <code>www.amazon.com</code> and <code>graph.facebook.com</code> are the only supported
     *          identity providers for OAuth 2.0 access tokens. Do not include URL schemes and port
     *          numbers.</p>
     *          <p>Do not specify this value for OpenID Connect ID tokens.</p>
     */
    ProviderId?: string;
    /**
     * <p>The Amazon Resource Names (ARNs) of the IAM managed policies that you want to use as
     *          managed session policies. The policies must exist in the same account as the role.</p>
     *          <p>This parameter is optional. You can provide up to 10 managed policy ARNs. However, the
     *          plain text that you use for both inline and managed session policies can't exceed 2,048
     *          characters. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs) and AWS
     *             Service Namespaces</a> in the AWS General Reference.</p>
     *          <note>
     *             <p>An AWS conversion compresses the passed session policies and session tags into a
     *             packed binary format that has a separate limit. Your request can fail for this limit
     *             even if your plain text meets the other requirements. The <code>PackedPolicySize</code>
     *             response element indicates by percentage how close the policies and tags for your
     *             request are to the upper size limit.
     *             </p>
     *          </note>
     *
     *          <p>Passing policies to this operation returns new
     *          temporary credentials. The resulting session's permissions are the intersection of the
     *          role's identity-based policy and the session policies. You can use the role's temporary
     *          credentials in subsequent AWS API calls to access resources in the account that owns
     *          the role. You cannot use session policies to grant more permissions than those allowed
     *          by the identity-based policy of the role that is being assumed. For more information, see
     *             <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">Session
     *             Policies</a> in the <i>IAM User Guide</i>.</p>
     */
    PolicyArns?: {
        arn?: string;
    }[];
    /**
     * <p>An IAM policy in JSON format that you want to use as an inline session policy.</p>
     *          <p>This parameter is optional. Passing policies to this operation returns new
     *          temporary credentials. The resulting session's permissions are the intersection of the
     *          role's identity-based policy and the session policies. You can use the role's temporary
     *          credentials in subsequent AWS API calls to access resources in the account that owns
     *          the role. You cannot use session policies to grant more permissions than those allowed
     *          by the identity-based policy of the role that is being assumed. For more information, see
     *             <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">Session
     *             Policies</a> in the <i>IAM User Guide</i>.</p>
     *          <p>The plain text that you use for both inline and managed session policies can't exceed
     *          2,048 characters. The JSON policy characters can be any ASCII character from the space
     *          character to the end of the valid character list (\u0020 through \u00FF). It can also
     *          include the tab (\u0009), linefeed (\u000A), and carriage return (\u000D)
     *          characters.</p>
     *          <note>
     *             <p>An AWS conversion compresses the passed session policies and session tags into a
     *             packed binary format that has a separate limit. Your request can fail for this limit
     *             even if your plain text meets the other requirements. The <code>PackedPolicySize</code>
     *             response element indicates by percentage how close the policies and tags for your
     *             request are to the upper size limit.
     *             </p>
     *          </note>
     */
    Policy?: string;
    /**
     * <p>The duration, in seconds, of the role session. The value can range from 900 seconds (15
     *          minutes) up to the maximum session duration setting for the role. This setting can have a
     *          value from 1 hour to 12 hours. If you specify a value higher than this setting, the
     *          operation fails. For example, if you specify a session duration of 12 hours, but your
     *          administrator set the maximum session duration to 6 hours, your operation fails. To learn
     *          how to view the maximum value for your role, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use.html#id_roles_use_view-role-max-session">View the
     *             Maximum Session Duration Setting for a Role</a> in the
     *             <i>IAM User Guide</i>.</p>
     *          <p>By default, the value is set to <code>3600</code> seconds. </p>
     *          <note>
     *             <p>The <code>DurationSeconds</code> parameter is separate from the duration of a console
     *             session that you might request using the returned credentials. The request to the
     *             federation endpoint for a console sign-in token takes a <code>SessionDuration</code>
     *             parameter that specifies the maximum length of the console session. For more
     *             information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_enable-console-custom-url.html">Creating a URL
     *                that Enables Federated Users to Access the AWS Management Console</a> in the
     *                <i>IAM User Guide</i>.</p>
     *          </note>
     */
    DurationSeconds?: number;
}
type LowerCaseKey<T> = {
    [K in keyof T as `${Uncapitalize<string & K>}`]: T[K];
};
/**
 * @public
 */
export interface FromWebTokenInit extends Omit<LowerCaseKey<AssumeRoleWithWebIdentityParams>, "roleSessionName">, CredentialProviderOptions {
    /**
     * The IAM session name used to distinguish sessions.
     */
    roleSessionName?: string;
    /**
     * A function that assumes a role with web identity and returns a promise fulfilled with
     * credentials for the assumed role.
     *
     * @param params input parameter of sts:AssumeRoleWithWebIdentity API.
     */
    roleAssumerWithWebIdentity?: (params: AssumeRoleWithWebIdentityParams) => Promise<AwsCredentialIdentity>;
    /**
     * STSClientConfig to be used for creating STS Client for assuming role.
     * @internal
     */
    clientConfig?: any;
    /**
     * @internal
     */
    clientPlugins?: Pluggable<any, any>[];
}
/**
 * @internal
 */
export declare const fromWebToken: (init: FromWebTokenInit) => RuntimeConfigAwsCredentialIdentityProvider;
export {};

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-web-identity/dist-types/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./fromTokenFile";
/**
 * @internal
 */
export * from "./fromWebToken";

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-web-identity/dist-types/ts3.4/fromTokenFile.d.ts

```typescript
import { CredentialProviderOptions } from "@aws-sdk/types";
import { AwsCredentialIdentityProvider } from "@smithy/types";
import { FromWebTokenInit } from "./fromWebToken";
export interface FromTokenFileInit
  extends Partial<
      Pick<
        FromWebTokenInit,
        Exclude<keyof FromWebTokenInit, "webIdentityToken">
      >
    >,
    CredentialProviderOptions {
  webIdentityTokenFile?: string;
}
export declare const fromTokenFile: (
  init?: FromTokenFileInit
) => AwsCredentialIdentityProvider;

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-web-identity/dist-types/ts3.4/fromWebToken.d.ts

```typescript
import {
  CredentialProviderOptions,
  RuntimeConfigAwsCredentialIdentityProvider,
} from "@aws-sdk/types";
import { AwsCredentialIdentity, Pluggable } from "@smithy/types";
export interface AssumeRoleWithWebIdentityParams {
  RoleArn: string;
  RoleSessionName: string;
  WebIdentityToken: string;
  ProviderId?: string;
  PolicyArns?: {
    arn?: string;
  }[];
  Policy?: string;
  DurationSeconds?: number;
}
type LowerCaseKey<T> = {
  [K in keyof T as `${Uncapitalize<string & K>}`]: T[K];
};
export interface FromWebTokenInit
  extends Pick<
      LowerCaseKey<AssumeRoleWithWebIdentityParams>,
      Exclude<
        keyof LowerCaseKey<AssumeRoleWithWebIdentityParams>,
        "roleSessionName"
      >
    >,
    CredentialProviderOptions {
  roleSessionName?: string;
  roleAssumerWithWebIdentity?: (
    params: AssumeRoleWithWebIdentityParams
  ) => Promise<AwsCredentialIdentity>;
  clientConfig?: any;
  clientPlugins?: Pluggable<any, any>[];
}
export declare const fromWebToken: (
  init: FromWebTokenInit
) => RuntimeConfigAwsCredentialIdentityProvider;
export {};

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-web-identity/dist-types/ts3.4/index.d.ts

```typescript
export * from "./fromTokenFile";
export * from "./fromWebToken";

```

## ./lib/lambda/node_modules/@aws-sdk/credential-provider-web-identity/package.json

```json
{
  "name": "@aws-sdk/credential-provider-web-identity",
  "version": "3.911.0",
  "description": "AWS credential provider that calls STS assumeRole for temporary AWS credentials",
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "node ../../scripts/compilation/inline credential-provider-web-identity",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch"
  },
  "browser": {
    "./dist-cjs/fromTokenFile": false,
    "./dist-es/fromTokenFile": false
  },
  "react-native": {
    "./dist-es/fromTokenFile": false,
    "./dist-cjs/fromTokenFile": false
  },
  "keywords": [
    "aws",
    "credentials"
  ],
  "sideEffects": false,
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "dependencies": {
    "@aws-sdk/core": "3.911.0",
    "@aws-sdk/nested-clients": "3.911.0",
    "@aws-sdk/types": "3.910.0",
    "@smithy/property-provider": "^4.2.2",
    "@smithy/shared-ini-file-loader": "^4.3.2",
    "@smithy/types": "^4.7.1",
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "@tsconfig/recommended": "1.0.1",
    "@types/node": "^18.19.69",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typescript": "~5.8.3"
  },
  "types": "./dist-types/index.d.ts",
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/aws/aws-sdk-js-v3/tree/main/packages/credential-provider-web-identity",
  "repository": {
    "type": "git",
    "url": "https://github.com/aws/aws-sdk-js-v3.git",
    "directory": "packages/credential-provider-web-identity"
  }
}

```

## ./lib/lambda/node_modules/@aws-sdk/endpoint-cache/dist-types/Endpoint.d.ts

```typescript
/**
 * @internal
 */
export interface Endpoint {
    /**
     * <p>An endpoint address.</p>
     */
    Address: string;
    /**
     * <p>The TTL for the endpoint, in minutes.</p>
     */
    CachePeriodInMinutes: number;
}

```

## ./lib/lambda/node_modules/@aws-sdk/endpoint-cache/dist-types/EndpointCache.d.ts

```typescript
import { Endpoint } from "./Endpoint";
/**
 * @internal
 */
export interface EndpointWithExpiry extends Pick<Endpoint, "Address"> {
    Expires: number;
}
/**
 * @internal
 */
export declare class EndpointCache {
    private readonly cache;
    constructor(capacity: number);
    /**
     * Returns an un-expired endpoint for the given key.
     *
     * @param endpointsWithExpiry
     * @returns
     */
    getEndpoint(key: string): string | undefined;
    /**
     * Returns un-expired endpoints for the given key.
     *
     * @param key
     * @returns
     */
    get(key: string): EndpointWithExpiry[] | undefined;
    /**
     * Stores the endpoints passed for the key in cache.
     * If not defined, uses empty string for the Address in endpoint.
     * If not defined, uses one minute for CachePeriodInMinutes in endpoint.
     * Stores milliseconds elapsed since the UNIX epoch in Expires param based
     * on value provided in CachePeriodInMinutes.
     *
     * @param key
     * @param endpoints
     */
    set(key: string, endpoints: Endpoint[]): void;
    /**
     * Deletes the value for the given key in the cache.
     *
     * @param {string} key
     */
    delete(key: string): void;
    /**
     * Checks whether the key exists in cache.
     *
     * @param {string} key
     * @returns {boolean}
     */
    has(key: string): boolean;
    /**
     * Clears the cache.
     */
    clear(): void;
}

```

## ./lib/lambda/node_modules/@aws-sdk/endpoint-cache/dist-types/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./Endpoint";
/**
 * @internal
 */
export * from "./EndpointCache";

```

## ./lib/lambda/node_modules/@aws-sdk/endpoint-cache/dist-types/ts3.4/Endpoint.d.ts

```typescript
export interface Endpoint {
  Address: string;
  CachePeriodInMinutes: number;
}

```

## ./lib/lambda/node_modules/@aws-sdk/endpoint-cache/dist-types/ts3.4/EndpointCache.d.ts

```typescript
import { Endpoint } from "./Endpoint";
export interface EndpointWithExpiry extends Pick<Endpoint, "Address"> {
  Expires: number;
}
export declare class EndpointCache {
  private readonly cache;
  constructor(capacity: number);
  getEndpoint(key: string): string | undefined;
  get(key: string): EndpointWithExpiry[] | undefined;
  set(key: string, endpoints: Endpoint[]): void;
  delete(key: string): void;
  has(key: string): boolean;
  clear(): void;
}

```

## ./lib/lambda/node_modules/@aws-sdk/endpoint-cache/dist-types/ts3.4/index.d.ts

```typescript
export * from "./Endpoint";
export * from "./EndpointCache";

```

## ./lib/lambda/node_modules/@aws-sdk/endpoint-cache/package.json

```json
{
  "name": "@aws-sdk/endpoint-cache",
  "version": "3.893.0",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "node ../../scripts/compilation/inline endpoint-cache",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch"
  },
  "sideEffects": false,
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "dependencies": {
    "mnemonist": "0.38.3",
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "@tsconfig/recommended": "1.0.1",
    "@types/node": "^18.19.69",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typescript": "~5.8.3"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/aws/aws-sdk-js-v3/tree/main/packages/endpoint-cache",
  "repository": {
    "type": "git",
    "url": "https://github.com/aws/aws-sdk-js-v3.git",
    "directory": "packages/endpoint-cache"
  }
}

```

## ./lib/lambda/node_modules/@aws-sdk/lib-dynamodb/dist-types/DynamoDBDocument.d.ts

```typescript
import { DynamoDBClient } from "@aws-sdk/client-dynamodb";
import { HttpHandlerOptions as __HttpHandlerOptions } from "@smithy/types";
import { BatchExecuteStatementCommandInput, BatchExecuteStatementCommandOutput } from "./commands/BatchExecuteStatementCommand";
import { BatchGetCommandInput, BatchGetCommandOutput } from "./commands/BatchGetCommand";
import { BatchWriteCommandInput, BatchWriteCommandOutput } from "./commands/BatchWriteCommand";
import { DeleteCommandInput, DeleteCommandOutput } from "./commands/DeleteCommand";
import { ExecuteStatementCommandInput, ExecuteStatementCommandOutput } from "./commands/ExecuteStatementCommand";
import { ExecuteTransactionCommandInput, ExecuteTransactionCommandOutput } from "./commands/ExecuteTransactionCommand";
import { GetCommandInput, GetCommandOutput } from "./commands/GetCommand";
import { PutCommandInput, PutCommandOutput } from "./commands/PutCommand";
import { QueryCommandInput, QueryCommandOutput } from "./commands/QueryCommand";
import { ScanCommandInput, ScanCommandOutput } from "./commands/ScanCommand";
import { TransactGetCommandInput, TransactGetCommandOutput } from "./commands/TransactGetCommand";
import { TransactWriteCommandInput, TransactWriteCommandOutput } from "./commands/TransactWriteCommand";
import { UpdateCommandInput, UpdateCommandOutput } from "./commands/UpdateCommand";
import { DynamoDBDocumentClient, TranslateConfig } from "./DynamoDBDocumentClient";
/**
 * The document client simplifies working with items in Amazon DynamoDB by
 * abstracting away the notion of attribute values. This abstraction annotates native
 * JavaScript types supplied as input parameters, as well as converts annotated
 * response data to native JavaScript types.
 *
 * ## Marshalling Input and Unmarshalling Response Data
 *
 * The document client affords developers the use of native JavaScript types
 * instead of `AttributeValue`s to simplify the JavaScript development
 * experience with Amazon DynamoDB. JavaScript objects passed in as parameters
 * are marshalled into `AttributeValue` shapes required by Amazon DynamoDB.
 * Responses from DynamoDB are unmarshalled into plain JavaScript objects
 * by the `DocumentClient`. The `DocumentClient` does not accept
 * `AttributeValue`s in favor of native JavaScript types.
 *
 * |          JavaScript Type          | DynamoDB AttributeValue |
 * | :-------------------------------: | ----------------------- |
 * |              String               | S                       |
 * |          Number / BigInt          | N                       |
 * |              Boolean              | BOOL                    |
 * |               null                | NULL                    |
 * |               Array               | L                       |
 * |              Object               | M                       |
 * |   Set\<Uint8Array, Blob, ...\>    | BS                      |
 * |       Set\<Number, BigInt\>       | NS                      |
 * |           Set\<String\>           | SS                      |
 * | Uint8Array, Buffer, File, Blob... | B                       |
 *
 * ### Example
 *
 * Here is an example list which is sent to DynamoDB client in an operation:
 *
 * ```json
 * { "L": [{ "NULL": true }, { "BOOL": false }, { "N": 1 }, { "S": "two" }] }
 * ```
 *
 * The DynamoDB document client abstracts the attribute values as follows in
 * both input and output:
 *
 * ```json
 * [null, false, 1, "two"]
 * ```
 *
 * @see {@link https://www.npmjs.com/package/@aws-sdk/client-dynamodb | @aws-sdk/client-dynamodb}
 */
export declare class DynamoDBDocument extends DynamoDBDocumentClient {
    static from(client: DynamoDBClient, translateConfig?: TranslateConfig): DynamoDBDocument;
    /**
     * Accepts native JavaScript types instead of `AttributeValue`s, and calls
     * BatchExecuteStatementCommand operation from {@link @aws-sdk/client-dynamodb#BatchExecuteStatementCommand}.
     *
     * JavaScript objects passed in as parameters are marshalled into `AttributeValue` shapes
     * required by Amazon DynamoDB. Responses from DynamoDB are unmarshalled into plain JavaScript objects.
     */
    batchExecuteStatement(args: BatchExecuteStatementCommandInput, options?: __HttpHandlerOptions): Promise<BatchExecuteStatementCommandOutput>;
    batchExecuteStatement(args: BatchExecuteStatementCommandInput, cb: (err: any, data?: BatchExecuteStatementCommandOutput) => void): void;
    batchExecuteStatement(args: BatchExecuteStatementCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: BatchExecuteStatementCommandOutput) => void): void;
    /**
     * Accepts native JavaScript types instead of `AttributeValue`s, and calls
     * BatchGetItemCommand operation from {@link @aws-sdk/client-dynamodb#BatchGetItemCommand}.
     *
     * JavaScript objects passed in as parameters are marshalled into `AttributeValue` shapes
     * required by Amazon DynamoDB. Responses from DynamoDB are unmarshalled into plain JavaScript objects.
     */
    batchGet(args: BatchGetCommandInput, options?: __HttpHandlerOptions): Promise<BatchGetCommandOutput>;
    batchGet(args: BatchGetCommandInput, cb: (err: any, data?: BatchGetCommandOutput) => void): void;
    batchGet(args: BatchGetCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: BatchGetCommandOutput) => void): void;
    /**
     * Accepts native JavaScript types instead of `AttributeValue`s, and calls
     * BatchWriteItemCommand operation from {@link @aws-sdk/client-dynamodb#BatchWriteItemCommand}.
     *
     * JavaScript objects passed in as parameters are marshalled into `AttributeValue` shapes
     * required by Amazon DynamoDB. Responses from DynamoDB are unmarshalled into plain JavaScript objects.
     */
    batchWrite(args: BatchWriteCommandInput, options?: __HttpHandlerOptions): Promise<BatchWriteCommandOutput>;
    batchWrite(args: BatchWriteCommandInput, cb: (err: any, data?: BatchWriteCommandOutput) => void): void;
    batchWrite(args: BatchWriteCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: BatchWriteCommandOutput) => void): void;
    /**
     * Accepts native JavaScript types instead of `AttributeValue`s, and calls
     * DeleteItemCommand operation from {@link @aws-sdk/client-dynamodb#DeleteItemCommand}.
     *
     * JavaScript objects passed in as parameters are marshalled into `AttributeValue` shapes
     * required by Amazon DynamoDB. Responses from DynamoDB are unmarshalled into plain JavaScript objects.
     */
    delete(args: DeleteCommandInput, options?: __HttpHandlerOptions): Promise<DeleteCommandOutput>;
    delete(args: DeleteCommandInput, cb: (err: any, data?: DeleteCommandOutput) => void): void;
    delete(args: DeleteCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: DeleteCommandOutput) => void): void;
    /**
     * Accepts native JavaScript types instead of `AttributeValue`s, and calls
     * ExecuteStatementCommand operation from {@link @aws-sdk/client-dynamodb#ExecuteStatementCommand}.
     *
     * JavaScript objects passed in as parameters are marshalled into `AttributeValue` shapes
     * required by Amazon DynamoDB. Responses from DynamoDB are unmarshalled into plain JavaScript objects.
     */
    executeStatement(args: ExecuteStatementCommandInput, options?: __HttpHandlerOptions): Promise<ExecuteStatementCommandOutput>;
    executeStatement(args: ExecuteStatementCommandInput, cb: (err: any, data?: ExecuteStatementCommandOutput) => void): void;
    executeStatement(args: ExecuteStatementCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ExecuteStatementCommandOutput) => void): void;
    /**
     * Accepts native JavaScript types instead of `AttributeValue`s, and calls
     * ExecuteTransactionCommand operation from {@link @aws-sdk/client-dynamodb#ExecuteTransactionCommand}.
     *
     * JavaScript objects passed in as parameters are marshalled into `AttributeValue` shapes
     * required by Amazon DynamoDB. Responses from DynamoDB are unmarshalled into plain JavaScript objects.
     */
    executeTransaction(args: ExecuteTransactionCommandInput, options?: __HttpHandlerOptions): Promise<ExecuteTransactionCommandOutput>;
    executeTransaction(args: ExecuteTransactionCommandInput, cb: (err: any, data?: ExecuteTransactionCommandOutput) => void): void;
    executeTransaction(args: ExecuteTransactionCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ExecuteTransactionCommandOutput) => void): void;
    /**
     * Accepts native JavaScript types instead of `AttributeValue`s, and calls
     * GetItemCommand operation from {@link @aws-sdk/client-dynamodb#GetItemCommand}.
     *
     * JavaScript objects passed in as parameters are marshalled into `AttributeValue` shapes
     * required by Amazon DynamoDB. Responses from DynamoDB are unmarshalled into plain JavaScript objects.
     */
    get(args: GetCommandInput, options?: __HttpHandlerOptions): Promise<GetCommandOutput>;
    get(args: GetCommandInput, cb: (err: any, data?: GetCommandOutput) => void): void;
    get(args: GetCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: GetCommandOutput) => void): void;
    /**
     * Accepts native JavaScript types instead of `AttributeValue`s, and calls
     * PutItemCommand operation from {@link @aws-sdk/client-dynamodb#PutItemCommand}.
     *
     * JavaScript objects passed in as parameters are marshalled into `AttributeValue` shapes
     * required by Amazon DynamoDB. Responses from DynamoDB are unmarshalled into plain JavaScript objects.
     */
    put(args: PutCommandInput, options?: __HttpHandlerOptions): Promise<PutCommandOutput>;
    put(args: PutCommandInput, cb: (err: any, data?: PutCommandOutput) => void): void;
    put(args: PutCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: PutCommandOutput) => void): void;
    /**
     * Accepts native JavaScript types instead of `AttributeValue`s, and calls
     * QueryCommand operation from {@link @aws-sdk/client-dynamodb#QueryCommand}.
     *
     * JavaScript objects passed in as parameters are marshalled into `AttributeValue` shapes
     * required by Amazon DynamoDB. Responses from DynamoDB are unmarshalled into plain JavaScript objects.
     */
    query(args: QueryCommandInput, options?: __HttpHandlerOptions): Promise<QueryCommandOutput>;
    query(args: QueryCommandInput, cb: (err: any, data?: QueryCommandOutput) => void): void;
    query(args: QueryCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: QueryCommandOutput) => void): void;
    /**
     * Accepts native JavaScript types instead of `AttributeValue`s, and calls
     * ScanCommand operation from {@link @aws-sdk/client-dynamodb#ScanCommand}.
     *
     * JavaScript objects passed in as parameters are marshalled into `AttributeValue` shapes
     * required by Amazon DynamoDB. Responses from DynamoDB are unmarshalled into plain JavaScript objects.
     */
    scan(args: ScanCommandInput, options?: __HttpHandlerOptions): Promise<ScanCommandOutput>;
    scan(args: ScanCommandInput, cb: (err: any, data?: ScanCommandOutput) => void): void;
    scan(args: ScanCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: ScanCommandOutput) => void): void;
    /**
     * Accepts native JavaScript types instead of `AttributeValue`s, and calls
     * TransactGetItemsCommand operation from {@link @aws-sdk/client-dynamodb#TransactGetItemsCommand}.
     *
     * JavaScript objects passed in as parameters are marshalled into `AttributeValue` shapes
     * required by Amazon DynamoDB. Responses from DynamoDB are unmarshalled into plain JavaScript objects.
     */
    transactGet(args: TransactGetCommandInput, options?: __HttpHandlerOptions): Promise<TransactGetCommandOutput>;
    transactGet(args: TransactGetCommandInput, cb: (err: any, data?: TransactGetCommandOutput) => void): void;
    transactGet(args: TransactGetCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: TransactGetCommandOutput) => void): void;
    /**
     * Accepts native JavaScript types instead of `AttributeValue`s, and calls
     * TransactWriteItemsCommand operation from {@link @aws-sdk/client-dynamodb#TransactWriteItemsCommand}.
     *
     * JavaScript objects passed in as parameters are marshalled into `AttributeValue` shapes
     * required by Amazon DynamoDB. Responses from DynamoDB are unmarshalled into plain JavaScript objects.
     */
    transactWrite(args: TransactWriteCommandInput, options?: __HttpHandlerOptions): Promise<TransactWriteCommandOutput>;
    transactWrite(args: TransactWriteCommandInput, cb: (err: any, data?: TransactWriteCommandOutput) => void): void;
    transactWrite(args: TransactWriteCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: TransactWriteCommandOutput) => void): void;
    /**
     * Accepts native JavaScript types instead of `AttributeValue`s, and calls
     * UpdateItemCommand operation from {@link @aws-sdk/client-dynamodb#UpdateItemCommand}.
     *
     * JavaScript objects passed in as parameters are marshalled into `AttributeValue` shapes
     * required by Amazon DynamoDB. Responses from DynamoDB are unmarshalled into plain JavaScript objects.
     */
    update(args: UpdateCommandInput, options?: __HttpHandlerOptions): Promise<UpdateCommandOutput>;
    update(args: UpdateCommandInput, cb: (err: any, data?: UpdateCommandOutput) => void): void;
    update(args: UpdateCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: UpdateCommandOutput) => void): void;
}

```

## ./lib/lambda/node_modules/@aws-sdk/lib-dynamodb/dist-types/DynamoDBDocumentClient.d.ts

```typescript
import { DynamoDBClient, DynamoDBClientResolvedConfig, ServiceInputTypes as __ServiceInputTypes, ServiceOutputTypes as __ServiceOutputTypes } from "@aws-sdk/client-dynamodb";
import { marshallOptions, unmarshallOptions } from "@aws-sdk/util-dynamodb";
import { Client as __Client } from "@smithy/smithy-client";
import { HttpHandlerOptions as __HttpHandlerOptions } from "@smithy/types";
import { BatchExecuteStatementCommandInput, BatchExecuteStatementCommandOutput } from "./commands/BatchExecuteStatementCommand";
import { BatchGetCommandInput, BatchGetCommandOutput } from "./commands/BatchGetCommand";
import { BatchWriteCommandInput, BatchWriteCommandOutput } from "./commands/BatchWriteCommand";
import { DeleteCommandInput, DeleteCommandOutput } from "./commands/DeleteCommand";
import { ExecuteStatementCommandInput, ExecuteStatementCommandOutput } from "./commands/ExecuteStatementCommand";
import { ExecuteTransactionCommandInput, ExecuteTransactionCommandOutput } from "./commands/ExecuteTransactionCommand";
import { GetCommandInput, GetCommandOutput } from "./commands/GetCommand";
import { PutCommandInput, PutCommandOutput } from "./commands/PutCommand";
import { QueryCommandInput, QueryCommandOutput } from "./commands/QueryCommand";
import { ScanCommandInput, ScanCommandOutput } from "./commands/ScanCommand";
import { TransactGetCommandInput, TransactGetCommandOutput } from "./commands/TransactGetCommand";
import { TransactWriteCommandInput, TransactWriteCommandOutput } from "./commands/TransactWriteCommand";
import { UpdateCommandInput, UpdateCommandOutput } from "./commands/UpdateCommand";
/**
 * @public
 */
export { __Client };
/**
 * @public
 */
export type ServiceInputTypes = __ServiceInputTypes | BatchExecuteStatementCommandInput | BatchGetCommandInput | BatchWriteCommandInput | DeleteCommandInput | ExecuteStatementCommandInput | ExecuteTransactionCommandInput | GetCommandInput | PutCommandInput | QueryCommandInput | ScanCommandInput | TransactGetCommandInput | TransactWriteCommandInput | UpdateCommandInput;
/**
 * @public
 */
export type ServiceOutputTypes = __ServiceOutputTypes | BatchExecuteStatementCommandOutput | BatchGetCommandOutput | BatchWriteCommandOutput | DeleteCommandOutput | ExecuteStatementCommandOutput | ExecuteTransactionCommandOutput | GetCommandOutput | PutCommandOutput | QueryCommandOutput | ScanCommandOutput | TransactGetCommandOutput | TransactWriteCommandOutput | UpdateCommandOutput;
/**
 * @public
 */
export type TranslateConfig = {
    marshallOptions?: marshallOptions;
    unmarshallOptions?: unmarshallOptions;
};
/**
 * @public
 */
export type DynamoDBDocumentClientResolvedConfig = DynamoDBClientResolvedConfig & {
    translateConfig?: TranslateConfig;
};
/**
 * The document client simplifies working with items in Amazon DynamoDB by
 * abstracting away the notion of attribute values. This abstraction annotates native
 * JavaScript types supplied as input parameters, as well as converts annotated
 * response data to native JavaScript types.
 *
 * ## Marshalling Input and Unmarshalling Response Data
 *
 * The document client affords developers the use of native JavaScript types
 * instead of `AttributeValue`s to simplify the JavaScript development
 * experience with Amazon DynamoDB. JavaScript objects passed in as parameters
 * are marshalled into `AttributeValue` shapes required by Amazon DynamoDB.
 * Responses from DynamoDB are unmarshalled into plain JavaScript objects
 * by the `DocumentClient`. The `DocumentClient` does not accept
 * `AttributeValue`s in favor of native JavaScript types.
 *
 * |          JavaScript Type          | DynamoDB AttributeValue |
 * | :-------------------------------: | ----------------------- |
 * |              String               | S                       |
 * |          Number / BigInt          | N                       |
 * |              Boolean              | BOOL                    |
 * |               null                | NULL                    |
 * |               Array               | L                       |
 * |              Object               | M                       |
 * |   Set\<Uint8Array, Blob, ...\>    | BS                      |
 * |       Set\<Number, BigInt\>       | NS                      |
 * |           Set\<String\>           | SS                      |
 * | Uint8Array, Buffer, File, Blob... | B                       |
 *
 * ### Example
 *
 * Here is an example list which is sent to DynamoDB client in an operation:
 *
 * ```json
 * { "L": [{ "NULL": true }, { "BOOL": false }, { "N": 1 }, { "S": "two" }] }
 * ```
 *
 * The DynamoDB document client abstracts the attribute values as follows in
 * both input and output:
 *
 * ```json
 * [null, false, 1, "two"]
 * ```
 *
 * @see {@link https://www.npmjs.com/package/@aws-sdk/client-dynamodb | @aws-sdk/client-dynamodb}
 *
 * @public
 */
export declare class DynamoDBDocumentClient extends __Client<__HttpHandlerOptions, ServiceInputTypes, ServiceOutputTypes, DynamoDBDocumentClientResolvedConfig> {
    readonly config: DynamoDBDocumentClientResolvedConfig;
    protected constructor(client: DynamoDBClient, translateConfig?: TranslateConfig);
    static from(client: DynamoDBClient, translateConfig?: TranslateConfig): DynamoDBDocumentClient;
    destroy(): void;
}

```

## ./lib/lambda/node_modules/@aws-sdk/lib-dynamodb/dist-types/baseCommand/DynamoDBDocumentClientCommand.d.ts

```typescript
import { Command as $Command } from "@smithy/smithy-client";
import { MiddlewareStack } from "@smithy/types";
import { KeyNodeChildren } from "../commands/utils";
import { DynamoDBDocumentClientResolvedConfig } from "../DynamoDBDocumentClient";
/**
 * Base class for Commands in lib-dynamodb used to pass middleware to
 * the underlying DynamoDBClient Commands.
 *
 * @public
 */
export declare abstract class DynamoDBDocumentClientCommand<Input extends object, Output extends object, BaseInput extends object, BaseOutput extends object, ResolvedClientConfiguration> extends $Command<Input | BaseInput, Output | BaseOutput, ResolvedClientConfiguration> {
    protected abstract readonly inputKeyNodes: KeyNodeChildren;
    protected abstract readonly outputKeyNodes: KeyNodeChildren;
    protected abstract clientCommand: $Command<Input | BaseInput, Output | BaseOutput, ResolvedClientConfiguration>;
    abstract middlewareStack: MiddlewareStack<Input | BaseInput, Output | BaseOutput>;
    protected addMarshallingMiddleware(configuration: DynamoDBDocumentClientResolvedConfig): void;
}

```

## ./lib/lambda/node_modules/@aws-sdk/lib-dynamodb/dist-types/commands/BatchExecuteStatementCommand.d.ts

```typescript
import { BatchExecuteStatementCommand as __BatchExecuteStatementCommand } from "@aws-sdk/client-dynamodb";
import { Command as $Command } from "@smithy/smithy-client";
import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MiddlewareStack } from "@smithy/types";
import { DynamoDBDocumentClientCommand } from "../baseCommand/DynamoDBDocumentClientCommand";
import { DynamoDBDocumentClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "../DynamoDBDocumentClient";
/**
 * @public
 */
export { DynamoDBDocumentClientCommand, $Command };
/**
 * @public
 */
export type BatchExecuteStatementCommandInput = Omit<__BatchExecuteStatementCommandInput, "Statements"> & {
    Statements: (Omit<BatchStatementRequest, "Parameters"> & {
        Parameters?: NativeAttributeValue[] | undefined;
    })[] | undefined;
};
/**
 * @public
 */
export type BatchExecuteStatementCommandOutput = Omit<__BatchExecuteStatementCommandOutput, "Responses"> & {
    Responses?: (Omit<BatchStatementResponse, "Error" | "Item"> & {
        Error?: (Omit<BatchStatementError, "Item"> & {
            Item?: Record<string, NativeAttributeValue> | undefined;
        }) | undefined;
        Item?: Record<string, NativeAttributeValue> | undefined;
    })[] | undefined;
};
/**
 * Accepts native JavaScript types instead of `AttributeValue`s, and calls
 * BatchExecuteStatementCommand operation from {@link @aws-sdk/client-dynamodb#BatchExecuteStatementCommand}.
 *
 * JavaScript objects passed in as parameters are marshalled into `AttributeValue` shapes
 * required by Amazon DynamoDB. Responses from DynamoDB are unmarshalled into plain JavaScript objects.
 *
 * @public
 */
export declare class BatchExecuteStatementCommand extends DynamoDBDocumentClientCommand<BatchExecuteStatementCommandInput, BatchExecuteStatementCommandOutput, __BatchExecuteStatementCommandInput, __BatchExecuteStatementCommandOutput, DynamoDBDocumentClientResolvedConfig> {
    readonly input: BatchExecuteStatementCommandInput;
    protected readonly inputKeyNodes: {
        Statements: {
            "*": {
                Parameters: import("../commands/utils").KeyNodeChildren;
            };
        };
    };
    protected readonly outputKeyNodes: {
        Responses: {
            "*": {
                Error: {
                    Item: import("../commands/utils").KeyNodeChildren;
                };
                Item: import("../commands/utils").KeyNodeChildren;
            };
        };
    };
    protected readonly clientCommand: __BatchExecuteStatementCommand;
    readonly middlewareStack: MiddlewareStack<BatchExecuteStatementCommandInput | __BatchExecuteStatementCommandInput, BatchExecuteStatementCommandOutput | __BatchExecuteStatementCommandOutput>;
    constructor(input: BatchExecuteStatementCommandInput);
    /**
     * @internal
     */
    resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBDocumentClientResolvedConfig, options?: __HttpHandlerOptions): Handler<BatchExecuteStatementCommandInput, BatchExecuteStatementCommandOutput>;
}
import type { BatchExecuteStatementCommandInput as __BatchExecuteStatementCommandInput, BatchExecuteStatementCommandOutput as __BatchExecuteStatementCommandOutput, BatchStatementError, BatchStatementRequest, BatchStatementResponse } from "@aws-sdk/client-dynamodb";
import type { NativeAttributeValue } from "@aws-sdk/util-dynamodb";

```

## ./lib/lambda/node_modules/@aws-sdk/lib-dynamodb/dist-types/commands/BatchGetCommand.d.ts

```typescript
import { BatchGetItemCommand as __BatchGetItemCommand } from "@aws-sdk/client-dynamodb";
import { Command as $Command } from "@smithy/smithy-client";
import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MiddlewareStack } from "@smithy/types";
import { DynamoDBDocumentClientCommand } from "../baseCommand/DynamoDBDocumentClientCommand";
import { DynamoDBDocumentClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "../DynamoDBDocumentClient";
/**
 * @public
 */
export { DynamoDBDocumentClientCommand, $Command };
/**
 * @public
 */
export type BatchGetCommandInput = Omit<__BatchGetItemCommandInput, "RequestItems"> & {
    RequestItems: Record<string, Omit<KeysAndAttributes, "Keys"> & {
        Keys: Record<string, NativeAttributeValue>[] | undefined;
    }> | undefined;
};
/**
 * @public
 */
export type BatchGetCommandOutput = Omit<__BatchGetItemCommandOutput, "Responses" | "UnprocessedKeys"> & {
    Responses?: Record<string, Record<string, NativeAttributeValue>[]> | undefined;
    UnprocessedKeys?: Record<string, Omit<KeysAndAttributes, "Keys"> & {
        Keys: Record<string, NativeAttributeValue>[] | undefined;
    }> | undefined;
};
/**
 * Accepts native JavaScript types instead of `AttributeValue`s, and calls
 * BatchGetItemCommand operation from {@link @aws-sdk/client-dynamodb#BatchGetItemCommand}.
 *
 * JavaScript objects passed in as parameters are marshalled into `AttributeValue` shapes
 * required by Amazon DynamoDB. Responses from DynamoDB are unmarshalled into plain JavaScript objects.
 *
 * @public
 */
export declare class BatchGetCommand extends DynamoDBDocumentClientCommand<BatchGetCommandInput, BatchGetCommandOutput, __BatchGetItemCommandInput, __BatchGetItemCommandOutput, DynamoDBDocumentClientResolvedConfig> {
    readonly input: BatchGetCommandInput;
    protected readonly inputKeyNodes: {
        RequestItems: {
            "*": {
                Keys: {
                    "*": import("../commands/utils").KeyNodeChildren;
                };
            };
        };
    };
    protected readonly outputKeyNodes: {
        Responses: {
            "*": {
                "*": import("../commands/utils").KeyNodeChildren;
            };
        };
        UnprocessedKeys: {
            "*": {
                Keys: {
                    "*": import("../commands/utils").KeyNodeChildren;
                };
            };
        };
    };
    protected readonly clientCommand: __BatchGetItemCommand;
    readonly middlewareStack: MiddlewareStack<BatchGetCommandInput | __BatchGetItemCommandInput, BatchGetCommandOutput | __BatchGetItemCommandOutput>;
    constructor(input: BatchGetCommandInput);
    /**
     * @internal
     */
    resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBDocumentClientResolvedConfig, options?: __HttpHandlerOptions): Handler<BatchGetCommandInput, BatchGetCommandOutput>;
}
import type { BatchGetItemCommandInput as __BatchGetItemCommandInput, BatchGetItemCommandOutput as __BatchGetItemCommandOutput, KeysAndAttributes } from "@aws-sdk/client-dynamodb";
import type { NativeAttributeValue } from "@aws-sdk/util-dynamodb";

```

## ./lib/lambda/node_modules/@aws-sdk/lib-dynamodb/dist-types/commands/BatchWriteCommand.d.ts

```typescript
import { BatchWriteItemCommand as __BatchWriteItemCommand } from "@aws-sdk/client-dynamodb";
import { Command as $Command } from "@smithy/smithy-client";
import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MiddlewareStack } from "@smithy/types";
import { DynamoDBDocumentClientCommand } from "../baseCommand/DynamoDBDocumentClientCommand";
import { DynamoDBDocumentClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "../DynamoDBDocumentClient";
/**
 * @public
 */
export { DynamoDBDocumentClientCommand, $Command };
/**
 * @public
 */
export type BatchWriteCommandInput = Omit<__BatchWriteItemCommandInput, "RequestItems"> & {
    RequestItems: Record<string, (Omit<WriteRequest, "PutRequest" | "DeleteRequest"> & {
        PutRequest?: (Omit<PutRequest, "Item"> & {
            Item: Record<string, NativeAttributeValue> | undefined;
        }) | undefined;
        DeleteRequest?: (Omit<DeleteRequest, "Key"> & {
            Key: Record<string, NativeAttributeValue> | undefined;
        }) | undefined;
    })[]> | undefined;
};
/**
 * @public
 */
export type BatchWriteCommandOutput = Omit<__BatchWriteItemCommandOutput, "UnprocessedItems" | "ItemCollectionMetrics"> & {
    UnprocessedItems?: Record<string, (Omit<WriteRequest, "PutRequest" | "DeleteRequest"> & {
        PutRequest?: (Omit<PutRequest, "Item"> & {
            Item: Record<string, NativeAttributeValue> | undefined;
        }) | undefined;
        DeleteRequest?: (Omit<DeleteRequest, "Key"> & {
            Key: Record<string, NativeAttributeValue> | undefined;
        }) | undefined;
    })[]> | undefined;
    ItemCollectionMetrics?: Record<string, (Omit<ItemCollectionMetrics, "ItemCollectionKey"> & {
        ItemCollectionKey?: Record<string, NativeAttributeValue> | undefined;
    })[]> | undefined;
};
/**
 * Accepts native JavaScript types instead of `AttributeValue`s, and calls
 * BatchWriteItemCommand operation from {@link @aws-sdk/client-dynamodb#BatchWriteItemCommand}.
 *
 * JavaScript objects passed in as parameters are marshalled into `AttributeValue` shapes
 * required by Amazon DynamoDB. Responses from DynamoDB are unmarshalled into plain JavaScript objects.
 *
 * @public
 */
export declare class BatchWriteCommand extends DynamoDBDocumentClientCommand<BatchWriteCommandInput, BatchWriteCommandOutput, __BatchWriteItemCommandInput, __BatchWriteItemCommandOutput, DynamoDBDocumentClientResolvedConfig> {
    readonly input: BatchWriteCommandInput;
    protected readonly inputKeyNodes: {
        RequestItems: {
            "*": {
                "*": {
                    PutRequest: {
                        Item: import("../commands/utils").KeyNodeChildren;
                    };
                    DeleteRequest: {
                        Key: import("../commands/utils").KeyNodeChildren;
                    };
                };
            };
        };
    };
    protected readonly outputKeyNodes: {
        UnprocessedItems: {
            "*": {
                "*": {
                    PutRequest: {
                        Item: import("../commands/utils").KeyNodeChildren;
                    };
                    DeleteRequest: {
                        Key: import("../commands/utils").KeyNodeChildren;
                    };
                };
            };
        };
        ItemCollectionMetrics: {
            "*": {
                "*": {
                    ItemCollectionKey: import("../commands/utils").KeyNodeChildren;
                };
            };
        };
    };
    protected readonly clientCommand: __BatchWriteItemCommand;
    readonly middlewareStack: MiddlewareStack<BatchWriteCommandInput | __BatchWriteItemCommandInput, BatchWriteCommandOutput | __BatchWriteItemCommandOutput>;
    constructor(input: BatchWriteCommandInput);
    /**
     * @internal
     */
    resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBDocumentClientResolvedConfig, options?: __HttpHandlerOptions): Handler<BatchWriteCommandInput, BatchWriteCommandOutput>;
}
import type { BatchWriteItemCommandInput as __BatchWriteItemCommandInput, BatchWriteItemCommandOutput as __BatchWriteItemCommandOutput, DeleteRequest, ItemCollectionMetrics, PutRequest, WriteRequest } from "@aws-sdk/client-dynamodb";
import type { NativeAttributeValue } from "@aws-sdk/util-dynamodb";

```

## ./lib/lambda/node_modules/@aws-sdk/lib-dynamodb/dist-types/commands/DeleteCommand.d.ts

```typescript
import { DeleteItemCommand as __DeleteItemCommand } from "@aws-sdk/client-dynamodb";
import { Command as $Command } from "@smithy/smithy-client";
import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MiddlewareStack } from "@smithy/types";
import { DynamoDBDocumentClientCommand } from "../baseCommand/DynamoDBDocumentClientCommand";
import { DynamoDBDocumentClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "../DynamoDBDocumentClient";
/**
 * @public
 */
export { DynamoDBDocumentClientCommand, $Command };
/**
 * @public
 */
export type DeleteCommandInput = Omit<__DeleteItemCommandInput, "Key" | "Expected" | "ExpressionAttributeValues"> & {
    Key: Record<string, NativeAttributeValue> | undefined;
    Expected?: Record<string, Omit<ExpectedAttributeValue, "Value" | "AttributeValueList"> & {
        Value?: NativeAttributeValue | undefined;
        AttributeValueList?: NativeAttributeValue[] | undefined;
    }> | undefined;
    ExpressionAttributeValues?: Record<string, NativeAttributeValue> | undefined;
};
/**
 * @public
 */
export type DeleteCommandOutput = Omit<__DeleteItemCommandOutput, "Attributes" | "ItemCollectionMetrics"> & {
    Attributes?: Record<string, NativeAttributeValue> | undefined;
    ItemCollectionMetrics?: (Omit<ItemCollectionMetrics, "ItemCollectionKey"> & {
        ItemCollectionKey?: Record<string, NativeAttributeValue> | undefined;
    }) | undefined;
};
/**
 * Accepts native JavaScript types instead of `AttributeValue`s, and calls
 * DeleteItemCommand operation from {@link @aws-sdk/client-dynamodb#DeleteItemCommand}.
 *
 * JavaScript objects passed in as parameters are marshalled into `AttributeValue` shapes
 * required by Amazon DynamoDB. Responses from DynamoDB are unmarshalled into plain JavaScript objects.
 *
 * @public
 */
export declare class DeleteCommand extends DynamoDBDocumentClientCommand<DeleteCommandInput, DeleteCommandOutput, __DeleteItemCommandInput, __DeleteItemCommandOutput, DynamoDBDocumentClientResolvedConfig> {
    readonly input: DeleteCommandInput;
    protected readonly inputKeyNodes: {
        Key: import("../commands/utils").KeyNodeChildren;
        Expected: {
            "*": {
                Value: null;
                AttributeValueList: import("../commands/utils").KeyNodeChildren;
            };
        };
        ExpressionAttributeValues: import("../commands/utils").KeyNodeChildren;
    };
    protected readonly outputKeyNodes: {
        Attributes: import("../commands/utils").KeyNodeChildren;
        ItemCollectionMetrics: {
            ItemCollectionKey: import("../commands/utils").KeyNodeChildren;
        };
    };
    protected readonly clientCommand: __DeleteItemCommand;
    readonly middlewareStack: MiddlewareStack<DeleteCommandInput | __DeleteItemCommandInput, DeleteCommandOutput | __DeleteItemCommandOutput>;
    constructor(input: DeleteCommandInput);
    /**
     * @internal
     */
    resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBDocumentClientResolvedConfig, options?: __HttpHandlerOptions): Handler<DeleteCommandInput, DeleteCommandOutput>;
}
import type { DeleteItemCommandInput as __DeleteItemCommandInput, DeleteItemCommandOutput as __DeleteItemCommandOutput, ExpectedAttributeValue, ItemCollectionMetrics } from "@aws-sdk/client-dynamodb";
import type { NativeAttributeValue } from "@aws-sdk/util-dynamodb";

```

## ./lib/lambda/node_modules/@aws-sdk/lib-dynamodb/dist-types/commands/ExecuteStatementCommand.d.ts

```typescript
import { ExecuteStatementCommand as __ExecuteStatementCommand } from "@aws-sdk/client-dynamodb";
import { Command as $Command } from "@smithy/smithy-client";
import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MiddlewareStack } from "@smithy/types";
import { DynamoDBDocumentClientCommand } from "../baseCommand/DynamoDBDocumentClientCommand";
import { DynamoDBDocumentClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "../DynamoDBDocumentClient";
/**
 * @public
 */
export { DynamoDBDocumentClientCommand, $Command };
/**
 * @public
 */
export type ExecuteStatementCommandInput = Omit<__ExecuteStatementCommandInput, "Parameters"> & {
    Parameters?: NativeAttributeValue[] | undefined;
};
/**
 * @public
 */
export type ExecuteStatementCommandOutput = Omit<__ExecuteStatementCommandOutput, "Items" | "LastEvaluatedKey"> & {
    Items?: Record<string, NativeAttributeValue>[] | undefined;
    LastEvaluatedKey?: Record<string, NativeAttributeValue> | undefined;
};
/**
 * Accepts native JavaScript types instead of `AttributeValue`s, and calls
 * ExecuteStatementCommand operation from {@link @aws-sdk/client-dynamodb#ExecuteStatementCommand}.
 *
 * JavaScript objects passed in as parameters are marshalled into `AttributeValue` shapes
 * required by Amazon DynamoDB. Responses from DynamoDB are unmarshalled into plain JavaScript objects.
 *
 * @public
 */
export declare class ExecuteStatementCommand extends DynamoDBDocumentClientCommand<ExecuteStatementCommandInput, ExecuteStatementCommandOutput, __ExecuteStatementCommandInput, __ExecuteStatementCommandOutput, DynamoDBDocumentClientResolvedConfig> {
    readonly input: ExecuteStatementCommandInput;
    protected readonly inputKeyNodes: {
        Parameters: import("../commands/utils").KeyNodeChildren;
    };
    protected readonly outputKeyNodes: {
        Items: {
            "*": import("../commands/utils").KeyNodeChildren;
        };
        LastEvaluatedKey: import("../commands/utils").KeyNodeChildren;
    };
    protected readonly clientCommand: __ExecuteStatementCommand;
    readonly middlewareStack: MiddlewareStack<ExecuteStatementCommandInput | __ExecuteStatementCommandInput, ExecuteStatementCommandOutput | __ExecuteStatementCommandOutput>;
    constructor(input: ExecuteStatementCommandInput);
    /**
     * @internal
     */
    resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBDocumentClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ExecuteStatementCommandInput, ExecuteStatementCommandOutput>;
}
import type { ExecuteStatementCommandInput as __ExecuteStatementCommandInput, ExecuteStatementCommandOutput as __ExecuteStatementCommandOutput } from "@aws-sdk/client-dynamodb";
import type { NativeAttributeValue } from "@aws-sdk/util-dynamodb";

```

## ./lib/lambda/node_modules/@aws-sdk/lib-dynamodb/dist-types/commands/ExecuteTransactionCommand.d.ts

```typescript
import { ExecuteTransactionCommand as __ExecuteTransactionCommand } from "@aws-sdk/client-dynamodb";
import { Command as $Command } from "@smithy/smithy-client";
import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MiddlewareStack } from "@smithy/types";
import { DynamoDBDocumentClientCommand } from "../baseCommand/DynamoDBDocumentClientCommand";
import { DynamoDBDocumentClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "../DynamoDBDocumentClient";
/**
 * @public
 */
export { DynamoDBDocumentClientCommand, $Command };
/**
 * @public
 */
export type ExecuteTransactionCommandInput = Omit<__ExecuteTransactionCommandInput, "TransactStatements"> & {
    TransactStatements: (Omit<ParameterizedStatement, "Parameters"> & {
        Parameters?: NativeAttributeValue[] | undefined;
    })[] | undefined;
};
/**
 * @public
 */
export type ExecuteTransactionCommandOutput = Omit<__ExecuteTransactionCommandOutput, "Responses"> & {
    Responses?: (Omit<ItemResponse, "Item"> & {
        Item?: Record<string, NativeAttributeValue> | undefined;
    })[] | undefined;
};
/**
 * Accepts native JavaScript types instead of `AttributeValue`s, and calls
 * ExecuteTransactionCommand operation from {@link @aws-sdk/client-dynamodb#ExecuteTransactionCommand}.
 *
 * JavaScript objects passed in as parameters are marshalled into `AttributeValue` shapes
 * required by Amazon DynamoDB. Responses from DynamoDB are unmarshalled into plain JavaScript objects.
 *
 * @public
 */
export declare class ExecuteTransactionCommand extends DynamoDBDocumentClientCommand<ExecuteTransactionCommandInput, ExecuteTransactionCommandOutput, __ExecuteTransactionCommandInput, __ExecuteTransactionCommandOutput, DynamoDBDocumentClientResolvedConfig> {
    readonly input: ExecuteTransactionCommandInput;
    protected readonly inputKeyNodes: {
        TransactStatements: {
            "*": {
                Parameters: import("../commands/utils").KeyNodeChildren;
            };
        };
    };
    protected readonly outputKeyNodes: {
        Responses: {
            "*": {
                Item: import("../commands/utils").KeyNodeChildren;
            };
        };
    };
    protected readonly clientCommand: __ExecuteTransactionCommand;
    readonly middlewareStack: MiddlewareStack<ExecuteTransactionCommandInput | __ExecuteTransactionCommandInput, ExecuteTransactionCommandOutput | __ExecuteTransactionCommandOutput>;
    constructor(input: ExecuteTransactionCommandInput);
    /**
     * @internal
     */
    resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBDocumentClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ExecuteTransactionCommandInput, ExecuteTransactionCommandOutput>;
}
import type { ExecuteTransactionCommandInput as __ExecuteTransactionCommandInput, ExecuteTransactionCommandOutput as __ExecuteTransactionCommandOutput, ItemResponse, ParameterizedStatement } from "@aws-sdk/client-dynamodb";
import type { NativeAttributeValue } from "@aws-sdk/util-dynamodb";

```

## ./lib/lambda/node_modules/@aws-sdk/lib-dynamodb/dist-types/commands/GetCommand.d.ts

```typescript
import { GetItemCommand as __GetItemCommand } from "@aws-sdk/client-dynamodb";
import { Command as $Command } from "@smithy/smithy-client";
import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MiddlewareStack } from "@smithy/types";
import { DynamoDBDocumentClientCommand } from "../baseCommand/DynamoDBDocumentClientCommand";
import { DynamoDBDocumentClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "../DynamoDBDocumentClient";
/**
 * @public
 */
export { DynamoDBDocumentClientCommand, $Command };
/**
 * @public
 */
export type GetCommandInput = Omit<__GetItemCommandInput, "Key"> & {
    Key: Record<string, NativeAttributeValue> | undefined;
};
/**
 * @public
 */
export type GetCommandOutput = Omit<__GetItemCommandOutput, "Item"> & {
    Item?: Record<string, NativeAttributeValue> | undefined;
};
/**
 * Accepts native JavaScript types instead of `AttributeValue`s, and calls
 * GetItemCommand operation from {@link @aws-sdk/client-dynamodb#GetItemCommand}.
 *
 * JavaScript objects passed in as parameters are marshalled into `AttributeValue` shapes
 * required by Amazon DynamoDB. Responses from DynamoDB are unmarshalled into plain JavaScript objects.
 *
 * @public
 */
export declare class GetCommand extends DynamoDBDocumentClientCommand<GetCommandInput, GetCommandOutput, __GetItemCommandInput, __GetItemCommandOutput, DynamoDBDocumentClientResolvedConfig> {
    readonly input: GetCommandInput;
    protected readonly inputKeyNodes: {
        Key: import("../commands/utils").KeyNodeChildren;
    };
    protected readonly outputKeyNodes: {
        Item: import("../commands/utils").KeyNodeChildren;
    };
    protected readonly clientCommand: __GetItemCommand;
    readonly middlewareStack: MiddlewareStack<GetCommandInput | __GetItemCommandInput, GetCommandOutput | __GetItemCommandOutput>;
    constructor(input: GetCommandInput);
    /**
     * @internal
     */
    resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBDocumentClientResolvedConfig, options?: __HttpHandlerOptions): Handler<GetCommandInput, GetCommandOutput>;
}
import type { GetItemCommandInput as __GetItemCommandInput, GetItemCommandOutput as __GetItemCommandOutput } from "@aws-sdk/client-dynamodb";
import type { NativeAttributeValue } from "@aws-sdk/util-dynamodb";

```

## ./lib/lambda/node_modules/@aws-sdk/lib-dynamodb/dist-types/commands/PutCommand.d.ts

```typescript
import { PutItemCommand as __PutItemCommand } from "@aws-sdk/client-dynamodb";
import { Command as $Command } from "@smithy/smithy-client";
import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MiddlewareStack } from "@smithy/types";
import { DynamoDBDocumentClientCommand } from "../baseCommand/DynamoDBDocumentClientCommand";
import { DynamoDBDocumentClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "../DynamoDBDocumentClient";
/**
 * @public
 */
export { DynamoDBDocumentClientCommand, $Command };
/**
 * @public
 */
export type PutCommandInput = Omit<__PutItemCommandInput, "Item" | "Expected" | "ExpressionAttributeValues"> & {
    Item: Record<string, NativeAttributeValue> | undefined;
    Expected?: Record<string, Omit<ExpectedAttributeValue, "Value" | "AttributeValueList"> & {
        Value?: NativeAttributeValue | undefined;
        AttributeValueList?: NativeAttributeValue[] | undefined;
    }> | undefined;
    ExpressionAttributeValues?: Record<string, NativeAttributeValue> | undefined;
};
/**
 * @public
 */
export type PutCommandOutput = Omit<__PutItemCommandOutput, "Attributes" | "ItemCollectionMetrics"> & {
    Attributes?: Record<string, NativeAttributeValue> | undefined;
    ItemCollectionMetrics?: (Omit<ItemCollectionMetrics, "ItemCollectionKey"> & {
        ItemCollectionKey?: Record<string, NativeAttributeValue> | undefined;
    }) | undefined;
};
/**
 * Accepts native JavaScript types instead of `AttributeValue`s, and calls
 * PutItemCommand operation from {@link @aws-sdk/client-dynamodb#PutItemCommand}.
 *
 * JavaScript objects passed in as parameters are marshalled into `AttributeValue` shapes
 * required by Amazon DynamoDB. Responses from DynamoDB are unmarshalled into plain JavaScript objects.
 *
 * @public
 */
export declare class PutCommand extends DynamoDBDocumentClientCommand<PutCommandInput, PutCommandOutput, __PutItemCommandInput, __PutItemCommandOutput, DynamoDBDocumentClientResolvedConfig> {
    readonly input: PutCommandInput;
    protected readonly inputKeyNodes: {
        Item: import("../commands/utils").KeyNodeChildren;
        Expected: {
            "*": {
                Value: null;
                AttributeValueList: import("../commands/utils").KeyNodeChildren;
            };
        };
        ExpressionAttributeValues: import("../commands/utils").KeyNodeChildren;
    };
    protected readonly outputKeyNodes: {
        Attributes: import("../commands/utils").KeyNodeChildren;
        ItemCollectionMetrics: {
            ItemCollectionKey: import("../commands/utils").KeyNodeChildren;
        };
    };
    protected readonly clientCommand: __PutItemCommand;
    readonly middlewareStack: MiddlewareStack<PutCommandInput | __PutItemCommandInput, PutCommandOutput | __PutItemCommandOutput>;
    constructor(input: PutCommandInput);
    /**
     * @internal
     */
    resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBDocumentClientResolvedConfig, options?: __HttpHandlerOptions): Handler<PutCommandInput, PutCommandOutput>;
}
import type { ExpectedAttributeValue, ItemCollectionMetrics, PutItemCommandInput as __PutItemCommandInput, PutItemCommandOutput as __PutItemCommandOutput } from "@aws-sdk/client-dynamodb";
import type { NativeAttributeValue } from "@aws-sdk/util-dynamodb";

```

## ./lib/lambda/node_modules/@aws-sdk/lib-dynamodb/dist-types/commands/QueryCommand.d.ts

```typescript
import { QueryCommand as __QueryCommand } from "@aws-sdk/client-dynamodb";
import { Command as $Command } from "@smithy/smithy-client";
import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MiddlewareStack } from "@smithy/types";
import { DynamoDBDocumentClientCommand } from "../baseCommand/DynamoDBDocumentClientCommand";
import { DynamoDBDocumentClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "../DynamoDBDocumentClient";
/**
 * @public
 */
export { DynamoDBDocumentClientCommand, $Command };
/**
 * @public
 */
export type QueryCommandInput = Omit<__QueryCommandInput, "KeyConditions" | "QueryFilter" | "ExclusiveStartKey" | "ExpressionAttributeValues"> & {
    KeyConditions?: Record<string, Omit<Condition, "AttributeValueList"> & {
        AttributeValueList?: NativeAttributeValue[] | undefined;
    }> | undefined;
    QueryFilter?: Record<string, Omit<Condition, "AttributeValueList"> & {
        AttributeValueList?: NativeAttributeValue[] | undefined;
    }> | undefined;
    ExclusiveStartKey?: Record<string, NativeAttributeValue> | undefined;
    ExpressionAttributeValues?: Record<string, NativeAttributeValue> | undefined;
};
/**
 * @public
 */
export type QueryCommandOutput = Omit<__QueryCommandOutput, "Items" | "LastEvaluatedKey"> & {
    Items?: Record<string, NativeAttributeValue>[] | undefined;
    LastEvaluatedKey?: Record<string, NativeAttributeValue> | undefined;
};
/**
 * Accepts native JavaScript types instead of `AttributeValue`s, and calls
 * QueryCommand operation from {@link @aws-sdk/client-dynamodb#QueryCommand}.
 *
 * JavaScript objects passed in as parameters are marshalled into `AttributeValue` shapes
 * required by Amazon DynamoDB. Responses from DynamoDB are unmarshalled into plain JavaScript objects.
 *
 * @public
 */
export declare class QueryCommand extends DynamoDBDocumentClientCommand<QueryCommandInput, QueryCommandOutput, __QueryCommandInput, __QueryCommandOutput, DynamoDBDocumentClientResolvedConfig> {
    readonly input: QueryCommandInput;
    protected readonly inputKeyNodes: {
        KeyConditions: {
            "*": {
                AttributeValueList: import("../commands/utils").KeyNodeChildren;
            };
        };
        QueryFilter: {
            "*": {
                AttributeValueList: import("../commands/utils").KeyNodeChildren;
            };
        };
        ExclusiveStartKey: import("../commands/utils").KeyNodeChildren;
        ExpressionAttributeValues: import("../commands/utils").KeyNodeChildren;
    };
    protected readonly outputKeyNodes: {
        Items: {
            "*": import("../commands/utils").KeyNodeChildren;
        };
        LastEvaluatedKey: import("../commands/utils").KeyNodeChildren;
    };
    protected readonly clientCommand: __QueryCommand;
    readonly middlewareStack: MiddlewareStack<QueryCommandInput | __QueryCommandInput, QueryCommandOutput | __QueryCommandOutput>;
    constructor(input: QueryCommandInput);
    /**
     * @internal
     */
    resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBDocumentClientResolvedConfig, options?: __HttpHandlerOptions): Handler<QueryCommandInput, QueryCommandOutput>;
}
import type { Condition, QueryCommandInput as __QueryCommandInput, QueryCommandOutput as __QueryCommandOutput } from "@aws-sdk/client-dynamodb";
import type { NativeAttributeValue } from "@aws-sdk/util-dynamodb";

```

## ./lib/lambda/node_modules/@aws-sdk/lib-dynamodb/dist-types/commands/ScanCommand.d.ts

```typescript
import { ScanCommand as __ScanCommand } from "@aws-sdk/client-dynamodb";
import { Command as $Command } from "@smithy/smithy-client";
import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MiddlewareStack } from "@smithy/types";
import { DynamoDBDocumentClientCommand } from "../baseCommand/DynamoDBDocumentClientCommand";
import { DynamoDBDocumentClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "../DynamoDBDocumentClient";
/**
 * @public
 */
export { DynamoDBDocumentClientCommand, $Command };
/**
 * @public
 */
export type ScanCommandInput = Omit<__ScanCommandInput, "ScanFilter" | "ExclusiveStartKey" | "ExpressionAttributeValues"> & {
    ScanFilter?: Record<string, Omit<Condition, "AttributeValueList"> & {
        AttributeValueList?: NativeAttributeValue[] | undefined;
    }> | undefined;
    ExclusiveStartKey?: Record<string, NativeAttributeValue> | undefined;
    ExpressionAttributeValues?: Record<string, NativeAttributeValue> | undefined;
};
/**
 * @public
 */
export type ScanCommandOutput = Omit<__ScanCommandOutput, "Items" | "LastEvaluatedKey"> & {
    Items?: Record<string, NativeAttributeValue>[] | undefined;
    LastEvaluatedKey?: Record<string, NativeAttributeValue> | undefined;
};
/**
 * Accepts native JavaScript types instead of `AttributeValue`s, and calls
 * ScanCommand operation from {@link @aws-sdk/client-dynamodb#ScanCommand}.
 *
 * JavaScript objects passed in as parameters are marshalled into `AttributeValue` shapes
 * required by Amazon DynamoDB. Responses from DynamoDB are unmarshalled into plain JavaScript objects.
 *
 * @public
 */
export declare class ScanCommand extends DynamoDBDocumentClientCommand<ScanCommandInput, ScanCommandOutput, __ScanCommandInput, __ScanCommandOutput, DynamoDBDocumentClientResolvedConfig> {
    readonly input: ScanCommandInput;
    protected readonly inputKeyNodes: {
        ScanFilter: {
            "*": {
                AttributeValueList: import("../commands/utils").KeyNodeChildren;
            };
        };
        ExclusiveStartKey: import("../commands/utils").KeyNodeChildren;
        ExpressionAttributeValues: import("../commands/utils").KeyNodeChildren;
    };
    protected readonly outputKeyNodes: {
        Items: {
            "*": import("../commands/utils").KeyNodeChildren;
        };
        LastEvaluatedKey: import("../commands/utils").KeyNodeChildren;
    };
    protected readonly clientCommand: __ScanCommand;
    readonly middlewareStack: MiddlewareStack<ScanCommandInput | __ScanCommandInput, ScanCommandOutput | __ScanCommandOutput>;
    constructor(input: ScanCommandInput);
    /**
     * @internal
     */
    resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBDocumentClientResolvedConfig, options?: __HttpHandlerOptions): Handler<ScanCommandInput, ScanCommandOutput>;
}
import type { Condition, ScanCommandInput as __ScanCommandInput, ScanCommandOutput as __ScanCommandOutput } from "@aws-sdk/client-dynamodb";
import type { NativeAttributeValue } from "@aws-sdk/util-dynamodb";

```

## ./lib/lambda/node_modules/@aws-sdk/lib-dynamodb/dist-types/commands/TransactGetCommand.d.ts

```typescript
import { TransactGetItemsCommand as __TransactGetItemsCommand } from "@aws-sdk/client-dynamodb";
import { Command as $Command } from "@smithy/smithy-client";
import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MiddlewareStack } from "@smithy/types";
import { DynamoDBDocumentClientCommand } from "../baseCommand/DynamoDBDocumentClientCommand";
import { DynamoDBDocumentClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "../DynamoDBDocumentClient";
/**
 * @public
 */
export { DynamoDBDocumentClientCommand, $Command };
/**
 * @public
 */
export type TransactGetCommandInput = Omit<__TransactGetItemsCommandInput, "TransactItems"> & {
    TransactItems: (Omit<TransactGetItem, "Get"> & {
        Get: (Omit<Get, "Key"> & {
            Key: Record<string, NativeAttributeValue> | undefined;
        }) | undefined;
    })[] | undefined;
};
/**
 * @public
 */
export type TransactGetCommandOutput = Omit<__TransactGetItemsCommandOutput, "Responses"> & {
    Responses?: (Omit<ItemResponse, "Item"> & {
        Item?: Record<string, NativeAttributeValue> | undefined;
    })[] | undefined;
};
/**
 * Accepts native JavaScript types instead of `AttributeValue`s, and calls
 * TransactGetItemsCommand operation from {@link @aws-sdk/client-dynamodb#TransactGetItemsCommand}.
 *
 * JavaScript objects passed in as parameters are marshalled into `AttributeValue` shapes
 * required by Amazon DynamoDB. Responses from DynamoDB are unmarshalled into plain JavaScript objects.
 *
 * @public
 */
export declare class TransactGetCommand extends DynamoDBDocumentClientCommand<TransactGetCommandInput, TransactGetCommandOutput, __TransactGetItemsCommandInput, __TransactGetItemsCommandOutput, DynamoDBDocumentClientResolvedConfig> {
    readonly input: TransactGetCommandInput;
    protected readonly inputKeyNodes: {
        TransactItems: {
            "*": {
                Get: {
                    Key: import("../commands/utils").KeyNodeChildren;
                };
            };
        };
    };
    protected readonly outputKeyNodes: {
        Responses: {
            "*": {
                Item: import("../commands/utils").KeyNodeChildren;
            };
        };
    };
    protected readonly clientCommand: __TransactGetItemsCommand;
    readonly middlewareStack: MiddlewareStack<TransactGetCommandInput | __TransactGetItemsCommandInput, TransactGetCommandOutput | __TransactGetItemsCommandOutput>;
    constructor(input: TransactGetCommandInput);
    /**
     * @internal
     */
    resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBDocumentClientResolvedConfig, options?: __HttpHandlerOptions): Handler<TransactGetCommandInput, TransactGetCommandOutput>;
}
import type { Get, ItemResponse, TransactGetItem, TransactGetItemsCommandInput as __TransactGetItemsCommandInput, TransactGetItemsCommandOutput as __TransactGetItemsCommandOutput } from "@aws-sdk/client-dynamodb";
import type { NativeAttributeValue } from "@aws-sdk/util-dynamodb";

```

## ./lib/lambda/node_modules/@aws-sdk/lib-dynamodb/dist-types/commands/TransactWriteCommand.d.ts

```typescript
import { TransactWriteItemsCommand as __TransactWriteItemsCommand } from "@aws-sdk/client-dynamodb";
import { Command as $Command } from "@smithy/smithy-client";
import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MiddlewareStack } from "@smithy/types";
import { DynamoDBDocumentClientCommand } from "../baseCommand/DynamoDBDocumentClientCommand";
import { DynamoDBDocumentClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "../DynamoDBDocumentClient";
/**
 * @public
 */
export { DynamoDBDocumentClientCommand, $Command };
/**
 * @public
 */
export type TransactWriteCommandInput = Omit<__TransactWriteItemsCommandInput, "TransactItems"> & {
    TransactItems: (Omit<TransactWriteItem, "ConditionCheck" | "Put" | "Delete" | "Update"> & {
        ConditionCheck?: (Omit<ConditionCheck, "Key" | "ExpressionAttributeValues"> & {
            Key: Record<string, NativeAttributeValue> | undefined;
            ExpressionAttributeValues?: Record<string, NativeAttributeValue> | undefined;
        }) | undefined;
        Put?: (Omit<Put, "Item" | "ExpressionAttributeValues"> & {
            Item: Record<string, NativeAttributeValue> | undefined;
            ExpressionAttributeValues?: Record<string, NativeAttributeValue> | undefined;
        }) | undefined;
        Delete?: (Omit<Delete, "Key" | "ExpressionAttributeValues"> & {
            Key: Record<string, NativeAttributeValue> | undefined;
            ExpressionAttributeValues?: Record<string, NativeAttributeValue> | undefined;
        }) | undefined;
        Update?: (Omit<Update, "Key" | "ExpressionAttributeValues"> & {
            Key: Record<string, NativeAttributeValue> | undefined;
            ExpressionAttributeValues?: Record<string, NativeAttributeValue> | undefined;
        }) | undefined;
    })[] | undefined;
};
/**
 * @public
 */
export type TransactWriteCommandOutput = Omit<__TransactWriteItemsCommandOutput, "ItemCollectionMetrics"> & {
    ItemCollectionMetrics?: Record<string, (Omit<ItemCollectionMetrics, "ItemCollectionKey"> & {
        ItemCollectionKey?: Record<string, NativeAttributeValue> | undefined;
    })[]> | undefined;
};
/**
 * Accepts native JavaScript types instead of `AttributeValue`s, and calls
 * TransactWriteItemsCommand operation from {@link @aws-sdk/client-dynamodb#TransactWriteItemsCommand}.
 *
 * JavaScript objects passed in as parameters are marshalled into `AttributeValue` shapes
 * required by Amazon DynamoDB. Responses from DynamoDB are unmarshalled into plain JavaScript objects.
 *
 * @public
 */
export declare class TransactWriteCommand extends DynamoDBDocumentClientCommand<TransactWriteCommandInput, TransactWriteCommandOutput, __TransactWriteItemsCommandInput, __TransactWriteItemsCommandOutput, DynamoDBDocumentClientResolvedConfig> {
    readonly input: TransactWriteCommandInput;
    protected readonly inputKeyNodes: {
        TransactItems: {
            "*": {
                ConditionCheck: {
                    Key: import("../commands/utils").KeyNodeChildren;
                    ExpressionAttributeValues: import("../commands/utils").KeyNodeChildren;
                };
                Put: {
                    Item: import("../commands/utils").KeyNodeChildren;
                    ExpressionAttributeValues: import("../commands/utils").KeyNodeChildren;
                };
                Delete: {
                    Key: import("../commands/utils").KeyNodeChildren;
                    ExpressionAttributeValues: import("../commands/utils").KeyNodeChildren;
                };
                Update: {
                    Key: import("../commands/utils").KeyNodeChildren;
                    ExpressionAttributeValues: import("../commands/utils").KeyNodeChildren;
                };
            };
        };
    };
    protected readonly outputKeyNodes: {
        ItemCollectionMetrics: {
            "*": {
                "*": {
                    ItemCollectionKey: import("../commands/utils").KeyNodeChildren;
                };
            };
        };
    };
    protected readonly clientCommand: __TransactWriteItemsCommand;
    readonly middlewareStack: MiddlewareStack<TransactWriteCommandInput | __TransactWriteItemsCommandInput, TransactWriteCommandOutput | __TransactWriteItemsCommandOutput>;
    constructor(input: TransactWriteCommandInput);
    /**
     * @internal
     */
    resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBDocumentClientResolvedConfig, options?: __HttpHandlerOptions): Handler<TransactWriteCommandInput, TransactWriteCommandOutput>;
}
import type { ConditionCheck, Delete, ItemCollectionMetrics, Put, TransactWriteItem, TransactWriteItemsCommandInput as __TransactWriteItemsCommandInput, TransactWriteItemsCommandOutput as __TransactWriteItemsCommandOutput, Update } from "@aws-sdk/client-dynamodb";
import type { NativeAttributeValue } from "@aws-sdk/util-dynamodb";

```

## ./lib/lambda/node_modules/@aws-sdk/lib-dynamodb/dist-types/commands/UpdateCommand.d.ts

```typescript
import { UpdateItemCommand as __UpdateItemCommand } from "@aws-sdk/client-dynamodb";
import { Command as $Command } from "@smithy/smithy-client";
import { Handler, HttpHandlerOptions as __HttpHandlerOptions, MiddlewareStack } from "@smithy/types";
import { DynamoDBDocumentClientCommand } from "../baseCommand/DynamoDBDocumentClientCommand";
import { DynamoDBDocumentClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes } from "../DynamoDBDocumentClient";
/**
 * @public
 */
export { DynamoDBDocumentClientCommand, $Command };
/**
 * @public
 */
export type UpdateCommandInput = Omit<__UpdateItemCommandInput, "Key" | "AttributeUpdates" | "Expected" | "ExpressionAttributeValues"> & {
    Key: Record<string, NativeAttributeValue> | undefined;
    AttributeUpdates?: Record<string, Omit<AttributeValueUpdate, "Value"> & {
        Value?: NativeAttributeValue | undefined;
    }> | undefined;
    Expected?: Record<string, Omit<ExpectedAttributeValue, "Value" | "AttributeValueList"> & {
        Value?: NativeAttributeValue | undefined;
        AttributeValueList?: NativeAttributeValue[] | undefined;
    }> | undefined;
    ExpressionAttributeValues?: Record<string, NativeAttributeValue> | undefined;
};
/**
 * @public
 */
export type UpdateCommandOutput = Omit<__UpdateItemCommandOutput, "Attributes" | "ItemCollectionMetrics"> & {
    Attributes?: Record<string, NativeAttributeValue> | undefined;
    ItemCollectionMetrics?: (Omit<ItemCollectionMetrics, "ItemCollectionKey"> & {
        ItemCollectionKey?: Record<string, NativeAttributeValue> | undefined;
    }) | undefined;
};
/**
 * Accepts native JavaScript types instead of `AttributeValue`s, and calls
 * UpdateItemCommand operation from {@link @aws-sdk/client-dynamodb#UpdateItemCommand}.
 *
 * JavaScript objects passed in as parameters are marshalled into `AttributeValue` shapes
 * required by Amazon DynamoDB. Responses from DynamoDB are unmarshalled into plain JavaScript objects.
 *
 * @public
 */
export declare class UpdateCommand extends DynamoDBDocumentClientCommand<UpdateCommandInput, UpdateCommandOutput, __UpdateItemCommandInput, __UpdateItemCommandOutput, DynamoDBDocumentClientResolvedConfig> {
    readonly input: UpdateCommandInput;
    protected readonly inputKeyNodes: {
        Key: import("../commands/utils").KeyNodeChildren;
        AttributeUpdates: {
            "*": {
                Value: null;
            };
        };
        Expected: {
            "*": {
                Value: null;
                AttributeValueList: import("../commands/utils").KeyNodeChildren;
            };
        };
        ExpressionAttributeValues: import("../commands/utils").KeyNodeChildren;
    };
    protected readonly outputKeyNodes: {
        Attributes: import("../commands/utils").KeyNodeChildren;
        ItemCollectionMetrics: {
            ItemCollectionKey: import("../commands/utils").KeyNodeChildren;
        };
    };
    protected readonly clientCommand: __UpdateItemCommand;
    readonly middlewareStack: MiddlewareStack<UpdateCommandInput | __UpdateItemCommandInput, UpdateCommandOutput | __UpdateItemCommandOutput>;
    constructor(input: UpdateCommandInput);
    /**
     * @internal
     */
    resolveMiddleware(clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>, configuration: DynamoDBDocumentClientResolvedConfig, options?: __HttpHandlerOptions): Handler<UpdateCommandInput, UpdateCommandOutput>;
}
import type { AttributeValueUpdate, ExpectedAttributeValue, ItemCollectionMetrics, UpdateItemCommandInput as __UpdateItemCommandInput, UpdateItemCommandOutput as __UpdateItemCommandOutput } from "@aws-sdk/client-dynamodb";
import type { NativeAttributeValue } from "@aws-sdk/util-dynamodb";

```

## ./lib/lambda/node_modules/@aws-sdk/lib-dynamodb/dist-types/commands/index.d.ts

```typescript
export * from "./BatchExecuteStatementCommand";
export * from "./BatchGetCommand";
export * from "./BatchWriteCommand";
export * from "./DeleteCommand";
export * from "./ExecuteStatementCommand";
export * from "./ExecuteTransactionCommand";
export * from "./GetCommand";
export * from "./PutCommand";
export * from "./QueryCommand";
export * from "./ScanCommand";
export * from "./TransactGetCommand";
export * from "./TransactWriteCommand";
export * from "./UpdateCommand";

```

## ./lib/lambda/node_modules/@aws-sdk/lib-dynamodb/dist-types/commands/utils.d.ts

```typescript
import { marshallOptions, unmarshallOptions } from "@aws-sdk/util-dynamodb";
/**
 * @internal
 */
export type KeyNodeSelf = null;
/**
 * @internal
 */
export declare const SELF: KeyNodeSelf;
/**
 * @internal
 */
export type KeyNodeChildren = Record<string, any>;
/**
 * @internal
 */
export declare const ALL_VALUES: KeyNodeChildren;
/**
 * @internal
 */
export declare const ALL_MEMBERS: KeyNodeChildren;
/**
 * @internal
 */
export type KeyNodes = KeyNodeSelf | KeyNodeChildren;
/**
 * @internal
 */
export declare const marshallInput: (obj: any, keyNodes: KeyNodeChildren, options?: marshallOptions) => any;
/**
 * @internal
 */
export declare const unmarshallOutput: (obj: any, keyNodes: KeyNodeChildren, options?: unmarshallOptions) => any;

```

## ./lib/lambda/node_modules/@aws-sdk/lib-dynamodb/dist-types/index.d.ts

```typescript
export * from "./DynamoDBDocument";
export * from "./DynamoDBDocumentClient";
export * from "./commands";
export * from "./pagination";
export { NumberValueImpl as NumberValue } from "@aws-sdk/util-dynamodb";
export { marshallOptions, unmarshallOptions } from "@aws-sdk/util-dynamodb";
export { NativeAttributeValue, NativeAttributeBinary, NativeScalarAttributeValue } from "@aws-sdk/util-dynamodb";

```

## ./lib/lambda/node_modules/@aws-sdk/lib-dynamodb/dist-types/pagination/Interfaces.d.ts

```typescript
import { PaginationConfiguration } from "@smithy/types";
import { DynamoDBDocument } from "../DynamoDBDocument";
import { DynamoDBDocumentClient } from "../DynamoDBDocumentClient";
/**
 * @public
 */
export { PaginationConfiguration };
/**
 * @public
 */
export interface DynamoDBDocumentPaginationConfiguration extends PaginationConfiguration {
    client: DynamoDBDocument | DynamoDBDocumentClient;
}

```

## ./lib/lambda/node_modules/@aws-sdk/lib-dynamodb/dist-types/pagination/QueryPaginator.d.ts

```typescript
import { Paginator } from "@smithy/types";
import { QueryCommandInput, QueryCommandOutput } from "../commands/QueryCommand";
import { DynamoDBDocumentPaginationConfiguration } from "./Interfaces";
/**
 * @public
 */
export { Paginator };
/**
 * @public
 */
export declare const paginateQuery: (config: DynamoDBDocumentPaginationConfiguration, input: QueryCommandInput, ...additionalArguments: any) => Paginator<QueryCommandOutput>;

```

## ./lib/lambda/node_modules/@aws-sdk/lib-dynamodb/dist-types/pagination/ScanPaginator.d.ts

```typescript
import { Paginator } from "@smithy/types";
import { ScanCommandInput, ScanCommandOutput } from "../commands/ScanCommand";
import { DynamoDBDocumentPaginationConfiguration } from "./Interfaces";
/**
 * @public
 */
export { Paginator };
/**
 * @public
 */
export declare const paginateScan: (config: DynamoDBDocumentPaginationConfiguration, input: ScanCommandInput, ...additionalArguments: any) => Paginator<ScanCommandOutput>;

```

## ./lib/lambda/node_modules/@aws-sdk/lib-dynamodb/dist-types/pagination/index.d.ts

```typescript
export * from "./Interfaces";
export * from "./QueryPaginator";
export * from "./ScanPaginator";

```

## ./lib/lambda/node_modules/@aws-sdk/lib-dynamodb/dist-types/ts3.4/DynamoDBDocument.d.ts

```typescript
import { DynamoDBClient } from "@aws-sdk/client-dynamodb";
import { HttpHandlerOptions as __HttpHandlerOptions } from "@smithy/types";
import {
  BatchExecuteStatementCommandInput,
  BatchExecuteStatementCommandOutput,
} from "./commands/BatchExecuteStatementCommand";
import {
  BatchGetCommandInput,
  BatchGetCommandOutput,
} from "./commands/BatchGetCommand";
import {
  BatchWriteCommandInput,
  BatchWriteCommandOutput,
} from "./commands/BatchWriteCommand";
import {
  DeleteCommandInput,
  DeleteCommandOutput,
} from "./commands/DeleteCommand";
import {
  ExecuteStatementCommandInput,
  ExecuteStatementCommandOutput,
} from "./commands/ExecuteStatementCommand";
import {
  ExecuteTransactionCommandInput,
  ExecuteTransactionCommandOutput,
} from "./commands/ExecuteTransactionCommand";
import { GetCommandInput, GetCommandOutput } from "./commands/GetCommand";
import { PutCommandInput, PutCommandOutput } from "./commands/PutCommand";
import { QueryCommandInput, QueryCommandOutput } from "./commands/QueryCommand";
import { ScanCommandInput, ScanCommandOutput } from "./commands/ScanCommand";
import {
  TransactGetCommandInput,
  TransactGetCommandOutput,
} from "./commands/TransactGetCommand";
import {
  TransactWriteCommandInput,
  TransactWriteCommandOutput,
} from "./commands/TransactWriteCommand";
import {
  UpdateCommandInput,
  UpdateCommandOutput,
} from "./commands/UpdateCommand";
import {
  DynamoDBDocumentClient,
  TranslateConfig,
} from "./DynamoDBDocumentClient";
export declare class DynamoDBDocument extends DynamoDBDocumentClient {
  static from(
    client: DynamoDBClient,
    translateConfig?: TranslateConfig
  ): DynamoDBDocument;
  batchExecuteStatement(
    args: BatchExecuteStatementCommandInput,
    options?: __HttpHandlerOptions
  ): Promise<BatchExecuteStatementCommandOutput>;
  batchExecuteStatement(
    args: BatchExecuteStatementCommandInput,
    cb: (err: any, data?: BatchExecuteStatementCommandOutput) => void
  ): void;
  batchExecuteStatement(
    args: BatchExecuteStatementCommandInput,
    options: __HttpHandlerOptions,
    cb: (err: any, data?: BatchExecuteStatementCommandOutput) => void
  ): void;
  batchGet(
    args: BatchGetCommandInput,
    options?: __HttpHandlerOptions
  ): Promise<BatchGetCommandOutput>;
  batchGet(
    args: BatchGetCommandInput,
    cb: (err: any, data?: BatchGetCommandOutput) => void
  ): void;
  batchGet(
    args: BatchGetCommandInput,
    options: __HttpHandlerOptions,
    cb: (err: any, data?: BatchGetCommandOutput) => void
  ): void;
  batchWrite(
    args: BatchWriteCommandInput,
    options?: __HttpHandlerOptions
  ): Promise<BatchWriteCommandOutput>;
  batchWrite(
    args: BatchWriteCommandInput,
    cb: (err: any, data?: BatchWriteCommandOutput) => void
  ): void;
  batchWrite(
    args: BatchWriteCommandInput,
    options: __HttpHandlerOptions,
    cb: (err: any, data?: BatchWriteCommandOutput) => void
  ): void;
  delete(
    args: DeleteCommandInput,
    options?: __HttpHandlerOptions
  ): Promise<DeleteCommandOutput>;
  delete(
    args: DeleteCommandInput,
    cb: (err: any, data?: DeleteCommandOutput) => void
  ): void;
  delete(
    args: DeleteCommandInput,
    options: __HttpHandlerOptions,
    cb: (err: any, data?: DeleteCommandOutput) => void
  ): void;
  executeStatement(
    args: ExecuteStatementCommandInput,
    options?: __HttpHandlerOptions
  ): Promise<ExecuteStatementCommandOutput>;
  executeStatement(
    args: ExecuteStatementCommandInput,
    cb: (err: any, data?: ExecuteStatementCommandOutput) => void
  ): void;
  executeStatement(
    args: ExecuteStatementCommandInput,
    options: __HttpHandlerOptions,
    cb: (err: any, data?: ExecuteStatementCommandOutput) => void
  ): void;
  executeTransaction(
    args: ExecuteTransactionCommandInput,
    options?: __HttpHandlerOptions
  ): Promise<ExecuteTransactionCommandOutput>;
  executeTransaction(
    args: ExecuteTransactionCommandInput,
    cb: (err: any, data?: ExecuteTransactionCommandOutput) => void
  ): void;
  executeTransaction(
    args: ExecuteTransactionCommandInput,
    options: __HttpHandlerOptions,
    cb: (err: any, data?: ExecuteTransactionCommandOutput) => void
  ): void;
  get(
    args: GetCommandInput,
    options?: __HttpHandlerOptions
  ): Promise<GetCommandOutput>;
  get(
    args: GetCommandInput,
    cb: (err: any, data?: GetCommandOutput) => void
  ): void;
  get(
    args: GetCommandInput,
    options: __HttpHandlerOptions,
    cb: (err: any, data?: GetCommandOutput) => void
  ): void;
  put(
    args: PutCommandInput,
    options?: __HttpHandlerOptions
  ): Promise<PutCommandOutput>;
  put(
    args: PutCommandInput,
    cb: (err: any, data?: PutCommandOutput) => void
  ): void;
  put(
    args: PutCommandInput,
    options: __HttpHandlerOptions,
    cb: (err: any, data?: PutCommandOutput) => void
  ): void;
  query(
    args: QueryCommandInput,
    options?: __HttpHandlerOptions
  ): Promise<QueryCommandOutput>;
  query(
    args: QueryCommandInput,
    cb: (err: any, data?: QueryCommandOutput) => void
  ): void;
  query(
    args: QueryCommandInput,
    options: __HttpHandlerOptions,
    cb: (err: any, data?: QueryCommandOutput) => void
  ): void;
  scan(
    args: ScanCommandInput,
    options?: __HttpHandlerOptions
  ): Promise<ScanCommandOutput>;
  scan(
    args: ScanCommandInput,
    cb: (err: any, data?: ScanCommandOutput) => void
  ): void;
  scan(
    args: ScanCommandInput,
    options: __HttpHandlerOptions,
    cb: (err: any, data?: ScanCommandOutput) => void
  ): void;
  transactGet(
    args: TransactGetCommandInput,
    options?: __HttpHandlerOptions
  ): Promise<TransactGetCommandOutput>;
  transactGet(
    args: TransactGetCommandInput,
    cb: (err: any, data?: TransactGetCommandOutput) => void
  ): void;
  transactGet(
    args: TransactGetCommandInput,
    options: __HttpHandlerOptions,
    cb: (err: any, data?: TransactGetCommandOutput) => void
  ): void;
  transactWrite(
    args: TransactWriteCommandInput,
    options?: __HttpHandlerOptions
  ): Promise<TransactWriteCommandOutput>;
  transactWrite(
    args: TransactWriteCommandInput,
    cb: (err: any, data?: TransactWriteCommandOutput) => void
  ): void;
  transactWrite(
    args: TransactWriteCommandInput,
    options: __HttpHandlerOptions,
    cb: (err: any, data?: TransactWriteCommandOutput) => void
  ): void;
  update(
    args: UpdateCommandInput,
    options?: __HttpHandlerOptions
  ): Promise<UpdateCommandOutput>;
  update(
    args: UpdateCommandInput,
    cb: (err: any, data?: UpdateCommandOutput) => void
  ): void;
  update(
    args: UpdateCommandInput,
    options: __HttpHandlerOptions,
    cb: (err: any, data?: UpdateCommandOutput) => void
  ): void;
}

```

## ./lib/lambda/node_modules/@aws-sdk/lib-dynamodb/dist-types/ts3.4/DynamoDBDocumentClient.d.ts

```typescript
import {
  DynamoDBClient,
  DynamoDBClientResolvedConfig,
  ServiceInputTypes as __ServiceInputTypes,
  ServiceOutputTypes as __ServiceOutputTypes,
} from "@aws-sdk/client-dynamodb";
import { marshallOptions, unmarshallOptions } from "@aws-sdk/util-dynamodb";
import { Client as __Client } from "@smithy/smithy-client";
import { HttpHandlerOptions as __HttpHandlerOptions } from "@smithy/types";
import {
  BatchExecuteStatementCommandInput,
  BatchExecuteStatementCommandOutput,
} from "./commands/BatchExecuteStatementCommand";
import {
  BatchGetCommandInput,
  BatchGetCommandOutput,
} from "./commands/BatchGetCommand";
import {
  BatchWriteCommandInput,
  BatchWriteCommandOutput,
} from "./commands/BatchWriteCommand";
import {
  DeleteCommandInput,
  DeleteCommandOutput,
} from "./commands/DeleteCommand";
import {
  ExecuteStatementCommandInput,
  ExecuteStatementCommandOutput,
} from "./commands/ExecuteStatementCommand";
import {
  ExecuteTransactionCommandInput,
  ExecuteTransactionCommandOutput,
} from "./commands/ExecuteTransactionCommand";
import { GetCommandInput, GetCommandOutput } from "./commands/GetCommand";
import { PutCommandInput, PutCommandOutput } from "./commands/PutCommand";
import { QueryCommandInput, QueryCommandOutput } from "./commands/QueryCommand";
import { ScanCommandInput, ScanCommandOutput } from "./commands/ScanCommand";
import {
  TransactGetCommandInput,
  TransactGetCommandOutput,
} from "./commands/TransactGetCommand";
import {
  TransactWriteCommandInput,
  TransactWriteCommandOutput,
} from "./commands/TransactWriteCommand";
import {
  UpdateCommandInput,
  UpdateCommandOutput,
} from "./commands/UpdateCommand";
export { __Client };
export type ServiceInputTypes =
  | __ServiceInputTypes
  | BatchExecuteStatementCommandInput
  | BatchGetCommandInput
  | BatchWriteCommandInput
  | DeleteCommandInput
  | ExecuteStatementCommandInput
  | ExecuteTransactionCommandInput
  | GetCommandInput
  | PutCommandInput
  | QueryCommandInput
  | ScanCommandInput
  | TransactGetCommandInput
  | TransactWriteCommandInput
  | UpdateCommandInput;
export type ServiceOutputTypes =
  | __ServiceOutputTypes
  | BatchExecuteStatementCommandOutput
  | BatchGetCommandOutput
  | BatchWriteCommandOutput
  | DeleteCommandOutput
  | ExecuteStatementCommandOutput
  | ExecuteTransactionCommandOutput
  | GetCommandOutput
  | PutCommandOutput
  | QueryCommandOutput
  | ScanCommandOutput
  | TransactGetCommandOutput
  | TransactWriteCommandOutput
  | UpdateCommandOutput;
export type TranslateConfig = {
  marshallOptions?: marshallOptions;
  unmarshallOptions?: unmarshallOptions;
};
export type DynamoDBDocumentClientResolvedConfig =
  DynamoDBClientResolvedConfig & {
    translateConfig?: TranslateConfig;
  };
export declare class DynamoDBDocumentClient extends __Client<
  __HttpHandlerOptions,
  ServiceInputTypes,
  ServiceOutputTypes,
  DynamoDBDocumentClientResolvedConfig
> {
  readonly config: DynamoDBDocumentClientResolvedConfig;
  protected constructor(
    client: DynamoDBClient,
    translateConfig?: TranslateConfig
  );
  static from(
    client: DynamoDBClient,
    translateConfig?: TranslateConfig
  ): DynamoDBDocumentClient;
  destroy(): void;
}

```

## ./lib/lambda/node_modules/@aws-sdk/lib-dynamodb/dist-types/ts3.4/baseCommand/DynamoDBDocumentClientCommand.d.ts

```typescript
import { Command as $Command } from "@smithy/smithy-client";
import { MiddlewareStack } from "@smithy/types";
import { KeyNodeChildren } from "../commands/utils";
import { DynamoDBDocumentClientResolvedConfig } from "../DynamoDBDocumentClient";
export declare abstract class DynamoDBDocumentClientCommand<
  Input extends object,
  Output extends object,
  BaseInput extends object,
  BaseOutput extends object,
  ResolvedClientConfiguration
> extends $Command<
  Input | BaseInput,
  Output | BaseOutput,
  ResolvedClientConfiguration
> {
  protected abstract readonly inputKeyNodes: KeyNodeChildren;
  protected abstract readonly outputKeyNodes: KeyNodeChildren;
  protected abstract clientCommand: $Command<
    Input | BaseInput,
    Output | BaseOutput,
    ResolvedClientConfiguration
  >;
  abstract middlewareStack: MiddlewareStack<
    Input | BaseInput,
    Output | BaseOutput
  >;
  protected addMarshallingMiddleware(
    configuration: DynamoDBDocumentClientResolvedConfig
  ): void;
}

```

## ./lib/lambda/node_modules/@aws-sdk/lib-dynamodb/dist-types/ts3.4/commands/BatchExecuteStatementCommand.d.ts

```typescript
import { BatchExecuteStatementCommand as __BatchExecuteStatementCommand } from "@aws-sdk/client-dynamodb";
import { Command as $Command } from "@smithy/smithy-client";
import {
  Handler,
  HttpHandlerOptions as __HttpHandlerOptions,
  MiddlewareStack,
} from "@smithy/types";
import { DynamoDBDocumentClientCommand } from "../baseCommand/DynamoDBDocumentClientCommand";
import {
  DynamoDBDocumentClientResolvedConfig,
  ServiceInputTypes,
  ServiceOutputTypes,
} from "../DynamoDBDocumentClient";
export { DynamoDBDocumentClientCommand, $Command };
export type BatchExecuteStatementCommandInput = Pick<
  __BatchExecuteStatementCommandInput,
  Exclude<keyof __BatchExecuteStatementCommandInput, "Statements">
> & {
  Statements:
    | (Pick<
        BatchStatementRequest,
        Exclude<keyof BatchStatementRequest, "Parameters">
      > & {
        Parameters?: NativeAttributeValue[] | undefined;
      })[]
    | undefined;
};
export type BatchExecuteStatementCommandOutput = Pick<
  __BatchExecuteStatementCommandOutput,
  Exclude<keyof __BatchExecuteStatementCommandOutput, "Responses">
> & {
  Responses?:
    | (Pick<
        BatchStatementResponse,
        Exclude<keyof BatchStatementResponse, "Error" | "Item">
      > & {
        Error?:
          | (Pick<
              BatchStatementError,
              Exclude<keyof BatchStatementError, "Item">
            > & {
              Item?: Record<string, NativeAttributeValue> | undefined;
            })
          | undefined;
        Item?: Record<string, NativeAttributeValue> | undefined;
      })[]
    | undefined;
};
export declare class BatchExecuteStatementCommand extends DynamoDBDocumentClientCommand<
  BatchExecuteStatementCommandInput,
  BatchExecuteStatementCommandOutput,
  __BatchExecuteStatementCommandInput,
  __BatchExecuteStatementCommandOutput,
  DynamoDBDocumentClientResolvedConfig
> {
  readonly input: BatchExecuteStatementCommandInput;
  protected readonly inputKeyNodes: {
    Statements: {
      "*": {
        Parameters: import("../commands/utils").KeyNodeChildren;
      };
    };
  };
  protected readonly outputKeyNodes: {
    Responses: {
      "*": {
        Error: {
          Item: import("../commands/utils").KeyNodeChildren;
        };
        Item: import("../commands/utils").KeyNodeChildren;
      };
    };
  };
  protected readonly clientCommand: __BatchExecuteStatementCommand;
  readonly middlewareStack: MiddlewareStack<
    BatchExecuteStatementCommandInput | __BatchExecuteStatementCommandInput,
    BatchExecuteStatementCommandOutput | __BatchExecuteStatementCommandOutput
  >;
  constructor(input: BatchExecuteStatementCommandInput);
  resolveMiddleware(
    clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>,
    configuration: DynamoDBDocumentClientResolvedConfig,
    options?: __HttpHandlerOptions
  ): Handler<
    BatchExecuteStatementCommandInput,
    BatchExecuteStatementCommandOutput
  >;
}
import {
  BatchExecuteStatementCommandInput as __BatchExecuteStatementCommandInput,
  BatchExecuteStatementCommandOutput as __BatchExecuteStatementCommandOutput,
  BatchStatementError,
  BatchStatementRequest,
  BatchStatementResponse,
} from "@aws-sdk/client-dynamodb";
import { NativeAttributeValue } from "@aws-sdk/util-dynamodb";

```

## ./lib/lambda/node_modules/@aws-sdk/lib-dynamodb/dist-types/ts3.4/commands/BatchGetCommand.d.ts

```typescript
import { BatchGetItemCommand as __BatchGetItemCommand } from "@aws-sdk/client-dynamodb";
import { Command as $Command } from "@smithy/smithy-client";
import {
  Handler,
  HttpHandlerOptions as __HttpHandlerOptions,
  MiddlewareStack,
} from "@smithy/types";
import { DynamoDBDocumentClientCommand } from "../baseCommand/DynamoDBDocumentClientCommand";
import {
  DynamoDBDocumentClientResolvedConfig,
  ServiceInputTypes,
  ServiceOutputTypes,
} from "../DynamoDBDocumentClient";
export { DynamoDBDocumentClientCommand, $Command };
export type BatchGetCommandInput = Pick<
  __BatchGetItemCommandInput,
  Exclude<keyof __BatchGetItemCommandInput, "RequestItems">
> & {
  RequestItems:
    | Record<
        string,
        Pick<KeysAndAttributes, Exclude<keyof KeysAndAttributes, "Keys">> & {
          Keys: Record<string, NativeAttributeValue>[] | undefined;
        }
      >
    | undefined;
};
export type BatchGetCommandOutput = Pick<
  __BatchGetItemCommandOutput,
  Exclude<keyof __BatchGetItemCommandOutput, "Responses" | "UnprocessedKeys">
> & {
  Responses?:
    | Record<string, Record<string, NativeAttributeValue>[]>
    | undefined;
  UnprocessedKeys?:
    | Record<
        string,
        Pick<KeysAndAttributes, Exclude<keyof KeysAndAttributes, "Keys">> & {
          Keys: Record<string, NativeAttributeValue>[] | undefined;
        }
      >
    | undefined;
};
export declare class BatchGetCommand extends DynamoDBDocumentClientCommand<
  BatchGetCommandInput,
  BatchGetCommandOutput,
  __BatchGetItemCommandInput,
  __BatchGetItemCommandOutput,
  DynamoDBDocumentClientResolvedConfig
> {
  readonly input: BatchGetCommandInput;
  protected readonly inputKeyNodes: {
    RequestItems: {
      "*": {
        Keys: {
          "*": import("../commands/utils").KeyNodeChildren;
        };
      };
    };
  };
  protected readonly outputKeyNodes: {
    Responses: {
      "*": {
        "*": import("../commands/utils").KeyNodeChildren;
      };
    };
    UnprocessedKeys: {
      "*": {
        Keys: {
          "*": import("../commands/utils").KeyNodeChildren;
        };
      };
    };
  };
  protected readonly clientCommand: __BatchGetItemCommand;
  readonly middlewareStack: MiddlewareStack<
    BatchGetCommandInput | __BatchGetItemCommandInput,
    BatchGetCommandOutput | __BatchGetItemCommandOutput
  >;
  constructor(input: BatchGetCommandInput);
  resolveMiddleware(
    clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>,
    configuration: DynamoDBDocumentClientResolvedConfig,
    options?: __HttpHandlerOptions
  ): Handler<BatchGetCommandInput, BatchGetCommandOutput>;
}
import {
  BatchGetItemCommandInput as __BatchGetItemCommandInput,
  BatchGetItemCommandOutput as __BatchGetItemCommandOutput,
  KeysAndAttributes,
} from "@aws-sdk/client-dynamodb";
import { NativeAttributeValue } from "@aws-sdk/util-dynamodb";

```

## ./lib/lambda/node_modules/@aws-sdk/lib-dynamodb/dist-types/ts3.4/commands/BatchWriteCommand.d.ts

```typescript
import { BatchWriteItemCommand as __BatchWriteItemCommand } from "@aws-sdk/client-dynamodb";
import { Command as $Command } from "@smithy/smithy-client";
import {
  Handler,
  HttpHandlerOptions as __HttpHandlerOptions,
  MiddlewareStack,
} from "@smithy/types";
import { DynamoDBDocumentClientCommand } from "../baseCommand/DynamoDBDocumentClientCommand";
import {
  DynamoDBDocumentClientResolvedConfig,
  ServiceInputTypes,
  ServiceOutputTypes,
} from "../DynamoDBDocumentClient";
export { DynamoDBDocumentClientCommand, $Command };
export type BatchWriteCommandInput = Pick<
  __BatchWriteItemCommandInput,
  Exclude<keyof __BatchWriteItemCommandInput, "RequestItems">
> & {
  RequestItems:
    | Record<
        string,
        (Pick<
          WriteRequest,
          Exclude<keyof WriteRequest, "PutRequest" | "DeleteRequest">
        > & {
          PutRequest?:
            | (Pick<PutRequest, Exclude<keyof PutRequest, "Item">> & {
                Item: Record<string, NativeAttributeValue> | undefined;
              })
            | undefined;
          DeleteRequest?:
            | (Pick<DeleteRequest, Exclude<keyof DeleteRequest, "Key">> & {
                Key: Record<string, NativeAttributeValue> | undefined;
              })
            | undefined;
        })[]
      >
    | undefined;
};
export type BatchWriteCommandOutput = Pick<
  __BatchWriteItemCommandOutput,
  Exclude<
    keyof __BatchWriteItemCommandOutput,
    "UnprocessedItems" | "ItemCollectionMetrics"
  >
> & {
  UnprocessedItems?:
    | Record<
        string,
        (Pick<
          WriteRequest,
          Exclude<keyof WriteRequest, "PutRequest" | "DeleteRequest">
        > & {
          PutRequest?:
            | (Pick<PutRequest, Exclude<keyof PutRequest, "Item">> & {
                Item: Record<string, NativeAttributeValue> | undefined;
              })
            | undefined;
          DeleteRequest?:
            | (Pick<DeleteRequest, Exclude<keyof DeleteRequest, "Key">> & {
                Key: Record<string, NativeAttributeValue> | undefined;
              })
            | undefined;
        })[]
      >
    | undefined;
  ItemCollectionMetrics?:
    | Record<
        string,
        (Pick<
          ItemCollectionMetrics,
          Exclude<keyof ItemCollectionMetrics, "ItemCollectionKey">
        > & {
          ItemCollectionKey?: Record<string, NativeAttributeValue> | undefined;
        })[]
      >
    | undefined;
};
export declare class BatchWriteCommand extends DynamoDBDocumentClientCommand<
  BatchWriteCommandInput,
  BatchWriteCommandOutput,
  __BatchWriteItemCommandInput,
  __BatchWriteItemCommandOutput,
  DynamoDBDocumentClientResolvedConfig
> {
  readonly input: BatchWriteCommandInput;
  protected readonly inputKeyNodes: {
    RequestItems: {
      "*": {
        "*": {
          PutRequest: {
            Item: import("../commands/utils").KeyNodeChildren;
          };
          DeleteRequest: {
            Key: import("../commands/utils").KeyNodeChildren;
          };
        };
      };
    };
  };
  protected readonly outputKeyNodes: {
    UnprocessedItems: {
      "*": {
        "*": {
          PutRequest: {
            Item: import("../commands/utils").KeyNodeChildren;
          };
          DeleteRequest: {
            Key: import("../commands/utils").KeyNodeChildren;
          };
        };
      };
    };
    ItemCollectionMetrics: {
      "*": {
        "*": {
          ItemCollectionKey: import("../commands/utils").KeyNodeChildren;
        };
      };
    };
  };
  protected readonly clientCommand: __BatchWriteItemCommand;
  readonly middlewareStack: MiddlewareStack<
    BatchWriteCommandInput | __BatchWriteItemCommandInput,
    BatchWriteCommandOutput | __BatchWriteItemCommandOutput
  >;
  constructor(input: BatchWriteCommandInput);
  resolveMiddleware(
    clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>,
    configuration: DynamoDBDocumentClientResolvedConfig,
    options?: __HttpHandlerOptions
  ): Handler<BatchWriteCommandInput, BatchWriteCommandOutput>;
}
import {
  BatchWriteItemCommandInput as __BatchWriteItemCommandInput,
  BatchWriteItemCommandOutput as __BatchWriteItemCommandOutput,
  DeleteRequest,
  ItemCollectionMetrics,
  PutRequest,
  WriteRequest,
} from "@aws-sdk/client-dynamodb";
import { NativeAttributeValue } from "@aws-sdk/util-dynamodb";

```

## ./lib/lambda/node_modules/@aws-sdk/lib-dynamodb/dist-types/ts3.4/commands/DeleteCommand.d.ts

```typescript
import { DeleteItemCommand as __DeleteItemCommand } from "@aws-sdk/client-dynamodb";
import { Command as $Command } from "@smithy/smithy-client";
import {
  Handler,
  HttpHandlerOptions as __HttpHandlerOptions,
  MiddlewareStack,
} from "@smithy/types";
import { DynamoDBDocumentClientCommand } from "../baseCommand/DynamoDBDocumentClientCommand";
import {
  DynamoDBDocumentClientResolvedConfig,
  ServiceInputTypes,
  ServiceOutputTypes,
} from "../DynamoDBDocumentClient";
export { DynamoDBDocumentClientCommand, $Command };
export type DeleteCommandInput = Pick<
  __DeleteItemCommandInput,
  Exclude<
    keyof __DeleteItemCommandInput,
    "Key" | "Expected" | "ExpressionAttributeValues"
  >
> & {
  Key: Record<string, NativeAttributeValue> | undefined;
  Expected?:
    | Record<
        string,
        Pick<
          ExpectedAttributeValue,
          Exclude<keyof ExpectedAttributeValue, "Value" | "AttributeValueList">
        > & {
          Value?: NativeAttributeValue | undefined;
          AttributeValueList?: NativeAttributeValue[] | undefined;
        }
      >
    | undefined;
  ExpressionAttributeValues?: Record<string, NativeAttributeValue> | undefined;
};
export type DeleteCommandOutput = Pick<
  __DeleteItemCommandOutput,
  Exclude<
    keyof __DeleteItemCommandOutput,
    "Attributes" | "ItemCollectionMetrics"
  >
> & {
  Attributes?: Record<string, NativeAttributeValue> | undefined;
  ItemCollectionMetrics?:
    | (Pick<
        ItemCollectionMetrics,
        Exclude<keyof ItemCollectionMetrics, "ItemCollectionKey">
      > & {
        ItemCollectionKey?: Record<string, NativeAttributeValue> | undefined;
      })
    | undefined;
};
export declare class DeleteCommand extends DynamoDBDocumentClientCommand<
  DeleteCommandInput,
  DeleteCommandOutput,
  __DeleteItemCommandInput,
  __DeleteItemCommandOutput,
  DynamoDBDocumentClientResolvedConfig
> {
  readonly input: DeleteCommandInput;
  protected readonly inputKeyNodes: {
    Key: import("../commands/utils").KeyNodeChildren;
    Expected: {
      "*": {
        Value: null;
        AttributeValueList: import("../commands/utils").KeyNodeChildren;
      };
    };
    ExpressionAttributeValues: import("../commands/utils").KeyNodeChildren;
  };
  protected readonly outputKeyNodes: {
    Attributes: import("../commands/utils").KeyNodeChildren;
    ItemCollectionMetrics: {
      ItemCollectionKey: import("../commands/utils").KeyNodeChildren;
    };
  };
  protected readonly clientCommand: __DeleteItemCommand;
  readonly middlewareStack: MiddlewareStack<
    DeleteCommandInput | __DeleteItemCommandInput,
    DeleteCommandOutput | __DeleteItemCommandOutput
  >;
  constructor(input: DeleteCommandInput);
  resolveMiddleware(
    clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>,
    configuration: DynamoDBDocumentClientResolvedConfig,
    options?: __HttpHandlerOptions
  ): Handler<DeleteCommandInput, DeleteCommandOutput>;
}
import {
  DeleteItemCommandInput as __DeleteItemCommandInput,
  DeleteItemCommandOutput as __DeleteItemCommandOutput,
  ExpectedAttributeValue,
  ItemCollectionMetrics,
} from "@aws-sdk/client-dynamodb";
import { NativeAttributeValue } from "@aws-sdk/util-dynamodb";

```

## ./lib/lambda/node_modules/@aws-sdk/lib-dynamodb/dist-types/ts3.4/commands/ExecuteStatementCommand.d.ts

```typescript
import { ExecuteStatementCommand as __ExecuteStatementCommand } from "@aws-sdk/client-dynamodb";
import { Command as $Command } from "@smithy/smithy-client";
import {
  Handler,
  HttpHandlerOptions as __HttpHandlerOptions,
  MiddlewareStack,
} from "@smithy/types";
import { DynamoDBDocumentClientCommand } from "../baseCommand/DynamoDBDocumentClientCommand";
import {
  DynamoDBDocumentClientResolvedConfig,
  ServiceInputTypes,
  ServiceOutputTypes,
} from "../DynamoDBDocumentClient";
export { DynamoDBDocumentClientCommand, $Command };
export type ExecuteStatementCommandInput = Pick<
  __ExecuteStatementCommandInput,
  Exclude<keyof __ExecuteStatementCommandInput, "Parameters">
> & {
  Parameters?: NativeAttributeValue[] | undefined;
};
export type ExecuteStatementCommandOutput = Pick<
  __ExecuteStatementCommandOutput,
  Exclude<keyof __ExecuteStatementCommandOutput, "Items" | "LastEvaluatedKey">
> & {
  Items?: Record<string, NativeAttributeValue>[] | undefined;
  LastEvaluatedKey?: Record<string, NativeAttributeValue> | undefined;
};
export declare class ExecuteStatementCommand extends DynamoDBDocumentClientCommand<
  ExecuteStatementCommandInput,
  ExecuteStatementCommandOutput,
  __ExecuteStatementCommandInput,
  __ExecuteStatementCommandOutput,
  DynamoDBDocumentClientResolvedConfig
> {
  readonly input: ExecuteStatementCommandInput;
  protected readonly inputKeyNodes: {
    Parameters: import("../commands/utils").KeyNodeChildren;
  };
  protected readonly outputKeyNodes: {
    Items: {
      "*": import("../commands/utils").KeyNodeChildren;
    };
    LastEvaluatedKey: import("../commands/utils").KeyNodeChildren;
  };
  protected readonly clientCommand: __ExecuteStatementCommand;
  readonly middlewareStack: MiddlewareStack<
    ExecuteStatementCommandInput | __ExecuteStatementCommandInput,
    ExecuteStatementCommandOutput | __ExecuteStatementCommandOutput
  >;
  constructor(input: ExecuteStatementCommandInput);
  resolveMiddleware(
    clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>,
    configuration: DynamoDBDocumentClientResolvedConfig,
    options?: __HttpHandlerOptions
  ): Handler<ExecuteStatementCommandInput, ExecuteStatementCommandOutput>;
}
import {
  ExecuteStatementCommandInput as __ExecuteStatementCommandInput,
  ExecuteStatementCommandOutput as __ExecuteStatementCommandOutput,
} from "@aws-sdk/client-dynamodb";
import { NativeAttributeValue } from "@aws-sdk/util-dynamodb";

```

## ./lib/lambda/node_modules/@aws-sdk/lib-dynamodb/dist-types/ts3.4/commands/ExecuteTransactionCommand.d.ts

```typescript
import { ExecuteTransactionCommand as __ExecuteTransactionCommand } from "@aws-sdk/client-dynamodb";
import { Command as $Command } from "@smithy/smithy-client";
import {
  Handler,
  HttpHandlerOptions as __HttpHandlerOptions,
  MiddlewareStack,
} from "@smithy/types";
import { DynamoDBDocumentClientCommand } from "../baseCommand/DynamoDBDocumentClientCommand";
import {
  DynamoDBDocumentClientResolvedConfig,
  ServiceInputTypes,
  ServiceOutputTypes,
} from "../DynamoDBDocumentClient";
export { DynamoDBDocumentClientCommand, $Command };
export type ExecuteTransactionCommandInput = Pick<
  __ExecuteTransactionCommandInput,
  Exclude<keyof __ExecuteTransactionCommandInput, "TransactStatements">
> & {
  TransactStatements:
    | (Pick<
        ParameterizedStatement,
        Exclude<keyof ParameterizedStatement, "Parameters">
      > & {
        Parameters?: NativeAttributeValue[] | undefined;
      })[]
    | undefined;
};
export type ExecuteTransactionCommandOutput = Pick<
  __ExecuteTransactionCommandOutput,
  Exclude<keyof __ExecuteTransactionCommandOutput, "Responses">
> & {
  Responses?:
    | (Pick<ItemResponse, Exclude<keyof ItemResponse, "Item">> & {
        Item?: Record<string, NativeAttributeValue> | undefined;
      })[]
    | undefined;
};
export declare class ExecuteTransactionCommand extends DynamoDBDocumentClientCommand<
  ExecuteTransactionCommandInput,
  ExecuteTransactionCommandOutput,
  __ExecuteTransactionCommandInput,
  __ExecuteTransactionCommandOutput,
  DynamoDBDocumentClientResolvedConfig
> {
  readonly input: ExecuteTransactionCommandInput;
  protected readonly inputKeyNodes: {
    TransactStatements: {
      "*": {
        Parameters: import("../commands/utils").KeyNodeChildren;
      };
    };
  };
  protected readonly outputKeyNodes: {
    Responses: {
      "*": {
        Item: import("../commands/utils").KeyNodeChildren;
      };
    };
  };
  protected readonly clientCommand: __ExecuteTransactionCommand;
  readonly middlewareStack: MiddlewareStack<
    ExecuteTransactionCommandInput | __ExecuteTransactionCommandInput,
    ExecuteTransactionCommandOutput | __ExecuteTransactionCommandOutput
  >;
  constructor(input: ExecuteTransactionCommandInput);
  resolveMiddleware(
    clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>,
    configuration: DynamoDBDocumentClientResolvedConfig,
    options?: __HttpHandlerOptions
  ): Handler<ExecuteTransactionCommandInput, ExecuteTransactionCommandOutput>;
}
import {
  ExecuteTransactionCommandInput as __ExecuteTransactionCommandInput,
  ExecuteTransactionCommandOutput as __ExecuteTransactionCommandOutput,
  ItemResponse,
  ParameterizedStatement,
} from "@aws-sdk/client-dynamodb";
import { NativeAttributeValue } from "@aws-sdk/util-dynamodb";

```

## ./lib/lambda/node_modules/@aws-sdk/lib-dynamodb/dist-types/ts3.4/commands/GetCommand.d.ts

```typescript
import { GetItemCommand as __GetItemCommand } from "@aws-sdk/client-dynamodb";
import { Command as $Command } from "@smithy/smithy-client";
import {
  Handler,
  HttpHandlerOptions as __HttpHandlerOptions,
  MiddlewareStack,
} from "@smithy/types";
import { DynamoDBDocumentClientCommand } from "../baseCommand/DynamoDBDocumentClientCommand";
import {
  DynamoDBDocumentClientResolvedConfig,
  ServiceInputTypes,
  ServiceOutputTypes,
} from "../DynamoDBDocumentClient";
export { DynamoDBDocumentClientCommand, $Command };
export type GetCommandInput = Pick<
  __GetItemCommandInput,
  Exclude<keyof __GetItemCommandInput, "Key">
> & {
  Key: Record<string, NativeAttributeValue> | undefined;
};
export type GetCommandOutput = Pick<
  __GetItemCommandOutput,
  Exclude<keyof __GetItemCommandOutput, "Item">
> & {
  Item?: Record<string, NativeAttributeValue> | undefined;
};
export declare class GetCommand extends DynamoDBDocumentClientCommand<
  GetCommandInput,
  GetCommandOutput,
  __GetItemCommandInput,
  __GetItemCommandOutput,
  DynamoDBDocumentClientResolvedConfig
> {
  readonly input: GetCommandInput;
  protected readonly inputKeyNodes: {
    Key: import("../commands/utils").KeyNodeChildren;
  };
  protected readonly outputKeyNodes: {
    Item: import("../commands/utils").KeyNodeChildren;
  };
  protected readonly clientCommand: __GetItemCommand;
  readonly middlewareStack: MiddlewareStack<
    GetCommandInput | __GetItemCommandInput,
    GetCommandOutput | __GetItemCommandOutput
  >;
  constructor(input: GetCommandInput);
  resolveMiddleware(
    clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>,
    configuration: DynamoDBDocumentClientResolvedConfig,
    options?: __HttpHandlerOptions
  ): Handler<GetCommandInput, GetCommandOutput>;
}
import {
  GetItemCommandInput as __GetItemCommandInput,
  GetItemCommandOutput as __GetItemCommandOutput,
} from "@aws-sdk/client-dynamodb";
import { NativeAttributeValue } from "@aws-sdk/util-dynamodb";

```

## ./lib/lambda/node_modules/@aws-sdk/lib-dynamodb/dist-types/ts3.4/commands/PutCommand.d.ts

```typescript
import { PutItemCommand as __PutItemCommand } from "@aws-sdk/client-dynamodb";
import { Command as $Command } from "@smithy/smithy-client";
import {
  Handler,
  HttpHandlerOptions as __HttpHandlerOptions,
  MiddlewareStack,
} from "@smithy/types";
import { DynamoDBDocumentClientCommand } from "../baseCommand/DynamoDBDocumentClientCommand";
import {
  DynamoDBDocumentClientResolvedConfig,
  ServiceInputTypes,
  ServiceOutputTypes,
} from "../DynamoDBDocumentClient";
export { DynamoDBDocumentClientCommand, $Command };
export type PutCommandInput = Pick<
  __PutItemCommandInput,
  Exclude<
    keyof __PutItemCommandInput,
    "Item" | "Expected" | "ExpressionAttributeValues"
  >
> & {
  Item: Record<string, NativeAttributeValue> | undefined;
  Expected?:
    | Record<
        string,
        Pick<
          ExpectedAttributeValue,
          Exclude<keyof ExpectedAttributeValue, "Value" | "AttributeValueList">
        > & {
          Value?: NativeAttributeValue | undefined;
          AttributeValueList?: NativeAttributeValue[] | undefined;
        }
      >
    | undefined;
  ExpressionAttributeValues?: Record<string, NativeAttributeValue> | undefined;
};
export type PutCommandOutput = Pick<
  __PutItemCommandOutput,
  Exclude<keyof __PutItemCommandOutput, "Attributes" | "ItemCollectionMetrics">
> & {
  Attributes?: Record<string, NativeAttributeValue> | undefined;
  ItemCollectionMetrics?:
    | (Pick<
        ItemCollectionMetrics,
        Exclude<keyof ItemCollectionMetrics, "ItemCollectionKey">
      > & {
        ItemCollectionKey?: Record<string, NativeAttributeValue> | undefined;
      })
    | undefined;
};
export declare class PutCommand extends DynamoDBDocumentClientCommand<
  PutCommandInput,
  PutCommandOutput,
  __PutItemCommandInput,
  __PutItemCommandOutput,
  DynamoDBDocumentClientResolvedConfig
> {
  readonly input: PutCommandInput;
  protected readonly inputKeyNodes: {
    Item: import("../commands/utils").KeyNodeChildren;
    Expected: {
      "*": {
        Value: null;
        AttributeValueList: import("../commands/utils").KeyNodeChildren;
      };
    };
    ExpressionAttributeValues: import("../commands/utils").KeyNodeChildren;
  };
  protected readonly outputKeyNodes: {
    Attributes: import("../commands/utils").KeyNodeChildren;
    ItemCollectionMetrics: {
      ItemCollectionKey: import("../commands/utils").KeyNodeChildren;
    };
  };
  protected readonly clientCommand: __PutItemCommand;
  readonly middlewareStack: MiddlewareStack<
    PutCommandInput | __PutItemCommandInput,
    PutCommandOutput | __PutItemCommandOutput
  >;
  constructor(input: PutCommandInput);
  resolveMiddleware(
    clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>,
    configuration: DynamoDBDocumentClientResolvedConfig,
    options?: __HttpHandlerOptions
  ): Handler<PutCommandInput, PutCommandOutput>;
}
import {
  ExpectedAttributeValue,
  ItemCollectionMetrics,
  PutItemCommandInput as __PutItemCommandInput,
  PutItemCommandOutput as __PutItemCommandOutput,
} from "@aws-sdk/client-dynamodb";
import { NativeAttributeValue } from "@aws-sdk/util-dynamodb";

```

## ./lib/lambda/node_modules/@aws-sdk/lib-dynamodb/dist-types/ts3.4/commands/QueryCommand.d.ts

```typescript
import { QueryCommand as __QueryCommand } from "@aws-sdk/client-dynamodb";
import { Command as $Command } from "@smithy/smithy-client";
import {
  Handler,
  HttpHandlerOptions as __HttpHandlerOptions,
  MiddlewareStack,
} from "@smithy/types";
import { DynamoDBDocumentClientCommand } from "../baseCommand/DynamoDBDocumentClientCommand";
import {
  DynamoDBDocumentClientResolvedConfig,
  ServiceInputTypes,
  ServiceOutputTypes,
} from "../DynamoDBDocumentClient";
export { DynamoDBDocumentClientCommand, $Command };
export type QueryCommandInput = Pick<
  __QueryCommandInput,
  Exclude<
    keyof __QueryCommandInput,
    | "KeyConditions"
    | "QueryFilter"
    | "ExclusiveStartKey"
    | "ExpressionAttributeValues"
  >
> & {
  KeyConditions?:
    | Record<
        string,
        Pick<Condition, Exclude<keyof Condition, "AttributeValueList">> & {
          AttributeValueList?: NativeAttributeValue[] | undefined;
        }
      >
    | undefined;
  QueryFilter?:
    | Record<
        string,
        Pick<Condition, Exclude<keyof Condition, "AttributeValueList">> & {
          AttributeValueList?: NativeAttributeValue[] | undefined;
        }
      >
    | undefined;
  ExclusiveStartKey?: Record<string, NativeAttributeValue> | undefined;
  ExpressionAttributeValues?: Record<string, NativeAttributeValue> | undefined;
};
export type QueryCommandOutput = Pick<
  __QueryCommandOutput,
  Exclude<keyof __QueryCommandOutput, "Items" | "LastEvaluatedKey">
> & {
  Items?: Record<string, NativeAttributeValue>[] | undefined;
  LastEvaluatedKey?: Record<string, NativeAttributeValue> | undefined;
};
export declare class QueryCommand extends DynamoDBDocumentClientCommand<
  QueryCommandInput,
  QueryCommandOutput,
  __QueryCommandInput,
  __QueryCommandOutput,
  DynamoDBDocumentClientResolvedConfig
> {
  readonly input: QueryCommandInput;
  protected readonly inputKeyNodes: {
    KeyConditions: {
      "*": {
        AttributeValueList: import("../commands/utils").KeyNodeChildren;
      };
    };
    QueryFilter: {
      "*": {
        AttributeValueList: import("../commands/utils").KeyNodeChildren;
      };
    };
    ExclusiveStartKey: import("../commands/utils").KeyNodeChildren;
    ExpressionAttributeValues: import("../commands/utils").KeyNodeChildren;
  };
  protected readonly outputKeyNodes: {
    Items: {
      "*": import("../commands/utils").KeyNodeChildren;
    };
    LastEvaluatedKey: import("../commands/utils").KeyNodeChildren;
  };
  protected readonly clientCommand: __QueryCommand;
  readonly middlewareStack: MiddlewareStack<
    QueryCommandInput | __QueryCommandInput,
    QueryCommandOutput | __QueryCommandOutput
  >;
  constructor(input: QueryCommandInput);
  resolveMiddleware(
    clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>,
    configuration: DynamoDBDocumentClientResolvedConfig,
    options?: __HttpHandlerOptions
  ): Handler<QueryCommandInput, QueryCommandOutput>;
}
import {
  Condition,
  QueryCommandInput as __QueryCommandInput,
  QueryCommandOutput as __QueryCommandOutput,
} from "@aws-sdk/client-dynamodb";
import { NativeAttributeValue } from "@aws-sdk/util-dynamodb";

```

## ./lib/lambda/node_modules/@aws-sdk/lib-dynamodb/dist-types/ts3.4/commands/ScanCommand.d.ts

```typescript
import { ScanCommand as __ScanCommand } from "@aws-sdk/client-dynamodb";
import { Command as $Command } from "@smithy/smithy-client";
import {
  Handler,
  HttpHandlerOptions as __HttpHandlerOptions,
  MiddlewareStack,
} from "@smithy/types";
import { DynamoDBDocumentClientCommand } from "../baseCommand/DynamoDBDocumentClientCommand";
import {
  DynamoDBDocumentClientResolvedConfig,
  ServiceInputTypes,
  ServiceOutputTypes,
} from "../DynamoDBDocumentClient";
export { DynamoDBDocumentClientCommand, $Command };
export type ScanCommandInput = Pick<
  __ScanCommandInput,
  Exclude<
    keyof __ScanCommandInput,
    "ScanFilter" | "ExclusiveStartKey" | "ExpressionAttributeValues"
  >
> & {
  ScanFilter?:
    | Record<
        string,
        Pick<Condition, Exclude<keyof Condition, "AttributeValueList">> & {
          AttributeValueList?: NativeAttributeValue[] | undefined;
        }
      >
    | undefined;
  ExclusiveStartKey?: Record<string, NativeAttributeValue> | undefined;
  ExpressionAttributeValues?: Record<string, NativeAttributeValue> | undefined;
};
export type ScanCommandOutput = Pick<
  __ScanCommandOutput,
  Exclude<keyof __ScanCommandOutput, "Items" | "LastEvaluatedKey">
> & {
  Items?: Record<string, NativeAttributeValue>[] | undefined;
  LastEvaluatedKey?: Record<string, NativeAttributeValue> | undefined;
};
export declare class ScanCommand extends DynamoDBDocumentClientCommand<
  ScanCommandInput,
  ScanCommandOutput,
  __ScanCommandInput,
  __ScanCommandOutput,
  DynamoDBDocumentClientResolvedConfig
> {
  readonly input: ScanCommandInput;
  protected readonly inputKeyNodes: {
    ScanFilter: {
      "*": {
        AttributeValueList: import("../commands/utils").KeyNodeChildren;
      };
    };
    ExclusiveStartKey: import("../commands/utils").KeyNodeChildren;
    ExpressionAttributeValues: import("../commands/utils").KeyNodeChildren;
  };
  protected readonly outputKeyNodes: {
    Items: {
      "*": import("../commands/utils").KeyNodeChildren;
    };
    LastEvaluatedKey: import("../commands/utils").KeyNodeChildren;
  };
  protected readonly clientCommand: __ScanCommand;
  readonly middlewareStack: MiddlewareStack<
    ScanCommandInput | __ScanCommandInput,
    ScanCommandOutput | __ScanCommandOutput
  >;
  constructor(input: ScanCommandInput);
  resolveMiddleware(
    clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>,
    configuration: DynamoDBDocumentClientResolvedConfig,
    options?: __HttpHandlerOptions
  ): Handler<ScanCommandInput, ScanCommandOutput>;
}
import {
  Condition,
  ScanCommandInput as __ScanCommandInput,
  ScanCommandOutput as __ScanCommandOutput,
} from "@aws-sdk/client-dynamodb";
import { NativeAttributeValue } from "@aws-sdk/util-dynamodb";

```

## ./lib/lambda/node_modules/@aws-sdk/lib-dynamodb/dist-types/ts3.4/commands/TransactGetCommand.d.ts

```typescript
import { TransactGetItemsCommand as __TransactGetItemsCommand } from "@aws-sdk/client-dynamodb";
import { Command as $Command } from "@smithy/smithy-client";
import {
  Handler,
  HttpHandlerOptions as __HttpHandlerOptions,
  MiddlewareStack,
} from "@smithy/types";
import { DynamoDBDocumentClientCommand } from "../baseCommand/DynamoDBDocumentClientCommand";
import {
  DynamoDBDocumentClientResolvedConfig,
  ServiceInputTypes,
  ServiceOutputTypes,
} from "../DynamoDBDocumentClient";
export { DynamoDBDocumentClientCommand, $Command };
export type TransactGetCommandInput = Pick<
  __TransactGetItemsCommandInput,
  Exclude<keyof __TransactGetItemsCommandInput, "TransactItems">
> & {
  TransactItems:
    | (Pick<TransactGetItem, Exclude<keyof TransactGetItem, "Get">> & {
        Get:
          | (Pick<Get, Exclude<keyof Get, "Key">> & {
              Key: Record<string, NativeAttributeValue> | undefined;
            })
          | undefined;
      })[]
    | undefined;
};
export type TransactGetCommandOutput = Pick<
  __TransactGetItemsCommandOutput,
  Exclude<keyof __TransactGetItemsCommandOutput, "Responses">
> & {
  Responses?:
    | (Pick<ItemResponse, Exclude<keyof ItemResponse, "Item">> & {
        Item?: Record<string, NativeAttributeValue> | undefined;
      })[]
    | undefined;
};
export declare class TransactGetCommand extends DynamoDBDocumentClientCommand<
  TransactGetCommandInput,
  TransactGetCommandOutput,
  __TransactGetItemsCommandInput,
  __TransactGetItemsCommandOutput,
  DynamoDBDocumentClientResolvedConfig
> {
  readonly input: TransactGetCommandInput;
  protected readonly inputKeyNodes: {
    TransactItems: {
      "*": {
        Get: {
          Key: import("../commands/utils").KeyNodeChildren;
        };
      };
    };
  };
  protected readonly outputKeyNodes: {
    Responses: {
      "*": {
        Item: import("../commands/utils").KeyNodeChildren;
      };
    };
  };
  protected readonly clientCommand: __TransactGetItemsCommand;
  readonly middlewareStack: MiddlewareStack<
    TransactGetCommandInput | __TransactGetItemsCommandInput,
    TransactGetCommandOutput | __TransactGetItemsCommandOutput
  >;
  constructor(input: TransactGetCommandInput);
  resolveMiddleware(
    clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>,
    configuration: DynamoDBDocumentClientResolvedConfig,
    options?: __HttpHandlerOptions
  ): Handler<TransactGetCommandInput, TransactGetCommandOutput>;
}
import {
  Get,
  ItemResponse,
  TransactGetItem,
  TransactGetItemsCommandInput as __TransactGetItemsCommandInput,
  TransactGetItemsCommandOutput as __TransactGetItemsCommandOutput,
} from "@aws-sdk/client-dynamodb";
import { NativeAttributeValue } from "@aws-sdk/util-dynamodb";

```

## ./lib/lambda/node_modules/@aws-sdk/lib-dynamodb/dist-types/ts3.4/commands/TransactWriteCommand.d.ts

```typescript
import { TransactWriteItemsCommand as __TransactWriteItemsCommand } from "@aws-sdk/client-dynamodb";
import { Command as $Command } from "@smithy/smithy-client";
import {
  Handler,
  HttpHandlerOptions as __HttpHandlerOptions,
  MiddlewareStack,
} from "@smithy/types";
import { DynamoDBDocumentClientCommand } from "../baseCommand/DynamoDBDocumentClientCommand";
import {
  DynamoDBDocumentClientResolvedConfig,
  ServiceInputTypes,
  ServiceOutputTypes,
} from "../DynamoDBDocumentClient";
export { DynamoDBDocumentClientCommand, $Command };
export type TransactWriteCommandInput = Pick<
  __TransactWriteItemsCommandInput,
  Exclude<keyof __TransactWriteItemsCommandInput, "TransactItems">
> & {
  TransactItems:
    | (Pick<
        TransactWriteItem,
        Exclude<
          keyof TransactWriteItem,
          "ConditionCheck" | "Put" | "Delete" | "Update"
        >
      > & {
        ConditionCheck?:
          | (Pick<
              ConditionCheck,
              Exclude<keyof ConditionCheck, "Key" | "ExpressionAttributeValues">
            > & {
              Key: Record<string, NativeAttributeValue> | undefined;
              ExpressionAttributeValues?:
                | Record<string, NativeAttributeValue>
                | undefined;
            })
          | undefined;
        Put?:
          | (Pick<
              Put,
              Exclude<keyof Put, "Item" | "ExpressionAttributeValues">
            > & {
              Item: Record<string, NativeAttributeValue> | undefined;
              ExpressionAttributeValues?:
                | Record<string, NativeAttributeValue>
                | undefined;
            })
          | undefined;
        Delete?:
          | (Pick<
              Delete,
              Exclude<keyof Delete, "Key" | "ExpressionAttributeValues">
            > & {
              Key: Record<string, NativeAttributeValue> | undefined;
              ExpressionAttributeValues?:
                | Record<string, NativeAttributeValue>
                | undefined;
            })
          | undefined;
        Update?:
          | (Pick<
              Update,
              Exclude<keyof Update, "Key" | "ExpressionAttributeValues">
            > & {
              Key: Record<string, NativeAttributeValue> | undefined;
              ExpressionAttributeValues?:
                | Record<string, NativeAttributeValue>
                | undefined;
            })
          | undefined;
      })[]
    | undefined;
};
export type TransactWriteCommandOutput = Pick<
  __TransactWriteItemsCommandOutput,
  Exclude<keyof __TransactWriteItemsCommandOutput, "ItemCollectionMetrics">
> & {
  ItemCollectionMetrics?:
    | Record<
        string,
        (Pick<
          ItemCollectionMetrics,
          Exclude<keyof ItemCollectionMetrics, "ItemCollectionKey">
        > & {
          ItemCollectionKey?: Record<string, NativeAttributeValue> | undefined;
        })[]
      >
    | undefined;
};
export declare class TransactWriteCommand extends DynamoDBDocumentClientCommand<
  TransactWriteCommandInput,
  TransactWriteCommandOutput,
  __TransactWriteItemsCommandInput,
  __TransactWriteItemsCommandOutput,
  DynamoDBDocumentClientResolvedConfig
> {
  readonly input: TransactWriteCommandInput;
  protected readonly inputKeyNodes: {
    TransactItems: {
      "*": {
        ConditionCheck: {
          Key: import("../commands/utils").KeyNodeChildren;
          ExpressionAttributeValues: import("../commands/utils").KeyNodeChildren;
        };
        Put: {
          Item: import("../commands/utils").KeyNodeChildren;
          ExpressionAttributeValues: import("../commands/utils").KeyNodeChildren;
        };
        Delete: {
          Key: import("../commands/utils").KeyNodeChildren;
          ExpressionAttributeValues: import("../commands/utils").KeyNodeChildren;
        };
        Update: {
          Key: import("../commands/utils").KeyNodeChildren;
          ExpressionAttributeValues: import("../commands/utils").KeyNodeChildren;
        };
      };
    };
  };
  protected readonly outputKeyNodes: {
    ItemCollectionMetrics: {
      "*": {
        "*": {
          ItemCollectionKey: import("../commands/utils").KeyNodeChildren;
        };
      };
    };
  };
  protected readonly clientCommand: __TransactWriteItemsCommand;
  readonly middlewareStack: MiddlewareStack<
    TransactWriteCommandInput | __TransactWriteItemsCommandInput,
    TransactWriteCommandOutput | __TransactWriteItemsCommandOutput
  >;
  constructor(input: TransactWriteCommandInput);
  resolveMiddleware(
    clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>,
    configuration: DynamoDBDocumentClientResolvedConfig,
    options?: __HttpHandlerOptions
  ): Handler<TransactWriteCommandInput, TransactWriteCommandOutput>;
}
import {
  ConditionCheck,
  Delete,
  ItemCollectionMetrics,
  Put,
  TransactWriteItem,
  TransactWriteItemsCommandInput as __TransactWriteItemsCommandInput,
  TransactWriteItemsCommandOutput as __TransactWriteItemsCommandOutput,
  Update,
} from "@aws-sdk/client-dynamodb";
import { NativeAttributeValue } from "@aws-sdk/util-dynamodb";

```

## ./lib/lambda/node_modules/@aws-sdk/lib-dynamodb/dist-types/ts3.4/commands/UpdateCommand.d.ts

```typescript
import { UpdateItemCommand as __UpdateItemCommand } from "@aws-sdk/client-dynamodb";
import { Command as $Command } from "@smithy/smithy-client";
import {
  Handler,
  HttpHandlerOptions as __HttpHandlerOptions,
  MiddlewareStack,
} from "@smithy/types";
import { DynamoDBDocumentClientCommand } from "../baseCommand/DynamoDBDocumentClientCommand";
import {
  DynamoDBDocumentClientResolvedConfig,
  ServiceInputTypes,
  ServiceOutputTypes,
} from "../DynamoDBDocumentClient";
export { DynamoDBDocumentClientCommand, $Command };
export type UpdateCommandInput = Pick<
  __UpdateItemCommandInput,
  Exclude<
    keyof __UpdateItemCommandInput,
    "Key" | "AttributeUpdates" | "Expected" | "ExpressionAttributeValues"
  >
> & {
  Key: Record<string, NativeAttributeValue> | undefined;
  AttributeUpdates?:
    | Record<
        string,
        Pick<
          AttributeValueUpdate,
          Exclude<keyof AttributeValueUpdate, "Value">
        > & {
          Value?: NativeAttributeValue | undefined;
        }
      >
    | undefined;
  Expected?:
    | Record<
        string,
        Pick<
          ExpectedAttributeValue,
          Exclude<keyof ExpectedAttributeValue, "Value" | "AttributeValueList">
        > & {
          Value?: NativeAttributeValue | undefined;
          AttributeValueList?: NativeAttributeValue[] | undefined;
        }
      >
    | undefined;
  ExpressionAttributeValues?: Record<string, NativeAttributeValue> | undefined;
};
export type UpdateCommandOutput = Pick<
  __UpdateItemCommandOutput,
  Exclude<
    keyof __UpdateItemCommandOutput,
    "Attributes" | "ItemCollectionMetrics"
  >
> & {
  Attributes?: Record<string, NativeAttributeValue> | undefined;
  ItemCollectionMetrics?:
    | (Pick<
        ItemCollectionMetrics,
        Exclude<keyof ItemCollectionMetrics, "ItemCollectionKey">
      > & {
        ItemCollectionKey?: Record<string, NativeAttributeValue> | undefined;
      })
    | undefined;
};
export declare class UpdateCommand extends DynamoDBDocumentClientCommand<
  UpdateCommandInput,
  UpdateCommandOutput,
  __UpdateItemCommandInput,
  __UpdateItemCommandOutput,
  DynamoDBDocumentClientResolvedConfig
> {
  readonly input: UpdateCommandInput;
  protected readonly inputKeyNodes: {
    Key: import("../commands/utils").KeyNodeChildren;
    AttributeUpdates: {
      "*": {
        Value: null;
      };
    };
    Expected: {
      "*": {
        Value: null;
        AttributeValueList: import("../commands/utils").KeyNodeChildren;
      };
    };
    ExpressionAttributeValues: import("../commands/utils").KeyNodeChildren;
  };
  protected readonly outputKeyNodes: {
    Attributes: import("../commands/utils").KeyNodeChildren;
    ItemCollectionMetrics: {
      ItemCollectionKey: import("../commands/utils").KeyNodeChildren;
    };
  };
  protected readonly clientCommand: __UpdateItemCommand;
  readonly middlewareStack: MiddlewareStack<
    UpdateCommandInput | __UpdateItemCommandInput,
    UpdateCommandOutput | __UpdateItemCommandOutput
  >;
  constructor(input: UpdateCommandInput);
  resolveMiddleware(
    clientStack: MiddlewareStack<ServiceInputTypes, ServiceOutputTypes>,
    configuration: DynamoDBDocumentClientResolvedConfig,
    options?: __HttpHandlerOptions
  ): Handler<UpdateCommandInput, UpdateCommandOutput>;
}
import {
  AttributeValueUpdate,
  ExpectedAttributeValue,
  ItemCollectionMetrics,
  UpdateItemCommandInput as __UpdateItemCommandInput,
  UpdateItemCommandOutput as __UpdateItemCommandOutput,
} from "@aws-sdk/client-dynamodb";
import { NativeAttributeValue } from "@aws-sdk/util-dynamodb";

```

## ./lib/lambda/node_modules/@aws-sdk/lib-dynamodb/dist-types/ts3.4/commands/index.d.ts

```typescript
export * from "./BatchExecuteStatementCommand";
export * from "./BatchGetCommand";
export * from "./BatchWriteCommand";
export * from "./DeleteCommand";
export * from "./ExecuteStatementCommand";
export * from "./ExecuteTransactionCommand";
export * from "./GetCommand";
export * from "./PutCommand";
export * from "./QueryCommand";
export * from "./ScanCommand";
export * from "./TransactGetCommand";
export * from "./TransactWriteCommand";
export * from "./UpdateCommand";

```

## ./lib/lambda/node_modules/@aws-sdk/lib-dynamodb/dist-types/ts3.4/commands/utils.d.ts

```typescript
import { marshallOptions, unmarshallOptions } from "@aws-sdk/util-dynamodb";
export type KeyNodeSelf = null;
export declare const SELF: KeyNodeSelf;
export type KeyNodeChildren = Record<string, any>;
export declare const ALL_VALUES: KeyNodeChildren;
export declare const ALL_MEMBERS: KeyNodeChildren;
export type KeyNodes = KeyNodeSelf | KeyNodeChildren;
export declare const marshallInput: (
  obj: any,
  keyNodes: KeyNodeChildren,
  options?: marshallOptions
) => any;
export declare const unmarshallOutput: (
  obj: any,
  keyNodes: KeyNodeChildren,
  options?: unmarshallOptions
) => any;

```

## ./lib/lambda/node_modules/@aws-sdk/lib-dynamodb/dist-types/ts3.4/index.d.ts

```typescript
export * from "./DynamoDBDocument";
export * from "./DynamoDBDocumentClient";
export * from "./commands";
export * from "./pagination";
export { NumberValueImpl as NumberValue } from "@aws-sdk/util-dynamodb";
export { marshallOptions, unmarshallOptions } from "@aws-sdk/util-dynamodb";
export {
  NativeAttributeValue,
  NativeAttributeBinary,
  NativeScalarAttributeValue,
} from "@aws-sdk/util-dynamodb";

```

## ./lib/lambda/node_modules/@aws-sdk/lib-dynamodb/dist-types/ts3.4/pagination/Interfaces.d.ts

```typescript
import { PaginationConfiguration } from "@smithy/types";
import { DynamoDBDocument } from "../DynamoDBDocument";
import { DynamoDBDocumentClient } from "../DynamoDBDocumentClient";
export { PaginationConfiguration };
export interface DynamoDBDocumentPaginationConfiguration
  extends PaginationConfiguration {
  client: DynamoDBDocument | DynamoDBDocumentClient;
}

```

## ./lib/lambda/node_modules/@aws-sdk/lib-dynamodb/dist-types/ts3.4/pagination/QueryPaginator.d.ts

```typescript
import { Paginator } from "@smithy/types";
import {
  QueryCommandInput,
  QueryCommandOutput,
} from "../commands/QueryCommand";
import { DynamoDBDocumentPaginationConfiguration } from "./Interfaces";
export { Paginator };
export declare const paginateQuery: (
  config: DynamoDBDocumentPaginationConfiguration,
  input: QueryCommandInput,
  ...additionalArguments: any
) => Paginator<QueryCommandOutput>;

```

## ./lib/lambda/node_modules/@aws-sdk/lib-dynamodb/dist-types/ts3.4/pagination/ScanPaginator.d.ts

```typescript
import { Paginator } from "@smithy/types";
import { ScanCommandInput, ScanCommandOutput } from "../commands/ScanCommand";
import { DynamoDBDocumentPaginationConfiguration } from "./Interfaces";
export { Paginator };
export declare const paginateScan: (
  config: DynamoDBDocumentPaginationConfiguration,
  input: ScanCommandInput,
  ...additionalArguments: any
) => Paginator<ScanCommandOutput>;

```

## ./lib/lambda/node_modules/@aws-sdk/lib-dynamodb/dist-types/ts3.4/pagination/index.d.ts

```typescript
export * from "./Interfaces";
export * from "./QueryPaginator";
export * from "./ScanPaginator";

```

## ./lib/lambda/node_modules/@aws-sdk/lib-dynamodb/package.json

```json
{
  "name": "@aws-sdk/lib-dynamodb",
  "version": "3.911.0",
  "description": "The document client simplifies working with items in Amazon DynamoDB by abstracting away the notion of attribute values.",
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "node ../../scripts/compilation/inline lib-dynamodb",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "extract:docs": "api-extractor run --local",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch",
    "test:e2e": "yarn g:vitest run -c vitest.config.e2e.mts --mode development",
    "test:e2e:watch": "yarn g:vitest watch -c vitest.config.e2e.mts",
    "test:integration": "yarn g:vitest run -c vitest.config.integ.mts --mode development",
    "test:integration:watch": "yarn g:vitest watch -c vitest.config.integ.mts"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "dependencies": {
    "@aws-sdk/core": "3.911.0",
    "@aws-sdk/util-dynamodb": "3.911.0",
    "@smithy/core": "^3.16.1",
    "@smithy/smithy-client": "^4.8.1",
    "@smithy/types": "^4.7.1",
    "tslib": "^2.6.2"
  },
  "peerDependencies": {
    "@aws-sdk/client-dynamodb": "^3.911.0"
  },
  "devDependencies": {
    "@aws-sdk/client-dynamodb": "3.911.0",
    "@tsconfig/recommended": "1.0.1",
    "@types/node": "^18.19.69",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typescript": "~5.8.3"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/aws/aws-sdk-js-v3/tree/main/lib/lib-dynamodb",
  "repository": {
    "type": "git",
    "url": "https://github.com/aws/aws-sdk-js-v3.git",
    "directory": "lib/lib-dynamodb"
  }
}

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-bucket-endpoint/dist-types/NodeDisableMultiregionAccessPointConfigOptions.d.ts

```typescript
import { LoadedConfigSelectors } from "@smithy/node-config-provider";
export declare const NODE_DISABLE_MULTIREGION_ACCESS_POINT_ENV_NAME = "AWS_S3_DISABLE_MULTIREGION_ACCESS_POINTS";
export declare const NODE_DISABLE_MULTIREGION_ACCESS_POINT_INI_NAME = "s3_disable_multiregion_access_points";
export declare const NODE_DISABLE_MULTIREGION_ACCESS_POINT_CONFIG_OPTIONS: LoadedConfigSelectors<boolean>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-bucket-endpoint/dist-types/NodeUseArnRegionConfigOptions.d.ts

```typescript
import { LoadedConfigSelectors } from "@smithy/node-config-provider";
export declare const NODE_USE_ARN_REGION_ENV_NAME = "AWS_S3_USE_ARN_REGION";
export declare const NODE_USE_ARN_REGION_INI_NAME = "s3_use_arn_region";
/**
 * Config to load useArnRegion from environment variables and shared INI files
 *
 * @internal
 */
export declare const NODE_USE_ARN_REGION_CONFIG_OPTIONS: LoadedConfigSelectors<boolean | undefined>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-bucket-endpoint/dist-types/bucketEndpointMiddleware.d.ts

```typescript
import { BuildMiddleware, Pluggable, RelativeMiddlewareOptions } from "@smithy/types";
import { BucketEndpointResolvedConfig } from "./configurations";
/**
 * @deprecated unused as of EndpointsV2.
 * @internal
 */
export declare const bucketEndpointMiddleware: (options: BucketEndpointResolvedConfig) => BuildMiddleware<any, any>;
/**
 * @deprecated unused as of EndpointsV2.
 * @internal
 */
export declare const bucketEndpointMiddlewareOptions: RelativeMiddlewareOptions;
/**
 * @deprecated unused as of EndpointsV2.
 * @internal
 */
export declare const getBucketEndpointPlugin: (options: BucketEndpointResolvedConfig) => Pluggable<any, any>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-bucket-endpoint/dist-types/bucketHostname.d.ts

```typescript
import { ArnHostnameParams, BucketHostnameParams } from "./bucketHostnameUtils";
/**
 * @deprecated unused as of EndpointsV2.
 * @internal
 */
export interface BucketHostname {
    hostname: string;
    bucketEndpoint: boolean;
    signingRegion?: string;
    signingService?: string;
}
/**
 * @deprecated unused as of EndpointsV2.
 * @internal
 */
export declare const bucketHostname: (options: BucketHostnameParams | ArnHostnameParams) => BucketHostname;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-bucket-endpoint/dist-types/bucketHostnameUtils.d.ts

```typescript
import { ARN } from "@aws-sdk/util-arn-parser";
/**
 * @deprecated unused as of EndpointsV2.
 */
export declare const DOT_PATTERN: RegExp;
/**
 * @deprecated unused as of EndpointsV2.
 */
export declare const S3_HOSTNAME_PATTERN: RegExp;
/**
 * @deprecated unused as of EndpointsV2.
 * @internal
 */
export interface AccessPointArn extends ARN {
    accessPointName: string;
}
/**
 * @deprecated unused as of EndpointsV2.
 * @internal
 */
export interface BucketHostnameParams {
    isCustomEndpoint?: boolean;
    baseHostname: string;
    bucketName: string;
    clientRegion: string;
    accelerateEndpoint?: boolean;
    dualstackEndpoint?: boolean;
    fipsEndpoint?: boolean;
    pathStyleEndpoint?: boolean;
    tlsCompatible?: boolean;
}
/**
 * @deprecated unused as of EndpointsV2.
 * @internal
 */
export interface ArnHostnameParams extends Omit<BucketHostnameParams, "bucketName"> {
    bucketName: ARN;
    clientSigningRegion?: string;
    clientPartition?: string;
    useArnRegion?: boolean;
    disableMultiregionAccessPoints?: boolean;
}
/**
 * @deprecated unused as of EndpointsV2.
 * @internal
 */
export declare const isBucketNameOptions: (options: BucketHostnameParams | ArnHostnameParams) => options is BucketHostnameParams;
/**
 * Determines whether a given string is DNS compliant per the rules outlined by
 * S3. Length, capitaization, and leading dot restrictions are enforced by the
 * DOMAIN_PATTERN regular expression.
 * @internal
 *
 * @see https://docs.aws.amazon.com/AmazonS3/latest/dev/BucketRestrictions.html
 *
 * @deprecated unused as of EndpointsV2.
 */
export declare const isDnsCompatibleBucketName: (bucketName: string) => boolean;
/**
 * @deprecated unused as of EndpointsV2.
 * @internal
 */
export declare const getSuffix: (hostname: string) => [string, string];
/**
 * Infer region and hostname suffix from a complete hostname
 * @internal
 * @param hostname - Hostname
 * @returns [Region, Hostname suffix]
 *
 * @deprecated unused as of EndpointsV2.
 */
export declare const getSuffixForArnEndpoint: (hostname: string) => [string, string];
/**
 * @deprecated unused as of EndpointsV2.
 * @internal
 */
export declare const validateArnEndpointOptions: (options: {
    accelerateEndpoint?: boolean;
    tlsCompatible?: boolean;
    pathStyleEndpoint?: boolean;
}) => void;
/**
 * @deprecated unused as of EndpointsV2.
 * @internal
 */
export declare const validateService: (service: string) => void;
/**
 * @deprecated unused as of EndpointsV2.
 * @internal
 */
export declare const validateS3Service: (service: string) => void;
/**
 * @internal
 */
export declare const validateOutpostService: (service: string) => void;
/**
 * Validate partition inferred from ARN is the same to `options.clientPartition`.
 * @internal
 */
export declare const validatePartition: (partition: string, options: {
    clientPartition: string;
}) => void;
/**
 * (Previous to deprecation)
 * validate region value inferred from ARN. If `options.useArnRegion` is set, it validates the region is not a FIPS
 * region. If `options.useArnRegion` is unset, it validates the region is equal to `options.clientRegion` or
 * `options.clientSigningRegion`.
 *
 * @internal
 *
 * @deprecated validation is deferred to the endpoint ruleset.
 */
export declare const validateRegion: (region: string, options: {
    useArnRegion?: boolean;
    allowFipsRegion?: boolean;
    clientRegion: string;
    clientSigningRegion: string;
    useFipsEndpoint: boolean;
}) => void;
/**
 * @deprecated unused as of EndpointsV2.
 */
export declare const validateRegionalClient: (region: string) => void;
/**
 * Validate an account ID
 * @internal
 */
export declare const validateAccountId: (accountId: string) => void;
/**
 * Validate a host label according to https://tools.ietf.org/html/rfc3986#section-3.2.2
 * @internal
 * @deprecated unused as of EndpointsV2.
 */
export declare const validateDNSHostLabel: (label: string, options?: {
    tlsCompatible?: boolean;
}) => void;
/**
 * @deprecated unused as of EndpointsV2.
 */
export declare const validateCustomEndpoint: (options: {
    isCustomEndpoint?: boolean;
    dualstackEndpoint?: boolean;
    accelerateEndpoint?: boolean;
}) => void;
/**
 * Validate and parse an Access Point ARN or Outposts ARN
 * @internal
 *
 * @param resource - The resource section of an ARN
 * @returns Access Point Name and optional Outpost ID.
 */
export declare const getArnResources: (resource: string) => {
    accesspointName: string;
    outpostId?: string;
};
/**
 * (Prior to deprecation) Throw if dual stack configuration is set to true.
 * @internal
 *
 * @deprecated validation deferred to endpoints ruleset.
 */
export declare const validateNoDualstack: (dualstackEndpoint?: boolean) => void;
/**
 * Validate fips endpoint is not set up.
 * @internal
 * @deprecated unused as of EndpointsV2.
 */
export declare const validateNoFIPS: (useFipsEndpoint?: boolean) => void;
/**
 * Validate the multi-region access point alias.
 * @internal
 * @deprecated unused as of EndpointsV2.
 */
export declare const validateMrapAlias: (name: string) => void;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-bucket-endpoint/dist-types/configurations.d.ts

```typescript
import { Provider, RegionInfoProvider } from "@smithy/types";
/**
 * @deprecated unused as of EndpointsV2.
 */
export interface BucketEndpointInputConfig {
    /**
     * Whether to use the bucket name as the endpoint for this request. The bucket
     * name must be a domain name with a CNAME record alias to an appropriate virtual
     * hosted-style S3 hostname, e.g. a bucket of `images.johnsmith.net` and a DNS
     * record of:
     *
     * ```
     * images.johnsmith.net CNAME 			images.johnsmith.net.s3.amazonaws.com.
     * ```
     *
     * @see https://docs.aws.amazon.com/AmazonS3/latest/userguide/VirtualHosting.html#VirtualHostingCustomURLs
     */
    bucketEndpoint?: boolean;
    /**
     * Whether to force path style URLs for S3 objects (e.g., https://s3.amazonaws.com/<bucketName>/<key> instead of https://<bucketName>.s3.amazonaws.com/<key>
     */
    forcePathStyle?: boolean;
    /**
     * Whether to use the S3 Transfer Acceleration endpoint by default
     */
    useAccelerateEndpoint?: boolean;
    /**
     * Whether to override the request region with the region inferred from requested resource's ARN. Defaults to false
     */
    useArnRegion?: boolean | Provider<boolean>;
    /**
     * Whether to prevent SDK from making cross-region request when supplied bucket is a multi-region access point ARN.
     * Defaults to false
     */
    disableMultiregionAccessPoints?: boolean | Provider<boolean>;
}
/**
 * @deprecated unused as of EndpointsV2.
 */
interface PreviouslyResolved {
    isCustomEndpoint?: boolean;
    region: Provider<string>;
    regionInfoProvider: RegionInfoProvider;
    useFipsEndpoint: Provider<boolean>;
    useDualstackEndpoint: Provider<boolean>;
}
/**
 * @deprecated unused as of EndpointsV2.
 */
export interface BucketEndpointResolvedConfig {
    /**
     * Whether the endpoint is specified by caller.
     * @internal
     */
    isCustomEndpoint?: boolean;
    /**
     * Resolved value for input config {@link BucketEndpointInputConfig.bucketEndpoint}
     */
    bucketEndpoint: boolean;
    /**
     * Resolved value for input config {@link BucketEndpointInputConfig.forcePathStyle}
     */
    forcePathStyle: boolean;
    /**
     * Resolved value for input config {@link BucketEndpointInputConfig.useAccelerateEndpoint}
     */
    useAccelerateEndpoint: boolean;
    /**
     * Enables FIPS compatible endpoints.
     */
    useFipsEndpoint: Provider<boolean>;
    /**
     * Enables IPv6/IPv4 dualstack endpoint.
     */
    useDualstackEndpoint: Provider<boolean>;
    /**
     * Resolved value for input config {@link BucketEndpointInputConfig.useArnRegion}
     */
    useArnRegion: Provider<boolean | undefined>;
    /**
     * Resolved value for input config {@link RegionInputConfig.region}
     */
    region: Provider<string>;
    /**
     * Fetch related hostname, signing name or signing region with given region.
     * @internal
     */
    regionInfoProvider: RegionInfoProvider;
    disableMultiregionAccessPoints: Provider<boolean>;
}
/**
 * @deprecated unused as of EndpointsV2.
 */
export declare function resolveBucketEndpointConfig<T>(input: T & PreviouslyResolved & BucketEndpointInputConfig): T & BucketEndpointResolvedConfig;
export {};

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-bucket-endpoint/dist-types/index.d.ts

```typescript
export * from "./NodeDisableMultiregionAccessPointConfigOptions";
export * from "./NodeUseArnRegionConfigOptions";
export * from "./bucketEndpointMiddleware";
export * from "./bucketHostname";
export * from "./configurations";
export { getArnResources, getSuffixForArnEndpoint, validateOutpostService, validatePartition, validateAccountId, validateRegion, validateDNSHostLabel, validateNoDualstack, validateNoFIPS, } from "./bucketHostnameUtils";

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-bucket-endpoint/dist-types/ts3.4/NodeDisableMultiregionAccessPointConfigOptions.d.ts

```typescript
import { LoadedConfigSelectors } from "@smithy/node-config-provider";
export declare const NODE_DISABLE_MULTIREGION_ACCESS_POINT_ENV_NAME =
  "AWS_S3_DISABLE_MULTIREGION_ACCESS_POINTS";
export declare const NODE_DISABLE_MULTIREGION_ACCESS_POINT_INI_NAME =
  "s3_disable_multiregion_access_points";
export declare const NODE_DISABLE_MULTIREGION_ACCESS_POINT_CONFIG_OPTIONS: LoadedConfigSelectors<boolean>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-bucket-endpoint/dist-types/ts3.4/NodeUseArnRegionConfigOptions.d.ts

```typescript
import { LoadedConfigSelectors } from "@smithy/node-config-provider";
export declare const NODE_USE_ARN_REGION_ENV_NAME = "AWS_S3_USE_ARN_REGION";
export declare const NODE_USE_ARN_REGION_INI_NAME = "s3_use_arn_region";
export declare const NODE_USE_ARN_REGION_CONFIG_OPTIONS: LoadedConfigSelectors<
  boolean | undefined
>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-bucket-endpoint/dist-types/ts3.4/bucketEndpointMiddleware.d.ts

```typescript
import {
  BuildMiddleware,
  Pluggable,
  RelativeMiddlewareOptions,
} from "@smithy/types";
import { BucketEndpointResolvedConfig } from "./configurations";
export declare const bucketEndpointMiddleware: (
  options: BucketEndpointResolvedConfig
) => BuildMiddleware<any, any>;
export declare const bucketEndpointMiddlewareOptions: RelativeMiddlewareOptions;
export declare const getBucketEndpointPlugin: (
  options: BucketEndpointResolvedConfig
) => Pluggable<any, any>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-bucket-endpoint/dist-types/ts3.4/bucketHostname.d.ts

```typescript
import { ArnHostnameParams, BucketHostnameParams } from "./bucketHostnameUtils";
export interface BucketHostname {
  hostname: string;
  bucketEndpoint: boolean;
  signingRegion?: string;
  signingService?: string;
}
export declare const bucketHostname: (
  options: BucketHostnameParams | ArnHostnameParams
) => BucketHostname;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-bucket-endpoint/dist-types/ts3.4/bucketHostnameUtils.d.ts

```typescript
import { ARN } from "@aws-sdk/util-arn-parser";
export declare const DOT_PATTERN: RegExp;
export declare const S3_HOSTNAME_PATTERN: RegExp;
export interface AccessPointArn extends ARN {
  accessPointName: string;
}
export interface BucketHostnameParams {
  isCustomEndpoint?: boolean;
  baseHostname: string;
  bucketName: string;
  clientRegion: string;
  accelerateEndpoint?: boolean;
  dualstackEndpoint?: boolean;
  fipsEndpoint?: boolean;
  pathStyleEndpoint?: boolean;
  tlsCompatible?: boolean;
}
export interface ArnHostnameParams
  extends Pick<
    BucketHostnameParams,
    Exclude<keyof BucketHostnameParams, "bucketName">
  > {
  bucketName: ARN;
  clientSigningRegion?: string;
  clientPartition?: string;
  useArnRegion?: boolean;
  disableMultiregionAccessPoints?: boolean;
}
export declare const isBucketNameOptions: (
  options: BucketHostnameParams | ArnHostnameParams
) => options is BucketHostnameParams;
export declare const isDnsCompatibleBucketName: (bucketName: string) => boolean;
export declare const getSuffix: (hostname: string) => [string, string];
export declare const getSuffixForArnEndpoint: (
  hostname: string
) => [string, string];
export declare const validateArnEndpointOptions: (options: {
  accelerateEndpoint?: boolean;
  tlsCompatible?: boolean;
  pathStyleEndpoint?: boolean;
}) => void;
export declare const validateService: (service: string) => void;
export declare const validateS3Service: (service: string) => void;
export declare const validateOutpostService: (service: string) => void;
export declare const validatePartition: (
  partition: string,
  options: {
    clientPartition: string;
  }
) => void;
export declare const validateRegion: (
  region: string,
  options: {
    useArnRegion?: boolean;
    allowFipsRegion?: boolean;
    clientRegion: string;
    clientSigningRegion: string;
    useFipsEndpoint: boolean;
  }
) => void;
export declare const validateRegionalClient: (region: string) => void;
export declare const validateAccountId: (accountId: string) => void;
export declare const validateDNSHostLabel: (
  label: string,
  options?: {
    tlsCompatible?: boolean;
  }
) => void;
export declare const validateCustomEndpoint: (options: {
  isCustomEndpoint?: boolean;
  dualstackEndpoint?: boolean;
  accelerateEndpoint?: boolean;
}) => void;
export declare const getArnResources: (resource: string) => {
  accesspointName: string;
  outpostId?: string;
};
export declare const validateNoDualstack: (dualstackEndpoint?: boolean) => void;
export declare const validateNoFIPS: (useFipsEndpoint?: boolean) => void;
export declare const validateMrapAlias: (name: string) => void;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-bucket-endpoint/dist-types/ts3.4/configurations.d.ts

```typescript
import { Provider, RegionInfoProvider } from "@smithy/types";
export interface BucketEndpointInputConfig {
  bucketEndpoint?: boolean;
  forcePathStyle?: boolean;
  useAccelerateEndpoint?: boolean;
  useArnRegion?: boolean | Provider<boolean>;
  disableMultiregionAccessPoints?: boolean | Provider<boolean>;
}
interface PreviouslyResolved {
  isCustomEndpoint?: boolean;
  region: Provider<string>;
  regionInfoProvider: RegionInfoProvider;
  useFipsEndpoint: Provider<boolean>;
  useDualstackEndpoint: Provider<boolean>;
}
export interface BucketEndpointResolvedConfig {
  isCustomEndpoint?: boolean;
  bucketEndpoint: boolean;
  forcePathStyle: boolean;
  useAccelerateEndpoint: boolean;
  useFipsEndpoint: Provider<boolean>;
  useDualstackEndpoint: Provider<boolean>;
  useArnRegion: Provider<boolean | undefined>;
  region: Provider<string>;
  regionInfoProvider: RegionInfoProvider;
  disableMultiregionAccessPoints: Provider<boolean>;
}
export declare function resolveBucketEndpointConfig<T>(
  input: T & PreviouslyResolved & BucketEndpointInputConfig
): T & BucketEndpointResolvedConfig;
export {};

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-bucket-endpoint/dist-types/ts3.4/index.d.ts

```typescript
export * from "./NodeDisableMultiregionAccessPointConfigOptions";
export * from "./NodeUseArnRegionConfigOptions";
export * from "./bucketEndpointMiddleware";
export * from "./bucketHostname";
export * from "./configurations";
export {
  getArnResources,
  getSuffixForArnEndpoint,
  validateOutpostService,
  validatePartition,
  validateAccountId,
  validateRegion,
  validateDNSHostLabel,
  validateNoDualstack,
  validateNoFIPS,
} from "./bucketHostnameUtils";

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-bucket-endpoint/package.json

```json
{
  "name": "@aws-sdk/middleware-bucket-endpoint",
  "version": "3.910.0",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "node ../../scripts/compilation/inline middleware-bucket-endpoint",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "extract:docs": "api-extractor run --local",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "sideEffects": false,
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "dependencies": {
    "@aws-sdk/types": "3.910.0",
    "@aws-sdk/util-arn-parser": "3.893.0",
    "@smithy/node-config-provider": "^4.3.2",
    "@smithy/protocol-http": "^5.3.2",
    "@smithy/types": "^4.7.1",
    "@smithy/util-config-provider": "^4.2.0",
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "@tsconfig/recommended": "1.0.1",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typescript": "~5.8.3"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/aws/aws-sdk-js-v3/tree/main/packages/middleware-bucket-endpoint",
  "repository": {
    "type": "git",
    "url": "https://github.com/aws/aws-sdk-js-v3.git",
    "directory": "packages/middleware-bucket-endpoint"
  }
}

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-endpoint-discovery/dist-types/configurations.d.ts

```typescript
import { LoadedConfigSelectors } from "@smithy/node-config-provider";
/**
 * @internal
 */
export declare const NODE_ENDPOINT_DISCOVERY_CONFIG_OPTIONS: LoadedConfigSelectors<boolean | undefined>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-endpoint-discovery/dist-types/endpointDiscoveryMiddleware.d.ts

```typescript
import { BuildHandler, HandlerExecutionContext, MetadataBearer } from "@smithy/types";
import { EndpointDiscoveryMiddlewareConfig } from "./getEndpointDiscoveryPlugin";
import { EndpointDiscoveryResolvedConfig, PreviouslyResolved } from "./resolveEndpointDiscoveryConfig";
export declare const endpointDiscoveryMiddleware: (config: EndpointDiscoveryResolvedConfig & PreviouslyResolved, middlewareConfig: EndpointDiscoveryMiddlewareConfig) => <Output extends MetadataBearer = MetadataBearer>(next: BuildHandler<any, Output>, context: HandlerExecutionContext) => BuildHandler<any, Output>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-endpoint-discovery/dist-types/getCacheKey.d.ts

```typescript
import { AwsCredentialIdentity, Provider } from "@smithy/types";
/**
 * Generate key to index the endpoints in the cache
 */
export declare const getCacheKey: (commandName: string, config: {
    credentials: Provider<AwsCredentialIdentity>;
}, options: {
    identifiers?: Record<string, string>;
}) => Promise<string>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-endpoint-discovery/dist-types/getEndpointDiscoveryPlugin.d.ts

```typescript
import { BuildHandlerOptions, HttpHandlerOptions, MiddlewareStack, Pluggable } from "@smithy/types";
import { EndpointDiscoveryResolvedConfig, PreviouslyResolved } from "./resolveEndpointDiscoveryConfig";
/**
 * @internal
 */
export declare const endpointDiscoveryMiddlewareOptions: BuildHandlerOptions;
/**
 * @public
 */
export interface EndpointDiscoveryMiddlewareConfig {
    isDiscoveredEndpointRequired: boolean;
    clientStack: MiddlewareStack<any, any>;
    options?: HttpHandlerOptions;
    identifiers?: Record<string, string>;
}
/**
 * @internal
 */
export declare const getEndpointDiscoveryPlugin: (pluginConfig: EndpointDiscoveryResolvedConfig & PreviouslyResolved, middlewareConfig: EndpointDiscoveryMiddlewareConfig) => Pluggable<any, any>;
/**
 * @internal
 * @deprecated Use getEndpointDiscoveryPlugin
 */
export declare const getEndpointDiscoveryRequiredPlugin: (pluginConfig: EndpointDiscoveryResolvedConfig & PreviouslyResolved, middlewareConfig: Omit<EndpointDiscoveryMiddlewareConfig, "isDiscoveredEndpointRequired">) => Pluggable<any, any>;
/**
 * @internal
 * @deprecated Use getEndpointDiscoveryPlugin
 */
export declare const getEndpointDiscoveryOptionalPlugin: (pluginConfig: EndpointDiscoveryResolvedConfig & PreviouslyResolved, middlewareConfig: Omit<EndpointDiscoveryMiddlewareConfig, "isDiscoveredEndpointRequired">) => Pluggable<any, any>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-endpoint-discovery/dist-types/index.d.ts

```typescript
export * from "./configurations";
export * from "./getEndpointDiscoveryPlugin";
export * from "./resolveEndpointDiscoveryConfig";

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-endpoint-discovery/dist-types/resolveEndpointDiscoveryConfig.d.ts

```typescript
import { EndpointCache } from "@aws-sdk/endpoint-cache";
import { AwsCredentialIdentity, MemoizedProvider, Provider } from "@smithy/types";
/**
 * @internal
 */
export interface PreviouslyResolved {
    isCustomEndpoint?: boolean;
    credentials: MemoizedProvider<AwsCredentialIdentity>;
    endpointDiscoveryEnabledProvider: Provider<boolean | undefined>;
}
/**
 * @public
 */
export interface EndpointDiscoveryInputConfig {
    /**
     * The size of the client cache storing endpoints from endpoint discovery operations.
     * Defaults to 1000.
     */
    endpointCacheSize?: number;
    /**
     * Whether to call operations with endpoints given by service dynamically.
     * Setting this config to `true` will enable endpoint discovery for all applicable operations.
     * Setting it to `false` will explicitly disable endpoint discovery even though operations that
     * require endpoint discovery will presumably fail. Leaving it to undefined means SDK only do
     * endpoint discovery when it's required. Defaults to `undefined`.
     */
    endpointDiscoveryEnabled?: boolean | undefined;
}
export interface EndpointDiscoveryResolvedConfig {
    /**
     * LRU Cache which stores endpoints from endpoint discovery operations.
     * The size is either provided by {@link EndpointDiscoveryInputConfig.endpointCacheSize}.
     */
    endpointCache: EndpointCache;
    /**
     * The constructor of the Command used for discovering endpoints.
     * @internal
     */
    endpointDiscoveryCommandCtor: new (comandConfig: any) => any;
    /**
     * Resolved value for input config {@link EndpointDiscoveryInputConfig.endpointDiscoveryEnabled}.
     */
    endpointDiscoveryEnabled: Provider<boolean | undefined>;
    /**
     * Stores whether endpoint discovery configuration is set locally by passing
     * {@link EndpointDiscoveryInputConfig.endpointDiscoveryEnabled} during client creation.
     * @internal
     */
    isClientEndpointDiscoveryEnabled: boolean;
}
export interface EndpointDiscoveryConfigOptions {
    /**
     * The constructor of the Command used for discovering endpoints.
     */
    endpointDiscoveryCommandCtor: new (comandConfig: any) => any;
}
/**
 * @internal
 */
export declare const resolveEndpointDiscoveryConfig: <T>(input: T & PreviouslyResolved & EndpointDiscoveryInputConfig, { endpointDiscoveryCommandCtor }: EndpointDiscoveryConfigOptions) => T & EndpointDiscoveryResolvedConfig;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-endpoint-discovery/dist-types/ts3.4/configurations.d.ts

```typescript
import { LoadedConfigSelectors } from "@smithy/node-config-provider";
export declare const NODE_ENDPOINT_DISCOVERY_CONFIG_OPTIONS: LoadedConfigSelectors<
  boolean | undefined
>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-endpoint-discovery/dist-types/ts3.4/endpointDiscoveryMiddleware.d.ts

```typescript
import {
  BuildHandler,
  HandlerExecutionContext,
  MetadataBearer,
} from "@smithy/types";
import { EndpointDiscoveryMiddlewareConfig } from "./getEndpointDiscoveryPlugin";
import {
  EndpointDiscoveryResolvedConfig,
  PreviouslyResolved,
} from "./resolveEndpointDiscoveryConfig";
export declare const endpointDiscoveryMiddleware: (
  config: EndpointDiscoveryResolvedConfig & PreviouslyResolved,
  middlewareConfig: EndpointDiscoveryMiddlewareConfig
) => <Output extends MetadataBearer = MetadataBearer>(
  next: BuildHandler<any, Output>,
  context: HandlerExecutionContext
) => BuildHandler<any, Output>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-endpoint-discovery/dist-types/ts3.4/getCacheKey.d.ts

```typescript
import { AwsCredentialIdentity, Provider } from "@smithy/types";
export declare const getCacheKey: (
  commandName: string,
  config: {
    credentials: Provider<AwsCredentialIdentity>;
  },
  options: {
    identifiers?: Record<string, string>;
  }
) => Promise<string>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-endpoint-discovery/dist-types/ts3.4/getEndpointDiscoveryPlugin.d.ts

```typescript
import {
  BuildHandlerOptions,
  HttpHandlerOptions,
  MiddlewareStack,
  Pluggable,
} from "@smithy/types";
import {
  EndpointDiscoveryResolvedConfig,
  PreviouslyResolved,
} from "./resolveEndpointDiscoveryConfig";
export declare const endpointDiscoveryMiddlewareOptions: BuildHandlerOptions;
export interface EndpointDiscoveryMiddlewareConfig {
  isDiscoveredEndpointRequired: boolean;
  clientStack: MiddlewareStack<any, any>;
  options?: HttpHandlerOptions;
  identifiers?: Record<string, string>;
}
export declare const getEndpointDiscoveryPlugin: (
  pluginConfig: EndpointDiscoveryResolvedConfig & PreviouslyResolved,
  middlewareConfig: EndpointDiscoveryMiddlewareConfig
) => Pluggable<any, any>;
export declare const getEndpointDiscoveryRequiredPlugin: (
  pluginConfig: EndpointDiscoveryResolvedConfig & PreviouslyResolved,
  middlewareConfig: Pick<
    EndpointDiscoveryMiddlewareConfig,
    Exclude<
      keyof EndpointDiscoveryMiddlewareConfig,
      "isDiscoveredEndpointRequired"
    >
  >
) => Pluggable<any, any>;
export declare const getEndpointDiscoveryOptionalPlugin: (
  pluginConfig: EndpointDiscoveryResolvedConfig & PreviouslyResolved,
  middlewareConfig: Pick<
    EndpointDiscoveryMiddlewareConfig,
    Exclude<
      keyof EndpointDiscoveryMiddlewareConfig,
      "isDiscoveredEndpointRequired"
    >
  >
) => Pluggable<any, any>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-endpoint-discovery/dist-types/ts3.4/index.d.ts

```typescript
export * from "./configurations";
export * from "./getEndpointDiscoveryPlugin";
export * from "./resolveEndpointDiscoveryConfig";

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-endpoint-discovery/dist-types/ts3.4/resolveEndpointDiscoveryConfig.d.ts

```typescript
import { EndpointCache } from "@aws-sdk/endpoint-cache";
import {
  AwsCredentialIdentity,
  MemoizedProvider,
  Provider,
} from "@smithy/types";
export interface PreviouslyResolved {
  isCustomEndpoint?: boolean;
  credentials: MemoizedProvider<AwsCredentialIdentity>;
  endpointDiscoveryEnabledProvider: Provider<boolean | undefined>;
}
export interface EndpointDiscoveryInputConfig {
  endpointCacheSize?: number;
  endpointDiscoveryEnabled?: boolean | undefined;
}
export interface EndpointDiscoveryResolvedConfig {
  endpointCache: EndpointCache;
  endpointDiscoveryCommandCtor: new (comandConfig: any) => any;
  endpointDiscoveryEnabled: Provider<boolean | undefined>;
  isClientEndpointDiscoveryEnabled: boolean;
}
export interface EndpointDiscoveryConfigOptions {
  endpointDiscoveryCommandCtor: new (comandConfig: any) => any;
}
export declare const resolveEndpointDiscoveryConfig: <T>(
  input: T & PreviouslyResolved & EndpointDiscoveryInputConfig,
  { endpointDiscoveryCommandCtor }: EndpointDiscoveryConfigOptions
) => T & EndpointDiscoveryResolvedConfig;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-endpoint-discovery/dist-types/ts3.4/updateDiscoveredEndpointInCache.d.ts

```typescript
import { EndpointDiscoveryMiddlewareConfig } from "./getEndpointDiscoveryPlugin";
import {
  EndpointDiscoveryResolvedConfig,
  PreviouslyResolved,
} from "./resolveEndpointDiscoveryConfig";
export interface UpdateDiscoveredEndpointInCacheOptions
  extends EndpointDiscoveryMiddlewareConfig {
  cacheKey: string;
  commandName: string;
  endpointDiscoveryCommandCtor: new (comandConfig: any) => any;
}
export declare const updateDiscoveredEndpointInCache: (
  config: EndpointDiscoveryResolvedConfig & PreviouslyResolved,
  options: UpdateDiscoveredEndpointInCacheOptions
) => Promise<void>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-endpoint-discovery/dist-types/updateDiscoveredEndpointInCache.d.ts

```typescript
import { EndpointDiscoveryMiddlewareConfig } from "./getEndpointDiscoveryPlugin";
import { EndpointDiscoveryResolvedConfig, PreviouslyResolved } from "./resolveEndpointDiscoveryConfig";
export interface UpdateDiscoveredEndpointInCacheOptions extends EndpointDiscoveryMiddlewareConfig {
    cacheKey: string;
    commandName: string;
    endpointDiscoveryCommandCtor: new (comandConfig: any) => any;
}
export declare const updateDiscoveredEndpointInCache: (config: EndpointDiscoveryResolvedConfig & PreviouslyResolved, options: UpdateDiscoveredEndpointInCacheOptions) => Promise<void>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-endpoint-discovery/package.json

```json
{
  "name": "@aws-sdk/middleware-endpoint-discovery",
  "version": "3.910.0",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "node ../../scripts/compilation/inline middleware-endpoint-discovery",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "extract:docs": "api-extractor run --local",
    "test": "yarn g:vitest run",
    "test:integration": "yarn g:vitest run -c vitest.config.integ.mts",
    "test:watch": "yarn g:vitest watch",
    "test:integration:watch": "yarn g:vitest watch -c vitest.config.integ.mts"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "sideEffects": false,
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "devDependencies": {
    "@tsconfig/recommended": "1.0.1",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typescript": "~5.8.3"
  },
  "dependencies": {
    "@aws-sdk/endpoint-cache": "3.893.0",
    "@aws-sdk/types": "3.910.0",
    "@smithy/node-config-provider": "^4.3.2",
    "@smithy/protocol-http": "^5.3.2",
    "@smithy/types": "^4.7.1",
    "tslib": "^2.6.2"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/aws/aws-sdk-js-v3/tree/main/packages/middleware-endpoint-discovery",
  "repository": {
    "type": "git",
    "url": "https://github.com/aws/aws-sdk-js-v3.git",
    "directory": "packages/middleware-endpoint-discovery"
  }
}

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-expect-continue/dist-types/index.d.ts

```typescript
import { HttpHandler } from "@smithy/protocol-http";
import { BuildHandlerOptions, BuildMiddleware, Pluggable, RequestHandler } from "@smithy/types";
interface PreviouslyResolved {
    runtime: string;
    requestHandler?: RequestHandler<any, any, any> | HttpHandler<any>;
}
export declare function addExpectContinueMiddleware(options: PreviouslyResolved): BuildMiddleware<any, any>;
export declare const addExpectContinueMiddlewareOptions: BuildHandlerOptions;
export declare const getAddExpectContinuePlugin: (options: PreviouslyResolved) => Pluggable<any, any>;
export {};

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-expect-continue/dist-types/ts3.4/index.d.ts

```typescript
import { HttpHandler } from "@smithy/protocol-http";
import {
  BuildHandlerOptions,
  BuildMiddleware,
  Pluggable,
  RequestHandler,
} from "@smithy/types";
interface PreviouslyResolved {
  runtime: string;
  requestHandler?: RequestHandler<any, any, any> | HttpHandler<any>;
}
export declare function addExpectContinueMiddleware(
  options: PreviouslyResolved
): BuildMiddleware<any, any>;
export declare const addExpectContinueMiddlewareOptions: BuildHandlerOptions;
export declare const getAddExpectContinuePlugin: (
  options: PreviouslyResolved
) => Pluggable<any, any>;
export {};

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-expect-continue/package.json

```json
{
  "name": "@aws-sdk/middleware-expect-continue",
  "version": "3.910.0",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "node ../../scripts/compilation/inline middleware-expect-continue",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "test": "yarn g:vitest run",
    "test:integration": "yarn g:vitest run -c vitest.config.integ.mts",
    "test:watch": "yarn g:vitest watch",
    "test:integration:watch": "yarn g:vitest watch -c vitest.config.integ.mts"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "sideEffects": false,
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "dependencies": {
    "@aws-sdk/types": "3.910.0",
    "@smithy/protocol-http": "^5.3.2",
    "@smithy/types": "^4.7.1",
    "tslib": "^2.6.2"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/aws/aws-sdk-js-v3/tree/main/packages/middleware-expect-continue",
  "repository": {
    "type": "git",
    "url": "https://github.com/aws/aws-sdk-js-v3.git",
    "directory": "packages/middleware-expect-continue"
  },
  "devDependencies": {
    "@tsconfig/recommended": "1.0.1",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typescript": "~5.8.3"
  }
}

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-flexible-checksums/dist-types/NODE_REQUEST_CHECKSUM_CALCULATION_CONFIG_OPTIONS.d.ts

```typescript
import { LoadedConfigSelectors } from "@smithy/node-config-provider";
import { RequestChecksumCalculation } from "./constants";
/**
 * @internal
 */
export declare const ENV_REQUEST_CHECKSUM_CALCULATION = "AWS_REQUEST_CHECKSUM_CALCULATION";
/**
 * @internal
 */
export declare const CONFIG_REQUEST_CHECKSUM_CALCULATION = "request_checksum_calculation";
/**
 * @internal
 */
export declare const NODE_REQUEST_CHECKSUM_CALCULATION_CONFIG_OPTIONS: LoadedConfigSelectors<RequestChecksumCalculation>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-flexible-checksums/dist-types/NODE_RESPONSE_CHECKSUM_VALIDATION_CONFIG_OPTIONS.d.ts

```typescript
import { LoadedConfigSelectors } from "@smithy/node-config-provider";
import { ResponseChecksumValidation } from "./constants";
/**
 * @internal
 */
export declare const ENV_RESPONSE_CHECKSUM_VALIDATION = "AWS_RESPONSE_CHECKSUM_VALIDATION";
/**
 * @internal
 */
export declare const CONFIG_RESPONSE_CHECKSUM_VALIDATION = "response_checksum_validation";
/**
 * @internal
 */
export declare const NODE_RESPONSE_CHECKSUM_VALIDATION_CONFIG_OPTIONS: LoadedConfigSelectors<ResponseChecksumValidation>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-flexible-checksums/dist-types/configuration.d.ts

```typescript
import { BodyLengthCalculator, ChecksumConstructor, Encoder, GetAwsChunkedEncodingStream, HashConstructor, Provider, StreamCollector, StreamHasher } from "@smithy/types";
import { RequestChecksumCalculation, ResponseChecksumValidation } from "./constants";
/**
 * @internal
 */
export interface PreviouslyResolved {
    /**
     * The function that will be used to convert binary data to a base64-encoded string.
     * @internal
     */
    base64Encoder: Encoder;
    /**
     * A function that can calculate the length of a body.
     */
    bodyLengthChecker: BodyLengthCalculator;
    /**
     * A function that returns Readable Stream which follows aws-chunked encoding stream.
     */
    getAwsChunkedEncodingStream: GetAwsChunkedEncodingStream;
    /**
     * A constructor for a class implementing the {@link Hash} interface that computes MD5 hashes.
     * @internal
     */
    md5: ChecksumConstructor | HashConstructor;
    /**
     * Determines when a checksum will be calculated for request payloads
     */
    requestChecksumCalculation: Provider<RequestChecksumCalculation>;
    /**
     * Determines when a checksum will be calculated for response payloads
     */
    responseChecksumValidation: Provider<ResponseChecksumValidation>;
    /**
     * A constructor for a class implementing the {@link Hash} interface that computes SHA1 hashes.
     * @internal
     */
    sha1: ChecksumConstructor | HashConstructor;
    /**
     * A constructor for a class implementing the {@link Hash} interface that computes SHA256 hashes.
     * @internal
     */
    sha256: ChecksumConstructor | HashConstructor;
    /**
     * A function that, given a hash constructor and a stream, calculates the hash of the streamed value.
     * @internal
     */
    streamHasher: StreamHasher<any>;
    /**
     * Collects streams into buffers.
     */
    streamCollector: StreamCollector;
    /**
     * Minimum bytes from a stream to buffer into a chunk before passing to chunked encoding.
     */
    requestStreamBufferSize: number;
}

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-flexible-checksums/dist-types/constants.d.ts

```typescript
/**
 * Determines when a checksum will be calculated for request payloads.
 * @public
 */
export declare const RequestChecksumCalculation: {
    /**
     * When set, a checksum will be calculated for all request payloads of operations
     * modeled with the {@link httpChecksum} trait where `requestChecksumRequired` is `true`
     * AND/OR a `requestAlgorithmMember` is modeled.
     * {@link https://smithy.io/2.0/aws/aws-core.html#aws-protocols-httpchecksum-trait httpChecksum}
     */
    readonly WHEN_SUPPORTED: "WHEN_SUPPORTED";
    /**
     * When set, a checksum will only be calculated for request payloads of operations
     * modeled with the {@link httpChecksum} trait where `requestChecksumRequired` is `true`
     * OR where a `requestAlgorithmMember` is modeled and the user sets it.
     * {@link https://smithy.io/2.0/aws/aws-core.html#aws-protocols-httpchecksum-trait httpChecksum}
     */
    readonly WHEN_REQUIRED: "WHEN_REQUIRED";
};
/**
 * @public
 */
export type RequestChecksumCalculation = (typeof RequestChecksumCalculation)[keyof typeof RequestChecksumCalculation];
/**
 * @internal
 */
export declare const DEFAULT_REQUEST_CHECKSUM_CALCULATION: "WHEN_SUPPORTED";
/**
 * Determines when checksum validation will be performed on response payloads.
 * @public
 */
export declare const ResponseChecksumValidation: {
    /**
     * When set, checksum validation MUST be performed on all response payloads of operations
     * modeled with the {@link httpChecksum} trait where `responseAlgorithms` is modeled,
     * except when no modeled checksum algorithms are supported by an SDK.
     * {@link https://smithy.io/2.0/aws/aws-core.html#aws-protocols-httpchecksum-trait httpChecksum}
     */
    readonly WHEN_SUPPORTED: "WHEN_SUPPORTED";
    /**
     * When set, checksum validation MUST NOT be performed on response payloads of operations UNLESS
     * the SDK supports the modeled checksum algorithms AND the user has set the `requestValidationModeMember` to `ENABLED`.
     * It is currently impossible to model an operation as requiring a response checksum,
     * but this setting leaves the door open for future updates.
     */
    readonly WHEN_REQUIRED: "WHEN_REQUIRED";
};
/**
 * @public
 */
export type ResponseChecksumValidation = (typeof ResponseChecksumValidation)[keyof typeof ResponseChecksumValidation];
/**
 * @internal
 */
export declare const DEFAULT_RESPONSE_CHECKSUM_VALIDATION: "WHEN_SUPPORTED";
/**
 * Checksum Algorithms supported by the SDK.
 * @public
 */
export declare enum ChecksumAlgorithm {
    /**
     * @deprecated Use {@link ChecksumAlgorithm.CRC32} instead.
     */
    MD5 = "MD5",
    CRC32 = "CRC32",
    CRC32C = "CRC32C",
    CRC64NVME = "CRC64NVME",
    SHA1 = "SHA1",
    SHA256 = "SHA256"
}
/**
 * Location when the checksum is stored in the request body.
 * @internal
 */
export declare enum ChecksumLocation {
    HEADER = "header",
    TRAILER = "trailer"
}
/**
 * @internal
 */
export declare const DEFAULT_CHECKSUM_ALGORITHM = ChecksumAlgorithm.CRC32;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-flexible-checksums/dist-types/crc64-nvme-crt-container.d.ts

```typescript
import { ChecksumConstructor } from "@smithy/types";
/**
 * @internal
 *
 * \@aws-sdk/crc64-nvme-crt will install the constructor in this
 * container if it is installed.
 *
 * This avoids a runtime-require being interpreted statically by bundlers.
 *
 */
export declare const crc64NvmeCrtContainer: {
    CrtCrc64Nvme: null | ChecksumConstructor;
};

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-flexible-checksums/dist-types/flexibleChecksumsInputMiddleware.d.ts

```typescript
import { RelativeMiddlewareOptions, SerializeMiddleware } from "@smithy/types";
import { PreviouslyResolved } from "./configuration";
/**
 * @internal
 */
export interface FlexibleChecksumsInputMiddlewareConfig {
    /**
     * Defines a top-level operation input member used to opt-in to best-effort validation
     * of a checksum returned in the HTTP response of the operation.
     */
    requestValidationModeMember?: string;
}
/**
 * @internal
 */
export declare const flexibleChecksumsInputMiddlewareOptions: RelativeMiddlewareOptions;
/**
 * @internal
 *
 * The input counterpart to the flexibleChecksumsMiddleware.
 */
export declare const flexibleChecksumsInputMiddleware: (config: PreviouslyResolved, middlewareConfig: FlexibleChecksumsInputMiddlewareConfig) => SerializeMiddleware<any, any>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-flexible-checksums/dist-types/flexibleChecksumsMiddleware.d.ts

```typescript
import { BuildHandlerOptions, BuildMiddleware } from "@smithy/types";
import { PreviouslyResolved } from "./configuration";
/**
 * @internal
 */
export interface FlexibleChecksumsRequestMiddlewareConfig {
    /**
     * Indicates an operation requires a checksum in its HTTP request.
     */
    requestChecksumRequired: boolean;
    /**
     * Member that is used to configure request checksum behavior.
     */
    requestAlgorithmMember?: {
        /**
         * Defines a top-level operation input member that is used to configure request checksum behavior.
         */
        name: string;
        /**
         * The {@link httpHeader} value, if present.
         * {@link https://smithy.io/2.0/spec/http-bindings.html#httpheader-trait httpHeader}
         */
        httpHeader?: string;
    };
}
/**
 * @internal
 */
export declare const flexibleChecksumsMiddlewareOptions: BuildHandlerOptions;
/**
 * @internal
 */
export declare const flexibleChecksumsMiddleware: (config: PreviouslyResolved, middlewareConfig: FlexibleChecksumsRequestMiddlewareConfig) => BuildMiddleware<any, any>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-flexible-checksums/dist-types/flexibleChecksumsResponseMiddleware.d.ts

```typescript
import { DeserializeMiddleware, RelativeMiddlewareOptions } from "@smithy/types";
import { PreviouslyResolved } from "./configuration";
/**
 * @internal
 */
export interface FlexibleChecksumsResponseMiddlewareConfig {
    /**
     * Defines a top-level operation input member used to opt-in to best-effort validation
     * of a checksum returned in the HTTP response of the operation.
     */
    requestValidationModeMember?: string;
    /**
     * Defines the checksum algorithms clients SHOULD look for when validating checksums
     * returned in the HTTP response.
     */
    responseAlgorithms?: string[];
}
/**
 * @internal
 */
export declare const flexibleChecksumsResponseMiddlewareOptions: RelativeMiddlewareOptions;
/**
 * @internal
 *
 * The validation counterpart to the flexibleChecksumsMiddleware.
 */
export declare const flexibleChecksumsResponseMiddleware: (config: PreviouslyResolved, middlewareConfig: FlexibleChecksumsResponseMiddlewareConfig) => DeserializeMiddleware<any, any>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-flexible-checksums/dist-types/getChecksum.d.ts

```typescript
import { ChecksumConstructor, Encoder, HashConstructor } from "@smithy/types";
export interface GetChecksumDigestOptions {
    checksumAlgorithmFn: ChecksumConstructor | HashConstructor;
    base64Encoder: Encoder;
}
export declare const getChecksum: (body: unknown, { checksumAlgorithmFn, base64Encoder }: GetChecksumDigestOptions) => Promise<string>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-flexible-checksums/dist-types/getChecksumAlgorithmForRequest.d.ts

```typescript
import { ChecksumAlgorithm, RequestChecksumCalculation } from "./constants";
export interface GetChecksumAlgorithmForRequestOptions {
    /**
     * Indicates an operation requires a checksum in its HTTP request.
     */
    requestChecksumRequired: boolean;
    /**
     * Defines a top-level operation input member that is used to configure request checksum behavior.
     */
    requestAlgorithmMember?: string;
    /**
     * Determines when a checksum will be calculated for request payloads
     */
    requestChecksumCalculation: RequestChecksumCalculation;
}
/**
 * Returns the checksum algorithm to use for the request, along with
 * the priority array of location to use to populate checksum and names
 * to be used as a key at the location.
 */
export declare const getChecksumAlgorithmForRequest: (input: any, { requestChecksumRequired, requestAlgorithmMember, requestChecksumCalculation }: GetChecksumAlgorithmForRequestOptions) => ChecksumAlgorithm | undefined;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-flexible-checksums/dist-types/getChecksumAlgorithmListForResponse.d.ts

```typescript
import { ChecksumAlgorithm } from "./constants";
/**
 * Returns the priority array of algorithm to use to verify checksum and names
 * to be used as a key in the response header.
 */
export declare const getChecksumAlgorithmListForResponse: (responseAlgorithms?: string[]) => ChecksumAlgorithm[];

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-flexible-checksums/dist-types/getChecksumLocationName.d.ts

```typescript
import { ChecksumAlgorithm } from "./constants";
/**
 * Returns location (header/trailer) name to use to populate checksum in.
 */
export declare const getChecksumLocationName: (algorithm: ChecksumAlgorithm) => string;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-flexible-checksums/dist-types/getCrc32ChecksumAlgorithmFunction.browser.d.ts

```typescript
import { AwsCrc32 } from "@aws-crypto/crc32";
export declare const getCrc32ChecksumAlgorithmFunction: () => typeof AwsCrc32;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-flexible-checksums/dist-types/getCrc32ChecksumAlgorithmFunction.d.ts

```typescript
import { AwsCrc32 } from "@aws-crypto/crc32";
import { Checksum } from "@smithy/types";
declare class NodeCrc32 implements Checksum {
    private checksum;
    update(data: Uint8Array): void;
    digest(): Promise<Uint8Array>;
    reset(): void;
}
export declare const getCrc32ChecksumAlgorithmFunction: () => typeof NodeCrc32 | typeof AwsCrc32;
export {};

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-flexible-checksums/dist-types/getFlexibleChecksumsPlugin.d.ts

```typescript
import { Pluggable } from "@smithy/types";
import { PreviouslyResolved } from "./configuration";
import { FlexibleChecksumsInputMiddlewareConfig } from "./flexibleChecksumsInputMiddleware";
import { FlexibleChecksumsRequestMiddlewareConfig } from "./flexibleChecksumsMiddleware";
import { FlexibleChecksumsResponseMiddlewareConfig } from "./flexibleChecksumsResponseMiddleware";
/**
 * @internal
 */
export interface FlexibleChecksumsMiddlewareConfig extends FlexibleChecksumsRequestMiddlewareConfig, FlexibleChecksumsInputMiddlewareConfig, FlexibleChecksumsResponseMiddlewareConfig {
}
/**
 * @internal
 */
export declare const getFlexibleChecksumsPlugin: (config: PreviouslyResolved, middlewareConfig: FlexibleChecksumsMiddlewareConfig) => Pluggable<any, any>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-flexible-checksums/dist-types/hasHeader.d.ts

```typescript
import { HeaderBag } from "@smithy/types";
/**
 * Returns true if header is present in headers.
 * Comparisons are case-insensitive.
 */
export declare const hasHeader: (header: string, headers: HeaderBag) => boolean;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-flexible-checksums/dist-types/hasHeaderWithPrefix.d.ts

```typescript
import { HeaderBag } from "@smithy/types";
/**
 * Returns true if header with headerPrefix is present in headers.
 * Comparisons are case-insensitive.
 */
export declare const hasHeaderWithPrefix: (headerPrefix: string, headers: HeaderBag) => boolean;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-flexible-checksums/dist-types/index.d.ts

```typescript
export * from "./NODE_REQUEST_CHECKSUM_CALCULATION_CONFIG_OPTIONS";
export * from "./NODE_RESPONSE_CHECKSUM_VALIDATION_CONFIG_OPTIONS";
export * from "./constants";
export * from "./crc64-nvme-crt-container";
export * from "./flexibleChecksumsMiddleware";
export * from "./getFlexibleChecksumsPlugin";
export * from "./resolveFlexibleChecksumsConfig";

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-flexible-checksums/dist-types/isChecksumWithPartNumber.d.ts

```typescript
export declare const isChecksumWithPartNumber: (checksum: string) => boolean;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-flexible-checksums/dist-types/isStreaming.d.ts

```typescript
/**
 * Returns true if the given value is a streaming response.
 */
export declare const isStreaming: (body: unknown) => boolean;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-flexible-checksums/dist-types/resolveFlexibleChecksumsConfig.d.ts

```typescript
import { Provider } from "@smithy/types";
import { RequestChecksumCalculation, ResponseChecksumValidation } from "./constants";
/**
 * @public
 */
export interface FlexibleChecksumsInputConfig {
    /**
     * Determines when a checksum will be calculated for request payloads.
     */
    requestChecksumCalculation?: RequestChecksumCalculation | Provider<RequestChecksumCalculation>;
    /**
     * Determines when checksum validation will be performed on response payloads.
     */
    responseChecksumValidation?: ResponseChecksumValidation | Provider<ResponseChecksumValidation>;
    /**
     * Default 0 (off).
     *
     * When set to a value greater than or equal to 8192, sets the minimum number
     * of bytes to buffer into a chunk when processing input streams
     * with chunked encoding (that is, when request checksums are enabled).
     * A minimum of 8kb = 8 * 1024 is required, and 64kb or higher is recommended.
     *
     * See https://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-streaming.html.
     *
     * This has a slight performance penalty because it must wrap and buffer
     * your input stream.
     * You do not need to set this value if your stream already flows chunks
     * of 8kb or greater.
     */
    requestStreamBufferSize?: number | false;
}
/**
 * @internal
 */
export interface FlexibleChecksumsResolvedConfig {
    requestChecksumCalculation: Provider<RequestChecksumCalculation>;
    responseChecksumValidation: Provider<ResponseChecksumValidation>;
    requestStreamBufferSize: number;
}
/**
 * @internal
 */
export declare const resolveFlexibleChecksumsConfig: <T>(input: T & FlexibleChecksumsInputConfig) => T & FlexibleChecksumsResolvedConfig;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-flexible-checksums/dist-types/selectChecksumAlgorithmFunction.d.ts

```typescript
import { ChecksumConstructor, HashConstructor } from "@smithy/types";
import { PreviouslyResolved } from "./configuration";
import { ChecksumAlgorithm } from "./constants";
/**
 * Returns the function that will compute the checksum for the given {@link ChecksumAlgorithm}.
 */
export declare const selectChecksumAlgorithmFunction: (checksumAlgorithm: ChecksumAlgorithm, config: PreviouslyResolved) => ChecksumConstructor | HashConstructor;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-flexible-checksums/dist-types/stringHasher.d.ts

```typescript
import { ChecksumConstructor, HashConstructor } from "@smithy/types";
/**
 * A function that, given a hash constructor and a string, calculates the hash of the string.
 */
export declare const stringHasher: (checksumAlgorithmFn: ChecksumConstructor | HashConstructor, body: any) => Promise<Uint8Array>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-flexible-checksums/dist-types/stringUnionSelector.d.ts

```typescript
export declare enum SelectorType {
    ENV = "env",
    CONFIG = "shared config entry"
}
/**
 * Returns undefined, if obj[key] is not defined.
 * Returns string value, if the string is defined in obj[key] and it's uppercase matches union value.
 * Throws error for all other cases.
 *
 * @internal
 */
export declare const stringUnionSelector: <U extends object, K extends keyof U>(obj: Record<string, string | undefined>, key: string, union: U, type: SelectorType) => U[K] | undefined;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-flexible-checksums/dist-types/ts3.4/NODE_REQUEST_CHECKSUM_CALCULATION_CONFIG_OPTIONS.d.ts

```typescript
import { LoadedConfigSelectors } from "@smithy/node-config-provider";
import { RequestChecksumCalculation } from "./constants";
export declare const ENV_REQUEST_CHECKSUM_CALCULATION =
  "AWS_REQUEST_CHECKSUM_CALCULATION";
export declare const CONFIG_REQUEST_CHECKSUM_CALCULATION =
  "request_checksum_calculation";
export declare const NODE_REQUEST_CHECKSUM_CALCULATION_CONFIG_OPTIONS: LoadedConfigSelectors<RequestChecksumCalculation>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-flexible-checksums/dist-types/ts3.4/NODE_RESPONSE_CHECKSUM_VALIDATION_CONFIG_OPTIONS.d.ts

```typescript
import { LoadedConfigSelectors } from "@smithy/node-config-provider";
import { ResponseChecksumValidation } from "./constants";
export declare const ENV_RESPONSE_CHECKSUM_VALIDATION =
  "AWS_RESPONSE_CHECKSUM_VALIDATION";
export declare const CONFIG_RESPONSE_CHECKSUM_VALIDATION =
  "response_checksum_validation";
export declare const NODE_RESPONSE_CHECKSUM_VALIDATION_CONFIG_OPTIONS: LoadedConfigSelectors<ResponseChecksumValidation>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-flexible-checksums/dist-types/ts3.4/configuration.d.ts

```typescript
import {
  BodyLengthCalculator,
  ChecksumConstructor,
  Encoder,
  GetAwsChunkedEncodingStream,
  HashConstructor,
  Provider,
  StreamCollector,
  StreamHasher,
} from "@smithy/types";
import {
  RequestChecksumCalculation,
  ResponseChecksumValidation,
} from "./constants";
export interface PreviouslyResolved {
  base64Encoder: Encoder;
  bodyLengthChecker: BodyLengthCalculator;
  getAwsChunkedEncodingStream: GetAwsChunkedEncodingStream;
  md5: ChecksumConstructor | HashConstructor;
  requestChecksumCalculation: Provider<RequestChecksumCalculation>;
  responseChecksumValidation: Provider<ResponseChecksumValidation>;
  sha1: ChecksumConstructor | HashConstructor;
  sha256: ChecksumConstructor | HashConstructor;
  streamHasher: StreamHasher<any>;
  streamCollector: StreamCollector;
  requestStreamBufferSize: number;
}

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-flexible-checksums/dist-types/ts3.4/constants.d.ts

```typescript
export declare const RequestChecksumCalculation: {
  readonly WHEN_SUPPORTED: "WHEN_SUPPORTED";
  readonly WHEN_REQUIRED: "WHEN_REQUIRED";
};
export type RequestChecksumCalculation =
  (typeof RequestChecksumCalculation)[keyof typeof RequestChecksumCalculation];
export declare const DEFAULT_REQUEST_CHECKSUM_CALCULATION: "WHEN_SUPPORTED";
export declare const ResponseChecksumValidation: {
  readonly WHEN_SUPPORTED: "WHEN_SUPPORTED";
  readonly WHEN_REQUIRED: "WHEN_REQUIRED";
};
export type ResponseChecksumValidation =
  (typeof ResponseChecksumValidation)[keyof typeof ResponseChecksumValidation];
export declare const DEFAULT_RESPONSE_CHECKSUM_VALIDATION: "WHEN_SUPPORTED";
export declare enum ChecksumAlgorithm {
  MD5 = "MD5",
  CRC32 = "CRC32",
  CRC32C = "CRC32C",
  CRC64NVME = "CRC64NVME",
  SHA1 = "SHA1",
  SHA256 = "SHA256",
}
export declare enum ChecksumLocation {
  HEADER = "header",
  TRAILER = "trailer",
}
export declare const DEFAULT_CHECKSUM_ALGORITHM = ChecksumAlgorithm.CRC32;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-flexible-checksums/dist-types/ts3.4/crc64-nvme-crt-container.d.ts

```typescript
import { ChecksumConstructor } from "@smithy/types";
export declare const crc64NvmeCrtContainer: {
  CrtCrc64Nvme: null | ChecksumConstructor;
};

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-flexible-checksums/dist-types/ts3.4/flexibleChecksumsInputMiddleware.d.ts

```typescript
import { RelativeMiddlewareOptions, SerializeMiddleware } from "@smithy/types";
import { PreviouslyResolved } from "./configuration";
export interface FlexibleChecksumsInputMiddlewareConfig {
  requestValidationModeMember?: string;
}
export declare const flexibleChecksumsInputMiddlewareOptions: RelativeMiddlewareOptions;
export declare const flexibleChecksumsInputMiddleware: (
  config: PreviouslyResolved,
  middlewareConfig: FlexibleChecksumsInputMiddlewareConfig
) => SerializeMiddleware<any, any>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-flexible-checksums/dist-types/ts3.4/flexibleChecksumsMiddleware.d.ts

```typescript
import { BuildHandlerOptions, BuildMiddleware } from "@smithy/types";
import { PreviouslyResolved } from "./configuration";
export interface FlexibleChecksumsRequestMiddlewareConfig {
  requestChecksumRequired: boolean;
  requestAlgorithmMember?: {
    name: string;
    httpHeader?: string;
  };
}
export declare const flexibleChecksumsMiddlewareOptions: BuildHandlerOptions;
export declare const flexibleChecksumsMiddleware: (
  config: PreviouslyResolved,
  middlewareConfig: FlexibleChecksumsRequestMiddlewareConfig
) => BuildMiddleware<any, any>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-flexible-checksums/dist-types/ts3.4/flexibleChecksumsResponseMiddleware.d.ts

```typescript
import {
  DeserializeMiddleware,
  RelativeMiddlewareOptions,
} from "@smithy/types";
import { PreviouslyResolved } from "./configuration";
export interface FlexibleChecksumsResponseMiddlewareConfig {
  requestValidationModeMember?: string;
  responseAlgorithms?: string[];
}
export declare const flexibleChecksumsResponseMiddlewareOptions: RelativeMiddlewareOptions;
export declare const flexibleChecksumsResponseMiddleware: (
  config: PreviouslyResolved,
  middlewareConfig: FlexibleChecksumsResponseMiddlewareConfig
) => DeserializeMiddleware<any, any>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-flexible-checksums/dist-types/ts3.4/getChecksum.d.ts

```typescript
import { ChecksumConstructor, Encoder, HashConstructor } from "@smithy/types";
export interface GetChecksumDigestOptions {
  checksumAlgorithmFn: ChecksumConstructor | HashConstructor;
  base64Encoder: Encoder;
}
export declare const getChecksum: (
  body: unknown,
  { checksumAlgorithmFn, base64Encoder }: GetChecksumDigestOptions
) => Promise<string>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-flexible-checksums/dist-types/ts3.4/getChecksumAlgorithmForRequest.d.ts

```typescript
import { ChecksumAlgorithm, RequestChecksumCalculation } from "./constants";
export interface GetChecksumAlgorithmForRequestOptions {
  requestChecksumRequired: boolean;
  requestAlgorithmMember?: string;
  requestChecksumCalculation: RequestChecksumCalculation;
}
export declare const getChecksumAlgorithmForRequest: (
  input: any,
  {
    requestChecksumRequired,
    requestAlgorithmMember,
    requestChecksumCalculation,
  }: GetChecksumAlgorithmForRequestOptions
) => ChecksumAlgorithm | undefined;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-flexible-checksums/dist-types/ts3.4/getChecksumAlgorithmListForResponse.d.ts

```typescript
import { ChecksumAlgorithm } from "./constants";
export declare const getChecksumAlgorithmListForResponse: (
  responseAlgorithms?: string[]
) => ChecksumAlgorithm[];

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-flexible-checksums/dist-types/ts3.4/getChecksumLocationName.d.ts

```typescript
import { ChecksumAlgorithm } from "./constants";
export declare const getChecksumLocationName: (
  algorithm: ChecksumAlgorithm
) => string;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-flexible-checksums/dist-types/ts3.4/getCrc32ChecksumAlgorithmFunction.browser.d.ts

```typescript
import { AwsCrc32 } from "@aws-crypto/crc32";
export declare const getCrc32ChecksumAlgorithmFunction: () => typeof AwsCrc32;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-flexible-checksums/dist-types/ts3.4/getCrc32ChecksumAlgorithmFunction.d.ts

```typescript
import { AwsCrc32 } from "@aws-crypto/crc32";
import { Checksum } from "@smithy/types";
declare class NodeCrc32 implements Checksum {
  private checksum;
  update(data: Uint8Array): void;
  digest(): Promise<Uint8Array>;
  reset(): void;
}
export declare const getCrc32ChecksumAlgorithmFunction: () =>
  | typeof NodeCrc32
  | typeof AwsCrc32;
export {};

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-flexible-checksums/dist-types/ts3.4/getFlexibleChecksumsPlugin.d.ts

```typescript
import { Pluggable } from "@smithy/types";
import { PreviouslyResolved } from "./configuration";
import { FlexibleChecksumsInputMiddlewareConfig } from "./flexibleChecksumsInputMiddleware";
import { FlexibleChecksumsRequestMiddlewareConfig } from "./flexibleChecksumsMiddleware";
import { FlexibleChecksumsResponseMiddlewareConfig } from "./flexibleChecksumsResponseMiddleware";
export interface FlexibleChecksumsMiddlewareConfig
  extends FlexibleChecksumsRequestMiddlewareConfig,
    FlexibleChecksumsInputMiddlewareConfig,
    FlexibleChecksumsResponseMiddlewareConfig {}
export declare const getFlexibleChecksumsPlugin: (
  config: PreviouslyResolved,
  middlewareConfig: FlexibleChecksumsMiddlewareConfig
) => Pluggable<any, any>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-flexible-checksums/dist-types/ts3.4/hasHeader.d.ts

```typescript
import { HeaderBag } from "@smithy/types";
export declare const hasHeader: (header: string, headers: HeaderBag) => boolean;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-flexible-checksums/dist-types/ts3.4/hasHeaderWithPrefix.d.ts

```typescript
import { HeaderBag } from "@smithy/types";
export declare const hasHeaderWithPrefix: (
  headerPrefix: string,
  headers: HeaderBag
) => boolean;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-flexible-checksums/dist-types/ts3.4/index.d.ts

```typescript
export * from "./NODE_REQUEST_CHECKSUM_CALCULATION_CONFIG_OPTIONS";
export * from "./NODE_RESPONSE_CHECKSUM_VALIDATION_CONFIG_OPTIONS";
export * from "./constants";
export * from "./crc64-nvme-crt-container";
export * from "./flexibleChecksumsMiddleware";
export * from "./getFlexibleChecksumsPlugin";
export * from "./resolveFlexibleChecksumsConfig";

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-flexible-checksums/dist-types/ts3.4/isChecksumWithPartNumber.d.ts

```typescript
export declare const isChecksumWithPartNumber: (checksum: string) => boolean;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-flexible-checksums/dist-types/ts3.4/isStreaming.d.ts

```typescript
export declare const isStreaming: (body: unknown) => boolean;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-flexible-checksums/dist-types/ts3.4/resolveFlexibleChecksumsConfig.d.ts

```typescript
import { Provider } from "@smithy/types";
import {
  RequestChecksumCalculation,
  ResponseChecksumValidation,
} from "./constants";
export interface FlexibleChecksumsInputConfig {
  requestChecksumCalculation?:
    | RequestChecksumCalculation
    | Provider<RequestChecksumCalculation>;
  responseChecksumValidation?:
    | ResponseChecksumValidation
    | Provider<ResponseChecksumValidation>;
  requestStreamBufferSize?: number | false;
}
export interface FlexibleChecksumsResolvedConfig {
  requestChecksumCalculation: Provider<RequestChecksumCalculation>;
  responseChecksumValidation: Provider<ResponseChecksumValidation>;
  requestStreamBufferSize: number;
}
export declare const resolveFlexibleChecksumsConfig: <T>(
  input: T & FlexibleChecksumsInputConfig
) => T & FlexibleChecksumsResolvedConfig;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-flexible-checksums/dist-types/ts3.4/selectChecksumAlgorithmFunction.d.ts

```typescript
import { ChecksumConstructor, HashConstructor } from "@smithy/types";
import { PreviouslyResolved } from "./configuration";
import { ChecksumAlgorithm } from "./constants";
export declare const selectChecksumAlgorithmFunction: (
  checksumAlgorithm: ChecksumAlgorithm,
  config: PreviouslyResolved
) => ChecksumConstructor | HashConstructor;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-flexible-checksums/dist-types/ts3.4/stringHasher.d.ts

```typescript
import { ChecksumConstructor, HashConstructor } from "@smithy/types";
export declare const stringHasher: (
  checksumAlgorithmFn: ChecksumConstructor | HashConstructor,
  body: any
) => Promise<Uint8Array>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-flexible-checksums/dist-types/ts3.4/stringUnionSelector.d.ts

```typescript
export declare enum SelectorType {
  ENV = "env",
  CONFIG = "shared config entry",
}
export declare const stringUnionSelector: <U extends object, K extends keyof U>(
  obj: Record<string, string | undefined>,
  key: string,
  union: U,
  type: SelectorType
) => U[K] | undefined;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-flexible-checksums/dist-types/ts3.4/types.d.ts

```typescript
import { ChecksumAlgorithm } from "./constants";
export declare const CLIENT_SUPPORTED_ALGORITHMS: ChecksumAlgorithm[];
export declare const PRIORITY_ORDER_ALGORITHMS: ChecksumAlgorithm[];

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-flexible-checksums/dist-types/ts3.4/validateChecksumFromResponse.d.ts

```typescript
import { HttpResponse } from "@smithy/protocol-http";
import { Logger } from "@smithy/types";
import { PreviouslyResolved } from "./configuration";
export interface ValidateChecksumFromResponseOptions {
  config: PreviouslyResolved;
  responseAlgorithms?: string[];
  logger?: Logger;
}
export declare const validateChecksumFromResponse: (
  response: HttpResponse,
  { config, responseAlgorithms, logger }: ValidateChecksumFromResponseOptions
) => Promise<void>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-flexible-checksums/dist-types/types.d.ts

```typescript
import { ChecksumAlgorithm } from "./constants";
/**
 * List of algorithms supported by client.
 */
export declare const CLIENT_SUPPORTED_ALGORITHMS: ChecksumAlgorithm[];
/**
 * Priority order for validating checksum algorithm. A faster algorithm has higher priority.
 */
export declare const PRIORITY_ORDER_ALGORITHMS: ChecksumAlgorithm[];

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-flexible-checksums/dist-types/validateChecksumFromResponse.d.ts

```typescript
import { HttpResponse } from "@smithy/protocol-http";
import { Logger } from "@smithy/types";
import { PreviouslyResolved } from "./configuration";
export interface ValidateChecksumFromResponseOptions {
    config: PreviouslyResolved;
    /**
     * Defines the checksum algorithms clients SHOULD look for when validating checksums
     * returned in the HTTP response.
     */
    responseAlgorithms?: string[];
    logger?: Logger;
}
export declare const validateChecksumFromResponse: (response: HttpResponse, { config, responseAlgorithms, logger }: ValidateChecksumFromResponseOptions) => Promise<void>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-flexible-checksums/package.json

```json
{
  "name": "@aws-sdk/middleware-flexible-checksums",
  "version": "3.911.0",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "node ../../scripts/compilation/inline middleware-flexible-checksums",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "extract:docs": "api-extractor run --local",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch",
    "test:integration": "yarn g:vitest run -c vitest.config.integ.mts",
    "test:integration:watch": "yarn g:vitest watch -c vitest.config.integ.mts",
    "test:e2e": "yarn g:vitest run -c vitest.config.e2e.mts",
    "test:e2e:watch": "yarn g:vitest watch -c vitest.config.e2e.mts"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "browser": {
    "./dist-es/getCrc32ChecksumAlgorithmFunction": "./dist-es/getCrc32ChecksumAlgorithmFunction.browser"
  },
  "react-native": {
    "./dist-es/getCrc32ChecksumAlgorithmFunction": "./dist-es/getCrc32ChecksumAlgorithmFunction.browser",
    "./dist-cjs/getCrc32ChecksumAlgorithmFunction": "./dist-cjs/getCrc32ChecksumAlgorithmFunction.browser"
  },
  "types": "./dist-types/index.d.ts",
  "sideEffects": false,
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "dependencies": {
    "@aws-crypto/crc32": "5.2.0",
    "@aws-crypto/crc32c": "5.2.0",
    "@aws-crypto/util": "5.2.0",
    "@aws-sdk/core": "3.911.0",
    "@aws-sdk/types": "3.910.0",
    "@smithy/is-array-buffer": "^4.2.0",
    "@smithy/node-config-provider": "^4.3.2",
    "@smithy/protocol-http": "^5.3.2",
    "@smithy/types": "^4.7.1",
    "@smithy/util-middleware": "^4.2.2",
    "@smithy/util-stream": "^4.5.2",
    "@smithy/util-utf8": "^4.2.0",
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "@smithy/node-http-handler": "^4.4.1",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typescript": "~5.8.3"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/aws/aws-sdk-js-v3/tree/main/packages/middleware-flexible-checksums",
  "repository": {
    "type": "git",
    "url": "https://github.com/aws/aws-sdk-js-v3.git",
    "directory": "packages/middleware-flexible-checksums"
  }
}

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-host-header/dist-types/index.d.ts

```typescript
import { AbsoluteLocation, BuildHandlerOptions, BuildMiddleware, Pluggable, RequestHandler } from "@smithy/types";
/**
 * @public
 */
export interface HostHeaderInputConfig {
}
interface PreviouslyResolved {
    requestHandler: RequestHandler<any, any>;
}
/**
 * @internal
 */
export interface HostHeaderResolvedConfig {
    /**
     * The HTTP handler to use. Fetch in browser and Https in Nodejs.
     */
    requestHandler: RequestHandler<any, any>;
}
/**
 * @internal
 */
export declare function resolveHostHeaderConfig<T>(input: T & PreviouslyResolved & HostHeaderInputConfig): T & HostHeaderResolvedConfig;
/**
 * @internal
 */
export declare const hostHeaderMiddleware: <Input extends object, Output extends object>(options: HostHeaderResolvedConfig) => BuildMiddleware<Input, Output>;
/**
 * @internal
 */
export declare const hostHeaderMiddlewareOptions: BuildHandlerOptions & AbsoluteLocation;
/**
 * @internal
 */
export declare const getHostHeaderPlugin: (options: HostHeaderResolvedConfig) => Pluggable<any, any>;
export {};

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-host-header/dist-types/ts3.4/index.d.ts

```typescript
import {
  AbsoluteLocation,
  BuildHandlerOptions,
  BuildMiddleware,
  Pluggable,
  RequestHandler,
} from "@smithy/types";
export interface HostHeaderInputConfig {}
interface PreviouslyResolved {
  requestHandler: RequestHandler<any, any>;
}
export interface HostHeaderResolvedConfig {
  requestHandler: RequestHandler<any, any>;
}
export declare function resolveHostHeaderConfig<T>(
  input: T & PreviouslyResolved & HostHeaderInputConfig
): T & HostHeaderResolvedConfig;
export declare const hostHeaderMiddleware: <
  Input extends object,
  Output extends object
>(
  options: HostHeaderResolvedConfig
) => BuildMiddleware<Input, Output>;
export declare const hostHeaderMiddlewareOptions: BuildHandlerOptions &
  AbsoluteLocation;
export declare const getHostHeaderPlugin: (
  options: HostHeaderResolvedConfig
) => Pluggable<any, any>;
export {};

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-host-header/package.json

```json
{
  "name": "@aws-sdk/middleware-host-header",
  "version": "3.910.0",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "node ../../scripts/compilation/inline middleware-host-header",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "extract:docs": "api-extractor run --local",
    "test": "yarn g:vitest run",
    "test:integration": "yarn g:vitest run -c vitest.config.integ.mts",
    "test:watch": "yarn g:vitest watch",
    "test:integration:watch": "yarn g:vitest watch -c vitest.config.integ.mts"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "sideEffects": false,
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "dependencies": {
    "@aws-sdk/types": "3.910.0",
    "@smithy/protocol-http": "^5.3.2",
    "@smithy/types": "^4.7.1",
    "tslib": "^2.6.2"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/aws/aws-sdk-js-v3/tree/main/packages/middleware-host-header",
  "repository": {
    "type": "git",
    "url": "https://github.com/aws/aws-sdk-js-v3.git",
    "directory": "packages/middleware-host-header"
  },
  "devDependencies": {
    "@tsconfig/recommended": "1.0.1",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typescript": "~5.8.3"
  }
}

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-location-constraint/dist-types/configuration.d.ts

```typescript
import { Provider } from "@smithy/types";
/**
 * @public
 */
export interface LocationConstraintInputConfig {
}
interface PreviouslyResolved {
    region: Provider<string>;
}
export interface LocationConstraintResolvedConfig {
    /**
     * Resolved value for input config {@link RegionInputConfig.region}
     */
    region: Provider<string>;
}
export declare function resolveLocationConstraintConfig<T>(input: T & LocationConstraintInputConfig & PreviouslyResolved): T & LocationConstraintResolvedConfig;
export {};

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-location-constraint/dist-types/index.d.ts

```typescript
import { InitializeHandlerOptions, InitializeMiddleware, Pluggable } from "@smithy/types";
import { LocationConstraintResolvedConfig } from "./configuration";
/**
 * This middleware modifies the input on S3 CreateBucket requests.  If the LocationConstraint has not been set, this
 * middleware will set a LocationConstraint to match the configured region.  The CreateBucketConfiguration will be
 * removed entirely on requests to the us-east-1 region.
 */
export declare function locationConstraintMiddleware(options: LocationConstraintResolvedConfig): InitializeMiddleware<any, any>;
export declare const locationConstraintMiddlewareOptions: InitializeHandlerOptions;
export declare const getLocationConstraintPlugin: (config: LocationConstraintResolvedConfig) => Pluggable<any, any>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-location-constraint/dist-types/ts3.4/configuration.d.ts

```typescript
import { Provider } from "@smithy/types";
export interface LocationConstraintInputConfig {}
interface PreviouslyResolved {
  region: Provider<string>;
}
export interface LocationConstraintResolvedConfig {
  region: Provider<string>;
}
export declare function resolveLocationConstraintConfig<T>(
  input: T & LocationConstraintInputConfig & PreviouslyResolved
): T & LocationConstraintResolvedConfig;
export {};

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-location-constraint/dist-types/ts3.4/index.d.ts

```typescript
import {
  InitializeHandlerOptions,
  InitializeMiddleware,
  Pluggable,
} from "@smithy/types";
import { LocationConstraintResolvedConfig } from "./configuration";
export declare function locationConstraintMiddleware(
  options: LocationConstraintResolvedConfig
): InitializeMiddleware<any, any>;
export declare const locationConstraintMiddlewareOptions: InitializeHandlerOptions;
export declare const getLocationConstraintPlugin: (
  config: LocationConstraintResolvedConfig
) => Pluggable<any, any>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-location-constraint/package.json

```json
{
  "name": "@aws-sdk/middleware-location-constraint",
  "version": "3.910.0",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "node ../../scripts/compilation/inline middleware-location-constraint",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "test": "yarn g:vitest run",
    "test:integration": "yarn g:vitest run -c vitest.config.integ.mts",
    "test:watch": "yarn g:vitest watch",
    "test:integration:watch": "yarn g:vitest watch -c vitest.config.integ.mts"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "sideEffects": false,
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "dependencies": {
    "@aws-sdk/types": "3.910.0",
    "@smithy/types": "^4.7.1",
    "tslib": "^2.6.2"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/aws/aws-sdk-js-v3/tree/main/packages/middleware-location-constraint",
  "repository": {
    "type": "git",
    "url": "https://github.com/aws/aws-sdk-js-v3.git",
    "directory": "packages/middleware-location-constraint"
  },
  "devDependencies": {
    "@tsconfig/recommended": "1.0.1",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typescript": "~5.8.3"
  }
}

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-logger/dist-types/index.d.ts

```typescript
export * from "./loggerMiddleware";

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-logger/dist-types/loggerMiddleware.d.ts

```typescript
import type { AbsoluteLocation, HandlerExecutionContext, InitializeHandler, InitializeHandlerOptions, MetadataBearer, Pluggable } from "@smithy/types";
export declare const loggerMiddleware: () => <Output extends MetadataBearer = MetadataBearer>(next: InitializeHandler<any, Output>, context: HandlerExecutionContext) => InitializeHandler<any, Output>;
export declare const loggerMiddlewareOptions: InitializeHandlerOptions & AbsoluteLocation;
export declare const getLoggerPlugin: (options: any) => Pluggable<any, any>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-logger/dist-types/ts3.4/index.d.ts

```typescript
export * from "./loggerMiddleware";

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-logger/dist-types/ts3.4/loggerMiddleware.d.ts

```typescript
import {
  AbsoluteLocation,
  HandlerExecutionContext,
  InitializeHandler,
  InitializeHandlerOptions,
  MetadataBearer,
  Pluggable,
} from "@smithy/types";
export declare const loggerMiddleware: () => <
  Output extends MetadataBearer = MetadataBearer
>(
  next: InitializeHandler<any, Output>,
  context: HandlerExecutionContext
) => InitializeHandler<any, Output>;
export declare const loggerMiddlewareOptions: InitializeHandlerOptions &
  AbsoluteLocation;
export declare const getLoggerPlugin: (options: any) => Pluggable<any, any>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-logger/package.json

```json
{
  "name": "@aws-sdk/middleware-logger",
  "version": "3.910.0",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "node ../../scripts/compilation/inline middleware-logger",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "test": "yarn g:vitest run",
    "test:integration": "yarn g:vitest run -c vitest.config.integ.mts",
    "test:watch": "yarn g:vitest watch",
    "test:integration:watch": "yarn g:vitest watch -c vitest.config.integ.mts"
  },
  "sideEffects": false,
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "email": "",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "dependencies": {
    "@aws-sdk/types": "3.910.0",
    "@smithy/types": "^4.7.1",
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "@tsconfig/recommended": "1.0.1",
    "@types/node": "^18.19.69",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typescript": "~5.8.3"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/aws/aws-sdk-js-v3/tree/main/packages/middleware-logger",
  "repository": {
    "type": "git",
    "url": "https://github.com/aws/aws-sdk-js-v3.git",
    "directory": "packages/middleware-logger"
  }
}

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-recursion-detection/dist-types/configuration.d.ts

```typescript
import { AbsoluteLocation, BuildHandlerOptions } from "@smithy/types";
/**
 * @internal
 */
export declare const recursionDetectionMiddlewareOptions: BuildHandlerOptions & AbsoluteLocation;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-recursion-detection/dist-types/getRecursionDetectionPlugin.d.ts

```typescript
import { Pluggable } from "@smithy/types";
/**
 * @internal
 */
export declare const getRecursionDetectionPlugin: (options: any) => Pluggable<any, any>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-recursion-detection/dist-types/index.d.ts

```typescript
export * from "./getRecursionDetectionPlugin";
export * from "./recursionDetectionMiddleware";

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-recursion-detection/dist-types/recursionDetectionMiddleware.browser.d.ts

```typescript
import { BuildMiddleware } from "@smithy/types";
/**
 * No-op middleware for runtimes outside of Node.js
 * @internal
 */
export declare const recursionDetectionMiddleware: () => BuildMiddleware<any, any>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-recursion-detection/dist-types/recursionDetectionMiddleware.d.ts

```typescript
import { BuildMiddleware } from "@smithy/types";
/**
 * Inject to trace ID to request header to detect recursion invocation in Lambda.
 * @internal
 */
export declare const recursionDetectionMiddleware: () => BuildMiddleware<any, any>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-recursion-detection/dist-types/recursionDetectionMiddleware.native.d.ts

```typescript
import { BuildMiddleware } from "@smithy/types";
/**
 * No-op middleware for runtimes outside of Node.js
 * @internal
 */
export declare const recursionDetectionMiddleware: () => BuildMiddleware<any, any>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-recursion-detection/dist-types/ts3.4/configuration.d.ts

```typescript
import { AbsoluteLocation, BuildHandlerOptions } from "@smithy/types";
export declare const recursionDetectionMiddlewareOptions: BuildHandlerOptions &
  AbsoluteLocation;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-recursion-detection/dist-types/ts3.4/getRecursionDetectionPlugin.d.ts

```typescript
import { Pluggable } from "@smithy/types";
export declare const getRecursionDetectionPlugin: (
  options: any
) => Pluggable<any, any>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-recursion-detection/dist-types/ts3.4/index.d.ts

```typescript
export * from "./getRecursionDetectionPlugin";
export * from "./recursionDetectionMiddleware";

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-recursion-detection/dist-types/ts3.4/recursionDetectionMiddleware.browser.d.ts

```typescript
import { BuildMiddleware } from "@smithy/types";
export declare const recursionDetectionMiddleware: () => BuildMiddleware<
  any,
  any
>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-recursion-detection/dist-types/ts3.4/recursionDetectionMiddleware.d.ts

```typescript
import { BuildMiddleware } from "@smithy/types";
export declare const recursionDetectionMiddleware: () => BuildMiddleware<
  any,
  any
>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-recursion-detection/dist-types/ts3.4/recursionDetectionMiddleware.native.d.ts

```typescript
import { BuildMiddleware } from "@smithy/types";
export declare const recursionDetectionMiddleware: () => BuildMiddleware<
  any,
  any
>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-recursion-detection/package.json

```json
{
  "name": "@aws-sdk/middleware-recursion-detection",
  "version": "3.910.0",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "node ../../scripts/compilation/inline middleware-recursion-detection",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "test": "yarn g:vitest run",
    "test:integration": "yarn g:vitest run -c vitest.config.integ.mts",
    "test:watch": "yarn g:vitest watch",
    "test:integration:watch": "yarn g:vitest watch -c vitest.config.integ.mts"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "sideEffects": false,
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "dependencies": {
    "@aws-sdk/types": "3.910.0",
    "@aws/lambda-invoke-store": "^0.0.1",
    "@smithy/protocol-http": "^5.3.2",
    "@smithy/types": "^4.7.1",
    "tslib": "^2.6.2"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/aws/aws-sdk-js-v3/tree/main/packages/middleware-recursion-detection",
  "repository": {
    "type": "git",
    "url": "https://github.com/aws/aws-sdk-js-v3.git",
    "directory": "packages/middleware-recursion-detection"
  },
  "devDependencies": {
    "@tsconfig/recommended": "1.0.1",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typescript": "~5.8.3"
  },
  "browser": {
    "./dist-es/recursionDetectionMiddleware": "./dist-es/recursionDetectionMiddleware.browser"
  },
  "react-native": {}
}

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-sdk-s3/dist-types/bucket-endpoint-middleware.d.ts

```typescript
import { RelativeMiddlewareOptions, SerializeMiddleware } from "@smithy/types";
interface PreviouslyResolved {
    bucketEndpoint?: boolean;
}
/**
 * @internal
 */
export declare function bucketEndpointMiddleware(options: PreviouslyResolved): SerializeMiddleware<any, any>;
/**
 * @internal
 */
export declare const bucketEndpointMiddlewareOptions: RelativeMiddlewareOptions;
export {};

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-sdk-s3/dist-types/check-content-length-header.d.ts

```typescript
import { FinalizeRequestHandlerOptions, FinalizeRequestMiddleware, Pluggable } from "@smithy/types";
/**
 * @internal
 *
 * Log a warning if the input to PutObject is detected to be a Stream of unknown ContentLength and
 * recommend the usage of the @aws-sdk/lib-storage Upload class.
 */
export declare function checkContentLengthHeader(): FinalizeRequestMiddleware<any, any>;
/**
 * @internal
 */
export declare const checkContentLengthHeaderMiddlewareOptions: FinalizeRequestHandlerOptions;
/**
 * @internal
 */
export declare const getCheckContentLengthHeaderPlugin: (unused: any) => Pluggable<any, any>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-sdk-s3/dist-types/index.d.ts

```typescript
export * from "./check-content-length-header";
export * from "./region-redirect-endpoint-middleware";
export * from "./region-redirect-middleware";
export * from "./s3-expires-middleware";
export * from "./s3-express/index";
export * from "./s3Configuration";
export * from "./throw-200-exceptions";
export * from "./validate-bucket-name";

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-sdk-s3/dist-types/region-redirect-endpoint-middleware.d.ts

```typescript
import { RelativeMiddlewareOptions, SerializeMiddleware } from "@smithy/types";
import { PreviouslyResolved } from "./region-redirect-middleware";
/**
 * @internal
 */
export declare const regionRedirectEndpointMiddleware: (config: PreviouslyResolved) => SerializeMiddleware<any, any>;
/**
 * @internal
 */
export declare const regionRedirectEndpointMiddlewareOptions: RelativeMiddlewareOptions;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-sdk-s3/dist-types/region-redirect-middleware.d.ts

```typescript
import { InitializeHandlerOptions, InitializeMiddleware, Pluggable, Provider } from "@smithy/types";
/**
 * @internal
 */
export interface PreviouslyResolved {
    region: Provider<string>;
    followRegionRedirects: boolean;
}
/**
 * @internal
 */
export declare function regionRedirectMiddleware(clientConfig: PreviouslyResolved): InitializeMiddleware<any, any>;
/**
 * @internal
 */
export declare const regionRedirectMiddlewareOptions: InitializeHandlerOptions;
/**
 * @internal
 */
export declare const getRegionRedirectMiddlewarePlugin: (clientConfig: PreviouslyResolved) => Pluggable<any, any>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-sdk-s3/dist-types/s3-expires-middleware.d.ts

```typescript
import { DeserializeMiddleware, Pluggable, RelativeMiddlewareOptions } from "@smithy/types";
/**
 * @internal
 */
interface PreviouslyResolved {
}
/**
 * @internal
 *
 * From the S3 Expires compatibility spec.
 * A model transform will ensure S3#Expires remains a timestamp shape, though
 * it is deprecated.
 * If a particular object has a non-date string set as the Expires value,
 * the SDK will have the raw string as "ExpiresString" on the response.
 *
 */
export declare const s3ExpiresMiddleware: (config: PreviouslyResolved) => DeserializeMiddleware<any, any>;
/**
 * @internal
 */
export declare const s3ExpiresMiddlewareOptions: RelativeMiddlewareOptions;
/**
 * @internal
 */
export declare const getS3ExpiresMiddlewarePlugin: (clientConfig: PreviouslyResolved) => Pluggable<any, any>;
export {};

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-sdk-s3/dist-types/s3-express/classes/S3ExpressIdentityCache.d.ts

```typescript
import { S3ExpressIdentityCacheEntry } from "./S3ExpressIdentityCacheEntry";
/**
 * @internal
 *
 * Stores identities by key.
 */
export declare class S3ExpressIdentityCache {
    private data;
    private lastPurgeTime;
    static EXPIRED_CREDENTIAL_PURGE_INTERVAL_MS: number;
    constructor(data?: Record<string, S3ExpressIdentityCacheEntry>);
    get(key: string): undefined | S3ExpressIdentityCacheEntry;
    set(key: string, entry: S3ExpressIdentityCacheEntry): S3ExpressIdentityCacheEntry;
    delete(key: string): void;
    purgeExpired(): Promise<void>;
}

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-sdk-s3/dist-types/s3-express/classes/S3ExpressIdentityCacheEntry.d.ts

```typescript
import { S3ExpressIdentity } from "../interfaces/S3ExpressIdentity";
/**
 * @internal
 */
export declare class S3ExpressIdentityCacheEntry {
    private _identity;
    isRefreshing: boolean;
    accessed: number;
    /**
     * @param identity - stored identity.
     * @param accessed - timestamp of last access in epoch ms.
     * @param isRefreshing - this key is currently in the process of being refreshed (background).
     */
    constructor(_identity: Promise<S3ExpressIdentity>, isRefreshing?: boolean, accessed?: number);
    get identity(): Promise<S3ExpressIdentity>;
}

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-sdk-s3/dist-types/s3-express/classes/S3ExpressIdentityProviderImpl.d.ts

```typescript
import { AwsCredentialIdentity } from "@aws-sdk/types";
import { S3ExpressIdentity } from "../interfaces/S3ExpressIdentity";
import { S3ExpressIdentityProvider } from "../interfaces/S3ExpressIdentityProvider";
import { S3ExpressIdentityCache } from "./S3ExpressIdentityCache";
/**
 * @internal
 *
 * This should match S3::CreateSessionCommandOutput::SessionCredentials
 * but it is not imported since that would create a circular dependency.
 */
type Credentials = {
    AccessKeyId: string | undefined;
    SecretAccessKey: string | undefined;
    SessionToken: string | undefined;
    Expiration: Date | undefined;
};
/**
 * @internal
 */
export declare class S3ExpressIdentityProviderImpl implements S3ExpressIdentityProvider {
    private createSessionFn;
    private cache;
    static REFRESH_WINDOW_MS: number;
    constructor(createSessionFn: (key: string) => Promise<{
        Credentials: Credentials;
    }>, cache?: S3ExpressIdentityCache);
    getS3ExpressIdentity(awsIdentity: AwsCredentialIdentity, identityProperties: {
        Bucket: string;
    } & Record<string, string>): Promise<S3ExpressIdentity>;
    private getIdentity;
}
export {};

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-sdk-s3/dist-types/s3-express/classes/SignatureV4S3Express.d.ts

```typescript
import { AwsCredentialIdentity } from "@aws-sdk/types";
import { SignatureV4 } from "@smithy/signature-v4";
import { HttpRequest as IHttpRequest, RequestPresigningArguments, RequestSigningArguments } from "@smithy/types";
export declare class SignatureV4S3Express extends SignatureV4 {
    /**
     * Signs with alternate provided credentials instead of those provided in the
     * constructor.
     *
     * Additionally omits the credential sessionToken and assigns it to the
     * alternate header field for S3 Express.
     */
    signWithCredentials(requestToSign: IHttpRequest, credentials: AwsCredentialIdentity, options?: RequestSigningArguments): Promise<IHttpRequest>;
    /**
     * Similar to {@link SignatureV4S3Express#signWithCredentials} but for presigning.
     */
    presignWithCredentials(requestToSign: IHttpRequest, credentials: AwsCredentialIdentity, options?: RequestPresigningArguments): Promise<IHttpRequest>;
}

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-sdk-s3/dist-types/s3-express/constants.d.ts

```typescript
import type { LoadedConfigSelectors } from "@smithy/node-config-provider";
/**
 * @internal
 *
 * @deprecated will be replaced by backend.
 *
 * TODO(s3-express): non-beta value, backend == S3Express.
 */
export declare const S3_EXPRESS_BUCKET_TYPE = "Directory";
/**
 * @internal
 */
export declare const S3_EXPRESS_BACKEND = "S3Express";
/**
 * @internal
 */
export declare const S3_EXPRESS_AUTH_SCHEME = "sigv4-s3express";
/**
 * @internal
 */
export declare const SESSION_TOKEN_QUERY_PARAM = "X-Amz-S3session-Token";
/**
 * @internal
 */
export declare const SESSION_TOKEN_HEADER: string;
/**
 * @internal
 */
export declare const NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_ENV_NAME = "AWS_S3_DISABLE_EXPRESS_SESSION_AUTH";
/**
 * @internal
 */
export declare const NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_INI_NAME = "s3_disable_express_session_auth";
/**
 * @internal
 */
export declare const NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_OPTIONS: LoadedConfigSelectors<boolean>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-sdk-s3/dist-types/s3-express/functions/s3ExpressHttpSigningMiddleware.d.ts

```typescript
import { IHttpRequest } from "@smithy/protocol-http";
import { AuthScheme, AwsCredentialIdentity, FinalizeRequestMiddleware, Pluggable, RequestSigner } from "@smithy/types";
interface SigningProperties {
    signingRegion: string;
    signingDate: Date;
    signingService: string;
}
interface PreviouslyResolved {
    signer: (authScheme?: AuthScheme | undefined) => Promise<RequestSigner & {
        signWithCredentials(req: IHttpRequest, identity: AwsCredentialIdentity, opts?: Partial<SigningProperties>): Promise<IHttpRequest>;
    }>;
}
/**
 * @internal
 */
export declare const s3ExpressHttpSigningMiddlewareOptions: import("@smithy/types").FinalizeRequestHandlerOptions & import("@smithy/types").RelativeLocation & Omit<import("@smithy/types").HandlerOptions, "step">;
/**
 * @internal
 */
export declare const s3ExpressHttpSigningMiddleware: <Input extends object, Output extends object>(config: PreviouslyResolved) => FinalizeRequestMiddleware<any, any>;
/**
 * @internal
 */
export declare const getS3ExpressHttpSigningPlugin: (config: {
    signer: (authScheme?: AuthScheme | undefined) => Promise<RequestSigner>;
}) => Pluggable<any, any>;
export {};

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-sdk-s3/dist-types/s3-express/functions/s3ExpressMiddleware.d.ts

```typescript
import { AwsCredentialIdentity } from "@aws-sdk/types";
import { BuildHandlerOptions, BuildMiddleware, Logger, MemoizedProvider, Pluggable } from "@smithy/types";
import { S3ExpressIdentity } from "../interfaces/S3ExpressIdentity";
import { S3ExpressIdentityProvider } from "../interfaces/S3ExpressIdentityProvider";
declare module "@smithy/types" {
    interface HandlerExecutionContext {
        /**
         * Reserved key, only when using S3.
         */
        s3ExpressIdentity?: S3ExpressIdentity;
    }
}
/**
 * @internal
 */
export interface S3ExpressResolvedConfig {
    logger?: Logger;
    s3ExpressIdentityProvider: S3ExpressIdentityProvider;
    credentials: MemoizedProvider<AwsCredentialIdentity>;
}
/**
 * @internal
 */
export declare const s3ExpressMiddleware: (options: S3ExpressResolvedConfig) => BuildMiddleware<any, any>;
/**
 * @internal
 */
export declare const s3ExpressMiddlewareOptions: BuildHandlerOptions;
/**
 * @internal
 */
export declare const getS3ExpressPlugin: (options: S3ExpressResolvedConfig) => Pluggable<any, any>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-sdk-s3/dist-types/s3-express/functions/signS3Express.d.ts

```typescript
import type { AwsCredentialIdentity, HttpRequest as IHttpRequest } from "@smithy/types";
import { S3ExpressIdentity } from "../interfaces/S3ExpressIdentity";
export declare const signS3Express: (s3ExpressIdentity: S3ExpressIdentity, signingOptions: {
    signingDate: Date;
    signingRegion: string;
    signingService: string;
}, request: IHttpRequest, sigV4MultiRegionSigner: {
    signWithCredentials(req: IHttpRequest, identity: AwsCredentialIdentity, opts?: Partial<typeof signingOptions>): Promise<IHttpRequest>;
}) => Promise<IHttpRequest>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-sdk-s3/dist-types/s3-express/index.d.ts

```typescript
export { S3ExpressIdentityCache } from "./classes/S3ExpressIdentityCache";
export { S3ExpressIdentityCacheEntry } from "./classes/S3ExpressIdentityCacheEntry";
export { S3ExpressIdentityProviderImpl } from "./classes/S3ExpressIdentityProviderImpl";
export { SignatureV4S3Express } from "./classes/SignatureV4S3Express";
export { NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_OPTIONS } from "./constants";
export { getS3ExpressPlugin, s3ExpressMiddleware, s3ExpressMiddlewareOptions } from "./functions/s3ExpressMiddleware";
export { getS3ExpressHttpSigningPlugin, s3ExpressHttpSigningMiddleware, s3ExpressHttpSigningMiddlewareOptions, } from "./functions/s3ExpressHttpSigningMiddleware";
export { S3ExpressIdentity } from "./interfaces/S3ExpressIdentity";
export { S3ExpressIdentityProvider } from "./interfaces/S3ExpressIdentityProvider";

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-sdk-s3/dist-types/s3-express/interfaces/S3ExpressIdentity.d.ts

```typescript
import { AwsCredentialIdentity } from "@aws-sdk/types";
/**
 * @public
 */
export interface S3ExpressIdentity extends AwsCredentialIdentity {
}

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-sdk-s3/dist-types/s3-express/interfaces/S3ExpressIdentityProvider.d.ts

```typescript
import { AwsCredentialIdentity } from "@aws-sdk/types";
import { S3ExpressIdentity } from "./S3ExpressIdentity";
/**
 * @public
 */
export interface S3ExpressIdentityProvider {
    /**
     * @param awsIdentity - pre-existing credentials.
     * @param identityProperties - unknown.
     */
    getS3ExpressIdentity(awsIdentity: AwsCredentialIdentity, identityProperties: Record<string, string>): Promise<S3ExpressIdentity>;
}

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-sdk-s3/dist-types/s3Configuration.d.ts

```typescript
import type { Client, Command } from "@smithy/types";
import { S3ExpressIdentityProvider } from "./s3-express";
/**
 * All endpoint parameters with built-in bindings of AWS::S3::*
 * @public
 */
export interface S3InputConfig {
    /**
     * Whether to force path style URLs for S3 objects
     * (e.g., https://s3.amazonaws.com/<bucketName>/<key> instead of https://<bucketName>.s3.amazonaws.com/<key>
     */
    forcePathStyle?: boolean;
    /**
     * Whether to use the S3 Transfer Acceleration endpoint by default
     */
    useAccelerateEndpoint?: boolean;
    /**
     * Whether multi-region access points (MRAP) should be disabled.
     */
    disableMultiregionAccessPoints?: boolean;
    /**
     * This feature was previously called the S3 Global Client.
     * This can result in additional latency as failed requests are retried
     * with a corrected region when receiving a permanent redirect error with status 301.
     * This feature should only be used as a last resort if you do not know the region of your bucket(s) ahead of time.
     */
    followRegionRedirects?: boolean;
    /**
     * Identity provider for an S3 feature.
     */
    s3ExpressIdentityProvider?: S3ExpressIdentityProvider;
    /**
     * Whether to use the bucket name as the endpoint for this client.
     */
    bucketEndpoint?: boolean;
}
/**
 * This is a placeholder for the actual
 * S3Client type from \@aws-sdk/client-s3. It is not explicitly
 * imported to avoid a circular dependency.
 * @internal
 */
type PlaceholderS3Client = Client<any, any, any> & any;
/**
 * Placeholder for the constructor for CreateSessionCommand.
 * @internal
 */
type PlaceholderCreateSessionCommandCtor = {
    new (args: any): Command<any, any, any, any, any>;
};
export interface S3ResolvedConfig {
    forcePathStyle: boolean;
    useAccelerateEndpoint: boolean;
    disableMultiregionAccessPoints: boolean;
    followRegionRedirects: boolean;
    s3ExpressIdentityProvider: S3ExpressIdentityProvider;
    bucketEndpoint: boolean;
}
export declare const resolveS3Config: <T>(input: T & S3InputConfig, { session, }: {
    session: [() => PlaceholderS3Client, PlaceholderCreateSessionCommandCtor];
}) => T & S3ResolvedConfig;
export {};

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-sdk-s3/dist-types/throw-200-exceptions.d.ts

```typescript
import { DeserializeMiddleware, Encoder, Pluggable, RelativeMiddlewareOptions } from "@smithy/types";
type PreviouslyResolved = {
    utf8Encoder: Encoder;
};
/**
 * In case of an internal error/terminated connection, S3 operations may return 200 errors. CopyObject, UploadPartCopy,
 * CompleteMultipartUpload may return empty payload or payload with only xml Preamble.
 * @internal
 */
export declare const throw200ExceptionsMiddleware: (config: PreviouslyResolved) => DeserializeMiddleware<any, any>;
/**
 * @internal
 */
export declare const throw200ExceptionsMiddlewareOptions: RelativeMiddlewareOptions;
/**
 *
 * @internal
 */
export declare const getThrow200ExceptionsPlugin: (config: PreviouslyResolved) => Pluggable<any, any>;
export {};

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-sdk-s3/dist-types/ts3.4/bucket-endpoint-middleware.d.ts

```typescript
import { RelativeMiddlewareOptions, SerializeMiddleware } from "@smithy/types";
interface PreviouslyResolved {
  bucketEndpoint?: boolean;
}
export declare function bucketEndpointMiddleware(
  options: PreviouslyResolved
): SerializeMiddleware<any, any>;
export declare const bucketEndpointMiddlewareOptions: RelativeMiddlewareOptions;
export {};

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-sdk-s3/dist-types/ts3.4/check-content-length-header.d.ts

```typescript
import {
  FinalizeRequestHandlerOptions,
  FinalizeRequestMiddleware,
  Pluggable,
} from "@smithy/types";
export declare function checkContentLengthHeader(): FinalizeRequestMiddleware<
  any,
  any
>;
export declare const checkContentLengthHeaderMiddlewareOptions: FinalizeRequestHandlerOptions;
export declare const getCheckContentLengthHeaderPlugin: (
  unused: any
) => Pluggable<any, any>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-sdk-s3/dist-types/ts3.4/index.d.ts

```typescript
export * from "./check-content-length-header";
export * from "./region-redirect-endpoint-middleware";
export * from "./region-redirect-middleware";
export * from "./s3-expires-middleware";
export * from "./s3-express/index";
export * from "./s3Configuration";
export * from "./throw-200-exceptions";
export * from "./validate-bucket-name";

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-sdk-s3/dist-types/ts3.4/region-redirect-endpoint-middleware.d.ts

```typescript
import { RelativeMiddlewareOptions, SerializeMiddleware } from "@smithy/types";
import { PreviouslyResolved } from "./region-redirect-middleware";
export declare const regionRedirectEndpointMiddleware: (
  config: PreviouslyResolved
) => SerializeMiddleware<any, any>;
export declare const regionRedirectEndpointMiddlewareOptions: RelativeMiddlewareOptions;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-sdk-s3/dist-types/ts3.4/region-redirect-middleware.d.ts

```typescript
import {
  InitializeHandlerOptions,
  InitializeMiddleware,
  Pluggable,
  Provider,
} from "@smithy/types";
export interface PreviouslyResolved {
  region: Provider<string>;
  followRegionRedirects: boolean;
}
export declare function regionRedirectMiddleware(
  clientConfig: PreviouslyResolved
): InitializeMiddleware<any, any>;
export declare const regionRedirectMiddlewareOptions: InitializeHandlerOptions;
export declare const getRegionRedirectMiddlewarePlugin: (
  clientConfig: PreviouslyResolved
) => Pluggable<any, any>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-sdk-s3/dist-types/ts3.4/s3-expires-middleware.d.ts

```typescript
import {
  DeserializeMiddleware,
  Pluggable,
  RelativeMiddlewareOptions,
} from "@smithy/types";
interface PreviouslyResolved {}
export declare const s3ExpiresMiddleware: (
  config: PreviouslyResolved
) => DeserializeMiddleware<any, any>;
export declare const s3ExpiresMiddlewareOptions: RelativeMiddlewareOptions;
export declare const getS3ExpiresMiddlewarePlugin: (
  clientConfig: PreviouslyResolved
) => Pluggable<any, any>;
export {};

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-sdk-s3/dist-types/ts3.4/s3-express/classes/S3ExpressIdentityCache.d.ts

```typescript
import { S3ExpressIdentityCacheEntry } from "./S3ExpressIdentityCacheEntry";
export declare class S3ExpressIdentityCache {
  private data;
  private lastPurgeTime;
  static EXPIRED_CREDENTIAL_PURGE_INTERVAL_MS: number;
  constructor(data?: Record<string, S3ExpressIdentityCacheEntry>);
  get(key: string): undefined | S3ExpressIdentityCacheEntry;
  set(
    key: string,
    entry: S3ExpressIdentityCacheEntry
  ): S3ExpressIdentityCacheEntry;
  delete(key: string): void;
  purgeExpired(): Promise<void>;
}

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-sdk-s3/dist-types/ts3.4/s3-express/classes/S3ExpressIdentityCacheEntry.d.ts

```typescript
import { S3ExpressIdentity } from "../interfaces/S3ExpressIdentity";
export declare class S3ExpressIdentityCacheEntry {
  private _identity;
  isRefreshing: boolean;
  accessed: number;
  constructor(
    _identity: Promise<S3ExpressIdentity>,
    isRefreshing?: boolean,
    accessed?: number
  );
  readonly identity: Promise<S3ExpressIdentity>;
}

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-sdk-s3/dist-types/ts3.4/s3-express/classes/S3ExpressIdentityProviderImpl.d.ts

```typescript
import { AwsCredentialIdentity } from "@aws-sdk/types";
import { S3ExpressIdentity } from "../interfaces/S3ExpressIdentity";
import { S3ExpressIdentityProvider } from "../interfaces/S3ExpressIdentityProvider";
import { S3ExpressIdentityCache } from "./S3ExpressIdentityCache";
type Credentials = {
  AccessKeyId: string | undefined;
  SecretAccessKey: string | undefined;
  SessionToken: string | undefined;
  Expiration: Date | undefined;
};
export declare class S3ExpressIdentityProviderImpl
  implements S3ExpressIdentityProvider
{
  private createSessionFn;
  private cache;
  static REFRESH_WINDOW_MS: number;
  constructor(
    createSessionFn: (key: string) => Promise<{
      Credentials: Credentials;
    }>,
    cache?: S3ExpressIdentityCache
  );
  getS3ExpressIdentity(
    awsIdentity: AwsCredentialIdentity,
    identityProperties: {
      Bucket: string;
    } & Record<string, string>
  ): Promise<S3ExpressIdentity>;
  private getIdentity;
}
export {};

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-sdk-s3/dist-types/ts3.4/s3-express/classes/SignatureV4S3Express.d.ts

```typescript
import { AwsCredentialIdentity } from "@aws-sdk/types";
import { SignatureV4 } from "@smithy/signature-v4";
import {
  HttpRequest as IHttpRequest,
  RequestPresigningArguments,
  RequestSigningArguments,
} from "@smithy/types";
export declare class SignatureV4S3Express extends SignatureV4 {
  signWithCredentials(
    requestToSign: IHttpRequest,
    credentials: AwsCredentialIdentity,
    options?: RequestSigningArguments
  ): Promise<IHttpRequest>;
  presignWithCredentials(
    requestToSign: IHttpRequest,
    credentials: AwsCredentialIdentity,
    options?: RequestPresigningArguments
  ): Promise<IHttpRequest>;
}

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-sdk-s3/dist-types/ts3.4/s3-express/constants.d.ts

```typescript
import { LoadedConfigSelectors } from "@smithy/node-config-provider";
export declare const S3_EXPRESS_BUCKET_TYPE = "Directory";
export declare const S3_EXPRESS_BACKEND = "S3Express";
export declare const S3_EXPRESS_AUTH_SCHEME = "sigv4-s3express";
export declare const SESSION_TOKEN_QUERY_PARAM = "X-Amz-S3session-Token";
export declare const SESSION_TOKEN_HEADER: string;
export declare const NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_ENV_NAME =
  "AWS_S3_DISABLE_EXPRESS_SESSION_AUTH";
export declare const NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_INI_NAME =
  "s3_disable_express_session_auth";
export declare const NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_OPTIONS: LoadedConfigSelectors<boolean>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-sdk-s3/dist-types/ts3.4/s3-express/functions/s3ExpressHttpSigningMiddleware.d.ts

```typescript
import { IHttpRequest } from "@smithy/protocol-http";
import {
  AuthScheme,
  AwsCredentialIdentity,
  FinalizeRequestMiddleware,
  Pluggable,
  RequestSigner,
} from "@smithy/types";
interface SigningProperties {
  signingRegion: string;
  signingDate: Date;
  signingService: string;
}
interface PreviouslyResolved {
  signer: (authScheme?: AuthScheme | undefined) => Promise<
    RequestSigner & {
      signWithCredentials(
        req: IHttpRequest,
        identity: AwsCredentialIdentity,
        opts?: Partial<SigningProperties>
      ): Promise<IHttpRequest>;
    }
  >;
}
export declare const s3ExpressHttpSigningMiddlewareOptions: import("@smithy/types").FinalizeRequestHandlerOptions &
  import("@smithy/types").RelativeLocation &
  Pick<
    import("@smithy/types").HandlerOptions,
    Exclude<keyof import("@smithy/types").HandlerOptions, "step">
  >;
export declare const s3ExpressHttpSigningMiddleware: <
  Input extends object,
  Output extends object
>(
  config: PreviouslyResolved
) => FinalizeRequestMiddleware<any, any>;
export declare const getS3ExpressHttpSigningPlugin: (config: {
  signer: (authScheme?: AuthScheme | undefined) => Promise<RequestSigner>;
}) => Pluggable<any, any>;
export {};

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-sdk-s3/dist-types/ts3.4/s3-express/functions/s3ExpressMiddleware.d.ts

```typescript
import { AwsCredentialIdentity } from "@aws-sdk/types";
import {
  BuildHandlerOptions,
  BuildMiddleware,
  Logger,
  MemoizedProvider,
  Pluggable,
} from "@smithy/types";
import { S3ExpressIdentity } from "../interfaces/S3ExpressIdentity";
import { S3ExpressIdentityProvider } from "../interfaces/S3ExpressIdentityProvider";
declare module "@smithy/types" {
  interface HandlerExecutionContext {
    s3ExpressIdentity?: S3ExpressIdentity;
  }
}
export interface S3ExpressResolvedConfig {
  logger?: Logger;
  s3ExpressIdentityProvider: S3ExpressIdentityProvider;
  credentials: MemoizedProvider<AwsCredentialIdentity>;
}
export declare const s3ExpressMiddleware: (
  options: S3ExpressResolvedConfig
) => BuildMiddleware<any, any>;
export declare const s3ExpressMiddlewareOptions: BuildHandlerOptions;
export declare const getS3ExpressPlugin: (
  options: S3ExpressResolvedConfig
) => Pluggable<any, any>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-sdk-s3/dist-types/ts3.4/s3-express/functions/signS3Express.d.ts

```typescript
import {
  AwsCredentialIdentity,
  HttpRequest as IHttpRequest,
} from "@smithy/types";
import { S3ExpressIdentity } from "../interfaces/S3ExpressIdentity";
export declare const signS3Express: (
  s3ExpressIdentity: S3ExpressIdentity,
  signingOptions: {
    signingDate: Date;
    signingRegion: string;
    signingService: string;
  },
  request: IHttpRequest,
  sigV4MultiRegionSigner: {
    signWithCredentials(
      req: IHttpRequest,
      identity: AwsCredentialIdentity,
      opts?: Partial<typeof signingOptions>
    ): Promise<IHttpRequest>;
  }
) => Promise<IHttpRequest>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-sdk-s3/dist-types/ts3.4/s3-express/index.d.ts

```typescript
export { S3ExpressIdentityCache } from "./classes/S3ExpressIdentityCache";
export { S3ExpressIdentityCacheEntry } from "./classes/S3ExpressIdentityCacheEntry";
export { S3ExpressIdentityProviderImpl } from "./classes/S3ExpressIdentityProviderImpl";
export { SignatureV4S3Express } from "./classes/SignatureV4S3Express";
export { NODE_DISABLE_S3_EXPRESS_SESSION_AUTH_OPTIONS } from "./constants";
export {
  getS3ExpressPlugin,
  s3ExpressMiddleware,
  s3ExpressMiddlewareOptions,
} from "./functions/s3ExpressMiddleware";
export {
  getS3ExpressHttpSigningPlugin,
  s3ExpressHttpSigningMiddleware,
  s3ExpressHttpSigningMiddlewareOptions,
} from "./functions/s3ExpressHttpSigningMiddleware";
export { S3ExpressIdentity } from "./interfaces/S3ExpressIdentity";
export { S3ExpressIdentityProvider } from "./interfaces/S3ExpressIdentityProvider";

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-sdk-s3/dist-types/ts3.4/s3-express/interfaces/S3ExpressIdentity.d.ts

```typescript
import { AwsCredentialIdentity } from "@aws-sdk/types";
export interface S3ExpressIdentity extends AwsCredentialIdentity {}

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-sdk-s3/dist-types/ts3.4/s3-express/interfaces/S3ExpressIdentityProvider.d.ts

```typescript
import { AwsCredentialIdentity } from "@aws-sdk/types";
import { S3ExpressIdentity } from "./S3ExpressIdentity";
export interface S3ExpressIdentityProvider {
  getS3ExpressIdentity(
    awsIdentity: AwsCredentialIdentity,
    identityProperties: Record<string, string>
  ): Promise<S3ExpressIdentity>;
}

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-sdk-s3/dist-types/ts3.4/s3Configuration.d.ts

```typescript
import { Client, Command } from "@smithy/types";
import { S3ExpressIdentityProvider } from "./s3-express";
export interface S3InputConfig {
  forcePathStyle?: boolean;
  useAccelerateEndpoint?: boolean;
  disableMultiregionAccessPoints?: boolean;
  followRegionRedirects?: boolean;
  s3ExpressIdentityProvider?: S3ExpressIdentityProvider;
  bucketEndpoint?: boolean;
}
type PlaceholderS3Client = Client<any, any, any> & any;
type PlaceholderCreateSessionCommandCtor = {
  new (args: any): Command<any, any, any, any, any>;
};
export interface S3ResolvedConfig {
  forcePathStyle: boolean;
  useAccelerateEndpoint: boolean;
  disableMultiregionAccessPoints: boolean;
  followRegionRedirects: boolean;
  s3ExpressIdentityProvider: S3ExpressIdentityProvider;
  bucketEndpoint: boolean;
}
export declare const resolveS3Config: <T>(
  input: T & S3InputConfig,
  {
    session,
  }: {
    session: [() => PlaceholderS3Client, PlaceholderCreateSessionCommandCtor];
  }
) => T & S3ResolvedConfig;
export {};

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-sdk-s3/dist-types/ts3.4/throw-200-exceptions.d.ts

```typescript
import {
  DeserializeMiddleware,
  Encoder,
  Pluggable,
  RelativeMiddlewareOptions,
} from "@smithy/types";
type PreviouslyResolved = {
  utf8Encoder: Encoder;
};
export declare const throw200ExceptionsMiddleware: (
  config: PreviouslyResolved
) => DeserializeMiddleware<any, any>;
export declare const throw200ExceptionsMiddlewareOptions: RelativeMiddlewareOptions;
export declare const getThrow200ExceptionsPlugin: (
  config: PreviouslyResolved
) => Pluggable<any, any>;
export {};

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-sdk-s3/dist-types/ts3.4/validate-bucket-name.d.ts

```typescript
import {
  InitializeHandlerOptions,
  InitializeMiddleware,
  Pluggable,
} from "@smithy/types";
import { S3ResolvedConfig } from "./s3Configuration";
export declare function validateBucketNameMiddleware({
  bucketEndpoint,
}: S3ResolvedConfig): InitializeMiddleware<any, any>;
export declare const validateBucketNameMiddlewareOptions: InitializeHandlerOptions;
export declare const getValidateBucketNamePlugin: (
  options: S3ResolvedConfig
) => Pluggable<any, any>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-sdk-s3/dist-types/validate-bucket-name.d.ts

```typescript
import { InitializeHandlerOptions, InitializeMiddleware, Pluggable } from "@smithy/types";
import { S3ResolvedConfig } from "./s3Configuration";
/**
 * @internal
 */
export declare function validateBucketNameMiddleware({ bucketEndpoint }: S3ResolvedConfig): InitializeMiddleware<any, any>;
/**
 * @internal
 */
export declare const validateBucketNameMiddlewareOptions: InitializeHandlerOptions;
/**
 * @internal
 */
export declare const getValidateBucketNamePlugin: (options: S3ResolvedConfig) => Pluggable<any, any>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-sdk-s3/package.json

```json
{
  "name": "@aws-sdk/middleware-sdk-s3",
  "version": "3.911.0",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "node ../../scripts/compilation/inline middleware-sdk-s3",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "test": "yarn g:vitest run",
    "test:types": "tsc -p tsconfig.test.json",
    "test:integration": "yarn g:vitest run -c vitest.config.integ.mts && yarn test:types",
    "test:e2e": "yarn g:vitest run -c vitest.config.e2e.mts --mode development",
    "extract:docs": "api-extractor run --local",
    "test:watch": "yarn g:vitest watch",
    "test:integration:watch": "yarn g:vitest watch -c vitest.config.integ.mts",
    "test:e2e:watch": "yarn g:vitest watch -c vitest.config.e2e.mts"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "sideEffects": false,
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "dependencies": {
    "@aws-sdk/core": "3.911.0",
    "@aws-sdk/types": "3.910.0",
    "@aws-sdk/util-arn-parser": "3.893.0",
    "@smithy/core": "^3.16.1",
    "@smithy/node-config-provider": "^4.3.2",
    "@smithy/protocol-http": "^5.3.2",
    "@smithy/signature-v4": "^5.3.2",
    "@smithy/smithy-client": "^4.8.1",
    "@smithy/types": "^4.7.1",
    "@smithy/util-config-provider": "^4.2.0",
    "@smithy/util-middleware": "^4.2.2",
    "@smithy/util-stream": "^4.5.2",
    "@smithy/util-utf8": "^4.2.0",
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "@tsconfig/recommended": "1.0.1",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typescript": "~5.8.3"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/aws/aws-sdk-js-v3/tree/main/packages/middleware-sdk-s3",
  "repository": {
    "type": "git",
    "url": "https://github.com/aws/aws-sdk-js-v3.git",
    "directory": "packages/middleware-sdk-s3"
  }
}

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-ssec/dist-types/index.d.ts

```typescript
import { ChecksumConstructor, Decoder, Encoder, HashConstructor, InitializeHandlerOptions, InitializeMiddleware, Pluggable } from "@smithy/types";
interface PreviouslyResolved {
    base64Encoder: Encoder;
    md5: ChecksumConstructor | HashConstructor;
    utf8Decoder: Decoder;
    base64Decoder: Decoder;
}
export declare function ssecMiddleware(options: PreviouslyResolved): InitializeMiddleware<any, any>;
export declare const ssecMiddlewareOptions: InitializeHandlerOptions;
export declare const getSsecPlugin: (config: PreviouslyResolved) => Pluggable<any, any>;
export declare function isValidBase64EncodedSSECustomerKey(str: string, options: PreviouslyResolved): boolean;
export {};

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-ssec/dist-types/ts3.4/index.d.ts

```typescript
import {
  ChecksumConstructor,
  Decoder,
  Encoder,
  HashConstructor,
  InitializeHandlerOptions,
  InitializeMiddleware,
  Pluggable,
} from "@smithy/types";
interface PreviouslyResolved {
  base64Encoder: Encoder;
  md5: ChecksumConstructor | HashConstructor;
  utf8Decoder: Decoder;
  base64Decoder: Decoder;
}
export declare function ssecMiddleware(
  options: PreviouslyResolved
): InitializeMiddleware<any, any>;
export declare const ssecMiddlewareOptions: InitializeHandlerOptions;
export declare const getSsecPlugin: (
  config: PreviouslyResolved
) => Pluggable<any, any>;
export declare function isValidBase64EncodedSSECustomerKey(
  str: string,
  options: PreviouslyResolved
): boolean;
export {};

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-ssec/package.json

```json
{
  "name": "@aws-sdk/middleware-ssec",
  "version": "3.910.0",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "node ../../scripts/compilation/inline middleware-ssec",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "test": "yarn g:vitest run",
    "test:integration": "yarn g:vitest run -c vitest.config.integ.mts",
    "test:watch": "yarn g:vitest watch",
    "test:integration:watch": "yarn g:vitest watch -c vitest.config.integ.mts"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "sideEffects": false,
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "dependencies": {
    "@aws-sdk/types": "3.910.0",
    "@smithy/types": "^4.7.1",
    "tslib": "^2.6.2"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/aws/aws-sdk-js-v3/tree/main/packages/middleware-ssec",
  "repository": {
    "type": "git",
    "url": "https://github.com/aws/aws-sdk-js-v3.git",
    "directory": "packages/middleware-ssec"
  },
  "devDependencies": {
    "@tsconfig/recommended": "1.0.1",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typescript": "~5.8.3"
  }
}

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-user-agent/dist-types/check-features.d.ts

```typescript
import type { AccountIdEndpointMode } from "@aws-sdk/core/account-id-endpoint";
import type { AwsHandlerExecutionContext } from "@aws-sdk/types";
import type { AwsCredentialIdentityProvider, BuildHandlerArguments, Provider, RetryStrategy, RetryStrategyV2 } from "@smithy/types";
/**
 * @internal
 */
type PreviouslyResolved = Partial<{
    credentials?: AwsCredentialIdentityProvider;
    accountIdEndpointMode?: Provider<AccountIdEndpointMode>;
    retryStrategy?: Provider<RetryStrategy | RetryStrategyV2>;
}>;
/**
 * @internal
 * Check for features that don't have a middleware activation site but
 * may be detected on the context, client config, or request.
 */
export declare function checkFeatures(context: AwsHandlerExecutionContext, config: PreviouslyResolved, args: BuildHandlerArguments<any>): Promise<void>;
export {};

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-user-agent/dist-types/configurations.d.ts

```typescript
import { Logger, Provider, UserAgent } from "@smithy/types";
/**
 * @internal
 */
export declare const DEFAULT_UA_APP_ID: undefined;
/**
 * @public
 */
export interface UserAgentInputConfig {
    /**
     * The custom user agent header that would be appended to default one
     */
    customUserAgent?: string | UserAgent;
    /**
     * The application ID used to identify the application.
     */
    userAgentAppId?: string | undefined | Provider<string | undefined>;
}
interface PreviouslyResolved {
    defaultUserAgentProvider: Provider<UserAgent>;
    runtime: string;
    logger?: Logger;
}
export interface UserAgentResolvedConfig {
    /**
     * The provider populating default tracking information to be sent with `user-agent`, `x-amz-user-agent` header.
     * @internal
     */
    defaultUserAgentProvider: Provider<UserAgent>;
    /**
     * The custom user agent header that would be appended to default one
     */
    customUserAgent?: UserAgent;
    /**
     * The runtime environment
     */
    runtime: string;
    /**
     * Resolved value for input config {config.userAgentAppId}
     */
    userAgentAppId: Provider<string | undefined>;
}
export declare function resolveUserAgentConfig<T>(input: T & PreviouslyResolved & UserAgentInputConfig): T & UserAgentResolvedConfig;
export {};

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-user-agent/dist-types/constants.d.ts

```typescript
export declare const USER_AGENT = "user-agent";
export declare const X_AMZ_USER_AGENT = "x-amz-user-agent";
export declare const SPACE = " ";
export declare const UA_NAME_SEPARATOR = "/";
export declare const UA_NAME_ESCAPE_REGEX: RegExp;
export declare const UA_VALUE_ESCAPE_REGEX: RegExp;
export declare const UA_ESCAPE_CHAR = "-";

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-user-agent/dist-types/encode-features.d.ts

```typescript
import type { AwsSdkFeatures } from "@aws-sdk/types";
/**
 * @internal
 */
export declare function encodeFeatures(features: AwsSdkFeatures): string;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-user-agent/dist-types/index.d.ts

```typescript
export * from "./configurations";
export * from "./user-agent-middleware";

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-user-agent/dist-types/ts3.4/check-features.d.ts

```typescript
import { AccountIdEndpointMode } from "@aws-sdk/core/account-id-endpoint";
import { AwsHandlerExecutionContext } from "@aws-sdk/types";
import {
  AwsCredentialIdentityProvider,
  BuildHandlerArguments,
  Provider,
  RetryStrategy,
  RetryStrategyV2,
} from "@smithy/types";
type PreviouslyResolved = Partial<{
  credentials?: AwsCredentialIdentityProvider;
  accountIdEndpointMode?: Provider<AccountIdEndpointMode>;
  retryStrategy?: Provider<RetryStrategy | RetryStrategyV2>;
}>;
export declare function checkFeatures(
  context: AwsHandlerExecutionContext,
  config: PreviouslyResolved,
  args: BuildHandlerArguments<any>
): Promise<void>;
export {};

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-user-agent/dist-types/ts3.4/configurations.d.ts

```typescript
import { Logger, Provider, UserAgent } from "@smithy/types";
export declare const DEFAULT_UA_APP_ID: undefined;
export interface UserAgentInputConfig {
  customUserAgent?: string | UserAgent;
  userAgentAppId?: string | undefined | Provider<string | undefined>;
}
interface PreviouslyResolved {
  defaultUserAgentProvider: Provider<UserAgent>;
  runtime: string;
  logger?: Logger;
}
export interface UserAgentResolvedConfig {
  defaultUserAgentProvider: Provider<UserAgent>;
  customUserAgent?: UserAgent;
  runtime: string;
  userAgentAppId: Provider<string | undefined>;
}
export declare function resolveUserAgentConfig<T>(
  input: T & PreviouslyResolved & UserAgentInputConfig
): T & UserAgentResolvedConfig;
export {};

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-user-agent/dist-types/ts3.4/constants.d.ts

```typescript
export declare const USER_AGENT = "user-agent";
export declare const X_AMZ_USER_AGENT = "x-amz-user-agent";
export declare const SPACE = " ";
export declare const UA_NAME_SEPARATOR = "/";
export declare const UA_NAME_ESCAPE_REGEX: RegExp;
export declare const UA_VALUE_ESCAPE_REGEX: RegExp;
export declare const UA_ESCAPE_CHAR = "-";

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-user-agent/dist-types/ts3.4/encode-features.d.ts

```typescript
import { AwsSdkFeatures } from "@aws-sdk/types";
export declare function encodeFeatures(features: AwsSdkFeatures): string;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-user-agent/dist-types/ts3.4/index.d.ts

```typescript
export * from "./configurations";
export * from "./user-agent-middleware";

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-user-agent/dist-types/ts3.4/user-agent-middleware.d.ts

```typescript
import { AwsHandlerExecutionContext } from "@aws-sdk/types";
import {
  AbsoluteLocation,
  BuildHandler,
  BuildHandlerOptions,
  HandlerExecutionContext,
  MetadataBearer,
  Pluggable,
} from "@smithy/types";
import { UserAgentResolvedConfig } from "./configurations";
export declare const userAgentMiddleware: (
  options: UserAgentResolvedConfig
) => <Output extends MetadataBearer>(
  next: BuildHandler<any, any>,
  context: HandlerExecutionContext | AwsHandlerExecutionContext
) => BuildHandler<any, any>;
export declare const getUserAgentMiddlewareOptions: BuildHandlerOptions &
  AbsoluteLocation;
export declare const getUserAgentPlugin: (
  config: UserAgentResolvedConfig
) => Pluggable<any, any>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-user-agent/dist-types/user-agent-middleware.d.ts

```typescript
import type { AwsHandlerExecutionContext } from "@aws-sdk/types";
import { AbsoluteLocation, BuildHandler, BuildHandlerOptions, HandlerExecutionContext, MetadataBearer, Pluggable } from "@smithy/types";
import { UserAgentResolvedConfig } from "./configurations";
/**
 * Build user agent header sections from:
 * 1. runtime-specific default user agent provider;
 * 2. custom user agent from `customUserAgent` client config;
 * 3. handler execution context set by internal SDK components;
 * The built user agent will be set to `x-amz-user-agent` header for ALL the
 * runtimes.
 * Please note that any override to the `user-agent` or `x-amz-user-agent` header
 * in the HTTP request is discouraged. Please use `customUserAgent` client
 * config or middleware setting the `userAgent` context to generate desired user
 * agent.
 */
export declare const userAgentMiddleware: (options: UserAgentResolvedConfig) => <Output extends MetadataBearer>(next: BuildHandler<any, any>, context: HandlerExecutionContext | AwsHandlerExecutionContext) => BuildHandler<any, any>;
export declare const getUserAgentMiddlewareOptions: BuildHandlerOptions & AbsoluteLocation;
export declare const getUserAgentPlugin: (config: UserAgentResolvedConfig) => Pluggable<any, any>;

```

## ./lib/lambda/node_modules/@aws-sdk/middleware-user-agent/package.json

```json
{
  "name": "@aws-sdk/middleware-user-agent",
  "version": "3.911.0",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "node ../../scripts/compilation/inline middleware-user-agent",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "test": "yarn g:vitest run",
    "test:integration": "yarn g:vitest run -c vitest.config.integ.mts",
    "extract:docs": "api-extractor run --local",
    "test:watch": "yarn g:vitest watch",
    "test:integration:watch": "yarn g:vitest watch -c vitest.config.integ.mts"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "sideEffects": false,
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "dependencies": {
    "@aws-sdk/core": "3.911.0",
    "@aws-sdk/types": "3.910.0",
    "@aws-sdk/util-endpoints": "3.910.0",
    "@smithy/core": "^3.16.1",
    "@smithy/protocol-http": "^5.3.2",
    "@smithy/types": "^4.7.1",
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "@tsconfig/recommended": "1.0.1",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typescript": "~5.8.3"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/aws/aws-sdk-js-v3/tree/main/packages/middleware-user-agent",
  "repository": {
    "type": "git",
    "url": "https://github.com/aws/aws-sdk-js-v3.git",
    "directory": "packages/middleware-user-agent"
  }
}

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/index.d.ts

```typescript
/**
 * This package exports nothing at the root.
 * Use submodules e.g. \@aws-sdk/nested-clients/client-sts.
 *
 * @internal
 */
export {};

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/submodules/sso-oidc/SSOOIDC.d.ts

```typescript
import { HttpHandlerOptions as __HttpHandlerOptions } from "@smithy/types";
import { CreateTokenCommandInput, CreateTokenCommandOutput } from "./commands/CreateTokenCommand";
import { SSOOIDCClient } from "./SSOOIDCClient";
export interface SSOOIDC {
    /**
     * @see {@link CreateTokenCommand}
     */
    createToken(args: CreateTokenCommandInput, options?: __HttpHandlerOptions): Promise<CreateTokenCommandOutput>;
    createToken(args: CreateTokenCommandInput, cb: (err: any, data?: CreateTokenCommandOutput) => void): void;
    createToken(args: CreateTokenCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: CreateTokenCommandOutput) => void): void;
}
/**
 * <p>IAM Identity Center OpenID Connect (OIDC) is a web service that enables a client (such as CLI or a
 *       native application) to register with IAM Identity Center. The service also enables the client to fetch the
 *       users access token upon successful authentication and authorization with IAM Identity Center.</p>
 *          <p>
 *             <b>API namespaces</b>
 *          </p>
 *          <p>IAM Identity Center uses the <code>sso</code> and <code>identitystore</code> API namespaces. IAM Identity Center
 *       OpenID Connect uses the <code>sso-oauth</code> namespace.</p>
 *          <p>
 *             <b>Considerations for using this guide</b>
 *          </p>
 *          <p>Before you begin using this guide, we recommend that you first review the following
 *       important information about how the IAM Identity Center OIDC service works.</p>
 *          <ul>
 *             <li>
 *                <p>The IAM Identity Center OIDC service currently implements only the portions of the OAuth 2.0 Device
 *           Authorization Grant standard (<a href="https://tools.ietf.org/html/rfc8628">https://tools.ietf.org/html/rfc8628</a>) that are necessary to enable single
 *           sign-on authentication with the CLI. </p>
 *             </li>
 *             <li>
 *                <p>With older versions of the CLI, the service only emits OIDC access tokens, so to
 *           obtain a new token, users must explicitly re-authenticate. To access the OIDC flow that
 *           supports token refresh and doesnt require re-authentication, update to the latest CLI
 *           version (1.27.10 for CLI V1 and 2.9.0 for CLI V2) with support for OIDC token refresh
 *           and configurable IAM Identity Center session durations. For more information, see <a href="https://docs.aws.amazon.com/singlesignon/latest/userguide/configure-user-session.html">Configure Amazon Web Services access portal session duration </a>. </p>
 *             </li>
 *             <li>
 *                <p>The access tokens provided by this service grant access to all Amazon Web Services account
 *           entitlements assigned to an IAM Identity Center user, not just a particular application.</p>
 *             </li>
 *             <li>
 *                <p>The documentation in this guide does not describe the mechanism to convert the access
 *           token into Amazon Web Services Auth (sigv4) credentials for use with IAM-protected Amazon Web Services service
 *           endpoints. For more information, see <a href="https://docs.aws.amazon.com/singlesignon/latest/PortalAPIReference/API_GetRoleCredentials.html">GetRoleCredentials</a> in the <i>IAM Identity Center Portal API Reference
 *           Guide</i>.</p>
 *             </li>
 *          </ul>
 *          <p>For general information about IAM Identity Center, see <a href="https://docs.aws.amazon.com/singlesignon/latest/userguide/what-is.html">What is
 *         IAM Identity Center?</a> in the <i>IAM Identity Center User Guide</i>.</p>
 * @public
 */
export declare class SSOOIDC extends SSOOIDCClient implements SSOOIDC {
}

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/submodules/sso-oidc/SSOOIDCClient.d.ts

```typescript
import { HostHeaderInputConfig, HostHeaderResolvedConfig } from "@aws-sdk/middleware-host-header";
import { UserAgentInputConfig, UserAgentResolvedConfig } from "@aws-sdk/middleware-user-agent";
import { RegionInputConfig, RegionResolvedConfig } from "@smithy/config-resolver";
import { EndpointInputConfig, EndpointResolvedConfig } from "@smithy/middleware-endpoint";
import { RetryInputConfig, RetryResolvedConfig } from "@smithy/middleware-retry";
import { HttpHandlerUserInput as __HttpHandlerUserInput } from "@smithy/protocol-http";
import { Client as __Client, DefaultsMode as __DefaultsMode, SmithyConfiguration as __SmithyConfiguration, SmithyResolvedConfiguration as __SmithyResolvedConfiguration } from "@smithy/smithy-client";
import { BodyLengthCalculator as __BodyLengthCalculator, CheckOptionalClientConfig as __CheckOptionalClientConfig, ChecksumConstructor as __ChecksumConstructor, Decoder as __Decoder, Encoder as __Encoder, HashConstructor as __HashConstructor, HttpHandlerOptions as __HttpHandlerOptions, Logger as __Logger, Provider as __Provider, Provider, StreamCollector as __StreamCollector, UrlParser as __UrlParser, UserAgent as __UserAgent } from "@smithy/types";
import { HttpAuthSchemeInputConfig, HttpAuthSchemeResolvedConfig } from "./auth/httpAuthSchemeProvider";
import { CreateTokenCommandInput, CreateTokenCommandOutput } from "./commands/CreateTokenCommand";
import { ClientInputEndpointParameters, ClientResolvedEndpointParameters, EndpointParameters } from "./endpoint/EndpointParameters";
import { RuntimeExtension, RuntimeExtensionsConfig } from "./runtimeExtensions";
export { __Client };
/**
 * @public
 */
export type ServiceInputTypes = CreateTokenCommandInput;
/**
 * @public
 */
export type ServiceOutputTypes = CreateTokenCommandOutput;
/**
 * @public
 */
export interface ClientDefaults extends Partial<__SmithyConfiguration<__HttpHandlerOptions>> {
    /**
     * The HTTP handler to use or its constructor options. Fetch in browser and Https in Nodejs.
     */
    requestHandler?: __HttpHandlerUserInput;
    /**
     * A constructor for a class implementing the {@link @smithy/types#ChecksumConstructor} interface
     * that computes the SHA-256 HMAC or checksum of a string or binary buffer.
     * @internal
     */
    sha256?: __ChecksumConstructor | __HashConstructor;
    /**
     * The function that will be used to convert strings into HTTP endpoints.
     * @internal
     */
    urlParser?: __UrlParser;
    /**
     * A function that can calculate the length of a request body.
     * @internal
     */
    bodyLengthChecker?: __BodyLengthCalculator;
    /**
     * A function that converts a stream into an array of bytes.
     * @internal
     */
    streamCollector?: __StreamCollector;
    /**
     * The function that will be used to convert a base64-encoded string to a byte array.
     * @internal
     */
    base64Decoder?: __Decoder;
    /**
     * The function that will be used to convert binary data to a base64-encoded string.
     * @internal
     */
    base64Encoder?: __Encoder;
    /**
     * The function that will be used to convert a UTF8-encoded string to a byte array.
     * @internal
     */
    utf8Decoder?: __Decoder;
    /**
     * The function that will be used to convert binary data to a UTF-8 encoded string.
     * @internal
     */
    utf8Encoder?: __Encoder;
    /**
     * The runtime environment.
     * @internal
     */
    runtime?: string;
    /**
     * Disable dynamically changing the endpoint of the client based on the hostPrefix
     * trait of an operation.
     */
    disableHostPrefix?: boolean;
    /**
     * Unique service identifier.
     * @internal
     */
    serviceId?: string;
    /**
     * Enables IPv6/IPv4 dualstack endpoint.
     */
    useDualstackEndpoint?: boolean | __Provider<boolean>;
    /**
     * Enables FIPS compatible endpoints.
     */
    useFipsEndpoint?: boolean | __Provider<boolean>;
    /**
     * The AWS region to which this client will send requests
     */
    region?: string | __Provider<string>;
    /**
     * Setting a client profile is similar to setting a value for the
     * AWS_PROFILE environment variable. Setting a profile on a client
     * in code only affects the single client instance, unlike AWS_PROFILE.
     *
     * When set, and only for environments where an AWS configuration
     * file exists, fields configurable by this file will be retrieved
     * from the specified profile within that file.
     * Conflicting code configuration and environment variables will
     * still have higher priority.
     *
     * For client credential resolution that involves checking the AWS
     * configuration file, the client's profile (this value) will be
     * used unless a different profile is set in the credential
     * provider options.
     *
     */
    profile?: string;
    /**
     * The provider populating default tracking information to be sent with `user-agent`, `x-amz-user-agent` header
     * @internal
     */
    defaultUserAgentProvider?: Provider<__UserAgent>;
    /**
     * Value for how many times a request will be made at most in case of retry.
     */
    maxAttempts?: number | __Provider<number>;
    /**
     * Specifies which retry algorithm to use.
     * @see https://docs.aws.amazon.com/AWSJavaScriptSDK/v3/latest/Package/-smithy-util-retry/Enum/RETRY_MODES/
     *
     */
    retryMode?: string | __Provider<string>;
    /**
     * Optional logger for logging debug/info/warn/error.
     */
    logger?: __Logger;
    /**
     * Optional extensions
     */
    extensions?: RuntimeExtension[];
    /**
     * The {@link @smithy/smithy-client#DefaultsMode} that will be used to determine how certain default configuration options are resolved in the SDK.
     */
    defaultsMode?: __DefaultsMode | __Provider<__DefaultsMode>;
}
/**
 * @public
 */
export type SSOOIDCClientConfigType = Partial<__SmithyConfiguration<__HttpHandlerOptions>> & ClientDefaults & UserAgentInputConfig & RetryInputConfig & RegionInputConfig & HostHeaderInputConfig & EndpointInputConfig<EndpointParameters> & HttpAuthSchemeInputConfig & ClientInputEndpointParameters;
/**
 * @public
 *
 *  The configuration interface of SSOOIDCClient class constructor that set the region, credentials and other options.
 */
export interface SSOOIDCClientConfig extends SSOOIDCClientConfigType {
}
/**
 * @public
 */
export type SSOOIDCClientResolvedConfigType = __SmithyResolvedConfiguration<__HttpHandlerOptions> & Required<ClientDefaults> & RuntimeExtensionsConfig & UserAgentResolvedConfig & RetryResolvedConfig & RegionResolvedConfig & HostHeaderResolvedConfig & EndpointResolvedConfig<EndpointParameters> & HttpAuthSchemeResolvedConfig & ClientResolvedEndpointParameters;
/**
 * @public
 *
 *  The resolved configuration interface of SSOOIDCClient class. This is resolved and normalized from the {@link SSOOIDCClientConfig | constructor configuration interface}.
 */
export interface SSOOIDCClientResolvedConfig extends SSOOIDCClientResolvedConfigType {
}
/**
 * <p>IAM Identity Center OpenID Connect (OIDC) is a web service that enables a client (such as CLI or a
 *       native application) to register with IAM Identity Center. The service also enables the client to fetch the
 *       users access token upon successful authentication and authorization with IAM Identity Center.</p>
 *          <p>
 *             <b>API namespaces</b>
 *          </p>
 *          <p>IAM Identity Center uses the <code>sso</code> and <code>identitystore</code> API namespaces. IAM Identity Center
 *       OpenID Connect uses the <code>sso-oauth</code> namespace.</p>
 *          <p>
 *             <b>Considerations for using this guide</b>
 *          </p>
 *          <p>Before you begin using this guide, we recommend that you first review the following
 *       important information about how the IAM Identity Center OIDC service works.</p>
 *          <ul>
 *             <li>
 *                <p>The IAM Identity Center OIDC service currently implements only the portions of the OAuth 2.0 Device
 *           Authorization Grant standard (<a href="https://tools.ietf.org/html/rfc8628">https://tools.ietf.org/html/rfc8628</a>) that are necessary to enable single
 *           sign-on authentication with the CLI. </p>
 *             </li>
 *             <li>
 *                <p>With older versions of the CLI, the service only emits OIDC access tokens, so to
 *           obtain a new token, users must explicitly re-authenticate. To access the OIDC flow that
 *           supports token refresh and doesnt require re-authentication, update to the latest CLI
 *           version (1.27.10 for CLI V1 and 2.9.0 for CLI V2) with support for OIDC token refresh
 *           and configurable IAM Identity Center session durations. For more information, see <a href="https://docs.aws.amazon.com/singlesignon/latest/userguide/configure-user-session.html">Configure Amazon Web Services access portal session duration </a>. </p>
 *             </li>
 *             <li>
 *                <p>The access tokens provided by this service grant access to all Amazon Web Services account
 *           entitlements assigned to an IAM Identity Center user, not just a particular application.</p>
 *             </li>
 *             <li>
 *                <p>The documentation in this guide does not describe the mechanism to convert the access
 *           token into Amazon Web Services Auth (sigv4) credentials for use with IAM-protected Amazon Web Services service
 *           endpoints. For more information, see <a href="https://docs.aws.amazon.com/singlesignon/latest/PortalAPIReference/API_GetRoleCredentials.html">GetRoleCredentials</a> in the <i>IAM Identity Center Portal API Reference
 *           Guide</i>.</p>
 *             </li>
 *          </ul>
 *          <p>For general information about IAM Identity Center, see <a href="https://docs.aws.amazon.com/singlesignon/latest/userguide/what-is.html">What is
 *         IAM Identity Center?</a> in the <i>IAM Identity Center User Guide</i>.</p>
 * @public
 */
export declare class SSOOIDCClient extends __Client<__HttpHandlerOptions, ServiceInputTypes, ServiceOutputTypes, SSOOIDCClientResolvedConfig> {
    /**
     * The resolved configuration of SSOOIDCClient class. This is resolved and normalized from the {@link SSOOIDCClientConfig | constructor configuration interface}.
     */
    readonly config: SSOOIDCClientResolvedConfig;
    constructor(...[configuration]: __CheckOptionalClientConfig<SSOOIDCClientConfig>);
    /**
     * Destroy underlying resources, like sockets. It's usually not necessary to do this.
     * However in Node.js, it's best to explicitly shut down the client's agent when it is no longer needed.
     * Otherwise, sockets might stay open for quite a long time before the server terminates them.
     */
    destroy(): void;
}

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/submodules/sso-oidc/auth/httpAuthExtensionConfiguration.d.ts

```typescript
import { AwsCredentialIdentity, AwsCredentialIdentityProvider, HttpAuthScheme } from "@smithy/types";
import { SSOOIDCHttpAuthSchemeProvider } from "./httpAuthSchemeProvider";
/**
 * @internal
 */
export interface HttpAuthExtensionConfiguration {
    setHttpAuthScheme(httpAuthScheme: HttpAuthScheme): void;
    httpAuthSchemes(): HttpAuthScheme[];
    setHttpAuthSchemeProvider(httpAuthSchemeProvider: SSOOIDCHttpAuthSchemeProvider): void;
    httpAuthSchemeProvider(): SSOOIDCHttpAuthSchemeProvider;
    setCredentials(credentials: AwsCredentialIdentity | AwsCredentialIdentityProvider): void;
    credentials(): AwsCredentialIdentity | AwsCredentialIdentityProvider | undefined;
}
/**
 * @internal
 */
export type HttpAuthRuntimeConfig = Partial<{
    httpAuthSchemes: HttpAuthScheme[];
    httpAuthSchemeProvider: SSOOIDCHttpAuthSchemeProvider;
    credentials: AwsCredentialIdentity | AwsCredentialIdentityProvider;
}>;
/**
 * @internal
 */
export declare const getHttpAuthExtensionConfiguration: (runtimeConfig: HttpAuthRuntimeConfig) => HttpAuthExtensionConfiguration;
/**
 * @internal
 */
export declare const resolveHttpAuthRuntimeConfig: (config: HttpAuthExtensionConfiguration) => HttpAuthRuntimeConfig;

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/submodules/sso-oidc/auth/httpAuthSchemeProvider.d.ts

```typescript
import { AwsSdkSigV4AuthInputConfig, AwsSdkSigV4AuthResolvedConfig, AwsSdkSigV4PreviouslyResolved } from "@aws-sdk/core";
import { HandlerExecutionContext, HttpAuthScheme, HttpAuthSchemeParameters, HttpAuthSchemeParametersProvider, HttpAuthSchemeProvider, Provider } from "@smithy/types";
import { SSOOIDCClientResolvedConfig } from "../SSOOIDCClient";
/**
 * @internal
 */
export interface SSOOIDCHttpAuthSchemeParameters extends HttpAuthSchemeParameters {
    region?: string;
}
/**
 * @internal
 */
export interface SSOOIDCHttpAuthSchemeParametersProvider extends HttpAuthSchemeParametersProvider<SSOOIDCClientResolvedConfig, HandlerExecutionContext, SSOOIDCHttpAuthSchemeParameters, object> {
}
/**
 * @internal
 */
export declare const defaultSSOOIDCHttpAuthSchemeParametersProvider: (config: SSOOIDCClientResolvedConfig, context: HandlerExecutionContext, input: object) => Promise<SSOOIDCHttpAuthSchemeParameters>;
/**
 * @internal
 */
export interface SSOOIDCHttpAuthSchemeProvider extends HttpAuthSchemeProvider<SSOOIDCHttpAuthSchemeParameters> {
}
/**
 * @internal
 */
export declare const defaultSSOOIDCHttpAuthSchemeProvider: SSOOIDCHttpAuthSchemeProvider;
/**
 * @internal
 */
export interface HttpAuthSchemeInputConfig extends AwsSdkSigV4AuthInputConfig {
    /**
     * A comma-separated list of case-sensitive auth scheme names.
     * An auth scheme name is a fully qualified auth scheme ID with the namespace prefix trimmed.
     * For example, the auth scheme with ID aws.auth#sigv4 is named sigv4.
     * @public
     */
    authSchemePreference?: string[] | Provider<string[]>;
    /**
     * Configuration of HttpAuthSchemes for a client which provides default identity providers and signers per auth scheme.
     * @internal
     */
    httpAuthSchemes?: HttpAuthScheme[];
    /**
     * Configuration of an HttpAuthSchemeProvider for a client which resolves which HttpAuthScheme to use.
     * @internal
     */
    httpAuthSchemeProvider?: SSOOIDCHttpAuthSchemeProvider;
}
/**
 * @internal
 */
export interface HttpAuthSchemeResolvedConfig extends AwsSdkSigV4AuthResolvedConfig {
    /**
     * A comma-separated list of case-sensitive auth scheme names.
     * An auth scheme name is a fully qualified auth scheme ID with the namespace prefix trimmed.
     * For example, the auth scheme with ID aws.auth#sigv4 is named sigv4.
     * @public
     */
    readonly authSchemePreference: Provider<string[]>;
    /**
     * Configuration of HttpAuthSchemes for a client which provides default identity providers and signers per auth scheme.
     * @internal
     */
    readonly httpAuthSchemes: HttpAuthScheme[];
    /**
     * Configuration of an HttpAuthSchemeProvider for a client which resolves which HttpAuthScheme to use.
     * @internal
     */
    readonly httpAuthSchemeProvider: SSOOIDCHttpAuthSchemeProvider;
}
/**
 * @internal
 */
export declare const resolveHttpAuthSchemeConfig: <T>(config: T & HttpAuthSchemeInputConfig & AwsSdkSigV4PreviouslyResolved) => T & HttpAuthSchemeResolvedConfig;

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/submodules/sso-oidc/commands/CreateTokenCommand.d.ts

```typescript
import { Command as $Command } from "@smithy/smithy-client";
import { MetadataBearer as __MetadataBearer } from "@smithy/types";
import { CreateTokenRequest, CreateTokenResponse } from "../models/models_0";
import { SSOOIDCClientResolvedConfig } from "../SSOOIDCClient";
/**
 * @public
 */
export type { __MetadataBearer };
export { $Command };
/**
 * @public
 *
 * The input for {@link CreateTokenCommand}.
 */
export interface CreateTokenCommandInput extends CreateTokenRequest {
}
/**
 * @public
 *
 * The output of {@link CreateTokenCommand}.
 */
export interface CreateTokenCommandOutput extends CreateTokenResponse, __MetadataBearer {
}
declare const CreateTokenCommand_base: {
    new (input: CreateTokenCommandInput): import("@smithy/smithy-client").CommandImpl<CreateTokenCommandInput, CreateTokenCommandOutput, SSOOIDCClientResolvedConfig, CreateTokenCommandInput, CreateTokenCommandOutput>;
    new (input: CreateTokenCommandInput): import("@smithy/smithy-client").CommandImpl<CreateTokenCommandInput, CreateTokenCommandOutput, SSOOIDCClientResolvedConfig, CreateTokenCommandInput, CreateTokenCommandOutput>;
    getEndpointParameterInstructions(): import("@smithy/middleware-endpoint").EndpointParameterInstructions;
};
/**
 * <p>Creates and returns access and refresh tokens for clients that are authenticated using
 *       client secrets. The access token can be used to fetch short-lived credentials for the assigned
 *       AWS accounts or to access application APIs using <code>bearer</code> authentication.</p>
 * @example
 * Use a bare-bones client and the command you need to make an API call.
 * ```javascript
 * import { SSOOIDCClient, CreateTokenCommand } from "@aws-sdk/client-sso-oidc"; // ES Modules import
 * // const { SSOOIDCClient, CreateTokenCommand } = require("@aws-sdk/client-sso-oidc"); // CommonJS import
 * // import type { SSOOIDCClientConfig } from "@aws-sdk/client-sso-oidc";
 * const config = {}; // type is SSOOIDCClientConfig
 * const client = new SSOOIDCClient(config);
 * const input = { // CreateTokenRequest
 *   clientId: "STRING_VALUE", // required
 *   clientSecret: "STRING_VALUE", // required
 *   grantType: "STRING_VALUE", // required
 *   deviceCode: "STRING_VALUE",
 *   code: "STRING_VALUE",
 *   refreshToken: "STRING_VALUE",
 *   scope: [ // Scopes
 *     "STRING_VALUE",
 *   ],
 *   redirectUri: "STRING_VALUE",
 *   codeVerifier: "STRING_VALUE",
 * };
 * const command = new CreateTokenCommand(input);
 * const response = await client.send(command);
 * // { // CreateTokenResponse
 * //   accessToken: "STRING_VALUE",
 * //   tokenType: "STRING_VALUE",
 * //   expiresIn: Number("int"),
 * //   refreshToken: "STRING_VALUE",
 * //   idToken: "STRING_VALUE",
 * // };
 *
 * ```
 *
 * @param CreateTokenCommandInput - {@link CreateTokenCommandInput}
 * @returns {@link CreateTokenCommandOutput}
 * @see {@link CreateTokenCommandInput} for command's `input` shape.
 * @see {@link CreateTokenCommandOutput} for command's `response` shape.
 * @see {@link SSOOIDCClientResolvedConfig | config} for SSOOIDCClient's `config` shape.
 *
 * @throws {@link AccessDeniedException} (client fault)
 *  <p>You do not have sufficient access to perform this action.</p>
 *
 * @throws {@link AuthorizationPendingException} (client fault)
 *  <p>Indicates that a request to authorize a client with an access user session token is
 *       pending.</p>
 *
 * @throws {@link ExpiredTokenException} (client fault)
 *  <p>Indicates that the token issued by the service is expired and is no longer valid.</p>
 *
 * @throws {@link InternalServerException} (server fault)
 *  <p>Indicates that an error from the service occurred while trying to process a
 *       request.</p>
 *
 * @throws {@link InvalidClientException} (client fault)
 *  <p>Indicates that the <code>clientId</code> or <code>clientSecret</code> in the request is
 *       invalid. For example, this can occur when a client sends an incorrect <code>clientId</code> or
 *       an expired <code>clientSecret</code>.</p>
 *
 * @throws {@link InvalidGrantException} (client fault)
 *  <p>Indicates that a request contains an invalid grant. This can occur if a client makes a
 *         <a>CreateToken</a> request with an invalid grant type.</p>
 *
 * @throws {@link InvalidRequestException} (client fault)
 *  <p>Indicates that something is wrong with the input to the request. For example, a required
 *       parameter might be missing or out of range.</p>
 *
 * @throws {@link InvalidScopeException} (client fault)
 *  <p>Indicates that the scope provided in the request is invalid.</p>
 *
 * @throws {@link SlowDownException} (client fault)
 *  <p>Indicates that the client is making the request too frequently and is more than the
 *       service can handle. </p>
 *
 * @throws {@link UnauthorizedClientException} (client fault)
 *  <p>Indicates that the client is not currently authorized to make the request. This can happen
 *       when a <code>clientId</code> is not issued for a public client.</p>
 *
 * @throws {@link UnsupportedGrantTypeException} (client fault)
 *  <p>Indicates that the grant type in the request is not supported by the service.</p>
 *
 * @throws {@link SSOOIDCServiceException}
 * <p>Base exception class for all service exceptions from SSOOIDC service.</p>
 *
 *
 * @example Call OAuth/OIDC /token endpoint for Device Code grant with Secret authentication
 * ```javascript
 * //
 * const input = {
 *   clientId: "_yzkThXVzLWVhc3QtMQEXAMPLECLIENTID",
 *   clientSecret: "VERYLONGSECRETeyJraWQiOiJrZXktMTU2NDAyODA5OSIsImFsZyI6IkhTMzg0In0",
 *   deviceCode: "yJraWQiOiJrZXktMTU2Njk2ODA4OCIsImFsZyI6IkhTMzIn0EXAMPLEDEVICECODE",
 *   grantType: "urn:ietf:params:oauth:grant-type:device-code"
 * };
 * const command = new CreateTokenCommand(input);
 * const response = await client.send(command);
 * /* response is
 * {
 *   accessToken: "aoal-YigITUDiNX1xZwOMXM5MxOWDL0E0jg9P6_C_jKQPxS_SKCP6f0kh1Up4g7TtvQqkMnD-GJiU_S1gvug6SrggAkc0:MGYCMQD3IatVjV7jAJU91kK3PkS/SfA2wtgWzOgZWDOR7sDGN9t0phCZz5It/aes/3C1Zj0CMQCKWOgRaiz6AIhza3DSXQNMLjRKXC8F8ceCsHlgYLMZ7hZidEXAMPLEACCESSTOKEN",
 *   expiresIn: 1579729529,
 *   refreshToken: "aorvJYubGpU6i91YnH7Mfo-AT2fIVa1zCfA_Rvq9yjVKIP3onFmmykuQ7E93y2I-9Nyj-A_sVvMufaLNL0bqnDRtgAkc0:MGUCMFrRsktMRVlWaOR70XGMFGLL0SlcCw4DiYveIiOVx1uK9BbD0gvAddsW3UTLozXKMgIxAJ3qxUvjpnlLIOaaKOoa/FuNgqJVvr9GMwDtnAtlh9iZzAkEXAMPLEREFRESHTOKEN",
 *   tokenType: "Bearer"
 * }
 * *\/
 * ```
 *
 * @example Call OAuth/OIDC /token endpoint for Refresh Token grant with Secret authentication
 * ```javascript
 * //
 * const input = {
 *   clientId: "_yzkThXVzLWVhc3QtMQEXAMPLECLIENTID",
 *   clientSecret: "VERYLONGSECRETeyJraWQiOiJrZXktMTU2NDAyODA5OSIsImFsZyI6IkhTMzg0In0",
 *   grantType: "refresh_token",
 *   refreshToken: "aorvJYubGpU6i91YnH7Mfo-AT2fIVa1zCfA_Rvq9yjVKIP3onFmmykuQ7E93y2I-9Nyj-A_sVvMufaLNL0bqnDRtgAkc0:MGUCMFrRsktMRVlWaOR70XGMFGLL0SlcCw4DiYveIiOVx1uK9BbD0gvAddsW3UTLozXKMgIxAJ3qxUvjpnlLIOaaKOoa/FuNgqJVvr9GMwDtnAtlh9iZzAkEXAMPLEREFRESHTOKEN",
 *   scope: [
 *     "codewhisperer:completions"
 *   ]
 * };
 * const command = new CreateTokenCommand(input);
 * const response = await client.send(command);
 * /* response is
 * {
 *   accessToken: "aoal-YigITUDiNX1xZwOMXM5MxOWDL0E0jg9P6_C_jKQPxS_SKCP6f0kh1Up4g7TtvQqkMnD-GJiU_S1gvug6SrggAkc0:MGYCMQD3IatVjV7jAJU91kK3PkS/SfA2wtgWzOgZWDOR7sDGN9t0phCZz5It/aes/3C1Zj0CMQCKWOgRaiz6AIhza3DSXQNMLjRKXC8F8ceCsHlgYLMZ7hZidEXAMPLEACCESSTOKEN",
 *   expiresIn: 1579729529,
 *   refreshToken: "aorvJYubGpU6i91YnH7Mfo-AT2fIVa1zCfA_Rvq9yjVKIP3onFmmykuQ7E93y2I-9Nyj-A_sVvMufaLNL0bqnDRtgAkc0:MGUCMFrRsktMRVlWaOR70XGMFGLL0SlcCw4DiYveIiOVx1uK9BbD0gvAddsW3UTLozXKMgIxAJ3qxUvjpnlLIOaaKOoa/FuNgqJVvr9GMwDtnAtlh9iZzAkEXAMPLEREFRESHTOKEN",
 *   tokenType: "Bearer"
 * }
 * *\/
 * ```
 *
 * @public
 */
export declare class CreateTokenCommand extends CreateTokenCommand_base {
    /** @internal type navigation helper, not in runtime. */
    protected static __types: {
        api: {
            input: CreateTokenRequest;
            output: CreateTokenResponse;
        };
        sdk: {
            input: CreateTokenCommandInput;
            output: CreateTokenCommandOutput;
        };
    };
}

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/submodules/sso-oidc/commands/index.d.ts

```typescript
export * from "./CreateTokenCommand";

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/submodules/sso-oidc/endpoint/EndpointParameters.d.ts

```typescript
import { Endpoint, EndpointParameters as __EndpointParameters, EndpointV2, Provider } from "@smithy/types";
/**
 * @public
 */
export interface ClientInputEndpointParameters {
    region?: string | undefined | Provider<string | undefined>;
    useDualstackEndpoint?: boolean | undefined | Provider<boolean | undefined>;
    useFipsEndpoint?: boolean | undefined | Provider<boolean | undefined>;
    endpoint?: string | Provider<string> | Endpoint | Provider<Endpoint> | EndpointV2 | Provider<EndpointV2>;
}
export type ClientResolvedEndpointParameters = Omit<ClientInputEndpointParameters, "endpoint"> & {
    defaultSigningName: string;
};
export declare const resolveClientEndpointParameters: <T>(options: T & ClientInputEndpointParameters) => T & ClientResolvedEndpointParameters;
export declare const commonParams: {
    readonly UseFIPS: {
        readonly type: "builtInParams";
        readonly name: "useFipsEndpoint";
    };
    readonly Endpoint: {
        readonly type: "builtInParams";
        readonly name: "endpoint";
    };
    readonly Region: {
        readonly type: "builtInParams";
        readonly name: "region";
    };
    readonly UseDualStack: {
        readonly type: "builtInParams";
        readonly name: "useDualstackEndpoint";
    };
};
export interface EndpointParameters extends __EndpointParameters {
    Region?: string | undefined;
    UseDualStack?: boolean | undefined;
    UseFIPS?: boolean | undefined;
    Endpoint?: string | undefined;
}

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/submodules/sso-oidc/endpoint/endpointResolver.d.ts

```typescript
import { EndpointV2, Logger } from "@smithy/types";
import { EndpointParameters } from "./EndpointParameters";
export declare const defaultEndpointResolver: (endpointParams: EndpointParameters, context?: {
    logger?: Logger;
}) => EndpointV2;

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/submodules/sso-oidc/endpoint/ruleset.d.ts

```typescript
import { RuleSetObject } from "@smithy/types";
export declare const ruleSet: RuleSetObject;

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/submodules/sso-oidc/extensionConfiguration.d.ts

```typescript
import { AwsRegionExtensionConfiguration } from "@aws-sdk/types";
import { HttpHandlerExtensionConfiguration } from "@smithy/protocol-http";
import { DefaultExtensionConfiguration } from "@smithy/types";
import { HttpAuthExtensionConfiguration } from "./auth/httpAuthExtensionConfiguration";
/**
 * @internal
 */
export interface SSOOIDCExtensionConfiguration extends HttpHandlerExtensionConfiguration, DefaultExtensionConfiguration, AwsRegionExtensionConfiguration, HttpAuthExtensionConfiguration {
}

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/submodules/sso-oidc/index.d.ts

```typescript
/**
 * <p>IAM Identity Center OpenID Connect (OIDC) is a web service that enables a client (such as CLI or a
 *       native application) to register with IAM Identity Center. The service also enables the client to fetch the
 *       users access token upon successful authentication and authorization with IAM Identity Center.</p>
 *          <p>
 *             <b>API namespaces</b>
 *          </p>
 *          <p>IAM Identity Center uses the <code>sso</code> and <code>identitystore</code> API namespaces. IAM Identity Center
 *       OpenID Connect uses the <code>sso-oauth</code> namespace.</p>
 *          <p>
 *             <b>Considerations for using this guide</b>
 *          </p>
 *          <p>Before you begin using this guide, we recommend that you first review the following
 *       important information about how the IAM Identity Center OIDC service works.</p>
 *          <ul>
 *             <li>
 *                <p>The IAM Identity Center OIDC service currently implements only the portions of the OAuth 2.0 Device
 *           Authorization Grant standard (<a href="https://tools.ietf.org/html/rfc8628">https://tools.ietf.org/html/rfc8628</a>) that are necessary to enable single
 *           sign-on authentication with the CLI. </p>
 *             </li>
 *             <li>
 *                <p>With older versions of the CLI, the service only emits OIDC access tokens, so to
 *           obtain a new token, users must explicitly re-authenticate. To access the OIDC flow that
 *           supports token refresh and doesnt require re-authentication, update to the latest CLI
 *           version (1.27.10 for CLI V1 and 2.9.0 for CLI V2) with support for OIDC token refresh
 *           and configurable IAM Identity Center session durations. For more information, see <a href="https://docs.aws.amazon.com/singlesignon/latest/userguide/configure-user-session.html">Configure Amazon Web Services access portal session duration </a>. </p>
 *             </li>
 *             <li>
 *                <p>The access tokens provided by this service grant access to all Amazon Web Services account
 *           entitlements assigned to an IAM Identity Center user, not just a particular application.</p>
 *             </li>
 *             <li>
 *                <p>The documentation in this guide does not describe the mechanism to convert the access
 *           token into Amazon Web Services Auth (sigv4) credentials for use with IAM-protected Amazon Web Services service
 *           endpoints. For more information, see <a href="https://docs.aws.amazon.com/singlesignon/latest/PortalAPIReference/API_GetRoleCredentials.html">GetRoleCredentials</a> in the <i>IAM Identity Center Portal API Reference
 *           Guide</i>.</p>
 *             </li>
 *          </ul>
 *          <p>For general information about IAM Identity Center, see <a href="https://docs.aws.amazon.com/singlesignon/latest/userguide/what-is.html">What is
 *         IAM Identity Center?</a> in the <i>IAM Identity Center User Guide</i>.</p>
 *
 * @packageDocumentation
 */
export * from "./SSOOIDCClient";
export * from "./SSOOIDC";
export { ClientInputEndpointParameters } from "./endpoint/EndpointParameters";
export type { RuntimeExtension } from "./runtimeExtensions";
export type { SSOOIDCExtensionConfiguration } from "./extensionConfiguration";
export * from "./commands";
export * from "./models";
export { SSOOIDCServiceException } from "./models/SSOOIDCServiceException";

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/submodules/sso-oidc/models/SSOOIDCServiceException.d.ts

```typescript
import { ServiceException as __ServiceException, ServiceExceptionOptions as __ServiceExceptionOptions } from "@smithy/smithy-client";
export type { __ServiceExceptionOptions };
export { __ServiceException };
/**
 * @public
 *
 * Base exception class for all service exceptions from SSOOIDC service.
 */
export declare class SSOOIDCServiceException extends __ServiceException {
    /**
     * @internal
     */
    constructor(options: __ServiceExceptionOptions);
}

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/submodules/sso-oidc/models/index.d.ts

```typescript
export * from "./models_0";

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/submodules/sso-oidc/models/models_0.d.ts

```typescript
import { ExceptionOptionType as __ExceptionOptionType } from "@smithy/smithy-client";
import { SSOOIDCServiceException as __BaseException } from "./SSOOIDCServiceException";
/**
 * @public
 * @enum
 */
export declare const AccessDeniedExceptionReason: {
    readonly KMS_ACCESS_DENIED: "KMS_AccessDeniedException";
};
/**
 * @public
 */
export type AccessDeniedExceptionReason = (typeof AccessDeniedExceptionReason)[keyof typeof AccessDeniedExceptionReason];
/**
 * <p>You do not have sufficient access to perform this action.</p>
 * @public
 */
export declare class AccessDeniedException extends __BaseException {
    readonly name: "AccessDeniedException";
    readonly $fault: "client";
    /**
     * <p>Single error code. For this exception the value will be <code>access_denied</code>.</p>
     * @public
     */
    error?: string | undefined;
    /**
     * <p>A string that uniquely identifies a reason for the error.</p>
     * @public
     */
    reason?: AccessDeniedExceptionReason | undefined;
    /**
     * <p>Human-readable text providing additional information, used to assist the client developer
     *       in understanding the error that occurred.</p>
     * @public
     */
    error_description?: string | undefined;
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<AccessDeniedException, __BaseException>);
}
/**
 * <p>Indicates that a request to authorize a client with an access user session token is
 *       pending.</p>
 * @public
 */
export declare class AuthorizationPendingException extends __BaseException {
    readonly name: "AuthorizationPendingException";
    readonly $fault: "client";
    /**
     * <p>Single error code. For this exception the value will be
     *       <code>authorization_pending</code>.</p>
     * @public
     */
    error?: string | undefined;
    /**
     * <p>Human-readable text providing additional information, used to assist the client developer
     *       in understanding the error that occurred.</p>
     * @public
     */
    error_description?: string | undefined;
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<AuthorizationPendingException, __BaseException>);
}
/**
 * @public
 */
export interface CreateTokenRequest {
    /**
     * <p>The unique identifier string for the client or application. This value comes from the
     *       result of the <a>RegisterClient</a> API.</p>
     * @public
     */
    clientId: string | undefined;
    /**
     * <p>A secret string generated for the client. This value should come from the persisted result
     *       of the <a>RegisterClient</a> API.</p>
     * @public
     */
    clientSecret: string | undefined;
    /**
     * <p>Supports the following OAuth grant types: Authorization Code, Device Code, and Refresh
     *       Token. Specify one of the following values, depending on the grant type that you want:</p>
     *          <p>* Authorization Code - <code>authorization_code</code>
     *          </p>
     *          <p>* Device Code - <code>urn:ietf:params:oauth:grant-type:device_code</code>
     *          </p>
     *          <p>* Refresh Token - <code>refresh_token</code>
     *          </p>
     * @public
     */
    grantType: string | undefined;
    /**
     * <p>Used only when calling this API for the Device Code grant type. This short-lived code is
     *       used to identify this authorization request. This comes from the result of the <a>StartDeviceAuthorization</a> API.</p>
     * @public
     */
    deviceCode?: string | undefined;
    /**
     * <p>Used only when calling this API for the Authorization Code grant type. The short-lived
     *       code is used to identify this authorization request.</p>
     * @public
     */
    code?: string | undefined;
    /**
     * <p>Used only when calling this API for the Refresh Token grant type. This token is used to
     *       refresh short-lived tokens, such as the access token, that might expire.</p>
     *          <p>For more information about the features and limitations of the current IAM Identity Center OIDC
     *       implementation, see <i>Considerations for Using this Guide</i> in the <a href="https://docs.aws.amazon.com/singlesignon/latest/OIDCAPIReference/Welcome.html">IAM Identity Center
     *         OIDC API Reference</a>.</p>
     * @public
     */
    refreshToken?: string | undefined;
    /**
     * <p>The list of scopes for which authorization is requested. This parameter has no effect; the access token will always include all scopes configured during client registration.</p>
     * @public
     */
    scope?: string[] | undefined;
    /**
     * <p>Used only when calling this API for the Authorization Code grant type. This value
     *       specifies the location of the client or application that has registered to receive the
     *       authorization code.</p>
     * @public
     */
    redirectUri?: string | undefined;
    /**
     * <p>Used only when calling this API for the Authorization Code grant type. This value is
     *       generated by the client and presented to validate the original code challenge value the client
     *       passed at authorization time.</p>
     * @public
     */
    codeVerifier?: string | undefined;
}
/**
 * @internal
 */
export declare const CreateTokenRequestFilterSensitiveLog: (obj: CreateTokenRequest) => any;
/**
 * @public
 */
export interface CreateTokenResponse {
    /**
     * <p>A bearer token to access Amazon Web Services accounts and applications assigned to a user.</p>
     * @public
     */
    accessToken?: string | undefined;
    /**
     * <p>Used to notify the client that the returned token is an access token. The supported token
     *       type is <code>Bearer</code>.</p>
     * @public
     */
    tokenType?: string | undefined;
    /**
     * <p>Indicates the time in seconds when an access token will expire.</p>
     * @public
     */
    expiresIn?: number | undefined;
    /**
     * <p>A token that, if present, can be used to refresh a previously issued access token that
     *       might have expired.</p>
     *          <p>For more information about the features and limitations of the current IAM Identity Center OIDC
     *       implementation, see <i>Considerations for Using this Guide</i> in the <a href="https://docs.aws.amazon.com/singlesignon/latest/OIDCAPIReference/Welcome.html">IAM Identity Center
     *         OIDC API Reference</a>.</p>
     * @public
     */
    refreshToken?: string | undefined;
    /**
     * <p>The <code>idToken</code> is not implemented or supported. For more information about the
     *       features and limitations of the current IAM Identity Center OIDC implementation, see
     *         <i>Considerations for Using this Guide</i> in the <a href="https://docs.aws.amazon.com/singlesignon/latest/OIDCAPIReference/Welcome.html">IAM Identity Center
     *         OIDC API Reference</a>.</p>
     *          <p>A JSON Web Token (JWT) that identifies who is associated with the issued access token.
     *     </p>
     * @public
     */
    idToken?: string | undefined;
}
/**
 * @internal
 */
export declare const CreateTokenResponseFilterSensitiveLog: (obj: CreateTokenResponse) => any;
/**
 * <p>Indicates that the token issued by the service is expired and is no longer valid.</p>
 * @public
 */
export declare class ExpiredTokenException extends __BaseException {
    readonly name: "ExpiredTokenException";
    readonly $fault: "client";
    /**
     * <p>Single error code. For this exception the value will be <code>expired_token</code>.</p>
     * @public
     */
    error?: string | undefined;
    /**
     * <p>Human-readable text providing additional information, used to assist the client developer
     *       in understanding the error that occurred.</p>
     * @public
     */
    error_description?: string | undefined;
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<ExpiredTokenException, __BaseException>);
}
/**
 * <p>Indicates that an error from the service occurred while trying to process a
 *       request.</p>
 * @public
 */
export declare class InternalServerException extends __BaseException {
    readonly name: "InternalServerException";
    readonly $fault: "server";
    /**
     * <p>Single error code. For this exception the value will be <code>server_error</code>.</p>
     * @public
     */
    error?: string | undefined;
    /**
     * <p>Human-readable text providing additional information, used to assist the client developer
     *       in understanding the error that occurred.</p>
     * @public
     */
    error_description?: string | undefined;
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<InternalServerException, __BaseException>);
}
/**
 * <p>Indicates that the <code>clientId</code> or <code>clientSecret</code> in the request is
 *       invalid. For example, this can occur when a client sends an incorrect <code>clientId</code> or
 *       an expired <code>clientSecret</code>.</p>
 * @public
 */
export declare class InvalidClientException extends __BaseException {
    readonly name: "InvalidClientException";
    readonly $fault: "client";
    /**
     * <p>Single error code. For this exception the value will be
     *       <code>invalid_client</code>.</p>
     * @public
     */
    error?: string | undefined;
    /**
     * <p>Human-readable text providing additional information, used to assist the client developer
     *       in understanding the error that occurred.</p>
     * @public
     */
    error_description?: string | undefined;
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<InvalidClientException, __BaseException>);
}
/**
 * <p>Indicates that a request contains an invalid grant. This can occur if a client makes a
 *         <a>CreateToken</a> request with an invalid grant type.</p>
 * @public
 */
export declare class InvalidGrantException extends __BaseException {
    readonly name: "InvalidGrantException";
    readonly $fault: "client";
    /**
     * <p>Single error code. For this exception the value will be <code>invalid_grant</code>.</p>
     * @public
     */
    error?: string | undefined;
    /**
     * <p>Human-readable text providing additional information, used to assist the client developer
     *       in understanding the error that occurred.</p>
     * @public
     */
    error_description?: string | undefined;
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<InvalidGrantException, __BaseException>);
}
/**
 * @public
 * @enum
 */
export declare const InvalidRequestExceptionReason: {
    readonly KMS_DISABLED_KEY: "KMS_DisabledException";
    readonly KMS_INVALID_KEY_USAGE: "KMS_InvalidKeyUsageException";
    readonly KMS_INVALID_STATE: "KMS_InvalidStateException";
    readonly KMS_KEY_NOT_FOUND: "KMS_NotFoundException";
};
/**
 * @public
 */
export type InvalidRequestExceptionReason = (typeof InvalidRequestExceptionReason)[keyof typeof InvalidRequestExceptionReason];
/**
 * <p>Indicates that something is wrong with the input to the request. For example, a required
 *       parameter might be missing or out of range.</p>
 * @public
 */
export declare class InvalidRequestException extends __BaseException {
    readonly name: "InvalidRequestException";
    readonly $fault: "client";
    /**
     * <p>Single error code. For this exception the value will be
     *       <code>invalid_request</code>.</p>
     * @public
     */
    error?: string | undefined;
    /**
     * <p>A string that uniquely identifies a reason for the error.</p>
     * @public
     */
    reason?: InvalidRequestExceptionReason | undefined;
    /**
     * <p>Human-readable text providing additional information, used to assist the client developer
     *       in understanding the error that occurred.</p>
     * @public
     */
    error_description?: string | undefined;
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<InvalidRequestException, __BaseException>);
}
/**
 * <p>Indicates that the scope provided in the request is invalid.</p>
 * @public
 */
export declare class InvalidScopeException extends __BaseException {
    readonly name: "InvalidScopeException";
    readonly $fault: "client";
    /**
     * <p>Single error code. For this exception the value will be <code>invalid_scope</code>.</p>
     * @public
     */
    error?: string | undefined;
    /**
     * <p>Human-readable text providing additional information, used to assist the client developer
     *       in understanding the error that occurred.</p>
     * @public
     */
    error_description?: string | undefined;
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<InvalidScopeException, __BaseException>);
}
/**
 * <p>Indicates that the client is making the request too frequently and is more than the
 *       service can handle. </p>
 * @public
 */
export declare class SlowDownException extends __BaseException {
    readonly name: "SlowDownException";
    readonly $fault: "client";
    /**
     * <p>Single error code. For this exception the value will be <code>slow_down</code>.</p>
     * @public
     */
    error?: string | undefined;
    /**
     * <p>Human-readable text providing additional information, used to assist the client developer
     *       in understanding the error that occurred.</p>
     * @public
     */
    error_description?: string | undefined;
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<SlowDownException, __BaseException>);
}
/**
 * <p>Indicates that the client is not currently authorized to make the request. This can happen
 *       when a <code>clientId</code> is not issued for a public client.</p>
 * @public
 */
export declare class UnauthorizedClientException extends __BaseException {
    readonly name: "UnauthorizedClientException";
    readonly $fault: "client";
    /**
     * <p>Single error code. For this exception the value will be
     *       <code>unauthorized_client</code>.</p>
     * @public
     */
    error?: string | undefined;
    /**
     * <p>Human-readable text providing additional information, used to assist the client developer
     *       in understanding the error that occurred.</p>
     * @public
     */
    error_description?: string | undefined;
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<UnauthorizedClientException, __BaseException>);
}
/**
 * <p>Indicates that the grant type in the request is not supported by the service.</p>
 * @public
 */
export declare class UnsupportedGrantTypeException extends __BaseException {
    readonly name: "UnsupportedGrantTypeException";
    readonly $fault: "client";
    /**
     * <p>Single error code. For this exception the value will be
     *         <code>unsupported_grant_type</code>.</p>
     * @public
     */
    error?: string | undefined;
    /**
     * <p>Human-readable text providing additional information, used to assist the client developer
     *       in understanding the error that occurred.</p>
     * @public
     */
    error_description?: string | undefined;
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<UnsupportedGrantTypeException, __BaseException>);
}

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/submodules/sso-oidc/protocols/Aws_restJson1.d.ts

```typescript
import { HttpRequest as __HttpRequest, HttpResponse as __HttpResponse } from "@smithy/protocol-http";
import { SerdeContext as __SerdeContext } from "@smithy/types";
import { CreateTokenCommandInput, CreateTokenCommandOutput } from "../commands/CreateTokenCommand";
/**
 * serializeAws_restJson1CreateTokenCommand
 */
export declare const se_CreateTokenCommand: (input: CreateTokenCommandInput, context: __SerdeContext) => Promise<__HttpRequest>;
/**
 * deserializeAws_restJson1CreateTokenCommand
 */
export declare const de_CreateTokenCommand: (output: __HttpResponse, context: __SerdeContext) => Promise<CreateTokenCommandOutput>;

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/submodules/sso-oidc/runtimeConfig.browser.d.ts

```typescript
import { FetchHttpHandler as RequestHandler } from "@smithy/fetch-http-handler";
import { SSOOIDCClientConfig } from "./SSOOIDCClient";
/**
 * @internal
 */
export declare const getRuntimeConfig: (config: SSOOIDCClientConfig) => {
    runtime: string;
    defaultsMode: import("@smithy/types").Provider<import("@smithy/smithy-client").ResolvedDefaultsMode>;
    bodyLengthChecker: import("@smithy/types").BodyLengthCalculator;
    defaultUserAgentProvider: (config?: import("@aws-sdk/util-user-agent-browser").PreviouslyResolved) => Promise<import("@smithy/types").UserAgent>;
    maxAttempts: number | import("@smithy/types").Provider<number>;
    region: string | import("@smithy/types").Provider<any>;
    requestHandler: import("@smithy/protocol-http").HttpHandler<any> | RequestHandler;
    retryMode: string | import("@smithy/types").Provider<string>;
    sha256: import("@smithy/types").HashConstructor;
    streamCollector: import("@smithy/types").StreamCollector;
    useDualstackEndpoint: (boolean | import("@smithy/types").Provider<boolean>) & (boolean | import("@smithy/types").Provider<boolean | undefined>);
    useFipsEndpoint: (boolean | import("@smithy/types").Provider<boolean>) & (boolean | import("@smithy/types").Provider<boolean | undefined>);
    apiVersion: string;
    cacheMiddleware?: boolean | undefined;
    urlParser: import("@smithy/types").UrlParser;
    base64Decoder: import("@smithy/types").Decoder;
    base64Encoder: (_input: Uint8Array | string) => string;
    utf8Decoder: import("@smithy/types").Decoder;
    utf8Encoder: (input: Uint8Array | string) => string;
    disableHostPrefix: boolean;
    serviceId: string;
    profile?: string;
    logger: import("@smithy/types").Logger;
    extensions: import("./runtimeExtensions").RuntimeExtension[];
    customUserAgent?: string | import("@smithy/types").UserAgent;
    userAgentAppId?: string | undefined | import("@smithy/types").Provider<string | undefined>;
    retryStrategy?: import("@smithy/types").RetryStrategy | import("@smithy/types").RetryStrategyV2;
    endpoint?: ((string | import("@smithy/types").Endpoint | import("@smithy/types").Provider<import("@smithy/types").Endpoint> | import("@smithy/types").EndpointV2 | import("@smithy/types").Provider<import("@smithy/types").EndpointV2>) & (string | import("@smithy/types").Provider<string> | import("@smithy/types").Endpoint | import("@smithy/types").Provider<import("@smithy/types").Endpoint> | import("@smithy/types").EndpointV2 | import("@smithy/types").Provider<import("@smithy/types").EndpointV2>)) | undefined;
    endpointProvider: (endpointParams: import("./endpoint/EndpointParameters").EndpointParameters, context?: {
        logger?: import("@smithy/types").Logger;
    }) => import("@smithy/types").EndpointV2;
    tls?: boolean;
    serviceConfiguredEndpoint?: never;
    authSchemePreference?: string[] | import("@smithy/types").Provider<string[]>;
    httpAuthSchemes: import("@smithy/types").HttpAuthScheme[] | ({
        schemeId: string;
        identityProvider: (ipc: import("@smithy/types").IdentityProviderConfig) => import("@smithy/types").IdentityProvider<import("@smithy/types").Identity> | undefined;
        signer: import("@aws-sdk/core").AwsSdkSigV4Signer;
    } | {
        schemeId: string;
        identityProvider: (ipc: import("@smithy/types").IdentityProviderConfig) => import("@smithy/types").IdentityProvider<import("@smithy/types").Identity> | (() => Promise<{}>);
        signer: import("@smithy/core").NoAuthSigner;
    })[];
    httpAuthSchemeProvider: import("./auth/httpAuthSchemeProvider").SSOOIDCHttpAuthSchemeProvider;
    credentials?: import("@smithy/types").AwsCredentialIdentity | import("@smithy/types").AwsCredentialIdentityProvider;
    signer?: import("@smithy/types").RequestSigner | ((authScheme?: import("@smithy/types").AuthScheme) => Promise<import("@smithy/types").RequestSigner>);
    signingEscapePath?: boolean;
    systemClockOffset?: number;
    signingRegion?: string;
    signerConstructor?: new (options: import("@smithy/signature-v4").SignatureV4Init & import("@smithy/signature-v4").SignatureV4CryptoInit) => import("@smithy/types").RequestSigner;
};

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/submodules/sso-oidc/runtimeConfig.d.ts

```typescript
import { NodeHttpHandler as RequestHandler } from "@smithy/node-http-handler";
import { SSOOIDCClientConfig } from "./SSOOIDCClient";
/**
 * @internal
 */
export declare const getRuntimeConfig: (config: SSOOIDCClientConfig) => {
    runtime: string;
    defaultsMode: import("@smithy/types").Provider<import("@smithy/smithy-client").ResolvedDefaultsMode>;
    authSchemePreference: string[] | import("@smithy/types").Provider<string[]>;
    bodyLengthChecker: import("@smithy/types").BodyLengthCalculator;
    defaultUserAgentProvider: (config?: import("@aws-sdk/util-user-agent-node").PreviouslyResolved) => Promise<import("@smithy/types").UserAgent>;
    maxAttempts: number | import("@smithy/types").Provider<number>;
    region: string | import("@smithy/types").Provider<string>;
    requestHandler: RequestHandler | import("@smithy/protocol-http").HttpHandler<any>;
    retryMode: string | import("@smithy/types").Provider<string>;
    sha256: import("@smithy/types").HashConstructor;
    streamCollector: import("@smithy/types").StreamCollector;
    useDualstackEndpoint: boolean | import("@smithy/types").Provider<boolean>;
    useFipsEndpoint: boolean | import("@smithy/types").Provider<boolean>;
    userAgentAppId: string | import("@smithy/types").Provider<string | undefined>;
    apiVersion: string;
    cacheMiddleware?: boolean | undefined;
    urlParser: import("@smithy/types").UrlParser;
    base64Decoder: import("@smithy/types").Decoder;
    base64Encoder: (_input: Uint8Array | string) => string;
    utf8Decoder: import("@smithy/types").Decoder;
    utf8Encoder: (input: Uint8Array | string) => string;
    disableHostPrefix: boolean;
    serviceId: string;
    profile?: string;
    logger: import("@smithy/types").Logger;
    extensions: import("./runtimeExtensions").RuntimeExtension[];
    customUserAgent?: string | import("@smithy/types").UserAgent;
    retryStrategy?: import("@smithy/types").RetryStrategy | import("@smithy/types").RetryStrategyV2;
    endpoint?: ((string | import("@smithy/types").Endpoint | import("@smithy/types").Provider<import("@smithy/types").Endpoint> | import("@smithy/types").EndpointV2 | import("@smithy/types").Provider<import("@smithy/types").EndpointV2>) & (string | import("@smithy/types").Provider<string> | import("@smithy/types").Endpoint | import("@smithy/types").Provider<import("@smithy/types").Endpoint> | import("@smithy/types").EndpointV2 | import("@smithy/types").Provider<import("@smithy/types").EndpointV2>)) | undefined;
    endpointProvider: (endpointParams: import("./endpoint/EndpointParameters").EndpointParameters, context?: {
        logger?: import("@smithy/types").Logger;
    }) => import("@smithy/types").EndpointV2;
    tls?: boolean;
    serviceConfiguredEndpoint?: never;
    httpAuthSchemes: import("@smithy/types").HttpAuthScheme[] | ({
        schemeId: string;
        identityProvider: (ipc: import("@smithy/types").IdentityProviderConfig) => import("@smithy/types").IdentityProvider<import("@smithy/types").Identity> | undefined;
        signer: import("@aws-sdk/core").AwsSdkSigV4Signer;
    } | {
        schemeId: string;
        identityProvider: (ipc: import("@smithy/types").IdentityProviderConfig) => import("@smithy/types").IdentityProvider<import("@smithy/types").Identity> | (() => Promise<{}>);
        signer: import("@smithy/core").NoAuthSigner;
    })[];
    httpAuthSchemeProvider: import("./auth/httpAuthSchemeProvider").SSOOIDCHttpAuthSchemeProvider;
    credentials?: import("@smithy/types").AwsCredentialIdentity | import("@smithy/types").AwsCredentialIdentityProvider;
    signer?: import("@smithy/types").RequestSigner | ((authScheme?: import("@smithy/types").AuthScheme) => Promise<import("@smithy/types").RequestSigner>);
    signingEscapePath?: boolean;
    systemClockOffset?: number;
    signingRegion?: string;
    signerConstructor?: new (options: import("@smithy/signature-v4").SignatureV4Init & import("@smithy/signature-v4").SignatureV4CryptoInit) => import("@smithy/types").RequestSigner;
};

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/submodules/sso-oidc/runtimeConfig.native.d.ts

```typescript
import { SSOOIDCClientConfig } from "./SSOOIDCClient";
/**
 * @internal
 */
export declare const getRuntimeConfig: (config: SSOOIDCClientConfig) => {
    runtime: string;
    sha256: import("@smithy/types").HashConstructor;
    requestHandler: import("@smithy/types").NodeHttpHandlerOptions | import("@smithy/types").FetchHttpHandlerOptions | Record<string, unknown> | import("@smithy/protocol-http").HttpHandler<any> | import("@smithy/fetch-http-handler").FetchHttpHandler;
    apiVersion: string;
    cacheMiddleware?: boolean;
    urlParser: import("@smithy/types").UrlParser;
    bodyLengthChecker: import("@smithy/types").BodyLengthCalculator;
    streamCollector: import("@smithy/types").StreamCollector;
    base64Decoder: import("@smithy/types").Decoder;
    base64Encoder: (_input: Uint8Array | string) => string;
    utf8Decoder: import("@smithy/types").Decoder;
    utf8Encoder: (input: Uint8Array | string) => string;
    disableHostPrefix: boolean;
    serviceId: string;
    useDualstackEndpoint: (boolean | import("@smithy/types").Provider<boolean>) & (boolean | import("@smithy/types").Provider<boolean | undefined>);
    useFipsEndpoint: (boolean | import("@smithy/types").Provider<boolean>) & (boolean | import("@smithy/types").Provider<boolean | undefined>);
    region: string | import("@smithy/types").Provider<any>;
    profile?: string;
    defaultUserAgentProvider: (config?: import("@aws-sdk/util-user-agent-browser").PreviouslyResolved) => Promise<import("@smithy/types").UserAgent>;
    maxAttempts: number | import("@smithy/types").Provider<number>;
    retryMode: string | import("@smithy/types").Provider<string>;
    logger: import("@smithy/types").Logger;
    extensions: import("./runtimeExtensions").RuntimeExtension[];
    defaultsMode: import("@smithy/smithy-client").DefaultsMode | import("@smithy/types").Provider<import("@smithy/smithy-client").DefaultsMode>;
    customUserAgent?: string | import("@smithy/types").UserAgent;
    userAgentAppId?: string | undefined | import("@smithy/types").Provider<string | undefined>;
    retryStrategy?: import("@smithy/types").RetryStrategy | import("@smithy/types").RetryStrategyV2;
    endpoint?: ((string | import("@smithy/types").Endpoint | import("@smithy/types").Provider<import("@smithy/types").Endpoint> | import("@smithy/types").EndpointV2 | import("@smithy/types").Provider<import("@smithy/types").EndpointV2>) & (string | import("@smithy/types").Provider<string> | import("@smithy/types").Endpoint | import("@smithy/types").Provider<import("@smithy/types").Endpoint> | import("@smithy/types").EndpointV2 | import("@smithy/types").Provider<import("@smithy/types").EndpointV2>)) | undefined;
    endpointProvider: (endpointParams: import("./endpoint/EndpointParameters").EndpointParameters, context?: {
        logger?: import("@smithy/types").Logger;
    }) => import("@smithy/types").EndpointV2;
    tls?: boolean;
    serviceConfiguredEndpoint?: never;
    authSchemePreference?: string[] | import("@smithy/types").Provider<string[]>;
    httpAuthSchemes: import("@smithy/types").HttpAuthScheme[] | ({
        schemeId: string;
        identityProvider: (ipc: import("@smithy/types").IdentityProviderConfig) => import("@smithy/types").IdentityProvider<import("@smithy/types").Identity> | undefined;
        signer: import("@aws-sdk/core").AwsSdkSigV4Signer;
    } | {
        schemeId: string;
        identityProvider: (ipc: import("@smithy/types").IdentityProviderConfig) => import("@smithy/types").IdentityProvider<import("@smithy/types").Identity> | (() => Promise<{}>);
        signer: import("@smithy/core").NoAuthSigner;
    })[];
    httpAuthSchemeProvider: import("./auth/httpAuthSchemeProvider").SSOOIDCHttpAuthSchemeProvider;
    credentials?: import("@smithy/types").AwsCredentialIdentity | import("@smithy/types").AwsCredentialIdentityProvider;
    signer?: import("@smithy/types").RequestSigner | ((authScheme?: import("@smithy/types").AuthScheme) => Promise<import("@smithy/types").RequestSigner>);
    signingEscapePath?: boolean;
    systemClockOffset?: number;
    signingRegion?: string;
    signerConstructor?: new (options: import("@smithy/signature-v4").SignatureV4Init & import("@smithy/signature-v4").SignatureV4CryptoInit) => import("@smithy/types").RequestSigner;
};

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/submodules/sso-oidc/runtimeConfig.shared.d.ts

```typescript
import { AwsSdkSigV4Signer } from "@aws-sdk/core";
import { NoAuthSigner } from "@smithy/core";
import { IdentityProviderConfig } from "@smithy/types";
import { SSOOIDCClientConfig } from "./SSOOIDCClient";
/**
 * @internal
 */
export declare const getRuntimeConfig: (config: SSOOIDCClientConfig) => {
    apiVersion: string;
    base64Decoder: import("@smithy/types").Decoder;
    base64Encoder: (_input: Uint8Array | string) => string;
    disableHostPrefix: boolean;
    endpointProvider: (endpointParams: import("./endpoint/EndpointParameters").EndpointParameters, context?: {
        logger?: import("@smithy/types").Logger;
    }) => import("@smithy/types").EndpointV2;
    extensions: import("./runtimeExtensions").RuntimeExtension[];
    httpAuthSchemeProvider: import("./auth/httpAuthSchemeProvider").SSOOIDCHttpAuthSchemeProvider;
    httpAuthSchemes: import("@smithy/types").HttpAuthScheme[] | ({
        schemeId: string;
        identityProvider: (ipc: IdentityProviderConfig) => import("@smithy/types").IdentityProvider<import("@smithy/types").Identity> | undefined;
        signer: AwsSdkSigV4Signer;
    } | {
        schemeId: string;
        identityProvider: (ipc: IdentityProviderConfig) => import("@smithy/types").IdentityProvider<import("@smithy/types").Identity> | (() => Promise<{}>);
        signer: NoAuthSigner;
    })[];
    logger: import("@smithy/types").Logger;
    serviceId: string;
    urlParser: import("@smithy/types").UrlParser;
    utf8Decoder: import("@smithy/types").Decoder;
    utf8Encoder: (input: Uint8Array | string) => string;
};

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/submodules/sso-oidc/runtimeExtensions.d.ts

```typescript
import { SSOOIDCExtensionConfiguration } from "./extensionConfiguration";
/**
 * @public
 */
export interface RuntimeExtension {
    configure(extensionConfiguration: SSOOIDCExtensionConfiguration): void;
}
/**
 * @public
 */
export interface RuntimeExtensionsConfig {
    extensions: RuntimeExtension[];
}
/**
 * @internal
 */
export declare const resolveRuntimeExtensions: (runtimeConfig: any, extensions: RuntimeExtension[]) => any;

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/submodules/sts/STS.d.ts

```typescript
import { HttpHandlerOptions as __HttpHandlerOptions } from "@smithy/types";
import { AssumeRoleCommandInput, AssumeRoleCommandOutput } from "./commands/AssumeRoleCommand";
import { AssumeRoleWithWebIdentityCommandInput, AssumeRoleWithWebIdentityCommandOutput } from "./commands/AssumeRoleWithWebIdentityCommand";
import { STSClient } from "./STSClient";
export interface STS {
    /**
     * @see {@link AssumeRoleCommand}
     */
    assumeRole(args: AssumeRoleCommandInput, options?: __HttpHandlerOptions): Promise<AssumeRoleCommandOutput>;
    assumeRole(args: AssumeRoleCommandInput, cb: (err: any, data?: AssumeRoleCommandOutput) => void): void;
    assumeRole(args: AssumeRoleCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: AssumeRoleCommandOutput) => void): void;
    /**
     * @see {@link AssumeRoleWithWebIdentityCommand}
     */
    assumeRoleWithWebIdentity(args: AssumeRoleWithWebIdentityCommandInput, options?: __HttpHandlerOptions): Promise<AssumeRoleWithWebIdentityCommandOutput>;
    assumeRoleWithWebIdentity(args: AssumeRoleWithWebIdentityCommandInput, cb: (err: any, data?: AssumeRoleWithWebIdentityCommandOutput) => void): void;
    assumeRoleWithWebIdentity(args: AssumeRoleWithWebIdentityCommandInput, options: __HttpHandlerOptions, cb: (err: any, data?: AssumeRoleWithWebIdentityCommandOutput) => void): void;
}
/**
 * <fullname>Security Token Service</fullname>
 *          <p>Security Token Service (STS) enables you to request temporary, limited-privilege
 *       credentials for users. This guide provides descriptions of the STS API. For
 *       more information about using this service, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp.html">Temporary Security Credentials</a>.</p>
 * @public
 */
export declare class STS extends STSClient implements STS {
}

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/submodules/sts/STSClient.d.ts

```typescript
import { HostHeaderInputConfig, HostHeaderResolvedConfig } from "@aws-sdk/middleware-host-header";
import { UserAgentInputConfig, UserAgentResolvedConfig } from "@aws-sdk/middleware-user-agent";
import { RegionInputConfig, RegionResolvedConfig } from "@smithy/config-resolver";
import { EndpointInputConfig, EndpointResolvedConfig } from "@smithy/middleware-endpoint";
import { RetryInputConfig, RetryResolvedConfig } from "@smithy/middleware-retry";
import { HttpHandlerUserInput as __HttpHandlerUserInput } from "@smithy/protocol-http";
import { Client as __Client, DefaultsMode as __DefaultsMode, SmithyConfiguration as __SmithyConfiguration, SmithyResolvedConfiguration as __SmithyResolvedConfiguration } from "@smithy/smithy-client";
import { AwsCredentialIdentityProvider, BodyLengthCalculator as __BodyLengthCalculator, CheckOptionalClientConfig as __CheckOptionalClientConfig, ChecksumConstructor as __ChecksumConstructor, Decoder as __Decoder, Encoder as __Encoder, HashConstructor as __HashConstructor, HttpHandlerOptions as __HttpHandlerOptions, Logger as __Logger, Provider as __Provider, Provider, StreamCollector as __StreamCollector, UrlParser as __UrlParser, UserAgent as __UserAgent } from "@smithy/types";
import { HttpAuthSchemeInputConfig, HttpAuthSchemeResolvedConfig } from "./auth/httpAuthSchemeProvider";
import { AssumeRoleCommandInput, AssumeRoleCommandOutput } from "./commands/AssumeRoleCommand";
import { AssumeRoleWithWebIdentityCommandInput, AssumeRoleWithWebIdentityCommandOutput } from "./commands/AssumeRoleWithWebIdentityCommand";
import { ClientInputEndpointParameters, ClientResolvedEndpointParameters, EndpointParameters } from "./endpoint/EndpointParameters";
import { RuntimeExtension, RuntimeExtensionsConfig } from "./runtimeExtensions";
export { __Client };
/**
 * @public
 */
export type ServiceInputTypes = AssumeRoleCommandInput | AssumeRoleWithWebIdentityCommandInput;
/**
 * @public
 */
export type ServiceOutputTypes = AssumeRoleCommandOutput | AssumeRoleWithWebIdentityCommandOutput;
/**
 * @public
 */
export interface ClientDefaults extends Partial<__SmithyConfiguration<__HttpHandlerOptions>> {
    /**
     * The HTTP handler to use or its constructor options. Fetch in browser and Https in Nodejs.
     */
    requestHandler?: __HttpHandlerUserInput;
    /**
     * A constructor for a class implementing the {@link @smithy/types#ChecksumConstructor} interface
     * that computes the SHA-256 HMAC or checksum of a string or binary buffer.
     * @internal
     */
    sha256?: __ChecksumConstructor | __HashConstructor;
    /**
     * The function that will be used to convert strings into HTTP endpoints.
     * @internal
     */
    urlParser?: __UrlParser;
    /**
     * A function that can calculate the length of a request body.
     * @internal
     */
    bodyLengthChecker?: __BodyLengthCalculator;
    /**
     * A function that converts a stream into an array of bytes.
     * @internal
     */
    streamCollector?: __StreamCollector;
    /**
     * The function that will be used to convert a base64-encoded string to a byte array.
     * @internal
     */
    base64Decoder?: __Decoder;
    /**
     * The function that will be used to convert binary data to a base64-encoded string.
     * @internal
     */
    base64Encoder?: __Encoder;
    /**
     * The function that will be used to convert a UTF8-encoded string to a byte array.
     * @internal
     */
    utf8Decoder?: __Decoder;
    /**
     * The function that will be used to convert binary data to a UTF-8 encoded string.
     * @internal
     */
    utf8Encoder?: __Encoder;
    /**
     * The runtime environment.
     * @internal
     */
    runtime?: string;
    /**
     * Disable dynamically changing the endpoint of the client based on the hostPrefix
     * trait of an operation.
     */
    disableHostPrefix?: boolean;
    /**
     * Unique service identifier.
     * @internal
     */
    serviceId?: string;
    /**
     * Enables IPv6/IPv4 dualstack endpoint.
     */
    useDualstackEndpoint?: boolean | __Provider<boolean>;
    /**
     * Enables FIPS compatible endpoints.
     */
    useFipsEndpoint?: boolean | __Provider<boolean>;
    /**
     * The AWS region to which this client will send requests
     */
    region?: string | __Provider<string>;
    /**
     * Setting a client profile is similar to setting a value for the
     * AWS_PROFILE environment variable. Setting a profile on a client
     * in code only affects the single client instance, unlike AWS_PROFILE.
     *
     * When set, and only for environments where an AWS configuration
     * file exists, fields configurable by this file will be retrieved
     * from the specified profile within that file.
     * Conflicting code configuration and environment variables will
     * still have higher priority.
     *
     * For client credential resolution that involves checking the AWS
     * configuration file, the client's profile (this value) will be
     * used unless a different profile is set in the credential
     * provider options.
     *
     */
    profile?: string;
    /**
     * The provider populating default tracking information to be sent with `user-agent`, `x-amz-user-agent` header
     * @internal
     */
    defaultUserAgentProvider?: Provider<__UserAgent>;
    /**
     * Default credentials provider; Not available in browser runtime.
     * @deprecated
     * @internal
     */
    credentialDefaultProvider?: (input: any) => AwsCredentialIdentityProvider;
    /**
     * Value for how many times a request will be made at most in case of retry.
     */
    maxAttempts?: number | __Provider<number>;
    /**
     * Specifies which retry algorithm to use.
     * @see https://docs.aws.amazon.com/AWSJavaScriptSDK/v3/latest/Package/-smithy-util-retry/Enum/RETRY_MODES/
     *
     */
    retryMode?: string | __Provider<string>;
    /**
     * Optional logger for logging debug/info/warn/error.
     */
    logger?: __Logger;
    /**
     * Optional extensions
     */
    extensions?: RuntimeExtension[];
    /**
     * The {@link @smithy/smithy-client#DefaultsMode} that will be used to determine how certain default configuration options are resolved in the SDK.
     */
    defaultsMode?: __DefaultsMode | __Provider<__DefaultsMode>;
}
/**
 * @public
 */
export type STSClientConfigType = Partial<__SmithyConfiguration<__HttpHandlerOptions>> & ClientDefaults & UserAgentInputConfig & RetryInputConfig & RegionInputConfig & HostHeaderInputConfig & EndpointInputConfig<EndpointParameters> & HttpAuthSchemeInputConfig & ClientInputEndpointParameters;
/**
 * @public
 *
 *  The configuration interface of STSClient class constructor that set the region, credentials and other options.
 */
export interface STSClientConfig extends STSClientConfigType {
}
/**
 * @public
 */
export type STSClientResolvedConfigType = __SmithyResolvedConfiguration<__HttpHandlerOptions> & Required<ClientDefaults> & RuntimeExtensionsConfig & UserAgentResolvedConfig & RetryResolvedConfig & RegionResolvedConfig & HostHeaderResolvedConfig & EndpointResolvedConfig<EndpointParameters> & HttpAuthSchemeResolvedConfig & ClientResolvedEndpointParameters;
/**
 * @public
 *
 *  The resolved configuration interface of STSClient class. This is resolved and normalized from the {@link STSClientConfig | constructor configuration interface}.
 */
export interface STSClientResolvedConfig extends STSClientResolvedConfigType {
}
/**
 * <fullname>Security Token Service</fullname>
 *          <p>Security Token Service (STS) enables you to request temporary, limited-privilege
 *       credentials for users. This guide provides descriptions of the STS API. For
 *       more information about using this service, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp.html">Temporary Security Credentials</a>.</p>
 * @public
 */
export declare class STSClient extends __Client<__HttpHandlerOptions, ServiceInputTypes, ServiceOutputTypes, STSClientResolvedConfig> {
    /**
     * The resolved configuration of STSClient class. This is resolved and normalized from the {@link STSClientConfig | constructor configuration interface}.
     */
    readonly config: STSClientResolvedConfig;
    constructor(...[configuration]: __CheckOptionalClientConfig<STSClientConfig>);
    /**
     * Destroy underlying resources, like sockets. It's usually not necessary to do this.
     * However in Node.js, it's best to explicitly shut down the client's agent when it is no longer needed.
     * Otherwise, sockets might stay open for quite a long time before the server terminates them.
     */
    destroy(): void;
}

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/submodules/sts/auth/httpAuthExtensionConfiguration.d.ts

```typescript
import { AwsCredentialIdentity, AwsCredentialIdentityProvider, HttpAuthScheme } from "@smithy/types";
import { STSHttpAuthSchemeProvider } from "./httpAuthSchemeProvider";
/**
 * @internal
 */
export interface HttpAuthExtensionConfiguration {
    setHttpAuthScheme(httpAuthScheme: HttpAuthScheme): void;
    httpAuthSchemes(): HttpAuthScheme[];
    setHttpAuthSchemeProvider(httpAuthSchemeProvider: STSHttpAuthSchemeProvider): void;
    httpAuthSchemeProvider(): STSHttpAuthSchemeProvider;
    setCredentials(credentials: AwsCredentialIdentity | AwsCredentialIdentityProvider): void;
    credentials(): AwsCredentialIdentity | AwsCredentialIdentityProvider | undefined;
}
/**
 * @internal
 */
export type HttpAuthRuntimeConfig = Partial<{
    httpAuthSchemes: HttpAuthScheme[];
    httpAuthSchemeProvider: STSHttpAuthSchemeProvider;
    credentials: AwsCredentialIdentity | AwsCredentialIdentityProvider;
}>;
/**
 * @internal
 */
export declare const getHttpAuthExtensionConfiguration: (runtimeConfig: HttpAuthRuntimeConfig) => HttpAuthExtensionConfiguration;
/**
 * @internal
 */
export declare const resolveHttpAuthRuntimeConfig: (config: HttpAuthExtensionConfiguration) => HttpAuthRuntimeConfig;

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/submodules/sts/auth/httpAuthSchemeProvider.d.ts

```typescript
import { AwsSdkSigV4AuthInputConfig, AwsSdkSigV4AuthResolvedConfig, AwsSdkSigV4PreviouslyResolved } from "@aws-sdk/core";
import { Client, HandlerExecutionContext, HttpAuthScheme, HttpAuthSchemeParameters, HttpAuthSchemeParametersProvider, HttpAuthSchemeProvider, Provider } from "@smithy/types";
import { STSClientResolvedConfig } from "../STSClient";
/**
 * @internal
 */
export interface STSHttpAuthSchemeParameters extends HttpAuthSchemeParameters {
    region?: string;
}
/**
 * @internal
 */
export interface STSHttpAuthSchemeParametersProvider extends HttpAuthSchemeParametersProvider<STSClientResolvedConfig, HandlerExecutionContext, STSHttpAuthSchemeParameters, object> {
}
/**
 * @internal
 */
export declare const defaultSTSHttpAuthSchemeParametersProvider: (config: STSClientResolvedConfig, context: HandlerExecutionContext, input: object) => Promise<STSHttpAuthSchemeParameters>;
/**
 * @internal
 */
export interface STSHttpAuthSchemeProvider extends HttpAuthSchemeProvider<STSHttpAuthSchemeParameters> {
}
/**
 * @internal
 */
export declare const defaultSTSHttpAuthSchemeProvider: STSHttpAuthSchemeProvider;
export interface StsAuthInputConfig {
}
export interface StsAuthResolvedConfig {
    /**
     * Reference to STSClient class constructor.
     * @internal
     */
    stsClientCtor: new (clientConfig: any) => Client<any, any, any>;
}
export declare const resolveStsAuthConfig: <T>(input: T & StsAuthInputConfig) => T & StsAuthResolvedConfig;
/**
 * @internal
 */
export interface HttpAuthSchemeInputConfig extends StsAuthInputConfig, AwsSdkSigV4AuthInputConfig {
    /**
     * A comma-separated list of case-sensitive auth scheme names.
     * An auth scheme name is a fully qualified auth scheme ID with the namespace prefix trimmed.
     * For example, the auth scheme with ID aws.auth#sigv4 is named sigv4.
     * @public
     */
    authSchemePreference?: string[] | Provider<string[]>;
    /**
     * Configuration of HttpAuthSchemes for a client which provides default identity providers and signers per auth scheme.
     * @internal
     */
    httpAuthSchemes?: HttpAuthScheme[];
    /**
     * Configuration of an HttpAuthSchemeProvider for a client which resolves which HttpAuthScheme to use.
     * @internal
     */
    httpAuthSchemeProvider?: STSHttpAuthSchemeProvider;
}
/**
 * @internal
 */
export interface HttpAuthSchemeResolvedConfig extends StsAuthResolvedConfig, AwsSdkSigV4AuthResolvedConfig {
    /**
     * A comma-separated list of case-sensitive auth scheme names.
     * An auth scheme name is a fully qualified auth scheme ID with the namespace prefix trimmed.
     * For example, the auth scheme with ID aws.auth#sigv4 is named sigv4.
     * @public
     */
    readonly authSchemePreference: Provider<string[]>;
    /**
     * Configuration of HttpAuthSchemes for a client which provides default identity providers and signers per auth scheme.
     * @internal
     */
    readonly httpAuthSchemes: HttpAuthScheme[];
    /**
     * Configuration of an HttpAuthSchemeProvider for a client which resolves which HttpAuthScheme to use.
     * @internal
     */
    readonly httpAuthSchemeProvider: STSHttpAuthSchemeProvider;
}
/**
 * @internal
 */
export declare const resolveHttpAuthSchemeConfig: <T>(config: T & HttpAuthSchemeInputConfig & AwsSdkSigV4PreviouslyResolved) => T & HttpAuthSchemeResolvedConfig;

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/submodules/sts/commands/AssumeRoleCommand.d.ts

```typescript
import { Command as $Command } from "@smithy/smithy-client";
import { MetadataBearer as __MetadataBearer } from "@smithy/types";
import { AssumeRoleRequest, AssumeRoleResponse } from "../models/models_0";
import { ServiceInputTypes, ServiceOutputTypes, STSClientResolvedConfig } from "../STSClient";
/**
 * @public
 */
export type { __MetadataBearer };
export { $Command };
/**
 * @public
 *
 * The input for {@link AssumeRoleCommand}.
 */
export interface AssumeRoleCommandInput extends AssumeRoleRequest {
}
/**
 * @public
 *
 * The output of {@link AssumeRoleCommand}.
 */
export interface AssumeRoleCommandOutput extends AssumeRoleResponse, __MetadataBearer {
}
declare const AssumeRoleCommand_base: {
    new (input: AssumeRoleCommandInput): import("@smithy/smithy-client").CommandImpl<AssumeRoleCommandInput, AssumeRoleCommandOutput, STSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes>;
    new (input: AssumeRoleCommandInput): import("@smithy/smithy-client").CommandImpl<AssumeRoleCommandInput, AssumeRoleCommandOutput, STSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes>;
    getEndpointParameterInstructions(): import("@smithy/middleware-endpoint").EndpointParameterInstructions;
};
/**
 * <p>Returns a set of temporary security credentials that you can use to access Amazon Web Services
 *          resources. These temporary credentials consist of an access key ID, a secret access key,
 *          and a security token. Typically, you use <code>AssumeRole</code> within your account or for
 *          cross-account access. For a comparison of <code>AssumeRole</code> with other API operations
 *          that produce temporary credentials, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_request.html">Requesting Temporary Security
 *             Credentials</a> and <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_sts-comparison.html">Compare STS
 *             credentials</a> in the <i>IAM User Guide</i>.</p>
 *          <p>
 *             <b>Permissions</b>
 *          </p>
 *          <p>The temporary security credentials created by <code>AssumeRole</code> can be used to
 *          make API calls to any Amazon Web Services service with the following exception: You cannot call the
 *          Amazon Web Services STS <code>GetFederationToken</code> or <code>GetSessionToken</code> API
 *          operations.</p>
 *          <p>(Optional) You can pass inline or managed session policies to this operation. You can
 *          pass a single JSON policy document to use as an inline session policy. You can also specify
 *          up to 10 managed policy Amazon Resource Names (ARNs) to use as managed session policies.
 *          The plaintext that you use for both inline and managed session policies can't exceed 2,048
 *          characters. Passing policies to this operation returns new
 *          temporary credentials. The resulting session's permissions are the intersection of the
 *          role's identity-based policy and the session policies. You can use the role's temporary
 *          credentials in subsequent Amazon Web Services API calls to access resources in the account that owns
 *          the role. You cannot use session policies to grant more permissions than those allowed
 *          by the identity-based policy of the role that is being assumed. For more information, see
 *             <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">Session
 *             Policies</a> in the <i>IAM User Guide</i>.</p>
 *          <p>When you create a role, you create two policies: a role trust policy that specifies
 *             <i>who</i> can assume the role, and a permissions policy that specifies
 *             <i>what</i> can be done with the role. You specify the trusted principal
 *          that is allowed to assume the role in the role trust policy.</p>
 *          <p>To assume a role from a different account, your Amazon Web Services account must be trusted by the
 *          role. The trust relationship is defined in the role's trust policy when the role is
 *          created. That trust policy states which accounts are allowed to delegate that access to
 *          users in the account. </p>
 *          <p>A user who wants to access a role in a different account must also have permissions that
 *          are delegated from the account administrator. The administrator must attach a policy that
 *          allows the user to call <code>AssumeRole</code> for the ARN of the role in the other
 *          account.</p>
 *          <p>To allow a user to assume a role in the same account, you can do either of the
 *          following:</p>
 *          <ul>
 *             <li>
 *                <p>Attach a policy to the user that allows the user to call <code>AssumeRole</code>
 *                (as long as the role's trust policy trusts the account).</p>
 *             </li>
 *             <li>
 *                <p>Add the user as a principal directly in the role's trust policy.</p>
 *             </li>
 *          </ul>
 *          <p>You can do either because the roles trust policy acts as an IAM resource-based
 *          policy. When a resource-based policy grants access to a principal in the same account, no
 *          additional identity-based policy is required. For more information about trust policies and
 *          resource-based policies, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html">IAM Policies</a> in the
 *             <i>IAM User Guide</i>.</p>
 *          <p>
 *             <b>Tags</b>
 *          </p>
 *          <p>(Optional) You can pass tag key-value pairs to your session. These tags are called
 *          session tags. For more information about session tags, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_session-tags.html">Passing Session Tags in STS</a> in the
 *             <i>IAM User Guide</i>.</p>
 *          <p>An administrator must grant you the permissions necessary to pass session tags. The
 *          administrator can also create granular permissions to allow you to pass only specific
 *          session tags. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/tutorial_attribute-based-access-control.html">Tutorial: Using Tags
 *             for Attribute-Based Access Control</a> in the
 *          <i>IAM User Guide</i>.</p>
 *          <p>You can set the session tags as transitive. Transitive tags persist during role
 *          chaining. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_session-tags.html#id_session-tags_role-chaining">Chaining Roles
 *             with Session Tags</a> in the <i>IAM User Guide</i>.</p>
 *          <p>
 *             <b>Using MFA with AssumeRole</b>
 *          </p>
 *          <p>(Optional) You can include multi-factor authentication (MFA) information when you call
 *             <code>AssumeRole</code>. This is useful for cross-account scenarios to ensure that the
 *          user that assumes the role has been authenticated with an Amazon Web Services MFA device. In that
 *          scenario, the trust policy of the role being assumed includes a condition that tests for
 *          MFA authentication. If the caller does not include valid MFA information, the request to
 *          assume the role is denied. The condition in a trust policy that tests for MFA
 *          authentication might look like the following example.</p>
 *          <p>
 *             <code>"Condition": \{"Bool": \{"aws:MultiFactorAuthPresent": true\}\}</code>
 *          </p>
 *          <p>For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/MFAProtectedAPI.html">Configuring MFA-Protected API Access</a>
 *          in the <i>IAM User Guide</i> guide.</p>
 *          <p>To use MFA with <code>AssumeRole</code>, you pass values for the
 *             <code>SerialNumber</code> and <code>TokenCode</code> parameters. The
 *             <code>SerialNumber</code> value identifies the user's hardware or virtual MFA device.
 *          The <code>TokenCode</code> is the time-based one-time password (TOTP) that the MFA device
 *          produces. </p>
 * @example
 * Use a bare-bones client and the command you need to make an API call.
 * ```javascript
 * import { STSClient, AssumeRoleCommand } from "@aws-sdk/client-sts"; // ES Modules import
 * // const { STSClient, AssumeRoleCommand } = require("@aws-sdk/client-sts"); // CommonJS import
 * // import type { STSClientConfig } from "@aws-sdk/client-sts";
 * const config = {}; // type is STSClientConfig
 * const client = new STSClient(config);
 * const input = { // AssumeRoleRequest
 *   RoleArn: "STRING_VALUE", // required
 *   RoleSessionName: "STRING_VALUE", // required
 *   PolicyArns: [ // policyDescriptorListType
 *     { // PolicyDescriptorType
 *       arn: "STRING_VALUE",
 *     },
 *   ],
 *   Policy: "STRING_VALUE",
 *   DurationSeconds: Number("int"),
 *   Tags: [ // tagListType
 *     { // Tag
 *       Key: "STRING_VALUE", // required
 *       Value: "STRING_VALUE", // required
 *     },
 *   ],
 *   TransitiveTagKeys: [ // tagKeyListType
 *     "STRING_VALUE",
 *   ],
 *   ExternalId: "STRING_VALUE",
 *   SerialNumber: "STRING_VALUE",
 *   TokenCode: "STRING_VALUE",
 *   SourceIdentity: "STRING_VALUE",
 *   ProvidedContexts: [ // ProvidedContextsListType
 *     { // ProvidedContext
 *       ProviderArn: "STRING_VALUE",
 *       ContextAssertion: "STRING_VALUE",
 *     },
 *   ],
 * };
 * const command = new AssumeRoleCommand(input);
 * const response = await client.send(command);
 * // { // AssumeRoleResponse
 * //   Credentials: { // Credentials
 * //     AccessKeyId: "STRING_VALUE", // required
 * //     SecretAccessKey: "STRING_VALUE", // required
 * //     SessionToken: "STRING_VALUE", // required
 * //     Expiration: new Date("TIMESTAMP"), // required
 * //   },
 * //   AssumedRoleUser: { // AssumedRoleUser
 * //     AssumedRoleId: "STRING_VALUE", // required
 * //     Arn: "STRING_VALUE", // required
 * //   },
 * //   PackedPolicySize: Number("int"),
 * //   SourceIdentity: "STRING_VALUE",
 * // };
 *
 * ```
 *
 * @param AssumeRoleCommandInput - {@link AssumeRoleCommandInput}
 * @returns {@link AssumeRoleCommandOutput}
 * @see {@link AssumeRoleCommandInput} for command's `input` shape.
 * @see {@link AssumeRoleCommandOutput} for command's `response` shape.
 * @see {@link STSClientResolvedConfig | config} for STSClient's `config` shape.
 *
 * @throws {@link ExpiredTokenException} (client fault)
 *  <p>The web identity token that was passed is expired or is not valid. Get a new identity
 *             token from the identity provider and then retry the request.</p>
 *
 * @throws {@link MalformedPolicyDocumentException} (client fault)
 *  <p>The request was rejected because the policy document was malformed. The error message
 *             describes the specific error.</p>
 *
 * @throws {@link PackedPolicyTooLargeException} (client fault)
 *  <p>The request was rejected because the total packed size of the session policies and
 *             session tags combined was too large. An Amazon Web Services conversion compresses the session policy
 *             document, session policy ARNs, and session tags into a packed binary format that has a
 *             separate limit. The error message indicates by percentage how close the policies and
 *             tags are to the upper size limit. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_session-tags.html">Passing Session Tags in STS</a> in
 *             the <i>IAM User Guide</i>.</p>
 *          <p>You could receive this error even though you meet other defined session policy and
 *             session tag limits. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-quotas.html#reference_iam-limits-entity-length">IAM and STS Entity Character Limits</a> in the <i>IAM User
 *                 Guide</i>.</p>
 *
 * @throws {@link RegionDisabledException} (client fault)
 *  <p>STS is not activated in the requested region for the account that is being asked to
 *             generate credentials. The account administrator must use the IAM console to activate
 *             STS in that region. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_enable-regions.html">Activating and
 *                 Deactivating STS in an Amazon Web Services Region</a> in the <i>IAM User
 *                 Guide</i>.</p>
 *
 * @throws {@link STSServiceException}
 * <p>Base exception class for all service exceptions from STS service.</p>
 *
 *
 * @example To assume a role
 * ```javascript
 * //
 * const input = {
 *   ExternalId: "123ABC",
 *   Policy: `{"Version":"2012-10-17","Statement":[{"Sid":"Stmt1","Effect":"Allow","Action":"s3:ListAllMyBuckets","Resource":"*"}]}`,
 *   RoleArn: "arn:aws:iam::123456789012:role/demo",
 *   RoleSessionName: "testAssumeRoleSession",
 *   Tags: [
 *     {
 *       Key: "Project",
 *       Value: "Unicorn"
 *     },
 *     {
 *       Key: "Team",
 *       Value: "Automation"
 *     },
 *     {
 *       Key: "Cost-Center",
 *       Value: "12345"
 *     }
 *   ],
 *   TransitiveTagKeys: [
 *     "Project",
 *     "Cost-Center"
 *   ]
 * };
 * const command = new AssumeRoleCommand(input);
 * const response = await client.send(command);
 * /* response is
 * {
 *   AssumedRoleUser: {
 *     Arn: "arn:aws:sts::123456789012:assumed-role/demo/Bob",
 *     AssumedRoleId: "ARO123EXAMPLE123:Bob"
 *   },
 *   Credentials: {
 *     AccessKeyId: "AKIAIOSFODNN7EXAMPLE",
 *     Expiration: "2011-07-15T23:28:33.359Z",
 *     SecretAccessKey: "wJalrXUtnFEMI/K7MDENG/bPxRfiCYzEXAMPLEKEY",
 *     SessionToken: "AQoDYXdzEPT//////////wEXAMPLEtc764bNrC9SAPBSM22wDOk4x4HIZ8j4FZTwdQWLWsKWHGBuFqwAeMicRXmxfpSPfIeoIYRqTflfKD8YUuwthAx7mSEI/qkPpKPi/kMcGdQrmGdeehM4IC1NtBmUpp2wUE8phUZampKsburEDy0KPkyQDYwT7WZ0wq5VSXDvp75YU9HFvlRd8Tx6q6fE8YQcHNVXAkiY9q6d+xo0rKwT38xVqr7ZD0u0iPPkUL64lIZbqBAz+scqKmlzm8FDrypNC9Yjc8fPOLn9FX9KSYvKTr4rvx3iSIlTJabIQwj2ICCR/oLxBA=="
 *   },
 *   PackedPolicySize: 8
 * }
 * *\/
 * ```
 *
 * @public
 */
export declare class AssumeRoleCommand extends AssumeRoleCommand_base {
    /** @internal type navigation helper, not in runtime. */
    protected static __types: {
        api: {
            input: AssumeRoleRequest;
            output: AssumeRoleResponse;
        };
        sdk: {
            input: AssumeRoleCommandInput;
            output: AssumeRoleCommandOutput;
        };
    };
}

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/submodules/sts/commands/AssumeRoleWithWebIdentityCommand.d.ts

```typescript
import { Command as $Command } from "@smithy/smithy-client";
import { MetadataBearer as __MetadataBearer } from "@smithy/types";
import { AssumeRoleWithWebIdentityRequest, AssumeRoleWithWebIdentityResponse } from "../models/models_0";
import { ServiceInputTypes, ServiceOutputTypes, STSClientResolvedConfig } from "../STSClient";
/**
 * @public
 */
export type { __MetadataBearer };
export { $Command };
/**
 * @public
 *
 * The input for {@link AssumeRoleWithWebIdentityCommand}.
 */
export interface AssumeRoleWithWebIdentityCommandInput extends AssumeRoleWithWebIdentityRequest {
}
/**
 * @public
 *
 * The output of {@link AssumeRoleWithWebIdentityCommand}.
 */
export interface AssumeRoleWithWebIdentityCommandOutput extends AssumeRoleWithWebIdentityResponse, __MetadataBearer {
}
declare const AssumeRoleWithWebIdentityCommand_base: {
    new (input: AssumeRoleWithWebIdentityCommandInput): import("@smithy/smithy-client").CommandImpl<AssumeRoleWithWebIdentityCommandInput, AssumeRoleWithWebIdentityCommandOutput, STSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes>;
    new (input: AssumeRoleWithWebIdentityCommandInput): import("@smithy/smithy-client").CommandImpl<AssumeRoleWithWebIdentityCommandInput, AssumeRoleWithWebIdentityCommandOutput, STSClientResolvedConfig, ServiceInputTypes, ServiceOutputTypes>;
    getEndpointParameterInstructions(): import("@smithy/middleware-endpoint").EndpointParameterInstructions;
};
/**
 * <p>Returns a set of temporary security credentials for users who have been authenticated in
 *          a mobile or web application with a web identity provider. Example providers include the
 *          OAuth 2.0 providers Login with Amazon and Facebook, or any OpenID Connect-compatible
 *          identity provider such as Google or <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-identity.html">Amazon Cognito federated identities</a>.</p>
 *          <note>
 *             <p>For mobile applications, we recommend that you use Amazon Cognito. You can use Amazon Cognito with the
 *                <a href="http://aws.amazon.com/sdkforios/">Amazon Web Services SDK for iOS Developer Guide</a> and the <a href="http://aws.amazon.com/sdkforandroid/">Amazon Web Services SDK for Android Developer Guide</a> to uniquely
 *             identify a user. You can also supply the user with a consistent identity throughout the
 *             lifetime of an application.</p>
 *             <p>To learn more about Amazon Cognito, see <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-identity.html">Amazon Cognito identity
 *                pools</a> in <i>Amazon Cognito Developer Guide</i>.</p>
 *          </note>
 *          <p>Calling <code>AssumeRoleWithWebIdentity</code> does not require the use of Amazon Web Services
 *          security credentials. Therefore, you can distribute an application (for example, on mobile
 *          devices) that requests temporary security credentials without including long-term Amazon Web Services
 *          credentials in the application. You also don't need to deploy server-based proxy services
 *          that use long-term Amazon Web Services credentials. Instead, the identity of the caller is validated by
 *          using a token from the web identity provider. For a comparison of
 *             <code>AssumeRoleWithWebIdentity</code> with the other API operations that produce
 *          temporary credentials, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_request.html">Requesting Temporary Security
 *             Credentials</a> and <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_sts-comparison.html">Compare STS
 *             credentials</a> in the <i>IAM User Guide</i>.</p>
 *          <p>The temporary security credentials returned by this API consist of an access key ID, a
 *          secret access key, and a security token. Applications can use these temporary security
 *          credentials to sign calls to Amazon Web Services service API operations.</p>
 *          <p>
 *             <b>Session Duration</b>
 *          </p>
 *          <p>By default, the temporary security credentials created by
 *             <code>AssumeRoleWithWebIdentity</code> last for one hour. However, you can use the
 *          optional <code>DurationSeconds</code> parameter to specify the duration of your session.
 *          You can provide a value from 900 seconds (15 minutes) up to the maximum session duration
 *          setting for the role. This setting can have a value from 1 hour to 12 hours. To learn how
 *          to view the maximum value for your role, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_update-role-settings.html#id_roles_update-session-duration">Update the maximum session duration for a role </a> in the
 *             <i>IAM User Guide</i>. The maximum session duration limit applies when
 *          you use the <code>AssumeRole*</code> API operations or the <code>assume-role*</code> CLI
 *          commands. However the limit does not apply when you use those operations to create a
 *          console URL. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use.html">Using IAM Roles</a> in the
 *             <i>IAM User Guide</i>. </p>
 *          <p>
 *             <b>Permissions</b>
 *          </p>
 *          <p>The temporary security credentials created by <code>AssumeRoleWithWebIdentity</code> can
 *          be used to make API calls to any Amazon Web Services service with the following exception: you cannot
 *          call the STS <code>GetFederationToken</code> or <code>GetSessionToken</code> API
 *          operations.</p>
 *          <p>(Optional) You can pass inline or managed <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">session policies</a> to
 *          this operation. You can pass a single JSON policy document to use as an inline session
 *          policy. You can also specify up to 10 managed policy Amazon Resource Names (ARNs) to use as
 *          managed session policies. The plaintext that you use for both inline and managed session
 *          policies can't exceed 2,048 characters. Passing policies to this operation returns new
 *          temporary credentials. The resulting session's permissions are the intersection of the
 *          role's identity-based policy and the session policies. You can use the role's temporary
 *          credentials in subsequent Amazon Web Services API calls to access resources in the account that owns
 *          the role. You cannot use session policies to grant more permissions than those allowed
 *          by the identity-based policy of the role that is being assumed. For more information, see
 *             <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">Session
 *             Policies</a> in the <i>IAM User Guide</i>.</p>
 *          <p>
 *             <b>Tags</b>
 *          </p>
 *          <p>(Optional) You can configure your IdP to pass attributes into your web identity token as
 *          session tags. Each session tag consists of a key name and an associated value. For more
 *          information about session tags, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_session-tags.html">Passing Session Tags in STS</a> in the
 *             <i>IAM User Guide</i>.</p>
 *          <p>You can pass up to 50 session tags. The plaintext session tag keys cant exceed 128
 *          characters and the values cant exceed 256 characters. For these and additional limits, see
 *             <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-limits.html#reference_iam-limits-entity-length">IAM
 *             and STS Character Limits</a> in the <i>IAM User Guide</i>.</p>
 *          <note>
 *             <p>An Amazon Web Services conversion compresses the passed inline session policy, managed policy ARNs,
 *             and session tags into a packed binary format that has a separate limit. Your request can
 *             fail for this limit even if your plaintext meets the other requirements. The
 *                <code>PackedPolicySize</code> response element indicates by percentage how close the
 *             policies and tags for your request are to the upper size limit.</p>
 *          </note>
 *          <p>You can pass a session tag with the same key as a tag that is attached to the role. When
 *          you do, the session tag overrides the role tag with the same key.</p>
 *          <p>An administrator must grant you the permissions necessary to pass session tags. The
 *          administrator can also create granular permissions to allow you to pass only specific
 *          session tags. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/tutorial_attribute-based-access-control.html">Tutorial: Using Tags
 *             for Attribute-Based Access Control</a> in the
 *          <i>IAM User Guide</i>.</p>
 *          <p>You can set the session tags as transitive. Transitive tags persist during role
 *          chaining. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_session-tags.html#id_session-tags_role-chaining">Chaining Roles
 *             with Session Tags</a> in the <i>IAM User Guide</i>.</p>
 *          <p>
 *             <b>Identities</b>
 *          </p>
 *          <p>Before your application can call <code>AssumeRoleWithWebIdentity</code>, you must have
 *          an identity token from a supported identity provider and create a role that the application
 *          can assume. The role that your application assumes must trust the identity provider that is
 *          associated with the identity token. In other words, the identity provider must be specified
 *          in the role's trust policy. </p>
 *          <important>
 *             <p>Calling <code>AssumeRoleWithWebIdentity</code> can result in an entry in your
 *             CloudTrail logs. The entry includes the <a href="http://openid.net/specs/openid-connect-core-1_0.html#Claims">Subject</a> of
 *             the provided web identity token. We recommend that you avoid using any personally
 *             identifiable information (PII) in this field. For example, you could instead use a GUID
 *             or a pairwise identifier, as <a href="http://openid.net/specs/openid-connect-core-1_0.html#SubjectIDTypes">suggested
 *                in the OIDC specification</a>.</p>
 *          </important>
 *          <p>For more information about how to use OIDC federation and the
 *             <code>AssumeRoleWithWebIdentity</code> API, see the following resources: </p>
 *          <ul>
 *             <li>
 *                <p>
 *                   <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_oidc_manual.html">Using Web Identity Federation API Operations for Mobile Apps</a> and <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_request.html#api_assumerolewithwebidentity">Federation Through a Web-based Identity Provider</a>. </p>
 *             </li>
 *             <li>
 *                <p>
 *                   <a href="http://aws.amazon.com/sdkforios/">Amazon Web Services SDK for iOS Developer Guide</a> and <a href="http://aws.amazon.com/sdkforandroid/">Amazon Web Services SDK for Android Developer Guide</a>. These toolkits
 *                contain sample apps that show how to invoke the identity providers. The toolkits then
 *                show how to use the information from these providers to get and use temporary
 *                security credentials. </p>
 *             </li>
 *          </ul>
 * @example
 * Use a bare-bones client and the command you need to make an API call.
 * ```javascript
 * import { STSClient, AssumeRoleWithWebIdentityCommand } from "@aws-sdk/client-sts"; // ES Modules import
 * // const { STSClient, AssumeRoleWithWebIdentityCommand } = require("@aws-sdk/client-sts"); // CommonJS import
 * // import type { STSClientConfig } from "@aws-sdk/client-sts";
 * const config = {}; // type is STSClientConfig
 * const client = new STSClient(config);
 * const input = { // AssumeRoleWithWebIdentityRequest
 *   RoleArn: "STRING_VALUE", // required
 *   RoleSessionName: "STRING_VALUE", // required
 *   WebIdentityToken: "STRING_VALUE", // required
 *   ProviderId: "STRING_VALUE",
 *   PolicyArns: [ // policyDescriptorListType
 *     { // PolicyDescriptorType
 *       arn: "STRING_VALUE",
 *     },
 *   ],
 *   Policy: "STRING_VALUE",
 *   DurationSeconds: Number("int"),
 * };
 * const command = new AssumeRoleWithWebIdentityCommand(input);
 * const response = await client.send(command);
 * // { // AssumeRoleWithWebIdentityResponse
 * //   Credentials: { // Credentials
 * //     AccessKeyId: "STRING_VALUE", // required
 * //     SecretAccessKey: "STRING_VALUE", // required
 * //     SessionToken: "STRING_VALUE", // required
 * //     Expiration: new Date("TIMESTAMP"), // required
 * //   },
 * //   SubjectFromWebIdentityToken: "STRING_VALUE",
 * //   AssumedRoleUser: { // AssumedRoleUser
 * //     AssumedRoleId: "STRING_VALUE", // required
 * //     Arn: "STRING_VALUE", // required
 * //   },
 * //   PackedPolicySize: Number("int"),
 * //   Provider: "STRING_VALUE",
 * //   Audience: "STRING_VALUE",
 * //   SourceIdentity: "STRING_VALUE",
 * // };
 *
 * ```
 *
 * @param AssumeRoleWithWebIdentityCommandInput - {@link AssumeRoleWithWebIdentityCommandInput}
 * @returns {@link AssumeRoleWithWebIdentityCommandOutput}
 * @see {@link AssumeRoleWithWebIdentityCommandInput} for command's `input` shape.
 * @see {@link AssumeRoleWithWebIdentityCommandOutput} for command's `response` shape.
 * @see {@link STSClientResolvedConfig | config} for STSClient's `config` shape.
 *
 * @throws {@link ExpiredTokenException} (client fault)
 *  <p>The web identity token that was passed is expired or is not valid. Get a new identity
 *             token from the identity provider and then retry the request.</p>
 *
 * @throws {@link IDPCommunicationErrorException} (client fault)
 *  <p>The request could not be fulfilled because the identity provider (IDP) that was asked
 *             to verify the incoming identity token could not be reached. This is often a transient
 *             error caused by network conditions. Retry the request a limited number of times so that
 *             you don't exceed the request rate. If the error persists, the identity provider might be
 *             down or not responding.</p>
 *
 * @throws {@link IDPRejectedClaimException} (client fault)
 *  <p>The identity provider (IdP) reported that authentication failed. This might be because
 *             the claim is invalid.</p>
 *          <p>If this error is returned for the <code>AssumeRoleWithWebIdentity</code> operation, it
 *             can also mean that the claim has expired or has been explicitly revoked. </p>
 *
 * @throws {@link InvalidIdentityTokenException} (client fault)
 *  <p>The web identity token that was passed could not be validated by Amazon Web Services. Get a new
 *             identity token from the identity provider and then retry the request.</p>
 *
 * @throws {@link MalformedPolicyDocumentException} (client fault)
 *  <p>The request was rejected because the policy document was malformed. The error message
 *             describes the specific error.</p>
 *
 * @throws {@link PackedPolicyTooLargeException} (client fault)
 *  <p>The request was rejected because the total packed size of the session policies and
 *             session tags combined was too large. An Amazon Web Services conversion compresses the session policy
 *             document, session policy ARNs, and session tags into a packed binary format that has a
 *             separate limit. The error message indicates by percentage how close the policies and
 *             tags are to the upper size limit. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_session-tags.html">Passing Session Tags in STS</a> in
 *             the <i>IAM User Guide</i>.</p>
 *          <p>You could receive this error even though you meet other defined session policy and
 *             session tag limits. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-quotas.html#reference_iam-limits-entity-length">IAM and STS Entity Character Limits</a> in the <i>IAM User
 *                 Guide</i>.</p>
 *
 * @throws {@link RegionDisabledException} (client fault)
 *  <p>STS is not activated in the requested region for the account that is being asked to
 *             generate credentials. The account administrator must use the IAM console to activate
 *             STS in that region. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_enable-regions.html">Activating and
 *                 Deactivating STS in an Amazon Web Services Region</a> in the <i>IAM User
 *                 Guide</i>.</p>
 *
 * @throws {@link STSServiceException}
 * <p>Base exception class for all service exceptions from STS service.</p>
 *
 *
 * @example To assume a role as an OpenID Connect-federated user
 * ```javascript
 * //
 * const input = {
 *   DurationSeconds: 3600,
 *   Policy: `{"Version":"2012-10-17","Statement":[{"Sid":"Stmt1","Effect":"Allow","Action":"s3:ListAllMyBuckets","Resource":"*"}]}`,
 *   ProviderId: "www.amazon.com",
 *   RoleArn: "arn:aws:iam::123456789012:role/FederatedWebIdentityRole",
 *   RoleSessionName: "app1",
 *   WebIdentityToken: "Atza%7CIQEBLjAsAhRFiXuWpUXuRvQ9PZL3GMFcYevydwIUFAHZwXZXXXXXXXXJnrulxKDHwy87oGKPznh0D6bEQZTSCzyoCtL_8S07pLpr0zMbn6w1lfVZKNTBdDansFBmtGnIsIapjI6xKR02Yc_2bQ8LZbUXSGm6Ry6_BG7PrtLZtj_dfCTj92xNGed-CrKqjG7nPBjNIL016GGvuS5gSvPRUxWES3VYfm1wl7WTI7jn-Pcb6M-buCgHhFOzTQxod27L9CqnOLio7N3gZAGpsp6n1-AJBOCJckcyXe2c6uD0srOJeZlKUm2eTDVMf8IehDVI0r1QOnTV6KzzAI3OY87Vd_cVMQ"
 * };
 * const command = new AssumeRoleWithWebIdentityCommand(input);
 * const response = await client.send(command);
 * /* response is
 * {
 *   AssumedRoleUser: {
 *     Arn: "arn:aws:sts::123456789012:assumed-role/FederatedWebIdentityRole/app1",
 *     AssumedRoleId: "AROACLKWSDQRAOEXAMPLE:app1"
 *   },
 *   Audience: "client.5498841531868486423.1548@apps.example.com",
 *   Credentials: {
 *     AccessKeyId: "AKIAIOSFODNN7EXAMPLE",
 *     Expiration: "2014-10-24T23:00:23Z",
 *     SecretAccessKey: "wJalrXUtnFEMI/K7MDENG/bPxRfiCYzEXAMPLEKEY",
 *     SessionToken: "AQoDYXdzEE0a8ANXXXXXXXXNO1ewxE5TijQyp+IEXAMPLE"
 *   },
 *   PackedPolicySize: 123,
 *   Provider: "www.amazon.com",
 *   SubjectFromWebIdentityToken: "amzn1.account.AF6RHO7KZU5XRVQJGXK6HEXAMPLE"
 * }
 * *\/
 * ```
 *
 * @public
 */
export declare class AssumeRoleWithWebIdentityCommand extends AssumeRoleWithWebIdentityCommand_base {
    /** @internal type navigation helper, not in runtime. */
    protected static __types: {
        api: {
            input: AssumeRoleWithWebIdentityRequest;
            output: AssumeRoleWithWebIdentityResponse;
        };
        sdk: {
            input: AssumeRoleWithWebIdentityCommandInput;
            output: AssumeRoleWithWebIdentityCommandOutput;
        };
    };
}

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/submodules/sts/commands/index.d.ts

```typescript
export * from "./AssumeRoleCommand";
export * from "./AssumeRoleWithWebIdentityCommand";

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/submodules/sts/defaultRoleAssumers.d.ts

```typescript
import { Pluggable } from "@smithy/types";
import { DefaultCredentialProvider, RoleAssumer, RoleAssumerWithWebIdentity, STSRoleAssumerOptions } from "./defaultStsRoleAssumers";
import { ServiceInputTypes, ServiceOutputTypes } from "./STSClient";
/**
 * The default role assumer that used by credential providers when sts:AssumeRole API is needed.
 */
export declare const getDefaultRoleAssumer: (stsOptions?: STSRoleAssumerOptions, stsPlugins?: Pluggable<ServiceInputTypes, ServiceOutputTypes>[]) => RoleAssumer;
/**
 * The default role assumer that used by credential providers when sts:AssumeRoleWithWebIdentity API is needed.
 */
export declare const getDefaultRoleAssumerWithWebIdentity: (stsOptions?: STSRoleAssumerOptions, stsPlugins?: Pluggable<ServiceInputTypes, ServiceOutputTypes>[]) => RoleAssumerWithWebIdentity;
/**
 * The default credential providers depend STS client to assume role with desired API: sts:assumeRole,
 * sts:assumeRoleWithWebIdentity, etc. This function decorates the default credential provider with role assumers which
 * encapsulates the process of calling STS commands. This can only be imported by AWS client packages to avoid circular
 * dependencies.
 *
 * @internal
 *
 * @deprecated this is no longer needed. Use the defaultProvider directly,
 * which will load STS if needed.
 */
export declare const decorateDefaultCredentialProvider: (provider: DefaultCredentialProvider) => DefaultCredentialProvider;

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/submodules/sts/defaultStsRoleAssumers.d.ts

```typescript
import type { CredentialProviderOptions } from "@aws-sdk/types";
import { AwsCredentialIdentity, Logger, Provider } from "@smithy/types";
import { AssumeRoleCommandInput } from "./commands/AssumeRoleCommand";
import { AssumeRoleWithWebIdentityCommandInput } from "./commands/AssumeRoleWithWebIdentityCommand";
import type { STSClient, STSClientConfig } from "./STSClient";
/**
 * @public
 */
export type STSRoleAssumerOptions = Pick<STSClientConfig, "logger" | "region" | "requestHandler"> & {
    credentialProviderLogger?: Logger;
    parentClientConfig?: CredentialProviderOptions["parentClientConfig"];
};
/**
 * @internal
 */
export type RoleAssumer = (sourceCreds: AwsCredentialIdentity, params: AssumeRoleCommandInput) => Promise<AwsCredentialIdentity>;
/**
 * The default role assumer that used by credential providers when sts:AssumeRole API is needed.
 * @internal
 */
export declare const getDefaultRoleAssumer: (stsOptions: STSRoleAssumerOptions, STSClient: new (options: STSClientConfig) => STSClient) => RoleAssumer;
/**
 * @internal
 */
export type RoleAssumerWithWebIdentity = (params: AssumeRoleWithWebIdentityCommandInput) => Promise<AwsCredentialIdentity>;
/**
 * The default role assumer that used by credential providers when sts:AssumeRoleWithWebIdentity API is needed.
 * @internal
 */
export declare const getDefaultRoleAssumerWithWebIdentity: (stsOptions: STSRoleAssumerOptions, STSClient: new (options: STSClientConfig) => STSClient) => RoleAssumerWithWebIdentity;
/**
 * @internal
 */
export type DefaultCredentialProvider = (input: any) => Provider<AwsCredentialIdentity>;
/**
 * The default credential providers depend STS client to assume role with desired API: sts:assumeRole,
 * sts:assumeRoleWithWebIdentity, etc. This function decorates the default credential provider with role assumers which
 * encapsulates the process of calling STS commands. This can only be imported by AWS client packages to avoid circular
 * dependencies.
 *
 * @internal
 */
export declare const decorateDefaultCredentialProvider: (provider: DefaultCredentialProvider) => DefaultCredentialProvider;

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/submodules/sts/endpoint/EndpointParameters.d.ts

```typescript
import { Endpoint, EndpointParameters as __EndpointParameters, EndpointV2, Provider } from "@smithy/types";
/**
 * @public
 */
export interface ClientInputEndpointParameters {
    region?: string | undefined | Provider<string | undefined>;
    useDualstackEndpoint?: boolean | undefined | Provider<boolean | undefined>;
    useFipsEndpoint?: boolean | undefined | Provider<boolean | undefined>;
    endpoint?: string | Provider<string> | Endpoint | Provider<Endpoint> | EndpointV2 | Provider<EndpointV2>;
    useGlobalEndpoint?: boolean | undefined | Provider<boolean | undefined>;
}
export type ClientResolvedEndpointParameters = Omit<ClientInputEndpointParameters, "endpoint"> & {
    defaultSigningName: string;
};
export declare const resolveClientEndpointParameters: <T>(options: T & ClientInputEndpointParameters) => T & ClientResolvedEndpointParameters;
export declare const commonParams: {
    readonly UseGlobalEndpoint: {
        readonly type: "builtInParams";
        readonly name: "useGlobalEndpoint";
    };
    readonly UseFIPS: {
        readonly type: "builtInParams";
        readonly name: "useFipsEndpoint";
    };
    readonly Endpoint: {
        readonly type: "builtInParams";
        readonly name: "endpoint";
    };
    readonly Region: {
        readonly type: "builtInParams";
        readonly name: "region";
    };
    readonly UseDualStack: {
        readonly type: "builtInParams";
        readonly name: "useDualstackEndpoint";
    };
};
export interface EndpointParameters extends __EndpointParameters {
    Region?: string | undefined;
    UseDualStack?: boolean | undefined;
    UseFIPS?: boolean | undefined;
    Endpoint?: string | undefined;
    UseGlobalEndpoint?: boolean | undefined;
}

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/submodules/sts/endpoint/endpointResolver.d.ts

```typescript
import { EndpointV2, Logger } from "@smithy/types";
import { EndpointParameters } from "./EndpointParameters";
export declare const defaultEndpointResolver: (endpointParams: EndpointParameters, context?: {
    logger?: Logger;
}) => EndpointV2;

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/submodules/sts/endpoint/ruleset.d.ts

```typescript
import { RuleSetObject } from "@smithy/types";
export declare const ruleSet: RuleSetObject;

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/submodules/sts/extensionConfiguration.d.ts

```typescript
import { AwsRegionExtensionConfiguration } from "@aws-sdk/types";
import { HttpHandlerExtensionConfiguration } from "@smithy/protocol-http";
import { DefaultExtensionConfiguration } from "@smithy/types";
import { HttpAuthExtensionConfiguration } from "./auth/httpAuthExtensionConfiguration";
/**
 * @internal
 */
export interface STSExtensionConfiguration extends HttpHandlerExtensionConfiguration, DefaultExtensionConfiguration, AwsRegionExtensionConfiguration, HttpAuthExtensionConfiguration {
}

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/submodules/sts/index.d.ts

```typescript
/**
 * <fullname>Security Token Service</fullname>
 *          <p>Security Token Service (STS) enables you to request temporary, limited-privilege
 *       credentials for users. This guide provides descriptions of the STS API. For
 *       more information about using this service, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp.html">Temporary Security Credentials</a>.</p>
 *
 * @packageDocumentation
 */
export * from "./STSClient";
export * from "./STS";
export { ClientInputEndpointParameters } from "./endpoint/EndpointParameters";
export type { RuntimeExtension } from "./runtimeExtensions";
export type { STSExtensionConfiguration } from "./extensionConfiguration";
export * from "./commands";
export * from "./models";
export * from "./defaultRoleAssumers";
export { STSServiceException } from "./models/STSServiceException";

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/submodules/sts/models/STSServiceException.d.ts

```typescript
import { ServiceException as __ServiceException, ServiceExceptionOptions as __ServiceExceptionOptions } from "@smithy/smithy-client";
export type { __ServiceExceptionOptions };
export { __ServiceException };
/**
 * @public
 *
 * Base exception class for all service exceptions from STS service.
 */
export declare class STSServiceException extends __ServiceException {
    /**
     * @internal
     */
    constructor(options: __ServiceExceptionOptions);
}

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/submodules/sts/models/index.d.ts

```typescript
export * from "./models_0";

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/submodules/sts/models/models_0.d.ts

```typescript
import { ExceptionOptionType as __ExceptionOptionType } from "@smithy/smithy-client";
import { STSServiceException as __BaseException } from "./STSServiceException";
/**
 * <p>The identifiers for the temporary security credentials that the operation
 *          returns.</p>
 * @public
 */
export interface AssumedRoleUser {
    /**
     * <p>A unique identifier that contains the role ID and the role session name of the role that
     *          is being assumed. The role ID is generated by Amazon Web Services when the role is created.</p>
     * @public
     */
    AssumedRoleId: string | undefined;
    /**
     * <p>The ARN of the temporary security credentials that are returned from the <a>AssumeRole</a> action. For more information about ARNs and how to use them in
     *          policies, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html">IAM Identifiers</a> in the
     *             <i>IAM User Guide</i>.</p>
     * @public
     */
    Arn: string | undefined;
}
/**
 * <p>A reference to the IAM managed policy that is passed as a session policy for a role
 *          session or a federated user session.</p>
 * @public
 */
export interface PolicyDescriptorType {
    /**
     * <p>The Amazon Resource Name (ARN) of the IAM managed policy to use as a session policy
     *          for the role. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs) and Amazon Web Services
     *             Service Namespaces</a> in the <i>Amazon Web Services General Reference</i>.</p>
     * @public
     */
    arn?: string | undefined;
}
/**
 * <p>Contains information about the provided context. This includes the signed and encrypted
 *          trusted context assertion and the context provider ARN from which the trusted context
 *          assertion was generated.</p>
 * @public
 */
export interface ProvidedContext {
    /**
     * <p>The context provider ARN from which the trusted context assertion was generated.</p>
     * @public
     */
    ProviderArn?: string | undefined;
    /**
     * <p>The signed and encrypted trusted context assertion generated by the context provider.
     *          The trusted context assertion is signed and encrypted by Amazon Web Services STS.</p>
     * @public
     */
    ContextAssertion?: string | undefined;
}
/**
 * <p>You can pass custom key-value pair attributes when you assume a role or federate a user.
 *          These are called session tags. You can then use the session tags to control access to
 *          resources. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_session-tags.html">Tagging Amazon Web Services STS Sessions</a> in the
 *             <i>IAM User Guide</i>.</p>
 * @public
 */
export interface Tag {
    /**
     * <p>The key for a session tag.</p>
     *          <p>You can pass up to 50 session tags. The plain text session tag keys cant exceed 128
     *          characters. For these and additional limits, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-limits.html#reference_iam-limits-entity-length">IAM
     *             and STS Character Limits</a> in the <i>IAM User Guide</i>.</p>
     * @public
     */
    Key: string | undefined;
    /**
     * <p>The value for a session tag.</p>
     *          <p>You can pass up to 50 session tags. The plain text session tag values cant exceed 256
     *          characters. For these and additional limits, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-limits.html#reference_iam-limits-entity-length">IAM
     *             and STS Character Limits</a> in the <i>IAM User Guide</i>.</p>
     * @public
     */
    Value: string | undefined;
}
/**
 * @public
 */
export interface AssumeRoleRequest {
    /**
     * <p>The Amazon Resource Name (ARN) of the role to assume.</p>
     * @public
     */
    RoleArn: string | undefined;
    /**
     * <p>An identifier for the assumed role session.</p>
     *          <p>Use the role session name to uniquely identify a session when the same role is assumed
     *          by different principals or for different reasons. In cross-account scenarios, the role
     *          session name is visible to, and can be logged by the account that owns the role. The role
     *          session name is also used in the ARN of the assumed role principal. This means that
     *          subsequent cross-account API requests that use the temporary security credentials will
     *          expose the role session name to the external account in their CloudTrail logs.</p>
     *          <p>For security purposes, administrators can view this field in <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/cloudtrail-integration.html#cloudtrail-integration_signin-tempcreds">CloudTrail logs</a> to help identify who performed an action in Amazon Web Services. Your
     *          administrator might require that you specify your user name as the session name when you
     *          assume the role. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_iam-condition-keys.html#ck_rolesessionname">
     *                <code>sts:RoleSessionName</code>
     *             </a>.</p>
     *          <p>The regex used to validate this parameter is a string of characters
     *     consisting of upper- and lower-case alphanumeric characters with no spaces. You can
     *     also include underscores or any of the following characters: =,.@-</p>
     * @public
     */
    RoleSessionName: string | undefined;
    /**
     * <p>The Amazon Resource Names (ARNs) of the IAM managed policies that you want to use as
     *          managed session policies. The policies must exist in the same account as the role.</p>
     *          <p>This parameter is optional. You can provide up to 10 managed policy ARNs. However, the
     *          plaintext that you use for both inline and managed session policies can't exceed 2,048
     *          characters. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs) and Amazon Web Services
     *             Service Namespaces</a> in the Amazon Web Services General Reference.</p>
     *          <note>
     *             <p>An Amazon Web Services conversion compresses the passed inline session policy, managed policy ARNs,
     *             and session tags into a packed binary format that has a separate limit. Your request can
     *             fail for this limit even if your plaintext meets the other requirements. The
     *                <code>PackedPolicySize</code> response element indicates by percentage how close the
     *             policies and tags for your request are to the upper size limit.</p>
     *          </note>
     *          <p>Passing policies to this operation returns new
     *          temporary credentials. The resulting session's permissions are the intersection of the
     *          role's identity-based policy and the session policies. You can use the role's temporary
     *          credentials in subsequent Amazon Web Services API calls to access resources in the account that owns
     *          the role. You cannot use session policies to grant more permissions than those allowed
     *          by the identity-based policy of the role that is being assumed. For more information, see
     *             <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">Session
     *             Policies</a> in the <i>IAM User Guide</i>.</p>
     * @public
     */
    PolicyArns?: PolicyDescriptorType[] | undefined;
    /**
     * <p>An IAM policy in JSON format that you want to use as an inline session policy.</p>
     *          <p>This parameter is optional. Passing policies to this operation returns new
     *          temporary credentials. The resulting session's permissions are the intersection of the
     *          role's identity-based policy and the session policies. You can use the role's temporary
     *          credentials in subsequent Amazon Web Services API calls to access resources in the account that owns
     *          the role. You cannot use session policies to grant more permissions than those allowed
     *          by the identity-based policy of the role that is being assumed. For more information, see
     *             <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">Session
     *             Policies</a> in the <i>IAM User Guide</i>.</p>
     *          <p>The plaintext that you use for both inline and managed session policies can't exceed
     *          2,048 characters. The JSON policy characters can be any ASCII character from the space
     *          character to the end of the valid character list (\u0020 through \u00FF). It can also
     *          include the tab (\u0009), linefeed (\u000A), and carriage return (\u000D)
     *          characters.</p>
     *          <note>
     *             <p>An Amazon Web Services conversion compresses the passed inline session policy, managed policy ARNs,
     *             and session tags into a packed binary format that has a separate limit. Your request can
     *             fail for this limit even if your plaintext meets the other requirements. The
     *                <code>PackedPolicySize</code> response element indicates by percentage how close the
     *             policies and tags for your request are to the upper size limit.</p>
     *          </note>
     *          <p>For more information about role session permissions, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">Session
     *             policies</a>.</p>
     * @public
     */
    Policy?: string | undefined;
    /**
     * <p>The duration, in seconds, of the role session. The value specified can range from 900
     *          seconds (15 minutes) up to the maximum session duration set for the role. The maximum
     *          session duration setting can have a value from 1 hour to 12 hours. If you specify a value
     *          higher than this setting or the administrator setting (whichever is lower), the operation
     *          fails. For example, if you specify a session duration of 12 hours, but your administrator
     *          set the maximum session duration to 6 hours, your operation fails. </p>
     *          <p>Role chaining limits your Amazon Web Services CLI or Amazon Web Services API role session to a maximum of one hour.
     *          When you use the <code>AssumeRole</code> API operation to assume a role, you can specify
     *          the duration of your role session with the <code>DurationSeconds</code> parameter. You can
     *          specify a parameter value of up to 43200 seconds (12 hours), depending on the maximum
     *          session duration setting for your role. However, if you assume a role using role chaining
     *          and provide a <code>DurationSeconds</code> parameter value greater than one hour, the
     *          operation fails. To learn how to view the maximum value for your role, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_update-role-settings.html#id_roles_update-session-duration">Update the maximum session duration for a role</a>.</p>
     *          <p>By default, the value is set to <code>3600</code> seconds. </p>
     *          <note>
     *             <p>The <code>DurationSeconds</code> parameter is separate from the duration of a console
     *             session that you might request using the returned credentials. The request to the
     *             federation endpoint for a console sign-in token takes a <code>SessionDuration</code>
     *             parameter that specifies the maximum length of the console session. For more
     *             information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_enable-console-custom-url.html">Creating a URL
     *                that Enables Federated Users to Access the Amazon Web Services Management Console</a> in the
     *                <i>IAM User Guide</i>.</p>
     *          </note>
     * @public
     */
    DurationSeconds?: number | undefined;
    /**
     * <p>A list of session tags that you want to pass. Each session tag consists of a key name
     *          and an associated value. For more information about session tags, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_session-tags.html">Tagging Amazon Web Services STS
     *             Sessions</a> in the <i>IAM User Guide</i>.</p>
     *          <p>This parameter is optional. You can pass up to 50 session tags. The plaintext session
     *          tag keys cant exceed 128 characters, and the values cant exceed 256 characters. For these
     *          and additional limits, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-limits.html#reference_iam-limits-entity-length">IAM
     *             and STS Character Limits</a> in the <i>IAM User Guide</i>.</p>
     *          <note>
     *             <p>An Amazon Web Services conversion compresses the passed inline session policy, managed policy ARNs,
     *             and session tags into a packed binary format that has a separate limit. Your request can
     *             fail for this limit even if your plaintext meets the other requirements. The
     *                <code>PackedPolicySize</code> response element indicates by percentage how close the
     *             policies and tags for your request are to the upper size limit.</p>
     *          </note>
     *          <p>You can pass a session tag with the same key as a tag that is already attached to the
     *          role. When you do, session tags override a role tag with the same key. </p>
     *          <p>Tag keyvalue pairs are not case sensitive, but case is preserved. This means that you
     *          cannot have separate <code>Department</code> and <code>department</code> tag keys. Assume
     *          that the role has the <code>Department</code>=<code>Marketing</code> tag and you pass the
     *             <code>department</code>=<code>engineering</code> session tag. <code>Department</code>
     *          and <code>department</code> are not saved as separate tags, and the session tag passed in
     *          the request takes precedence over the role tag.</p>
     *          <p>Additionally, if you used temporary credentials to perform this operation, the new
     *          session inherits any transitive session tags from the calling session. If you pass a
     *          session tag with the same key as an inherited tag, the operation fails. To view the
     *          inherited tags for a session, see the CloudTrail logs. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_session-tags.html#id_session-tags_ctlogs">Viewing Session Tags in CloudTrail</a> in the
     *          <i>IAM User Guide</i>.</p>
     * @public
     */
    Tags?: Tag[] | undefined;
    /**
     * <p>A list of keys for session tags that you want to set as transitive. If you set a tag key
     *          as transitive, the corresponding key and value passes to subsequent sessions in a role
     *          chain. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_session-tags.html#id_session-tags_role-chaining">Chaining Roles
     *             with Session Tags</a> in the <i>IAM User Guide</i>.</p>
     *          <p>This parameter is optional. The transitive status of a session tag does not impact its
     *          packed binary size.</p>
     *          <p>If you choose not to specify a transitive tag key, then no tags are passed from this
     *          session to any subsequent sessions.</p>
     * @public
     */
    TransitiveTagKeys?: string[] | undefined;
    /**
     * <p>A unique identifier that might be required when you assume a role in another account. If
     *          the administrator of the account to which the role belongs provided you with an external
     *          ID, then provide that value in the <code>ExternalId</code> parameter. This value can be any
     *          string, such as a passphrase or account number. A cross-account role is usually set up to
     *          trust everyone in an account. Therefore, the administrator of the trusting account might
     *          send an external ID to the administrator of the trusted account. That way, only someone
     *          with the ID can assume the role, rather than everyone in the account. For more information
     *          about the external ID, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-user_externalid.html">How to Use an External ID
     *             When Granting Access to Your Amazon Web Services Resources to a Third Party</a> in the
     *             <i>IAM User Guide</i>.</p>
     *          <p>The regex used to validate this parameter is a string of
     *     characters consisting of upper- and lower-case alphanumeric characters with no spaces.
     *     You can also include underscores or any of the following characters: =,.@:/-</p>
     * @public
     */
    ExternalId?: string | undefined;
    /**
     * <p>The identification number of the MFA device that is associated with the user who is
     *          making the <code>AssumeRole</code> call. Specify this value if the trust policy of the role
     *          being assumed includes a condition that requires MFA authentication. The value is either
     *          the serial number for a hardware device (such as <code>GAHT12345678</code>) or an Amazon
     *          Resource Name (ARN) for a virtual device (such as
     *             <code>arn:aws:iam::123456789012:mfa/user</code>).</p>
     *          <p>The regex used to validate this parameter is a string of characters
     *     consisting of upper- and lower-case alphanumeric characters with no spaces. You can
     *     also include underscores or any of the following characters: =,.@-</p>
     * @public
     */
    SerialNumber?: string | undefined;
    /**
     * <p>The value provided by the MFA device, if the trust policy of the role being assumed
     *          requires MFA. (In other words, if the policy includes a condition that tests for MFA). If
     *          the role being assumed requires MFA and if the <code>TokenCode</code> value is missing or
     *          expired, the <code>AssumeRole</code> call returns an "access denied" error.</p>
     *          <p>The format for this parameter, as described by its regex pattern, is a sequence of six
     *          numeric digits.</p>
     * @public
     */
    TokenCode?: string | undefined;
    /**
     * <p>The source identity specified by the principal that is calling the
     *             <code>AssumeRole</code> operation. The source identity value persists across <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html#iam-term-role-chaining">chained role</a> sessions.</p>
     *          <p>You can require users to specify a source identity when they assume a role. You do this
     *          by using the <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_condition-keys.html#condition-keys-sourceidentity">
     *                <code>sts:SourceIdentity</code>
     *             </a> condition key in a role trust policy. You
     *          can use source identity information in CloudTrail logs to determine who took actions with a
     *          role. You can use the <code>aws:SourceIdentity</code> condition key to further control
     *          access to Amazon Web Services resources based on the value of source identity. For more information about
     *          using source identity, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_control-access_monitor.html">Monitor and control
     *             actions taken with assumed roles</a> in the
     *          <i>IAM User Guide</i>.</p>
     *          <p>The regex used to validate this parameter is a string of characters consisting of upper-
     *          and lower-case alphanumeric characters with no spaces. You can also include underscores or
     *          any of the following characters: +=,.@-. You cannot use a value that begins with the text
     *             <code>aws:</code>. This prefix is reserved for Amazon Web Services internal use.</p>
     * @public
     */
    SourceIdentity?: string | undefined;
    /**
     * <p>A list of previously acquired trusted context assertions in the format of a JSON array.
     *          The trusted context assertion is signed and encrypted by Amazon Web Services STS.</p>
     *          <p>The following is an example of a <code>ProvidedContext</code> value that includes a
     *          single trusted context assertion and the ARN of the context provider from which the trusted
     *          context assertion was generated.</p>
     *          <p>
     *             <code>[\{"ProviderArn":"arn:aws:iam::aws:contextProvider/IdentityCenter","ContextAssertion":"trusted-context-assertion"\}]</code>
     *          </p>
     * @public
     */
    ProvidedContexts?: ProvidedContext[] | undefined;
}
/**
 * <p>Amazon Web Services credentials for API authentication.</p>
 * @public
 */
export interface Credentials {
    /**
     * <p>The access key ID that identifies the temporary security credentials.</p>
     * @public
     */
    AccessKeyId: string | undefined;
    /**
     * <p>The secret access key that can be used to sign requests.</p>
     * @public
     */
    SecretAccessKey: string | undefined;
    /**
     * <p>The token that users must pass to the service API to use the temporary
     *          credentials.</p>
     * @public
     */
    SessionToken: string | undefined;
    /**
     * <p>The date on which the current credentials expire.</p>
     * @public
     */
    Expiration: Date | undefined;
}
/**
 * @internal
 */
export declare const CredentialsFilterSensitiveLog: (obj: Credentials) => any;
/**
 * <p>Contains the response to a successful <a>AssumeRole</a> request, including
 *       temporary Amazon Web Services credentials that can be used to make Amazon Web Services requests. </p>
 * @public
 */
export interface AssumeRoleResponse {
    /**
     * <p>The temporary security credentials, which include an access key ID, a secret access key,
     *          and a security (or session) token.</p>
     *          <note>
     *             <p>The size of the security token that STS API operations return is not fixed. We
     *         strongly recommend that you make no assumptions about the maximum size.</p>
     *          </note>
     * @public
     */
    Credentials?: Credentials | undefined;
    /**
     * <p>The Amazon Resource Name (ARN) and the assumed role ID, which are identifiers that you
     *          can use to refer to the resulting temporary security credentials. For example, you can
     *          reference these credentials as a principal in a resource-based policy by using the ARN or
     *          assumed role ID. The ARN and ID include the <code>RoleSessionName</code> that you specified
     *          when you called <code>AssumeRole</code>. </p>
     * @public
     */
    AssumedRoleUser?: AssumedRoleUser | undefined;
    /**
     * <p>A percentage value that indicates the packed size of the session policies and session
     *       tags combined passed in the request. The request fails if the packed size is greater than 100 percent,
     *       which means the policies and tags exceeded the allowed space.</p>
     * @public
     */
    PackedPolicySize?: number | undefined;
    /**
     * <p>The source identity specified by the principal that is calling the
     *             <code>AssumeRole</code> operation.</p>
     *          <p>You can require users to specify a source identity when they assume a role. You do this
     *          by using the <code>sts:SourceIdentity</code> condition key in a role trust policy. You can
     *          use source identity information in CloudTrail logs to determine who took actions with a role.
     *          You can use the <code>aws:SourceIdentity</code> condition key to further control access to
     *          Amazon Web Services resources based on the value of source identity. For more information about using
     *          source identity, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_control-access_monitor.html">Monitor and control
     *             actions taken with assumed roles</a> in the
     *          <i>IAM User Guide</i>.</p>
     *          <p>The regex used to validate this parameter is a string of characters consisting of upper-
     *          and lower-case alphanumeric characters with no spaces. You can also include underscores or
     *          any of the following characters: =,.@-</p>
     * @public
     */
    SourceIdentity?: string | undefined;
}
/**
 * @internal
 */
export declare const AssumeRoleResponseFilterSensitiveLog: (obj: AssumeRoleResponse) => any;
/**
 * <p>The web identity token that was passed is expired or is not valid. Get a new identity
 *             token from the identity provider and then retry the request.</p>
 * @public
 */
export declare class ExpiredTokenException extends __BaseException {
    readonly name: "ExpiredTokenException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<ExpiredTokenException, __BaseException>);
}
/**
 * <p>The request was rejected because the policy document was malformed. The error message
 *             describes the specific error.</p>
 * @public
 */
export declare class MalformedPolicyDocumentException extends __BaseException {
    readonly name: "MalformedPolicyDocumentException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<MalformedPolicyDocumentException, __BaseException>);
}
/**
 * <p>The request was rejected because the total packed size of the session policies and
 *             session tags combined was too large. An Amazon Web Services conversion compresses the session policy
 *             document, session policy ARNs, and session tags into a packed binary format that has a
 *             separate limit. The error message indicates by percentage how close the policies and
 *             tags are to the upper size limit. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_session-tags.html">Passing Session Tags in STS</a> in
 *             the <i>IAM User Guide</i>.</p>
 *          <p>You could receive this error even though you meet other defined session policy and
 *             session tag limits. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-quotas.html#reference_iam-limits-entity-length">IAM and STS Entity Character Limits</a> in the <i>IAM User
 *                 Guide</i>.</p>
 * @public
 */
export declare class PackedPolicyTooLargeException extends __BaseException {
    readonly name: "PackedPolicyTooLargeException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<PackedPolicyTooLargeException, __BaseException>);
}
/**
 * <p>STS is not activated in the requested region for the account that is being asked to
 *             generate credentials. The account administrator must use the IAM console to activate
 *             STS in that region. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_enable-regions.html">Activating and
 *                 Deactivating STS in an Amazon Web Services Region</a> in the <i>IAM User
 *                 Guide</i>.</p>
 * @public
 */
export declare class RegionDisabledException extends __BaseException {
    readonly name: "RegionDisabledException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<RegionDisabledException, __BaseException>);
}
/**
 * <p>The identity provider (IdP) reported that authentication failed. This might be because
 *             the claim is invalid.</p>
 *          <p>If this error is returned for the <code>AssumeRoleWithWebIdentity</code> operation, it
 *             can also mean that the claim has expired or has been explicitly revoked. </p>
 * @public
 */
export declare class IDPRejectedClaimException extends __BaseException {
    readonly name: "IDPRejectedClaimException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<IDPRejectedClaimException, __BaseException>);
}
/**
 * <p>The web identity token that was passed could not be validated by Amazon Web Services. Get a new
 *             identity token from the identity provider and then retry the request.</p>
 * @public
 */
export declare class InvalidIdentityTokenException extends __BaseException {
    readonly name: "InvalidIdentityTokenException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<InvalidIdentityTokenException, __BaseException>);
}
/**
 * @public
 */
export interface AssumeRoleWithWebIdentityRequest {
    /**
     * <p>The Amazon Resource Name (ARN) of the role that the caller is assuming.</p>
     *          <note>
     *             <p>Additional considerations apply to Amazon Cognito identity pools that assume <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies-cross-account-resource-access.html">cross-account IAM roles</a>. The trust policies of these roles must accept the
     *                <code>cognito-identity.amazonaws.com</code> service principal and must contain the
     *                <code>cognito-identity.amazonaws.com:aud</code> condition key to restrict role
     *             assumption to users from your intended identity pools. A policy that trusts Amazon Cognito
     *             identity pools without this condition creates a risk that a user from an unintended
     *             identity pool can assume the role. For more information, see <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/iam-roles.html#trust-policies"> Trust policies for
     *                IAM roles in Basic (Classic) authentication </a> in the <i>Amazon Cognito
     *                Developer Guide</i>.</p>
     *          </note>
     * @public
     */
    RoleArn: string | undefined;
    /**
     * <p>An identifier for the assumed role session. Typically, you pass the name or identifier
     *          that is associated with the user who is using your application. That way, the temporary
     *          security credentials that your application will use are associated with that user. This
     *          session name is included as part of the ARN and assumed role ID in the
     *             <code>AssumedRoleUser</code> response element.</p>
     *          <p>For security purposes, administrators can view this field in <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/cloudtrail-integration.html#cloudtrail-integration_signin-tempcreds">CloudTrail logs</a> to help identify who performed an action in Amazon Web Services. Your
     *          administrator might require that you specify your user name as the session name when you
     *          assume the role. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_iam-condition-keys.html#ck_rolesessionname">
     *                <code>sts:RoleSessionName</code>
     *             </a>.</p>
     *          <p>The regex used to validate this parameter is a string of characters
     *     consisting of upper- and lower-case alphanumeric characters with no spaces. You can
     *     also include underscores or any of the following characters: =,.@-</p>
     * @public
     */
    RoleSessionName: string | undefined;
    /**
     * <p>The OAuth 2.0 access token or OpenID Connect ID token that is provided by the identity
     *          provider. Your application must get this token by authenticating the user who is using your
     *          application with a web identity provider before the application makes an
     *             <code>AssumeRoleWithWebIdentity</code> call. Timestamps in the token must be formatted
     *          as either an integer or a long integer. Tokens must be signed using either RSA keys (RS256,
     *          RS384, or RS512) or ECDSA keys (ES256, ES384, or ES512).</p>
     * @public
     */
    WebIdentityToken: string | undefined;
    /**
     * <p>The fully qualified host component of the domain name of the OAuth 2.0 identity
     *          provider. Do not specify this value for an OpenID Connect identity provider.</p>
     *          <p>Currently <code>www.amazon.com</code> and <code>graph.facebook.com</code> are the only
     *          supported identity providers for OAuth 2.0 access tokens. Do not include URL schemes and
     *          port numbers.</p>
     *          <p>Do not specify this value for OpenID Connect ID tokens.</p>
     * @public
     */
    ProviderId?: string | undefined;
    /**
     * <p>The Amazon Resource Names (ARNs) of the IAM managed policies that you want to use as
     *          managed session policies. The policies must exist in the same account as the role.</p>
     *          <p>This parameter is optional. You can provide up to 10 managed policy ARNs. However, the
     *          plaintext that you use for both inline and managed session policies can't exceed 2,048
     *          characters. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs) and Amazon Web Services
     *             Service Namespaces</a> in the Amazon Web Services General Reference.</p>
     *          <note>
     *             <p>An Amazon Web Services conversion compresses the passed inline session policy, managed policy ARNs,
     *             and session tags into a packed binary format that has a separate limit. Your request can
     *             fail for this limit even if your plaintext meets the other requirements. The
     *                <code>PackedPolicySize</code> response element indicates by percentage how close the
     *             policies and tags for your request are to the upper size limit.</p>
     *          </note>
     *          <p>Passing policies to this operation returns new
     *          temporary credentials. The resulting session's permissions are the intersection of the
     *          role's identity-based policy and the session policies. You can use the role's temporary
     *          credentials in subsequent Amazon Web Services API calls to access resources in the account that owns
     *          the role. You cannot use session policies to grant more permissions than those allowed
     *          by the identity-based policy of the role that is being assumed. For more information, see
     *             <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">Session
     *             Policies</a> in the <i>IAM User Guide</i>.</p>
     * @public
     */
    PolicyArns?: PolicyDescriptorType[] | undefined;
    /**
     * <p>An IAM policy in JSON format that you want to use as an inline session policy.</p>
     *          <p>This parameter is optional. Passing policies to this operation returns new
     *          temporary credentials. The resulting session's permissions are the intersection of the
     *          role's identity-based policy and the session policies. You can use the role's temporary
     *          credentials in subsequent Amazon Web Services API calls to access resources in the account that owns
     *          the role. You cannot use session policies to grant more permissions than those allowed
     *          by the identity-based policy of the role that is being assumed. For more information, see
     *             <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">Session
     *             Policies</a> in the <i>IAM User Guide</i>.</p>
     *          <p>The plaintext that you use for both inline and managed session policies can't exceed
     *          2,048 characters. The JSON policy characters can be any ASCII character from the space
     *          character to the end of the valid character list (\u0020 through \u00FF). It can also
     *          include the tab (\u0009), linefeed (\u000A), and carriage return (\u000D)
     *          characters.</p>
     *          <p>For more information about role session permissions, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">Session
     *             policies</a>.</p>
     *          <note>
     *             <p>An Amazon Web Services conversion compresses the passed inline session policy, managed policy ARNs,
     *             and session tags into a packed binary format that has a separate limit. Your request can
     *             fail for this limit even if your plaintext meets the other requirements. The
     *                <code>PackedPolicySize</code> response element indicates by percentage how close the
     *             policies and tags for your request are to the upper size limit.</p>
     *          </note>
     * @public
     */
    Policy?: string | undefined;
    /**
     * <p>The duration, in seconds, of the role session. The value can range from 900 seconds (15
     *          minutes) up to the maximum session duration setting for the role. This setting can have a
     *          value from 1 hour to 12 hours. If you specify a value higher than this setting, the
     *          operation fails. For example, if you specify a session duration of 12 hours, but your
     *          administrator set the maximum session duration to 6 hours, your operation fails. To learn
     *          how to view the maximum value for your role, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use.html#id_roles_use_view-role-max-session">View the
     *             Maximum Session Duration Setting for a Role</a> in the
     *             <i>IAM User Guide</i>.</p>
     *          <p>By default, the value is set to <code>3600</code> seconds. </p>
     *          <note>
     *             <p>The <code>DurationSeconds</code> parameter is separate from the duration of a console
     *             session that you might request using the returned credentials. The request to the
     *             federation endpoint for a console sign-in token takes a <code>SessionDuration</code>
     *             parameter that specifies the maximum length of the console session. For more
     *             information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_enable-console-custom-url.html">Creating a URL
     *                that Enables Federated Users to Access the Amazon Web Services Management Console</a> in the
     *                <i>IAM User Guide</i>.</p>
     *          </note>
     * @public
     */
    DurationSeconds?: number | undefined;
}
/**
 * @internal
 */
export declare const AssumeRoleWithWebIdentityRequestFilterSensitiveLog: (obj: AssumeRoleWithWebIdentityRequest) => any;
/**
 * <p>Contains the response to a successful <a>AssumeRoleWithWebIdentity</a>
 *       request, including temporary Amazon Web Services credentials that can be used to make Amazon Web Services requests. </p>
 * @public
 */
export interface AssumeRoleWithWebIdentityResponse {
    /**
     * <p>The temporary security credentials, which include an access key ID, a secret access key,
     *          and a security token.</p>
     *          <note>
     *             <p>The size of the security token that STS API operations return is not fixed. We
     *         strongly recommend that you make no assumptions about the maximum size.</p>
     *          </note>
     * @public
     */
    Credentials?: Credentials | undefined;
    /**
     * <p>The unique user identifier that is returned by the identity provider. This identifier is
     *          associated with the <code>WebIdentityToken</code> that was submitted with the
     *             <code>AssumeRoleWithWebIdentity</code> call. The identifier is typically unique to the
     *          user and the application that acquired the <code>WebIdentityToken</code> (pairwise
     *          identifier). For OpenID Connect ID tokens, this field contains the value returned by the
     *          identity provider as the token's <code>sub</code> (Subject) claim. </p>
     * @public
     */
    SubjectFromWebIdentityToken?: string | undefined;
    /**
     * <p>The Amazon Resource Name (ARN) and the assumed role ID, which are identifiers that you
     *          can use to refer to the resulting temporary security credentials. For example, you can
     *          reference these credentials as a principal in a resource-based policy by using the ARN or
     *          assumed role ID. The ARN and ID include the <code>RoleSessionName</code> that you specified
     *          when you called <code>AssumeRole</code>. </p>
     * @public
     */
    AssumedRoleUser?: AssumedRoleUser | undefined;
    /**
     * <p>A percentage value that indicates the packed size of the session policies and session
     *       tags combined passed in the request. The request fails if the packed size is greater than 100 percent,
     *       which means the policies and tags exceeded the allowed space.</p>
     * @public
     */
    PackedPolicySize?: number | undefined;
    /**
     * <p> The issuing authority of the web identity token presented. For OpenID Connect ID
     *          tokens, this contains the value of the <code>iss</code> field. For OAuth 2.0 access tokens,
     *          this contains the value of the <code>ProviderId</code> parameter that was passed in the
     *             <code>AssumeRoleWithWebIdentity</code> request.</p>
     * @public
     */
    Provider?: string | undefined;
    /**
     * <p>The intended audience (also known as client ID) of the web identity token. This is
     *          traditionally the client identifier issued to the application that requested the web
     *          identity token.</p>
     * @public
     */
    Audience?: string | undefined;
    /**
     * <p>The value of the source identity that is returned in the JSON web token (JWT) from the
     *          identity provider.</p>
     *          <p>You can require users to set a source identity value when they assume a role. You do
     *          this by using the <code>sts:SourceIdentity</code> condition key in a role trust policy.
     *          That way, actions that are taken with the role are associated with that user. After the
     *          source identity is set, the value cannot be changed. It is present in the request for all
     *          actions that are taken by the role and persists across <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html#id_roles_terms-and-concepts">chained role</a>
     *          sessions. You can configure your identity provider to use an attribute associated with your
     *          users, like user name or email, as the source identity when calling
     *             <code>AssumeRoleWithWebIdentity</code>. You do this by adding a claim to the JSON web
     *          token. To learn more about OIDC tokens and claims, see <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-tokens-with-identity-providers.html">Using Tokens with User Pools</a> in the <i>Amazon Cognito Developer Guide</i>.
     *          For more information about using source identity, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_control-access_monitor.html">Monitor and control
     *             actions taken with assumed roles</a> in the
     *          <i>IAM User Guide</i>.</p>
     *          <p>The regex used to validate this parameter is a string of characters
     *     consisting of upper- and lower-case alphanumeric characters with no spaces. You can
     *     also include underscores or any of the following characters: =,.@-</p>
     * @public
     */
    SourceIdentity?: string | undefined;
}
/**
 * @internal
 */
export declare const AssumeRoleWithWebIdentityResponseFilterSensitiveLog: (obj: AssumeRoleWithWebIdentityResponse) => any;
/**
 * <p>The request could not be fulfilled because the identity provider (IDP) that was asked
 *             to verify the incoming identity token could not be reached. This is often a transient
 *             error caused by network conditions. Retry the request a limited number of times so that
 *             you don't exceed the request rate. If the error persists, the identity provider might be
 *             down or not responding.</p>
 * @public
 */
export declare class IDPCommunicationErrorException extends __BaseException {
    readonly name: "IDPCommunicationErrorException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<IDPCommunicationErrorException, __BaseException>);
}

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/submodules/sts/protocols/Aws_query.d.ts

```typescript
import { HttpRequest as __HttpRequest, HttpResponse as __HttpResponse } from "@smithy/protocol-http";
import { SerdeContext as __SerdeContext } from "@smithy/types";
import { AssumeRoleCommandInput, AssumeRoleCommandOutput } from "../commands/AssumeRoleCommand";
import { AssumeRoleWithWebIdentityCommandInput, AssumeRoleWithWebIdentityCommandOutput } from "../commands/AssumeRoleWithWebIdentityCommand";
/**
 * serializeAws_queryAssumeRoleCommand
 */
export declare const se_AssumeRoleCommand: (input: AssumeRoleCommandInput, context: __SerdeContext) => Promise<__HttpRequest>;
/**
 * serializeAws_queryAssumeRoleWithWebIdentityCommand
 */
export declare const se_AssumeRoleWithWebIdentityCommand: (input: AssumeRoleWithWebIdentityCommandInput, context: __SerdeContext) => Promise<__HttpRequest>;
/**
 * deserializeAws_queryAssumeRoleCommand
 */
export declare const de_AssumeRoleCommand: (output: __HttpResponse, context: __SerdeContext) => Promise<AssumeRoleCommandOutput>;
/**
 * deserializeAws_queryAssumeRoleWithWebIdentityCommand
 */
export declare const de_AssumeRoleWithWebIdentityCommand: (output: __HttpResponse, context: __SerdeContext) => Promise<AssumeRoleWithWebIdentityCommandOutput>;

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/submodules/sts/runtimeConfig.browser.d.ts

```typescript
import { FetchHttpHandler as RequestHandler } from "@smithy/fetch-http-handler";
import { STSClientConfig } from "./STSClient";
/**
 * @internal
 */
export declare const getRuntimeConfig: (config: STSClientConfig) => {
    runtime: string;
    defaultsMode: import("@smithy/types").Provider<import("@smithy/smithy-client").ResolvedDefaultsMode>;
    bodyLengthChecker: import("@smithy/types").BodyLengthCalculator;
    credentialDefaultProvider: ((input: any) => import("@smithy/types").AwsCredentialIdentityProvider) | ((_: unknown) => () => Promise<import("@smithy/types").AwsCredentialIdentity>);
    defaultUserAgentProvider: (config?: import("@aws-sdk/util-user-agent-browser").PreviouslyResolved) => Promise<import("@smithy/types").UserAgent>;
    maxAttempts: number | import("@smithy/types").Provider<number>;
    region: string | import("@smithy/types").Provider<any>;
    requestHandler: import("@smithy/protocol-http").HttpHandler<any> | RequestHandler;
    retryMode: string | import("@smithy/types").Provider<string>;
    sha256: import("@smithy/types").HashConstructor;
    streamCollector: import("@smithy/types").StreamCollector;
    useDualstackEndpoint: (boolean | import("@smithy/types").Provider<boolean>) & (boolean | import("@smithy/types").Provider<boolean | undefined>);
    useFipsEndpoint: (boolean | import("@smithy/types").Provider<boolean>) & (boolean | import("@smithy/types").Provider<boolean | undefined>);
    apiVersion: string;
    cacheMiddleware?: boolean | undefined;
    urlParser: import("@smithy/types").UrlParser;
    base64Decoder: import("@smithy/types").Decoder;
    base64Encoder: (_input: Uint8Array | string) => string;
    utf8Decoder: import("@smithy/types").Decoder;
    utf8Encoder: (input: Uint8Array | string) => string;
    disableHostPrefix: boolean;
    serviceId: string;
    profile?: string;
    logger: import("@smithy/types").Logger;
    extensions: import("./runtimeExtensions").RuntimeExtension[];
    customUserAgent?: string | import("@smithy/types").UserAgent;
    userAgentAppId?: string | undefined | import("@smithy/types").Provider<string | undefined>;
    retryStrategy?: import("@smithy/types").RetryStrategy | import("@smithy/types").RetryStrategyV2;
    endpoint?: ((string | import("@smithy/types").Endpoint | import("@smithy/types").Provider<import("@smithy/types").Endpoint> | import("@smithy/types").EndpointV2 | import("@smithy/types").Provider<import("@smithy/types").EndpointV2>) & (string | import("@smithy/types").Provider<string> | import("@smithy/types").Endpoint | import("@smithy/types").Provider<import("@smithy/types").Endpoint> | import("@smithy/types").EndpointV2 | import("@smithy/types").Provider<import("@smithy/types").EndpointV2>)) | undefined;
    endpointProvider: (params: import("./endpoint/EndpointParameters").EndpointParameters, context?: {
        logger?: import("@smithy/types").Logger;
    }) => import("@smithy/types").EndpointV2;
    tls?: boolean;
    serviceConfiguredEndpoint?: never;
    authSchemePreference?: string[] | import("@smithy/types").Provider<string[]>;
    httpAuthSchemes: import("@smithy/types").HttpAuthScheme[] | ({
        schemeId: string;
        identityProvider: (ipc: import("@smithy/types").IdentityProviderConfig) => import("@smithy/types").IdentityProvider<import("@smithy/types").Identity> | undefined;
        signer: import("@aws-sdk/core").AwsSdkSigV4Signer;
    } | {
        schemeId: string;
        identityProvider: (ipc: import("@smithy/types").IdentityProviderConfig) => import("@smithy/types").IdentityProvider<import("@smithy/types").Identity> | (() => Promise<{}>);
        signer: import("@smithy/core").NoAuthSigner;
    })[];
    httpAuthSchemeProvider: import("./auth/httpAuthSchemeProvider").STSHttpAuthSchemeProvider;
    credentials?: import("@smithy/types").AwsCredentialIdentity | import("@smithy/types").AwsCredentialIdentityProvider;
    signer?: import("@smithy/types").RequestSigner | ((authScheme?: import("@smithy/types").AuthScheme) => Promise<import("@smithy/types").RequestSigner>);
    signingEscapePath?: boolean;
    systemClockOffset?: number;
    signingRegion?: string;
    signerConstructor?: new (options: import("@smithy/signature-v4").SignatureV4Init & import("@smithy/signature-v4").SignatureV4CryptoInit) => import("@smithy/types").RequestSigner;
    useGlobalEndpoint?: boolean | undefined | import("@smithy/types").Provider<boolean | undefined>;
};

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/submodules/sts/runtimeConfig.d.ts

```typescript
import { NoAuthSigner } from "@smithy/core";
import { NodeHttpHandler as RequestHandler } from "@smithy/node-http-handler";
import { IdentityProviderConfig } from "@smithy/types";
import { STSClientConfig } from "./STSClient";
/**
 * @internal
 */
export declare const getRuntimeConfig: (config: STSClientConfig) => {
    runtime: string;
    defaultsMode: import("@smithy/types").Provider<import("@smithy/smithy-client").ResolvedDefaultsMode>;
    authSchemePreference: string[] | import("@smithy/types").Provider<string[]>;
    bodyLengthChecker: import("@smithy/types").BodyLengthCalculator;
    defaultUserAgentProvider: (config?: import("@aws-sdk/util-user-agent-node").PreviouslyResolved) => Promise<import("@smithy/types").UserAgent>;
    httpAuthSchemes: import("@smithy/types").HttpAuthScheme[] | {
        schemeId: string;
        identityProvider: (ipc: IdentityProviderConfig) => import("@smithy/types").IdentityProvider<import("@smithy/types").Identity> | (() => Promise<{}>);
        signer: NoAuthSigner;
    }[];
    maxAttempts: number | import("@smithy/types").Provider<number>;
    region: string | import("@smithy/types").Provider<string>;
    requestHandler: RequestHandler | import("@smithy/protocol-http").HttpHandler<any>;
    retryMode: string | import("@smithy/types").Provider<string>;
    sha256: import("@smithy/types").HashConstructor;
    streamCollector: import("@smithy/types").StreamCollector;
    useDualstackEndpoint: boolean | import("@smithy/types").Provider<boolean>;
    useFipsEndpoint: boolean | import("@smithy/types").Provider<boolean>;
    userAgentAppId: string | import("@smithy/types").Provider<string | undefined>;
    apiVersion: string;
    cacheMiddleware?: boolean | undefined;
    urlParser: import("@smithy/types").UrlParser;
    base64Decoder: import("@smithy/types").Decoder;
    base64Encoder: (_input: Uint8Array | string) => string;
    utf8Decoder: import("@smithy/types").Decoder;
    utf8Encoder: (input: Uint8Array | string) => string;
    disableHostPrefix: boolean;
    serviceId: string;
    profile?: string;
    credentialDefaultProvider?: (input: any) => import("@smithy/types").AwsCredentialIdentityProvider;
    logger: import("@smithy/types").Logger;
    extensions: import("./runtimeExtensions").RuntimeExtension[];
    customUserAgent?: string | import("@smithy/types").UserAgent;
    retryStrategy?: import("@smithy/types").RetryStrategy | import("@smithy/types").RetryStrategyV2;
    endpoint?: ((string | import("@smithy/types").Endpoint | import("@smithy/types").Provider<import("@smithy/types").Endpoint> | import("@smithy/types").EndpointV2 | import("@smithy/types").Provider<import("@smithy/types").EndpointV2>) & (string | import("@smithy/types").Provider<string> | import("@smithy/types").Endpoint | import("@smithy/types").Provider<import("@smithy/types").Endpoint> | import("@smithy/types").EndpointV2 | import("@smithy/types").Provider<import("@smithy/types").EndpointV2>)) | undefined;
    endpointProvider: (params: import("./endpoint/EndpointParameters").EndpointParameters, context?: {
        logger?: import("@smithy/types").Logger;
    }) => import("@smithy/types").EndpointV2;
    tls?: boolean;
    serviceConfiguredEndpoint?: never;
    httpAuthSchemeProvider: import("./auth/httpAuthSchemeProvider").STSHttpAuthSchemeProvider;
    credentials?: import("@smithy/types").AwsCredentialIdentity | import("@smithy/types").AwsCredentialIdentityProvider;
    signer?: import("@smithy/types").RequestSigner | ((authScheme?: import("@smithy/types").AuthScheme) => Promise<import("@smithy/types").RequestSigner>);
    signingEscapePath?: boolean;
    systemClockOffset?: number;
    signingRegion?: string;
    signerConstructor?: new (options: import("@smithy/signature-v4").SignatureV4Init & import("@smithy/signature-v4").SignatureV4CryptoInit) => import("@smithy/types").RequestSigner;
    useGlobalEndpoint?: boolean | undefined | import("@smithy/types").Provider<boolean | undefined>;
};

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/submodules/sts/runtimeConfig.native.d.ts

```typescript
import { STSClientConfig } from "./STSClient";
/**
 * @internal
 */
export declare const getRuntimeConfig: (config: STSClientConfig) => {
    runtime: string;
    sha256: import("@smithy/types").HashConstructor;
    requestHandler: import("@smithy/types").NodeHttpHandlerOptions | import("@smithy/types").FetchHttpHandlerOptions | Record<string, unknown> | import("@smithy/protocol-http").HttpHandler<any> | import("@smithy/fetch-http-handler").FetchHttpHandler;
    apiVersion: string;
    cacheMiddleware?: boolean;
    urlParser: import("@smithy/types").UrlParser;
    bodyLengthChecker: import("@smithy/types").BodyLengthCalculator;
    streamCollector: import("@smithy/types").StreamCollector;
    base64Decoder: import("@smithy/types").Decoder;
    base64Encoder: (_input: Uint8Array | string) => string;
    utf8Decoder: import("@smithy/types").Decoder;
    utf8Encoder: (input: Uint8Array | string) => string;
    disableHostPrefix: boolean;
    serviceId: string;
    useDualstackEndpoint: (boolean | import("@smithy/types").Provider<boolean>) & (boolean | import("@smithy/types").Provider<boolean | undefined>);
    useFipsEndpoint: (boolean | import("@smithy/types").Provider<boolean>) & (boolean | import("@smithy/types").Provider<boolean | undefined>);
    region: string | import("@smithy/types").Provider<any>;
    profile?: string;
    defaultUserAgentProvider: (config?: import("@aws-sdk/util-user-agent-browser").PreviouslyResolved) => Promise<import("@smithy/types").UserAgent>;
    credentialDefaultProvider: ((input: any) => import("@smithy/types").AwsCredentialIdentityProvider) | ((_: unknown) => () => Promise<import("@smithy/types").AwsCredentialIdentity>);
    maxAttempts: number | import("@smithy/types").Provider<number>;
    retryMode: string | import("@smithy/types").Provider<string>;
    logger: import("@smithy/types").Logger;
    extensions: import("./runtimeExtensions").RuntimeExtension[];
    defaultsMode: import("@smithy/smithy-client").DefaultsMode | import("@smithy/types").Provider<import("@smithy/smithy-client").DefaultsMode>;
    customUserAgent?: string | import("@smithy/types").UserAgent;
    userAgentAppId?: string | undefined | import("@smithy/types").Provider<string | undefined>;
    retryStrategy?: import("@smithy/types").RetryStrategy | import("@smithy/types").RetryStrategyV2;
    endpoint?: ((string | import("@smithy/types").Endpoint | import("@smithy/types").Provider<import("@smithy/types").Endpoint> | import("@smithy/types").EndpointV2 | import("@smithy/types").Provider<import("@smithy/types").EndpointV2>) & (string | import("@smithy/types").Provider<string> | import("@smithy/types").Endpoint | import("@smithy/types").Provider<import("@smithy/types").Endpoint> | import("@smithy/types").EndpointV2 | import("@smithy/types").Provider<import("@smithy/types").EndpointV2>)) | undefined;
    endpointProvider: (params: import("./endpoint/EndpointParameters").EndpointParameters, context?: {
        logger?: import("@smithy/types").Logger;
    }) => import("@smithy/types").EndpointV2;
    tls?: boolean;
    serviceConfiguredEndpoint?: never;
    authSchemePreference?: string[] | import("@smithy/types").Provider<string[]>;
    httpAuthSchemes: import("@smithy/types").HttpAuthScheme[] | ({
        schemeId: string;
        identityProvider: (ipc: import("@smithy/types").IdentityProviderConfig) => import("@smithy/types").IdentityProvider<import("@smithy/types").Identity> | undefined;
        signer: import("@aws-sdk/core").AwsSdkSigV4Signer;
    } | {
        schemeId: string;
        identityProvider: (ipc: import("@smithy/types").IdentityProviderConfig) => import("@smithy/types").IdentityProvider<import("@smithy/types").Identity> | (() => Promise<{}>);
        signer: import("@smithy/core").NoAuthSigner;
    })[];
    httpAuthSchemeProvider: import("./auth/httpAuthSchemeProvider").STSHttpAuthSchemeProvider;
    credentials?: import("@smithy/types").AwsCredentialIdentity | import("@smithy/types").AwsCredentialIdentityProvider;
    signer?: import("@smithy/types").RequestSigner | ((authScheme?: import("@smithy/types").AuthScheme) => Promise<import("@smithy/types").RequestSigner>);
    signingEscapePath?: boolean;
    systemClockOffset?: number;
    signingRegion?: string;
    signerConstructor?: new (options: import("@smithy/signature-v4").SignatureV4Init & import("@smithy/signature-v4").SignatureV4CryptoInit) => import("@smithy/types").RequestSigner;
    useGlobalEndpoint?: boolean | undefined | import("@smithy/types").Provider<boolean | undefined>;
};

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/submodules/sts/runtimeConfig.shared.d.ts

```typescript
import { AwsSdkSigV4Signer } from "@aws-sdk/core";
import { NoAuthSigner } from "@smithy/core";
import { IdentityProviderConfig } from "@smithy/types";
import { STSClientConfig } from "./STSClient";
/**
 * @internal
 */
export declare const getRuntimeConfig: (config: STSClientConfig) => {
    apiVersion: string;
    base64Decoder: import("@smithy/types").Decoder;
    base64Encoder: (_input: Uint8Array | string) => string;
    disableHostPrefix: boolean;
    endpointProvider: (params: import("./endpoint/EndpointParameters").EndpointParameters, context?: {
        logger?: import("@smithy/types").Logger;
    }) => import("@smithy/types").EndpointV2;
    extensions: import("./runtimeExtensions").RuntimeExtension[];
    httpAuthSchemeProvider: import("./auth/httpAuthSchemeProvider").STSHttpAuthSchemeProvider;
    httpAuthSchemes: import("@smithy/types").HttpAuthScheme[] | ({
        schemeId: string;
        identityProvider: (ipc: IdentityProviderConfig) => import("@smithy/types").IdentityProvider<import("@smithy/types").Identity> | undefined;
        signer: AwsSdkSigV4Signer;
    } | {
        schemeId: string;
        identityProvider: (ipc: IdentityProviderConfig) => import("@smithy/types").IdentityProvider<import("@smithy/types").Identity> | (() => Promise<{}>);
        signer: NoAuthSigner;
    })[];
    logger: import("@smithy/types").Logger;
    serviceId: string;
    urlParser: import("@smithy/types").UrlParser;
    utf8Decoder: import("@smithy/types").Decoder;
    utf8Encoder: (input: Uint8Array | string) => string;
};

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/submodules/sts/runtimeExtensions.d.ts

```typescript
import { STSExtensionConfiguration } from "./extensionConfiguration";
/**
 * @public
 */
export interface RuntimeExtension {
    configure(extensionConfiguration: STSExtensionConfiguration): void;
}
/**
 * @public
 */
export interface RuntimeExtensionsConfig {
    extensions: RuntimeExtension[];
}
/**
 * @internal
 */
export declare const resolveRuntimeExtensions: (runtimeConfig: any, extensions: RuntimeExtension[]) => any;

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/ts3.4/index.d.ts

```typescript
export {};

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/ts3.4/submodules/sso-oidc/SSOOIDC.d.ts

```typescript
import { HttpHandlerOptions as __HttpHandlerOptions } from "@smithy/types";
import {
  CreateTokenCommandInput,
  CreateTokenCommandOutput,
} from "./commands/CreateTokenCommand";
import { SSOOIDCClient } from "./SSOOIDCClient";
export interface SSOOIDC {
  createToken(
    args: CreateTokenCommandInput,
    options?: __HttpHandlerOptions
  ): Promise<CreateTokenCommandOutput>;
  createToken(
    args: CreateTokenCommandInput,
    cb: (err: any, data?: CreateTokenCommandOutput) => void
  ): void;
  createToken(
    args: CreateTokenCommandInput,
    options: __HttpHandlerOptions,
    cb: (err: any, data?: CreateTokenCommandOutput) => void
  ): void;
}
export declare class SSOOIDC extends SSOOIDCClient implements SSOOIDC {}

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/ts3.4/submodules/sso-oidc/SSOOIDCClient.d.ts

```typescript
import {
  HostHeaderInputConfig,
  HostHeaderResolvedConfig,
} from "@aws-sdk/middleware-host-header";
import {
  UserAgentInputConfig,
  UserAgentResolvedConfig,
} from "@aws-sdk/middleware-user-agent";
import {
  RegionInputConfig,
  RegionResolvedConfig,
} from "@smithy/config-resolver";
import {
  EndpointInputConfig,
  EndpointResolvedConfig,
} from "@smithy/middleware-endpoint";
import {
  RetryInputConfig,
  RetryResolvedConfig,
} from "@smithy/middleware-retry";
import { HttpHandlerUserInput as __HttpHandlerUserInput } from "@smithy/protocol-http";
import {
  Client as __Client,
  DefaultsMode as __DefaultsMode,
  SmithyConfiguration as __SmithyConfiguration,
  SmithyResolvedConfiguration as __SmithyResolvedConfiguration,
} from "@smithy/smithy-client";
import {
  BodyLengthCalculator as __BodyLengthCalculator,
  CheckOptionalClientConfig as __CheckOptionalClientConfig,
  ChecksumConstructor as __ChecksumConstructor,
  Decoder as __Decoder,
  Encoder as __Encoder,
  HashConstructor as __HashConstructor,
  HttpHandlerOptions as __HttpHandlerOptions,
  Logger as __Logger,
  Provider as __Provider,
  Provider,
  StreamCollector as __StreamCollector,
  UrlParser as __UrlParser,
  UserAgent as __UserAgent,
} from "@smithy/types";
import {
  HttpAuthSchemeInputConfig,
  HttpAuthSchemeResolvedConfig,
} from "./auth/httpAuthSchemeProvider";
import {
  CreateTokenCommandInput,
  CreateTokenCommandOutput,
} from "./commands/CreateTokenCommand";
import {
  ClientInputEndpointParameters,
  ClientResolvedEndpointParameters,
  EndpointParameters,
} from "./endpoint/EndpointParameters";
import { RuntimeExtension, RuntimeExtensionsConfig } from "./runtimeExtensions";
export { __Client };
export type ServiceInputTypes = CreateTokenCommandInput;
export type ServiceOutputTypes = CreateTokenCommandOutput;
export interface ClientDefaults
  extends Partial<__SmithyConfiguration<__HttpHandlerOptions>> {
  requestHandler?: __HttpHandlerUserInput;
  sha256?: __ChecksumConstructor | __HashConstructor;
  urlParser?: __UrlParser;
  bodyLengthChecker?: __BodyLengthCalculator;
  streamCollector?: __StreamCollector;
  base64Decoder?: __Decoder;
  base64Encoder?: __Encoder;
  utf8Decoder?: __Decoder;
  utf8Encoder?: __Encoder;
  runtime?: string;
  disableHostPrefix?: boolean;
  serviceId?: string;
  useDualstackEndpoint?: boolean | __Provider<boolean>;
  useFipsEndpoint?: boolean | __Provider<boolean>;
  region?: string | __Provider<string>;
  profile?: string;
  defaultUserAgentProvider?: Provider<__UserAgent>;
  maxAttempts?: number | __Provider<number>;
  retryMode?: string | __Provider<string>;
  logger?: __Logger;
  extensions?: RuntimeExtension[];
  defaultsMode?: __DefaultsMode | __Provider<__DefaultsMode>;
}
export type SSOOIDCClientConfigType = Partial<
  __SmithyConfiguration<__HttpHandlerOptions>
> &
  ClientDefaults &
  UserAgentInputConfig &
  RetryInputConfig &
  RegionInputConfig &
  HostHeaderInputConfig &
  EndpointInputConfig<EndpointParameters> &
  HttpAuthSchemeInputConfig &
  ClientInputEndpointParameters;
export interface SSOOIDCClientConfig extends SSOOIDCClientConfigType {}
export type SSOOIDCClientResolvedConfigType =
  __SmithyResolvedConfiguration<__HttpHandlerOptions> &
    Required<ClientDefaults> &
    RuntimeExtensionsConfig &
    UserAgentResolvedConfig &
    RetryResolvedConfig &
    RegionResolvedConfig &
    HostHeaderResolvedConfig &
    EndpointResolvedConfig<EndpointParameters> &
    HttpAuthSchemeResolvedConfig &
    ClientResolvedEndpointParameters;
export interface SSOOIDCClientResolvedConfig
  extends SSOOIDCClientResolvedConfigType {}
export declare class SSOOIDCClient extends __Client<
  __HttpHandlerOptions,
  ServiceInputTypes,
  ServiceOutputTypes,
  SSOOIDCClientResolvedConfig
> {
  readonly config: SSOOIDCClientResolvedConfig;
  constructor(
    ...[configuration]: __CheckOptionalClientConfig<SSOOIDCClientConfig>
  );
  destroy(): void;
}

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/ts3.4/submodules/sso-oidc/auth/httpAuthExtensionConfiguration.d.ts

```typescript
import {
  AwsCredentialIdentity,
  AwsCredentialIdentityProvider,
  HttpAuthScheme,
} from "@smithy/types";
import { SSOOIDCHttpAuthSchemeProvider } from "./httpAuthSchemeProvider";
export interface HttpAuthExtensionConfiguration {
  setHttpAuthScheme(httpAuthScheme: HttpAuthScheme): void;
  httpAuthSchemes(): HttpAuthScheme[];
  setHttpAuthSchemeProvider(
    httpAuthSchemeProvider: SSOOIDCHttpAuthSchemeProvider
  ): void;
  httpAuthSchemeProvider(): SSOOIDCHttpAuthSchemeProvider;
  setCredentials(
    credentials: AwsCredentialIdentity | AwsCredentialIdentityProvider
  ): void;
  credentials():
    | AwsCredentialIdentity
    | AwsCredentialIdentityProvider
    | undefined;
}
export type HttpAuthRuntimeConfig = Partial<{
  httpAuthSchemes: HttpAuthScheme[];
  httpAuthSchemeProvider: SSOOIDCHttpAuthSchemeProvider;
  credentials: AwsCredentialIdentity | AwsCredentialIdentityProvider;
}>;
export declare const getHttpAuthExtensionConfiguration: (
  runtimeConfig: HttpAuthRuntimeConfig
) => HttpAuthExtensionConfiguration;
export declare const resolveHttpAuthRuntimeConfig: (
  config: HttpAuthExtensionConfiguration
) => HttpAuthRuntimeConfig;

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/ts3.4/submodules/sso-oidc/auth/httpAuthSchemeProvider.d.ts

```typescript
import {
  AwsSdkSigV4AuthInputConfig,
  AwsSdkSigV4AuthResolvedConfig,
  AwsSdkSigV4PreviouslyResolved,
} from "@aws-sdk/core";
import {
  HandlerExecutionContext,
  HttpAuthScheme,
  HttpAuthSchemeParameters,
  HttpAuthSchemeParametersProvider,
  HttpAuthSchemeProvider,
  Provider,
} from "@smithy/types";
import { SSOOIDCClientResolvedConfig } from "../SSOOIDCClient";
export interface SSOOIDCHttpAuthSchemeParameters
  extends HttpAuthSchemeParameters {
  region?: string;
}
export interface SSOOIDCHttpAuthSchemeParametersProvider
  extends HttpAuthSchemeParametersProvider<
    SSOOIDCClientResolvedConfig,
    HandlerExecutionContext,
    SSOOIDCHttpAuthSchemeParameters,
    object
  > {}
export declare const defaultSSOOIDCHttpAuthSchemeParametersProvider: (
  config: SSOOIDCClientResolvedConfig,
  context: HandlerExecutionContext,
  input: object
) => Promise<SSOOIDCHttpAuthSchemeParameters>;
export interface SSOOIDCHttpAuthSchemeProvider
  extends HttpAuthSchemeProvider<SSOOIDCHttpAuthSchemeParameters> {}
export declare const defaultSSOOIDCHttpAuthSchemeProvider: SSOOIDCHttpAuthSchemeProvider;
export interface HttpAuthSchemeInputConfig extends AwsSdkSigV4AuthInputConfig {
  authSchemePreference?: string[] | Provider<string[]>;
  httpAuthSchemes?: HttpAuthScheme[];
  httpAuthSchemeProvider?: SSOOIDCHttpAuthSchemeProvider;
}
export interface HttpAuthSchemeResolvedConfig
  extends AwsSdkSigV4AuthResolvedConfig {
  readonly authSchemePreference: Provider<string[]>;
  readonly httpAuthSchemes: HttpAuthScheme[];
  readonly httpAuthSchemeProvider: SSOOIDCHttpAuthSchemeProvider;
}
export declare const resolveHttpAuthSchemeConfig: <T>(
  config: T & HttpAuthSchemeInputConfig & AwsSdkSigV4PreviouslyResolved
) => T & HttpAuthSchemeResolvedConfig;

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/ts3.4/submodules/sso-oidc/commands/CreateTokenCommand.d.ts

```typescript
import { Command as $Command } from "@smithy/smithy-client";
import { MetadataBearer as __MetadataBearer } from "@smithy/types";
import { CreateTokenRequest, CreateTokenResponse } from "../models/models_0";
import { SSOOIDCClientResolvedConfig } from "../SSOOIDCClient";
export { __MetadataBearer };
export { $Command };
export interface CreateTokenCommandInput extends CreateTokenRequest {}
export interface CreateTokenCommandOutput
  extends CreateTokenResponse,
    __MetadataBearer {}
declare const CreateTokenCommand_base: {
  new (
    input: CreateTokenCommandInput
  ): import("@smithy/smithy-client").CommandImpl<
    CreateTokenCommandInput,
    CreateTokenCommandOutput,
    SSOOIDCClientResolvedConfig,
    CreateTokenCommandInput,
    CreateTokenCommandOutput
  >;
  new (
    input: CreateTokenCommandInput
  ): import("@smithy/smithy-client").CommandImpl<
    CreateTokenCommandInput,
    CreateTokenCommandOutput,
    SSOOIDCClientResolvedConfig,
    CreateTokenCommandInput,
    CreateTokenCommandOutput
  >;
  getEndpointParameterInstructions(): import("@smithy/middleware-endpoint").EndpointParameterInstructions;
};
export declare class CreateTokenCommand extends CreateTokenCommand_base {
  protected static __types: {
    api: {
      input: CreateTokenRequest;
      output: CreateTokenResponse;
    };
    sdk: {
      input: CreateTokenCommandInput;
      output: CreateTokenCommandOutput;
    };
  };
}

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/ts3.4/submodules/sso-oidc/commands/index.d.ts

```typescript
export * from "./CreateTokenCommand";

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/ts3.4/submodules/sso-oidc/endpoint/EndpointParameters.d.ts

```typescript
import {
  Endpoint,
  EndpointParameters as __EndpointParameters,
  EndpointV2,
  Provider,
} from "@smithy/types";
export interface ClientInputEndpointParameters {
  region?: string | undefined | Provider<string | undefined>;
  useDualstackEndpoint?: boolean | undefined | Provider<boolean | undefined>;
  useFipsEndpoint?: boolean | undefined | Provider<boolean | undefined>;
  endpoint?:
    | string
    | Provider<string>
    | Endpoint
    | Provider<Endpoint>
    | EndpointV2
    | Provider<EndpointV2>;
}
export type ClientResolvedEndpointParameters = Pick<
  ClientInputEndpointParameters,
  Exclude<keyof ClientInputEndpointParameters, "endpoint">
> & {
  defaultSigningName: string;
};
export declare const resolveClientEndpointParameters: <T>(
  options: T & ClientInputEndpointParameters
) => T & ClientResolvedEndpointParameters;
export declare const commonParams: {
  readonly UseFIPS: {
    readonly type: "builtInParams";
    readonly name: "useFipsEndpoint";
  };
  readonly Endpoint: {
    readonly type: "builtInParams";
    readonly name: "endpoint";
  };
  readonly Region: {
    readonly type: "builtInParams";
    readonly name: "region";
  };
  readonly UseDualStack: {
    readonly type: "builtInParams";
    readonly name: "useDualstackEndpoint";
  };
};
export interface EndpointParameters extends __EndpointParameters {
  Region?: string | undefined;
  UseDualStack?: boolean | undefined;
  UseFIPS?: boolean | undefined;
  Endpoint?: string | undefined;
}

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/ts3.4/submodules/sso-oidc/endpoint/endpointResolver.d.ts

```typescript
import { EndpointV2, Logger } from "@smithy/types";
import { EndpointParameters } from "./EndpointParameters";
export declare const defaultEndpointResolver: (
  endpointParams: EndpointParameters,
  context?: {
    logger?: Logger;
  }
) => EndpointV2;

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/ts3.4/submodules/sso-oidc/endpoint/ruleset.d.ts

```typescript
import { RuleSetObject } from "@smithy/types";
export declare const ruleSet: RuleSetObject;

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/ts3.4/submodules/sso-oidc/extensionConfiguration.d.ts

```typescript
import { AwsRegionExtensionConfiguration } from "@aws-sdk/types";
import { HttpHandlerExtensionConfiguration } from "@smithy/protocol-http";
import { DefaultExtensionConfiguration } from "@smithy/types";
import { HttpAuthExtensionConfiguration } from "./auth/httpAuthExtensionConfiguration";
export interface SSOOIDCExtensionConfiguration
  extends HttpHandlerExtensionConfiguration,
    DefaultExtensionConfiguration,
    AwsRegionExtensionConfiguration,
    HttpAuthExtensionConfiguration {}

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/ts3.4/submodules/sso-oidc/index.d.ts

```typescript
export * from "./SSOOIDCClient";
export * from "./SSOOIDC";
export { ClientInputEndpointParameters } from "./endpoint/EndpointParameters";
export { RuntimeExtension } from "./runtimeExtensions";
export { SSOOIDCExtensionConfiguration } from "./extensionConfiguration";
export * from "./commands";
export * from "./models";
export { SSOOIDCServiceException } from "./models/SSOOIDCServiceException";

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/ts3.4/submodules/sso-oidc/models/SSOOIDCServiceException.d.ts

```typescript
import {
  ServiceException as __ServiceException,
  ServiceExceptionOptions as __ServiceExceptionOptions,
} from "@smithy/smithy-client";
export { __ServiceExceptionOptions };
export { __ServiceException };
export declare class SSOOIDCServiceException extends __ServiceException {
  constructor(options: __ServiceExceptionOptions);
}

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/ts3.4/submodules/sso-oidc/models/index.d.ts

```typescript
export * from "./models_0";

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/ts3.4/submodules/sso-oidc/models/models_0.d.ts

```typescript
import { ExceptionOptionType as __ExceptionOptionType } from "@smithy/smithy-client";
import { SSOOIDCServiceException as __BaseException } from "./SSOOIDCServiceException";
export declare const AccessDeniedExceptionReason: {
  readonly KMS_ACCESS_DENIED: "KMS_AccessDeniedException";
};
export type AccessDeniedExceptionReason =
  (typeof AccessDeniedExceptionReason)[keyof typeof AccessDeniedExceptionReason];
export declare class AccessDeniedException extends __BaseException {
  readonly name: "AccessDeniedException";
  readonly $fault: "client";
  error?: string | undefined;
  reason?: AccessDeniedExceptionReason | undefined;
  error_description?: string | undefined;
  constructor(
    opts: __ExceptionOptionType<AccessDeniedException, __BaseException>
  );
}
export declare class AuthorizationPendingException extends __BaseException {
  readonly name: "AuthorizationPendingException";
  readonly $fault: "client";
  error?: string | undefined;
  error_description?: string | undefined;
  constructor(
    opts: __ExceptionOptionType<AuthorizationPendingException, __BaseException>
  );
}
export interface CreateTokenRequest {
  clientId: string | undefined;
  clientSecret: string | undefined;
  grantType: string | undefined;
  deviceCode?: string | undefined;
  code?: string | undefined;
  refreshToken?: string | undefined;
  scope?: string[] | undefined;
  redirectUri?: string | undefined;
  codeVerifier?: string | undefined;
}
export declare const CreateTokenRequestFilterSensitiveLog: (
  obj: CreateTokenRequest
) => any;
export interface CreateTokenResponse {
  accessToken?: string | undefined;
  tokenType?: string | undefined;
  expiresIn?: number | undefined;
  refreshToken?: string | undefined;
  idToken?: string | undefined;
}
export declare const CreateTokenResponseFilterSensitiveLog: (
  obj: CreateTokenResponse
) => any;
export declare class ExpiredTokenException extends __BaseException {
  readonly name: "ExpiredTokenException";
  readonly $fault: "client";
  error?: string | undefined;
  error_description?: string | undefined;
  constructor(
    opts: __ExceptionOptionType<ExpiredTokenException, __BaseException>
  );
}
export declare class InternalServerException extends __BaseException {
  readonly name: "InternalServerException";
  readonly $fault: "server";
  error?: string | undefined;
  error_description?: string | undefined;
  constructor(
    opts: __ExceptionOptionType<InternalServerException, __BaseException>
  );
}
export declare class InvalidClientException extends __BaseException {
  readonly name: "InvalidClientException";
  readonly $fault: "client";
  error?: string | undefined;
  error_description?: string | undefined;
  constructor(
    opts: __ExceptionOptionType<InvalidClientException, __BaseException>
  );
}
export declare class InvalidGrantException extends __BaseException {
  readonly name: "InvalidGrantException";
  readonly $fault: "client";
  error?: string | undefined;
  error_description?: string | undefined;
  constructor(
    opts: __ExceptionOptionType<InvalidGrantException, __BaseException>
  );
}
export declare const InvalidRequestExceptionReason: {
  readonly KMS_DISABLED_KEY: "KMS_DisabledException";
  readonly KMS_INVALID_KEY_USAGE: "KMS_InvalidKeyUsageException";
  readonly KMS_INVALID_STATE: "KMS_InvalidStateException";
  readonly KMS_KEY_NOT_FOUND: "KMS_NotFoundException";
};
export type InvalidRequestExceptionReason =
  (typeof InvalidRequestExceptionReason)[keyof typeof InvalidRequestExceptionReason];
export declare class InvalidRequestException extends __BaseException {
  readonly name: "InvalidRequestException";
  readonly $fault: "client";
  error?: string | undefined;
  reason?: InvalidRequestExceptionReason | undefined;
  error_description?: string | undefined;
  constructor(
    opts: __ExceptionOptionType<InvalidRequestException, __BaseException>
  );
}
export declare class InvalidScopeException extends __BaseException {
  readonly name: "InvalidScopeException";
  readonly $fault: "client";
  error?: string | undefined;
  error_description?: string | undefined;
  constructor(
    opts: __ExceptionOptionType<InvalidScopeException, __BaseException>
  );
}
export declare class SlowDownException extends __BaseException {
  readonly name: "SlowDownException";
  readonly $fault: "client";
  error?: string | undefined;
  error_description?: string | undefined;
  constructor(opts: __ExceptionOptionType<SlowDownException, __BaseException>);
}
export declare class UnauthorizedClientException extends __BaseException {
  readonly name: "UnauthorizedClientException";
  readonly $fault: "client";
  error?: string | undefined;
  error_description?: string | undefined;
  constructor(
    opts: __ExceptionOptionType<UnauthorizedClientException, __BaseException>
  );
}
export declare class UnsupportedGrantTypeException extends __BaseException {
  readonly name: "UnsupportedGrantTypeException";
  readonly $fault: "client";
  error?: string | undefined;
  error_description?: string | undefined;
  constructor(
    opts: __ExceptionOptionType<UnsupportedGrantTypeException, __BaseException>
  );
}

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/ts3.4/submodules/sso-oidc/protocols/Aws_restJson1.d.ts

```typescript
import {
  HttpRequest as __HttpRequest,
  HttpResponse as __HttpResponse,
} from "@smithy/protocol-http";
import { SerdeContext as __SerdeContext } from "@smithy/types";
import {
  CreateTokenCommandInput,
  CreateTokenCommandOutput,
} from "../commands/CreateTokenCommand";
export declare const se_CreateTokenCommand: (
  input: CreateTokenCommandInput,
  context: __SerdeContext
) => Promise<__HttpRequest>;
export declare const de_CreateTokenCommand: (
  output: __HttpResponse,
  context: __SerdeContext
) => Promise<CreateTokenCommandOutput>;

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/ts3.4/submodules/sso-oidc/runtimeConfig.browser.d.ts

```typescript
import { FetchHttpHandler as RequestHandler } from "@smithy/fetch-http-handler";
import { SSOOIDCClientConfig } from "./SSOOIDCClient";
export declare const getRuntimeConfig: (config: SSOOIDCClientConfig) => {
  runtime: string;
  defaultsMode: import("@smithy/types").Provider<
    import("@smithy/smithy-client").ResolvedDefaultsMode
  >;
  bodyLengthChecker: import("@smithy/types").BodyLengthCalculator;
  defaultUserAgentProvider: (
    config?: import("@aws-sdk/util-user-agent-browser").PreviouslyResolved
  ) => Promise<import("@smithy/types").UserAgent>;
  maxAttempts: number | import("@smithy/types").Provider<number>;
  region: string | import("@smithy/types").Provider<any>;
  requestHandler:
    | import("@smithy/protocol-http").HttpHandler<any>
    | RequestHandler;
  retryMode: string | import("@smithy/types").Provider<string>;
  sha256: import("@smithy/types").HashConstructor;
  streamCollector: import("@smithy/types").StreamCollector;
  useDualstackEndpoint: (boolean | import("@smithy/types").Provider<boolean>) &
    (boolean | import("@smithy/types").Provider<boolean | undefined>);
  useFipsEndpoint: (boolean | import("@smithy/types").Provider<boolean>) &
    (boolean | import("@smithy/types").Provider<boolean | undefined>);
  apiVersion: string;
  cacheMiddleware?: boolean | undefined;
  urlParser: import("@smithy/types").UrlParser;
  base64Decoder: import("@smithy/types").Decoder;
  base64Encoder: (_input: Uint8Array | string) => string;
  utf8Decoder: import("@smithy/types").Decoder;
  utf8Encoder: (input: Uint8Array | string) => string;
  disableHostPrefix: boolean;
  serviceId: string;
  profile?: string;
  logger: import("@smithy/types").Logger;
  extensions: import("./runtimeExtensions").RuntimeExtension[];
  customUserAgent?: string | import("@smithy/types").UserAgent;
  userAgentAppId?:
    | string
    | undefined
    | import("@smithy/types").Provider<string | undefined>;
  retryStrategy?:
    | import("@smithy/types").RetryStrategy
    | import("@smithy/types").RetryStrategyV2;
  endpoint?:
    | ((
        | string
        | import("@smithy/types").Endpoint
        | import("@smithy/types").Provider<import("@smithy/types").Endpoint>
        | import("@smithy/types").EndpointV2
        | import("@smithy/types").Provider<import("@smithy/types").EndpointV2>
      ) &
        (
          | string
          | import("@smithy/types").Provider<string>
          | import("@smithy/types").Endpoint
          | import("@smithy/types").Provider<import("@smithy/types").Endpoint>
          | import("@smithy/types").EndpointV2
          | import("@smithy/types").Provider<import("@smithy/types").EndpointV2>
        ))
    | undefined;
  endpointProvider: (
    endpointParams: import("./endpoint/EndpointParameters").EndpointParameters,
    context?: {
      logger?: import("@smithy/types").Logger;
    }
  ) => import("@smithy/types").EndpointV2;
  tls?: boolean;
  serviceConfiguredEndpoint?: never;
  authSchemePreference?: string[] | import("@smithy/types").Provider<string[]>;
  httpAuthSchemes:
    | import("@smithy/types").HttpAuthScheme[]
    | (
        | {
            schemeId: string;
            identityProvider: (
              ipc: import("@smithy/types").IdentityProviderConfig
            ) =>
              | import("@smithy/types").IdentityProvider<
                  import("@smithy/types").Identity
                >
              | undefined;
            signer: import("@aws-sdk/core").AwsSdkSigV4Signer;
          }
        | {
            schemeId: string;
            identityProvider: (
              ipc: import("@smithy/types").IdentityProviderConfig
            ) =>
              | import("@smithy/types").IdentityProvider<
                  import("@smithy/types").Identity
                >
              | (() => Promise<{}>);
            signer: import("@smithy/core").NoAuthSigner;
          }
      )[];
  httpAuthSchemeProvider: import("./auth/httpAuthSchemeProvider").SSOOIDCHttpAuthSchemeProvider;
  credentials?:
    | import("@smithy/types").AwsCredentialIdentity
    | import("@smithy/types").AwsCredentialIdentityProvider;
  signer?:
    | import("@smithy/types").RequestSigner
    | ((
        authScheme?: import("@smithy/types").AuthScheme
      ) => Promise<import("@smithy/types").RequestSigner>);
  signingEscapePath?: boolean;
  systemClockOffset?: number;
  signingRegion?: string;
  signerConstructor?: new (
    options: import("@smithy/signature-v4").SignatureV4Init &
      import("@smithy/signature-v4").SignatureV4CryptoInit
  ) => import("@smithy/types").RequestSigner;
};

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/ts3.4/submodules/sso-oidc/runtimeConfig.d.ts

```typescript
import { NodeHttpHandler as RequestHandler } from "@smithy/node-http-handler";
import { SSOOIDCClientConfig } from "./SSOOIDCClient";
export declare const getRuntimeConfig: (config: SSOOIDCClientConfig) => {
  runtime: string;
  defaultsMode: import("@smithy/types").Provider<
    import("@smithy/smithy-client").ResolvedDefaultsMode
  >;
  authSchemePreference: string[] | import("@smithy/types").Provider<string[]>;
  bodyLengthChecker: import("@smithy/types").BodyLengthCalculator;
  defaultUserAgentProvider: (
    config?: import("@aws-sdk/util-user-agent-node").PreviouslyResolved
  ) => Promise<import("@smithy/types").UserAgent>;
  maxAttempts: number | import("@smithy/types").Provider<number>;
  region: string | import("@smithy/types").Provider<string>;
  requestHandler:
    | RequestHandler
    | import("@smithy/protocol-http").HttpHandler<any>;
  retryMode: string | import("@smithy/types").Provider<string>;
  sha256: import("@smithy/types").HashConstructor;
  streamCollector: import("@smithy/types").StreamCollector;
  useDualstackEndpoint: boolean | import("@smithy/types").Provider<boolean>;
  useFipsEndpoint: boolean | import("@smithy/types").Provider<boolean>;
  userAgentAppId: string | import("@smithy/types").Provider<string | undefined>;
  apiVersion: string;
  cacheMiddleware?: boolean | undefined;
  urlParser: import("@smithy/types").UrlParser;
  base64Decoder: import("@smithy/types").Decoder;
  base64Encoder: (_input: Uint8Array | string) => string;
  utf8Decoder: import("@smithy/types").Decoder;
  utf8Encoder: (input: Uint8Array | string) => string;
  disableHostPrefix: boolean;
  serviceId: string;
  profile?: string;
  logger: import("@smithy/types").Logger;
  extensions: import("./runtimeExtensions").RuntimeExtension[];
  customUserAgent?: string | import("@smithy/types").UserAgent;
  retryStrategy?:
    | import("@smithy/types").RetryStrategy
    | import("@smithy/types").RetryStrategyV2;
  endpoint?:
    | ((
        | string
        | import("@smithy/types").Endpoint
        | import("@smithy/types").Provider<import("@smithy/types").Endpoint>
        | import("@smithy/types").EndpointV2
        | import("@smithy/types").Provider<import("@smithy/types").EndpointV2>
      ) &
        (
          | string
          | import("@smithy/types").Provider<string>
          | import("@smithy/types").Endpoint
          | import("@smithy/types").Provider<import("@smithy/types").Endpoint>
          | import("@smithy/types").EndpointV2
          | import("@smithy/types").Provider<import("@smithy/types").EndpointV2>
        ))
    | undefined;
  endpointProvider: (
    endpointParams: import("./endpoint/EndpointParameters").EndpointParameters,
    context?: {
      logger?: import("@smithy/types").Logger;
    }
  ) => import("@smithy/types").EndpointV2;
  tls?: boolean;
  serviceConfiguredEndpoint?: never;
  httpAuthSchemes:
    | import("@smithy/types").HttpAuthScheme[]
    | (
        | {
            schemeId: string;
            identityProvider: (
              ipc: import("@smithy/types").IdentityProviderConfig
            ) =>
              | import("@smithy/types").IdentityProvider<
                  import("@smithy/types").Identity
                >
              | undefined;
            signer: import("@aws-sdk/core").AwsSdkSigV4Signer;
          }
        | {
            schemeId: string;
            identityProvider: (
              ipc: import("@smithy/types").IdentityProviderConfig
            ) =>
              | import("@smithy/types").IdentityProvider<
                  import("@smithy/types").Identity
                >
              | (() => Promise<{}>);
            signer: import("@smithy/core").NoAuthSigner;
          }
      )[];
  httpAuthSchemeProvider: import("./auth/httpAuthSchemeProvider").SSOOIDCHttpAuthSchemeProvider;
  credentials?:
    | import("@smithy/types").AwsCredentialIdentity
    | import("@smithy/types").AwsCredentialIdentityProvider;
  signer?:
    | import("@smithy/types").RequestSigner
    | ((
        authScheme?: import("@smithy/types").AuthScheme
      ) => Promise<import("@smithy/types").RequestSigner>);
  signingEscapePath?: boolean;
  systemClockOffset?: number;
  signingRegion?: string;
  signerConstructor?: new (
    options: import("@smithy/signature-v4").SignatureV4Init &
      import("@smithy/signature-v4").SignatureV4CryptoInit
  ) => import("@smithy/types").RequestSigner;
};

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/ts3.4/submodules/sso-oidc/runtimeConfig.native.d.ts

```typescript
import { SSOOIDCClientConfig } from "./SSOOIDCClient";
export declare const getRuntimeConfig: (config: SSOOIDCClientConfig) => {
  runtime: string;
  sha256: import("@smithy/types").HashConstructor;
  requestHandler:
    | import("@smithy/types").NodeHttpHandlerOptions
    | import("@smithy/types").FetchHttpHandlerOptions
    | Record<string, unknown>
    | import("@smithy/protocol-http").HttpHandler<any>
    | import("@smithy/fetch-http-handler").FetchHttpHandler;
  apiVersion: string;
  cacheMiddleware?: boolean;
  urlParser: import("@smithy/types").UrlParser;
  bodyLengthChecker: import("@smithy/types").BodyLengthCalculator;
  streamCollector: import("@smithy/types").StreamCollector;
  base64Decoder: import("@smithy/types").Decoder;
  base64Encoder: (_input: Uint8Array | string) => string;
  utf8Decoder: import("@smithy/types").Decoder;
  utf8Encoder: (input: Uint8Array | string) => string;
  disableHostPrefix: boolean;
  serviceId: string;
  useDualstackEndpoint: (boolean | import("@smithy/types").Provider<boolean>) &
    (boolean | import("@smithy/types").Provider<boolean | undefined>);
  useFipsEndpoint: (boolean | import("@smithy/types").Provider<boolean>) &
    (boolean | import("@smithy/types").Provider<boolean | undefined>);
  region: string | import("@smithy/types").Provider<any>;
  profile?: string;
  defaultUserAgentProvider: (
    config?: import("@aws-sdk/util-user-agent-browser").PreviouslyResolved
  ) => Promise<import("@smithy/types").UserAgent>;
  maxAttempts: number | import("@smithy/types").Provider<number>;
  retryMode: string | import("@smithy/types").Provider<string>;
  logger: import("@smithy/types").Logger;
  extensions: import("./runtimeExtensions").RuntimeExtension[];
  defaultsMode:
    | import("@smithy/smithy-client").DefaultsMode
    | import("@smithy/types").Provider<
        import("@smithy/smithy-client").DefaultsMode
      >;
  customUserAgent?: string | import("@smithy/types").UserAgent;
  userAgentAppId?:
    | string
    | undefined
    | import("@smithy/types").Provider<string | undefined>;
  retryStrategy?:
    | import("@smithy/types").RetryStrategy
    | import("@smithy/types").RetryStrategyV2;
  endpoint?:
    | ((
        | string
        | import("@smithy/types").Endpoint
        | import("@smithy/types").Provider<import("@smithy/types").Endpoint>
        | import("@smithy/types").EndpointV2
        | import("@smithy/types").Provider<import("@smithy/types").EndpointV2>
      ) &
        (
          | string
          | import("@smithy/types").Provider<string>
          | import("@smithy/types").Endpoint
          | import("@smithy/types").Provider<import("@smithy/types").Endpoint>
          | import("@smithy/types").EndpointV2
          | import("@smithy/types").Provider<import("@smithy/types").EndpointV2>
        ))
    | undefined;
  endpointProvider: (
    endpointParams: import("./endpoint/EndpointParameters").EndpointParameters,
    context?: {
      logger?: import("@smithy/types").Logger;
    }
  ) => import("@smithy/types").EndpointV2;
  tls?: boolean;
  serviceConfiguredEndpoint?: never;
  authSchemePreference?: string[] | import("@smithy/types").Provider<string[]>;
  httpAuthSchemes:
    | import("@smithy/types").HttpAuthScheme[]
    | (
        | {
            schemeId: string;
            identityProvider: (
              ipc: import("@smithy/types").IdentityProviderConfig
            ) =>
              | import("@smithy/types").IdentityProvider<
                  import("@smithy/types").Identity
                >
              | undefined;
            signer: import("@aws-sdk/core").AwsSdkSigV4Signer;
          }
        | {
            schemeId: string;
            identityProvider: (
              ipc: import("@smithy/types").IdentityProviderConfig
            ) =>
              | import("@smithy/types").IdentityProvider<
                  import("@smithy/types").Identity
                >
              | (() => Promise<{}>);
            signer: import("@smithy/core").NoAuthSigner;
          }
      )[];
  httpAuthSchemeProvider: import("./auth/httpAuthSchemeProvider").SSOOIDCHttpAuthSchemeProvider;
  credentials?:
    | import("@smithy/types").AwsCredentialIdentity
    | import("@smithy/types").AwsCredentialIdentityProvider;
  signer?:
    | import("@smithy/types").RequestSigner
    | ((
        authScheme?: import("@smithy/types").AuthScheme
      ) => Promise<import("@smithy/types").RequestSigner>);
  signingEscapePath?: boolean;
  systemClockOffset?: number;
  signingRegion?: string;
  signerConstructor?: new (
    options: import("@smithy/signature-v4").SignatureV4Init &
      import("@smithy/signature-v4").SignatureV4CryptoInit
  ) => import("@smithy/types").RequestSigner;
};

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/ts3.4/submodules/sso-oidc/runtimeConfig.shared.d.ts

```typescript
import { AwsSdkSigV4Signer } from "@aws-sdk/core";
import { NoAuthSigner } from "@smithy/core";
import { IdentityProviderConfig } from "@smithy/types";
import { SSOOIDCClientConfig } from "./SSOOIDCClient";
export declare const getRuntimeConfig: (config: SSOOIDCClientConfig) => {
  apiVersion: string;
  base64Decoder: import("@smithy/types").Decoder;
  base64Encoder: (_input: Uint8Array | string) => string;
  disableHostPrefix: boolean;
  endpointProvider: (
    endpointParams: import("./endpoint/EndpointParameters").EndpointParameters,
    context?: {
      logger?: import("@smithy/types").Logger;
    }
  ) => import("@smithy/types").EndpointV2;
  extensions: import("./runtimeExtensions").RuntimeExtension[];
  httpAuthSchemeProvider: import("./auth/httpAuthSchemeProvider").SSOOIDCHttpAuthSchemeProvider;
  httpAuthSchemes:
    | import("@smithy/types").HttpAuthScheme[]
    | (
        | {
            schemeId: string;
            identityProvider: (
              ipc: IdentityProviderConfig
            ) =>
              | import("@smithy/types").IdentityProvider<
                  import("@smithy/types").Identity
                >
              | undefined;
            signer: AwsSdkSigV4Signer;
          }
        | {
            schemeId: string;
            identityProvider: (
              ipc: IdentityProviderConfig
            ) =>
              | import("@smithy/types").IdentityProvider<
                  import("@smithy/types").Identity
                >
              | (() => Promise<{}>);
            signer: NoAuthSigner;
          }
      )[];
  logger: import("@smithy/types").Logger;
  serviceId: string;
  urlParser: import("@smithy/types").UrlParser;
  utf8Decoder: import("@smithy/types").Decoder;
  utf8Encoder: (input: Uint8Array | string) => string;
};

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/ts3.4/submodules/sso-oidc/runtimeExtensions.d.ts

```typescript
import { SSOOIDCExtensionConfiguration } from "./extensionConfiguration";
export interface RuntimeExtension {
  configure(extensionConfiguration: SSOOIDCExtensionConfiguration): void;
}
export interface RuntimeExtensionsConfig {
  extensions: RuntimeExtension[];
}
export declare const resolveRuntimeExtensions: (
  runtimeConfig: any,
  extensions: RuntimeExtension[]
) => any;

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/ts3.4/submodules/sts/STS.d.ts

```typescript
import { HttpHandlerOptions as __HttpHandlerOptions } from "@smithy/types";
import {
  AssumeRoleCommandInput,
  AssumeRoleCommandOutput,
} from "./commands/AssumeRoleCommand";
import {
  AssumeRoleWithWebIdentityCommandInput,
  AssumeRoleWithWebIdentityCommandOutput,
} from "./commands/AssumeRoleWithWebIdentityCommand";
import { STSClient } from "./STSClient";
export interface STS {
  assumeRole(
    args: AssumeRoleCommandInput,
    options?: __HttpHandlerOptions
  ): Promise<AssumeRoleCommandOutput>;
  assumeRole(
    args: AssumeRoleCommandInput,
    cb: (err: any, data?: AssumeRoleCommandOutput) => void
  ): void;
  assumeRole(
    args: AssumeRoleCommandInput,
    options: __HttpHandlerOptions,
    cb: (err: any, data?: AssumeRoleCommandOutput) => void
  ): void;
  assumeRoleWithWebIdentity(
    args: AssumeRoleWithWebIdentityCommandInput,
    options?: __HttpHandlerOptions
  ): Promise<AssumeRoleWithWebIdentityCommandOutput>;
  assumeRoleWithWebIdentity(
    args: AssumeRoleWithWebIdentityCommandInput,
    cb: (err: any, data?: AssumeRoleWithWebIdentityCommandOutput) => void
  ): void;
  assumeRoleWithWebIdentity(
    args: AssumeRoleWithWebIdentityCommandInput,
    options: __HttpHandlerOptions,
    cb: (err: any, data?: AssumeRoleWithWebIdentityCommandOutput) => void
  ): void;
}
export declare class STS extends STSClient implements STS {}

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/ts3.4/submodules/sts/STSClient.d.ts

```typescript
import {
  HostHeaderInputConfig,
  HostHeaderResolvedConfig,
} from "@aws-sdk/middleware-host-header";
import {
  UserAgentInputConfig,
  UserAgentResolvedConfig,
} from "@aws-sdk/middleware-user-agent";
import {
  RegionInputConfig,
  RegionResolvedConfig,
} from "@smithy/config-resolver";
import {
  EndpointInputConfig,
  EndpointResolvedConfig,
} from "@smithy/middleware-endpoint";
import {
  RetryInputConfig,
  RetryResolvedConfig,
} from "@smithy/middleware-retry";
import { HttpHandlerUserInput as __HttpHandlerUserInput } from "@smithy/protocol-http";
import {
  Client as __Client,
  DefaultsMode as __DefaultsMode,
  SmithyConfiguration as __SmithyConfiguration,
  SmithyResolvedConfiguration as __SmithyResolvedConfiguration,
} from "@smithy/smithy-client";
import {
  AwsCredentialIdentityProvider,
  BodyLengthCalculator as __BodyLengthCalculator,
  CheckOptionalClientConfig as __CheckOptionalClientConfig,
  ChecksumConstructor as __ChecksumConstructor,
  Decoder as __Decoder,
  Encoder as __Encoder,
  HashConstructor as __HashConstructor,
  HttpHandlerOptions as __HttpHandlerOptions,
  Logger as __Logger,
  Provider as __Provider,
  Provider,
  StreamCollector as __StreamCollector,
  UrlParser as __UrlParser,
  UserAgent as __UserAgent,
} from "@smithy/types";
import {
  HttpAuthSchemeInputConfig,
  HttpAuthSchemeResolvedConfig,
} from "./auth/httpAuthSchemeProvider";
import {
  AssumeRoleCommandInput,
  AssumeRoleCommandOutput,
} from "./commands/AssumeRoleCommand";
import {
  AssumeRoleWithWebIdentityCommandInput,
  AssumeRoleWithWebIdentityCommandOutput,
} from "./commands/AssumeRoleWithWebIdentityCommand";
import {
  ClientInputEndpointParameters,
  ClientResolvedEndpointParameters,
  EndpointParameters,
} from "./endpoint/EndpointParameters";
import { RuntimeExtension, RuntimeExtensionsConfig } from "./runtimeExtensions";
export { __Client };
export type ServiceInputTypes =
  | AssumeRoleCommandInput
  | AssumeRoleWithWebIdentityCommandInput;
export type ServiceOutputTypes =
  | AssumeRoleCommandOutput
  | AssumeRoleWithWebIdentityCommandOutput;
export interface ClientDefaults
  extends Partial<__SmithyConfiguration<__HttpHandlerOptions>> {
  requestHandler?: __HttpHandlerUserInput;
  sha256?: __ChecksumConstructor | __HashConstructor;
  urlParser?: __UrlParser;
  bodyLengthChecker?: __BodyLengthCalculator;
  streamCollector?: __StreamCollector;
  base64Decoder?: __Decoder;
  base64Encoder?: __Encoder;
  utf8Decoder?: __Decoder;
  utf8Encoder?: __Encoder;
  runtime?: string;
  disableHostPrefix?: boolean;
  serviceId?: string;
  useDualstackEndpoint?: boolean | __Provider<boolean>;
  useFipsEndpoint?: boolean | __Provider<boolean>;
  region?: string | __Provider<string>;
  profile?: string;
  defaultUserAgentProvider?: Provider<__UserAgent>;
  credentialDefaultProvider?: (input: any) => AwsCredentialIdentityProvider;
  maxAttempts?: number | __Provider<number>;
  retryMode?: string | __Provider<string>;
  logger?: __Logger;
  extensions?: RuntimeExtension[];
  defaultsMode?: __DefaultsMode | __Provider<__DefaultsMode>;
}
export type STSClientConfigType = Partial<
  __SmithyConfiguration<__HttpHandlerOptions>
> &
  ClientDefaults &
  UserAgentInputConfig &
  RetryInputConfig &
  RegionInputConfig &
  HostHeaderInputConfig &
  EndpointInputConfig<EndpointParameters> &
  HttpAuthSchemeInputConfig &
  ClientInputEndpointParameters;
export interface STSClientConfig extends STSClientConfigType {}
export type STSClientResolvedConfigType =
  __SmithyResolvedConfiguration<__HttpHandlerOptions> &
    Required<ClientDefaults> &
    RuntimeExtensionsConfig &
    UserAgentResolvedConfig &
    RetryResolvedConfig &
    RegionResolvedConfig &
    HostHeaderResolvedConfig &
    EndpointResolvedConfig<EndpointParameters> &
    HttpAuthSchemeResolvedConfig &
    ClientResolvedEndpointParameters;
export interface STSClientResolvedConfig extends STSClientResolvedConfigType {}
export declare class STSClient extends __Client<
  __HttpHandlerOptions,
  ServiceInputTypes,
  ServiceOutputTypes,
  STSClientResolvedConfig
> {
  readonly config: STSClientResolvedConfig;
  constructor(...[configuration]: __CheckOptionalClientConfig<STSClientConfig>);
  destroy(): void;
}

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/ts3.4/submodules/sts/auth/httpAuthExtensionConfiguration.d.ts

```typescript
import {
  AwsCredentialIdentity,
  AwsCredentialIdentityProvider,
  HttpAuthScheme,
} from "@smithy/types";
import { STSHttpAuthSchemeProvider } from "./httpAuthSchemeProvider";
export interface HttpAuthExtensionConfiguration {
  setHttpAuthScheme(httpAuthScheme: HttpAuthScheme): void;
  httpAuthSchemes(): HttpAuthScheme[];
  setHttpAuthSchemeProvider(
    httpAuthSchemeProvider: STSHttpAuthSchemeProvider
  ): void;
  httpAuthSchemeProvider(): STSHttpAuthSchemeProvider;
  setCredentials(
    credentials: AwsCredentialIdentity | AwsCredentialIdentityProvider
  ): void;
  credentials():
    | AwsCredentialIdentity
    | AwsCredentialIdentityProvider
    | undefined;
}
export type HttpAuthRuntimeConfig = Partial<{
  httpAuthSchemes: HttpAuthScheme[];
  httpAuthSchemeProvider: STSHttpAuthSchemeProvider;
  credentials: AwsCredentialIdentity | AwsCredentialIdentityProvider;
}>;
export declare const getHttpAuthExtensionConfiguration: (
  runtimeConfig: HttpAuthRuntimeConfig
) => HttpAuthExtensionConfiguration;
export declare const resolveHttpAuthRuntimeConfig: (
  config: HttpAuthExtensionConfiguration
) => HttpAuthRuntimeConfig;

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/ts3.4/submodules/sts/auth/httpAuthSchemeProvider.d.ts

```typescript
import {
  AwsSdkSigV4AuthInputConfig,
  AwsSdkSigV4AuthResolvedConfig,
  AwsSdkSigV4PreviouslyResolved,
} from "@aws-sdk/core";
import {
  Client,
  HandlerExecutionContext,
  HttpAuthScheme,
  HttpAuthSchemeParameters,
  HttpAuthSchemeParametersProvider,
  HttpAuthSchemeProvider,
  Provider,
} from "@smithy/types";
import { STSClientResolvedConfig } from "../STSClient";
export interface STSHttpAuthSchemeParameters extends HttpAuthSchemeParameters {
  region?: string;
}
export interface STSHttpAuthSchemeParametersProvider
  extends HttpAuthSchemeParametersProvider<
    STSClientResolvedConfig,
    HandlerExecutionContext,
    STSHttpAuthSchemeParameters,
    object
  > {}
export declare const defaultSTSHttpAuthSchemeParametersProvider: (
  config: STSClientResolvedConfig,
  context: HandlerExecutionContext,
  input: object
) => Promise<STSHttpAuthSchemeParameters>;
export interface STSHttpAuthSchemeProvider
  extends HttpAuthSchemeProvider<STSHttpAuthSchemeParameters> {}
export declare const defaultSTSHttpAuthSchemeProvider: STSHttpAuthSchemeProvider;
export interface StsAuthInputConfig {}
export interface StsAuthResolvedConfig {
  stsClientCtor: new (clientConfig: any) => Client<any, any, any>;
}
export declare const resolveStsAuthConfig: <T>(
  input: T & StsAuthInputConfig
) => T & StsAuthResolvedConfig;
export interface HttpAuthSchemeInputConfig
  extends StsAuthInputConfig,
    AwsSdkSigV4AuthInputConfig {
  authSchemePreference?: string[] | Provider<string[]>;
  httpAuthSchemes?: HttpAuthScheme[];
  httpAuthSchemeProvider?: STSHttpAuthSchemeProvider;
}
export interface HttpAuthSchemeResolvedConfig
  extends StsAuthResolvedConfig,
    AwsSdkSigV4AuthResolvedConfig {
  readonly authSchemePreference: Provider<string[]>;
  readonly httpAuthSchemes: HttpAuthScheme[];
  readonly httpAuthSchemeProvider: STSHttpAuthSchemeProvider;
}
export declare const resolveHttpAuthSchemeConfig: <T>(
  config: T & HttpAuthSchemeInputConfig & AwsSdkSigV4PreviouslyResolved
) => T & HttpAuthSchemeResolvedConfig;

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/ts3.4/submodules/sts/commands/AssumeRoleCommand.d.ts

```typescript
import { Command as $Command } from "@smithy/smithy-client";
import { MetadataBearer as __MetadataBearer } from "@smithy/types";
import { AssumeRoleRequest, AssumeRoleResponse } from "../models/models_0";
import {
  ServiceInputTypes,
  ServiceOutputTypes,
  STSClientResolvedConfig,
} from "../STSClient";
export { __MetadataBearer };
export { $Command };
export interface AssumeRoleCommandInput extends AssumeRoleRequest {}
export interface AssumeRoleCommandOutput
  extends AssumeRoleResponse,
    __MetadataBearer {}
declare const AssumeRoleCommand_base: {
  new (
    input: AssumeRoleCommandInput
  ): import("@smithy/smithy-client").CommandImpl<
    AssumeRoleCommandInput,
    AssumeRoleCommandOutput,
    STSClientResolvedConfig,
    ServiceInputTypes,
    ServiceOutputTypes
  >;
  new (
    input: AssumeRoleCommandInput
  ): import("@smithy/smithy-client").CommandImpl<
    AssumeRoleCommandInput,
    AssumeRoleCommandOutput,
    STSClientResolvedConfig,
    ServiceInputTypes,
    ServiceOutputTypes
  >;
  getEndpointParameterInstructions(): import("@smithy/middleware-endpoint").EndpointParameterInstructions;
};
export declare class AssumeRoleCommand extends AssumeRoleCommand_base {
  protected static __types: {
    api: {
      input: AssumeRoleRequest;
      output: AssumeRoleResponse;
    };
    sdk: {
      input: AssumeRoleCommandInput;
      output: AssumeRoleCommandOutput;
    };
  };
}

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/ts3.4/submodules/sts/commands/AssumeRoleWithWebIdentityCommand.d.ts

```typescript
import { Command as $Command } from "@smithy/smithy-client";
import { MetadataBearer as __MetadataBearer } from "@smithy/types";
import {
  AssumeRoleWithWebIdentityRequest,
  AssumeRoleWithWebIdentityResponse,
} from "../models/models_0";
import {
  ServiceInputTypes,
  ServiceOutputTypes,
  STSClientResolvedConfig,
} from "../STSClient";
export { __MetadataBearer };
export { $Command };
export interface AssumeRoleWithWebIdentityCommandInput
  extends AssumeRoleWithWebIdentityRequest {}
export interface AssumeRoleWithWebIdentityCommandOutput
  extends AssumeRoleWithWebIdentityResponse,
    __MetadataBearer {}
declare const AssumeRoleWithWebIdentityCommand_base: {
  new (
    input: AssumeRoleWithWebIdentityCommandInput
  ): import("@smithy/smithy-client").CommandImpl<
    AssumeRoleWithWebIdentityCommandInput,
    AssumeRoleWithWebIdentityCommandOutput,
    STSClientResolvedConfig,
    ServiceInputTypes,
    ServiceOutputTypes
  >;
  new (
    input: AssumeRoleWithWebIdentityCommandInput
  ): import("@smithy/smithy-client").CommandImpl<
    AssumeRoleWithWebIdentityCommandInput,
    AssumeRoleWithWebIdentityCommandOutput,
    STSClientResolvedConfig,
    ServiceInputTypes,
    ServiceOutputTypes
  >;
  getEndpointParameterInstructions(): import("@smithy/middleware-endpoint").EndpointParameterInstructions;
};
export declare class AssumeRoleWithWebIdentityCommand extends AssumeRoleWithWebIdentityCommand_base {
  protected static __types: {
    api: {
      input: AssumeRoleWithWebIdentityRequest;
      output: AssumeRoleWithWebIdentityResponse;
    };
    sdk: {
      input: AssumeRoleWithWebIdentityCommandInput;
      output: AssumeRoleWithWebIdentityCommandOutput;
    };
  };
}

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/ts3.4/submodules/sts/commands/index.d.ts

```typescript
export * from "./AssumeRoleCommand";
export * from "./AssumeRoleWithWebIdentityCommand";

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/ts3.4/submodules/sts/defaultRoleAssumers.d.ts

```typescript
import { Pluggable } from "@smithy/types";
import {
  DefaultCredentialProvider,
  RoleAssumer,
  RoleAssumerWithWebIdentity,
  STSRoleAssumerOptions,
} from "./defaultStsRoleAssumers";
import { ServiceInputTypes, ServiceOutputTypes } from "./STSClient";
export declare const getDefaultRoleAssumer: (
  stsOptions?: STSRoleAssumerOptions,
  stsPlugins?: Pluggable<ServiceInputTypes, ServiceOutputTypes>[]
) => RoleAssumer;
export declare const getDefaultRoleAssumerWithWebIdentity: (
  stsOptions?: STSRoleAssumerOptions,
  stsPlugins?: Pluggable<ServiceInputTypes, ServiceOutputTypes>[]
) => RoleAssumerWithWebIdentity;
export declare const decorateDefaultCredentialProvider: (
  provider: DefaultCredentialProvider
) => DefaultCredentialProvider;

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/ts3.4/submodules/sts/defaultStsRoleAssumers.d.ts

```typescript
import { CredentialProviderOptions } from "@aws-sdk/types";
import { AwsCredentialIdentity, Logger, Provider } from "@smithy/types";
import { AssumeRoleCommandInput } from "./commands/AssumeRoleCommand";
import { AssumeRoleWithWebIdentityCommandInput } from "./commands/AssumeRoleWithWebIdentityCommand";
import { STSClient, STSClientConfig } from "./STSClient";
export type STSRoleAssumerOptions = Pick<
  STSClientConfig,
  "logger" | "region" | "requestHandler"
> & {
  credentialProviderLogger?: Logger;
  parentClientConfig?: CredentialProviderOptions["parentClientConfig"];
};
export type RoleAssumer = (
  sourceCreds: AwsCredentialIdentity,
  params: AssumeRoleCommandInput
) => Promise<AwsCredentialIdentity>;
export declare const getDefaultRoleAssumer: (
  stsOptions: STSRoleAssumerOptions,
  STSClient: new (options: STSClientConfig) => STSClient
) => RoleAssumer;
export type RoleAssumerWithWebIdentity = (
  params: AssumeRoleWithWebIdentityCommandInput
) => Promise<AwsCredentialIdentity>;
export declare const getDefaultRoleAssumerWithWebIdentity: (
  stsOptions: STSRoleAssumerOptions,
  STSClient: new (options: STSClientConfig) => STSClient
) => RoleAssumerWithWebIdentity;
export type DefaultCredentialProvider = (
  input: any
) => Provider<AwsCredentialIdentity>;
export declare const decorateDefaultCredentialProvider: (
  provider: DefaultCredentialProvider
) => DefaultCredentialProvider;

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/ts3.4/submodules/sts/endpoint/EndpointParameters.d.ts

```typescript
import {
  Endpoint,
  EndpointParameters as __EndpointParameters,
  EndpointV2,
  Provider,
} from "@smithy/types";
export interface ClientInputEndpointParameters {
  region?: string | undefined | Provider<string | undefined>;
  useDualstackEndpoint?: boolean | undefined | Provider<boolean | undefined>;
  useFipsEndpoint?: boolean | undefined | Provider<boolean | undefined>;
  endpoint?:
    | string
    | Provider<string>
    | Endpoint
    | Provider<Endpoint>
    | EndpointV2
    | Provider<EndpointV2>;
  useGlobalEndpoint?: boolean | undefined | Provider<boolean | undefined>;
}
export type ClientResolvedEndpointParameters = Pick<
  ClientInputEndpointParameters,
  Exclude<keyof ClientInputEndpointParameters, "endpoint">
> & {
  defaultSigningName: string;
};
export declare const resolveClientEndpointParameters: <T>(
  options: T & ClientInputEndpointParameters
) => T & ClientResolvedEndpointParameters;
export declare const commonParams: {
  readonly UseGlobalEndpoint: {
    readonly type: "builtInParams";
    readonly name: "useGlobalEndpoint";
  };
  readonly UseFIPS: {
    readonly type: "builtInParams";
    readonly name: "useFipsEndpoint";
  };
  readonly Endpoint: {
    readonly type: "builtInParams";
    readonly name: "endpoint";
  };
  readonly Region: {
    readonly type: "builtInParams";
    readonly name: "region";
  };
  readonly UseDualStack: {
    readonly type: "builtInParams";
    readonly name: "useDualstackEndpoint";
  };
};
export interface EndpointParameters extends __EndpointParameters {
  Region?: string | undefined;
  UseDualStack?: boolean | undefined;
  UseFIPS?: boolean | undefined;
  Endpoint?: string | undefined;
  UseGlobalEndpoint?: boolean | undefined;
}

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/ts3.4/submodules/sts/endpoint/endpointResolver.d.ts

```typescript
import { EndpointV2, Logger } from "@smithy/types";
import { EndpointParameters } from "./EndpointParameters";
export declare const defaultEndpointResolver: (
  endpointParams: EndpointParameters,
  context?: {
    logger?: Logger;
  }
) => EndpointV2;

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/ts3.4/submodules/sts/endpoint/ruleset.d.ts

```typescript
import { RuleSetObject } from "@smithy/types";
export declare const ruleSet: RuleSetObject;

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/ts3.4/submodules/sts/extensionConfiguration.d.ts

```typescript
import { AwsRegionExtensionConfiguration } from "@aws-sdk/types";
import { HttpHandlerExtensionConfiguration } from "@smithy/protocol-http";
import { DefaultExtensionConfiguration } from "@smithy/types";
import { HttpAuthExtensionConfiguration } from "./auth/httpAuthExtensionConfiguration";
export interface STSExtensionConfiguration
  extends HttpHandlerExtensionConfiguration,
    DefaultExtensionConfiguration,
    AwsRegionExtensionConfiguration,
    HttpAuthExtensionConfiguration {}

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/ts3.4/submodules/sts/index.d.ts

```typescript
export * from "./STSClient";
export * from "./STS";
export { ClientInputEndpointParameters } from "./endpoint/EndpointParameters";
export { RuntimeExtension } from "./runtimeExtensions";
export { STSExtensionConfiguration } from "./extensionConfiguration";
export * from "./commands";
export * from "./models";
export * from "./defaultRoleAssumers";
export { STSServiceException } from "./models/STSServiceException";

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/ts3.4/submodules/sts/models/STSServiceException.d.ts

```typescript
import {
  ServiceException as __ServiceException,
  ServiceExceptionOptions as __ServiceExceptionOptions,
} from "@smithy/smithy-client";
export { __ServiceExceptionOptions };
export { __ServiceException };
export declare class STSServiceException extends __ServiceException {
  constructor(options: __ServiceExceptionOptions);
}

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/ts3.4/submodules/sts/models/index.d.ts

```typescript
export * from "./models_0";

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/ts3.4/submodules/sts/models/models_0.d.ts

```typescript
import { ExceptionOptionType as __ExceptionOptionType } from "@smithy/smithy-client";
import { STSServiceException as __BaseException } from "./STSServiceException";
export interface AssumedRoleUser {
  AssumedRoleId: string | undefined;
  Arn: string | undefined;
}
export interface PolicyDescriptorType {
  arn?: string | undefined;
}
export interface ProvidedContext {
  ProviderArn?: string | undefined;
  ContextAssertion?: string | undefined;
}
export interface Tag {
  Key: string | undefined;
  Value: string | undefined;
}
export interface AssumeRoleRequest {
  RoleArn: string | undefined;
  RoleSessionName: string | undefined;
  PolicyArns?: PolicyDescriptorType[] | undefined;
  Policy?: string | undefined;
  DurationSeconds?: number | undefined;
  Tags?: Tag[] | undefined;
  TransitiveTagKeys?: string[] | undefined;
  ExternalId?: string | undefined;
  SerialNumber?: string | undefined;
  TokenCode?: string | undefined;
  SourceIdentity?: string | undefined;
  ProvidedContexts?: ProvidedContext[] | undefined;
}
export interface Credentials {
  AccessKeyId: string | undefined;
  SecretAccessKey: string | undefined;
  SessionToken: string | undefined;
  Expiration: Date | undefined;
}
export declare const CredentialsFilterSensitiveLog: (obj: Credentials) => any;
export interface AssumeRoleResponse {
  Credentials?: Credentials | undefined;
  AssumedRoleUser?: AssumedRoleUser | undefined;
  PackedPolicySize?: number | undefined;
  SourceIdentity?: string | undefined;
}
export declare const AssumeRoleResponseFilterSensitiveLog: (
  obj: AssumeRoleResponse
) => any;
export declare class ExpiredTokenException extends __BaseException {
  readonly name: "ExpiredTokenException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ExpiredTokenException, __BaseException>
  );
}
export declare class MalformedPolicyDocumentException extends __BaseException {
  readonly name: "MalformedPolicyDocumentException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      MalformedPolicyDocumentException,
      __BaseException
    >
  );
}
export declare class PackedPolicyTooLargeException extends __BaseException {
  readonly name: "PackedPolicyTooLargeException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<PackedPolicyTooLargeException, __BaseException>
  );
}
export declare class RegionDisabledException extends __BaseException {
  readonly name: "RegionDisabledException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<RegionDisabledException, __BaseException>
  );
}
export declare class IDPRejectedClaimException extends __BaseException {
  readonly name: "IDPRejectedClaimException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<IDPRejectedClaimException, __BaseException>
  );
}
export declare class InvalidIdentityTokenException extends __BaseException {
  readonly name: "InvalidIdentityTokenException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidIdentityTokenException, __BaseException>
  );
}
export interface AssumeRoleWithWebIdentityRequest {
  RoleArn: string | undefined;
  RoleSessionName: string | undefined;
  WebIdentityToken: string | undefined;
  ProviderId?: string | undefined;
  PolicyArns?: PolicyDescriptorType[] | undefined;
  Policy?: string | undefined;
  DurationSeconds?: number | undefined;
}
export declare const AssumeRoleWithWebIdentityRequestFilterSensitiveLog: (
  obj: AssumeRoleWithWebIdentityRequest
) => any;
export interface AssumeRoleWithWebIdentityResponse {
  Credentials?: Credentials | undefined;
  SubjectFromWebIdentityToken?: string | undefined;
  AssumedRoleUser?: AssumedRoleUser | undefined;
  PackedPolicySize?: number | undefined;
  Provider?: string | undefined;
  Audience?: string | undefined;
  SourceIdentity?: string | undefined;
}
export declare const AssumeRoleWithWebIdentityResponseFilterSensitiveLog: (
  obj: AssumeRoleWithWebIdentityResponse
) => any;
export declare class IDPCommunicationErrorException extends __BaseException {
  readonly name: "IDPCommunicationErrorException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<IDPCommunicationErrorException, __BaseException>
  );
}

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/ts3.4/submodules/sts/protocols/Aws_query.d.ts

```typescript
import {
  HttpRequest as __HttpRequest,
  HttpResponse as __HttpResponse,
} from "@smithy/protocol-http";
import { SerdeContext as __SerdeContext } from "@smithy/types";
import {
  AssumeRoleCommandInput,
  AssumeRoleCommandOutput,
} from "../commands/AssumeRoleCommand";
import {
  AssumeRoleWithWebIdentityCommandInput,
  AssumeRoleWithWebIdentityCommandOutput,
} from "../commands/AssumeRoleWithWebIdentityCommand";
export declare const se_AssumeRoleCommand: (
  input: AssumeRoleCommandInput,
  context: __SerdeContext
) => Promise<__HttpRequest>;
export declare const se_AssumeRoleWithWebIdentityCommand: (
  input: AssumeRoleWithWebIdentityCommandInput,
  context: __SerdeContext
) => Promise<__HttpRequest>;
export declare const de_AssumeRoleCommand: (
  output: __HttpResponse,
  context: __SerdeContext
) => Promise<AssumeRoleCommandOutput>;
export declare const de_AssumeRoleWithWebIdentityCommand: (
  output: __HttpResponse,
  context: __SerdeContext
) => Promise<AssumeRoleWithWebIdentityCommandOutput>;

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/ts3.4/submodules/sts/runtimeConfig.browser.d.ts

```typescript
import { FetchHttpHandler as RequestHandler } from "@smithy/fetch-http-handler";
import { STSClientConfig } from "./STSClient";
export declare const getRuntimeConfig: (config: STSClientConfig) => {
  runtime: string;
  defaultsMode: import("@smithy/types").Provider<
    import("@smithy/smithy-client").ResolvedDefaultsMode
  >;
  bodyLengthChecker: import("@smithy/types").BodyLengthCalculator;
  credentialDefaultProvider:
    | ((input: any) => import("@smithy/types").AwsCredentialIdentityProvider)
    | ((
        _: unknown
      ) => () => Promise<import("@smithy/types").AwsCredentialIdentity>);
  defaultUserAgentProvider: (
    config?: import("@aws-sdk/util-user-agent-browser").PreviouslyResolved
  ) => Promise<import("@smithy/types").UserAgent>;
  maxAttempts: number | import("@smithy/types").Provider<number>;
  region: string | import("@smithy/types").Provider<any>;
  requestHandler:
    | import("@smithy/protocol-http").HttpHandler<any>
    | RequestHandler;
  retryMode: string | import("@smithy/types").Provider<string>;
  sha256: import("@smithy/types").HashConstructor;
  streamCollector: import("@smithy/types").StreamCollector;
  useDualstackEndpoint: (boolean | import("@smithy/types").Provider<boolean>) &
    (boolean | import("@smithy/types").Provider<boolean | undefined>);
  useFipsEndpoint: (boolean | import("@smithy/types").Provider<boolean>) &
    (boolean | import("@smithy/types").Provider<boolean | undefined>);
  apiVersion: string;
  cacheMiddleware?: boolean | undefined;
  urlParser: import("@smithy/types").UrlParser;
  base64Decoder: import("@smithy/types").Decoder;
  base64Encoder: (_input: Uint8Array | string) => string;
  utf8Decoder: import("@smithy/types").Decoder;
  utf8Encoder: (input: Uint8Array | string) => string;
  disableHostPrefix: boolean;
  serviceId: string;
  profile?: string;
  logger: import("@smithy/types").Logger;
  extensions: import("./runtimeExtensions").RuntimeExtension[];
  customUserAgent?: string | import("@smithy/types").UserAgent;
  userAgentAppId?:
    | string
    | undefined
    | import("@smithy/types").Provider<string | undefined>;
  retryStrategy?:
    | import("@smithy/types").RetryStrategy
    | import("@smithy/types").RetryStrategyV2;
  endpoint?:
    | ((
        | string
        | import("@smithy/types").Endpoint
        | import("@smithy/types").Provider<import("@smithy/types").Endpoint>
        | import("@smithy/types").EndpointV2
        | import("@smithy/types").Provider<import("@smithy/types").EndpointV2>
      ) &
        (
          | string
          | import("@smithy/types").Provider<string>
          | import("@smithy/types").Endpoint
          | import("@smithy/types").Provider<import("@smithy/types").Endpoint>
          | import("@smithy/types").EndpointV2
          | import("@smithy/types").Provider<import("@smithy/types").EndpointV2>
        ))
    | undefined;
  endpointProvider: (
    params: import("./endpoint/EndpointParameters").EndpointParameters,
    context?: {
      logger?: import("@smithy/types").Logger;
    }
  ) => import("@smithy/types").EndpointV2;
  tls?: boolean;
  serviceConfiguredEndpoint?: never;
  authSchemePreference?: string[] | import("@smithy/types").Provider<string[]>;
  httpAuthSchemes:
    | import("@smithy/types").HttpAuthScheme[]
    | (
        | {
            schemeId: string;
            identityProvider: (
              ipc: import("@smithy/types").IdentityProviderConfig
            ) =>
              | import("@smithy/types").IdentityProvider<
                  import("@smithy/types").Identity
                >
              | undefined;
            signer: import("@aws-sdk/core").AwsSdkSigV4Signer;
          }
        | {
            schemeId: string;
            identityProvider: (
              ipc: import("@smithy/types").IdentityProviderConfig
            ) =>
              | import("@smithy/types").IdentityProvider<
                  import("@smithy/types").Identity
                >
              | (() => Promise<{}>);
            signer: import("@smithy/core").NoAuthSigner;
          }
      )[];
  httpAuthSchemeProvider: import("./auth/httpAuthSchemeProvider").STSHttpAuthSchemeProvider;
  credentials?:
    | import("@smithy/types").AwsCredentialIdentity
    | import("@smithy/types").AwsCredentialIdentityProvider;
  signer?:
    | import("@smithy/types").RequestSigner
    | ((
        authScheme?: import("@smithy/types").AuthScheme
      ) => Promise<import("@smithy/types").RequestSigner>);
  signingEscapePath?: boolean;
  systemClockOffset?: number;
  signingRegion?: string;
  signerConstructor?: new (
    options: import("@smithy/signature-v4").SignatureV4Init &
      import("@smithy/signature-v4").SignatureV4CryptoInit
  ) => import("@smithy/types").RequestSigner;
  useGlobalEndpoint?:
    | boolean
    | undefined
    | import("@smithy/types").Provider<boolean | undefined>;
};

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/ts3.4/submodules/sts/runtimeConfig.d.ts

```typescript
import { NoAuthSigner } from "@smithy/core";
import { NodeHttpHandler as RequestHandler } from "@smithy/node-http-handler";
import { IdentityProviderConfig } from "@smithy/types";
import { STSClientConfig } from "./STSClient";
export declare const getRuntimeConfig: (config: STSClientConfig) => {
  runtime: string;
  defaultsMode: import("@smithy/types").Provider<
    import("@smithy/smithy-client").ResolvedDefaultsMode
  >;
  authSchemePreference: string[] | import("@smithy/types").Provider<string[]>;
  bodyLengthChecker: import("@smithy/types").BodyLengthCalculator;
  defaultUserAgentProvider: (
    config?: import("@aws-sdk/util-user-agent-node").PreviouslyResolved
  ) => Promise<import("@smithy/types").UserAgent>;
  httpAuthSchemes:
    | import("@smithy/types").HttpAuthScheme[]
    | {
        schemeId: string;
        identityProvider: (
          ipc: IdentityProviderConfig
        ) =>
          | import("@smithy/types").IdentityProvider<
              import("@smithy/types").Identity
            >
          | (() => Promise<{}>);
        signer: NoAuthSigner;
      }[];
  maxAttempts: number | import("@smithy/types").Provider<number>;
  region: string | import("@smithy/types").Provider<string>;
  requestHandler:
    | RequestHandler
    | import("@smithy/protocol-http").HttpHandler<any>;
  retryMode: string | import("@smithy/types").Provider<string>;
  sha256: import("@smithy/types").HashConstructor;
  streamCollector: import("@smithy/types").StreamCollector;
  useDualstackEndpoint: boolean | import("@smithy/types").Provider<boolean>;
  useFipsEndpoint: boolean | import("@smithy/types").Provider<boolean>;
  userAgentAppId: string | import("@smithy/types").Provider<string | undefined>;
  apiVersion: string;
  cacheMiddleware?: boolean | undefined;
  urlParser: import("@smithy/types").UrlParser;
  base64Decoder: import("@smithy/types").Decoder;
  base64Encoder: (_input: Uint8Array | string) => string;
  utf8Decoder: import("@smithy/types").Decoder;
  utf8Encoder: (input: Uint8Array | string) => string;
  disableHostPrefix: boolean;
  serviceId: string;
  profile?: string;
  credentialDefaultProvider?: (
    input: any
  ) => import("@smithy/types").AwsCredentialIdentityProvider;
  logger: import("@smithy/types").Logger;
  extensions: import("./runtimeExtensions").RuntimeExtension[];
  customUserAgent?: string | import("@smithy/types").UserAgent;
  retryStrategy?:
    | import("@smithy/types").RetryStrategy
    | import("@smithy/types").RetryStrategyV2;
  endpoint?:
    | ((
        | string
        | import("@smithy/types").Endpoint
        | import("@smithy/types").Provider<import("@smithy/types").Endpoint>
        | import("@smithy/types").EndpointV2
        | import("@smithy/types").Provider<import("@smithy/types").EndpointV2>
      ) &
        (
          | string
          | import("@smithy/types").Provider<string>
          | import("@smithy/types").Endpoint
          | import("@smithy/types").Provider<import("@smithy/types").Endpoint>
          | import("@smithy/types").EndpointV2
          | import("@smithy/types").Provider<import("@smithy/types").EndpointV2>
        ))
    | undefined;
  endpointProvider: (
    params: import("./endpoint/EndpointParameters").EndpointParameters,
    context?: {
      logger?: import("@smithy/types").Logger;
    }
  ) => import("@smithy/types").EndpointV2;
  tls?: boolean;
  serviceConfiguredEndpoint?: never;
  httpAuthSchemeProvider: import("./auth/httpAuthSchemeProvider").STSHttpAuthSchemeProvider;
  credentials?:
    | import("@smithy/types").AwsCredentialIdentity
    | import("@smithy/types").AwsCredentialIdentityProvider;
  signer?:
    | import("@smithy/types").RequestSigner
    | ((
        authScheme?: import("@smithy/types").AuthScheme
      ) => Promise<import("@smithy/types").RequestSigner>);
  signingEscapePath?: boolean;
  systemClockOffset?: number;
  signingRegion?: string;
  signerConstructor?: new (
    options: import("@smithy/signature-v4").SignatureV4Init &
      import("@smithy/signature-v4").SignatureV4CryptoInit
  ) => import("@smithy/types").RequestSigner;
  useGlobalEndpoint?:
    | boolean
    | undefined
    | import("@smithy/types").Provider<boolean | undefined>;
};

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/ts3.4/submodules/sts/runtimeConfig.native.d.ts

```typescript
import { STSClientConfig } from "./STSClient";
export declare const getRuntimeConfig: (config: STSClientConfig) => {
  runtime: string;
  sha256: import("@smithy/types").HashConstructor;
  requestHandler:
    | import("@smithy/types").NodeHttpHandlerOptions
    | import("@smithy/types").FetchHttpHandlerOptions
    | Record<string, unknown>
    | import("@smithy/protocol-http").HttpHandler<any>
    | import("@smithy/fetch-http-handler").FetchHttpHandler;
  apiVersion: string;
  cacheMiddleware?: boolean;
  urlParser: import("@smithy/types").UrlParser;
  bodyLengthChecker: import("@smithy/types").BodyLengthCalculator;
  streamCollector: import("@smithy/types").StreamCollector;
  base64Decoder: import("@smithy/types").Decoder;
  base64Encoder: (_input: Uint8Array | string) => string;
  utf8Decoder: import("@smithy/types").Decoder;
  utf8Encoder: (input: Uint8Array | string) => string;
  disableHostPrefix: boolean;
  serviceId: string;
  useDualstackEndpoint: (boolean | import("@smithy/types").Provider<boolean>) &
    (boolean | import("@smithy/types").Provider<boolean | undefined>);
  useFipsEndpoint: (boolean | import("@smithy/types").Provider<boolean>) &
    (boolean | import("@smithy/types").Provider<boolean | undefined>);
  region: string | import("@smithy/types").Provider<any>;
  profile?: string;
  defaultUserAgentProvider: (
    config?: import("@aws-sdk/util-user-agent-browser").PreviouslyResolved
  ) => Promise<import("@smithy/types").UserAgent>;
  credentialDefaultProvider:
    | ((input: any) => import("@smithy/types").AwsCredentialIdentityProvider)
    | ((
        _: unknown
      ) => () => Promise<import("@smithy/types").AwsCredentialIdentity>);
  maxAttempts: number | import("@smithy/types").Provider<number>;
  retryMode: string | import("@smithy/types").Provider<string>;
  logger: import("@smithy/types").Logger;
  extensions: import("./runtimeExtensions").RuntimeExtension[];
  defaultsMode:
    | import("@smithy/smithy-client").DefaultsMode
    | import("@smithy/types").Provider<
        import("@smithy/smithy-client").DefaultsMode
      >;
  customUserAgent?: string | import("@smithy/types").UserAgent;
  userAgentAppId?:
    | string
    | undefined
    | import("@smithy/types").Provider<string | undefined>;
  retryStrategy?:
    | import("@smithy/types").RetryStrategy
    | import("@smithy/types").RetryStrategyV2;
  endpoint?:
    | ((
        | string
        | import("@smithy/types").Endpoint
        | import("@smithy/types").Provider<import("@smithy/types").Endpoint>
        | import("@smithy/types").EndpointV2
        | import("@smithy/types").Provider<import("@smithy/types").EndpointV2>
      ) &
        (
          | string
          | import("@smithy/types").Provider<string>
          | import("@smithy/types").Endpoint
          | import("@smithy/types").Provider<import("@smithy/types").Endpoint>
          | import("@smithy/types").EndpointV2
          | import("@smithy/types").Provider<import("@smithy/types").EndpointV2>
        ))
    | undefined;
  endpointProvider: (
    params: import("./endpoint/EndpointParameters").EndpointParameters,
    context?: {
      logger?: import("@smithy/types").Logger;
    }
  ) => import("@smithy/types").EndpointV2;
  tls?: boolean;
  serviceConfiguredEndpoint?: never;
  authSchemePreference?: string[] | import("@smithy/types").Provider<string[]>;
  httpAuthSchemes:
    | import("@smithy/types").HttpAuthScheme[]
    | (
        | {
            schemeId: string;
            identityProvider: (
              ipc: import("@smithy/types").IdentityProviderConfig
            ) =>
              | import("@smithy/types").IdentityProvider<
                  import("@smithy/types").Identity
                >
              | undefined;
            signer: import("@aws-sdk/core").AwsSdkSigV4Signer;
          }
        | {
            schemeId: string;
            identityProvider: (
              ipc: import("@smithy/types").IdentityProviderConfig
            ) =>
              | import("@smithy/types").IdentityProvider<
                  import("@smithy/types").Identity
                >
              | (() => Promise<{}>);
            signer: import("@smithy/core").NoAuthSigner;
          }
      )[];
  httpAuthSchemeProvider: import("./auth/httpAuthSchemeProvider").STSHttpAuthSchemeProvider;
  credentials?:
    | import("@smithy/types").AwsCredentialIdentity
    | import("@smithy/types").AwsCredentialIdentityProvider;
  signer?:
    | import("@smithy/types").RequestSigner
    | ((
        authScheme?: import("@smithy/types").AuthScheme
      ) => Promise<import("@smithy/types").RequestSigner>);
  signingEscapePath?: boolean;
  systemClockOffset?: number;
  signingRegion?: string;
  signerConstructor?: new (
    options: import("@smithy/signature-v4").SignatureV4Init &
      import("@smithy/signature-v4").SignatureV4CryptoInit
  ) => import("@smithy/types").RequestSigner;
  useGlobalEndpoint?:
    | boolean
    | undefined
    | import("@smithy/types").Provider<boolean | undefined>;
};

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/ts3.4/submodules/sts/runtimeConfig.shared.d.ts

```typescript
import { AwsSdkSigV4Signer } from "@aws-sdk/core";
import { NoAuthSigner } from "@smithy/core";
import { IdentityProviderConfig } from "@smithy/types";
import { STSClientConfig } from "./STSClient";
export declare const getRuntimeConfig: (config: STSClientConfig) => {
  apiVersion: string;
  base64Decoder: import("@smithy/types").Decoder;
  base64Encoder: (_input: Uint8Array | string) => string;
  disableHostPrefix: boolean;
  endpointProvider: (
    params: import("./endpoint/EndpointParameters").EndpointParameters,
    context?: {
      logger?: import("@smithy/types").Logger;
    }
  ) => import("@smithy/types").EndpointV2;
  extensions: import("./runtimeExtensions").RuntimeExtension[];
  httpAuthSchemeProvider: import("./auth/httpAuthSchemeProvider").STSHttpAuthSchemeProvider;
  httpAuthSchemes:
    | import("@smithy/types").HttpAuthScheme[]
    | (
        | {
            schemeId: string;
            identityProvider: (
              ipc: IdentityProviderConfig
            ) =>
              | import("@smithy/types").IdentityProvider<
                  import("@smithy/types").Identity
                >
              | undefined;
            signer: AwsSdkSigV4Signer;
          }
        | {
            schemeId: string;
            identityProvider: (
              ipc: IdentityProviderConfig
            ) =>
              | import("@smithy/types").IdentityProvider<
                  import("@smithy/types").Identity
                >
              | (() => Promise<{}>);
            signer: NoAuthSigner;
          }
      )[];
  logger: import("@smithy/types").Logger;
  serviceId: string;
  urlParser: import("@smithy/types").UrlParser;
  utf8Decoder: import("@smithy/types").Decoder;
  utf8Encoder: (input: Uint8Array | string) => string;
};

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/dist-types/ts3.4/submodules/sts/runtimeExtensions.d.ts

```typescript
import { STSExtensionConfiguration } from "./extensionConfiguration";
export interface RuntimeExtension {
  configure(extensionConfiguration: STSExtensionConfiguration): void;
}
export interface RuntimeExtensionsConfig {
  extensions: RuntimeExtension[];
}
export declare const resolveRuntimeExtensions: (
  runtimeConfig: any,
  extensions: RuntimeExtension[]
) => any;

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/package.json

```json
{
  "name": "@aws-sdk/nested-clients",
  "version": "3.911.0",
  "description": "Nested clients for AWS SDK packages.",
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "scripts": {
    "build": "yarn lint && concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "node ../../scripts/compilation/inline nested-clients",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "lint": "node ../../scripts/validation/submodules-linter.js --pkg nested-clients",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "sideEffects": false,
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "dependencies": {
    "@aws-crypto/sha256-browser": "5.2.0",
    "@aws-crypto/sha256-js": "5.2.0",
    "@aws-sdk/core": "3.911.0",
    "@aws-sdk/middleware-host-header": "3.910.0",
    "@aws-sdk/middleware-logger": "3.910.0",
    "@aws-sdk/middleware-recursion-detection": "3.910.0",
    "@aws-sdk/middleware-user-agent": "3.911.0",
    "@aws-sdk/region-config-resolver": "3.910.0",
    "@aws-sdk/types": "3.910.0",
    "@aws-sdk/util-endpoints": "3.910.0",
    "@aws-sdk/util-user-agent-browser": "3.910.0",
    "@aws-sdk/util-user-agent-node": "3.911.0",
    "@smithy/config-resolver": "^4.3.2",
    "@smithy/core": "^3.16.1",
    "@smithy/fetch-http-handler": "^5.3.3",
    "@smithy/hash-node": "^4.2.2",
    "@smithy/invalid-dependency": "^4.2.2",
    "@smithy/middleware-content-length": "^4.2.2",
    "@smithy/middleware-endpoint": "^4.3.3",
    "@smithy/middleware-retry": "^4.4.3",
    "@smithy/middleware-serde": "^4.2.2",
    "@smithy/middleware-stack": "^4.2.2",
    "@smithy/node-config-provider": "^4.3.2",
    "@smithy/node-http-handler": "^4.4.1",
    "@smithy/protocol-http": "^5.3.2",
    "@smithy/smithy-client": "^4.8.1",
    "@smithy/types": "^4.7.1",
    "@smithy/url-parser": "^4.2.2",
    "@smithy/util-base64": "^4.3.0",
    "@smithy/util-body-length-browser": "^4.2.0",
    "@smithy/util-body-length-node": "^4.2.1",
    "@smithy/util-defaults-mode-browser": "^4.3.2",
    "@smithy/util-defaults-mode-node": "^4.2.3",
    "@smithy/util-endpoints": "^3.2.2",
    "@smithy/util-middleware": "^4.2.2",
    "@smithy/util-retry": "^4.2.2",
    "@smithy/util-utf8": "^4.2.0",
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typescript": "~5.8.3"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "./sso-oidc.d.ts",
    "./sso-oidc.js",
    "./sts.d.ts",
    "./sts.js",
    "dist-*/**"
  ],
  "browser": {
    "./dist-es/submodules/sso-oidc/runtimeConfig": "./dist-es/submodules/sso-oidc/runtimeConfig.browser",
    "./dist-es/submodules/sts/runtimeConfig": "./dist-es/submodules/sts/runtimeConfig.browser"
  },
  "react-native": {},
  "homepage": "https://github.com/aws/aws-sdk-js-v3/tree/main/packages/nested-clients",
  "repository": {
    "type": "git",
    "url": "https://github.com/aws/aws-sdk-js-v3.git",
    "directory": "packages/nested-clients"
  },
  "exports": {
    "./sso-oidc": {
      "types": "./dist-types/submodules/sso-oidc/index.d.ts",
      "module": "./dist-es/submodules/sso-oidc/index.js",
      "node": "./dist-cjs/submodules/sso-oidc/index.js",
      "import": "./dist-es/submodules/sso-oidc/index.js",
      "require": "./dist-cjs/submodules/sso-oidc/index.js"
    },
    "./sts": {
      "types": "./dist-types/submodules/sts/index.d.ts",
      "module": "./dist-es/submodules/sts/index.js",
      "node": "./dist-cjs/submodules/sts/index.js",
      "import": "./dist-es/submodules/sts/index.js",
      "require": "./dist-cjs/submodules/sts/index.js"
    }
  }
}

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/sso-oidc.d.ts

```typescript
/**
 * Do not edit:
 * This is a compatibility redirect for contexts that do not understand package.json exports field.
 */
declare module "@aws-sdk/nested-clients/sso-oidc" {
  export * from "@aws-sdk/nested-clients/dist-types/submodules/sso-oidc/index.d";
}

```

## ./lib/lambda/node_modules/@aws-sdk/nested-clients/sts.d.ts

```typescript
/**
 * Do not edit:
 * This is a compatibility redirect for contexts that do not understand package.json exports field.
 */
declare module "@aws-sdk/nested-clients/sts" {
  export * from "@aws-sdk/nested-clients/dist-types/submodules/sts/index.d";
}

```

## ./lib/lambda/node_modules/@aws-sdk/region-config-resolver/dist-types/extensions/index.d.ts

```typescript
import { AwsRegionExtensionConfiguration } from "@aws-sdk/types";
import { Provider } from "@smithy/types";
export type RegionExtensionRuntimeConfigType = Partial<{
    region: string | Provider<string>;
}>;
/**
 * @internal
 */
export declare const getAwsRegionExtensionConfiguration: (runtimeConfig: RegionExtensionRuntimeConfigType) => {
    setRegion(region: Provider<string>): void;
    region(): Provider<string>;
};
/**
 * @internal
 */
export declare const resolveAwsRegionExtensionConfiguration: (awsRegionExtensionConfiguration: AwsRegionExtensionConfiguration) => RegionExtensionRuntimeConfigType;

```

## ./lib/lambda/node_modules/@aws-sdk/region-config-resolver/dist-types/index.d.ts

```typescript
export * from "./extensions";
export * from "./regionConfig";

```

## ./lib/lambda/node_modules/@aws-sdk/region-config-resolver/dist-types/regionConfig/config.d.ts

```typescript
import { LoadedConfigSelectors, LocalConfigOptions } from "@smithy/node-config-provider";
/**
 * @internal
 */
export declare const REGION_ENV_NAME = "AWS_REGION";
/**
 * @internal
 */
export declare const REGION_INI_NAME = "region";
/**
 * @internal
 */
export declare const NODE_REGION_CONFIG_OPTIONS: LoadedConfigSelectors<string>;
/**
 * @internal
 */
export declare const NODE_REGION_CONFIG_FILE_OPTIONS: LocalConfigOptions;

```

## ./lib/lambda/node_modules/@aws-sdk/region-config-resolver/dist-types/regionConfig/getRealRegion.d.ts

```typescript
/**
 * @internal
 */
export declare const getRealRegion: (region: string) => string;

```

## ./lib/lambda/node_modules/@aws-sdk/region-config-resolver/dist-types/regionConfig/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./config";
/**
 * @internal
 */
export * from "./resolveRegionConfig";

```

## ./lib/lambda/node_modules/@aws-sdk/region-config-resolver/dist-types/regionConfig/isFipsRegion.d.ts

```typescript
/**
 * @internal
 */
export declare const isFipsRegion: (region: string) => boolean;

```

## ./lib/lambda/node_modules/@aws-sdk/region-config-resolver/dist-types/regionConfig/resolveRegionConfig.d.ts

```typescript
import { Provider } from "@smithy/types";
/**
 * @public
 */
export interface RegionInputConfig {
    /**
     * The AWS region to which this client will send requests
     */
    region?: string | Provider<string>;
    /**
     * Enables FIPS compatible endpoints.
     */
    useFipsEndpoint?: boolean | Provider<boolean>;
}
/**
 * @internal
 */
interface PreviouslyResolved {
}
/**
 * @internal
 */
export interface RegionResolvedConfig {
    /**
     * Resolved value for input config {@link RegionInputConfig.region}
     */
    region: Provider<string>;
    /**
     * Resolved value for input {@link RegionInputConfig.useFipsEndpoint}
     */
    useFipsEndpoint: Provider<boolean>;
}
/**
 * @internal
 */
export declare const resolveRegionConfig: <T>(input: T & RegionInputConfig & PreviouslyResolved) => T & RegionResolvedConfig;
export {};

```

## ./lib/lambda/node_modules/@aws-sdk/region-config-resolver/dist-types/ts3.4/extensions/index.d.ts

```typescript
import { AwsRegionExtensionConfiguration } from "@aws-sdk/types";
import { Provider } from "@smithy/types";
export type RegionExtensionRuntimeConfigType = Partial<{
  region: string | Provider<string>;
}>;
export declare const getAwsRegionExtensionConfiguration: (
  runtimeConfig: RegionExtensionRuntimeConfigType
) => {
  setRegion(region: Provider<string>): void;
  region(): Provider<string>;
};
export declare const resolveAwsRegionExtensionConfiguration: (
  awsRegionExtensionConfiguration: AwsRegionExtensionConfiguration
) => RegionExtensionRuntimeConfigType;

```

## ./lib/lambda/node_modules/@aws-sdk/region-config-resolver/dist-types/ts3.4/index.d.ts

```typescript
export * from "./extensions";
export * from "./regionConfig";

```

## ./lib/lambda/node_modules/@aws-sdk/region-config-resolver/dist-types/ts3.4/regionConfig/config.d.ts

```typescript
import {
  LoadedConfigSelectors,
  LocalConfigOptions,
} from "@smithy/node-config-provider";
export declare const REGION_ENV_NAME = "AWS_REGION";
export declare const REGION_INI_NAME = "region";
export declare const NODE_REGION_CONFIG_OPTIONS: LoadedConfigSelectors<string>;
export declare const NODE_REGION_CONFIG_FILE_OPTIONS: LocalConfigOptions;

```

## ./lib/lambda/node_modules/@aws-sdk/region-config-resolver/dist-types/ts3.4/regionConfig/getRealRegion.d.ts

```typescript
export declare const getRealRegion: (region: string) => string;

```

## ./lib/lambda/node_modules/@aws-sdk/region-config-resolver/dist-types/ts3.4/regionConfig/index.d.ts

```typescript
export * from "./config";
export * from "./resolveRegionConfig";

```

## ./lib/lambda/node_modules/@aws-sdk/region-config-resolver/dist-types/ts3.4/regionConfig/isFipsRegion.d.ts

```typescript
export declare const isFipsRegion: (region: string) => boolean;

```

## ./lib/lambda/node_modules/@aws-sdk/region-config-resolver/dist-types/ts3.4/regionConfig/resolveRegionConfig.d.ts

```typescript
import { Provider } from "@smithy/types";
export interface RegionInputConfig {
  region?: string | Provider<string>;
  useFipsEndpoint?: boolean | Provider<boolean>;
}
interface PreviouslyResolved {}
export interface RegionResolvedConfig {
  region: Provider<string>;
  useFipsEndpoint: Provider<boolean>;
}
export declare const resolveRegionConfig: <T>(
  input: T & RegionInputConfig & PreviouslyResolved
) => T & RegionResolvedConfig;
export {};

```

## ./lib/lambda/node_modules/@aws-sdk/region-config-resolver/package.json

```json
{
  "name": "@aws-sdk/region-config-resolver",
  "version": "3.910.0",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "node ../../scripts/compilation/inline region-config-resolver",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "extract:docs": "api-extractor run --local",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "sideEffects": false,
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "dependencies": {
    "@aws-sdk/types": "3.910.0",
    "@smithy/node-config-provider": "^4.3.2",
    "@smithy/types": "^4.7.1",
    "@smithy/util-config-provider": "^4.2.0",
    "@smithy/util-middleware": "^4.2.2",
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "@tsconfig/recommended": "1.0.1",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "jest": "28.1.1",
    "rimraf": "3.0.2",
    "typescript": "~5.8.3"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/awslabs/smithy-typescript/tree/main/packages/region-config-resolver",
  "repository": {
    "type": "git",
    "url": "https://github.com/aws/aws-sdk-js-v3.git",
    "directory": "packages/region-config-resolver"
  }
}

```

## ./lib/lambda/node_modules/@aws-sdk/s3-request-presigner/dist-types/constants.d.ts

```typescript
export declare const UNSIGNED_PAYLOAD = "UNSIGNED-PAYLOAD";
export declare const SHA256_HEADER = "X-Amz-Content-Sha256";
export declare const ALGORITHM_QUERY_PARAM = "X-Amz-Algorithm";
export declare const CREDENTIAL_QUERY_PARAM = "X-Amz-Credential";
export declare const AMZ_DATE_QUERY_PARAM = "X-Amz-Date";
export declare const SIGNED_HEADERS_QUERY_PARAM = "X-Amz-SignedHeaders";
export declare const EXPIRES_QUERY_PARAM = "X-Amz-Expires";
export declare const HOST_HEADER = "host";
export declare const ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256";

```

## ./lib/lambda/node_modules/@aws-sdk/s3-request-presigner/dist-types/getSignedUrl.d.ts

```typescript
import { Client, Command } from "@smithy/smithy-client";
import { MetadataBearer, RequestPresigningArguments } from "@smithy/types";
/**
 * @public
 */
export declare const getSignedUrl: <InputTypesUnion extends object, InputType extends InputTypesUnion, OutputType extends MetadataBearer = MetadataBearer>(client: Client<any, InputTypesUnion, MetadataBearer, any>, command: Command<InputType, OutputType, any, InputTypesUnion, MetadataBearer>, options?: RequestPresigningArguments) => Promise<string>;

```

## ./lib/lambda/node_modules/@aws-sdk/s3-request-presigner/dist-types/index.d.ts

```typescript
export * from "./getSignedUrl";
export * from "./presigner";

```

## ./lib/lambda/node_modules/@aws-sdk/s3-request-presigner/dist-types/presigner.d.ts

```typescript
import { SignatureV4MultiRegionInit } from "@aws-sdk/signature-v4-multi-region";
import { AwsCredentialIdentity, RequestPresigner, RequestPresigningArguments } from "@smithy/types";
import { HttpRequest as IHttpRequest } from "@smithy/types";
type PartialBy<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;
export type S3RequestPresignerOptions = PartialBy<SignatureV4MultiRegionInit, "service" | "uriEscapePath"> & {
    signingName?: string;
};
export declare class S3RequestPresigner implements RequestPresigner {
    private readonly signer;
    constructor(options: S3RequestPresignerOptions);
    presign(requestToSign: IHttpRequest, { unsignableHeaders, hoistableHeaders, unhoistableHeaders, ...options }?: RequestPresigningArguments): Promise<IHttpRequest>;
    presignWithCredentials(requestToSign: IHttpRequest, credentials: AwsCredentialIdentity, { unsignableHeaders, hoistableHeaders, unhoistableHeaders, ...options }?: RequestPresigningArguments): Promise<IHttpRequest>;
    private prepareRequest;
}
export {};

```

## ./lib/lambda/node_modules/@aws-sdk/s3-request-presigner/dist-types/ts3.4/constants.d.ts

```typescript
export declare const UNSIGNED_PAYLOAD = "UNSIGNED-PAYLOAD";
export declare const SHA256_HEADER = "X-Amz-Content-Sha256";
export declare const ALGORITHM_QUERY_PARAM = "X-Amz-Algorithm";
export declare const CREDENTIAL_QUERY_PARAM = "X-Amz-Credential";
export declare const AMZ_DATE_QUERY_PARAM = "X-Amz-Date";
export declare const SIGNED_HEADERS_QUERY_PARAM = "X-Amz-SignedHeaders";
export declare const EXPIRES_QUERY_PARAM = "X-Amz-Expires";
export declare const HOST_HEADER = "host";
export declare const ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256";

```

## ./lib/lambda/node_modules/@aws-sdk/s3-request-presigner/dist-types/ts3.4/getSignedUrl.d.ts

```typescript
import { Client, Command } from "@smithy/smithy-client";
import { MetadataBearer, RequestPresigningArguments } from "@smithy/types";
export declare const getSignedUrl: <
  InputTypesUnion extends object,
  InputType extends InputTypesUnion,
  OutputType extends MetadataBearer = MetadataBearer
>(
  client: Client<any, InputTypesUnion, MetadataBearer, any>,
  command: Command<InputType, OutputType, any, InputTypesUnion, MetadataBearer>,
  options?: RequestPresigningArguments
) => Promise<string>;

```

## ./lib/lambda/node_modules/@aws-sdk/s3-request-presigner/dist-types/ts3.4/index.d.ts

```typescript
export * from "./getSignedUrl";
export * from "./presigner";

```

## ./lib/lambda/node_modules/@aws-sdk/s3-request-presigner/dist-types/ts3.4/presigner.d.ts

```typescript
import { SignatureV4MultiRegionInit } from "@aws-sdk/signature-v4-multi-region";
import {
  AwsCredentialIdentity,
  RequestPresigner,
  RequestPresigningArguments,
} from "@smithy/types";
import { HttpRequest as IHttpRequest } from "@smithy/types";
type PartialBy<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>> &
  Partial<Pick<T, K>>;
export type S3RequestPresignerOptions = PartialBy<
  SignatureV4MultiRegionInit,
  "service" | "uriEscapePath"
> & {
  signingName?: string;
};
export declare class S3RequestPresigner implements RequestPresigner {
  private readonly signer;
  constructor(options: S3RequestPresignerOptions);
  presign(
    requestToSign: IHttpRequest,
    {
      unsignableHeaders,
      hoistableHeaders,
      unhoistableHeaders,
      ...options
    }?: RequestPresigningArguments
  ): Promise<IHttpRequest>;
  presignWithCredentials(
    requestToSign: IHttpRequest,
    credentials: AwsCredentialIdentity,
    {
      unsignableHeaders,
      hoistableHeaders,
      unhoistableHeaders,
      ...options
    }?: RequestPresigningArguments
  ): Promise<IHttpRequest>;
  private prepareRequest;
}
export {};

```

## ./lib/lambda/node_modules/@aws-sdk/s3-request-presigner/package.json

```json
{
  "name": "@aws-sdk/s3-request-presigner",
  "version": "3.911.0",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "node ../../scripts/compilation/inline s3-request-presigner",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "extract:docs": "api-extractor run --local",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "sideEffects": false,
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "dependencies": {
    "@aws-sdk/signature-v4-multi-region": "3.911.0",
    "@aws-sdk/types": "3.910.0",
    "@aws-sdk/util-format-url": "3.910.0",
    "@smithy/middleware-endpoint": "^4.3.3",
    "@smithy/protocol-http": "^5.3.2",
    "@smithy/smithy-client": "^4.8.1",
    "@smithy/types": "^4.7.1",
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "@aws-sdk/client-s3": "3.911.0",
    "@smithy/hash-node": "^4.2.2",
    "@tsconfig/recommended": "1.0.1",
    "@types/node": "^18.19.69",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typescript": "~5.8.3"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/aws/aws-sdk-js-v3/tree/main/packages/s3-request-presigner",
  "repository": {
    "type": "git",
    "url": "https://github.com/aws/aws-sdk-js-v3.git",
    "directory": "packages/s3-request-presigner"
  }
}

```

## ./lib/lambda/node_modules/@aws-sdk/signature-v4-multi-region/dist-types/SignatureV4MultiRegion.d.ts

```typescript
import { SignatureV4CryptoInit, SignatureV4Init } from "@smithy/signature-v4";
import { AwsCredentialIdentity, HttpRequest, RequestPresigner, RequestPresigningArguments, RequestSigner, RequestSigningArguments } from "@smithy/types";
/**
 * @internal
 */
export type SignatureV4MultiRegionInit = SignatureV4Init & SignatureV4CryptoInit & {
    runtime?: string;
};
/**
 * A SigV4-compatible signer for S3 service. In order to support SigV4a algorithm according to the operation input
 * dynamically, the signer wraps native module SigV4a signer and JS SigV4 signer. It signs the request with SigV4a
 * algorithm if the request needs to be signed with `*` region. Otherwise, it signs the request with normal SigV4
 * signer.
 * @internal
 */
export declare class SignatureV4MultiRegion implements RequestPresigner, RequestSigner {
    private sigv4aSigner?;
    private readonly sigv4Signer;
    private readonly signerOptions;
    static sigv4aDependency(): "none" | "js" | "crt";
    constructor(options: SignatureV4MultiRegionInit);
    sign(requestToSign: HttpRequest, options?: RequestSigningArguments): Promise<HttpRequest>;
    /**
     * Sign with alternate credentials to the ones provided in the constructor.
     * Note: This is only supported for SigV4a when using the CRT implementation.
     */
    signWithCredentials(requestToSign: HttpRequest, credentials: AwsCredentialIdentity, options?: RequestSigningArguments): Promise<HttpRequest>;
    /**
     * Presign a request.
     * Note: This is only supported for SigV4a when using the CRT implementation.
     */
    presign(originalRequest: HttpRequest, options?: RequestPresigningArguments): Promise<HttpRequest>;
    presignWithCredentials(originalRequest: HttpRequest, credentials: AwsCredentialIdentity, options?: RequestPresigningArguments): Promise<HttpRequest>;
    private getSigv4aSigner;
}

```

## ./lib/lambda/node_modules/@aws-sdk/signature-v4-multi-region/dist-types/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./SignatureV4MultiRegion";
export * from "./signature-v4-crt-container";

```

## ./lib/lambda/node_modules/@aws-sdk/signature-v4-multi-region/dist-types/signature-v4-crt-container.d.ts

```typescript
import type { AwsCredentialIdentity } from "@aws-sdk/types";
import type { HttpRequest, RequestPresigner, RequestSigner, RequestSigningArguments } from "@smithy/types";
/**
 * @public
 */
export type OptionalCrtSignerV4 = {
    /**
     * This constructor is not typed so as not to require a type import
     * from the signature-v4-crt package.
     *
     * The true type is CrtSignerV4 from \@aws-sdk/signature-v4-crt.
     */
    new (options: any): RequestPresigner & RequestSigner & {
        signWithCredentials(requestToSign: HttpRequest, credentials: AwsCredentialIdentity, options: RequestSigningArguments): Promise<HttpRequest>;
    };
};
/**
 * @public
 *
 * \@aws-sdk/signature-v4-crt will install the constructor in this
 * container if it is installed.
 *
 * This avoids a runtime-require being interpreted statically by bundlers.
 *
 */
export declare const signatureV4CrtContainer: {
    CrtSignerV4: null | OptionalCrtSignerV4;
};

```

## ./lib/lambda/node_modules/@aws-sdk/signature-v4-multi-region/dist-types/ts3.4/SignatureV4MultiRegion.d.ts

```typescript
import { SignatureV4CryptoInit, SignatureV4Init } from "@smithy/signature-v4";
import {
  AwsCredentialIdentity,
  HttpRequest,
  RequestPresigner,
  RequestPresigningArguments,
  RequestSigner,
  RequestSigningArguments,
} from "@smithy/types";
export type SignatureV4MultiRegionInit = SignatureV4Init &
  SignatureV4CryptoInit & {
    runtime?: string;
  };
export declare class SignatureV4MultiRegion
  implements RequestPresigner, RequestSigner
{
  private sigv4aSigner?;
  private readonly sigv4Signer;
  private readonly signerOptions;
  static sigv4aDependency(): "none" | "js" | "crt";
  constructor(options: SignatureV4MultiRegionInit);
  sign(
    requestToSign: HttpRequest,
    options?: RequestSigningArguments
  ): Promise<HttpRequest>;
  signWithCredentials(
    requestToSign: HttpRequest,
    credentials: AwsCredentialIdentity,
    options?: RequestSigningArguments
  ): Promise<HttpRequest>;
  presign(
    originalRequest: HttpRequest,
    options?: RequestPresigningArguments
  ): Promise<HttpRequest>;
  presignWithCredentials(
    originalRequest: HttpRequest,
    credentials: AwsCredentialIdentity,
    options?: RequestPresigningArguments
  ): Promise<HttpRequest>;
  private getSigv4aSigner;
}

```

## ./lib/lambda/node_modules/@aws-sdk/signature-v4-multi-region/dist-types/ts3.4/index.d.ts

```typescript
export * from "./SignatureV4MultiRegion";
export * from "./signature-v4-crt-container";

```

## ./lib/lambda/node_modules/@aws-sdk/signature-v4-multi-region/dist-types/ts3.4/signature-v4-crt-container.d.ts

```typescript
import { AwsCredentialIdentity } from "@aws-sdk/types";
import {
  HttpRequest,
  RequestPresigner,
  RequestSigner,
  RequestSigningArguments,
} from "@smithy/types";
export type OptionalCrtSignerV4 = {
  new (options: any): RequestPresigner &
    RequestSigner & {
      signWithCredentials(
        requestToSign: HttpRequest,
        credentials: AwsCredentialIdentity,
        options: RequestSigningArguments
      ): Promise<HttpRequest>;
    };
};
export declare const signatureV4CrtContainer: {
  CrtSignerV4: null | OptionalCrtSignerV4;
};

```

## ./lib/lambda/node_modules/@aws-sdk/signature-v4-multi-region/package.json

```json
{
  "name": "@aws-sdk/signature-v4-multi-region",
  "version": "3.911.0",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "node ../../scripts/compilation/inline signature-v4-multi-region",
    "build:es": "tsc -p tsconfig.es.json",
    "build:browser": "node ./test-browser/browser-build/esbuild",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "test": "yarn g:vitest run",
    "test:e2e": "yarn g:vitest run -c vitest.config.e2e.mts",
    "test:browser": "yarn build:browser && yarn g:vitest run -c vitest.config.browser.mts",
    "test:watch": "yarn g:vitest watch"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "sideEffects": false,
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "dependencies": {
    "@aws-sdk/middleware-sdk-s3": "3.911.0",
    "@aws-sdk/types": "3.910.0",
    "@smithy/protocol-http": "^5.3.2",
    "@smithy/signature-v4": "^5.3.2",
    "@smithy/types": "^4.7.1",
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "@tsconfig/recommended": "1.0.1",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typescript": "~5.8.3"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/aws/aws-sdk-js-v3/tree/main/packages/signature-v4-multi-region",
  "repository": {
    "type": "git",
    "url": "https://github.com/aws/aws-sdk-js-v3.git",
    "directory": "packages/signature-v4-multi-region"
  }
}

```

## ./lib/lambda/node_modules/@aws-sdk/token-providers/dist-types/constants.d.ts

```typescript
/**
 * The time window (5 mins) that SDK will treat the SSO token expires in before the defined expiration date in token.
 * This is needed because server side may have invalidated the token before the defined expiration date.
 *
 * @internal
 */
export declare const EXPIRE_WINDOW_MS: number;
export declare const REFRESH_MESSAGE = "To refresh this SSO session run 'aws sso login' with the corresponding profile.";

```

## ./lib/lambda/node_modules/@aws-sdk/token-providers/dist-types/fromEnvSigningName.d.ts

```typescript
import type { CredentialProviderOptions, TokenIdentityProvider } from "@aws-sdk/types";
/**
 * @public
 */
export interface FromEnvSigningNameInit extends CredentialProviderOptions {
    signingName?: string;
}
/**
 * Creates a TokenIdentityProvider that retrieves bearer token from environment variable
 *
 * @param options - Configuration options for the token provider
 * @param options.logger - Optional logger for debug messages
 * @param options.signingName - Service signing name used to determine environment variable key
 * @returns TokenIdentityProvider that provides bearer token from environment variable
 *
 * @public
 */
export declare const fromEnvSigningName: ({ logger, signingName }?: FromEnvSigningNameInit) => TokenIdentityProvider;

```

## ./lib/lambda/node_modules/@aws-sdk/token-providers/dist-types/fromSso.d.ts

```typescript
import { CredentialProviderOptions, RuntimeConfigIdentityProvider, TokenIdentity } from "@aws-sdk/types";
import { SourceProfileInit } from "@smithy/shared-ini-file-loader";
export interface FromSsoInit extends SourceProfileInit, CredentialProviderOptions {
    /**
     * @see SSOOIDCClientConfig in \@aws-sdk/client-sso-oidc.
     */
    clientConfig?: any;
}
/**
 * Creates a token provider that will read from SSO token cache or ssoOidc.createToken() call.
 */
export declare const fromSso: (_init?: FromSsoInit) => RuntimeConfigIdentityProvider<TokenIdentity>;

```

## ./lib/lambda/node_modules/@aws-sdk/token-providers/dist-types/fromStatic.d.ts

```typescript
import { CredentialProviderOptions, TokenIdentity, TokenIdentityProvider } from "@aws-sdk/types";
export interface FromStaticInit extends CredentialProviderOptions {
    token?: TokenIdentity;
}
/**
 * Creates a token provider that will read from static token.
 * @public
 */
export declare const fromStatic: ({ token, logger }: FromStaticInit) => TokenIdentityProvider;

```

## ./lib/lambda/node_modules/@aws-sdk/token-providers/dist-types/getNewSsoOidcToken.d.ts

```typescript
import { SSOToken } from "@smithy/shared-ini-file-loader";
import { FromSsoInit } from "./fromSso";
/**
 * Returns a new SSO OIDC token from ssoOids.createToken() API call.
 * @internal
 */
export declare const getNewSsoOidcToken: (ssoToken: SSOToken, ssoRegion: string, init?: FromSsoInit) => Promise<import("@aws-sdk/nested-clients/sso-oidc").CreateTokenCommandOutput>;

```

## ./lib/lambda/node_modules/@aws-sdk/token-providers/dist-types/getSsoOidcClient.d.ts

```typescript
import { FromSsoInit } from "./fromSso";
/**
 * Returns a SSOOIDC client for the given region.
 * @internal
 */
export declare const getSsoOidcClient: (ssoRegion: string, init?: FromSsoInit) => Promise<import("@aws-sdk/nested-clients/sso-oidc").SSOOIDCClient>;

```

## ./lib/lambda/node_modules/@aws-sdk/token-providers/dist-types/index.d.ts

```typescript
export * from "./fromEnvSigningName";
export * from "./fromSso";
export * from "./fromStatic";
export * from "./nodeProvider";

```

## ./lib/lambda/node_modules/@aws-sdk/token-providers/dist-types/nodeProvider.d.ts

```typescript
import { TokenIdentityProvider } from "@aws-sdk/types";
import { FromSsoInit } from "./fromSso";
/**
 * Creates a token provider that will attempt to find token from the
 * following sources (listed in order of precedence):
 *   * SSO token from SSO cache or ssoOidc.createToken() call
 *
 * The default token provider is designed to invoke one provider at a time and only
 * continue to the next if no token has been located. It currently has only SSO
 * Token Provider in the chain.
 *
 * @param init                  Configuration that is passed to each individual
 *                              provider
 *
 * @see fromSso                 The function used to source credentials from
 *                              SSO cache or ssoOidc.createToken() call
 */
export declare const nodeProvider: (init?: FromSsoInit) => TokenIdentityProvider;

```

## ./lib/lambda/node_modules/@aws-sdk/token-providers/dist-types/ts3.4/constants.d.ts

```typescript
export declare const EXPIRE_WINDOW_MS: number;
export declare const REFRESH_MESSAGE =
  "To refresh this SSO session run 'aws sso login' with the corresponding profile.";

```

## ./lib/lambda/node_modules/@aws-sdk/token-providers/dist-types/ts3.4/fromEnvSigningName.d.ts

```typescript
import {
  CredentialProviderOptions,
  TokenIdentityProvider,
} from "@aws-sdk/types";
export interface FromEnvSigningNameInit extends CredentialProviderOptions {
  signingName?: string;
}
export declare const fromEnvSigningName: ({
  logger,
  signingName,
}?: FromEnvSigningNameInit) => TokenIdentityProvider;

```

## ./lib/lambda/node_modules/@aws-sdk/token-providers/dist-types/ts3.4/fromSso.d.ts

```typescript
import {
  CredentialProviderOptions,
  RuntimeConfigIdentityProvider,
  TokenIdentity,
} from "@aws-sdk/types";
import { SourceProfileInit } from "@smithy/shared-ini-file-loader";
export interface FromSsoInit
  extends SourceProfileInit,
    CredentialProviderOptions {
  clientConfig?: any;
}
export declare const fromSso: (
  _init?: FromSsoInit
) => RuntimeConfigIdentityProvider<TokenIdentity>;

```

## ./lib/lambda/node_modules/@aws-sdk/token-providers/dist-types/ts3.4/fromStatic.d.ts

```typescript
import {
  CredentialProviderOptions,
  TokenIdentity,
  TokenIdentityProvider,
} from "@aws-sdk/types";
export interface FromStaticInit extends CredentialProviderOptions {
  token?: TokenIdentity;
}
export declare const fromStatic: ({
  token,
  logger,
}: FromStaticInit) => TokenIdentityProvider;

```

## ./lib/lambda/node_modules/@aws-sdk/token-providers/dist-types/ts3.4/getNewSsoOidcToken.d.ts

```typescript
import { SSOToken } from "@smithy/shared-ini-file-loader";
import { FromSsoInit } from "./fromSso";
export declare const getNewSsoOidcToken: (
  ssoToken: SSOToken,
  ssoRegion: string,
  init?: FromSsoInit
) => Promise<
  import("@aws-sdk/nested-clients/sso-oidc").CreateTokenCommandOutput
>;

```

## ./lib/lambda/node_modules/@aws-sdk/token-providers/dist-types/ts3.4/getSsoOidcClient.d.ts

```typescript
import { FromSsoInit } from "./fromSso";
export declare const getSsoOidcClient: (
  ssoRegion: string,
  init?: FromSsoInit
) => Promise<import("@aws-sdk/nested-clients/sso-oidc").SSOOIDCClient>;

```

## ./lib/lambda/node_modules/@aws-sdk/token-providers/dist-types/ts3.4/index.d.ts

```typescript
export * from "./fromEnvSigningName";
export * from "./fromSso";
export * from "./fromStatic";
export * from "./nodeProvider";

```

## ./lib/lambda/node_modules/@aws-sdk/token-providers/dist-types/ts3.4/nodeProvider.d.ts

```typescript
import { TokenIdentityProvider } from "@aws-sdk/types";
import { FromSsoInit } from "./fromSso";
export declare const nodeProvider: (
  init?: FromSsoInit
) => TokenIdentityProvider;

```

## ./lib/lambda/node_modules/@aws-sdk/token-providers/dist-types/ts3.4/validateTokenExpiry.d.ts

```typescript
import { TokenIdentity } from "@aws-sdk/types";
export declare const validateTokenExpiry: (token: TokenIdentity) => void;

```

## ./lib/lambda/node_modules/@aws-sdk/token-providers/dist-types/ts3.4/validateTokenKey.d.ts

```typescript
export declare const validateTokenKey: (
  key: string,
  value: unknown,
  forRefresh?: boolean
) => void;

```

## ./lib/lambda/node_modules/@aws-sdk/token-providers/dist-types/ts3.4/writeSSOTokenToFile.d.ts

```typescript
import { SSOToken } from "@smithy/shared-ini-file-loader";
export declare const writeSSOTokenToFile: (
  id: string,
  ssoToken: SSOToken
) => Promise<void>;

```

## ./lib/lambda/node_modules/@aws-sdk/token-providers/dist-types/validateTokenExpiry.d.ts

```typescript
import { TokenIdentity } from "@aws-sdk/types";
/**
 * Throws TokenProviderError is token is expired.
 */
export declare const validateTokenExpiry: (token: TokenIdentity) => void;

```

## ./lib/lambda/node_modules/@aws-sdk/token-providers/dist-types/validateTokenKey.d.ts

```typescript
/**
 * Throws TokenProviderError if value is undefined for key.
 */
export declare const validateTokenKey: (key: string, value: unknown, forRefresh?: boolean) => void;

```

## ./lib/lambda/node_modules/@aws-sdk/token-providers/dist-types/writeSSOTokenToFile.d.ts

```typescript
import { SSOToken } from "@smithy/shared-ini-file-loader";
/**
 * Writes SSO token to file based on filepath computed from ssoStartUrl or session name.
 */
export declare const writeSSOTokenToFile: (id: string, ssoToken: SSOToken) => Promise<void>;

```

## ./lib/lambda/node_modules/@aws-sdk/token-providers/package.json

```json
{
  "name": "@aws-sdk/token-providers",
  "version": "3.911.0",
  "description": "A collection of token providers",
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "node ../../scripts/compilation/inline token-providers",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "extract:docs": "api-extractor run --local",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch",
    "test:integration": "yarn g:vitest run -c vitest.config.integ.mts",
    "test:integration:watch": "yarn g:vitest watch -c vitest.config.integ.mts"
  },
  "keywords": [
    "aws",
    "token"
  ],
  "sideEffects": false,
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "dependencies": {
    "@aws-sdk/core": "3.911.0",
    "@aws-sdk/nested-clients": "3.911.0",
    "@aws-sdk/types": "3.910.0",
    "@smithy/property-provider": "^4.2.2",
    "@smithy/shared-ini-file-loader": "^4.3.2",
    "@smithy/types": "^4.7.1",
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "@tsconfig/recommended": "1.0.1",
    "@types/node": "^18.19.69",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typescript": "~5.8.3"
  },
  "types": "./dist-types/index.d.ts",
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "browser": {},
  "react-native": {},
  "homepage": "https://github.com/aws/aws-sdk-js-v3/tree/main/packages/token-providers",
  "repository": {
    "type": "git",
    "url": "https://github.com/aws/aws-sdk-js-v3.git",
    "directory": "packages/token-providers"
  }
}

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/abort.d.ts

```typescript
export { AbortController, AbortHandler, AbortSignal } from "@smithy/types";

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/auth.d.ts

```typescript
export { AuthScheme, HttpAuthDefinition, HttpAuthLocation } from "@smithy/types";

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/blob/blob-types.d.ts

```typescript
import { BlobTypes } from '@smithy/types';
export { BlobTypes };

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/checksum.d.ts

```typescript
export { Checksum, ChecksumConstructor } from "@smithy/types";

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/client.d.ts

```typescript
export { Client } from "@smithy/types";

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/command.d.ts

```typescript
export { Command } from "@smithy/types";

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/connection.d.ts

```typescript
export { ConnectConfiguration, ConnectionManager, ConnectionManagerConfiguration, ConnectionPool } from "@smithy/types";

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/credentials.d.ts

```typescript
import { Logger } from "@smithy/types";
import { AwsCredentialIdentity } from "./identity";
import { Provider } from "./util";
/**
 * @public
 *
 * An object representing temporary or permanent AWS credentials.
 *
 * @deprecated Use {@link AwsCredentialIdentity}
 */
export interface Credentials extends AwsCredentialIdentity {
}
/**
 * @public
 *
 * @deprecated Use {@link AwsCredentialIdentityProvider}
 */
export type CredentialProvider = Provider<Credentials>;
/**
 * @public
 *
 * Common options for credential providers.
 */
export type CredentialProviderOptions = {
    /**
     * This logger is only used to provide information
     * on what credential providers were used during resolution.
     *
     * It does not log credentials.
     */
    logger?: Logger;
    /**
     * Present if the credential provider was created by calling
     * the defaultCredentialProvider in a client's middleware, having
     * access to the client's config.
     *
     * The region of that parent or outer client is important because
     * an inner client used by the credential provider may need
     * to match its default partition or region with that of
     * the outer client.
     *
     * @internal
     * @deprecated - not truly deprecated, marked as a warning to not use this.
     */
    parentClientConfig?: {
        region?: string | Provider<string>;
        profile?: string;
        [key: string]: unknown;
    };
};

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/crypto.d.ts

```typescript
export { Hash, HashConstructor, StreamHasher, randomValues, SourceData } from "@smithy/types";

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/dns.d.ts

```typescript
/**
 * @public
 *
 * DNS record types
 */
export declare enum HostAddressType {
    /**
     * IPv6
     */
    AAAA = "AAAA",
    /**
     * IPv4
     */
    A = "A"
}
/**
 * @public
 */
export interface HostAddress {
    /**
     * The {@link HostAddressType} of the host address.
     */
    addressType: HostAddressType;
    /**
     * The resolved numerical address represented as a
     * string.
     */
    address: string;
    /**
     * The host name the {@link address} was resolved from.
     */
    hostName: string;
    /**
     * The service record of {@link hostName}.
     */
    service?: string;
}
/**
 * @public
 */
export interface HostResolverArguments {
    /**
     * The host name to resolve.
     */
    hostName: string;
    /**
     * The service record of {@link hostName}.
     */
    service?: string;
}
/**
 * @public
 *
 * Host Resolver interface for DNS queries
 */
export interface HostResolver {
    /**
     * Resolves the address(es) for {@link HostResolverArguments} and returns a
     * list of addresses with (most likely) two addresses, one {@link HostAddressType.AAAA}
     * and one {@link HostAddressType.A}. Calls to this function will likely alter
     * the cache (if implemented) so that if there's multiple addresses, a different
     * set will be returned on the next call.
     * In the case of multi-answer, still only a maximum of two records should be
     * returned. The resolver implementation is responsible for caching and rotation
     * of the multiple addresses that get returned.
     * Implementations don't have to explictly call getaddrinfo(), they can use
     * high level abstractions provided in their language runtimes/libraries.
     * @param args - arguments with host name query addresses for
     * @returns promise with a list of {@link HostAddress}
     */
    resolveAddress(args: HostResolverArguments): Promise<HostAddress[]>;
    /**
     * Reports a failure on a {@link HostAddress} so that the cache (if implemented)
     * can accomodate the failure and likely not return the address until it recovers.
     * @param addr - host address to report a failure on
     */
    reportFailureOnAddress(addr: HostAddress): void;
    /**
     * Empties the cache (if implemented) for a {@link HostResolverArguments.hostName}.
     * If {@link HostResolverArguments.hostName} is not provided, the cache (if
     * implemented) is emptied for all host names.
     * @param args - optional arguments to empty the cache for
     */
    purgeCache(args?: HostResolverArguments): void;
}

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/encode.d.ts

```typescript
export { MessageDecoder, MessageEncoder, AvailableMessage, AvailableMessages } from "@smithy/types";

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/endpoint.d.ts

```typescript
export { EndpointARN, EndpointPartition, EndpointURLScheme, EndpointURL, EndpointObjectProperty, EndpointV2, EndpointParameters, } from "@smithy/types";

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/eventStream.d.ts

```typescript
export { Message, MessageHeaders, BooleanHeaderValue, ByteHeaderValue, ShortHeaderValue, IntegerHeaderValue, LongHeaderValue, BinaryHeaderValue, StringHeaderValue, TimestampHeaderValue, UuidHeaderValue, MessageHeaderValue, Int64, EventStreamSerdeContext, EventStreamMarshaller, EventStreamMarshallerDeserFn, EventStreamMarshallerSerFn, EventStreamPayloadHandler, EventStreamPayloadHandlerProvider, EventStreamRequestSigner, EventStreamSerdeProvider, EventStreamSignerProvider, } from "@smithy/types";

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/extensions/index.d.ts

```typescript
import { Provider } from "@smithy/types";
/**
 * @internal
 */
export interface AwsRegionExtensionConfiguration {
    setRegion(region: Provider<string>): void;
    region(): Provider<string>;
}

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/feature-ids.d.ts

```typescript
/**
 * @internal
 */
export type AwsSdkFeatures = Partial<{
    RESOURCE_MODEL: "A";
    WAITER: "B";
    PAGINATOR: "C";
    RETRY_MODE_LEGACY: "D";
    RETRY_MODE_STANDARD: "E";
    RETRY_MODE_ADAPTIVE: "F";
    S3_EXPRESS_BUCKET: "J";
    S3_ACCESS_GRANTS: "K";
    GZIP_REQUEST_COMPRESSION: "L";
    PROTOCOL_RPC_V2_CBOR: "M";
    ENDPOINT_OVERRIDE: "N";
    ACCOUNT_ID_ENDPOINT: "O";
    ACCOUNT_ID_MODE_PREFERRED: "P";
    ACCOUNT_ID_MODE_DISABLED: "Q";
    ACCOUNT_ID_MODE_REQUIRED: "R";
    SIGV4A_SIGNING: "S";
    FLEXIBLE_CHECKSUMS_REQ_CRC32: "U";
    FLEXIBLE_CHECKSUMS_REQ_CRC32C: "V";
    FLEXIBLE_CHECKSUMS_REQ_CRC64: "W";
    FLEXIBLE_CHECKSUMS_REQ_SHA1: "X";
    FLEXIBLE_CHECKSUMS_REQ_SHA256: "Y";
    FLEXIBLE_CHECKSUMS_REQ_WHEN_SUPPORTED: "Z";
    FLEXIBLE_CHECKSUMS_REQ_WHEN_REQUIRED: "a";
    FLEXIBLE_CHECKSUMS_RES_WHEN_SUPPORTED: "b";
    FLEXIBLE_CHECKSUMS_RES_WHEN_REQUIRED: "c";
    DDB_MAPPER: "d";
}> & AwsSdkCredentialsFeatures & AwsSdkTokenFeatures;
/**
 * @internal
 */
export type AwsSdkCredentialsFeatures = Partial<{
    RESOLVED_ACCOUNT_ID: "T";
    CREDENTIALS_CODE: "e";
    CREDENTIALS_ENV_VARS: "g";
    CREDENTIALS_ENV_VARS_STS_WEB_ID_TOKEN: "h";
    CREDENTIALS_STS_ASSUME_ROLE: "i";
    CREDENTIALS_STS_ASSUME_ROLE_SAML: "j";
    CREDENTIALS_STS_ASSUME_ROLE_WEB_ID: "k";
    CREDENTIALS_STS_FEDERATION_TOKEN: "l";
    CREDENTIALS_STS_SESSION_TOKEN: "m";
    CREDENTIALS_PROFILE: "n";
    CREDENTIALS_PROFILE_SOURCE_PROFILE: "o";
    CREDENTIALS_PROFILE_NAMED_PROVIDER: "p";
    CREDENTIALS_PROFILE_STS_WEB_ID_TOKEN: "q";
    CREDENTIALS_PROFILE_SSO: "r";
    CREDENTIALS_SSO: "s";
    CREDENTIALS_PROFILE_SSO_LEGACY: "t";
    CREDENTIALS_SSO_LEGACY: "u";
    CREDENTIALS_PROFILE_PROCESS: "v";
    CREDENTIALS_PROCESS: "w";
    CREDENTIALS_BOTO2_CONFIG_FILE: "x";
    CREDENTIALS_AWS_SDK_STORE: "y";
    CREDENTIALS_HTTP: "z";
    CREDENTIALS_IMDS: "0";
}>;
/**
 * @internal
 */
export type AwsSdkTokenFeatures = Partial<{
    BEARER_SERVICE_ENV_VARS: "3";
}>;

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/function.d.ts

```typescript
/**
 * Resolves a function that accepts both the object argument fields of F1 and F2.
 * The function returns an intersection of what F1 and F2 return.
 *
 * @public
 */
export type MergeFunctions<F1, F2> = F1 extends (arg: infer A1) => infer R1 ? F2 extends (arg: infer A2) => infer R2 ? R1 extends Promise<unknown> ? (arg?: A1 & A2) => Promise<Awaited<R1> & Awaited<R2>> : (arg?: A1 & A2) => R1 & R2 : never : never;

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/http.d.ts

```typescript
import { HttpResponse } from "@smithy/types";
export { Endpoint, HeaderBag, HttpHandlerOptions, HttpMessage, HttpRequest, HttpResponse, QueryParameterBag, } from "@smithy/types";
/**
 * @public
 *
 * A collection of key/value pairs with case-insensitive keys.
 */
export interface Headers extends Map<string, string> {
    /**
     * Returns a new instance of Headers with the specified header set to the
     * provided value. Does not modify the original Headers instance.
     *
     * @param headerName - The name of the header to add or overwrite
     * @param headerValue - The value to which the header should be set
     */
    withHeader(headerName: string, headerValue: string): Headers;
    /**
     * Returns a new instance of Headers without the specified header. Does not
     * modify the original Headers instance.
     *
     * @param headerName - The name of the header to remove
     */
    withoutHeader(headerName: string): Headers;
}
/**
 * @public
 *
 * Represents HTTP message whose body has been resolved to a string. This is
 * used in parsing http message.
 */
export interface ResolvedHttpResponse extends HttpResponse {
    body: string;
}

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/identity/AnonymousIdentity.d.ts

```typescript
import { Identity } from "./Identity";
/**
 * @public
 */
export interface AnonymousIdentity extends Identity {
}

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/identity/AwsCredentialIdentity.d.ts

```typescript
import type { AwsCredentialIdentity, AwsCredentialIdentityProvider, Logger, RequestHandler } from "@smithy/types";
import type { AwsSdkCredentialsFeatures } from "../feature-ids";
export { AwsCredentialIdentity, AwsCredentialIdentityProvider, IdentityProvider } from "@smithy/types";
/**
 * @public
 */
export interface AwsIdentityProperties {
    /**
     * These are resolved client config values, and may be async providers.
     */
    callerClientConfig?: {
        /**
         * It is likely a programming error if you use
         * the caller client config credentials in a credential provider, since
         * it will recurse.
         *
         * @deprecated do not use.
         */
        credentials?: AwsCredentialIdentity | AwsCredentialIdentityProvider;
        /**
         * @internal
         * @deprecated minimize use.
         */
        credentialDefaultProvider?: (input?: any) => AwsCredentialIdentityProvider;
        logger?: Logger;
        profile?: string;
        region(): Promise<string>;
        requestHandler?: RequestHandler<any, any>;
    };
}
/**
 * @public
 *
 * Variation of {@link IdentityProvider} which accepts a contextual
 * client configuration that includes an AWS region and potentially other
 * configurable fields.
 *
 * Used to link a credential provider to a client if it is being called
 * in the context of a client.
 */
export type RuntimeConfigIdentityProvider<T> = (awsIdentityProperties?: AwsIdentityProperties) => Promise<T>;
/**
 * @public
 *
 * Variation of {@link AwsCredentialIdentityProvider} which accepts a contextual
 * client configuration that includes an AWS region and potentially other
 * configurable fields.
 *
 * Used to link a credential provider to a client if it is being called
 * in the context of a client.
 */
export type RuntimeConfigAwsCredentialIdentityProvider = RuntimeConfigIdentityProvider<AwsCredentialIdentity>;
/**
 * @public
 *
 * AwsCredentialIdentity with source attribution metadata.
 */
export type AttributedAwsCredentialIdentity = AwsCredentialIdentity & {
    $source?: AwsSdkCredentialsFeatures;
};

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/identity/Identity.d.ts

```typescript
export { Identity, IdentityProvider } from "@smithy/types";

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/identity/LoginIdentity.d.ts

```typescript
import { Identity, IdentityProvider } from "./Identity";
/**
 * @public
 */
export interface LoginIdentity extends Identity {
    /**
     * Identity username
     */
    readonly username: string;
    /**
     * Identity password
     */
    readonly password: string;
}
/**
 * @public
 */
export type LoginIdentityProvider = IdentityProvider<LoginIdentity>;

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/identity/TokenIdentity.d.ts

```typescript
import type { TokenIdentity } from "@smithy/types";
import type { AwsSdkTokenFeatures } from "../feature-ids";
export { TokenIdentity, TokenIdentityProvider } from "@smithy/types";
/**
 * @public
 *
 * TokenIdentity with source attribution metadata.
 */
export type AttributedTokenIdentity = TokenIdentity & {
    $source?: AwsSdkTokenFeatures;
};

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/identity/index.d.ts

```typescript
export * from "./AnonymousIdentity";
export * from "./AwsCredentialIdentity";
export * from "./Identity";
export * from "./LoginIdentity";
export * from "./TokenIdentity";

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/index.d.ts

```typescript
export * from "./abort";
export * from "./auth";
export * from "./blob/blob-types";
export * from "./checksum";
export * from "./client";
export * from "./command";
export * from "./connection";
export * from "./credentials";
export * from "./crypto";
export * from "./dns";
export * from "./encode";
export * from "./endpoint";
export * from "./eventStream";
export * from "./extensions";
export * from "./feature-ids";
export * from "./function";
export * from "./http";
export * from "./identity";
export * from "./logger";
export * from "./middleware";
export * from "./pagination";
export * from "./profile";
export * from "./request";
export * from "./response";
export * from "./retry";
export * from "./serde";
export * from "./shapes";
export * from "./signature";
export * from "./stream";
export * from "./token";
export * from "./transfer";
export * from "./uri";
export * from "./util";
export * from "./waiter";

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/logger.d.ts

```typescript
import type { Logger } from "@smithy/types";
export type { Logger } from "@smithy/types";
/**
 * @public
 *
 * A list of logger's log level. These levels are sorted in
 * order of increasing severity. Each log level includes itself and all
 * the levels behind itself.
 *
 * @example `new Logger({logLevel: 'warn'})` will print all the warn and error
 * message.
 */
export type LogLevel = "all" | "trace" | "debug" | "log" | "info" | "warn" | "error" | "off";
/**
 * @public
 *
 * An object consumed by Logger constructor to initiate a logger object.
 */
export interface LoggerOptions {
    logger?: Logger;
    logLevel?: LogLevel;
}

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/middleware.d.ts

```typescript
import { HandlerExecutionContext } from "@smithy/types";
import { AwsSdkFeatures } from "./feature-ids";
export { AbsoluteLocation, BuildHandler, BuildHandlerArguments, BuildHandlerOptions, BuildHandlerOutput, BuildMiddleware, DeserializeHandler, DeserializeHandlerArguments, DeserializeHandlerOptions, DeserializeHandlerOutput, DeserializeMiddleware, FinalizeHandler, FinalizeHandlerArguments, FinalizeHandlerOutput, FinalizeRequestHandlerOptions, FinalizeRequestMiddleware, Handler, HandlerExecutionContext, HandlerOptions, InitializeHandler, InitializeHandlerArguments, InitializeHandlerOptions, InitializeHandlerOutput, InitializeMiddleware, MiddlewareStack, MiddlewareType, Pluggable, Priority, Relation, RelativeLocation, RelativeMiddlewareOptions, SerializeHandler, SerializeHandlerArguments, SerializeHandlerOptions, SerializeHandlerOutput, SerializeMiddleware, Step, Terminalware, } from "@smithy/types";
/**
 * @internal
 * Contains reserved keys for AWS SDK internal usage of the
 * handler execution context object.
 */
export interface AwsHandlerExecutionContext extends HandlerExecutionContext {
    __aws_sdk_context?: {
        features?: AwsSdkFeatures;
    };
}

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/pagination.d.ts

```typescript
export { PaginationConfiguration, Paginator } from "@smithy/types";

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/profile.d.ts

```typescript
export { IniSection, Profile, ParsedIniData, SharedConfigFiles } from "@smithy/types";

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/request.d.ts

```typescript
/**
 * @internal
 */
export interface Request {
    destination: URL;
    body?: any;
}

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/response.d.ts

```typescript
export { MetadataBearer, ResponseMetadata } from "@smithy/types";
/**
 * @internal
 */
export interface Response {
    body: any;
}

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/retry.d.ts

```typescript
export { ExponentialBackoffJitterType, ExponentialBackoffStrategyOptions, RetryBackoffStrategy, RetryErrorInfo, RetryErrorType, RetryStrategyOptions, RetryStrategyV2, RetryToken, StandardRetryBackoffStrategy, StandardRetryToken, } from "@smithy/types";

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/serde.d.ts

```typescript
export { EndpointBearer, StreamCollector, SerdeContext, ResponseDeserializer, RequestSerializer, SdkStreamMixin, SdkStream, WithSdkStreamMixin, SdkStreamMixinInjector, SdkStreamSerdeContext, } from "@smithy/types";
/**
 * @public
 *
 * Declare DOM interfaces in case dom.d.ts is not added to the tsconfig lib, causing
 * interfaces to not be defined. For developers with dom.d.ts added, the interfaces will
 * be merged correctly.
 *
 * This is also required for any clients with streaming interfaces where the corresponding
 * types are also referred. The type is only declared here once since this `@aws-sdk/types`
 * is depended by all `@aws-sdk` packages.
 */
declare global {
    /**
     * @public
     */
    export interface ReadableStream {
    }
    /**
     * @public
     */
    export interface Blob {
    }
}

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/shapes.d.ts

```typescript
export { DocumentType, RetryableTrait, SmithyException, SdkError } from "@smithy/types";

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/signature.d.ts

```typescript
export { DateInput, EventSigner, EventSigningArguments, FormattedEvent, MessageSigner, RequestSigningArguments, RequestPresigner, RequestPresigningArguments, RequestSigner, SignableMessage, SignedMessage, SigningArguments, StringSigner, } from "@smithy/types";

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/stream.d.ts

```typescript
export { GetAwsChunkedEncodingStream, GetAwsChunkedEncodingStreamOptions } from "@smithy/types";

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/token.d.ts

```typescript
import { TokenIdentity } from "./identity";
import { Provider } from "./util";
/**
 * @public
 *
 * An object representing temporary or permanent AWS token.
 *
 * @deprecated Use {@link TokenIdentity}
 */
export interface Token extends TokenIdentity {
}
/**
 * @public
 *
 * @deprecated Use {@link TokenIdentityProvider}
 */
export type TokenProvider = Provider<Token>;

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/transfer.d.ts

```typescript
export { RequestContext, RequestHandler, RequestHandlerMetadata, RequestHandlerOutput, RequestHandlerProtocol, } from "@smithy/types";

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/ts3.4/abort.d.ts

```typescript
export { AbortController, AbortHandler, AbortSignal } from "@smithy/types";

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/ts3.4/auth.d.ts

```typescript
export {
  AuthScheme,
  HttpAuthDefinition,
  HttpAuthLocation,
} from "@smithy/types";

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/ts3.4/blob/blob-types.d.ts

```typescript
import { BlobTypes } from "@smithy/types";
export { BlobTypes };

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/ts3.4/checksum.d.ts

```typescript
export { Checksum, ChecksumConstructor } from "@smithy/types";

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/ts3.4/client.d.ts

```typescript
export { Client } from "@smithy/types";

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/ts3.4/command.d.ts

```typescript
export { Command } from "@smithy/types";

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/ts3.4/connection.d.ts

```typescript
export {
  ConnectConfiguration,
  ConnectionManager,
  ConnectionManagerConfiguration,
  ConnectionPool,
} from "@smithy/types";

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/ts3.4/credentials.d.ts

```typescript
import { Logger } from "@smithy/types";
import { AwsCredentialIdentity } from "./identity";
import { Provider } from "./util";
export interface Credentials extends AwsCredentialIdentity {}
export type CredentialProvider = Provider<Credentials>;
export type CredentialProviderOptions = {
  logger?: Logger;
  parentClientConfig?: {
    region?: string | Provider<string>;
    profile?: string;
    [key: string]: unknown;
  };
};

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/ts3.4/crypto.d.ts

```typescript
export {
  Hash,
  HashConstructor,
  StreamHasher,
  randomValues,
  SourceData,
} from "@smithy/types";

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/ts3.4/dns.d.ts

```typescript
export declare enum HostAddressType {
  AAAA = "AAAA",
  A = "A",
}
export interface HostAddress {
  addressType: HostAddressType;
  address: string;
  hostName: string;
  service?: string;
}
export interface HostResolverArguments {
  hostName: string;
  service?: string;
}
export interface HostResolver {
  resolveAddress(args: HostResolverArguments): Promise<HostAddress[]>;
  reportFailureOnAddress(addr: HostAddress): void;
  purgeCache(args?: HostResolverArguments): void;
}

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/ts3.4/encode.d.ts

```typescript
export {
  MessageDecoder,
  MessageEncoder,
  AvailableMessage,
  AvailableMessages,
} from "@smithy/types";

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/ts3.4/endpoint.d.ts

```typescript
export {
  EndpointARN,
  EndpointPartition,
  EndpointURLScheme,
  EndpointURL,
  EndpointObjectProperty,
  EndpointV2,
  EndpointParameters,
} from "@smithy/types";

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/ts3.4/eventStream.d.ts

```typescript
export {
  Message,
  MessageHeaders,
  BooleanHeaderValue,
  ByteHeaderValue,
  ShortHeaderValue,
  IntegerHeaderValue,
  LongHeaderValue,
  BinaryHeaderValue,
  StringHeaderValue,
  TimestampHeaderValue,
  UuidHeaderValue,
  MessageHeaderValue,
  Int64,
  EventStreamSerdeContext,
  EventStreamMarshaller,
  EventStreamMarshallerDeserFn,
  EventStreamMarshallerSerFn,
  EventStreamPayloadHandler,
  EventStreamPayloadHandlerProvider,
  EventStreamRequestSigner,
  EventStreamSerdeProvider,
  EventStreamSignerProvider,
} from "@smithy/types";

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/ts3.4/extensions/index.d.ts

```typescript
import { Provider } from "@smithy/types";
export interface AwsRegionExtensionConfiguration {
  setRegion(region: Provider<string>): void;
  region(): Provider<string>;
}

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/ts3.4/feature-ids.d.ts

```typescript
export type AwsSdkFeatures = Partial<{
  RESOURCE_MODEL: "A";
  WAITER: "B";
  PAGINATOR: "C";
  RETRY_MODE_LEGACY: "D";
  RETRY_MODE_STANDARD: "E";
  RETRY_MODE_ADAPTIVE: "F";
  S3_EXPRESS_BUCKET: "J";
  S3_ACCESS_GRANTS: "K";
  GZIP_REQUEST_COMPRESSION: "L";
  PROTOCOL_RPC_V2_CBOR: "M";
  ENDPOINT_OVERRIDE: "N";
  ACCOUNT_ID_ENDPOINT: "O";
  ACCOUNT_ID_MODE_PREFERRED: "P";
  ACCOUNT_ID_MODE_DISABLED: "Q";
  ACCOUNT_ID_MODE_REQUIRED: "R";
  SIGV4A_SIGNING: "S";
  FLEXIBLE_CHECKSUMS_REQ_CRC32: "U";
  FLEXIBLE_CHECKSUMS_REQ_CRC32C: "V";
  FLEXIBLE_CHECKSUMS_REQ_CRC64: "W";
  FLEXIBLE_CHECKSUMS_REQ_SHA1: "X";
  FLEXIBLE_CHECKSUMS_REQ_SHA256: "Y";
  FLEXIBLE_CHECKSUMS_REQ_WHEN_SUPPORTED: "Z";
  FLEXIBLE_CHECKSUMS_REQ_WHEN_REQUIRED: "a";
  FLEXIBLE_CHECKSUMS_RES_WHEN_SUPPORTED: "b";
  FLEXIBLE_CHECKSUMS_RES_WHEN_REQUIRED: "c";
  DDB_MAPPER: "d";
}> &
  AwsSdkCredentialsFeatures &
  AwsSdkTokenFeatures;
export type AwsSdkCredentialsFeatures = Partial<{
  RESOLVED_ACCOUNT_ID: "T";
  CREDENTIALS_CODE: "e";
  CREDENTIALS_ENV_VARS: "g";
  CREDENTIALS_ENV_VARS_STS_WEB_ID_TOKEN: "h";
  CREDENTIALS_STS_ASSUME_ROLE: "i";
  CREDENTIALS_STS_ASSUME_ROLE_SAML: "j";
  CREDENTIALS_STS_ASSUME_ROLE_WEB_ID: "k";
  CREDENTIALS_STS_FEDERATION_TOKEN: "l";
  CREDENTIALS_STS_SESSION_TOKEN: "m";
  CREDENTIALS_PROFILE: "n";
  CREDENTIALS_PROFILE_SOURCE_PROFILE: "o";
  CREDENTIALS_PROFILE_NAMED_PROVIDER: "p";
  CREDENTIALS_PROFILE_STS_WEB_ID_TOKEN: "q";
  CREDENTIALS_PROFILE_SSO: "r";
  CREDENTIALS_SSO: "s";
  CREDENTIALS_PROFILE_SSO_LEGACY: "t";
  CREDENTIALS_SSO_LEGACY: "u";
  CREDENTIALS_PROFILE_PROCESS: "v";
  CREDENTIALS_PROCESS: "w";
  CREDENTIALS_BOTO2_CONFIG_FILE: "x";
  CREDENTIALS_AWS_SDK_STORE: "y";
  CREDENTIALS_HTTP: "z";
  CREDENTIALS_IMDS: "0";
}>;
export type AwsSdkTokenFeatures = Partial<{
  BEARER_SERVICE_ENV_VARS: "3";
}>;

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/ts3.4/function.d.ts

```typescript
export type MergeFunctions<F1, F2> = F1 extends (arg: infer A1) => infer R1
  ? F2 extends (arg: infer A2) => infer R2
    ? R1 extends Promise<unknown>
      ? (arg?: A1 & A2) => Promise<Awaited<R1> & Awaited<R2>>
      : (arg?: A1 & A2) => R1 & R2
    : never
  : never;

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/ts3.4/http.d.ts

```typescript
import { HttpResponse } from "@smithy/types";
export {
  Endpoint,
  HeaderBag,
  HttpHandlerOptions,
  HttpMessage,
  HttpRequest,
  HttpResponse,
  QueryParameterBag,
} from "@smithy/types";
export interface Headers extends Map<string, string> {
  withHeader(headerName: string, headerValue: string): Headers;
  withoutHeader(headerName: string): Headers;
}
export interface ResolvedHttpResponse extends HttpResponse {
  body: string;
}

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/ts3.4/identity/AnonymousIdentity.d.ts

```typescript
import { Identity } from "./Identity";
export interface AnonymousIdentity extends Identity {}

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/ts3.4/identity/AwsCredentialIdentity.d.ts

```typescript
import {
  AwsCredentialIdentity,
  AwsCredentialIdentityProvider,
  Logger,
  RequestHandler,
} from "@smithy/types";
import { AwsSdkCredentialsFeatures } from "../feature-ids";
export {
  AwsCredentialIdentity,
  AwsCredentialIdentityProvider,
  IdentityProvider,
} from "@smithy/types";
export interface AwsIdentityProperties {
  callerClientConfig?: {
    credentials?: AwsCredentialIdentity | AwsCredentialIdentityProvider;
    credentialDefaultProvider?: (input?: any) => AwsCredentialIdentityProvider;
    logger?: Logger;
    profile?: string;
    region(): Promise<string>;
    requestHandler?: RequestHandler<any, any>;
  };
}
export type RuntimeConfigIdentityProvider<T> = (
  awsIdentityProperties?: AwsIdentityProperties
) => Promise<T>;
export type RuntimeConfigAwsCredentialIdentityProvider =
  RuntimeConfigIdentityProvider<AwsCredentialIdentity>;
export type AttributedAwsCredentialIdentity = AwsCredentialIdentity & {
  $source?: AwsSdkCredentialsFeatures;
};

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/ts3.4/identity/Identity.d.ts

```typescript
export { Identity, IdentityProvider } from "@smithy/types";

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/ts3.4/identity/LoginIdentity.d.ts

```typescript
import { Identity, IdentityProvider } from "./Identity";
export interface LoginIdentity extends Identity {
  readonly username: string;
  readonly password: string;
}
export type LoginIdentityProvider = IdentityProvider<LoginIdentity>;

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/ts3.4/identity/TokenIdentity.d.ts

```typescript
import { TokenIdentity } from "@smithy/types";
import { AwsSdkTokenFeatures } from "../feature-ids";
export { TokenIdentity, TokenIdentityProvider } from "@smithy/types";
export type AttributedTokenIdentity = TokenIdentity & {
  $source?: AwsSdkTokenFeatures;
};

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/ts3.4/identity/index.d.ts

```typescript
export * from "./AnonymousIdentity";
export * from "./AwsCredentialIdentity";
export * from "./Identity";
export * from "./LoginIdentity";
export * from "./TokenIdentity";

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/ts3.4/index.d.ts

```typescript
export * from "./abort";
export * from "./auth";
export * from "./blob/blob-types";
export * from "./checksum";
export * from "./client";
export * from "./command";
export * from "./connection";
export * from "./credentials";
export * from "./crypto";
export * from "./dns";
export * from "./encode";
export * from "./endpoint";
export * from "./eventStream";
export * from "./extensions";
export * from "./feature-ids";
export * from "./function";
export * from "./http";
export * from "./identity";
export * from "./logger";
export * from "./middleware";
export * from "./pagination";
export * from "./profile";
export * from "./request";
export * from "./response";
export * from "./retry";
export * from "./serde";
export * from "./shapes";
export * from "./signature";
export * from "./stream";
export * from "./token";
export * from "./transfer";
export * from "./uri";
export * from "./util";
export * from "./waiter";

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/ts3.4/logger.d.ts

```typescript
import { Logger } from "@smithy/types";
export { Logger } from "@smithy/types";
export type LogLevel =
  | "all"
  | "trace"
  | "debug"
  | "log"
  | "info"
  | "warn"
  | "error"
  | "off";
export interface LoggerOptions {
  logger?: Logger;
  logLevel?: LogLevel;
}

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/ts3.4/middleware.d.ts

```typescript
import { HandlerExecutionContext } from "@smithy/types";
import { AwsSdkFeatures } from "./feature-ids";
export {
  AbsoluteLocation,
  BuildHandler,
  BuildHandlerArguments,
  BuildHandlerOptions,
  BuildHandlerOutput,
  BuildMiddleware,
  DeserializeHandler,
  DeserializeHandlerArguments,
  DeserializeHandlerOptions,
  DeserializeHandlerOutput,
  DeserializeMiddleware,
  FinalizeHandler,
  FinalizeHandlerArguments,
  FinalizeHandlerOutput,
  FinalizeRequestHandlerOptions,
  FinalizeRequestMiddleware,
  Handler,
  HandlerExecutionContext,
  HandlerOptions,
  InitializeHandler,
  InitializeHandlerArguments,
  InitializeHandlerOptions,
  InitializeHandlerOutput,
  InitializeMiddleware,
  MiddlewareStack,
  MiddlewareType,
  Pluggable,
  Priority,
  Relation,
  RelativeLocation,
  RelativeMiddlewareOptions,
  SerializeHandler,
  SerializeHandlerArguments,
  SerializeHandlerOptions,
  SerializeHandlerOutput,
  SerializeMiddleware,
  Step,
  Terminalware,
} from "@smithy/types";
export interface AwsHandlerExecutionContext extends HandlerExecutionContext {
  __aws_sdk_context?: {
    features?: AwsSdkFeatures;
  };
}

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/ts3.4/pagination.d.ts

```typescript
export { PaginationConfiguration, Paginator } from "@smithy/types";

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/ts3.4/profile.d.ts

```typescript
export {
  IniSection,
  Profile,
  ParsedIniData,
  SharedConfigFiles,
} from "@smithy/types";

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/ts3.4/request.d.ts

```typescript
export interface Request {
  destination: URL;
  body?: any;
}

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/ts3.4/response.d.ts

```typescript
export { MetadataBearer, ResponseMetadata } from "@smithy/types";
export interface Response {
  body: any;
}

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/ts3.4/retry.d.ts

```typescript
export {
  ExponentialBackoffJitterType,
  ExponentialBackoffStrategyOptions,
  RetryBackoffStrategy,
  RetryErrorInfo,
  RetryErrorType,
  RetryStrategyOptions,
  RetryStrategyV2,
  RetryToken,
  StandardRetryBackoffStrategy,
  StandardRetryToken,
} from "@smithy/types";

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/ts3.4/serde.d.ts

```typescript
export {
  EndpointBearer,
  StreamCollector,
  SerdeContext,
  ResponseDeserializer,
  RequestSerializer,
  SdkStreamMixin,
  SdkStream,
  WithSdkStreamMixin,
  SdkStreamMixinInjector,
  SdkStreamSerdeContext,
} from "@smithy/types";
declare global {
  export interface ReadableStream {}
  export interface Blob {}
}

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/ts3.4/shapes.d.ts

```typescript
export {
  DocumentType,
  RetryableTrait,
  SmithyException,
  SdkError,
} from "@smithy/types";

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/ts3.4/signature.d.ts

```typescript
export {
  DateInput,
  EventSigner,
  EventSigningArguments,
  FormattedEvent,
  MessageSigner,
  RequestSigningArguments,
  RequestPresigner,
  RequestPresigningArguments,
  RequestSigner,
  SignableMessage,
  SignedMessage,
  SigningArguments,
  StringSigner,
} from "@smithy/types";

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/ts3.4/stream.d.ts

```typescript
export {
  GetAwsChunkedEncodingStream,
  GetAwsChunkedEncodingStreamOptions,
} from "@smithy/types";

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/ts3.4/token.d.ts

```typescript
import { TokenIdentity } from "./identity";
import { Provider } from "./util";
export interface Token extends TokenIdentity {}
export type TokenProvider = Provider<Token>;

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/ts3.4/transfer.d.ts

```typescript
export {
  RequestContext,
  RequestHandler,
  RequestHandlerMetadata,
  RequestHandlerOutput,
  RequestHandlerProtocol,
} from "@smithy/types";

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/ts3.4/uri.d.ts

```typescript
export { URI } from "@smithy/types";

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/ts3.4/util.d.ts

```typescript
export {
  Encoder,
  Decoder,
  Provider,
  UserAgentPair,
  UserAgent,
  UrlParser,
  MemoizedProvider,
  BodyLengthCalculator,
  RegionInfo,
  RegionInfoProviderOptions,
  RegionInfoProvider,
  RetryStrategy,
} from "@smithy/types";

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/ts3.4/waiter.d.ts

```typescript
export { WaiterConfiguration } from "@smithy/types";

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/uri.d.ts

```typescript
export { URI } from "@smithy/types";

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/util.d.ts

```typescript
export { Encoder, Decoder, Provider, UserAgentPair, UserAgent, UrlParser, MemoizedProvider, BodyLengthCalculator, RegionInfo, RegionInfoProviderOptions, RegionInfoProvider, RetryStrategy, } from "@smithy/types";

```

## ./lib/lambda/node_modules/@aws-sdk/types/dist-types/waiter.d.ts

```typescript
export { WaiterConfiguration } from "@smithy/types";

```

## ./lib/lambda/node_modules/@aws-sdk/types/package.json

```json
{
  "name": "@aws-sdk/types",
  "version": "3.910.0",
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "description": "Types for the AWS SDK",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "node ../../scripts/compilation/inline types",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "extract:docs": "api-extractor run --local",
    "test": "tsc -p tsconfig.test.json"
  },
  "sideEffects": false,
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/aws/aws-sdk-js-v3/tree/main/packages/types",
  "repository": {
    "type": "git",
    "url": "https://github.com/aws/aws-sdk-js-v3.git",
    "directory": "packages/types"
  },
  "dependencies": {
    "@smithy/types": "^4.7.1",
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "@tsconfig/recommended": "1.0.1",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typescript": "~5.8.3"
  },
  "browser": {},
  "react-native": {}
}

```

## ./lib/lambda/node_modules/@aws-sdk/util-arn-parser/dist-types/index.d.ts

```typescript
export interface ARN {
    partition: string;
    service: string;
    region: string;
    accountId: string;
    resource: string;
}
/**
 * Validate whether a string is an ARN.
 */
export declare const validate: (str: any) => boolean;
/**
 * Parse an ARN string into structure with partition, service, region, accountId and resource values
 */
export declare const parse: (arn: string) => ARN;
type buildOptions = Omit<ARN, "partition"> & {
    partition?: string;
};
/**
 * Build an ARN with service, partition, region, accountId, and resources strings
 */
export declare const build: (arnObject: buildOptions) => string;
export {};

```

## ./lib/lambda/node_modules/@aws-sdk/util-arn-parser/dist-types/ts3.4/index.d.ts

```typescript
export interface ARN {
  partition: string;
  service: string;
  region: string;
  accountId: string;
  resource: string;
}
export declare const validate: (str: any) => boolean;
export declare const parse: (arn: string) => ARN;
type buildOptions = Pick<ARN, Exclude<keyof ARN, "partition">> & {
  partition?: string;
};
export declare const build: (arnObject: buildOptions) => string;
export {};

```

## ./lib/lambda/node_modules/@aws-sdk/util-arn-parser/package.json

```json
{
  "name": "@aws-sdk/util-arn-parser",
  "version": "3.893.0",
  "description": "A parser to Amazon Resource Names",
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "node ../../scripts/compilation/inline util-arn-parser",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch"
  },
  "sideEffects": false,
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "dependencies": {
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "@tsconfig/recommended": "1.0.1",
    "@types/node": "^18.19.69",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typescript": "~5.8.3"
  },
  "types": "./dist-types/index.d.ts",
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/aws/aws-sdk-js-v3/tree/main/packages/util-arn-parser",
  "repository": {
    "type": "git",
    "url": "https://github.com/aws/aws-sdk-js-v3.git",
    "directory": "packages/util-arn-parser"
  }
}

```

## ./lib/lambda/node_modules/@aws-sdk/util-dynamodb/dist-types/NumberValue.d.ts

```typescript
import { NumberValue as INumberValue } from "./models";
/**
 *
 * Class for storing DynamoDB numbers that exceed the scale of
 * JavaScript's MAX_SAFE_INTEGER and MIN_SAFE_INTEGER, or the
 * decimal precision limit.
 *
 * This class does not support mathematical operations in JavaScript.
 * Convert the contained string value to your application-specific
 * large number implementation to perform mathematical operations.
 *
 * @public
 *
 */
export declare class NumberValue implements INumberValue {
    value: string;
    /**
     * This class does not validate that your string input is a valid number.
     *
     * @param value - a precise number, or any BigInt or string, or AttributeValue.
     */
    constructor(value: number | Number | BigInt | string | {
        N: string;
    });
    /**
     * This class does not validate that your string input is a valid number.
     *
     * @param value - a precise number, or any BigInt or string, or AttributeValue.
     */
    static from(value: number | Number | BigInt | string | {
        N: string;
    }): NumberValue;
    /**
     * @returns the AttributeValue form for DynamoDB.
     */
    toAttributeValue(): {
        N: string;
    };
    /**
     * @returns BigInt representation.
     *
     * @throws SyntaxError if the string representation is not convertable to a BigInt.
     */
    toBigInt(): bigint;
    /**
     * @override
     *
     * @returns string representation. This is the canonical format in DynamoDB.
     */
    toString(): string;
    /**
     * @override
     */
    valueOf(): string;
}

```

## ./lib/lambda/node_modules/@aws-sdk/util-dynamodb/dist-types/convertToAttr.d.ts

```typescript
import { AttributeValue } from "@aws-sdk/client-dynamodb";
import { marshallOptions } from "./marshall";
import { NativeAttributeValue } from "./models";
/**
 * Convert a JavaScript value to its equivalent DynamoDB AttributeValue type.
 *
 * @param data - The data to convert to a DynamoDB AttributeValue.
 * @param options - An optional configuration object for `convertToAttr`.
 */
export declare const convertToAttr: (data: NativeAttributeValue, options?: marshallOptions) => AttributeValue;

```

## ./lib/lambda/node_modules/@aws-sdk/util-dynamodb/dist-types/convertToNative.d.ts

```typescript
import { AttributeValue } from "@aws-sdk/client-dynamodb";
import type { NativeAttributeValue } from "./models";
import { unmarshallOptions } from "./unmarshall";
/**
 * Convert a DynamoDB AttributeValue object to its equivalent JavaScript type.
 *
 * @param data - The DynamoDB record to convert to JavaScript type.
 * @param options - An optional configuration object for `convertToNative`.
 */
export declare const convertToNative: (data: AttributeValue, options?: unmarshallOptions) => NativeAttributeValue;

```

## ./lib/lambda/node_modules/@aws-sdk/util-dynamodb/dist-types/index.d.ts

```typescript
export { NumberValue as NumberValueImpl } from "./NumberValue";
export * from "./convertToAttr";
export * from "./convertToNative";
export * from "./marshall";
export * from "./models";
export * from "./unmarshall";

```

## ./lib/lambda/node_modules/@aws-sdk/util-dynamodb/dist-types/marshall.d.ts

```typescript
import { AttributeValue } from "@aws-sdk/client-dynamodb";
import { NativeAttributeBinary, NativeAttributeValue } from "./models";
import { NumberValue } from "./NumberValue";
/**
 * An optional configuration object for `marshall`
 */
export interface marshallOptions {
    /**
     * Whether to automatically convert empty strings, blobs, and sets to `null`
     */
    convertEmptyValues?: boolean;
    /**
     * Whether to remove undefined values from JS arrays/Sets/objects
     * when marshalling to DynamoDB lists/sets/maps respectively.
     *
     * A DynamoDB item is not itself considered a map. Only
     * attributes of an item are examined.
     */
    removeUndefinedValues?: boolean;
    /**
     * Whether to convert typeof object to map attribute.
     */
    convertClassInstanceToMap?: boolean;
    /**
     * Whether to convert the top level container
     * if it is a map or list.
     *
     * Default is true when using the DynamoDBDocumentClient,
     * but false if directly using the marshall function (backwards compatibility).
     */
    convertTopLevelContainer?: boolean;
    /**
     * Whether to allow numbers beyond Number.MAX_SAFE_INTEGER during marshalling.
     * When set to true, allows numbers that may lose precision when converted to JavaScript numbers.
     * When false (default), throws an error if a number exceeds Number.MAX_SAFE_INTEGER to prevent
     * unintended loss of precision. Consider using the NumberValue type from @aws-sdk/lib-dynamodb
     * for precise handling of large numbers.
     */
    allowImpreciseNumbers?: boolean;
}
/**
 * Convert a JavaScript object into a DynamoDB record.
 *
 * @param data - The data to convert to a DynamoDB record
 * @param options - An optional configuration object for `marshall`
 *
 */
export declare function marshall(data: null, options?: marshallOptions): AttributeValue.NULLMember;
export declare function marshall(data: Set<bigint> | Set<number> | Set<NumberValue>, options?: marshallOptions): AttributeValue.NSMember;
export declare function marshall(data: Set<string>, options?: marshallOptions): AttributeValue.SSMember;
export declare function marshall(data: Set<NativeAttributeBinary>, options?: marshallOptions): AttributeValue.BSMember;
export declare function marshall(data: NativeAttributeBinary, options?: marshallOptions): AttributeValue.BMember;
export declare function marshall(data: boolean, options?: marshallOptions): AttributeValue.BOOLMember;
export declare function marshall(data: number | NumberValue | bigint, options?: marshallOptions): AttributeValue.NMember;
export declare function marshall(data: string, options?: marshallOptions): AttributeValue.SMember;
export declare function marshall(data: boolean, options?: marshallOptions): AttributeValue.BOOLMember;
export declare function marshall<O extends {
    convertTopLevelContainer: true;
}>(data: NativeAttributeValue[], options: marshallOptions & O): AttributeValue.LMember;
export declare function marshall<O extends {
    convertTopLevelContainer: false;
}>(data: NativeAttributeValue[], options: marshallOptions & O): AttributeValue[];
export declare function marshall<O extends {
    convertTopLevelContainer: boolean;
}>(data: NativeAttributeValue[], options: marshallOptions & O): AttributeValue[] | AttributeValue.LMember;
export declare function marshall(data: NativeAttributeValue[], options?: marshallOptions): AttributeValue[];
export declare function marshall<O extends {
    convertTopLevelContainer: true;
}>(data: Map<string, NativeAttributeValue> | Record<string, NativeAttributeValue>, options: marshallOptions & O): AttributeValue.MMember;
export declare function marshall<O extends {
    convertTopLevelContainer: false;
}>(data: Map<string, NativeAttributeValue> | Record<string, NativeAttributeValue>, options: marshallOptions & O): Record<string, AttributeValue>;
export declare function marshall<O extends {
    convertTopLevelContainer: boolean;
}>(data: Map<string, NativeAttributeValue> | Record<string, NativeAttributeValue>, options: marshallOptions & O): Record<string, AttributeValue> | AttributeValue.MMember;
export declare function marshall(data: Map<string, NativeAttributeValue> | Record<string, NativeAttributeValue>, options?: marshallOptions): Record<string, AttributeValue>;
export declare function marshall(data: any, options?: marshallOptions): any;
/**
 * This signature will be unmatchable but is included for information.
 */
export declare function marshall(data: unknown, options?: marshallOptions): AttributeValue.$UnknownMember;

```

## ./lib/lambda/node_modules/@aws-sdk/util-dynamodb/dist-types/models.d.ts

```typescript
/**
 * A interface recognizable as a numeric value that stores the underlying number
 * as a string.
 *
 * Intended to be a deserialization target for the DynamoDB Document Client when
 * the `wrapNumbers` flag is set. This allows for numeric values that lose
 * precision when converted to JavaScript's `number` type.
 */
export interface NumberValue {
    readonly value: string;
}
/**
 * @public
 */
export type NativeAttributeValue = NativeScalarAttributeValue | {
    [key: string]: NativeAttributeValue;
} | NativeAttributeValue[] | Set<number | bigint | NumberValue | string | NativeAttributeBinary | undefined> | InstanceType<{
    new (...args: any[]): any;
}>;
/**
 * @public
 */
export type NativeScalarAttributeValue = null | undefined | boolean | number | NumberValue | bigint | NativeAttributeBinary | string;
/**
 * Declare File in case DOM is not added to the tsconfig lib causing
 * File interface is not defined. For developers with DOM lib added,
 * the File interface will be merged correctly.
 */
declare global {
    interface File {
    }
}
type IfDefined<T> = {} extends T ? never : T;
/**
 * @public
 */
export type NativeAttributeBinary = ArrayBuffer | IfDefined<Blob> | IfDefined<Buffer> | DataView | IfDefined<File> | Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array | BigInt64Array | BigUint64Array;
export {};

```

## ./lib/lambda/node_modules/@aws-sdk/util-dynamodb/dist-types/ts3.4/NumberValue.d.ts

```typescript
import { NumberValue as INumberValue } from "./models";
export declare class NumberValue implements INumberValue {
  value: string;
  constructor(
    value:
      | number
      | Number
      | BigInt
      | string
      | {
          N: string;
        }
  );
  static from(
    value:
      | number
      | Number
      | BigInt
      | string
      | {
          N: string;
        }
  ): NumberValue;
  toAttributeValue(): {
    N: string;
  };
  toBigInt(): bigint;
  toString(): string;
  valueOf(): string;
}

```

## ./lib/lambda/node_modules/@aws-sdk/util-dynamodb/dist-types/ts3.4/convertToAttr.d.ts

```typescript
import { AttributeValue } from "@aws-sdk/client-dynamodb";
import { marshallOptions } from "./marshall";
import { NativeAttributeValue } from "./models";
export declare const convertToAttr: (
  data: NativeAttributeValue,
  options?: marshallOptions
) => AttributeValue;

```

## ./lib/lambda/node_modules/@aws-sdk/util-dynamodb/dist-types/ts3.4/convertToNative.d.ts

```typescript
import { AttributeValue } from "@aws-sdk/client-dynamodb";
import { NativeAttributeValue } from "./models";
import { unmarshallOptions } from "./unmarshall";
export declare const convertToNative: (
  data: AttributeValue,
  options?: unmarshallOptions
) => NativeAttributeValue;

```

## ./lib/lambda/node_modules/@aws-sdk/util-dynamodb/dist-types/ts3.4/index.d.ts

```typescript
export { NumberValue as NumberValueImpl } from "./NumberValue";
export * from "./convertToAttr";
export * from "./convertToNative";
export * from "./marshall";
export * from "./models";
export * from "./unmarshall";

```

## ./lib/lambda/node_modules/@aws-sdk/util-dynamodb/dist-types/ts3.4/marshall.d.ts

```typescript
import { AttributeValue } from "@aws-sdk/client-dynamodb";
import { NativeAttributeBinary, NativeAttributeValue } from "./models";
import { NumberValue } from "./NumberValue";
export interface marshallOptions {
  convertEmptyValues?: boolean;
  removeUndefinedValues?: boolean;
  convertClassInstanceToMap?: boolean;
  convertTopLevelContainer?: boolean;
  allowImpreciseNumbers?: boolean;
}
export declare function marshall(
  data: null,
  options?: marshallOptions
): AttributeValue.NULLMember;
export declare function marshall(
  data: Set<bigint> | Set<number> | Set<NumberValue>,
  options?: marshallOptions
): AttributeValue.NSMember;
export declare function marshall(
  data: Set<string>,
  options?: marshallOptions
): AttributeValue.SSMember;
export declare function marshall(
  data: Set<NativeAttributeBinary>,
  options?: marshallOptions
): AttributeValue.BSMember;
export declare function marshall(
  data: NativeAttributeBinary,
  options?: marshallOptions
): AttributeValue.BMember;
export declare function marshall(
  data: boolean,
  options?: marshallOptions
): AttributeValue.BOOLMember;
export declare function marshall(
  data: number | NumberValue | bigint,
  options?: marshallOptions
): AttributeValue.NMember;
export declare function marshall(
  data: string,
  options?: marshallOptions
): AttributeValue.SMember;
export declare function marshall(
  data: boolean,
  options?: marshallOptions
): AttributeValue.BOOLMember;
export declare function marshall<
  O extends {
    convertTopLevelContainer: true;
  }
>(
  data: NativeAttributeValue[],
  options: marshallOptions & O
): AttributeValue.LMember;
export declare function marshall<
  O extends {
    convertTopLevelContainer: false;
  }
>(data: NativeAttributeValue[], options: marshallOptions & O): AttributeValue[];
export declare function marshall<
  O extends {
    convertTopLevelContainer: boolean;
  }
>(
  data: NativeAttributeValue[],
  options: marshallOptions & O
): AttributeValue[] | AttributeValue.LMember;
export declare function marshall(
  data: NativeAttributeValue[],
  options?: marshallOptions
): AttributeValue[];
export declare function marshall<
  O extends {
    convertTopLevelContainer: true;
  }
>(
  data:
    | Map<string, NativeAttributeValue>
    | Record<string, NativeAttributeValue>,
  options: marshallOptions & O
): AttributeValue.MMember;
export declare function marshall<
  O extends {
    convertTopLevelContainer: false;
  }
>(
  data:
    | Map<string, NativeAttributeValue>
    | Record<string, NativeAttributeValue>,
  options: marshallOptions & O
): Record<string, AttributeValue>;
export declare function marshall<
  O extends {
    convertTopLevelContainer: boolean;
  }
>(
  data:
    | Map<string, NativeAttributeValue>
    | Record<string, NativeAttributeValue>,
  options: marshallOptions & O
): Record<string, AttributeValue> | AttributeValue.MMember;
export declare function marshall(
  data:
    | Map<string, NativeAttributeValue>
    | Record<string, NativeAttributeValue>,
  options?: marshallOptions
): Record<string, AttributeValue>;
export declare function marshall(data: any, options?: marshallOptions): any;
export declare function marshall(
  data: unknown,
  options?: marshallOptions
): AttributeValue.$UnknownMember;

```

## ./lib/lambda/node_modules/@aws-sdk/util-dynamodb/dist-types/ts3.4/models.d.ts

```typescript
export interface NumberValue {
  readonly value: string;
}
export type NativeAttributeValue =
  | NativeScalarAttributeValue
  | {
      [key: string]: NativeAttributeValue;
    }
  | NativeAttributeValue[]
  | Set<
      number | bigint | NumberValue | string | NativeAttributeBinary | undefined
    >
  | InstanceType<{
      new (...args: any[]): any;
    }>;
export type NativeScalarAttributeValue =
  | null
  | undefined
  | boolean
  | number
  | NumberValue
  | bigint
  | NativeAttributeBinary
  | string;
declare global {
  interface File {}
}
type IfDefined<T> = {} extends T ? never : T;
export type NativeAttributeBinary =
  | ArrayBuffer
  | IfDefined<Blob>
  | IfDefined<Buffer>
  | DataView
  | IfDefined<File>
  | Int8Array
  | Uint8Array
  | Uint8ClampedArray
  | Int16Array
  | Uint16Array
  | Int32Array
  | Uint32Array
  | Float32Array
  | Float64Array
  | BigInt64Array
  | BigUint64Array;
export {};

```

## ./lib/lambda/node_modules/@aws-sdk/util-dynamodb/dist-types/ts3.4/unmarshall.d.ts

```typescript
import { AttributeValue } from "@aws-sdk/client-dynamodb";
import { NativeAttributeValue } from "./models";
import { NumberValue } from "./NumberValue";
export interface unmarshallOptions {
  wrapNumbers?:
    | boolean
    | ((value: string) => number | bigint | NumberValue | any);
  convertWithoutMapWrapper?: boolean;
}
export declare const unmarshall: (
  data: Record<string, AttributeValue> | AttributeValue,
  options?: unmarshallOptions
) => Record<string, NativeAttributeValue>;

```

## ./lib/lambda/node_modules/@aws-sdk/util-dynamodb/dist-types/unmarshall.d.ts

```typescript
import { AttributeValue } from "@aws-sdk/client-dynamodb";
import { NativeAttributeValue } from "./models";
import { NumberValue } from "./NumberValue";
/**
 * An optional configuration object for `convertToNative`
 */
export interface unmarshallOptions {
    /**
     * Whether to modify how numbers are unmarshalled from DynamoDB.
     * When set to true, returns numbers as NumberValue instances instead of native JavaScript numbers.
     * This allows for the safe round-trip transport of numbers of arbitrary size.
     *
     * If a function is provided, it will be called with the string representation of numbers to handle
     * custom conversions (e.g., using BigInt or decimal libraries).
     */
    wrapNumbers?: boolean | ((value: string) => number | bigint | NumberValue | any);
    /**
     * When true, skip wrapping the data in `{ M: data }` before converting.
     *
     * Default is true when using the DynamoDBDocumentClient,
     * but false if directly using the unmarshall function (backwards compatibility).
     */
    convertWithoutMapWrapper?: boolean;
}
/**
 * Convert a DynamoDB record into a JavaScript object.
 *
 * @param data - The DynamoDB record
 * @param options - An optional configuration object for `unmarshall`
 */
export declare const unmarshall: (data: Record<string, AttributeValue> | AttributeValue, options?: unmarshallOptions) => Record<string, NativeAttributeValue>;

```

## ./lib/lambda/node_modules/@aws-sdk/util-dynamodb/package.json

```json
{
  "name": "@aws-sdk/util-dynamodb",
  "version": "3.911.0",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "node ../../scripts/compilation/inline util-dynamodb",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "extract:docs": "api-extractor run --local",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "sideEffects": false,
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "dependencies": {
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "@aws-sdk/client-dynamodb": "3.911.0",
    "@tsconfig/recommended": "1.0.1",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typescript": "~5.8.3"
  },
  "peerDependencies": {
    "@aws-sdk/client-dynamodb": "^3.911.0"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/aws/aws-sdk-js-v3/tree/main/packages/util-dynamodb",
  "repository": {
    "type": "git",
    "url": "https://github.com/aws/aws-sdk-js-v3.git",
    "directory": "packages/util-dynamodb"
  }
}

```

## ./lib/lambda/node_modules/@aws-sdk/util-endpoints/dist-cjs/lib/aws/partitions.json

```json
{
    "partitions": [{
            "id": "aws",
            "outputs": {
                "dnsSuffix": "amazonaws.com",
                "dualStackDnsSuffix": "api.aws",
                "implicitGlobalRegion": "us-east-1",
                "name": "aws",
                "supportsDualStack": true,
                "supportsFIPS": true
            },
            "regionRegex": "^(us|eu|ap|sa|ca|me|af|il|mx)\\-\\w+\\-\\d+$",
            "regions": {
                "af-south-1": {
                    "description": "Africa (Cape Town)"
                },
                "ap-east-1": {
                    "description": "Asia Pacific (Hong Kong)"
                },
                "ap-east-2": {
                    "description": "Asia Pacific (Taipei)"
                },
                "ap-northeast-1": {
                    "description": "Asia Pacific (Tokyo)"
                },
                "ap-northeast-2": {
                    "description": "Asia Pacific (Seoul)"
                },
                "ap-northeast-3": {
                    "description": "Asia Pacific (Osaka)"
                },
                "ap-south-1": {
                    "description": "Asia Pacific (Mumbai)"
                },
                "ap-south-2": {
                    "description": "Asia Pacific (Hyderabad)"
                },
                "ap-southeast-1": {
                    "description": "Asia Pacific (Singapore)"
                },
                "ap-southeast-2": {
                    "description": "Asia Pacific (Sydney)"
                },
                "ap-southeast-3": {
                    "description": "Asia Pacific (Jakarta)"
                },
                "ap-southeast-4": {
                    "description": "Asia Pacific (Melbourne)"
                },
                "ap-southeast-5": {
                    "description": "Asia Pacific (Malaysia)"
                },
                "ap-southeast-6": {
                    "description": "Asia Pacific (New Zealand)"
                },
                "ap-southeast-7": {
                    "description": "Asia Pacific (Thailand)"
                },
                "aws-global": {
                    "description": "aws global region"
                },
                "ca-central-1": {
                    "description": "Canada (Central)"
                },
                "ca-west-1": {
                    "description": "Canada West (Calgary)"
                },
                "eu-central-1": {
                    "description": "Europe (Frankfurt)"
                },
                "eu-central-2": {
                    "description": "Europe (Zurich)"
                },
                "eu-north-1": {
                    "description": "Europe (Stockholm)"
                },
                "eu-south-1": {
                    "description": "Europe (Milan)"
                },
                "eu-south-2": {
                    "description": "Europe (Spain)"
                },
                "eu-west-1": {
                    "description": "Europe (Ireland)"
                },
                "eu-west-2": {
                    "description": "Europe (London)"
                },
                "eu-west-3": {
                    "description": "Europe (Paris)"
                },
                "il-central-1": {
                    "description": "Israel (Tel Aviv)"
                },
                "me-central-1": {
                    "description": "Middle East (UAE)"
                },
                "me-south-1": {
                    "description": "Middle East (Bahrain)"
                },
                "mx-central-1": {
                    "description": "Mexico (Central)"
                },
                "sa-east-1": {
                    "description": "South America (Sao Paulo)"
                },
                "us-east-1": {
                    "description": "US East (N. Virginia)"
                },
                "us-east-2": {
                    "description": "US East (Ohio)"
                },
                "us-west-1": {
                    "description": "US West (N. California)"
                },
                "us-west-2": {
                    "description": "US West (Oregon)"
                }
            }
        }, {
            "id": "aws-cn",
            "outputs": {
                "dnsSuffix": "amazonaws.com.cn",
                "dualStackDnsSuffix": "api.amazonwebservices.com.cn",
                "implicitGlobalRegion": "cn-northwest-1",
                "name": "aws-cn",
                "supportsDualStack": true,
                "supportsFIPS": true
            },
            "regionRegex": "^cn\\-\\w+\\-\\d+$",
            "regions": {
                "aws-cn-global": {
                    "description": "aws-cn global region"
                },
                "cn-north-1": {
                    "description": "China (Beijing)"
                },
                "cn-northwest-1": {
                    "description": "China (Ningxia)"
                }
            }
        }, {
            "id": "aws-eusc",
            "outputs": {
                "dnsSuffix": "amazonaws.eu",
                "dualStackDnsSuffix": "api.amazonwebservices.eu",
                "implicitGlobalRegion": "eusc-de-east-1",
                "name": "aws-eusc",
                "supportsDualStack": true,
                "supportsFIPS": true
            },
            "regionRegex": "^eusc\\-(de)\\-\\w+\\-\\d+$",
            "regions": {
                "eusc-de-east-1": {
                    "description": "EU (Germany)"
                }
            }
        }, {
            "id": "aws-iso",
            "outputs": {
                "dnsSuffix": "c2s.ic.gov",
                "dualStackDnsSuffix": "api.aws.ic.gov",
                "implicitGlobalRegion": "us-iso-east-1",
                "name": "aws-iso",
                "supportsDualStack": true,
                "supportsFIPS": true
            },
            "regionRegex": "^us\\-iso\\-\\w+\\-\\d+$",
            "regions": {
                "aws-iso-global": {
                    "description": "aws-iso global region"
                },
                "us-iso-east-1": {
                    "description": "US ISO East"
                },
                "us-iso-west-1": {
                    "description": "US ISO WEST"
                }
            }
        }, {
            "id": "aws-iso-b",
            "outputs": {
                "dnsSuffix": "sc2s.sgov.gov",
                "dualStackDnsSuffix": "api.aws.scloud",
                "implicitGlobalRegion": "us-isob-east-1",
                "name": "aws-iso-b",
                "supportsDualStack": true,
                "supportsFIPS": true
            },
            "regionRegex": "^us\\-isob\\-\\w+\\-\\d+$",
            "regions": {
                "aws-iso-b-global": {
                    "description": "aws-iso-b global region"
                },
                "us-isob-east-1": {
                    "description": "US ISOB East (Ohio)"
                }
            }
        }, {
            "id": "aws-iso-e",
            "outputs": {
                "dnsSuffix": "cloud.adc-e.uk",
                "dualStackDnsSuffix": "api.cloud-aws.adc-e.uk",
                "implicitGlobalRegion": "eu-isoe-west-1",
                "name": "aws-iso-e",
                "supportsDualStack": true,
                "supportsFIPS": true
            },
            "regionRegex": "^eu\\-isoe\\-\\w+\\-\\d+$",
            "regions": {
                "aws-iso-e-global": {
                    "description": "aws-iso-e global region"
                },
                "eu-isoe-west-1": {
                    "description": "EU ISOE West"
                }
            }
        }, {
            "id": "aws-iso-f",
            "outputs": {
                "dnsSuffix": "csp.hci.ic.gov",
                "dualStackDnsSuffix": "api.aws.hci.ic.gov",
                "implicitGlobalRegion": "us-isof-south-1",
                "name": "aws-iso-f",
                "supportsDualStack": true,
                "supportsFIPS": true
            },
            "regionRegex": "^us\\-isof\\-\\w+\\-\\d+$",
            "regions": {
                "aws-iso-f-global": {
                    "description": "aws-iso-f global region"
                },
                "us-isof-east-1": {
                    "description": "US ISOF EAST"
                },
                "us-isof-south-1": {
                    "description": "US ISOF SOUTH"
                }
            }
        }, {
            "id": "aws-us-gov",
            "outputs": {
                "dnsSuffix": "amazonaws.com",
                "dualStackDnsSuffix": "api.aws",
                "implicitGlobalRegion": "us-gov-west-1",
                "name": "aws-us-gov",
                "supportsDualStack": true,
                "supportsFIPS": true
            },
            "regionRegex": "^us\\-gov\\-\\w+\\-\\d+$",
            "regions": {
                "aws-us-gov-global": {
                    "description": "aws-us-gov global region"
                },
                "us-gov-east-1": {
                    "description": "AWS GovCloud (US-East)"
                },
                "us-gov-west-1": {
                    "description": "AWS GovCloud (US-West)"
                }
            }
        }],
    "version": "1.1"
}

```

## ./lib/lambda/node_modules/@aws-sdk/util-endpoints/dist-es/lib/aws/partitions.json

```json
{
    "partitions": [{
            "id": "aws",
            "outputs": {
                "dnsSuffix": "amazonaws.com",
                "dualStackDnsSuffix": "api.aws",
                "implicitGlobalRegion": "us-east-1",
                "name": "aws",
                "supportsDualStack": true,
                "supportsFIPS": true
            },
            "regionRegex": "^(us|eu|ap|sa|ca|me|af|il|mx)\\-\\w+\\-\\d+$",
            "regions": {
                "af-south-1": {
                    "description": "Africa (Cape Town)"
                },
                "ap-east-1": {
                    "description": "Asia Pacific (Hong Kong)"
                },
                "ap-east-2": {
                    "description": "Asia Pacific (Taipei)"
                },
                "ap-northeast-1": {
                    "description": "Asia Pacific (Tokyo)"
                },
                "ap-northeast-2": {
                    "description": "Asia Pacific (Seoul)"
                },
                "ap-northeast-3": {
                    "description": "Asia Pacific (Osaka)"
                },
                "ap-south-1": {
                    "description": "Asia Pacific (Mumbai)"
                },
                "ap-south-2": {
                    "description": "Asia Pacific (Hyderabad)"
                },
                "ap-southeast-1": {
                    "description": "Asia Pacific (Singapore)"
                },
                "ap-southeast-2": {
                    "description": "Asia Pacific (Sydney)"
                },
                "ap-southeast-3": {
                    "description": "Asia Pacific (Jakarta)"
                },
                "ap-southeast-4": {
                    "description": "Asia Pacific (Melbourne)"
                },
                "ap-southeast-5": {
                    "description": "Asia Pacific (Malaysia)"
                },
                "ap-southeast-6": {
                    "description": "Asia Pacific (New Zealand)"
                },
                "ap-southeast-7": {
                    "description": "Asia Pacific (Thailand)"
                },
                "aws-global": {
                    "description": "aws global region"
                },
                "ca-central-1": {
                    "description": "Canada (Central)"
                },
                "ca-west-1": {
                    "description": "Canada West (Calgary)"
                },
                "eu-central-1": {
                    "description": "Europe (Frankfurt)"
                },
                "eu-central-2": {
                    "description": "Europe (Zurich)"
                },
                "eu-north-1": {
                    "description": "Europe (Stockholm)"
                },
                "eu-south-1": {
                    "description": "Europe (Milan)"
                },
                "eu-south-2": {
                    "description": "Europe (Spain)"
                },
                "eu-west-1": {
                    "description": "Europe (Ireland)"
                },
                "eu-west-2": {
                    "description": "Europe (London)"
                },
                "eu-west-3": {
                    "description": "Europe (Paris)"
                },
                "il-central-1": {
                    "description": "Israel (Tel Aviv)"
                },
                "me-central-1": {
                    "description": "Middle East (UAE)"
                },
                "me-south-1": {
                    "description": "Middle East (Bahrain)"
                },
                "mx-central-1": {
                    "description": "Mexico (Central)"
                },
                "sa-east-1": {
                    "description": "South America (Sao Paulo)"
                },
                "us-east-1": {
                    "description": "US East (N. Virginia)"
                },
                "us-east-2": {
                    "description": "US East (Ohio)"
                },
                "us-west-1": {
                    "description": "US West (N. California)"
                },
                "us-west-2": {
                    "description": "US West (Oregon)"
                }
            }
        }, {
            "id": "aws-cn",
            "outputs": {
                "dnsSuffix": "amazonaws.com.cn",
                "dualStackDnsSuffix": "api.amazonwebservices.com.cn",
                "implicitGlobalRegion": "cn-northwest-1",
                "name": "aws-cn",
                "supportsDualStack": true,
                "supportsFIPS": true
            },
            "regionRegex": "^cn\\-\\w+\\-\\d+$",
            "regions": {
                "aws-cn-global": {
                    "description": "aws-cn global region"
                },
                "cn-north-1": {
                    "description": "China (Beijing)"
                },
                "cn-northwest-1": {
                    "description": "China (Ningxia)"
                }
            }
        }, {
            "id": "aws-eusc",
            "outputs": {
                "dnsSuffix": "amazonaws.eu",
                "dualStackDnsSuffix": "api.amazonwebservices.eu",
                "implicitGlobalRegion": "eusc-de-east-1",
                "name": "aws-eusc",
                "supportsDualStack": true,
                "supportsFIPS": true
            },
            "regionRegex": "^eusc\\-(de)\\-\\w+\\-\\d+$",
            "regions": {
                "eusc-de-east-1": {
                    "description": "EU (Germany)"
                }
            }
        }, {
            "id": "aws-iso",
            "outputs": {
                "dnsSuffix": "c2s.ic.gov",
                "dualStackDnsSuffix": "api.aws.ic.gov",
                "implicitGlobalRegion": "us-iso-east-1",
                "name": "aws-iso",
                "supportsDualStack": true,
                "supportsFIPS": true
            },
            "regionRegex": "^us\\-iso\\-\\w+\\-\\d+$",
            "regions": {
                "aws-iso-global": {
                    "description": "aws-iso global region"
                },
                "us-iso-east-1": {
                    "description": "US ISO East"
                },
                "us-iso-west-1": {
                    "description": "US ISO WEST"
                }
            }
        }, {
            "id": "aws-iso-b",
            "outputs": {
                "dnsSuffix": "sc2s.sgov.gov",
                "dualStackDnsSuffix": "api.aws.scloud",
                "implicitGlobalRegion": "us-isob-east-1",
                "name": "aws-iso-b",
                "supportsDualStack": true,
                "supportsFIPS": true
            },
            "regionRegex": "^us\\-isob\\-\\w+\\-\\d+$",
            "regions": {
                "aws-iso-b-global": {
                    "description": "aws-iso-b global region"
                },
                "us-isob-east-1": {
                    "description": "US ISOB East (Ohio)"
                }
            }
        }, {
            "id": "aws-iso-e",
            "outputs": {
                "dnsSuffix": "cloud.adc-e.uk",
                "dualStackDnsSuffix": "api.cloud-aws.adc-e.uk",
                "implicitGlobalRegion": "eu-isoe-west-1",
                "name": "aws-iso-e",
                "supportsDualStack": true,
                "supportsFIPS": true
            },
            "regionRegex": "^eu\\-isoe\\-\\w+\\-\\d+$",
            "regions": {
                "aws-iso-e-global": {
                    "description": "aws-iso-e global region"
                },
                "eu-isoe-west-1": {
                    "description": "EU ISOE West"
                }
            }
        }, {
            "id": "aws-iso-f",
            "outputs": {
                "dnsSuffix": "csp.hci.ic.gov",
                "dualStackDnsSuffix": "api.aws.hci.ic.gov",
                "implicitGlobalRegion": "us-isof-south-1",
                "name": "aws-iso-f",
                "supportsDualStack": true,
                "supportsFIPS": true
            },
            "regionRegex": "^us\\-isof\\-\\w+\\-\\d+$",
            "regions": {
                "aws-iso-f-global": {
                    "description": "aws-iso-f global region"
                },
                "us-isof-east-1": {
                    "description": "US ISOF EAST"
                },
                "us-isof-south-1": {
                    "description": "US ISOF SOUTH"
                }
            }
        }, {
            "id": "aws-us-gov",
            "outputs": {
                "dnsSuffix": "amazonaws.com",
                "dualStackDnsSuffix": "api.aws",
                "implicitGlobalRegion": "us-gov-west-1",
                "name": "aws-us-gov",
                "supportsDualStack": true,
                "supportsFIPS": true
            },
            "regionRegex": "^us\\-gov\\-\\w+\\-\\d+$",
            "regions": {
                "aws-us-gov-global": {
                    "description": "aws-us-gov global region"
                },
                "us-gov-east-1": {
                    "description": "AWS GovCloud (US-East)"
                },
                "us-gov-west-1": {
                    "description": "AWS GovCloud (US-West)"
                }
            }
        }],
    "version": "1.1"
}

```

## ./lib/lambda/node_modules/@aws-sdk/util-endpoints/dist-types/aws.d.ts

```typescript
import { EndpointFunctions } from "@smithy/util-endpoints";
export declare const awsEndpointFunctions: EndpointFunctions;

```

## ./lib/lambda/node_modules/@aws-sdk/util-endpoints/dist-types/index.d.ts

```typescript
export * from "./aws";
export * from "./lib/aws/partition";
export * from "./lib/isIpAddress";
export * from "./resolveDefaultAwsRegionalEndpointsConfig";
export * from "./resolveEndpoint";
export * from "./types";

```

## ./lib/lambda/node_modules/@aws-sdk/util-endpoints/dist-types/lib/aws/index.d.ts

```typescript
export * from "./isVirtualHostableS3Bucket";
export * from "./parseArn";
export * from "./partition";

```

## ./lib/lambda/node_modules/@aws-sdk/util-endpoints/dist-types/lib/aws/isVirtualHostableS3Bucket.d.ts

```typescript
/**
 * Evaluates whether a string is a DNS compatible bucket name and can be used with
 * virtual hosted style addressing.
 */
export declare const isVirtualHostableS3Bucket: (value: string, allowSubDomains?: boolean) => boolean;

```

## ./lib/lambda/node_modules/@aws-sdk/util-endpoints/dist-types/lib/aws/parseArn.d.ts

```typescript
import { EndpointARN } from "@smithy/types";
/**
 * Evaluates a single string argument value, and returns an object containing
 * details about the parsed ARN.
 * If the input was not a valid ARN, the function returns null.
 */
export declare const parseArn: (value: string) => EndpointARN | null;

```

## ./lib/lambda/node_modules/@aws-sdk/util-endpoints/dist-types/lib/aws/partition.d.ts

```typescript
import { EndpointPartition } from "@smithy/types";
export type PartitionsInfo = {
    partitions: Array<{
        id: string;
        outputs: {
            dnsSuffix: string;
            dualStackDnsSuffix: string;
            name: string;
            supportsDualStack: boolean;
            supportsFIPS: boolean;
        };
        regionRegex: string;
        regions: Record<string, {
            description?: string;
        } | undefined>;
    }>;
};
/**
 * Evaluates a single string argument value as a region, and matches the
 * string value to an AWS partition.
 * The matcher MUST always return a successful object describing the partition
 * that the region has been determined to be a part of.
 */
export declare const partition: (value: string) => EndpointPartition;
/**
 * Set custom partitions.json data.
 * @internal
 */
export declare const setPartitionInfo: (partitionsInfo: PartitionsInfo, userAgentPrefix?: string) => void;
/**
 * Reset to the default partitions.json data.
 * @internal
 */
export declare const useDefaultPartitionInfo: () => void;
/**
 * @internal
 */
export declare const getUserAgentPrefix: () => string;

```

## ./lib/lambda/node_modules/@aws-sdk/util-endpoints/dist-types/lib/isIpAddress.d.ts

```typescript
export { isIpAddress } from "@smithy/util-endpoints";

```

## ./lib/lambda/node_modules/@aws-sdk/util-endpoints/dist-types/resolveDefaultAwsRegionalEndpointsConfig.d.ts

```typescript
import type { Endpoint, EndpointParameters, EndpointV2, Logger, Provider } from "@smithy/types";
/**
 * This is an additional config resolver layer for clients using the default
 * AWS regional endpoints ruleset. It makes the *resolved* config guarantee the presence of an
 * endpoint provider function. This differs from the base behavior of the Endpoint
 * config resolver, which only normalizes config.endpoint IFF one is provided by the caller.
 *
 * This is not used by AWS SDK clients, but rather
 * generated clients that have the aws.api#service trait. This includes protocol tests
 * and other customers.
 *
 * This resolver is MUTUALLY EXCLUSIVE with the EndpointRequired config resolver from
 * |@smithy/middleware-endpoint.
 *
 * It must be placed after the `resolveEndpointConfig`
 * resolver. This replaces the endpoints.json-based default endpoint provider.
 *
 * @public
 */
export type DefaultAwsRegionalEndpointsInputConfig = {
    endpoint?: unknown;
};
type PreviouslyResolved = {
    logger?: Logger;
    region?: undefined | string | Provider<string | undefined>;
    useFipsEndpoint?: undefined | boolean | Provider<string | boolean>;
    useDualstackEndpoint?: undefined | boolean | Provider<string | boolean>;
    endpointProvider: (endpointParams: EndpointParameters | DefaultRegionalEndpointParameters, context?: {
        logger?: Logger;
    }) => EndpointV2;
};
/**
 * @internal
 */
type DefaultRegionalEndpointParameters = {
    Region?: string | undefined;
    UseDualStack?: boolean | undefined;
    UseFIPS?: boolean | undefined;
};
/**
 * @internal
 */
export interface DefaultAwsRegionalEndpointsResolvedConfig {
    endpoint: Provider<Endpoint>;
}
/**
 * MUST resolve after `\@smithy/middleware-endpoint`::`resolveEndpointConfig`.
 *
 * @internal
 */
export declare const resolveDefaultAwsRegionalEndpointsConfig: <T>(input: T & DefaultAwsRegionalEndpointsInputConfig & PreviouslyResolved) => T & DefaultAwsRegionalEndpointsResolvedConfig;
/**
 * @internal
 */
export declare const toEndpointV1: (endpoint: EndpointV2) => Endpoint;
export {};

```

## ./lib/lambda/node_modules/@aws-sdk/util-endpoints/dist-types/resolveEndpoint.d.ts

```typescript
export { resolveEndpoint } from "@smithy/util-endpoints";

```

## ./lib/lambda/node_modules/@aws-sdk/util-endpoints/dist-types/ts3.4/aws.d.ts

```typescript
import { EndpointFunctions } from "@smithy/util-endpoints";
export declare const awsEndpointFunctions: EndpointFunctions;

```

## ./lib/lambda/node_modules/@aws-sdk/util-endpoints/dist-types/ts3.4/index.d.ts

```typescript
export * from "./aws";
export * from "./lib/aws/partition";
export * from "./lib/isIpAddress";
export * from "./resolveDefaultAwsRegionalEndpointsConfig";
export * from "./resolveEndpoint";
export * from "./types";

```

## ./lib/lambda/node_modules/@aws-sdk/util-endpoints/dist-types/ts3.4/lib/aws/index.d.ts

```typescript
export * from "./isVirtualHostableS3Bucket";
export * from "./parseArn";
export * from "./partition";

```

## ./lib/lambda/node_modules/@aws-sdk/util-endpoints/dist-types/ts3.4/lib/aws/isVirtualHostableS3Bucket.d.ts

```typescript
export declare const isVirtualHostableS3Bucket: (
  value: string,
  allowSubDomains?: boolean
) => boolean;

```

## ./lib/lambda/node_modules/@aws-sdk/util-endpoints/dist-types/ts3.4/lib/aws/parseArn.d.ts

```typescript
import { EndpointARN } from "@smithy/types";
export declare const parseArn: (value: string) => EndpointARN | null;

```

## ./lib/lambda/node_modules/@aws-sdk/util-endpoints/dist-types/ts3.4/lib/aws/partition.d.ts

```typescript
import { EndpointPartition } from "@smithy/types";
export type PartitionsInfo = {
  partitions: Array<{
    id: string;
    outputs: {
      dnsSuffix: string;
      dualStackDnsSuffix: string;
      name: string;
      supportsDualStack: boolean;
      supportsFIPS: boolean;
    };
    regionRegex: string;
    regions: Record<
      string,
      | {
          description?: string;
        }
      | undefined
    >;
  }>;
};
export declare const partition: (value: string) => EndpointPartition;
export declare const setPartitionInfo: (
  partitionsInfo: PartitionsInfo,
  userAgentPrefix?: string
) => void;
export declare const useDefaultPartitionInfo: () => void;
export declare const getUserAgentPrefix: () => string;

```

## ./lib/lambda/node_modules/@aws-sdk/util-endpoints/dist-types/ts3.4/lib/isIpAddress.d.ts

```typescript
export { isIpAddress } from "@smithy/util-endpoints";

```

## ./lib/lambda/node_modules/@aws-sdk/util-endpoints/dist-types/ts3.4/resolveDefaultAwsRegionalEndpointsConfig.d.ts

```typescript
import {
  Endpoint,
  EndpointParameters,
  EndpointV2,
  Logger,
  Provider,
} from "@smithy/types";
export type DefaultAwsRegionalEndpointsInputConfig = {
  endpoint?: unknown;
};
type PreviouslyResolved = {
  logger?: Logger;
  region?: undefined | string | Provider<string | undefined>;
  useFipsEndpoint?: undefined | boolean | Provider<string | boolean>;
  useDualstackEndpoint?: undefined | boolean | Provider<string | boolean>;
  endpointProvider: (
    endpointParams: EndpointParameters | DefaultRegionalEndpointParameters,
    context?: {
      logger?: Logger;
    }
  ) => EndpointV2;
};
type DefaultRegionalEndpointParameters = {
  Region?: string | undefined;
  UseDualStack?: boolean | undefined;
  UseFIPS?: boolean | undefined;
};
export interface DefaultAwsRegionalEndpointsResolvedConfig {
  endpoint: Provider<Endpoint>;
}
export declare const resolveDefaultAwsRegionalEndpointsConfig: <T>(
  input: T & DefaultAwsRegionalEndpointsInputConfig & PreviouslyResolved
) => T & DefaultAwsRegionalEndpointsResolvedConfig;
export declare const toEndpointV1: (endpoint: EndpointV2) => Endpoint;
export {};

```

## ./lib/lambda/node_modules/@aws-sdk/util-endpoints/dist-types/ts3.4/resolveEndpoint.d.ts

```typescript
export { resolveEndpoint } from "@smithy/util-endpoints";

```

## ./lib/lambda/node_modules/@aws-sdk/util-endpoints/dist-types/ts3.4/types/EndpointError.d.ts

```typescript
export { EndpointError } from "@smithy/util-endpoints";

```

## ./lib/lambda/node_modules/@aws-sdk/util-endpoints/dist-types/ts3.4/types/EndpointRuleObject.d.ts

```typescript
export {
  EndpointObjectProperties,
  EndpointObjectHeaders,
  EndpointObject,
  EndpointRuleObject,
} from "@smithy/util-endpoints";

```

## ./lib/lambda/node_modules/@aws-sdk/util-endpoints/dist-types/ts3.4/types/ErrorRuleObject.d.ts

```typescript
export { ErrorRuleObject } from "@smithy/util-endpoints";

```

## ./lib/lambda/node_modules/@aws-sdk/util-endpoints/dist-types/ts3.4/types/RuleSetObject.d.ts

```typescript
export {
  DeprecatedObject,
  ParameterObject,
  RuleSetObject,
} from "@smithy/util-endpoints";

```

## ./lib/lambda/node_modules/@aws-sdk/util-endpoints/dist-types/ts3.4/types/TreeRuleObject.d.ts

```typescript
export { RuleSetRules, TreeRuleObject } from "@smithy/util-endpoints";

```

## ./lib/lambda/node_modules/@aws-sdk/util-endpoints/dist-types/ts3.4/types/index.d.ts

```typescript
export * from "./EndpointError";
export * from "./EndpointRuleObject";
export * from "./ErrorRuleObject";
export * from "./RuleSetObject";
export * from "./TreeRuleObject";
export * from "./shared";

```

## ./lib/lambda/node_modules/@aws-sdk/util-endpoints/dist-types/ts3.4/types/shared.d.ts

```typescript
export {
  ReferenceObject,
  FunctionObject,
  FunctionArgv,
  FunctionReturn,
  ConditionObject,
  Expression,
  EndpointParams,
  EndpointResolverOptions,
  ReferenceRecord,
  EvaluateOptions,
} from "@smithy/util-endpoints";

```

## ./lib/lambda/node_modules/@aws-sdk/util-endpoints/dist-types/types/EndpointError.d.ts

```typescript
export { EndpointError } from "@smithy/util-endpoints";

```

## ./lib/lambda/node_modules/@aws-sdk/util-endpoints/dist-types/types/EndpointRuleObject.d.ts

```typescript
export { EndpointObjectProperties, EndpointObjectHeaders, EndpointObject, EndpointRuleObject, } from "@smithy/util-endpoints";

```

## ./lib/lambda/node_modules/@aws-sdk/util-endpoints/dist-types/types/ErrorRuleObject.d.ts

```typescript
export { ErrorRuleObject } from "@smithy/util-endpoints";

```

## ./lib/lambda/node_modules/@aws-sdk/util-endpoints/dist-types/types/RuleSetObject.d.ts

```typescript
export { DeprecatedObject, ParameterObject, RuleSetObject } from "@smithy/util-endpoints";

```

## ./lib/lambda/node_modules/@aws-sdk/util-endpoints/dist-types/types/TreeRuleObject.d.ts

```typescript
export { RuleSetRules, TreeRuleObject } from "@smithy/util-endpoints";

```

## ./lib/lambda/node_modules/@aws-sdk/util-endpoints/dist-types/types/index.d.ts

```typescript
export * from "./EndpointError";
export * from "./EndpointRuleObject";
export * from "./ErrorRuleObject";
export * from "./RuleSetObject";
export * from "./TreeRuleObject";
export * from "./shared";

```

## ./lib/lambda/node_modules/@aws-sdk/util-endpoints/dist-types/types/shared.d.ts

```typescript
export { ReferenceObject, FunctionObject, FunctionArgv, FunctionReturn, ConditionObject, Expression, EndpointParams, EndpointResolverOptions, ReferenceRecord, EvaluateOptions, } from "@smithy/util-endpoints";

```

## ./lib/lambda/node_modules/@aws-sdk/util-endpoints/package.json

```json
{
  "name": "@aws-sdk/util-endpoints",
  "version": "3.910.0",
  "description": "Utilities to help with endpoint resolution",
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "node ../../scripts/compilation/inline util-endpoints",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "test": "yarn g:vitest run",
    "test:integration": "yarn g:vitest run -c vitest.config.integ.mts",
    "test:watch": "yarn g:vitest watch",
    "test:integration:watch": "yarn g:vitest watch -c vitest.config.integ.mts"
  },
  "sideEffects": true,
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "dependencies": {
    "@aws-sdk/types": "3.910.0",
    "@smithy/types": "^4.7.1",
    "@smithy/url-parser": "^4.2.2",
    "@smithy/util-endpoints": "^3.2.2",
    "tslib": "^2.6.2"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/aws/aws-sdk-js-v3/tree/main/packages/util-endpoints",
  "repository": {
    "type": "git",
    "url": "https://github.com/aws/aws-sdk-js-v3.git",
    "directory": "packages/util-endpoints"
  },
  "devDependencies": {
    "@tsconfig/recommended": "1.0.1",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typescript": "~5.8.3"
  }
}

```

## ./lib/lambda/node_modules/@aws-sdk/util-format-url/dist-types/index.d.ts

```typescript
import { HttpRequest } from "@smithy/types";
export declare function formatUrl(request: Omit<HttpRequest, "headers" | "method">): string;

```

## ./lib/lambda/node_modules/@aws-sdk/util-format-url/dist-types/ts3.4/index.d.ts

```typescript
import { HttpRequest } from "@smithy/types";
export declare function formatUrl(
  request: Pick<HttpRequest, Exclude<keyof HttpRequest, "headers" | "method">>
): string;

```

## ./lib/lambda/node_modules/@aws-sdk/util-format-url/package.json

```json
{
  "name": "@aws-sdk/util-format-url",
  "version": "3.910.0",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "node ../../scripts/compilation/inline util-format-url",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "sideEffects": false,
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "dependencies": {
    "@aws-sdk/types": "3.910.0",
    "@smithy/querystring-builder": "^4.2.2",
    "@smithy/types": "^4.7.1",
    "tslib": "^2.6.2"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/aws/aws-sdk-js-v3/tree/main/packages/util-format-url",
  "repository": {
    "type": "git",
    "url": "https://github.com/aws/aws-sdk-js-v3.git",
    "directory": "packages/util-format-url"
  },
  "devDependencies": {
    "@tsconfig/recommended": "1.0.1",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typescript": "~5.8.3"
  }
}

```

## ./lib/lambda/node_modules/@aws-sdk/util-locate-window/dist-types/index.d.ts

```typescript
/**
 * Locates the global scope for a browser or browser-like environment. If
 * neither `window` nor `self` is defined by the environment, the same object
 * will be returned on each invocation.
 */
export declare function locateWindow(): Window;

```

## ./lib/lambda/node_modules/@aws-sdk/util-locate-window/dist-types/ts3.4/index.d.ts

```typescript
export declare function locateWindow(): Window;

```

## ./lib/lambda/node_modules/@aws-sdk/util-locate-window/package.json

```json
{
  "name": "@aws-sdk/util-locate-window",
  "version": "3.893.0",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "node ../../scripts/compilation/inline util-locate-window",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch"
  },
  "sideEffects": false,
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "dependencies": {
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "@tsconfig/recommended": "1.0.1",
    "@types/node": "^18.19.69",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typescript": "~5.8.3"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/aws/aws-sdk-js-v3/tree/main/packages/util-locate-window",
  "repository": {
    "type": "git",
    "url": "https://github.com/aws/aws-sdk-js-v3.git",
    "directory": "packages/util-locate-window"
  }
}

```

## ./lib/lambda/node_modules/@aws-sdk/util-user-agent-browser/dist-types/configurations.d.ts

```typescript
/**
 * @internal
 */
export interface DefaultUserAgentOptions {
    serviceId?: string;
    clientVersion: string;
}

```

## ./lib/lambda/node_modules/@aws-sdk/util-user-agent-browser/dist-types/createUserAgentStringParsingProvider.d.ts

```typescript
import type { UserAgent } from "@smithy/types";
import type { DefaultUserAgentOptions } from "./configurations";
import type { PreviouslyResolved } from "./index";
/**
 * This is an alternative to the default user agent provider that uses the bowser
 * library to parse the user agent string.
 *
 * Use this with your client's `defaultUserAgentProvider` constructor object field
 * to use the legacy behavior.
 *
 * @deprecated use the default provider unless you need the older UA-parsing functionality.
 * @public
 */
export declare const createUserAgentStringParsingProvider: ({ serviceId, clientVersion }: DefaultUserAgentOptions) => ((config?: PreviouslyResolved) => Promise<UserAgent>);

```

## ./lib/lambda/node_modules/@aws-sdk/util-user-agent-browser/dist-types/index.d.ts

```typescript
import { Provider, UserAgent } from "@smithy/types";
import type { DefaultUserAgentOptions } from "./configurations";
export { createUserAgentStringParsingProvider } from "./createUserAgentStringParsingProvider";
/**
 * @internal
 */
export interface PreviouslyResolved {
    userAgentAppId: Provider<string | undefined>;
}
/**
 * Default provider of the AWS SDK user agent string in react-native.
 * @internal
 */
export declare const createDefaultUserAgentProvider: ({ serviceId, clientVersion }: DefaultUserAgentOptions) => ((config?: PreviouslyResolved) => Promise<UserAgent>);
/**
 * Rudimentary UA string parsing as a fallback.
 * @internal
 */
export declare const fallback: {
    os(ua: string): string | undefined;
    browser(ua: string): string | undefined;
};
/**
 * @internal
 * @deprecated use createDefaultUserAgentProvider
 */
export declare const defaultUserAgent: ({ serviceId, clientVersion }: DefaultUserAgentOptions) => ((config?: PreviouslyResolved) => Promise<UserAgent>);

```

## ./lib/lambda/node_modules/@aws-sdk/util-user-agent-browser/dist-types/index.native.d.ts

```typescript
import { Provider, UserAgent } from "@smithy/types";
import { DefaultUserAgentOptions } from "./configurations";
/**
 * @internal
 */
export interface PreviouslyResolved {
    userAgentAppId: Provider<string | undefined>;
}
/**
 * Default provider to the user agent in ReactNative.
 * @internal
 */
export declare const createDefaultUserAgentProvider: ({ serviceId, clientVersion }: DefaultUserAgentOptions) => ((config?: PreviouslyResolved) => Promise<UserAgent>);
/**
 * @internal
 * @deprecated use createDefaultUserAgentProvider
 */
export declare const defaultUserAgent: ({ serviceId, clientVersion }: DefaultUserAgentOptions) => ((config?: PreviouslyResolved) => Promise<UserAgent>);

```

## ./lib/lambda/node_modules/@aws-sdk/util-user-agent-browser/dist-types/ts3.4/configurations.d.ts

```typescript
export interface DefaultUserAgentOptions {
  serviceId?: string;
  clientVersion: string;
}

```

## ./lib/lambda/node_modules/@aws-sdk/util-user-agent-browser/dist-types/ts3.4/createUserAgentStringParsingProvider.d.ts

```typescript
import { UserAgent } from "@smithy/types";
import { DefaultUserAgentOptions } from "./configurations";
import { PreviouslyResolved } from "./index";
export declare const createUserAgentStringParsingProvider: ({
  serviceId,
  clientVersion,
}: DefaultUserAgentOptions) => (
  config?: PreviouslyResolved
) => Promise<UserAgent>;

```

## ./lib/lambda/node_modules/@aws-sdk/util-user-agent-browser/dist-types/ts3.4/index.d.ts

```typescript
import { Provider, UserAgent } from "@smithy/types";
import { DefaultUserAgentOptions } from "./configurations";
export { createUserAgentStringParsingProvider } from "./createUserAgentStringParsingProvider";
export interface PreviouslyResolved {
  userAgentAppId: Provider<string | undefined>;
}
export declare const createDefaultUserAgentProvider: ({
  serviceId,
  clientVersion,
}: DefaultUserAgentOptions) => (
  config?: PreviouslyResolved
) => Promise<UserAgent>;
export declare const fallback: {
  os(ua: string): string | undefined;
  browser(ua: string): string | undefined;
};
export declare const defaultUserAgent: ({
  serviceId,
  clientVersion,
}: DefaultUserAgentOptions) => (
  config?: PreviouslyResolved
) => Promise<UserAgent>;

```

## ./lib/lambda/node_modules/@aws-sdk/util-user-agent-browser/dist-types/ts3.4/index.native.d.ts

```typescript
import { Provider, UserAgent } from "@smithy/types";
import { DefaultUserAgentOptions } from "./configurations";
export interface PreviouslyResolved {
  userAgentAppId: Provider<string | undefined>;
}
export declare const createDefaultUserAgentProvider: ({
  serviceId,
  clientVersion,
}: DefaultUserAgentOptions) => (
  config?: PreviouslyResolved
) => Promise<UserAgent>;
export declare const defaultUserAgent: ({
  serviceId,
  clientVersion,
}: DefaultUserAgentOptions) => (
  config?: PreviouslyResolved
) => Promise<UserAgent>;

```

## ./lib/lambda/node_modules/@aws-sdk/util-user-agent-browser/package.json

```json
{
  "name": "@aws-sdk/util-user-agent-browser",
  "version": "3.910.0",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "node ../../scripts/compilation/inline util-user-agent-browser",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "browser": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "sideEffects": false,
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "react-native": "dist-es/index.native.js",
  "dependencies": {
    "@aws-sdk/types": "3.910.0",
    "@smithy/types": "^4.7.1",
    "bowser": "^2.11.0",
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "@tsconfig/recommended": "1.0.1",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typescript": "~5.8.3"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/aws/aws-sdk-js-v3/tree/main/packages/util-user-agent-browser",
  "repository": {
    "type": "git",
    "url": "https://github.com/aws/aws-sdk-js-v3.git",
    "directory": "packages/util-user-agent-browser"
  }
}

```

## ./lib/lambda/node_modules/@aws-sdk/util-user-agent-node/dist-types/crt-availability.d.ts

```typescript
/**
 * If \@aws-sdk/signature-v4-crt is installed and loaded, it will register
 * this value to true.
 * @internal
 */
export declare const crtAvailability: {
    isCrtAvailable: boolean;
};

```

## ./lib/lambda/node_modules/@aws-sdk/util-user-agent-node/dist-types/defaultUserAgent.d.ts

```typescript
import { Provider, UserAgent } from "@smithy/types";
/**
 * @internal
 */
export { crtAvailability } from "./crt-availability";
/**
 * @internal
 */
export interface DefaultUserAgentOptions {
    serviceId?: string;
    clientVersion: string;
}
/**
 * @internal
 */
export interface PreviouslyResolved {
    userAgentAppId: Provider<string | undefined>;
}
/**
 * Collect metrics from runtime to put into user agent.
 * @internal
 */
export declare const createDefaultUserAgentProvider: ({ serviceId, clientVersion }: DefaultUserAgentOptions) => (config?: PreviouslyResolved) => Promise<UserAgent>;
/**
 * @internal
 * @deprecated use createDefaultUserAgentProvider
 */
export declare const defaultUserAgent: ({ serviceId, clientVersion }: DefaultUserAgentOptions) => (config?: PreviouslyResolved) => Promise<UserAgent>;

```

## ./lib/lambda/node_modules/@aws-sdk/util-user-agent-node/dist-types/index.d.ts

```typescript
export * from "./defaultUserAgent";
export * from "./nodeAppIdConfigOptions";

```

## ./lib/lambda/node_modules/@aws-sdk/util-user-agent-node/dist-types/is-crt-available.d.ts

```typescript
import { UserAgentPair } from "@smithy/types";
/**
 * @internal
 */
export declare const isCrtAvailable: () => UserAgentPair | null;

```

## ./lib/lambda/node_modules/@aws-sdk/util-user-agent-node/dist-types/nodeAppIdConfigOptions.d.ts

```typescript
import { LoadedConfigSelectors } from "@smithy/node-config-provider";
/**
 * @internal
 */
export declare const UA_APP_ID_ENV_NAME = "AWS_SDK_UA_APP_ID";
/**
 * @internal
 */
export declare const UA_APP_ID_INI_NAME = "sdk_ua_app_id";
/**
 * @internal
 */
export declare const NODE_APP_ID_CONFIG_OPTIONS: LoadedConfigSelectors<string | undefined>;

```

## ./lib/lambda/node_modules/@aws-sdk/util-user-agent-node/dist-types/ts3.4/crt-availability.d.ts

```typescript
export declare const crtAvailability: {
  isCrtAvailable: boolean;
};

```

## ./lib/lambda/node_modules/@aws-sdk/util-user-agent-node/dist-types/ts3.4/defaultUserAgent.d.ts

```typescript
import { Provider, UserAgent } from "@smithy/types";
export { crtAvailability } from "./crt-availability";
export interface DefaultUserAgentOptions {
  serviceId?: string;
  clientVersion: string;
}
export interface PreviouslyResolved {
  userAgentAppId: Provider<string | undefined>;
}
export declare const createDefaultUserAgentProvider: ({
  serviceId,
  clientVersion,
}: DefaultUserAgentOptions) => (
  config?: PreviouslyResolved
) => Promise<UserAgent>;
export declare const defaultUserAgent: ({
  serviceId,
  clientVersion,
}: DefaultUserAgentOptions) => (
  config?: PreviouslyResolved
) => Promise<UserAgent>;

```

## ./lib/lambda/node_modules/@aws-sdk/util-user-agent-node/dist-types/ts3.4/index.d.ts

```typescript
export * from "./defaultUserAgent";
export * from "./nodeAppIdConfigOptions";

```

## ./lib/lambda/node_modules/@aws-sdk/util-user-agent-node/dist-types/ts3.4/is-crt-available.d.ts

```typescript
import { UserAgentPair } from "@smithy/types";
export declare const isCrtAvailable: () => UserAgentPair | null;

```

## ./lib/lambda/node_modules/@aws-sdk/util-user-agent-node/dist-types/ts3.4/nodeAppIdConfigOptions.d.ts

```typescript
import { LoadedConfigSelectors } from "@smithy/node-config-provider";
export declare const UA_APP_ID_ENV_NAME = "AWS_SDK_UA_APP_ID";
export declare const UA_APP_ID_INI_NAME = "sdk_ua_app_id";
export declare const NODE_APP_ID_CONFIG_OPTIONS: LoadedConfigSelectors<
  string | undefined
>;

```

## ./lib/lambda/node_modules/@aws-sdk/util-user-agent-node/package.json

```json
{
  "name": "@aws-sdk/util-user-agent-node",
  "version": "3.911.0",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "node ../../scripts/compilation/inline util-user-agent-node",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "sideEffects": false,
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "dependencies": {
    "@aws-sdk/middleware-user-agent": "3.911.0",
    "@aws-sdk/types": "3.910.0",
    "@smithy/node-config-provider": "^4.3.2",
    "@smithy/types": "^4.7.1",
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "@tsconfig/recommended": "1.0.1",
    "@types/node": "^18.19.69",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typescript": "~5.8.3"
  },
  "peerDependencies": {
    "aws-crt": ">=1.0.0"
  },
  "peerDependenciesMeta": {
    "aws-crt": {
      "optional": true
    }
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/aws/aws-sdk-js-v3/tree/main/packages/util-user-agent-node",
  "repository": {
    "type": "git",
    "url": "https://github.com/aws/aws-sdk-js-v3.git",
    "directory": "packages/util-user-agent-node"
  }
}

```

## ./lib/lambda/node_modules/@aws-sdk/xml-builder/dist-types/XmlNode.d.ts

```typescript
import { Stringable } from "./stringable";
/**
 * @internal
 *
 * Represents an XML node.
 */
export declare class XmlNode {
    private name;
    readonly children: Stringable[];
    private attributes;
    static of(name: string, childText?: string, withName?: string): XmlNode;
    constructor(name: string, children?: Stringable[]);
    withName(name: string): XmlNode;
    addAttribute(name: string, value: any): XmlNode;
    addChildNode(child: Stringable): XmlNode;
    removeAttribute(name: string): XmlNode;
    /**
     * @internal
     * Alias of {@link XmlNode#withName(string)} for codegen brevity.
     */
    n(name: string): XmlNode;
    /**
     * @internal
     * Alias of {@link XmlNode#addChildNode(string)} for codegen brevity.
     */
    c(child: Stringable): XmlNode;
    /**
     * @internal
     * Checked version of {@link XmlNode#addAttribute(string)} for codegen brevity.
     */
    a(name: string, value: any): XmlNode;
    /**
     * Create a child node.
     * Used in serialization of string fields.
     * @internal
     */
    cc(input: any, field: string, withName?: string): void;
    /**
     * Creates list child nodes.
     * @internal
     */
    l(input: any, listName: string, memberName: string, valueProvider: Function): void;
    /**
     * Creates list child nodes with container.
     * @internal
     */
    lc(input: any, listName: string, memberName: string, valueProvider: Function): void;
    toString(): string;
}

```

## ./lib/lambda/node_modules/@aws-sdk/xml-builder/dist-types/XmlText.d.ts

```typescript
import { Stringable } from "./stringable";
/**
 * @internal
 *
 * Represents an XML text value.
 */
export declare class XmlText implements Stringable {
    private value;
    constructor(value: string);
    toString(): string;
}

```

## ./lib/lambda/node_modules/@aws-sdk/xml-builder/dist-types/escape-attribute.d.ts

```typescript
/**
 * @internal
 *
 * Escapes characters that can not be in an XML attribute.
 */
export declare function escapeAttribute(value: string): string;

```

## ./lib/lambda/node_modules/@aws-sdk/xml-builder/dist-types/escape-element.d.ts

```typescript
/**
 * @internal
 *
 * Escapes characters that can not be in an XML element.
 */
export declare function escapeElement(value: string): string;

```

## ./lib/lambda/node_modules/@aws-sdk/xml-builder/dist-types/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./XmlNode";
/**
 * @internal
 */
export * from "./XmlText";
/**
 * @internal
 */
export { parseXML } from "./xml-parser";

```

## ./lib/lambda/node_modules/@aws-sdk/xml-builder/dist-types/stringable.d.ts

```typescript
/**
 * @internal
 */
export interface Stringable {
    toString(): string;
}

```

## ./lib/lambda/node_modules/@aws-sdk/xml-builder/dist-types/ts3.4/XmlNode.d.ts

```typescript
import { Stringable } from "./stringable";
export declare class XmlNode {
  private name;
  readonly children: Stringable[];
  private attributes;
  static of(name: string, childText?: string, withName?: string): XmlNode;
  constructor(name: string, children?: Stringable[]);
  withName(name: string): XmlNode;
  addAttribute(name: string, value: any): XmlNode;
  addChildNode(child: Stringable): XmlNode;
  removeAttribute(name: string): XmlNode;
  n(name: string): XmlNode;
  c(child: Stringable): XmlNode;
  a(name: string, value: any): XmlNode;
  cc(input: any, field: string, withName?: string): void;
  l(
    input: any,
    listName: string,
    memberName: string,
    valueProvider: Function
  ): void;
  lc(
    input: any,
    listName: string,
    memberName: string,
    valueProvider: Function
  ): void;
  toString(): string;
}

```

## ./lib/lambda/node_modules/@aws-sdk/xml-builder/dist-types/ts3.4/XmlText.d.ts

```typescript
import { Stringable } from "./stringable";
export declare class XmlText implements Stringable {
  private value;
  constructor(value: string);
  toString(): string;
}

```

## ./lib/lambda/node_modules/@aws-sdk/xml-builder/dist-types/ts3.4/escape-attribute.d.ts

```typescript
export declare function escapeAttribute(value: string): string;

```

## ./lib/lambda/node_modules/@aws-sdk/xml-builder/dist-types/ts3.4/escape-element.d.ts

```typescript
export declare function escapeElement(value: string): string;

```

## ./lib/lambda/node_modules/@aws-sdk/xml-builder/dist-types/ts3.4/index.d.ts

```typescript
export * from "./XmlNode";
export * from "./XmlText";
export { parseXML } from "./xml-parser";

```

## ./lib/lambda/node_modules/@aws-sdk/xml-builder/dist-types/ts3.4/stringable.d.ts

```typescript
export interface Stringable {
  toString(): string;
}

```

## ./lib/lambda/node_modules/@aws-sdk/xml-builder/dist-types/ts3.4/xml-parser.browser.d.ts

```typescript
export declare function parseXML(xmlString: string): any;

```

## ./lib/lambda/node_modules/@aws-sdk/xml-builder/dist-types/ts3.4/xml-parser.d.ts

```typescript
export declare function parseXML(xmlString: string): any;

```

## ./lib/lambda/node_modules/@aws-sdk/xml-builder/dist-types/xml-parser.browser.d.ts

```typescript
/**
 * Cases where this differs from fast-xml-parser:
 *
 * 1. Mixing text with nested tags (does not occur in AWS REST XML).
 * <mixed-text> hello, <bold>world</bold>, how are you?</mixed-text>
 *
 * @internal
 */
export declare function parseXML(xmlString: string): any;

```

## ./lib/lambda/node_modules/@aws-sdk/xml-builder/dist-types/xml-parser.d.ts

```typescript
/**
 * @internal
 */
export declare function parseXML(xmlString: string): any;

```

## ./lib/lambda/node_modules/@aws-sdk/xml-builder/package.json

```json
{
  "name": "@aws-sdk/xml-builder",
  "version": "3.911.0",
  "description": "XML builder for the AWS SDK",
  "dependencies": {
    "@smithy/types": "^4.7.1",
    "fast-xml-parser": "5.2.5",
    "tslib": "^2.6.2"
  },
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
    "build:cjs": "node ../../scripts/compilation/inline xml-builder",
    "build:es": "tsc -p tsconfig.es.json",
    "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
    "build:types": "tsc -p tsconfig.types.json",
    "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch"
  },
  "sideEffects": false,
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "browser": {
    "./dist-es/xml-parser": "./dist-es/xml-parser.browser"
  },
  "react-native": {
    "./dist-es/xml-parser": "./dist-es/xml-parser",
    "./dist-cjs/xml-parser": "./dist-cjs/xml-parser"
  },
  "homepage": "https://github.com/aws/aws-sdk-js-v3/tree/main/packages/xml-builder",
  "repository": {
    "type": "git",
    "url": "https://github.com/aws/aws-sdk-js-v3.git",
    "directory": "packages/xml-builder"
  },
  "devDependencies": {
    "@tsconfig/recommended": "1.0.1",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typescript": "~5.8.3"
  }
}

```

## ./lib/lambda/node_modules/@smithy/abort-controller/dist-types/AbortController.d.ts

```typescript
import { AbortController as DeprecatedAbortController } from "@smithy/types";
import { AbortSignal } from "./AbortSignal";
/**
 * @public
 */
export { DeprecatedAbortController as IAbortController };
/**
 * @deprecated This implementation was added as Node.js didn't support AbortController prior to 15.x
 * Use native implementation in browsers or Node.js \>=15.4.0.
 *
 * @public
 */
export declare class AbortController implements DeprecatedAbortController {
    readonly signal: AbortSignal;
    abort(): void;
}

```

## ./lib/lambda/node_modules/@smithy/abort-controller/dist-types/AbortSignal.d.ts

```typescript
import { AbortHandler, AbortSignal as DeprecatedAbortSignal } from "@smithy/types";
/**
 * @public
 */
export { AbortHandler, DeprecatedAbortSignal as IAbortSignal };
/**
 * @public
 */
export declare class AbortSignal implements DeprecatedAbortSignal {
    onabort: AbortHandler | null;
    private _aborted;
    constructor();
    /**
     * Whether the associated operation has already been cancelled.
     */
    get aborted(): boolean;
    /**
     * @internal
     */
    abort(): void;
}

```

## ./lib/lambda/node_modules/@smithy/abort-controller/dist-types/index.d.ts

```typescript
/**
 * This implementation was added as Node.js didn't support AbortController prior to 15.x
 * Use native implementation in browsers or Node.js \>=15.4.0.
 *
 * @deprecated Use standard implementations in [Browsers](https://developer.mozilla.org/en-US/docs/Web/API/AbortController) and [Node.js](https://nodejs.org/docs/latest/api/globals.html#class-abortcontroller)
 * @packageDocumentation
 */
export * from "./AbortController";
export * from "./AbortSignal";

```

## ./lib/lambda/node_modules/@smithy/abort-controller/dist-types/ts3.4/AbortController.d.ts

```typescript
import { AbortController as DeprecatedAbortController } from "@smithy/types";
import { AbortSignal } from "./AbortSignal";
/**
 * @public
 */
export { DeprecatedAbortController as IAbortController };
/**
 * @deprecated This implementation was added as Node.js didn't support AbortController prior to 15.x
 * Use native implementation in browsers or Node.js \>=15.4.0.
 *
 * @public
 */
export declare class AbortController implements DeprecatedAbortController {
    readonly signal: AbortSignal;
    abort(): void;
}

```

## ./lib/lambda/node_modules/@smithy/abort-controller/dist-types/ts3.4/AbortSignal.d.ts

```typescript
import { AbortHandler, AbortSignal as DeprecatedAbortSignal } from "@smithy/types";
/**
 * @public
 */
export { AbortHandler, DeprecatedAbortSignal as IAbortSignal };
/**
 * @public
 */
export declare class AbortSignal implements DeprecatedAbortSignal {
    onabort: AbortHandler | null;
    private _aborted;
    constructor();
    /*
    * Whether the associated operation has already been cancelled.
    */
    readonly aborted: boolean;
    /**
     * @internal
     */
    abort(): void;
}

```

## ./lib/lambda/node_modules/@smithy/abort-controller/dist-types/ts3.4/index.d.ts

```typescript
/**
 * This implementation was added as Node.js didn't support AbortController prior to 15.x
 * Use native implementation in browsers or Node.js \>=15.4.0.
 *
 * @deprecated Use standard implementations in [Browsers](https://developer.mozilla.org/en-US/docs/Web/API/AbortController) and [Node.js](https://nodejs.org/docs/latest/api/globals.html#class-abortcontroller)
 * @packageDocumentation
 */
export * from "./AbortController";
export * from "./AbortSignal";

```

## ./lib/lambda/node_modules/@smithy/abort-controller/package.json

```json
{
  "name": "@smithy/abort-controller",
  "version": "4.2.3",
  "description": "A simple abort controller library",
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline abort-controller",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "rimraf dist-types/ts3.4 && downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../../.prettierignore --write \"**/*.{ts,md,json}\"",
    "extract:docs": "api-extractor run --local",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch"
  },
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "sideEffects": false,
  "dependencies": {
    "@smithy/types": "^4.8.0",
    "tslib": "^2.6.2"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/smithy-lang/smithy-typescript/tree/main/packages/abort-controller",
  "repository": {
    "type": "git",
    "url": "https://github.com/smithy-lang/smithy-typescript.git",
    "directory": "packages/abort-controller"
  },
  "devDependencies": {
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  }
}
```

## ./lib/lambda/node_modules/@smithy/chunked-blob-reader/dist-types/index.d.ts

```typescript
/**
 * @internal
 * Reads the blob data into the onChunk consumer.
 */
export declare function blobReader(blob: Blob, onChunk: (chunk: Uint8Array) => void, chunkSize?: number): Promise<void>;

```

## ./lib/lambda/node_modules/@smithy/chunked-blob-reader/dist-types/ts3.4/index.d.ts

```typescript
/**
 * @internal
 * Reads the blob data into the onChunk consumer.
 */
export declare function blobReader(blob: Blob, onChunk: (chunk: Uint8Array) => void, chunkSize?: number): Promise<void>;

```

## ./lib/lambda/node_modules/@smithy/chunked-blob-reader/package.json

```json
{
  "name": "@smithy/chunked-blob-reader",
  "version": "5.2.0",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline chunked-blob-reader",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "rimraf dist-types/ts3.4 && downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../../.prettierignore --write \"**/*.{ts,md,json}\"",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "sideEffects": false,
  "dependencies": {
    "tslib": "^2.6.2"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/smithy-lang/smithy-typescript/tree/main/packages/chunked-blob-reader",
  "repository": {
    "type": "git",
    "url": "https://github.com/smithy-lang/smithy-typescript.git",
    "directory": "packages/chunked-blob-reader"
  },
  "devDependencies": {
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  },
  "engines": {
    "node": ">=18.0.0"
  }
}
```

## ./lib/lambda/node_modules/@smithy/chunked-blob-reader-native/dist-types/index.d.ts

```typescript
/**
 * @internal
 */
export declare function blobReader(blob: Blob, onChunk: (chunk: Uint8Array) => void, chunkSize?: number): Promise<void>;

```

## ./lib/lambda/node_modules/@smithy/chunked-blob-reader-native/dist-types/ts3.4/index.d.ts

```typescript
/**
 * @internal
 */
export declare function blobReader(blob: Blob, onChunk: (chunk: Uint8Array) => void, chunkSize?: number): Promise<void>;

```

## ./lib/lambda/node_modules/@smithy/chunked-blob-reader-native/package.json

```json
{
  "name": "@smithy/chunked-blob-reader-native",
  "version": "4.2.1",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline chunked-blob-reader-native",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "rimraf dist-types/ts3.4 && downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../../.prettierignore --write \"**/*.{ts,md,json}\"",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "sideEffects": false,
  "dependencies": {
    "@smithy/util-base64": "^4.3.0",
    "tslib": "^2.6.2"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/smithy-lang/smithy-typescript/tree/main/packages/chunked-blob-reader-native",
  "repository": {
    "type": "git",
    "url": "https://github.com/smithy-lang/smithy-typescript.git",
    "directory": "packages/chunked-blob-reader-native"
  },
  "devDependencies": {
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  },
  "engines": {
    "node": ">=18.0.0"
  }
}
```

## ./lib/lambda/node_modules/@smithy/config-resolver/dist-types/endpointsConfig/NodeUseDualstackEndpointConfigOptions.d.ts

```typescript
import type { LoadedConfigSelectors } from "@smithy/node-config-provider";
/**
 * @internal
 */
export declare const ENV_USE_DUALSTACK_ENDPOINT = "AWS_USE_DUALSTACK_ENDPOINT";
/**
 * @internal
 */
export declare const CONFIG_USE_DUALSTACK_ENDPOINT = "use_dualstack_endpoint";
/**
 * @internal
 */
export declare const DEFAULT_USE_DUALSTACK_ENDPOINT = false;
/**
 * @internal
 */
export declare const NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS: LoadedConfigSelectors<boolean>;

```

## ./lib/lambda/node_modules/@smithy/config-resolver/dist-types/endpointsConfig/NodeUseFipsEndpointConfigOptions.d.ts

```typescript
import type { LoadedConfigSelectors } from "@smithy/node-config-provider";
/**
 * @internal
 */
export declare const ENV_USE_FIPS_ENDPOINT = "AWS_USE_FIPS_ENDPOINT";
/**
 * @internal
 */
export declare const CONFIG_USE_FIPS_ENDPOINT = "use_fips_endpoint";
/**
 * @internal
 */
export declare const DEFAULT_USE_FIPS_ENDPOINT = false;
/**
 * @internal
 */
export declare const NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS: LoadedConfigSelectors<boolean>;

```

## ./lib/lambda/node_modules/@smithy/config-resolver/dist-types/endpointsConfig/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./NodeUseDualstackEndpointConfigOptions";
/**
 * @internal
 */
export * from "./NodeUseFipsEndpointConfigOptions";
/**
 * @internal
 */
export * from "./resolveCustomEndpointsConfig";
/**
 * @internal
 */
export * from "./resolveEndpointsConfig";

```

## ./lib/lambda/node_modules/@smithy/config-resolver/dist-types/endpointsConfig/resolveCustomEndpointsConfig.d.ts

```typescript
import type { Endpoint, Provider, UrlParser } from "@smithy/types";
import type { EndpointsInputConfig, EndpointsResolvedConfig } from "./resolveEndpointsConfig";
/**
 * @public
 * @deprecated superseded by default endpointRuleSet generation.
 */
export interface CustomEndpointsInputConfig extends EndpointsInputConfig {
    /**
     * The fully qualified endpoint of the webservice.
     */
    endpoint: string | Endpoint | Provider<Endpoint>;
}
/**
 * @internal
 * @deprecated superseded by default endpointRuleSet generation.
 */
interface PreviouslyResolved {
    urlParser: UrlParser;
}
/**
 * @internal
 * @deprecated superseded by default endpointRuleSet generation.
 */
export interface CustomEndpointsResolvedConfig extends EndpointsResolvedConfig {
    /**
     * Whether the endpoint is specified by caller.
     * @internal
     */
    isCustomEndpoint: true;
}
/**
 * @internal
 *
 * @deprecated superseded by default endpointRuleSet generation.
 */
export declare const resolveCustomEndpointsConfig: <T>(input: T & CustomEndpointsInputConfig & PreviouslyResolved) => T & CustomEndpointsResolvedConfig;
export {};

```

## ./lib/lambda/node_modules/@smithy/config-resolver/dist-types/endpointsConfig/resolveEndpointsConfig.d.ts

```typescript
import type { Endpoint, Provider, RegionInfoProvider, UrlParser } from "@smithy/types";
/**
 * @public
 * @deprecated see \@smithy/middleware-endpoint resolveEndpointConfig.
 */
export interface EndpointsInputConfig {
    /**
     * The fully qualified endpoint of the webservice. This is only required when using
     * a custom endpoint (for example, when using a local version of S3).
     */
    endpoint?: string | Endpoint | Provider<Endpoint>;
    /**
     * Whether TLS is enabled for requests.
     */
    tls?: boolean;
    /**
     * Enables IPv6/IPv4 dualstack endpoint.
     */
    useDualstackEndpoint?: boolean | Provider<boolean>;
}
/**
 * @internal
 * @deprecated see \@smithy/middleware-endpoint resolveEndpointConfig.
 */
interface PreviouslyResolved {
    regionInfoProvider: RegionInfoProvider;
    urlParser: UrlParser;
    region: Provider<string>;
    useFipsEndpoint: Provider<boolean>;
}
/**
 * @internal
 * @deprecated see \@smithy/middleware-endpoint resolveEndpointConfig.
 */
export interface EndpointsResolvedConfig extends Required<EndpointsInputConfig> {
    /**
     * Resolved value for input {@link EndpointsInputConfig.endpoint}
     */
    endpoint: Provider<Endpoint>;
    /**
     * Whether the endpoint is specified by caller.
     * @internal
     */
    isCustomEndpoint?: boolean;
    /**
     * Resolved value for input {@link EndpointsInputConfig.useDualstackEndpoint}
     */
    useDualstackEndpoint: Provider<boolean>;
}
/**
 * @internal
 *
 * @deprecated endpoints rulesets use \@smithy/middleware-endpoint resolveEndpointConfig.
 * All generated clients should migrate to Endpoints 2.0 endpointRuleSet traits.
 */
export declare const resolveEndpointsConfig: <T>(input: T & EndpointsInputConfig & PreviouslyResolved) => T & EndpointsResolvedConfig;
export {};

```

## ./lib/lambda/node_modules/@smithy/config-resolver/dist-types/endpointsConfig/utils/getEndpointFromRegion.d.ts

```typescript
import type { Provider, RegionInfoProvider, UrlParser } from "@smithy/types";
interface GetEndpointFromRegionOptions {
    region: Provider<string>;
    tls?: boolean;
    regionInfoProvider: RegionInfoProvider;
    urlParser: UrlParser;
    useDualstackEndpoint: Provider<boolean>;
    useFipsEndpoint: Provider<boolean>;
}
export declare const getEndpointFromRegion: (input: GetEndpointFromRegionOptions) => Promise<import("@smithy/types").Endpoint>;
export {};

```

## ./lib/lambda/node_modules/@smithy/config-resolver/dist-types/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./endpointsConfig";
/**
 * @internal
 */
export * from "./regionConfig";
/**
 * @internal
 */
export * from "./regionInfo";

```

## ./lib/lambda/node_modules/@smithy/config-resolver/dist-types/regionConfig/config.d.ts

```typescript
import type { LoadedConfigSelectors, LocalConfigOptions } from "@smithy/node-config-provider";
/**
 * @internal
 */
export declare const REGION_ENV_NAME = "AWS_REGION";
/**
 * @internal
 */
export declare const REGION_INI_NAME = "region";
/**
 * @internal
 */
export declare const NODE_REGION_CONFIG_OPTIONS: LoadedConfigSelectors<string>;
/**
 * @internal
 */
export declare const NODE_REGION_CONFIG_FILE_OPTIONS: LocalConfigOptions;

```

## ./lib/lambda/node_modules/@smithy/config-resolver/dist-types/regionConfig/getRealRegion.d.ts

```typescript
/**
 * @internal
 */
export declare const getRealRegion: (region: string) => string;

```

## ./lib/lambda/node_modules/@smithy/config-resolver/dist-types/regionConfig/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./config";
/**
 * @internal
 */
export * from "./resolveRegionConfig";

```

## ./lib/lambda/node_modules/@smithy/config-resolver/dist-types/regionConfig/isFipsRegion.d.ts

```typescript
/**
 * @internal
 */
export declare const isFipsRegion: (region: string) => boolean;

```

## ./lib/lambda/node_modules/@smithy/config-resolver/dist-types/regionConfig/resolveRegionConfig.d.ts

```typescript
import type { Provider } from "@smithy/types";
/**
 * @public
 */
export interface RegionInputConfig {
    /**
     * The AWS region to which this client will send requests
     */
    region?: string | Provider<string>;
    /**
     * Enables FIPS compatible endpoints.
     */
    useFipsEndpoint?: boolean | Provider<boolean>;
}
interface PreviouslyResolved {
}
/**
 * @internal
 */
export interface RegionResolvedConfig {
    /**
     * Resolved value for input config {@link RegionInputConfig.region}
     */
    region: Provider<string>;
    /**
     * Resolved value for input {@link RegionInputConfig.useFipsEndpoint}
     */
    useFipsEndpoint: Provider<boolean>;
}
/**
 * @internal
 */
export declare const resolveRegionConfig: <T>(input: T & RegionInputConfig & PreviouslyResolved) => T & RegionResolvedConfig;
export {};

```

## ./lib/lambda/node_modules/@smithy/config-resolver/dist-types/regionInfo/EndpointVariant.d.ts

```typescript
import type { EndpointVariantTag } from "./EndpointVariantTag";
/**
 * Provides hostname information for specific host label.
 *
 * @internal
 * @deprecated unused as of endpointsRuleSets.
 */
export type EndpointVariant = {
    hostname: string;
    tags: EndpointVariantTag[];
};

```

## ./lib/lambda/node_modules/@smithy/config-resolver/dist-types/regionInfo/EndpointVariantTag.d.ts

```typescript
/**
 *
 *
 * The tag which mentions which area variant is providing information for.
 * Can be either "fips" or "dualstack".
 *
 * @internal
 * @deprecated unused for endpointRuleSets.
 */
export type EndpointVariantTag = "fips" | "dualstack";

```

## ./lib/lambda/node_modules/@smithy/config-resolver/dist-types/regionInfo/PartitionHash.d.ts

```typescript
import type { EndpointVariant } from "./EndpointVariant";
/**
 * The hash of partition with the information specific to that partition.
 * The information includes the list of regions belonging to that partition,
 * and the hostname to be used for the partition.
 *
 * @internal
 * @deprecated unused for endpointRuleSets.
 */
export type PartitionHash = Record<string, {
    regions: string[];
    regionRegex: string;
    variants: EndpointVariant[];
    endpoint?: string;
}>;

```

## ./lib/lambda/node_modules/@smithy/config-resolver/dist-types/regionInfo/RegionHash.d.ts

```typescript
import type { EndpointVariant } from "./EndpointVariant";
/**
 * The hash of region with the information specific to that region.
 * The information can include hostname, signingService and signingRegion.
 *
 * @internal
 * @deprecated unused for endpointRuleSets.
 */
export type RegionHash = Record<string, {
    variants: EndpointVariant[];
    signingService?: string;
    signingRegion?: string;
}>;

```

## ./lib/lambda/node_modules/@smithy/config-resolver/dist-types/regionInfo/getHostnameFromVariants.d.ts

```typescript
import type { EndpointVariant } from "./EndpointVariant";
/**
 * @internal
 * @deprecated unused as of endpointsRuleSets.
 */
export interface GetHostnameFromVariantsOptions {
    useFipsEndpoint: boolean;
    useDualstackEndpoint: boolean;
}
/**
 * @internal
 * @deprecated unused as of endpointsRuleSets.
 */
export declare const getHostnameFromVariants: (variants: EndpointVariant[] | undefined, { useFipsEndpoint, useDualstackEndpoint }: GetHostnameFromVariantsOptions) => string | undefined;

```

## ./lib/lambda/node_modules/@smithy/config-resolver/dist-types/regionInfo/getRegionInfo.d.ts

```typescript
import type { RegionInfo } from "@smithy/types";
import type { PartitionHash } from "./PartitionHash";
import type { RegionHash } from "./RegionHash";
/**
 * @internal
 * @deprecated unused as of endpointsRuleSets.
 */
export interface GetRegionInfoOptions {
    useFipsEndpoint?: boolean;
    useDualstackEndpoint?: boolean;
    signingService: string;
    regionHash: RegionHash;
    partitionHash: PartitionHash;
}
/**
 * @internal
 * @deprecated unused as of endpointsRuleSets.
 */
export declare const getRegionInfo: (region: string, { useFipsEndpoint, useDualstackEndpoint, signingService, regionHash, partitionHash, }: GetRegionInfoOptions) => RegionInfo;

```

## ./lib/lambda/node_modules/@smithy/config-resolver/dist-types/regionInfo/getResolvedHostname.d.ts

```typescript
/**
 * @internal
 * @deprecated unused for endpointRuleSets.
 */
export interface GetResolvedHostnameOptions {
    regionHostname?: string;
    partitionHostname?: string;
}
/**
 * @internal
 * @deprecated unused for endpointRuleSets.
 */
export declare const getResolvedHostname: (resolvedRegion: string, { regionHostname, partitionHostname }: GetResolvedHostnameOptions) => string | undefined;

```

## ./lib/lambda/node_modules/@smithy/config-resolver/dist-types/regionInfo/getResolvedPartition.d.ts

```typescript
import type { PartitionHash } from "./PartitionHash";
/**
 * @internal
 * @deprecated unused for endpointRuleSets.
 */
export interface GetResolvedPartitionOptions {
    partitionHash: PartitionHash;
}
/**
 * @internal
 * @deprecated unused for endpointRuleSets.
 */
export declare const getResolvedPartition: (region: string, { partitionHash }: GetResolvedPartitionOptions) => string;

```

## ./lib/lambda/node_modules/@smithy/config-resolver/dist-types/regionInfo/getResolvedSigningRegion.d.ts

```typescript
/**
 * @internal
 * @deprecated unused for endpointRuleSets.
 */
export interface GetResolvedSigningRegionOptions {
    regionRegex: string;
    signingRegion?: string;
    useFipsEndpoint: boolean;
}
/**
 * @internal
 * @deprecated unused for endpointRuleSets.
 */
export declare const getResolvedSigningRegion: (hostname: string, { signingRegion, regionRegex, useFipsEndpoint }: GetResolvedSigningRegionOptions) => string | undefined;

```

## ./lib/lambda/node_modules/@smithy/config-resolver/dist-types/regionInfo/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./PartitionHash";
/**
 * @internal
 */
export * from "./RegionHash";
/**
 * @internal
 */
export * from "./getRegionInfo";

```

## ./lib/lambda/node_modules/@smithy/config-resolver/dist-types/ts3.4/endpointsConfig/NodeUseDualstackEndpointConfigOptions.d.ts

```typescript
import { LoadedConfigSelectors } from "@smithy/node-config-provider";
/**
 * @internal
 */
export declare const ENV_USE_DUALSTACK_ENDPOINT = "AWS_USE_DUALSTACK_ENDPOINT";
/**
 * @internal
 */
export declare const CONFIG_USE_DUALSTACK_ENDPOINT = "use_dualstack_endpoint";
/**
 * @internal
 */
export declare const DEFAULT_USE_DUALSTACK_ENDPOINT = false;
/**
 * @internal
 */
export declare const NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS: LoadedConfigSelectors<boolean>;

```

## ./lib/lambda/node_modules/@smithy/config-resolver/dist-types/ts3.4/endpointsConfig/NodeUseFipsEndpointConfigOptions.d.ts

```typescript
import { LoadedConfigSelectors } from "@smithy/node-config-provider";
/**
 * @internal
 */
export declare const ENV_USE_FIPS_ENDPOINT = "AWS_USE_FIPS_ENDPOINT";
/**
 * @internal
 */
export declare const CONFIG_USE_FIPS_ENDPOINT = "use_fips_endpoint";
/**
 * @internal
 */
export declare const DEFAULT_USE_FIPS_ENDPOINT = false;
/**
 * @internal
 */
export declare const NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS: LoadedConfigSelectors<boolean>;

```

## ./lib/lambda/node_modules/@smithy/config-resolver/dist-types/ts3.4/endpointsConfig/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./NodeUseDualstackEndpointConfigOptions";
/**
 * @internal
 */
export * from "./NodeUseFipsEndpointConfigOptions";
/**
 * @internal
 */
export * from "./resolveCustomEndpointsConfig";
/**
 * @internal
 */
export * from "./resolveEndpointsConfig";

```

## ./lib/lambda/node_modules/@smithy/config-resolver/dist-types/ts3.4/endpointsConfig/resolveCustomEndpointsConfig.d.ts

```typescript
import { Endpoint, Provider, UrlParser } from "@smithy/types";
import { EndpointsInputConfig, EndpointsResolvedConfig } from "./resolveEndpointsConfig";
/**
 * @public
 * @deprecated superseded by default endpointRuleSet generation.
 */
export interface CustomEndpointsInputConfig extends EndpointsInputConfig {
    /**
     * The fully qualified endpoint of the webservice.
     */
    endpoint: string | Endpoint | Provider<Endpoint>;
}
/**
 * @internal
 * @deprecated superseded by default endpointRuleSet generation.
 */
interface PreviouslyResolved {
    urlParser: UrlParser;
}
/**
 * @internal
 * @deprecated superseded by default endpointRuleSet generation.
 */
export interface CustomEndpointsResolvedConfig extends EndpointsResolvedConfig {
    /**
     * Whether the endpoint is specified by caller.
     * @internal
     */
    isCustomEndpoint: true;
}
/**
 * @internal
 *
 * @deprecated superseded by default endpointRuleSet generation.
 */
export declare const resolveCustomEndpointsConfig: <T>(input: T & CustomEndpointsInputConfig & PreviouslyResolved) => T & CustomEndpointsResolvedConfig;
export {};

```

## ./lib/lambda/node_modules/@smithy/config-resolver/dist-types/ts3.4/endpointsConfig/resolveEndpointsConfig.d.ts

```typescript
import { Endpoint, Provider, RegionInfoProvider, UrlParser } from "@smithy/types";
/**
 * @public
 * @deprecated see \@smithy/middleware-endpoint resolveEndpointConfig.
 */
export interface EndpointsInputConfig {
    /**
     * The fully qualified endpoint of the webservice. This is only required when using
     * a custom endpoint (for example, when using a local version of S3).
     */
    endpoint?: string | Endpoint | Provider<Endpoint>;
    /**
     * Whether TLS is enabled for requests.
     */
    tls?: boolean;
    /**
     * Enables IPv6/IPv4 dualstack endpoint.
     */
    useDualstackEndpoint?: boolean | Provider<boolean>;
}
/**
 * @internal
 * @deprecated see \@smithy/middleware-endpoint resolveEndpointConfig.
 */
interface PreviouslyResolved {
    regionInfoProvider: RegionInfoProvider;
    urlParser: UrlParser;
    region: Provider<string>;
    useFipsEndpoint: Provider<boolean>;
}
/**
 * @internal
 * @deprecated see \@smithy/middleware-endpoint resolveEndpointConfig.
 */
export interface EndpointsResolvedConfig extends Required<EndpointsInputConfig> {
    /**
     * Resolved value for input {@link EndpointsInputConfig.endpoint}
     */
    endpoint: Provider<Endpoint>;
    /**
     * Whether the endpoint is specified by caller.
     * @internal
     */
    isCustomEndpoint?: boolean;
    /**
     * Resolved value for input {@link EndpointsInputConfig.useDualstackEndpoint}
     */
    useDualstackEndpoint: Provider<boolean>;
}
/**
 * @internal
 *
 * @deprecated endpoints rulesets use \@smithy/middleware-endpoint resolveEndpointConfig.
 * All generated clients should migrate to Endpoints 2.0 endpointRuleSet traits.
 */
export declare const resolveEndpointsConfig: <T>(input: T & EndpointsInputConfig & PreviouslyResolved) => T & EndpointsResolvedConfig;
export {};

```

## ./lib/lambda/node_modules/@smithy/config-resolver/dist-types/ts3.4/endpointsConfig/utils/getEndpointFromRegion.d.ts

```typescript
import { Provider, RegionInfoProvider, UrlParser } from "@smithy/types";
interface GetEndpointFromRegionOptions {
    region: Provider<string>;
    tls?: boolean;
    regionInfoProvider: RegionInfoProvider;
    urlParser: UrlParser;
    useDualstackEndpoint: Provider<boolean>;
    useFipsEndpoint: Provider<boolean>;
}
export declare const getEndpointFromRegion: (input: GetEndpointFromRegionOptions) => Promise<import("@smithy/types").Endpoint>;
export {};

```

## ./lib/lambda/node_modules/@smithy/config-resolver/dist-types/ts3.4/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./endpointsConfig";
/**
 * @internal
 */
export * from "./regionConfig";
/**
 * @internal
 */
export * from "./regionInfo";

```

## ./lib/lambda/node_modules/@smithy/config-resolver/dist-types/ts3.4/regionConfig/config.d.ts

```typescript
import { LoadedConfigSelectors, LocalConfigOptions } from "@smithy/node-config-provider";
/**
 * @internal
 */
export declare const REGION_ENV_NAME = "AWS_REGION";
/**
 * @internal
 */
export declare const REGION_INI_NAME = "region";
/**
 * @internal
 */
export declare const NODE_REGION_CONFIG_OPTIONS: LoadedConfigSelectors<string>;
/**
 * @internal
 */
export declare const NODE_REGION_CONFIG_FILE_OPTIONS: LocalConfigOptions;

```

## ./lib/lambda/node_modules/@smithy/config-resolver/dist-types/ts3.4/regionConfig/getRealRegion.d.ts

```typescript
/**
 * @internal
 */
export declare const getRealRegion: (region: string) => string;

```

## ./lib/lambda/node_modules/@smithy/config-resolver/dist-types/ts3.4/regionConfig/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./config";
/**
 * @internal
 */
export * from "./resolveRegionConfig";

```

## ./lib/lambda/node_modules/@smithy/config-resolver/dist-types/ts3.4/regionConfig/isFipsRegion.d.ts

```typescript
/**
 * @internal
 */
export declare const isFipsRegion: (region: string) => boolean;

```

## ./lib/lambda/node_modules/@smithy/config-resolver/dist-types/ts3.4/regionConfig/resolveRegionConfig.d.ts

```typescript
import { Provider } from "@smithy/types";
/**
 * @public
 */
export interface RegionInputConfig {
    /**
     * The AWS region to which this client will send requests
     */
    region?: string | Provider<string>;
    /**
     * Enables FIPS compatible endpoints.
     */
    useFipsEndpoint?: boolean | Provider<boolean>;
}
interface PreviouslyResolved {
}
/**
 * @internal
 */
export interface RegionResolvedConfig {
    /**
     * Resolved value for input config {@link RegionInputConfig.region}
     */
    region: Provider<string>;
    /**
     * Resolved value for input {@link RegionInputConfig.useFipsEndpoint}
     */
    useFipsEndpoint: Provider<boolean>;
}
/**
 * @internal
 */
export declare const resolveRegionConfig: <T>(input: T & RegionInputConfig & PreviouslyResolved) => T & RegionResolvedConfig;
export {};

```

## ./lib/lambda/node_modules/@smithy/config-resolver/dist-types/ts3.4/regionInfo/EndpointVariant.d.ts

```typescript
import { EndpointVariantTag } from "./EndpointVariantTag";
/**
 * Provides hostname information for specific host label.
 *
 * @internal
 * @deprecated unused as of endpointsRuleSets.
 */
export type EndpointVariant = {
    hostname: string;
    tags: EndpointVariantTag[];
};

```

## ./lib/lambda/node_modules/@smithy/config-resolver/dist-types/ts3.4/regionInfo/EndpointVariantTag.d.ts

```typescript
/**
 *
 *
 * The tag which mentions which area variant is providing information for.
 * Can be either "fips" or "dualstack".
 *
 * @internal
 * @deprecated unused for endpointRuleSets.
 */
export type EndpointVariantTag = "fips" | "dualstack";

```

## ./lib/lambda/node_modules/@smithy/config-resolver/dist-types/ts3.4/regionInfo/PartitionHash.d.ts

```typescript
import { EndpointVariant } from "./EndpointVariant";
/**
 * The hash of partition with the information specific to that partition.
 * The information includes the list of regions belonging to that partition,
 * and the hostname to be used for the partition.
 *
 * @internal
 * @deprecated unused for endpointRuleSets.
 */
export type PartitionHash = Record<string, {
    regions: string[];
    regionRegex: string;
    variants: EndpointVariant[];
    endpoint?: string;
}>;

```

## ./lib/lambda/node_modules/@smithy/config-resolver/dist-types/ts3.4/regionInfo/RegionHash.d.ts

```typescript
import { EndpointVariant } from "./EndpointVariant";
/**
 * The hash of region with the information specific to that region.
 * The information can include hostname, signingService and signingRegion.
 *
 * @internal
 * @deprecated unused for endpointRuleSets.
 */
export type RegionHash = Record<string, {
    variants: EndpointVariant[];
    signingService?: string;
    signingRegion?: string;
}>;

```

## ./lib/lambda/node_modules/@smithy/config-resolver/dist-types/ts3.4/regionInfo/getHostnameFromVariants.d.ts

```typescript
import { EndpointVariant } from "./EndpointVariant";
/**
 * @internal
 * @deprecated unused as of endpointsRuleSets.
 */
export interface GetHostnameFromVariantsOptions {
    useFipsEndpoint: boolean;
    useDualstackEndpoint: boolean;
}
/**
 * @internal
 * @deprecated unused as of endpointsRuleSets.
 */
export declare const getHostnameFromVariants: (variants: EndpointVariant[] | undefined, { useFipsEndpoint, useDualstackEndpoint }: GetHostnameFromVariantsOptions) => string | undefined;

```

## ./lib/lambda/node_modules/@smithy/config-resolver/dist-types/ts3.4/regionInfo/getRegionInfo.d.ts

```typescript
import { RegionInfo } from "@smithy/types";
import { PartitionHash } from "./PartitionHash";
import { RegionHash } from "./RegionHash";
/**
 * @internal
 * @deprecated unused as of endpointsRuleSets.
 */
export interface GetRegionInfoOptions {
    useFipsEndpoint?: boolean;
    useDualstackEndpoint?: boolean;
    signingService: string;
    regionHash: RegionHash;
    partitionHash: PartitionHash;
}
/**
 * @internal
 * @deprecated unused as of endpointsRuleSets.
 */
export declare const getRegionInfo: (region: string, { useFipsEndpoint, useDualstackEndpoint, signingService, regionHash, partitionHash, }: GetRegionInfoOptions) => RegionInfo;

```

## ./lib/lambda/node_modules/@smithy/config-resolver/dist-types/ts3.4/regionInfo/getResolvedHostname.d.ts

```typescript
/**
 * @internal
 * @deprecated unused for endpointRuleSets.
 */
export interface GetResolvedHostnameOptions {
    regionHostname?: string;
    partitionHostname?: string;
}
/**
 * @internal
 * @deprecated unused for endpointRuleSets.
 */
export declare const getResolvedHostname: (resolvedRegion: string, { regionHostname, partitionHostname }: GetResolvedHostnameOptions) => string | undefined;

```

## ./lib/lambda/node_modules/@smithy/config-resolver/dist-types/ts3.4/regionInfo/getResolvedPartition.d.ts

```typescript
import { PartitionHash } from "./PartitionHash";
/**
 * @internal
 * @deprecated unused for endpointRuleSets.
 */
export interface GetResolvedPartitionOptions {
    partitionHash: PartitionHash;
}
/**
 * @internal
 * @deprecated unused for endpointRuleSets.
 */
export declare const getResolvedPartition: (region: string, { partitionHash }: GetResolvedPartitionOptions) => string;

```

## ./lib/lambda/node_modules/@smithy/config-resolver/dist-types/ts3.4/regionInfo/getResolvedSigningRegion.d.ts

```typescript
/**
 * @internal
 * @deprecated unused for endpointRuleSets.
 */
export interface GetResolvedSigningRegionOptions {
    regionRegex: string;
    signingRegion?: string;
    useFipsEndpoint: boolean;
}
/**
 * @internal
 * @deprecated unused for endpointRuleSets.
 */
export declare const getResolvedSigningRegion: (hostname: string, { signingRegion, regionRegex, useFipsEndpoint }: GetResolvedSigningRegionOptions) => string | undefined;

```

## ./lib/lambda/node_modules/@smithy/config-resolver/dist-types/ts3.4/regionInfo/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./PartitionHash";
/**
 * @internal
 */
export * from "./RegionHash";
/**
 * @internal
 */
export * from "./getRegionInfo";

```

## ./lib/lambda/node_modules/@smithy/config-resolver/package.json

```json
{
  "name": "@smithy/config-resolver",
  "version": "4.3.3",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline config-resolver",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "rimraf dist-types/ts3.4 && downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../../.prettierignore --write \"**/*.{ts,md,json}\"",
    "test": "yarn g:vitest run",
    "extract:docs": "api-extractor run --local",
    "test:watch": "yarn g:vitest watch"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "sideEffects": false,
  "dependencies": {
    "@smithy/node-config-provider": "^4.3.3",
    "@smithy/types": "^4.8.0",
    "@smithy/util-config-provider": "^4.2.0",
    "@smithy/util-middleware": "^4.2.3",
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/smithy-lang/smithy-typescript/tree/main/packages/config-resolver",
  "repository": {
    "type": "git",
    "url": "https://github.com/smithy-lang/smithy-typescript.git",
    "directory": "packages/config-resolver"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  }
}
```

## ./lib/lambda/node_modules/@smithy/core/cbor.d.ts

```typescript
/**
 * Do not edit:
 * This is a compatibility redirect for contexts that do not understand package.json exports field.
 */
declare module "@smithy/core/cbor" {
  export * from "@smithy/core/dist-types/submodules/cbor/index.d";
}

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/getSmithyContext.d.ts

```typescript
import type { HandlerExecutionContext } from "@smithy/types";
/**
 * @internal
 */
export declare const getSmithyContext: (context: HandlerExecutionContext) => Record<string, unknown>;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/index.d.ts

```typescript
export * from "./getSmithyContext";
export * from "./middleware-http-auth-scheme";
export * from "./middleware-http-signing";
export * from "./normalizeProvider";
export { createPaginator } from "./pagination/createPaginator";
export * from "./request-builder/requestBuilder";
export * from "./setFeature";
export * from "./util-identity-and-auth";

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/middleware-http-auth-scheme/getHttpAuthSchemeEndpointRuleSetPlugin.d.ts

```typescript
import type { HandlerExecutionContext, HttpAuthSchemeParameters, HttpAuthSchemeParametersProvider, IdentityProviderConfig, Pluggable, RelativeMiddlewareOptions, SerializeHandlerOptions } from "@smithy/types";
import type { PreviouslyResolved } from "./httpAuthSchemeMiddleware";
/**
 * @internal
 */
export declare const httpAuthSchemeEndpointRuleSetMiddlewareOptions: SerializeHandlerOptions & RelativeMiddlewareOptions;
/**
 * @internal
 */
interface HttpAuthSchemeEndpointRuleSetPluginOptions<TConfig extends object, TContext extends HandlerExecutionContext, TParameters extends HttpAuthSchemeParameters, TInput extends object> {
    httpAuthSchemeParametersProvider: HttpAuthSchemeParametersProvider<TConfig, TContext, TParameters, TInput>;
    identityProviderConfigProvider: (config: TConfig) => Promise<IdentityProviderConfig>;
}
/**
 * @internal
 */
export declare const getHttpAuthSchemeEndpointRuleSetPlugin: <TConfig extends object, TContext extends HandlerExecutionContext, TParameters extends HttpAuthSchemeParameters, TInput extends object>(config: TConfig & PreviouslyResolved<TParameters>, { httpAuthSchemeParametersProvider, identityProviderConfigProvider, }: HttpAuthSchemeEndpointRuleSetPluginOptions<TConfig, TContext, TParameters, TInput>) => Pluggable<any, any>;
export {};

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/middleware-http-auth-scheme/getHttpAuthSchemePlugin.d.ts

```typescript
import type { HandlerExecutionContext, HttpAuthSchemeParameters, HttpAuthSchemeParametersProvider, IdentityProviderConfig, Pluggable, RelativeMiddlewareOptions, SerializeHandlerOptions } from "@smithy/types";
import type { PreviouslyResolved } from "./httpAuthSchemeMiddleware";
/**
 * @internal
 */
export declare const httpAuthSchemeMiddlewareOptions: SerializeHandlerOptions & RelativeMiddlewareOptions;
/**
 * @internal
 */
interface HttpAuthSchemePluginOptions<TConfig extends object, TContext extends HandlerExecutionContext, TParameters extends HttpAuthSchemeParameters, TInput extends object> {
    httpAuthSchemeParametersProvider: HttpAuthSchemeParametersProvider<TConfig, TContext, TParameters, TInput>;
    identityProviderConfigProvider: (config: TConfig) => Promise<IdentityProviderConfig>;
}
/**
 * @internal
 */
export declare const getHttpAuthSchemePlugin: <TConfig extends object, TContext extends HandlerExecutionContext, TParameters extends HttpAuthSchemeParameters, TInput extends object>(config: TConfig & PreviouslyResolved<TParameters>, { httpAuthSchemeParametersProvider, identityProviderConfigProvider, }: HttpAuthSchemePluginOptions<TConfig, TContext, TParameters, TInput>) => Pluggable<any, any>;
export {};

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/middleware-http-auth-scheme/httpAuthSchemeMiddleware.d.ts

```typescript
import type { HandlerExecutionContext, HttpAuthScheme, HttpAuthSchemeParameters, HttpAuthSchemeParametersProvider, HttpAuthSchemeProvider, IdentityProviderConfig, Provider, SelectedHttpAuthScheme, SerializeMiddleware, SMITHY_CONTEXT_KEY } from "@smithy/types";
/**
 * @internal
 */
export interface PreviouslyResolved<TParameters extends HttpAuthSchemeParameters> {
    authSchemePreference?: Provider<string[]>;
    httpAuthSchemes: HttpAuthScheme[];
    httpAuthSchemeProvider: HttpAuthSchemeProvider<TParameters>;
}
/**
 * @internal
 */
interface HttpAuthSchemeMiddlewareOptions<TConfig extends object, TContext extends HandlerExecutionContext, TParameters extends HttpAuthSchemeParameters, TInput extends object> {
    httpAuthSchemeParametersProvider: HttpAuthSchemeParametersProvider<TConfig, TContext, TParameters, TInput>;
    identityProviderConfigProvider: (config: TConfig) => Promise<IdentityProviderConfig>;
}
/**
 * @internal
 */
interface HttpAuthSchemeMiddlewareSmithyContext extends Record<string, unknown> {
    selectedHttpAuthScheme?: SelectedHttpAuthScheme;
}
/**
 * @internal
 */
interface HttpAuthSchemeMiddlewareHandlerExecutionContext extends HandlerExecutionContext {
    [SMITHY_CONTEXT_KEY]?: HttpAuthSchemeMiddlewareSmithyContext;
}
/**
 * @internal
 */
export declare const httpAuthSchemeMiddleware: <TInput extends object, Output extends object, TConfig extends object, TContext extends HttpAuthSchemeMiddlewareHandlerExecutionContext, TParameters extends HttpAuthSchemeParameters>(config: TConfig & PreviouslyResolved<TParameters>, mwOptions: HttpAuthSchemeMiddlewareOptions<TConfig, TContext, TParameters, TInput>) => SerializeMiddleware<TInput, Output>;
export {};

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/middleware-http-auth-scheme/index.d.ts

```typescript
export * from "./httpAuthSchemeMiddleware";
export * from "./getHttpAuthSchemeEndpointRuleSetPlugin";
export * from "./getHttpAuthSchemePlugin";

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/middleware-http-auth-scheme/resolveAuthOptions.d.ts

```typescript
import type { HttpAuthOption } from "@smithy/types";
/**
 * Resolves list of auth options based on the supported ones, vs the preference list.
 *
 * @param candidateAuthOptions list of supported auth options selected by the standard
 *   resolution process (model-based, endpoints 2.0, etc.)
 * @param authSchemePreference list of auth schemes preferred by user.
 * @returns
 */
export declare const resolveAuthOptions: (candidateAuthOptions: HttpAuthOption[], authSchemePreference: string[]) => HttpAuthOption[];

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/middleware-http-signing/getHttpSigningMiddleware.d.ts

```typescript
import type { FinalizeRequestHandlerOptions, Pluggable, RelativeMiddlewareOptions } from "@smithy/types";
/**
 * @internal
 */
export declare const httpSigningMiddlewareOptions: FinalizeRequestHandlerOptions & RelativeMiddlewareOptions;
/**
 * @internal
 */
export declare const getHttpSigningPlugin: <Input extends object, Output extends object>(config: object) => Pluggable<Input, Output>;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/middleware-http-signing/httpSigningMiddleware.d.ts

```typescript
import type { FinalizeRequestMiddleware } from "@smithy/types";
/**
 * @internal
 */
export declare const httpSigningMiddleware: <Input extends object, Output extends object>(config: object) => FinalizeRequestMiddleware<Input, Output>;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/middleware-http-signing/index.d.ts

```typescript
export * from "./httpSigningMiddleware";
export * from "./getHttpSigningMiddleware";

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/normalizeProvider.d.ts

```typescript
import type { Provider } from "@smithy/types";
/**
 * @internal
 *
 * @returns a provider function for the input value if it isn't already one.
 */
export declare const normalizeProvider: <T>(input: T | Provider<T>) => Provider<T>;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/pagination/createPaginator.d.ts

```typescript
import type { PaginationConfiguration, Paginator } from "@smithy/types";
/**
 * @internal
 *
 * Creates a paginator.
 */
export declare function createPaginator<PaginationConfigType extends PaginationConfiguration, InputType extends object, OutputType extends object>(ClientCtor: any, CommandCtor: any, inputTokenName: string, outputTokenName: string, pageSizeTokenName?: string): (config: PaginationConfigType, input: InputType, ...additionalArguments: any[]) => Paginator<OutputType>;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/request-builder/requestBuilder.d.ts

```typescript
/**
 * @internal
 * Backwards compatibility re-export.
 */
export { requestBuilder } from "@smithy/core/protocols";

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/setFeature.d.ts

```typescript
import type { HandlerExecutionContext, SmithyFeatures } from "@smithy/types";
/**
 * @internal
 * Indicates to the request context that a given feature is active.
 *
 * @param context - handler execution context.
 * @param feature - readable name of feature.
 * @param value - encoding value of feature. This is required because the
 * specification asks the library not to include a runtime lookup of all
 * the feature identifiers.
 */
export declare function setFeature<F extends keyof SmithyFeatures>(context: HandlerExecutionContext, feature: F, value: SmithyFeatures[F]): void;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/submodules/cbor/CborCodec.d.ts

```typescript
import { SerdeContext } from "@smithy/core/protocols";
import type { Codec, Schema, ShapeDeserializer, ShapeSerializer } from "@smithy/types";
/**
 * @alpha
 */
export declare class CborCodec extends SerdeContext implements Codec<Uint8Array, Uint8Array> {
    createSerializer(): CborShapeSerializer;
    createDeserializer(): CborShapeDeserializer;
}
/**
 * @alpha
 */
export declare class CborShapeSerializer extends SerdeContext implements ShapeSerializer {
    private value;
    write(schema: Schema, value: unknown): void;
    /**
     * Recursive serializer transform that copies and prepares the user input object
     * for CBOR serialization.
     */
    serialize(schema: Schema, source: unknown): any;
    flush(): Uint8Array;
}
/**
 * @alpha
 */
export declare class CborShapeDeserializer extends SerdeContext implements ShapeDeserializer {
    read(schema: Schema, bytes: Uint8Array): any;
    /**
     * Public because it's called by the protocol implementation to deserialize errors.
     * @internal
     */
    readValue(_schema: Schema, value: any): any;
}

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/submodules/cbor/SmithyRpcV2CborProtocol.d.ts

```typescript
import { RpcProtocol } from "@smithy/core/protocols";
import type { EndpointBearer, HandlerExecutionContext, HttpRequest as IHttpRequest, HttpResponse as IHttpResponse, MetadataBearer, OperationSchema, ResponseMetadata, SerdeFunctions } from "@smithy/types";
import { CborCodec } from "./CborCodec";
/**
 * Client protocol for Smithy RPCv2 CBOR.
 *
 * @alpha
 */
export declare class SmithyRpcV2CborProtocol extends RpcProtocol {
    private codec;
    protected serializer: import("./CborCodec").CborShapeSerializer;
    protected deserializer: import("./CborCodec").CborShapeDeserializer;
    constructor({ defaultNamespace }: {
        defaultNamespace: string;
    });
    getShapeId(): string;
    getPayloadCodec(): CborCodec;
    serializeRequest<Input extends object>(operationSchema: OperationSchema, input: Input, context: HandlerExecutionContext & SerdeFunctions & EndpointBearer): Promise<IHttpRequest>;
    deserializeResponse<Output extends MetadataBearer>(operationSchema: OperationSchema, context: HandlerExecutionContext & SerdeFunctions, response: IHttpResponse): Promise<Output>;
    protected handleError(operationSchema: OperationSchema, context: HandlerExecutionContext & SerdeFunctions, response: IHttpResponse, dataObject: any, metadata: ResponseMetadata): Promise<never>;
    protected getDefaultContentType(): string;
}

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/submodules/cbor/byte-printer.d.ts

```typescript
/**
 * Prints bytes as binary string with numbers.
 * @param bytes - to print.
 * @deprecated for testing only, do not use in runtime.
 */
export declare function printBytes(bytes: Uint8Array): string[];

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/submodules/cbor/cbor-decode.d.ts

```typescript
import type { CborValueType, Float32, Uint8, Uint32 } from "./cbor-types";
/**
 * @internal
 * @param bytes - to be set as the decode source.
 *
 * Sets the decode bytearray source and its data view.
 */
export declare function setPayload(bytes: Uint8Array): void;
/**
 * @internal
 * Decodes the data between the two indices.
 */
export declare function decode(at: Uint32, to: Uint32): CborValueType;
/**
 * @internal
 */
export declare function bytesToFloat16(a: Uint8, b: Uint8): Float32;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/submodules/cbor/cbor-encode.d.ts

```typescript
/**
 * @internal
 */
export declare function toUint8Array(): Uint8Array;
export declare function resize(size: number): void;
/**
 * @param _input - JS data object.
 */
export declare function encode(_input: any): void;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/submodules/cbor/cbor-types.d.ts

```typescript
export type CborItemType = undefined | boolean | number | bigint | [CborUnstructuredByteStringType, Uint64] | string | CborTagType;
export type CborTagType = {
    tag: Uint64 | number;
    value: CborValueType;
    [tagSymbol]: true;
};
export type CborUnstructuredByteStringType = Uint8Array;
export type CborListType<T = any> = Array<T>;
export type CborMapType<T = any> = Record<string, T>;
export type CborCollectionType<T = any> = CborMapType<T> | CborListType<T>;
export type CborValueType = CborItemType | CborCollectionType | any;
export type CborArgumentLength = 1 | 2 | 4 | 8;
export type CborArgumentLengthOffset = 1 | 2 | 3 | 5 | 9;
export type CborOffset = number;
export type Uint8 = number;
export type Uint32 = number;
export type Uint64 = bigint;
export type Float32 = number;
export type Int64 = bigint;
export type Float16Binary = number;
export type Float32Binary = number;
export type CborMajorType = typeof majorUint64 | typeof majorNegativeInt64 | typeof majorUnstructuredByteString | typeof majorUtf8String | typeof majorList | typeof majorMap | typeof majorTag | typeof majorSpecial;
export declare const majorUint64 = 0;
export declare const majorNegativeInt64 = 1;
export declare const majorUnstructuredByteString = 2;
export declare const majorUtf8String = 3;
export declare const majorList = 4;
export declare const majorMap = 5;
export declare const majorTag = 6;
export declare const majorSpecial = 7;
export declare const specialFalse = 20;
export declare const specialTrue = 21;
export declare const specialNull = 22;
export declare const specialUndefined = 23;
export declare const extendedOneByte = 24;
export declare const extendedFloat16 = 25;
export declare const extendedFloat32 = 26;
export declare const extendedFloat64 = 27;
export declare const minorIndefinite = 31;
export declare function alloc(size: number): Uint8Array;
/**
 * @public
 *
 * The presence of this symbol as an object key indicates it should be considered a tag
 * for CBOR serialization purposes.
 *
 * The object must also have the properties "tag" and "value".
 */
export declare const tagSymbol: unique symbol;
/**
 * @public
 * Applies the tag symbol to the object.
 */
export declare function tag(data: {
    tag: number | bigint;
    value: any;
    [tagSymbol]?: true;
}): {
    tag: number | bigint;
    value: any;
    [tagSymbol]: true;
};

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/submodules/cbor/cbor.d.ts

```typescript
/**
 * This implementation is synchronous and only implements the parts of CBOR
 * specification used by Smithy RPCv2 CBOR protocol.
 *
 * This cbor serde implementation is derived from AWS SDK for Go's implementation.
 * @see https://github.com/aws/smithy-go/tree/main/encoding/cbor
 *
 * The cbor-x implementation was also instructional:
 * @see https://github.com/kriszyp/cbor-x
 */
export declare const cbor: {
    deserialize(payload: Uint8Array): any;
    serialize(input: any): Uint8Array;
    /**
     * @public
     * @param size - byte length to allocate.
     *
     * This may be used to garbage collect the CBOR
     * shared encoding buffer space,
     * e.g. resizeEncodingBuffer(0);
     *
     * This may also be used to pre-allocate more space for
     * CBOR encoding, e.g. resizeEncodingBuffer(100_000_000);
     */
    resizeEncodingBuffer(size: number): void;
};

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/submodules/cbor/index.d.ts

```typescript
export { cbor } from "./cbor";
export { tag, tagSymbol } from "./cbor-types";
export * from "./parseCborBody";
export * from "./SmithyRpcV2CborProtocol";
export * from "./CborCodec";

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/submodules/cbor/parseCborBody.d.ts

```typescript
import { HttpRequest as __HttpRequest } from "@smithy/protocol-http";
import type { HeaderBag as __HeaderBag, HttpResponse, SerdeContext as __SerdeContext, SerdeContext } from "@smithy/types";
import type { tagSymbol } from "./cbor-types";
/**
 * @internal
 */
export declare const parseCborBody: (streamBody: any, context: SerdeContext) => any;
/**
 * @internal
 */
export declare const dateToTag: (date: Date) => {
    tag: number | bigint;
    value: any;
    [tagSymbol]: true;
};
/**
 * @internal
 */
export declare const parseCborErrorBody: (errorBody: any, context: SerdeContext) => Promise<any>;
/**
 * @internal
 */
export declare const loadSmithyRpcV2CborErrorCode: (output: HttpResponse, data: any) => string | undefined;
/**
 * @internal
 */
export declare const checkCborResponse: (response: HttpResponse) => void;
/**
 * @internal
 */
export declare const buildHttpRpcRequest: (context: __SerdeContext, headers: __HeaderBag, path: string, resolvedHostname: string | undefined, body: any) => Promise<__HttpRequest>;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/submodules/event-streams/EventStreamSerde.d.ts

```typescript
import type { NormalizedSchema } from "@smithy/core/schema";
import type { EventStreamMarshaller, HttpRequest as IHttpRequest, HttpResponse as IHttpResponse, SerdeFunctions, ShapeDeserializer, ShapeSerializer } from "@smithy/types";
/**
 * Separated module for async mixin of EventStream serde capability.
 * This is used by the HttpProtocol base class from \@smithy/core/protocols.
 *
 * @alpha
 */
export declare class EventStreamSerde {
    private readonly marshaller;
    private readonly serializer;
    private readonly deserializer;
    private readonly serdeContext?;
    private readonly defaultContentType;
    /**
     * Properties are injected by the HttpProtocol.
     */
    constructor({ marshaller, serializer, deserializer, serdeContext, defaultContentType, }: {
        marshaller: EventStreamMarshaller;
        serializer: ShapeSerializer<string | Uint8Array>;
        deserializer: ShapeDeserializer<string | Uint8Array>;
        serdeContext?: SerdeFunctions;
        defaultContentType: string;
    });
    /**
     * @param eventStream - the iterable provided by the caller.
     * @param requestSchema - the schema of the event stream container (struct).
     * @param [initialRequest] - only provided if the initial-request is part of the event stream (RPC).
     *
     * @returns a stream suitable for the HTTP body of a request.
     */
    serializeEventStream({ eventStream, requestSchema, initialRequest, }: {
        eventStream: AsyncIterable<any>;
        requestSchema: NormalizedSchema;
        initialRequest?: any;
    }): Promise<IHttpRequest["body"] | Uint8Array>;
    /**
     * @param response - http response from which to read the event stream.
     * @param unionSchema - schema of the event stream container (struct).
     * @param [initialResponseContainer] - provided and written to only if the initial response is part of the event stream (RPC).
     *
     * @returns the asyncIterable of the event stream for the end-user.
     */
    deserializeEventStream({ response, responseSchema, initialResponseContainer, }: {
        response: IHttpResponse;
        responseSchema: NormalizedSchema;
        initialResponseContainer?: any;
    }): Promise<AsyncIterable<{
        [key: string]: any;
        $unknown?: unknown;
    }>>;
    /**
     * @param unionMember - member name within the structure that contains an event stream union.
     * @param unionSchema - schema of the union.
     * @param event
     *
     * @returns the event body (bytes) and event type (string).
     */
    private writeEventBody;
}

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/submodules/event-streams/index.d.ts

```typescript
export * from "./EventStreamSerde";

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/submodules/protocols/HttpBindingProtocol.d.ts

```typescript
import { NormalizedSchema } from "@smithy/core/schema";
import { HttpRequest } from "@smithy/protocol-http";
import type { EndpointBearer, HandlerExecutionContext, HttpRequest as IHttpRequest, HttpResponse as IHttpResponse, MetadataBearer, OperationSchema, Schema, SerdeFunctions } from "@smithy/types";
import { HttpProtocol } from "./HttpProtocol";
/**
 * Base for HTTP-binding protocols. Downstream examples
 * include AWS REST JSON and AWS REST XML.
 *
 * @alpha
 */
export declare abstract class HttpBindingProtocol extends HttpProtocol {
    serializeRequest<Input extends object>(operationSchema: OperationSchema, _input: Input, context: HandlerExecutionContext & SerdeFunctions & EndpointBearer): Promise<IHttpRequest>;
    protected serializeQuery(ns: NormalizedSchema, data: any, query: HttpRequest["query"]): void;
    deserializeResponse<Output extends MetadataBearer>(operationSchema: OperationSchema, context: HandlerExecutionContext & SerdeFunctions, response: IHttpResponse): Promise<Output>;
    /**
     * The base method ignores HTTP bindings.
     *
     * @deprecated (only this signature) use signature without headerBindings.
     * @override
     */
    protected deserializeHttpMessage(schema: Schema, context: HandlerExecutionContext & SerdeFunctions, response: IHttpResponse, headerBindings: Set<string>, dataObject: any): Promise<string[]>;
    protected deserializeHttpMessage(schema: Schema, context: HandlerExecutionContext & SerdeFunctions, response: IHttpResponse, dataObject: any): Promise<string[]>;
}

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/submodules/protocols/HttpProtocol.d.ts

```typescript
import type { EventStreamSerde } from "@smithy/core/event-streams";
import { NormalizedSchema } from "@smithy/core/schema";
import type { ClientProtocol, Codec, Endpoint, EndpointBearer, EndpointV2, EventStreamMarshaller, HandlerExecutionContext, HttpRequest as IHttpRequest, HttpResponse as IHttpResponse, MetadataBearer, OperationSchema, ResponseMetadata, Schema, SerdeFunctions, ShapeDeserializer, ShapeSerializer } from "@smithy/types";
import { SerdeContext } from "./SerdeContext";
/**
 * Abstract base for HTTP-based client protocols.
 *
 * @alpha
 */
export declare abstract class HttpProtocol extends SerdeContext implements ClientProtocol<IHttpRequest, IHttpResponse> {
    readonly options: {
        defaultNamespace: string;
    };
    protected abstract serializer: ShapeSerializer<string | Uint8Array>;
    protected abstract deserializer: ShapeDeserializer<string | Uint8Array>;
    protected constructor(options: {
        defaultNamespace: string;
    });
    abstract getShapeId(): string;
    abstract getPayloadCodec(): Codec<any, any>;
    getRequestType(): new (...args: any[]) => IHttpRequest;
    getResponseType(): new (...args: any[]) => IHttpResponse;
    /**
     * @override
     */
    setSerdeContext(serdeContext: SerdeFunctions): void;
    abstract serializeRequest<Input extends object>(operationSchema: OperationSchema, input: Input, context: HandlerExecutionContext & SerdeFunctions & EndpointBearer): Promise<IHttpRequest>;
    updateServiceEndpoint(request: IHttpRequest, endpoint: EndpointV2 | Endpoint): IHttpRequest;
    abstract deserializeResponse<Output extends MetadataBearer>(operationSchema: OperationSchema, context: HandlerExecutionContext & SerdeFunctions, response: IHttpResponse): Promise<Output>;
    protected setHostPrefix<Input extends object>(request: IHttpRequest, operationSchema: OperationSchema, input: Input): void;
    protected abstract handleError(operationSchema: OperationSchema, context: HandlerExecutionContext & SerdeFunctions, response: IHttpResponse, dataObject: any, metadata: ResponseMetadata): Promise<never>;
    protected deserializeMetadata(output: IHttpResponse): ResponseMetadata;
    /**
     * @param eventStream - the iterable provided by the caller.
     * @param requestSchema - the schema of the event stream container (struct).
     * @param [initialRequest] - only provided if the initial-request is part of the event stream (RPC).
     *
     * @returns a stream suitable for the HTTP body of a request.
     */
    protected serializeEventStream({ eventStream, requestSchema, initialRequest, }: {
        eventStream: AsyncIterable<any>;
        requestSchema: NormalizedSchema;
        initialRequest?: any;
    }): Promise<IHttpRequest["body"]>;
    /**
     * @param response - http response from which to read the event stream.
     * @param unionSchema - schema of the event stream container (struct).
     * @param [initialResponseContainer] - provided and written to only if the initial response is part of the event stream (RPC).
     *
     * @returns the asyncIterable of the event stream.
     */
    protected deserializeEventStream({ response, responseSchema, initialResponseContainer, }: {
        response: IHttpResponse;
        responseSchema: NormalizedSchema;
        initialResponseContainer?: any;
    }): Promise<AsyncIterable<{
        [key: string]: any;
        $unknown?: unknown;
    }>>;
    /**
     * Loads eventStream capability async (for chunking).
     */
    protected loadEventStreamCapability(): Promise<EventStreamSerde>;
    /**
     * @returns content-type default header value for event stream events and other documents.
     */
    protected getDefaultContentType(): string;
    /**
     * For HTTP binding protocols, this method is overridden in {@link HttpBindingProtocol}.
     *
     * @deprecated only use this for HTTP binding protocols.
     */
    protected deserializeHttpMessage(schema: Schema, context: HandlerExecutionContext & SerdeFunctions, response: IHttpResponse, headerBindings: Set<string>, dataObject: any): Promise<string[]>;
    protected deserializeHttpMessage(schema: Schema, context: HandlerExecutionContext & SerdeFunctions, response: IHttpResponse, dataObject: any): Promise<string[]>;
    protected getEventStreamMarshaller(): EventStreamMarshaller;
}

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/submodules/protocols/RpcProtocol.d.ts

```typescript
import type { EndpointBearer, HandlerExecutionContext, HttpRequest as IHttpRequest, HttpResponse as IHttpResponse, MetadataBearer, OperationSchema, SerdeFunctions } from "@smithy/types";
import { HttpProtocol } from "./HttpProtocol";
/**
 * Abstract base for RPC-over-HTTP protocols.
 *
 * @alpha
 */
export declare abstract class RpcProtocol extends HttpProtocol {
    serializeRequest<Input extends object>(operationSchema: OperationSchema, input: Input, context: HandlerExecutionContext & SerdeFunctions & EndpointBearer): Promise<IHttpRequest>;
    deserializeResponse<Output extends MetadataBearer>(operationSchema: OperationSchema, context: HandlerExecutionContext & SerdeFunctions, response: IHttpResponse): Promise<Output>;
}

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/submodules/protocols/SerdeContext.d.ts

```typescript
import type { ConfigurableSerdeContext, SerdeFunctions } from "@smithy/types";
/**
 * @internal
 */
export declare abstract class SerdeContext implements ConfigurableSerdeContext {
    protected serdeContext?: SerdeFunctions;
    setSerdeContext(serdeContext: SerdeFunctions): void;
}

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/submodules/protocols/collect-stream-body.d.ts

```typescript
import type { SerdeContext } from "@smithy/types";
import { Uint8ArrayBlobAdapter } from "@smithy/util-stream";
/**
 * @internal
 *
 * Collect low-level response body stream to Uint8Array.
 */
export declare const collectBody: (streamBody: any | undefined, context: {
    streamCollector: SerdeContext["streamCollector"];
}) => Promise<Uint8ArrayBlobAdapter>;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/submodules/protocols/extended-encode-uri-component.d.ts

```typescript
/**
 * @internal
 *
 * Function that wraps encodeURIComponent to encode additional characters
 * to fully adhere to RFC 3986.
 */
export declare function extendedEncodeURIComponent(str: string): string;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/submodules/protocols/index.d.ts

```typescript
export * from "./collect-stream-body";
export * from "./extended-encode-uri-component";
export * from "./HttpBindingProtocol";
export * from "./HttpProtocol";
export * from "./RpcProtocol";
export * from "./requestBuilder";
export * from "./resolve-path";
export * from "./serde/FromStringShapeDeserializer";
export * from "./serde/HttpInterceptingShapeDeserializer";
export * from "./serde/HttpInterceptingShapeSerializer";
export * from "./serde/ToStringShapeSerializer";
export * from "./serde/determineTimestampFormat";
export * from "./SerdeContext";

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/submodules/protocols/requestBuilder.d.ts

```typescript
import { HttpRequest } from "@smithy/protocol-http";
import type { SerdeContext } from "@smithy/types";
/**
 * @internal
 * used in code-generated serde.
 */
export declare function requestBuilder(input: any, context: SerdeContext): RequestBuilder;
/**
 * @internal
 */
export declare class RequestBuilder {
    private input;
    private context;
    private query;
    private method;
    private headers;
    private path;
    private body;
    private hostname;
    private resolvePathStack;
    constructor(input: any, context: SerdeContext);
    build(): Promise<HttpRequest>;
    /**
     * Brevity setter for "hostname".
     */
    hn(hostname: string): this;
    /**
     * Brevity initial builder for "basepath".
     */
    bp(uriLabel: string): this;
    /**
     * Brevity incremental builder for "path".
     */
    p(memberName: string, labelValueProvider: () => string | undefined, uriLabel: string, isGreedyLabel: boolean): this;
    /**
     * Brevity setter for "headers".
     */
    h(headers: Record<string, string>): this;
    /**
     * Brevity setter for "query".
     */
    q(query: Record<string, string>): this;
    /**
     * Brevity setter for "body".
     */
    b(body: any): this;
    /**
     * Brevity setter for "method".
     */
    m(method: string): this;
}

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/submodules/protocols/resolve-path.d.ts

```typescript
/**
 * @internal
 */
export declare const resolvedPath: (resolvedPath: string, input: unknown, memberName: string, labelValueProvider: () => string | undefined, uriLabel: string, isGreedyLabel: boolean) => string;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/submodules/protocols/serde/FromStringShapeDeserializer.d.ts

```typescript
import type { CodecSettings, Schema, ShapeDeserializer } from "@smithy/types";
import { SerdeContext } from "../SerdeContext";
/**
 * This deserializer reads strings.
 *
 * @alpha
 */
export declare class FromStringShapeDeserializer extends SerdeContext implements ShapeDeserializer<string> {
    private settings;
    constructor(settings: CodecSettings);
    read(_schema: Schema, data: string): any;
    private base64ToUtf8;
}

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/submodules/protocols/serde/HttpInterceptingShapeDeserializer.d.ts

```typescript
import type { CodecSettings, Schema, SerdeFunctions, ShapeDeserializer } from "@smithy/types";
import { SerdeContext } from "../SerdeContext";
/**
 * This deserializer is a dispatcher that decides whether to use a string deserializer
 * or a codec deserializer based on HTTP traits.
 *
 * For example, in a JSON HTTP message, the deserialization of a field will differ depending on whether
 * it is bound to the HTTP header (string) or body (JSON).
 *
 * @alpha
 */
export declare class HttpInterceptingShapeDeserializer<CodecShapeDeserializer extends ShapeDeserializer<any>> extends SerdeContext implements ShapeDeserializer<string | Uint8Array> {
    private codecDeserializer;
    private stringDeserializer;
    constructor(codecDeserializer: CodecShapeDeserializer, codecSettings: CodecSettings);
    /**
     * @override
     */
    setSerdeContext(serdeContext: SerdeFunctions): void;
    read(schema: Schema, data: string | Uint8Array): any | Promise<any>;
}

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/submodules/protocols/serde/HttpInterceptingShapeSerializer.d.ts

```typescript
import type { CodecSettings, ConfigurableSerdeContext, Schema as ISchema, SerdeFunctions, ShapeSerializer } from "@smithy/types";
import { ToStringShapeSerializer } from "./ToStringShapeSerializer";
/**
 * This serializer decides whether to dispatch to a string serializer or a codec serializer
 * depending on HTTP binding traits within the given schema.
 *
 * For example, a JavaScript array is serialized differently when being written
 * to a REST JSON HTTP header (comma-delimited string) and a REST JSON HTTP body (JSON array).
 *
 * @alpha
 */
export declare class HttpInterceptingShapeSerializer<CodecShapeSerializer extends ShapeSerializer<string | Uint8Array>> implements ShapeSerializer<string | Uint8Array>, ConfigurableSerdeContext {
    private codecSerializer;
    private stringSerializer;
    private buffer;
    constructor(codecSerializer: CodecShapeSerializer, codecSettings: CodecSettings, stringSerializer?: ToStringShapeSerializer);
    /**
     * @override
     */
    setSerdeContext(serdeContext: SerdeFunctions): void;
    write(schema: ISchema, value: unknown): void;
    flush(): string | Uint8Array;
}

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/submodules/protocols/serde/ToStringShapeSerializer.d.ts

```typescript
import type { CodecSettings, Schema, ShapeSerializer } from "@smithy/types";
import { SerdeContext } from "../SerdeContext";
/**
 * Serializes a shape to string.
 *
 * @alpha
 */
export declare class ToStringShapeSerializer extends SerdeContext implements ShapeSerializer<string> {
    private settings;
    private stringBuffer;
    constructor(settings: CodecSettings);
    write(schema: Schema, value: unknown): void;
    flush(): string;
}

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/submodules/protocols/serde/determineTimestampFormat.d.ts

```typescript
import type { NormalizedSchema } from "@smithy/core/schema";
import type { CodecSettings, TimestampDateTimeSchema, TimestampEpochSecondsSchema, TimestampHttpDateSchema } from "@smithy/types";
/**
 * Assuming the schema is a timestamp type, the function resolves the format using
 * either the timestamp's own traits, or the default timestamp format from the CodecSettings.
 *
 * @internal
 */
export declare function determineTimestampFormat(ns: NormalizedSchema, settings: CodecSettings): TimestampDateTimeSchema | TimestampHttpDateSchema | TimestampEpochSecondsSchema;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/submodules/schema/TypeRegistry.d.ts

```typescript
import type { Schema as ISchema, StaticErrorSchema } from "@smithy/types";
import type { ErrorSchema } from "./schemas/ErrorSchema";
/**
 * A way to look up schema by their ShapeId values.
 *
 * @alpha
 */
export declare class TypeRegistry {
    readonly namespace: string;
    private schemas;
    private exceptions;
    static readonly registries: Map<string, TypeRegistry>;
    private constructor();
    /**
     * @param namespace - specifier.
     * @returns the schema for that namespace, creating it if necessary.
     */
    static for(namespace: string): TypeRegistry;
    /**
     * Adds the given schema to a type registry with the same namespace.
     *
     * @param shapeId - to be registered.
     * @param schema - to be registered.
     */
    register(shapeId: string, schema: ISchema): void;
    /**
     * @param shapeId - query.
     * @returns the schema.
     */
    getSchema(shapeId: string): ISchema;
    /**
     * Associates an error schema with its constructor.
     */
    registerError(es: ErrorSchema | StaticErrorSchema, ctor: any): void;
    /**
     * @param es - query.
     * @returns Error constructor that extends the service's base exception.
     */
    getErrorCtor(es: ErrorSchema | StaticErrorSchema): any;
    /**
     * The smithy-typescript code generator generates a synthetic (i.e. unmodeled) base exception,
     * because generated SDKs before the introduction of schemas have the notion of a ServiceBaseException, which
     * is unique per service/model.
     *
     * This is generated under a unique prefix that is combined with the service namespace, and this
     * method is used to retrieve it.
     *
     * The base exception synthetic schema is used when an error is returned by a service, but we cannot
     * determine what existing schema to use to deserialize it.
     *
     * @returns the synthetic base exception of the service namespace associated with this registry instance.
     */
    getBaseException(): StaticErrorSchema | undefined;
    /**
     * @param predicate - criterion.
     * @returns a schema in this registry matching the predicate.
     */
    find(predicate: (schema: ISchema) => boolean): ISchema | undefined;
    /**
     * Unloads the current TypeRegistry.
     */
    clear(): void;
    private normalizeShapeId;
}

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/submodules/schema/deref.d.ts

```typescript
import type { Schema, SchemaRef } from "@smithy/types";
/**
 * Dereferences a SchemaRef if needed.
 * @internal
 */
export declare const deref: (schemaRef: SchemaRef) => Schema;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/submodules/schema/index.d.ts

```typescript
export * from "./deref";
export * from "./middleware/getSchemaSerdePlugin";
export * from "./schemas/ListSchema";
export * from "./schemas/MapSchema";
export * from "./schemas/OperationSchema";
export * from "./schemas/operation";
export * from "./schemas/ErrorSchema";
export * from "./schemas/NormalizedSchema";
export * from "./schemas/Schema";
export * from "./schemas/SimpleSchema";
export * from "./schemas/StructureSchema";
export * from "./schemas/sentinels";
export * from "./schemas/translateTraits";
export * from "./TypeRegistry";

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/submodules/schema/middleware/getSchemaSerdePlugin.d.ts

```typescript
import type { DeserializeHandlerOptions, MetadataBearer, Pluggable, SerializeHandlerOptions } from "@smithy/types";
import type { PreviouslyResolved } from "./schema-middleware-types";
/**
 * @internal
 */
export declare const deserializerMiddlewareOption: DeserializeHandlerOptions;
/**
 * @internal
 */
export declare const serializerMiddlewareOption: SerializeHandlerOptions;
/**
 * @internal
 */
export declare function getSchemaSerdePlugin<InputType extends object = any, OutputType extends MetadataBearer = any>(config: PreviouslyResolved): Pluggable<InputType, OutputType>;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/submodules/schema/middleware/schema-middleware-types.d.ts

```typescript
import type { ClientProtocol, SerdeContext, UrlParser } from "@smithy/types";
/**
 * @internal
 */
export type PreviouslyResolved = Omit<SerdeContext & {
    urlParser: UrlParser;
    protocol: ClientProtocol<any, any>;
}, "endpoint">;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/submodules/schema/middleware/schemaDeserializationMiddleware.d.ts

```typescript
import type { DeserializeHandler, DeserializeHandlerArguments, HandlerExecutionContext } from "@smithy/types";
import type { PreviouslyResolved } from "./schema-middleware-types";
/**
 * @internal
 */
export declare const schemaDeserializationMiddleware: <O>(config: PreviouslyResolved) => (next: DeserializeHandler<any, any>, context: HandlerExecutionContext) => (args: DeserializeHandlerArguments<any>) => Promise<{
    response: unknown;
    output: O;
}>;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/submodules/schema/middleware/schemaSerializationMiddleware.d.ts

```typescript
import type { HandlerExecutionContext, SerializeHandler, SerializeHandlerArguments } from "@smithy/types";
import type { PreviouslyResolved } from "./schema-middleware-types";
/**
 * @internal
 */
export declare const schemaSerializationMiddleware: (config: PreviouslyResolved) => (next: SerializeHandler<any, any>, context: HandlerExecutionContext) => (args: SerializeHandlerArguments<any>) => Promise<import("@smithy/types").SerializeHandlerOutput<any>>;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/submodules/schema/schemas/ErrorSchema.d.ts

```typescript
import type { SchemaRef, SchemaTraits } from "@smithy/types";
import { StructureSchema } from "./StructureSchema";
/**
 * A schema for a structure shape having the error trait. These represent enumerated operation errors.
 * Because Smithy-TS SDKs use classes for exceptions, whereas plain objects are used for all other data,
 * and have an existing notion of a XYZServiceBaseException, the ErrorSchema differs from a StructureSchema
 * by additionally holding the class reference for the corresponding ServiceException class.
 *
 * @alpha
 * @deprecated use StaticSchema
 */
export declare class ErrorSchema extends StructureSchema {
    static readonly symbol: unique symbol;
    /**
     * @deprecated - field unused.
     */
    ctor: any;
    protected readonly symbol: symbol;
}
/**
 * Factory for ErrorSchema, to reduce codegen output and register the schema.
 *
 * @internal
 * @deprecated use StaticSchema
 *
 * @param namespace - shapeId namespace.
 * @param name - shapeId name.
 * @param traits - shape level serde traits.
 * @param memberNames - list of member names.
 * @param memberList - list of schemaRef corresponding to each
 * @param ctor - class reference for the existing Error extending class.
 */
export declare const error: (namespace: string, name: string, traits: SchemaTraits, memberNames: string[], memberList: SchemaRef[], 
/**
 * @deprecated - field unused.
 */
ctor?: any) => ErrorSchema;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/submodules/schema/schemas/ListSchema.d.ts

```typescript
import type { ListSchema as IListSchema, SchemaRef, SchemaTraits } from "@smithy/types";
import { Schema } from "./Schema";
/**
 * A schema with a single member schema.
 * The deprecated Set type may be represented as a list.
 *
 * @alpha
 * @deprecated use StaticSchema
 */
export declare class ListSchema extends Schema implements IListSchema {
    static readonly symbol: unique symbol;
    name: string;
    traits: SchemaTraits;
    valueSchema: SchemaRef;
    protected readonly symbol: symbol;
}
/**
 * Factory for ListSchema.
 *
 * @internal
 * @deprecated use StaticSchema
 */
export declare const list: (namespace: string, name: string, traits: SchemaTraits, valueSchema: SchemaRef) => ListSchema;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/submodules/schema/schemas/MapSchema.d.ts

```typescript
import type { MapSchema as IMapSchema, SchemaRef, SchemaTraits } from "@smithy/types";
import { Schema } from "./Schema";
/**
 * A schema with a key schema and value schema.
 * @alpha
 * @deprecated use StaticSchema
 */
export declare class MapSchema extends Schema implements IMapSchema {
    static readonly symbol: unique symbol;
    name: string;
    traits: SchemaTraits;
    /**
     * This is expected to be StringSchema, but may have traits.
     */
    keySchema: SchemaRef;
    valueSchema: SchemaRef;
    protected readonly symbol: symbol;
}
/**
 * Factory for MapSchema.
 * @internal
 * @deprecated use StaticSchema
 */
export declare const map: (namespace: string, name: string, traits: SchemaTraits, keySchema: SchemaRef, valueSchema: SchemaRef) => MapSchema;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/submodules/schema/schemas/NormalizedSchema.d.ts

```typescript
import type { $MemberSchema, $Schema, $SchemaRef, NormalizedSchema as INormalizedSchema, SchemaRef, SchemaTraitsObject, StaticSchema } from "@smithy/types";
/**
 * Wraps both class instances, numeric sentinel values, and member schema pairs.
 * Presents a consistent interface for interacting with polymorphic schema representations.
 *
 * @alpha
 */
export declare class NormalizedSchema implements INormalizedSchema {
    readonly ref: $SchemaRef;
    private readonly memberName?;
    static readonly symbol: unique symbol;
    protected readonly symbol: symbol;
    private readonly name;
    private readonly schema;
    private readonly _isMemberSchema;
    private readonly traits;
    private readonly memberTraits;
    private normalizedTraits?;
    /**
     * @param ref - a polymorphic SchemaRef to be dereferenced/normalized.
     * @param memberName - optional memberName if this NormalizedSchema should be considered a member schema.
     */
    private constructor();
    static [Symbol.hasInstance](lhs: unknown): lhs is NormalizedSchema;
    /**
     * Static constructor that attempts to avoid wrapping a NormalizedSchema within another.
     */
    static of(ref: SchemaRef | $SchemaRef): NormalizedSchema;
    /**
     * @returns the underlying non-normalized schema.
     */
    getSchema(): Exclude<$Schema, $MemberSchema | INormalizedSchema>;
    /**
     * @param withNamespace - qualifies the name.
     * @returns e.g. `MyShape` or `com.namespace#MyShape`.
     */
    getName(withNamespace?: boolean): string | undefined;
    /**
     * @returns the member name if the schema is a member schema.
     */
    getMemberName(): string;
    isMemberSchema(): boolean;
    /**
     * boolean methods on this class help control flow in shape serialization and deserialization.
     */
    isListSchema(): boolean;
    isMapSchema(): boolean;
    isStructSchema(): boolean;
    isBlobSchema(): boolean;
    isTimestampSchema(): boolean;
    isUnitSchema(): boolean;
    isDocumentSchema(): boolean;
    isStringSchema(): boolean;
    isBooleanSchema(): boolean;
    isNumericSchema(): boolean;
    isBigIntegerSchema(): boolean;
    isBigDecimalSchema(): boolean;
    isStreaming(): boolean;
    /**
     * This is a shortcut to avoid calling `getMergedTraits().idempotencyToken` on every string.
     * @returns whether the schema has the idempotencyToken trait.
     */
    isIdempotencyToken(): boolean;
    /**
     * @returns own traits merged with member traits, where member traits of the same trait key take priority.
     * This method is cached.
     */
    getMergedTraits(): SchemaTraitsObject;
    /**
     * @returns only the member traits. If the schema is not a member, this returns empty.
     */
    getMemberTraits(): SchemaTraitsObject;
    /**
     * @returns only the traits inherent to the shape or member target shape if this schema is a member.
     * If there are any member traits they are excluded.
     */
    getOwnTraits(): SchemaTraitsObject;
    /**
     * @returns the map's key's schema. Returns a dummy Document schema if this schema is a Document.
     *
     * @throws Error if the schema is not a Map or Document.
     */
    getKeySchema(): NormalizedSchema;
    /**
     * @returns the schema of the map's value or list's member.
     * Returns a dummy Document schema if this schema is a Document.
     *
     * @throws Error if the schema is not a Map, List, nor Document.
     */
    getValueSchema(): NormalizedSchema;
    /**
     * @returns the NormalizedSchema for the given member name. The returned instance will return true for `isMemberSchema()`
     * and will have the member name given.
     * @param memberName - which member to retrieve and wrap.
     *
     * @throws Error if member does not exist or the schema is neither a document nor structure.
     * Note that errors are assumed to be structures and unions are considered structures for these purposes.
     */
    getMemberSchema(memberName: string): NormalizedSchema;
    /**
     * This can be used for checking the members as a hashmap.
     * Prefer the structIterator method for iteration.
     *
     * This does NOT return list and map members, it is only for structures.
     *
     * @deprecated use (checked) structIterator instead.
     *
     * @returns a map of member names to member schemas (normalized).
     */
    getMemberSchemas(): Record<string, NormalizedSchema>;
    /**
     * @returns member name of event stream or empty string indicating none exists or this
     * isn't a structure schema.
     */
    getEventStreamMember(): string;
    /**
     * Allows iteration over members of a structure schema.
     * Each yield is a pair of the member name and member schema.
     *
     * This avoids the overhead of calling Object.entries(ns.getMemberSchemas()).
     */
    structIterator(): Generator<[string, NormalizedSchema], undefined, undefined>;
}
/**
 * @internal
 */
export declare const isStaticSchema: (sc: SchemaRef) => sc is StaticSchema;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/submodules/schema/schemas/OperationSchema.d.ts

```typescript
import type { OperationSchema as IOperationSchema, SchemaRef, SchemaTraits } from "@smithy/types";
import { Schema } from "./Schema";
/**
 * This is used as a reference container for the input/output pair of schema, and for trait
 * detection on the operation that may affect client protocol logic.
 *
 * @alpha
 * @deprecated use StaticSchema
 */
export declare class OperationSchema extends Schema implements IOperationSchema {
    static readonly symbol: unique symbol;
    name: string;
    traits: SchemaTraits;
    input: SchemaRef;
    output: SchemaRef;
    protected readonly symbol: symbol;
}
/**
 * Factory for OperationSchema.
 * @internal
 * @deprecated use StaticSchema
 */
export declare const op: (namespace: string, name: string, traits: SchemaTraits, input: SchemaRef, output: SchemaRef) => OperationSchema;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/submodules/schema/schemas/Schema.d.ts

```typescript
import type { SchemaTraits, TraitsSchema } from "@smithy/types";
/**
 * Abstract base for class-based Schema except NormalizedSchema.
 *
 * @alpha
 * @deprecated use StaticSchema
 */
export declare abstract class Schema implements TraitsSchema {
    name: string;
    namespace: string;
    traits: SchemaTraits;
    protected abstract readonly symbol: symbol;
    static assign<T extends Schema>(instance: T, values: Omit<T, "getName" | "symbol">): T;
    static [Symbol.hasInstance](lhs: unknown): boolean;
    getName(): string;
}

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/submodules/schema/schemas/SimpleSchema.d.ts

```typescript
import type { SchemaRef, SchemaTraits, TraitsSchema } from "@smithy/types";
import { Schema } from "./Schema";
/**
 * Although numeric values exist for most simple schema, this class is used for cases where traits are
 * attached to those schema, since a single number cannot easily represent both a schema and its traits.
 *
 * @alpha
 * @deprecated use StaticSchema
 */
export declare class SimpleSchema extends Schema implements TraitsSchema {
    static readonly symbol: unique symbol;
    name: string;
    schemaRef: SchemaRef;
    traits: SchemaTraits;
    protected readonly symbol: symbol;
}
/**
 * Factory for simple schema class objects.
 *
 * @internal
 * @deprecated use StaticSchema
 */
export declare const sim: (namespace: string, name: string, schemaRef: SchemaRef, traits: SchemaTraits) => SimpleSchema;
/**
 * @internal
 * @deprecated
 */
export declare const simAdapter: (namespace: string, name: string, traits: SchemaTraits, schemaRef: SchemaRef) => SimpleSchema;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/submodules/schema/schemas/StructureSchema.d.ts

```typescript
import type { SchemaRef, SchemaTraits, StructureSchema as IStructureSchema } from "@smithy/types";
import { Schema } from "./Schema";
/**
 * A structure schema has a known list of members. This is also used for unions.
 *
 * @alpha
 * @deprecated use StaticSchema
 */
export declare class StructureSchema extends Schema implements IStructureSchema {
    static symbol: symbol;
    name: string;
    traits: SchemaTraits;
    memberNames: string[];
    memberList: SchemaRef[];
    protected readonly symbol: symbol;
}
/**
 * Factory for StructureSchema.
 *
 * @internal
 * @deprecated use StaticSchema
 */
export declare const struct: (namespace: string, name: string, traits: SchemaTraits, memberNames: string[], memberList: SchemaRef[]) => StructureSchema;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/submodules/schema/schemas/operation.d.ts

```typescript
import type { OperationSchema, SchemaRef, SchemaTraits } from "@smithy/types";
/**
 * Converts the static schema array into an object-form to adapt
 * to the signature of ClientProtocol classes.
 * @internal
 */
export declare const operation: (namespace: string, name: string, traits: SchemaTraits, input: SchemaRef, output: SchemaRef) => OperationSchema;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/submodules/schema/schemas/sentinels.d.ts

```typescript
import type { BigDecimalSchema, BigIntegerSchema, BlobSchema, BooleanSchema, DocumentSchema, ListSchemaModifier, MapSchemaModifier, NumericSchema, StreamingBlobSchema, StringSchema, TimestampDateTimeSchema, TimestampDefaultSchema, TimestampEpochSecondsSchema, TimestampHttpDateSchema } from "@smithy/types";
/**
 * Schema sentinel runtime values.
 * @alpha
 *
 * @deprecated use inline numbers with type annotation to save space.
 */
export declare const SCHEMA: {
    BLOB: BlobSchema;
    STREAMING_BLOB: StreamingBlobSchema;
    BOOLEAN: BooleanSchema;
    STRING: StringSchema;
    NUMERIC: NumericSchema;
    BIG_INTEGER: BigIntegerSchema;
    BIG_DECIMAL: BigDecimalSchema;
    DOCUMENT: DocumentSchema;
    TIMESTAMP_DEFAULT: TimestampDefaultSchema;
    TIMESTAMP_DATE_TIME: TimestampDateTimeSchema;
    TIMESTAMP_HTTP_DATE: TimestampHttpDateSchema;
    TIMESTAMP_EPOCH_SECONDS: TimestampEpochSecondsSchema;
    LIST_MODIFIER: ListSchemaModifier;
    MAP_MODIFIER: MapSchemaModifier;
};

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/submodules/schema/schemas/translateTraits.d.ts

```typescript
import type { SchemaTraits, SchemaTraitsObject } from "@smithy/types";
/**
 * @internal
 * @param indicator - numeric indicator for preset trait combination.
 * @returns equivalent trait object.
 */
export declare function translateTraits(indicator: SchemaTraits): SchemaTraitsObject;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/submodules/serde/copyDocumentWithTransform.d.ts

```typescript
import type { SchemaRef } from "@smithy/types";
/**
 * @internal
 * @deprecated the former functionality has been internalized to the CborCodec.
 */
export declare const copyDocumentWithTransform: (source: any, schemaRef: SchemaRef, transform?: (_: any, schemaRef: SchemaRef) => any) => any;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/submodules/serde/date-utils.d.ts

```typescript
/**
 * @internal
 *
 * Builds a proper UTC HttpDate timestamp from a Date object
 * since not all environments will have this as the expected
 * format.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toUTCString}
 * - Prior to ECMAScript 2018, the format of the return value
 * - varied according to the platform. The most common return
 * - value was an RFC-1123 formatted date stamp, which is a
 * - slightly updated version of RFC-822 date stamps.
 */
export declare function dateToUtcString(date: Date): string;
/**
 * @internal
 *
 * Parses a value into a Date. Returns undefined if the input is null or
 * undefined, throws an error if the input is not a string that can be parsed
 * as an RFC 3339 date.
 *
 * Input strings must conform to RFC3339 section 5.6, and cannot have a UTC
 * offset. Fractional precision is supported.
 *
 * @see {@link https://xml2rfc.tools.ietf.org/public/rfc/html/rfc3339.html#anchor14}
 *
 * @param value - the value to parse
 * @returns a Date or undefined
 */
export declare const parseRfc3339DateTime: (value: unknown) => Date | undefined;
/**
 * @internal
 *
 * Parses a value into a Date. Returns undefined if the input is null or
 * undefined, throws an error if the input is not a string that can be parsed
 * as an RFC 3339 date.
 *
 * Input strings must conform to RFC3339 section 5.6, and can have a UTC
 * offset. Fractional precision is supported.
 *
 * @see {@link https://xml2rfc.tools.ietf.org/public/rfc/html/rfc3339.html#anchor14}
 *
 * @param value - the value to parse
 * @returns a Date or undefined
 */
export declare const parseRfc3339DateTimeWithOffset: (value: unknown) => Date | undefined;
/**
 * @internal
 *
 * Parses a value into a Date. Returns undefined if the input is null or
 * undefined, throws an error if the input is not a string that can be parsed
 * as an RFC 7231 IMF-fixdate or obs-date.
 *
 * Input strings must conform to RFC7231 section 7.1.1.1. Fractional seconds are supported.
 *
 * @see {@link https://datatracker.ietf.org/doc/html/rfc7231.html#section-7.1.1.1}
 *
 * @param value - the value to parse
 * @returns a Date or undefined
 */
export declare const parseRfc7231DateTime: (value: unknown) => Date | undefined;
/**
 * @internal
 *
 * Parses a value into a Date. Returns undefined if the input is null or
 * undefined, throws an error if the input is not a number or a parseable string.
 *
 * Input strings must be an integer or floating point number. Fractional seconds are supported.
 *
 * @param value - the value to parse
 * @returns a Date or undefined
 */
export declare const parseEpochTimestamp: (value: unknown) => Date | undefined;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/submodules/serde/generateIdempotencyToken.d.ts

```typescript
import { v4 as generateIdempotencyToken } from "@smithy/uuid";
export { generateIdempotencyToken };

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/submodules/serde/index.d.ts

```typescript
export * from "./copyDocumentWithTransform";
export * from "./date-utils";
export * from "./generateIdempotencyToken";
export * from "./lazy-json";
export * from "./parse-utils";
export * from "./quote-header";
export * from "./schema-serde-lib/schema-date-utils";
export * from "./split-every";
export * from "./split-header";
export * from "./value/NumericValue";

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/submodules/serde/lazy-json.d.ts

```typescript
/**
 * @public
 *
 * A model field with this type means that you may provide a JavaScript
 * object in lieu of a JSON string, and it will be serialized to JSON
 * automatically before being sent in a request.
 *
 * For responses, you will receive a "LazyJsonString", which is a boxed String object
 * with additional mixin methods.
 * To get the string value, call `.toString()`, or to get the JSON object value,
 * call `.deserializeJSON()` or parse it yourself.
 */
export type AutomaticJsonStringConversion = Parameters<typeof JSON.stringify>[0] | LazyJsonString;
/**
 * @internal
 */
export interface LazyJsonString extends String {
    /**
     * @returns the JSON parsing of the string value.
     */
    deserializeJSON(): any;
    /**
     * @returns the original string value rather than a JSON.stringified value.
     */
    toJSON(): string;
}
/**
 * @internal
 *
 * Extension of the native String class in the previous implementation
 * has negative global performance impact on method dispatch for strings,
 * and is generally discouraged.
 *
 * This current implementation may look strange, but is necessary to preserve the interface and
 * behavior of extending the String class.
 */
export declare const LazyJsonString: {
    new (s: string): LazyJsonString;
    (s: string): LazyJsonString;
    from(s: any): LazyJsonString;
    /**
     * @deprecated use #from.
     */
    fromObject(s: any): LazyJsonString;
};

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/submodules/serde/parse-utils.d.ts

```typescript
/**
 * @internal
 *
 * Give an input string, strictly parses a boolean value.
 *
 * @param value - The boolean string to parse.
 * @returns true for "true", false for "false", otherwise an error is thrown.
 */
export declare const parseBoolean: (value: string) => boolean;
/**
 * @internal
 *
 * Asserts a value is a boolean and returns it.
 * Casts strings and numbers with a warning if there is evidence that they were
 * intended to be booleans.
 *
 * @param value - A value that is expected to be a boolean.
 * @returns The value if it's a boolean, undefined if it's null/undefined,
 *   otherwise an error is thrown.
 */
export declare const expectBoolean: (value: any) => boolean | undefined;
/**
 * @internal
 *
 * Asserts a value is a number and returns it.
 * Casts strings with a warning if the string is a parseable number.
 * This is to unblock slight API definition/implementation inconsistencies.
 *
 * @param value - A value that is expected to be a number.
 * @returns The value if it's a number, undefined if it's null/undefined,
 *   otherwise an error is thrown.
 */
export declare const expectNumber: (value: any) => number | undefined;
/**
 * @internal
 *
 * Asserts a value is a 32-bit float and returns it.
 *
 * @param value - A value that is expected to be a 32-bit float.
 * @returns The value if it's a float, undefined if it's null/undefined,
 *   otherwise an error is thrown.
 */
export declare const expectFloat32: (value: any) => number | undefined;
/**
 * @internal
 *
 * Asserts a value is an integer and returns it.
 *
 * @param value - A value that is expected to be an integer.
 * @returns The value if it's an integer, undefined if it's null/undefined,
 *   otherwise an error is thrown.
 */
export declare const expectLong: (value: any) => number | undefined;
/**
 * @internal
 *
 * @deprecated Use expectLong
 */
export declare const expectInt: (value: any) => number | undefined;
/**
 * @internal
 *
 * Asserts a value is a 32-bit integer and returns it.
 *
 * @param value - A value that is expected to be an integer.
 * @returns The value if it's an integer, undefined if it's null/undefined,
 *   otherwise an error is thrown.
 */
export declare const expectInt32: (value: any) => number | undefined;
/**
 * @internal
 *
 * Asserts a value is a 16-bit integer and returns it.
 *
 * @param value - A value that is expected to be an integer.
 * @returns The value if it's an integer, undefined if it's null/undefined,
 *   otherwise an error is thrown.
 */
export declare const expectShort: (value: any) => number | undefined;
/**
 * @internal
 *
 * Asserts a value is an 8-bit integer and returns it.
 *
 * @param value - A value that is expected to be an integer.
 * @returns The value if it's an integer, undefined if it's null/undefined,
 *   otherwise an error is thrown.
 */
export declare const expectByte: (value: any) => number | undefined;
/**
 * @internal
 *
 * Asserts a value is not null or undefined and returns it, or throws an error.
 *
 * @param value - A value that is expected to be defined
 * @param location - The location where we're expecting to find a defined object (optional)
 * @returns The value if it's not undefined, otherwise throws an error
 */
export declare const expectNonNull: <T>(value: T | null | undefined, location?: string) => T;
/**
 * @internal
 *
 * Asserts a value is an JSON-like object and returns it. This is expected to be used
 * with values parsed from JSON (arrays, objects, numbers, strings, booleans).
 *
 * @param value - A value that is expected to be an object
 * @returns The value if it's an object, undefined if it's null/undefined,
 *   otherwise an error is thrown.
 */
export declare const expectObject: (value: any) => Record<string, any> | undefined;
/**
 * @internal
 *
 * Asserts a value is a string and returns it.
 * Numbers and boolean will be cast to strings with a warning.
 *
 * @param value - A value that is expected to be a string.
 * @returns The value if it's a string, undefined if it's null/undefined,
 *   otherwise an error is thrown.
 */
export declare const expectString: (value: any) => string | undefined;
/**
 * @internal
 *
 * Asserts a value is a JSON-like object with only one non-null/non-undefined key and
 * returns it.
 *
 * @param value - A value that is expected to be an object with exactly one non-null,
 *              non-undefined key.
 * @returns the value if it's a union, undefined if it's null/undefined, otherwise
 *  an error is thrown.
 */
export declare const expectUnion: (value: unknown) => Record<string, any> | undefined;
/**
 * @internal
 *
 * Parses a value into a double. If the value is null or undefined, undefined
 * will be returned. If the value is a string, it will be parsed by the standard
 * parseFloat with one exception: NaN may only be explicitly set as the string
 * "NaN", any implicit Nan values will result in an error being thrown. If any
 * other type is provided, an exception will be thrown.
 *
 * @param value - A number or string representation of a double.
 * @returns The value as a number, or undefined if it's null/undefined.
 */
export declare const strictParseDouble: (value: string | number) => number | undefined;
/**
 * @internal
 *
 * @deprecated Use strictParseDouble
 */
export declare const strictParseFloat: (value: string | number) => number | undefined;
/**
 * @internal
 *
 * Parses a value into a float. If the value is null or undefined, undefined
 * will be returned. If the value is a string, it will be parsed by the standard
 * parseFloat with one exception: NaN may only be explicitly set as the string
 * "NaN", any implicit Nan values will result in an error being thrown. If any
 * other type is provided, an exception will be thrown.
 *
 * @param value - A number or string representation of a float.
 * @returns The value as a number, or undefined if it's null/undefined.
 */
export declare const strictParseFloat32: (value: string | number) => number | undefined;
/**
 * @internal
 *
 * Asserts a value is a number and returns it. If the value is a string
 * representation of a non-numeric number type (NaN, Infinity, -Infinity),
 * the value will be parsed. Any other string value will result in an exception
 * being thrown. Null or undefined will be returned as undefined. Any other
 * type will result in an exception being thrown.
 *
 * @param value - A number or string representation of a non-numeric float.
 * @returns The value as a number, or undefined if it's null/undefined.
 */
export declare const limitedParseDouble: (value: string | number) => number | undefined;
/**
 * @internal
 *
 * @deprecated Use limitedParseDouble
 */
export declare const handleFloat: (value: string | number) => number | undefined;
/**
 * @internal
 *
 * @deprecated Use limitedParseDouble
 */
export declare const limitedParseFloat: (value: string | number) => number | undefined;
/**
 * @internal
 *
 * Asserts a value is a 32-bit float and returns it. If the value is a string
 * representation of a non-numeric number type (NaN, Infinity, -Infinity),
 * the value will be parsed. Any other string value will result in an exception
 * being thrown. Null or undefined will be returned as undefined. Any other
 * type will result in an exception being thrown.
 *
 * @param value - A number or string representation of a non-numeric float.
 * @returns The value as a number, or undefined if it's null/undefined.
 */
export declare const limitedParseFloat32: (value: string | number) => number | undefined;
/**
 * @internal
 *
 * Parses a value into an integer. If the value is null or undefined, undefined
 * will be returned. If the value is a string, it will be parsed by parseFloat
 * and the result will be asserted to be an integer. If the parsed value is not
 * an integer, or the raw value is any type other than a string or number, an
 * exception will be thrown.
 *
 * @param value - A number or string representation of an integer.
 * @returns The value as a number, or undefined if it's null/undefined.
 */
export declare const strictParseLong: (value: string | number) => number | undefined;
/**
 * @internal
 *
 * @deprecated Use strictParseLong
 */
export declare const strictParseInt: (value: string | number) => number | undefined;
/**
 * @internal
 *
 * Parses a value into a 32-bit integer. If the value is null or undefined, undefined
 * will be returned. If the value is a string, it will be parsed by parseFloat
 * and the result will be asserted to be an integer. If the parsed value is not
 * an integer, or the raw value is any type other than a string or number, an
 * exception will be thrown.
 *
 * @param value - A number or string representation of a 32-bit integer.
 * @returns The value as a number, or undefined if it's null/undefined.
 */
export declare const strictParseInt32: (value: string | number) => number | undefined;
/**
 * @internal
 *
 * Parses a value into a 16-bit integer. If the value is null or undefined, undefined
 * will be returned. If the value is a string, it will be parsed by parseFloat
 * and the result will be asserted to be an integer. If the parsed value is not
 * an integer, or the raw value is any type other than a string or number, an
 * exception will be thrown.
 *
 * @param value - A number or string representation of a 16-bit integer.
 * @returns The value as a number, or undefined if it's null/undefined.
 */
export declare const strictParseShort: (value: string | number) => number | undefined;
/**
 * @internal
 *
 * Parses a value into an 8-bit integer. If the value is null or undefined, undefined
 * will be returned. If the value is a string, it will be parsed by parseFloat
 * and the result will be asserted to be an integer. If the parsed value is not
 * an integer, or the raw value is any type other than a string or number, an
 * exception will be thrown.
 *
 * @param value - A number or string representation of an 8-bit integer.
 * @returns The value as a number, or undefined if it's null/undefined.
 */
export declare const strictParseByte: (value: string | number) => number | undefined;
/**
 * @internal
 */
export declare const logger: {
    warn: {
        (...data: any[]): void;
        (message?: any, ...optionalParams: any[]): void;
    };
};

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/submodules/serde/quote-header.d.ts

```typescript
/**
 * @public
 * @param part - header list element
 * @returns quoted string if part contains delimiter.
 */
export declare function quoteHeader(part: string): string;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/submodules/serde/schema-serde-lib/schema-date-utils.d.ts

```typescript
/**
 * @internal
 *
 * Parses a value into a Date. Returns undefined if the input is null or
 * undefined, throws an error if the input is not a number or a parseable string.
 *
 * Input strings must be an integer or floating point number. Fractional seconds are supported.
 *
 * @param value - the value to parse
 * @returns a Date or undefined
 */
export declare const _parseEpochTimestamp: (value: unknown) => Date | undefined;
/**
 * @internal
 *
 * Parses a value into a Date. Returns undefined if the input is null or
 * undefined, throws an error if the input is not a string that can be parsed
 * as an RFC 3339 date.
 *
 * Input strings must conform to RFC3339 section 5.6, and can have a UTC
 * offset. Fractional precision is supported.
 *
 * @see {@link https://xml2rfc.tools.ietf.org/public/rfc/html/rfc3339.html#anchor14}
 *
 * @param value - the value to parse
 * @returns a Date or undefined
 */
export declare const _parseRfc3339DateTimeWithOffset: (value: unknown) => Date | undefined;
/**
 * @internal
 *
 * Parses a value into a Date. Returns undefined if the input is null or
 * undefined, throws an error if the input is not a string that can be parsed
 * as an RFC 7231 date.
 *
 * Input strings must conform to RFC7231 section 7.1.1.1. Fractional seconds are supported.
 *
 * RFC 850 and unix asctime formats are also accepted.
 * todo: practically speaking, are RFC 850 and asctime even used anymore?
 * todo: can we remove those parts?
 *
 * @see {@link https://datatracker.ietf.org/doc/html/rfc7231.html#section-7.1.1.1}
 *
 * @param value - the value to parse.
 * @returns a Date or undefined.
 */
export declare const _parseRfc7231DateTime: (value: unknown) => Date | undefined;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/submodules/serde/split-every.d.ts

```typescript
/**
 * @internal
 *
 * Given an input string, splits based on the delimiter after a given
 * number of delimiters has been encountered.
 *
 * @param value - The input string to split.
 * @param delimiter - The delimiter to split on.
 * @param numDelimiters - The number of delimiters to have encountered to split.
 */
export declare function splitEvery(value: string, delimiter: string, numDelimiters: number): Array<string>;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/submodules/serde/split-header.d.ts

```typescript
/**
 * @param value - header string value.
 * @returns value split by commas that aren't in quotes.
 */
export declare const splitHeader: (value: string) => string[];

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/submodules/serde/value/NumericValue.d.ts

```typescript
/**
 * Types which may be represented by {@link NumericValue}.
 *
 * There is currently only one option, because BigInteger and Long should
 * use JS BigInt directly, and all other numeric types can be contained in JS Number.
 *
 * @public
 */
export type NumericType = "bigDecimal";
/**
 * Serialization container for Smithy simple types that do not have a
 * direct JavaScript runtime representation.
 *
 * This container does not perform numeric mathematical operations.
 * It is a container for discerning a value's true type.
 *
 * It allows storage of numeric types not representable in JS without
 * making a decision on what numeric library to use.
 *
 * @public
 */
export declare class NumericValue {
    readonly string: string;
    readonly type: NumericType;
    constructor(string: string, type: NumericType);
    toString(): string;
    static [Symbol.hasInstance](object: unknown): boolean;
}
/**
 * Serde shortcut.
 * @internal
 */
export declare function nv(input: string | unknown): NumericValue;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/getSmithyContext.d.ts

```typescript
import { HandlerExecutionContext } from "@smithy/types";
/**
 * @internal
 */
export declare const getSmithyContext: (context: HandlerExecutionContext) => Record<string, unknown>;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/index.d.ts

```typescript
export * from "./getSmithyContext";
export * from "./middleware-http-auth-scheme";
export * from "./middleware-http-signing";
export * from "./normalizeProvider";
export { createPaginator } from "./pagination/createPaginator";
export * from "./request-builder/requestBuilder";
export * from "./setFeature";
export * from "./util-identity-and-auth";

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/middleware-http-auth-scheme/getHttpAuthSchemeEndpointRuleSetPlugin.d.ts

```typescript
import { HandlerExecutionContext, HttpAuthSchemeParameters, HttpAuthSchemeParametersProvider, IdentityProviderConfig, Pluggable, RelativeMiddlewareOptions, SerializeHandlerOptions } from "@smithy/types";
import { PreviouslyResolved } from "./httpAuthSchemeMiddleware";
/**
 * @internal
 */
export declare const httpAuthSchemeEndpointRuleSetMiddlewareOptions: SerializeHandlerOptions & RelativeMiddlewareOptions;
/**
 * @internal
 */
interface HttpAuthSchemeEndpointRuleSetPluginOptions<TConfig extends object, TContext extends HandlerExecutionContext, TParameters extends HttpAuthSchemeParameters, TInput extends object> {
    httpAuthSchemeParametersProvider: HttpAuthSchemeParametersProvider<TConfig, TContext, TParameters, TInput>;
    identityProviderConfigProvider: (config: TConfig) => Promise<IdentityProviderConfig>;
}
/**
 * @internal
 */
export declare const getHttpAuthSchemeEndpointRuleSetPlugin: <TConfig extends object, TContext extends HandlerExecutionContext, TParameters extends HttpAuthSchemeParameters, TInput extends object>(config: TConfig & PreviouslyResolved<TParameters>, { httpAuthSchemeParametersProvider, identityProviderConfigProvider, }: HttpAuthSchemeEndpointRuleSetPluginOptions<TConfig, TContext, TParameters, TInput>) => Pluggable<any, any>;
export {};

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/middleware-http-auth-scheme/getHttpAuthSchemePlugin.d.ts

```typescript
import { HandlerExecutionContext, HttpAuthSchemeParameters, HttpAuthSchemeParametersProvider, IdentityProviderConfig, Pluggable, RelativeMiddlewareOptions, SerializeHandlerOptions } from "@smithy/types";
import { PreviouslyResolved } from "./httpAuthSchemeMiddleware";
/**
 * @internal
 */
export declare const httpAuthSchemeMiddlewareOptions: SerializeHandlerOptions & RelativeMiddlewareOptions;
/**
 * @internal
 */
interface HttpAuthSchemePluginOptions<TConfig extends object, TContext extends HandlerExecutionContext, TParameters extends HttpAuthSchemeParameters, TInput extends object> {
    httpAuthSchemeParametersProvider: HttpAuthSchemeParametersProvider<TConfig, TContext, TParameters, TInput>;
    identityProviderConfigProvider: (config: TConfig) => Promise<IdentityProviderConfig>;
}
/**
 * @internal
 */
export declare const getHttpAuthSchemePlugin: <TConfig extends object, TContext extends HandlerExecutionContext, TParameters extends HttpAuthSchemeParameters, TInput extends object>(config: TConfig & PreviouslyResolved<TParameters>, { httpAuthSchemeParametersProvider, identityProviderConfigProvider, }: HttpAuthSchemePluginOptions<TConfig, TContext, TParameters, TInput>) => Pluggable<any, any>;
export {};

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/middleware-http-auth-scheme/httpAuthSchemeMiddleware.d.ts

```typescript
import { HandlerExecutionContext, HttpAuthScheme, HttpAuthSchemeParameters, HttpAuthSchemeParametersProvider, HttpAuthSchemeProvider, IdentityProviderConfig, Provider, SelectedHttpAuthScheme, SerializeMiddleware, SMITHY_CONTEXT_KEY } from "@smithy/types";
/**
 * @internal
 */
export interface PreviouslyResolved<TParameters extends HttpAuthSchemeParameters> {
    authSchemePreference?: Provider<string[]>;
    httpAuthSchemes: HttpAuthScheme[];
    httpAuthSchemeProvider: HttpAuthSchemeProvider<TParameters>;
}
/**
 * @internal
 */
interface HttpAuthSchemeMiddlewareOptions<TConfig extends object, TContext extends HandlerExecutionContext, TParameters extends HttpAuthSchemeParameters, TInput extends object> {
    httpAuthSchemeParametersProvider: HttpAuthSchemeParametersProvider<TConfig, TContext, TParameters, TInput>;
    identityProviderConfigProvider: (config: TConfig) => Promise<IdentityProviderConfig>;
}
/**
 * @internal
 */
interface HttpAuthSchemeMiddlewareSmithyContext extends Record<string, unknown> {
    selectedHttpAuthScheme?: SelectedHttpAuthScheme;
}
/**
 * @internal
 */
interface HttpAuthSchemeMiddlewareHandlerExecutionContext extends HandlerExecutionContext {
    [SMITHY_CONTEXT_KEY]?: HttpAuthSchemeMiddlewareSmithyContext;
}
/**
 * @internal
 */
export declare const httpAuthSchemeMiddleware: <TInput extends object, Output extends object, TConfig extends object, TContext extends HttpAuthSchemeMiddlewareHandlerExecutionContext, TParameters extends HttpAuthSchemeParameters>(config: TConfig & PreviouslyResolved<TParameters>, mwOptions: HttpAuthSchemeMiddlewareOptions<TConfig, TContext, TParameters, TInput>) => SerializeMiddleware<TInput, Output>;
export {};

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/middleware-http-auth-scheme/index.d.ts

```typescript
export * from "./httpAuthSchemeMiddleware";
export * from "./getHttpAuthSchemeEndpointRuleSetPlugin";
export * from "./getHttpAuthSchemePlugin";

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/middleware-http-auth-scheme/resolveAuthOptions.d.ts

```typescript
import { HttpAuthOption } from "@smithy/types";
/**
 * Resolves list of auth options based on the supported ones, vs the preference list.
 *
 * @param candidateAuthOptions list of supported auth options selected by the standard
 *   resolution process (model-based, endpoints 2.0, etc.)
 * @param authSchemePreference list of auth schemes preferred by user.
 * @returns
 */
export declare const resolveAuthOptions: (candidateAuthOptions: HttpAuthOption[], authSchemePreference: string[]) => HttpAuthOption[];

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/middleware-http-signing/getHttpSigningMiddleware.d.ts

```typescript
import { FinalizeRequestHandlerOptions, Pluggable, RelativeMiddlewareOptions } from "@smithy/types";
/**
 * @internal
 */
export declare const httpSigningMiddlewareOptions: FinalizeRequestHandlerOptions & RelativeMiddlewareOptions;
/**
 * @internal
 */
export declare const getHttpSigningPlugin: <Input extends object, Output extends object>(config: object) => Pluggable<Input, Output>;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/middleware-http-signing/httpSigningMiddleware.d.ts

```typescript
import { FinalizeRequestMiddleware } from "@smithy/types";
/**
 * @internal
 */
export declare const httpSigningMiddleware: <Input extends object, Output extends object>(config: object) => FinalizeRequestMiddleware<Input, Output>;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/middleware-http-signing/index.d.ts

```typescript
export * from "./httpSigningMiddleware";
export * from "./getHttpSigningMiddleware";

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/normalizeProvider.d.ts

```typescript
import { Provider } from "@smithy/types";
/**
 * @internal
 *
 * @returns a provider function for the input value if it isn't already one.
 */
export declare const normalizeProvider: <T>(input: T | Provider<T>) => Provider<T>;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/pagination/createPaginator.d.ts

```typescript
import { PaginationConfiguration, Paginator } from "@smithy/types";
/**
 * @internal
 *
 * Creates a paginator.
 */
export declare function createPaginator<PaginationConfigType extends PaginationConfiguration, InputType extends object, OutputType extends object>(ClientCtor: any, CommandCtor: any, inputTokenName: string, outputTokenName: string, pageSizeTokenName?: string): (config: PaginationConfigType, input: InputType, ...additionalArguments: any[]) => Paginator<OutputType>;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/request-builder/requestBuilder.d.ts

```typescript
/**
 * @internal
 * Backwards compatibility re-export.
 */
export { requestBuilder } from "@smithy/core/protocols";

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/setFeature.d.ts

```typescript
import { HandlerExecutionContext, SmithyFeatures } from "@smithy/types";
/**
 * @internal
 * Indicates to the request context that a given feature is active.
 *
 * @param context - handler execution context.
 * @param feature - readable name of feature.
 * @param value - encoding value of feature. This is required because the
 * specification asks the library not to include a runtime lookup of all
 * the feature identifiers.
 */
export declare function setFeature<F extends keyof SmithyFeatures>(context: HandlerExecutionContext, feature: F, value: SmithyFeatures[F]): void;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/submodules/cbor/CborCodec.d.ts

```typescript
import { SerdeContext } from "@smithy/core/protocols";
import { Codec, Schema, ShapeDeserializer, ShapeSerializer } from "@smithy/types";
/**
 * @alpha
 */
export declare class CborCodec extends SerdeContext implements Codec<Uint8Array, Uint8Array> {
    createSerializer(): CborShapeSerializer;
    createDeserializer(): CborShapeDeserializer;
}
/**
 * @alpha
 */
export declare class CborShapeSerializer extends SerdeContext implements ShapeSerializer {
    private value;
    write(schema: Schema, value: unknown): void;
    /**
     * Recursive serializer transform that copies and prepares the user input object
     * for CBOR serialization.
     */
    serialize(schema: Schema, source: unknown): any;
    flush(): Uint8Array;
}
/**
 * @alpha
 */
export declare class CborShapeDeserializer extends SerdeContext implements ShapeDeserializer {
    read(schema: Schema, bytes: Uint8Array): any;
    /**
     * Public because it's called by the protocol implementation to deserialize errors.
     * @internal
     */
    readValue(_schema: Schema, value: any): any;
}

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/submodules/cbor/SmithyRpcV2CborProtocol.d.ts

```typescript
import { RpcProtocol } from "@smithy/core/protocols";
import { EndpointBearer, HandlerExecutionContext, HttpRequest as IHttpRequest, HttpResponse as IHttpResponse, MetadataBearer, OperationSchema, ResponseMetadata, SerdeFunctions } from "@smithy/types";
import { CborCodec } from "./CborCodec";
/**
 * Client protocol for Smithy RPCv2 CBOR.
 *
 * @alpha
 */
export declare class SmithyRpcV2CborProtocol extends RpcProtocol {
    private codec;
    protected serializer: import("./CborCodec").CborShapeSerializer;
    protected deserializer: import("./CborCodec").CborShapeDeserializer;
    constructor({ defaultNamespace }: {
        defaultNamespace: string;
    });
    getShapeId(): string;
    getPayloadCodec(): CborCodec;
    serializeRequest<Input extends object>(operationSchema: OperationSchema, input: Input, context: HandlerExecutionContext & SerdeFunctions & EndpointBearer): Promise<IHttpRequest>;
    deserializeResponse<Output extends MetadataBearer>(operationSchema: OperationSchema, context: HandlerExecutionContext & SerdeFunctions, response: IHttpResponse): Promise<Output>;
    protected handleError(operationSchema: OperationSchema, context: HandlerExecutionContext & SerdeFunctions, response: IHttpResponse, dataObject: any, metadata: ResponseMetadata): Promise<never>;
    protected getDefaultContentType(): string;
}

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/submodules/cbor/byte-printer.d.ts

```typescript
/**
 * Prints bytes as binary string with numbers.
 * @param bytes - to print.
 * @deprecated for testing only, do not use in runtime.
 */
export declare function printBytes(bytes: Uint8Array): string[];

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/submodules/cbor/cbor-decode.d.ts

```typescript
import { CborValueType, Float32, Uint8, Uint32 } from "./cbor-types";
/**
 * @internal
 * @param bytes - to be set as the decode source.
 *
 * Sets the decode bytearray source and its data view.
 */
export declare function setPayload(bytes: Uint8Array): void;
/**
 * @internal
 * Decodes the data between the two indices.
 */
export declare function decode(at: Uint32, to: Uint32): CborValueType;
/**
 * @internal
 */
export declare function bytesToFloat16(a: Uint8, b: Uint8): Float32;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/submodules/cbor/cbor-encode.d.ts

```typescript
/**
 * @internal
 */
export declare function toUint8Array(): Uint8Array;
export declare function resize(size: number): void;
/**
 * @param _input - JS data object.
 */
export declare function encode(_input: any): void;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/submodules/cbor/cbor-types.d.ts

```typescript
export type CborItemType = undefined | boolean | number | bigint | [
    CborUnstructuredByteStringType,
    Uint64
] | string | CborTagType;
export type CborTagType = {
    tag: Uint64 | number;
    value: CborValueType;
    [tagSymbol]: true;
};
export type CborUnstructuredByteStringType = Uint8Array;
export type CborListType<T = any> = Array<T>;
export type CborMapType<T = any> = Record<string, T>;
export type CborCollectionType<T = any> = CborMapType<T> | CborListType<T>;
export type CborValueType = CborItemType | CborCollectionType | any;
export type CborArgumentLength = 1 | 2 | 4 | 8;
export type CborArgumentLengthOffset = 1 | 2 | 3 | 5 | 9;
export type CborOffset = number;
export type Uint8 = number;
export type Uint32 = number;
export type Uint64 = bigint;
export type Float32 = number;
export type Int64 = bigint;
export type Float16Binary = number;
export type Float32Binary = number;
export type CborMajorType = typeof majorUint64 | typeof majorNegativeInt64 | typeof majorUnstructuredByteString | typeof majorUtf8String | typeof majorList | typeof majorMap | typeof majorTag | typeof majorSpecial;
export declare const majorUint64 = 0;
export declare const majorNegativeInt64 = 1;
export declare const majorUnstructuredByteString = 2;
export declare const majorUtf8String = 3;
export declare const majorList = 4;
export declare const majorMap = 5;
export declare const majorTag = 6;
export declare const majorSpecial = 7;
export declare const specialFalse = 20;
export declare const specialTrue = 21;
export declare const specialNull = 22;
export declare const specialUndefined = 23;
export declare const extendedOneByte = 24;
export declare const extendedFloat16 = 25;
export declare const extendedFloat32 = 26;
export declare const extendedFloat64 = 27;
export declare const minorIndefinite = 31;
export declare function alloc(size: number): Uint8Array;
/**
 * @public
 *
 * The presence of this symbol as an object key indicates it should be considered a tag
 * for CBOR serialization purposes.
 *
 * The object must also have the properties "tag" and "value".
 */
export declare const tagSymbol: unique symbol;
/**
 * @public
 * Applies the tag symbol to the object.
 */
export declare function tag(data: {
    tag: number | bigint;
    value: any;
    [tagSymbol]?: true;
}): {
    tag: number | bigint;
    value: any;
    [tagSymbol]: true;
};

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/submodules/cbor/cbor.d.ts

```typescript
/**
 * This implementation is synchronous and only implements the parts of CBOR
 * specification used by Smithy RPCv2 CBOR protocol.
 *
 * This cbor serde implementation is derived from AWS SDK for Go's implementation.
 * @see https://github.com/aws/smithy-go/tree/main/encoding/cbor
 *
 * The cbor-x implementation was also instructional:
 * @see https://github.com/kriszyp/cbor-x
 */
export declare const cbor: {
    deserialize(payload: Uint8Array): any;
    serialize(input: any): Uint8Array;
    /**
     * @public
     * @param size - byte length to allocate.
     *
     * This may be used to garbage collect the CBOR
     * shared encoding buffer space,
     * e.g. resizeEncodingBuffer(0);
     *
     * This may also be used to pre-allocate more space for
     * CBOR encoding, e.g. resizeEncodingBuffer(100_000_000);
     */
    resizeEncodingBuffer(size: number): void;
};

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/submodules/cbor/index.d.ts

```typescript
export { cbor } from "./cbor";
export { tag, tagSymbol } from "./cbor-types";
export * from "./parseCborBody";
export * from "./SmithyRpcV2CborProtocol";
export * from "./CborCodec";

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/submodules/cbor/parseCborBody.d.ts

```typescript
import { HttpRequest as __HttpRequest } from "@smithy/protocol-http";
import { HeaderBag as __HeaderBag, HttpResponse, SerdeContext as __SerdeContext, SerdeContext } from "@smithy/types";
import { tagSymbol } from "./cbor-types";
/**
 * @internal
 */
export declare const parseCborBody: (streamBody: any, context: SerdeContext) => any;
/**
 * @internal
 */
export declare const dateToTag: (date: Date) => {
    tag: number | bigint;
    value: any;
    [tagSymbol]: true;
};
/**
 * @internal
 */
export declare const parseCborErrorBody: (errorBody: any, context: SerdeContext) => Promise<any>;
/**
 * @internal
 */
export declare const loadSmithyRpcV2CborErrorCode: (output: HttpResponse, data: any) => string | undefined;
/**
 * @internal
 */
export declare const checkCborResponse: (response: HttpResponse) => void;
/**
 * @internal
 */
export declare const buildHttpRpcRequest: (context: __SerdeContext, headers: __HeaderBag, path: string, resolvedHostname: string | undefined, body: any) => Promise<__HttpRequest>;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/submodules/event-streams/EventStreamSerde.d.ts

```typescript
import { NormalizedSchema } from "@smithy/core/schema";
import { EventStreamMarshaller, HttpRequest as IHttpRequest, HttpResponse as IHttpResponse, SerdeFunctions, ShapeDeserializer, ShapeSerializer } from "@smithy/types";
/**
 * Separated module for async mixin of EventStream serde capability.
 * This is used by the HttpProtocol base class from \@smithy/core/protocols.
 *
 * @alpha
 */
export declare class EventStreamSerde {
    private readonly marshaller;
    private readonly serializer;
    private readonly deserializer;
    private readonly serdeContext?;
    private readonly defaultContentType;
    /**
     * Properties are injected by the HttpProtocol.
     */
    constructor({ marshaller, serializer, deserializer, serdeContext, defaultContentType, }: {
        marshaller: EventStreamMarshaller;
        serializer: ShapeSerializer<string | Uint8Array>;
        deserializer: ShapeDeserializer<string | Uint8Array>;
        serdeContext?: SerdeFunctions;
        defaultContentType: string;
    });
    /**
     * @param eventStream - the iterable provided by the caller.
     * @param requestSchema - the schema of the event stream container (struct).
     * @param [initialRequest] - only provided if the initial-request is part of the event stream (RPC).
     *
     * @returns a stream suitable for the HTTP body of a request.
     */
    serializeEventStream({ eventStream, requestSchema, initialRequest, }: {
        eventStream: AsyncIterable<any>;
        requestSchema: NormalizedSchema;
        initialRequest?: any;
    }): Promise<IHttpRequest["body"] | Uint8Array>;
    /**
     * @param response - http response from which to read the event stream.
     * @param unionSchema - schema of the event stream container (struct).
     * @param [initialResponseContainer] - provided and written to only if the initial response is part of the event stream (RPC).
     *
     * @returns the asyncIterable of the event stream for the end-user.
     */
    deserializeEventStream({ response, responseSchema, initialResponseContainer, }: {
        response: IHttpResponse;
        responseSchema: NormalizedSchema;
        initialResponseContainer?: any;
    }): Promise<AsyncIterable<{
        [key: string]: any;
        $unknown?: unknown;
    }>>;
    /**
     * @param unionMember - member name within the structure that contains an event stream union.
     * @param unionSchema - schema of the union.
     * @param event
     *
     * @returns the event body (bytes) and event type (string).
     */
    private writeEventBody;
}

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/submodules/event-streams/index.d.ts

```typescript
export * from "./EventStreamSerde";

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/submodules/protocols/HttpBindingProtocol.d.ts

```typescript
import { NormalizedSchema } from "@smithy/core/schema";
import { HttpRequest } from "@smithy/protocol-http";
import { EndpointBearer, HandlerExecutionContext, HttpRequest as IHttpRequest, HttpResponse as IHttpResponse, MetadataBearer, OperationSchema, Schema, SerdeFunctions } from "@smithy/types";
import { HttpProtocol } from "./HttpProtocol";
/**
 * Base for HTTP-binding protocols. Downstream examples
 * include AWS REST JSON and AWS REST XML.
 *
 * @alpha
 */
export declare abstract class HttpBindingProtocol extends HttpProtocol {
    serializeRequest<Input extends object>(operationSchema: OperationSchema, _input: Input, context: HandlerExecutionContext & SerdeFunctions & EndpointBearer): Promise<IHttpRequest>;
    protected serializeQuery(ns: NormalizedSchema, data: any, query: HttpRequest["query"]): void;
    deserializeResponse<Output extends MetadataBearer>(operationSchema: OperationSchema, context: HandlerExecutionContext & SerdeFunctions, response: IHttpResponse): Promise<Output>;
    /**
     * The base method ignores HTTP bindings.
     *
     * @deprecated (only this signature) use signature without headerBindings.
     * @override
     */
    protected deserializeHttpMessage(schema: Schema, context: HandlerExecutionContext & SerdeFunctions, response: IHttpResponse, headerBindings: Set<string>, dataObject: any): Promise<string[]>;
    protected deserializeHttpMessage(schema: Schema, context: HandlerExecutionContext & SerdeFunctions, response: IHttpResponse, dataObject: any): Promise<string[]>;
}

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/submodules/protocols/HttpProtocol.d.ts

```typescript
import { EventStreamSerde } from "@smithy/core/event-streams";
import { NormalizedSchema } from "@smithy/core/schema";
import { ClientProtocol, Codec, Endpoint, EndpointBearer, EndpointV2, EventStreamMarshaller, HandlerExecutionContext, HttpRequest as IHttpRequest, HttpResponse as IHttpResponse, MetadataBearer, OperationSchema, ResponseMetadata, Schema, SerdeFunctions, ShapeDeserializer, ShapeSerializer } from "@smithy/types";
import { SerdeContext } from "./SerdeContext";
/**
 * Abstract base for HTTP-based client protocols.
 *
 * @alpha
 */
export declare abstract class HttpProtocol extends SerdeContext implements ClientProtocol<IHttpRequest, IHttpResponse> {
    readonly options: {
        defaultNamespace: string;
    };
    protected abstract serializer: ShapeSerializer<string | Uint8Array>;
    protected abstract deserializer: ShapeDeserializer<string | Uint8Array>;
    protected constructor(options: {
        defaultNamespace: string;
    });
    abstract getShapeId(): string;
    abstract getPayloadCodec(): Codec<any, any>;
    getRequestType(): new (...args: any[]) => IHttpRequest;
    getResponseType(): new (...args: any[]) => IHttpResponse;
    /**
     * @override
     */
    setSerdeContext(serdeContext: SerdeFunctions): void;
    abstract serializeRequest<Input extends object>(operationSchema: OperationSchema, input: Input, context: HandlerExecutionContext & SerdeFunctions & EndpointBearer): Promise<IHttpRequest>;
    updateServiceEndpoint(request: IHttpRequest, endpoint: EndpointV2 | Endpoint): IHttpRequest;
    abstract deserializeResponse<Output extends MetadataBearer>(operationSchema: OperationSchema, context: HandlerExecutionContext & SerdeFunctions, response: IHttpResponse): Promise<Output>;
    protected setHostPrefix<Input extends object>(request: IHttpRequest, operationSchema: OperationSchema, input: Input): void;
    protected abstract handleError(operationSchema: OperationSchema, context: HandlerExecutionContext & SerdeFunctions, response: IHttpResponse, dataObject: any, metadata: ResponseMetadata): Promise<never>;
    protected deserializeMetadata(output: IHttpResponse): ResponseMetadata;
    /**
     * @param eventStream - the iterable provided by the caller.
     * @param requestSchema - the schema of the event stream container (struct).
     * @param [initialRequest] - only provided if the initial-request is part of the event stream (RPC).
     *
     * @returns a stream suitable for the HTTP body of a request.
     */
    protected serializeEventStream({ eventStream, requestSchema, initialRequest, }: {
        eventStream: AsyncIterable<any>;
        requestSchema: NormalizedSchema;
        initialRequest?: any;
    }): Promise<IHttpRequest["body"]>;
    /**
     * @param response - http response from which to read the event stream.
     * @param unionSchema - schema of the event stream container (struct).
     * @param [initialResponseContainer] - provided and written to only if the initial response is part of the event stream (RPC).
     *
     * @returns the asyncIterable of the event stream.
     */
    protected deserializeEventStream({ response, responseSchema, initialResponseContainer, }: {
        response: IHttpResponse;
        responseSchema: NormalizedSchema;
        initialResponseContainer?: any;
    }): Promise<AsyncIterable<{
        [key: string]: any;
        $unknown?: unknown;
    }>>;
    /**
     * Loads eventStream capability async (for chunking).
     */
    protected loadEventStreamCapability(): Promise<EventStreamSerde>;
    /**
     * @returns content-type default header value for event stream events and other documents.
     */
    protected getDefaultContentType(): string;
    /**
     * For HTTP binding protocols, this method is overridden in {@link HttpBindingProtocol}.
     *
     * @deprecated only use this for HTTP binding protocols.
     */
    protected deserializeHttpMessage(schema: Schema, context: HandlerExecutionContext & SerdeFunctions, response: IHttpResponse, headerBindings: Set<string>, dataObject: any): Promise<string[]>;
    protected deserializeHttpMessage(schema: Schema, context: HandlerExecutionContext & SerdeFunctions, response: IHttpResponse, dataObject: any): Promise<string[]>;
    protected getEventStreamMarshaller(): EventStreamMarshaller;
}

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/submodules/protocols/RpcProtocol.d.ts

```typescript
import { EndpointBearer, HandlerExecutionContext, HttpRequest as IHttpRequest, HttpResponse as IHttpResponse, MetadataBearer, OperationSchema, SerdeFunctions } from "@smithy/types";
import { HttpProtocol } from "./HttpProtocol";
/**
 * Abstract base for RPC-over-HTTP protocols.
 *
 * @alpha
 */
export declare abstract class RpcProtocol extends HttpProtocol {
    serializeRequest<Input extends object>(operationSchema: OperationSchema, input: Input, context: HandlerExecutionContext & SerdeFunctions & EndpointBearer): Promise<IHttpRequest>;
    deserializeResponse<Output extends MetadataBearer>(operationSchema: OperationSchema, context: HandlerExecutionContext & SerdeFunctions, response: IHttpResponse): Promise<Output>;
}

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/submodules/protocols/SerdeContext.d.ts

```typescript
import { ConfigurableSerdeContext, SerdeFunctions } from "@smithy/types";
/**
 * @internal
 */
export declare abstract class SerdeContext implements ConfigurableSerdeContext {
    protected serdeContext?: SerdeFunctions;
    setSerdeContext(serdeContext: SerdeFunctions): void;
}

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/submodules/protocols/collect-stream-body.d.ts

```typescript
import { SerdeContext } from "@smithy/types";
import { Uint8ArrayBlobAdapter } from "@smithy/util-stream";
/**
 * @internal
 *
 * Collect low-level response body stream to Uint8Array.
 */
export declare const collectBody: (streamBody: any | undefined, context: {
    streamCollector: SerdeContext["streamCollector"];
}) => Promise<Uint8ArrayBlobAdapter>;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/submodules/protocols/extended-encode-uri-component.d.ts

```typescript
/**
 * @internal
 *
 * Function that wraps encodeURIComponent to encode additional characters
 * to fully adhere to RFC 3986.
 */
export declare function extendedEncodeURIComponent(str: string): string;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/submodules/protocols/index.d.ts

```typescript
export * from "./collect-stream-body";
export * from "./extended-encode-uri-component";
export * from "./HttpBindingProtocol";
export * from "./HttpProtocol";
export * from "./RpcProtocol";
export * from "./requestBuilder";
export * from "./resolve-path";
export * from "./serde/FromStringShapeDeserializer";
export * from "./serde/HttpInterceptingShapeDeserializer";
export * from "./serde/HttpInterceptingShapeSerializer";
export * from "./serde/ToStringShapeSerializer";
export * from "./serde/determineTimestampFormat";
export * from "./SerdeContext";

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/submodules/protocols/requestBuilder.d.ts

```typescript
import { HttpRequest } from "@smithy/protocol-http";
import { SerdeContext } from "@smithy/types";
/**
 * @internal
 * used in code-generated serde.
 */
export declare function requestBuilder(input: any, context: SerdeContext): RequestBuilder;
/**
 * @internal
 */
export declare class RequestBuilder {
    private input;
    private context;
    private query;
    private method;
    private headers;
    private path;
    private body;
    private hostname;
    private resolvePathStack;
    constructor(input: any, context: SerdeContext);
    build(): Promise<HttpRequest>;
    /**
     * Brevity setter for "hostname".
     */
    hn(hostname: string): this;
    /**
     * Brevity initial builder for "basepath".
     */
    bp(uriLabel: string): this;
    /**
     * Brevity incremental builder for "path".
     */
    p(memberName: string, labelValueProvider: () => string | undefined, uriLabel: string, isGreedyLabel: boolean): this;
    /**
     * Brevity setter for "headers".
     */
    h(headers: Record<string, string>): this;
    /**
     * Brevity setter for "query".
     */
    q(query: Record<string, string>): this;
    /**
     * Brevity setter for "body".
     */
    b(body: any): this;
    /**
     * Brevity setter for "method".
     */
    m(method: string): this;
}

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/submodules/protocols/resolve-path.d.ts

```typescript
/**
 * @internal
 */
export declare const resolvedPath: (resolvedPath: string, input: unknown, memberName: string, labelValueProvider: () => string | undefined, uriLabel: string, isGreedyLabel: boolean) => string;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/submodules/protocols/serde/FromStringShapeDeserializer.d.ts

```typescript
import { CodecSettings, Schema, ShapeDeserializer } from "@smithy/types";
import { SerdeContext } from "../SerdeContext";
/**
 * This deserializer reads strings.
 *
 * @alpha
 */
export declare class FromStringShapeDeserializer extends SerdeContext implements ShapeDeserializer<string> {
    private settings;
    constructor(settings: CodecSettings);
    read(_schema: Schema, data: string): any;
    private base64ToUtf8;
}

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/submodules/protocols/serde/HttpInterceptingShapeDeserializer.d.ts

```typescript
import { CodecSettings, Schema, SerdeFunctions, ShapeDeserializer } from "@smithy/types";
import { SerdeContext } from "../SerdeContext";
/**
 * This deserializer is a dispatcher that decides whether to use a string deserializer
 * or a codec deserializer based on HTTP traits.
 *
 * For example, in a JSON HTTP message, the deserialization of a field will differ depending on whether
 * it is bound to the HTTP header (string) or body (JSON).
 *
 * @alpha
 */
export declare class HttpInterceptingShapeDeserializer<CodecShapeDeserializer extends ShapeDeserializer<any>> extends SerdeContext implements ShapeDeserializer<string | Uint8Array> {
    private codecDeserializer;
    private stringDeserializer;
    constructor(codecDeserializer: CodecShapeDeserializer, codecSettings: CodecSettings);
    /**
     * @override
     */
    setSerdeContext(serdeContext: SerdeFunctions): void;
    read(schema: Schema, data: string | Uint8Array): any | Promise<any>;
}

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/submodules/protocols/serde/HttpInterceptingShapeSerializer.d.ts

```typescript
import { CodecSettings, ConfigurableSerdeContext, Schema as ISchema, SerdeFunctions, ShapeSerializer } from "@smithy/types";
import { ToStringShapeSerializer } from "./ToStringShapeSerializer";
/**
 * This serializer decides whether to dispatch to a string serializer or a codec serializer
 * depending on HTTP binding traits within the given schema.
 *
 * For example, a JavaScript array is serialized differently when being written
 * to a REST JSON HTTP header (comma-delimited string) and a REST JSON HTTP body (JSON array).
 *
 * @alpha
 */
export declare class HttpInterceptingShapeSerializer<CodecShapeSerializer extends ShapeSerializer<string | Uint8Array>> implements ShapeSerializer<string | Uint8Array>, ConfigurableSerdeContext {
    private codecSerializer;
    private stringSerializer;
    private buffer;
    constructor(codecSerializer: CodecShapeSerializer, codecSettings: CodecSettings, stringSerializer?: ToStringShapeSerializer);
    /**
     * @override
     */
    setSerdeContext(serdeContext: SerdeFunctions): void;
    write(schema: ISchema, value: unknown): void;
    flush(): string | Uint8Array;
}

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/submodules/protocols/serde/ToStringShapeSerializer.d.ts

```typescript
import { CodecSettings, Schema, ShapeSerializer } from "@smithy/types";
import { SerdeContext } from "../SerdeContext";
/**
 * Serializes a shape to string.
 *
 * @alpha
 */
export declare class ToStringShapeSerializer extends SerdeContext implements ShapeSerializer<string> {
    private settings;
    private stringBuffer;
    constructor(settings: CodecSettings);
    write(schema: Schema, value: unknown): void;
    flush(): string;
}

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/submodules/protocols/serde/determineTimestampFormat.d.ts

```typescript
import { NormalizedSchema } from "@smithy/core/schema";
import { CodecSettings, TimestampDateTimeSchema, TimestampEpochSecondsSchema, TimestampHttpDateSchema } from "@smithy/types";
/**
 * Assuming the schema is a timestamp type, the function resolves the format using
 * either the timestamp's own traits, or the default timestamp format from the CodecSettings.
 *
 * @internal
 */
export declare function determineTimestampFormat(ns: NormalizedSchema, settings: CodecSettings): TimestampDateTimeSchema | TimestampHttpDateSchema | TimestampEpochSecondsSchema;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/submodules/schema/TypeRegistry.d.ts

```typescript
import { Schema as ISchema, StaticErrorSchema } from "@smithy/types";
import { ErrorSchema } from "./schemas/ErrorSchema";
/**
 * A way to look up schema by their ShapeId values.
 *
 * @alpha
 */
export declare class TypeRegistry {
    readonly namespace: string;
    private schemas;
    private exceptions;
    static readonly registries: Map<string, TypeRegistry>;
    private constructor();
    /**
     * @param namespace - specifier.
     * @returns the schema for that namespace, creating it if necessary.
     */
    static for(namespace: string): TypeRegistry;
    /**
     * Adds the given schema to a type registry with the same namespace.
     *
     * @param shapeId - to be registered.
     * @param schema - to be registered.
     */
    register(shapeId: string, schema: ISchema): void;
    /**
     * @param shapeId - query.
     * @returns the schema.
     */
    getSchema(shapeId: string): ISchema;
    /**
     * Associates an error schema with its constructor.
     */
    registerError(es: ErrorSchema | StaticErrorSchema, ctor: any): void;
    /**
     * @param es - query.
     * @returns Error constructor that extends the service's base exception.
     */
    getErrorCtor(es: ErrorSchema | StaticErrorSchema): any;
    /**
     * The smithy-typescript code generator generates a synthetic (i.e. unmodeled) base exception,
     * because generated SDKs before the introduction of schemas have the notion of a ServiceBaseException, which
     * is unique per service/model.
     *
     * This is generated under a unique prefix that is combined with the service namespace, and this
     * method is used to retrieve it.
     *
     * The base exception synthetic schema is used when an error is returned by a service, but we cannot
     * determine what existing schema to use to deserialize it.
     *
     * @returns the synthetic base exception of the service namespace associated with this registry instance.
     */
    getBaseException(): StaticErrorSchema | undefined;
    /**
     * @param predicate - criterion.
     * @returns a schema in this registry matching the predicate.
     */
    find(predicate: (schema: ISchema) => boolean): ISchema | undefined;
    /**
     * Unloads the current TypeRegistry.
     */
    clear(): void;
    private normalizeShapeId;
}

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/submodules/schema/deref.d.ts

```typescript
import { Schema, SchemaRef } from "@smithy/types";
/**
 * Dereferences a SchemaRef if needed.
 * @internal
 */
export declare const deref: (schemaRef: SchemaRef) => Schema;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/submodules/schema/index.d.ts

```typescript
export * from "./deref";
export * from "./middleware/getSchemaSerdePlugin";
export * from "./schemas/ListSchema";
export * from "./schemas/MapSchema";
export * from "./schemas/OperationSchema";
export * from "./schemas/operation";
export * from "./schemas/ErrorSchema";
export * from "./schemas/NormalizedSchema";
export * from "./schemas/Schema";
export * from "./schemas/SimpleSchema";
export * from "./schemas/StructureSchema";
export * from "./schemas/sentinels";
export * from "./schemas/translateTraits";
export * from "./TypeRegistry";

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/submodules/schema/middleware/getSchemaSerdePlugin.d.ts

```typescript
import { DeserializeHandlerOptions, MetadataBearer, Pluggable, SerializeHandlerOptions } from "@smithy/types";
import { PreviouslyResolved } from "./schema-middleware-types";
/**
 * @internal
 */
export declare const deserializerMiddlewareOption: DeserializeHandlerOptions;
/**
 * @internal
 */
export declare const serializerMiddlewareOption: SerializeHandlerOptions;
/**
 * @internal
 */
export declare function getSchemaSerdePlugin<InputType extends object = any, OutputType extends MetadataBearer = any>(config: PreviouslyResolved): Pluggable<InputType, OutputType>;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/submodules/schema/middleware/schema-middleware-types.d.ts

```typescript
import { ClientProtocol, SerdeContext, UrlParser } from "@smithy/types";
/**
 * @internal
 */
export type PreviouslyResolved = Pick<SerdeContext & {
    urlParser: UrlParser;
    protocol: ClientProtocol<any, any>;
}, Exclude<keyof (SerdeContext & {
    urlParser: UrlParser;
    protocol: ClientProtocol<any, any>;
}), "endpoint">>;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/submodules/schema/middleware/schemaDeserializationMiddleware.d.ts

```typescript
import { DeserializeHandler, DeserializeHandlerArguments, HandlerExecutionContext } from "@smithy/types";
import { PreviouslyResolved } from "./schema-middleware-types";
/**
 * @internal
 */
export declare const schemaDeserializationMiddleware: <O>(config: PreviouslyResolved) => (next: DeserializeHandler<any, any>, context: HandlerExecutionContext) => (args: DeserializeHandlerArguments<any>) => Promise<{
    response: unknown;
    output: O;
}>;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/submodules/schema/middleware/schemaSerializationMiddleware.d.ts

```typescript
import { HandlerExecutionContext, SerializeHandler, SerializeHandlerArguments } from "@smithy/types";
import { PreviouslyResolved } from "./schema-middleware-types";
/**
 * @internal
 */
export declare const schemaSerializationMiddleware: (config: PreviouslyResolved) => (next: SerializeHandler<any, any>, context: HandlerExecutionContext) => (args: SerializeHandlerArguments<any>) => Promise<import("@smithy/types").SerializeHandlerOutput<any>>;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/submodules/schema/schemas/ErrorSchema.d.ts

```typescript
import { SchemaRef, SchemaTraits } from "@smithy/types";
import { StructureSchema } from "./StructureSchema";
/**
 * A schema for a structure shape having the error trait. These represent enumerated operation errors.
 * Because Smithy-TS SDKs use classes for exceptions, whereas plain objects are used for all other data,
 * and have an existing notion of a XYZServiceBaseException, the ErrorSchema differs from a StructureSchema
 * by additionally holding the class reference for the corresponding ServiceException class.
 *
 * @alpha
 * @deprecated use StaticSchema
 */
export declare class ErrorSchema extends StructureSchema {
    static readonly symbol: unique symbol;
    /**
     * @deprecated - field unused.
     */
    ctor: any;
    protected readonly symbol: symbol;
}
/**
 * Factory for ErrorSchema, to reduce codegen output and register the schema.
 *
 * @internal
 * @deprecated use StaticSchema
 *
 * @param namespace - shapeId namespace.
 * @param name - shapeId name.
 * @param traits - shape level serde traits.
 * @param memberNames - list of member names.
 * @param memberList - list of schemaRef corresponding to each
 * @param ctor - class reference for the existing Error extending class.
 */
export declare const error: (namespace: string, name: string, traits: SchemaTraits, memberNames: string[], memberList: SchemaRef[], 
/**
 * @deprecated - field unused.
 */
ctor?: any) => ErrorSchema;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/submodules/schema/schemas/ListSchema.d.ts

```typescript
import { ListSchema as IListSchema, SchemaRef, SchemaTraits } from "@smithy/types";
import { Schema } from "./Schema";
/**
 * A schema with a single member schema.
 * The deprecated Set type may be represented as a list.
 *
 * @alpha
 * @deprecated use StaticSchema
 */
export declare class ListSchema extends Schema implements IListSchema {
    static readonly symbol: unique symbol;
    name: string;
    traits: SchemaTraits;
    valueSchema: SchemaRef;
    protected readonly symbol: symbol;
}
/**
 * Factory for ListSchema.
 *
 * @internal
 * @deprecated use StaticSchema
 */
export declare const list: (namespace: string, name: string, traits: SchemaTraits, valueSchema: SchemaRef) => ListSchema;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/submodules/schema/schemas/MapSchema.d.ts

```typescript
import { MapSchema as IMapSchema, SchemaRef, SchemaTraits } from "@smithy/types";
import { Schema } from "./Schema";
/**
 * A schema with a key schema and value schema.
 * @alpha
 * @deprecated use StaticSchema
 */
export declare class MapSchema extends Schema implements IMapSchema {
    static readonly symbol: unique symbol;
    name: string;
    traits: SchemaTraits;
    /**
     * This is expected to be StringSchema, but may have traits.
     */
    keySchema: SchemaRef;
    valueSchema: SchemaRef;
    protected readonly symbol: symbol;
}
/**
 * Factory for MapSchema.
 * @internal
 * @deprecated use StaticSchema
 */
export declare const map: (namespace: string, name: string, traits: SchemaTraits, keySchema: SchemaRef, valueSchema: SchemaRef) => MapSchema;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/submodules/schema/schemas/NormalizedSchema.d.ts

```typescript
import { $MemberSchema, $Schema, $SchemaRef, NormalizedSchema as INormalizedSchema, SchemaRef, SchemaTraitsObject, StaticSchema } from "@smithy/types";
/**
 * Wraps both class instances, numeric sentinel values, and member schema pairs.
 * Presents a consistent interface for interacting with polymorphic schema representations.
 *
 * @alpha
 */
export declare class NormalizedSchema implements INormalizedSchema {
    readonly ref: $SchemaRef;
    private readonly memberName?;
    static readonly symbol: unique symbol;
    protected readonly symbol: symbol;
    private readonly name;
    private readonly schema;
    private readonly _isMemberSchema;
    private readonly traits;
    private readonly memberTraits;
    private normalizedTraits?;
    /**
     * @param ref - a polymorphic SchemaRef to be dereferenced/normalized.
     * @param memberName - optional memberName if this NormalizedSchema should be considered a member schema.
     */
    private constructor();
    static [Symbol.hasInstance](lhs: unknown): lhs is NormalizedSchema;
    /**
     * Static constructor that attempts to avoid wrapping a NormalizedSchema within another.
     */
    static of(ref: SchemaRef | $SchemaRef): NormalizedSchema;
    /**
     * @returns the underlying non-normalized schema.
     */
    getSchema(): Exclude<$Schema, $MemberSchema | INormalizedSchema>;
    /**
     * @param withNamespace - qualifies the name.
     * @returns e.g. `MyShape` or `com.namespace#MyShape`.
     */
    getName(withNamespace?: boolean): string | undefined;
    /**
     * @returns the member name if the schema is a member schema.
     */
    getMemberName(): string;
    isMemberSchema(): boolean;
    /**
     * boolean methods on this class help control flow in shape serialization and deserialization.
     */
    isListSchema(): boolean;
    isMapSchema(): boolean;
    isStructSchema(): boolean;
    isBlobSchema(): boolean;
    isTimestampSchema(): boolean;
    isUnitSchema(): boolean;
    isDocumentSchema(): boolean;
    isStringSchema(): boolean;
    isBooleanSchema(): boolean;
    isNumericSchema(): boolean;
    isBigIntegerSchema(): boolean;
    isBigDecimalSchema(): boolean;
    isStreaming(): boolean;
    /**
     * This is a shortcut to avoid calling `getMergedTraits().idempotencyToken` on every string.
     * @returns whether the schema has the idempotencyToken trait.
     */
    isIdempotencyToken(): boolean;
    /**
     * @returns own traits merged with member traits, where member traits of the same trait key take priority.
     * This method is cached.
     */
    getMergedTraits(): SchemaTraitsObject;
    /**
     * @returns only the member traits. If the schema is not a member, this returns empty.
     */
    getMemberTraits(): SchemaTraitsObject;
    /**
     * @returns only the traits inherent to the shape or member target shape if this schema is a member.
     * If there are any member traits they are excluded.
     */
    getOwnTraits(): SchemaTraitsObject;
    /**
     * @returns the map's key's schema. Returns a dummy Document schema if this schema is a Document.
     *
     * @throws Error if the schema is not a Map or Document.
     */
    getKeySchema(): NormalizedSchema;
    /**
     * @returns the schema of the map's value or list's member.
     * Returns a dummy Document schema if this schema is a Document.
     *
     * @throws Error if the schema is not a Map, List, nor Document.
     */
    getValueSchema(): NormalizedSchema;
    /**
     * @returns the NormalizedSchema for the given member name. The returned instance will return true for `isMemberSchema()`
     * and will have the member name given.
     * @param memberName - which member to retrieve and wrap.
     *
     * @throws Error if member does not exist or the schema is neither a document nor structure.
     * Note that errors are assumed to be structures and unions are considered structures for these purposes.
     */
    getMemberSchema(memberName: string): NormalizedSchema;
    /**
     * This can be used for checking the members as a hashmap.
     * Prefer the structIterator method for iteration.
     *
     * This does NOT return list and map members, it is only for structures.
     *
     * @deprecated use (checked) structIterator instead.
     *
     * @returns a map of member names to member schemas (normalized).
     */
    getMemberSchemas(): Record<string, NormalizedSchema>;
    /**
     * @returns member name of event stream or empty string indicating none exists or this
     * isn't a structure schema.
     */
    getEventStreamMember(): string;
    /**
     * Allows iteration over members of a structure schema.
     * Each yield is a pair of the member name and member schema.
     *
     * This avoids the overhead of calling Object.entries(ns.getMemberSchemas()).
     */
    structIterator(): Generator<[
        string,
        NormalizedSchema
    ], undefined, undefined>;
}
/**
 * @internal
 */
export declare const isStaticSchema: (sc: SchemaRef) => sc is StaticSchema;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/submodules/schema/schemas/OperationSchema.d.ts

```typescript
import { OperationSchema as IOperationSchema, SchemaRef, SchemaTraits } from "@smithy/types";
import { Schema } from "./Schema";
/**
 * This is used as a reference container for the input/output pair of schema, and for trait
 * detection on the operation that may affect client protocol logic.
 *
 * @alpha
 * @deprecated use StaticSchema
 */
export declare class OperationSchema extends Schema implements IOperationSchema {
    static readonly symbol: unique symbol;
    name: string;
    traits: SchemaTraits;
    input: SchemaRef;
    output: SchemaRef;
    protected readonly symbol: symbol;
}
/**
 * Factory for OperationSchema.
 * @internal
 * @deprecated use StaticSchema
 */
export declare const op: (namespace: string, name: string, traits: SchemaTraits, input: SchemaRef, output: SchemaRef) => OperationSchema;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/submodules/schema/schemas/Schema.d.ts

```typescript
import { SchemaTraits, TraitsSchema } from "@smithy/types";
/**
 * Abstract base for class-based Schema except NormalizedSchema.
 *
 * @alpha
 * @deprecated use StaticSchema
 */
export declare abstract class Schema implements TraitsSchema {
    name: string;
    namespace: string;
    traits: SchemaTraits;
    protected abstract readonly symbol: symbol;
    static assign<T extends Schema>(instance: T, values: Pick<T, Exclude<keyof T, "getName" | "symbol">>): T;
    static [Symbol.hasInstance](lhs: unknown): boolean;
    getName(): string;
}

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/submodules/schema/schemas/SimpleSchema.d.ts

```typescript
import { SchemaRef, SchemaTraits, TraitsSchema } from "@smithy/types";
import { Schema } from "./Schema";
/**
 * Although numeric values exist for most simple schema, this class is used for cases where traits are
 * attached to those schema, since a single number cannot easily represent both a schema and its traits.
 *
 * @alpha
 * @deprecated use StaticSchema
 */
export declare class SimpleSchema extends Schema implements TraitsSchema {
    static readonly symbol: unique symbol;
    name: string;
    schemaRef: SchemaRef;
    traits: SchemaTraits;
    protected readonly symbol: symbol;
}
/**
 * Factory for simple schema class objects.
 *
 * @internal
 * @deprecated use StaticSchema
 */
export declare const sim: (namespace: string, name: string, schemaRef: SchemaRef, traits: SchemaTraits) => SimpleSchema;
/**
 * @internal
 * @deprecated
 */
export declare const simAdapter: (namespace: string, name: string, traits: SchemaTraits, schemaRef: SchemaRef) => SimpleSchema;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/submodules/schema/schemas/StructureSchema.d.ts

```typescript
import { SchemaRef, SchemaTraits, StructureSchema as IStructureSchema } from "@smithy/types";
import { Schema } from "./Schema";
/**
 * A structure schema has a known list of members. This is also used for unions.
 *
 * @alpha
 * @deprecated use StaticSchema
 */
export declare class StructureSchema extends Schema implements IStructureSchema {
    static symbol: symbol;
    name: string;
    traits: SchemaTraits;
    memberNames: string[];
    memberList: SchemaRef[];
    protected readonly symbol: symbol;
}
/**
 * Factory for StructureSchema.
 *
 * @internal
 * @deprecated use StaticSchema
 */
export declare const struct: (namespace: string, name: string, traits: SchemaTraits, memberNames: string[], memberList: SchemaRef[]) => StructureSchema;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/submodules/schema/schemas/operation.d.ts

```typescript
import { OperationSchema, SchemaRef, SchemaTraits } from "@smithy/types";
/**
 * Converts the static schema array into an object-form to adapt
 * to the signature of ClientProtocol classes.
 * @internal
 */
export declare const operation: (namespace: string, name: string, traits: SchemaTraits, input: SchemaRef, output: SchemaRef) => OperationSchema;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/submodules/schema/schemas/sentinels.d.ts

```typescript
import { BigDecimalSchema, BigIntegerSchema, BlobSchema, BooleanSchema, DocumentSchema, ListSchemaModifier, MapSchemaModifier, NumericSchema, StreamingBlobSchema, StringSchema, TimestampDateTimeSchema, TimestampDefaultSchema, TimestampEpochSecondsSchema, TimestampHttpDateSchema } from "@smithy/types";
/**
 * Schema sentinel runtime values.
 * @alpha
 *
 * @deprecated use inline numbers with type annotation to save space.
 */
export declare const SCHEMA: {
    BLOB: BlobSchema;
    STREAMING_BLOB: StreamingBlobSchema;
    BOOLEAN: BooleanSchema;
    STRING: StringSchema;
    NUMERIC: NumericSchema;
    BIG_INTEGER: BigIntegerSchema;
    BIG_DECIMAL: BigDecimalSchema;
    DOCUMENT: DocumentSchema;
    TIMESTAMP_DEFAULT: TimestampDefaultSchema;
    TIMESTAMP_DATE_TIME: TimestampDateTimeSchema;
    TIMESTAMP_HTTP_DATE: TimestampHttpDateSchema;
    TIMESTAMP_EPOCH_SECONDS: TimestampEpochSecondsSchema;
    LIST_MODIFIER: ListSchemaModifier;
    MAP_MODIFIER: MapSchemaModifier;
};

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/submodules/schema/schemas/translateTraits.d.ts

```typescript
import { SchemaTraits, SchemaTraitsObject } from "@smithy/types";
/**
 * @internal
 * @param indicator - numeric indicator for preset trait combination.
 * @returns equivalent trait object.
 */
export declare function translateTraits(indicator: SchemaTraits): SchemaTraitsObject;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/submodules/serde/copyDocumentWithTransform.d.ts

```typescript
import { SchemaRef } from "@smithy/types";
/**
 * @internal
 * @deprecated the former functionality has been internalized to the CborCodec.
 */
export declare const copyDocumentWithTransform: (source: any, schemaRef: SchemaRef, transform?: (_: any, schemaRef: SchemaRef) => any) => any;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/submodules/serde/date-utils.d.ts

```typescript
/**
 * @internal
 *
 * Builds a proper UTC HttpDate timestamp from a Date object
 * since not all environments will have this as the expected
 * format.
 *
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toUTCString}
 * - Prior to ECMAScript 2018, the format of the return value
 * - varied according to the platform. The most common return
 * - value was an RFC-1123 formatted date stamp, which is a
 * - slightly updated version of RFC-822 date stamps.
 */
export declare function dateToUtcString(date: Date): string;
/**
 * @internal
 *
 * Parses a value into a Date. Returns undefined if the input is null or
 * undefined, throws an error if the input is not a string that can be parsed
 * as an RFC 3339 date.
 *
 * Input strings must conform to RFC3339 section 5.6, and cannot have a UTC
 * offset. Fractional precision is supported.
 *
 * @see {@link https://xml2rfc.tools.ietf.org/public/rfc/html/rfc3339.html#anchor14}
 *
 * @param value - the value to parse
 * @returns a Date or undefined
 */
export declare const parseRfc3339DateTime: (value: unknown) => Date | undefined;
/**
 * @internal
 *
 * Parses a value into a Date. Returns undefined if the input is null or
 * undefined, throws an error if the input is not a string that can be parsed
 * as an RFC 3339 date.
 *
 * Input strings must conform to RFC3339 section 5.6, and can have a UTC
 * offset. Fractional precision is supported.
 *
 * @see {@link https://xml2rfc.tools.ietf.org/public/rfc/html/rfc3339.html#anchor14}
 *
 * @param value - the value to parse
 * @returns a Date or undefined
 */
export declare const parseRfc3339DateTimeWithOffset: (value: unknown) => Date | undefined;
/**
 * @internal
 *
 * Parses a value into a Date. Returns undefined if the input is null or
 * undefined, throws an error if the input is not a string that can be parsed
 * as an RFC 7231 IMF-fixdate or obs-date.
 *
 * Input strings must conform to RFC7231 section 7.1.1.1. Fractional seconds are supported.
 *
 * @see {@link https://datatracker.ietf.org/doc/html/rfc7231.html#section-7.1.1.1}
 *
 * @param value - the value to parse
 * @returns a Date or undefined
 */
export declare const parseRfc7231DateTime: (value: unknown) => Date | undefined;
/**
 * @internal
 *
 * Parses a value into a Date. Returns undefined if the input is null or
 * undefined, throws an error if the input is not a number or a parseable string.
 *
 * Input strings must be an integer or floating point number. Fractional seconds are supported.
 *
 * @param value - the value to parse
 * @returns a Date or undefined
 */
export declare const parseEpochTimestamp: (value: unknown) => Date | undefined;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/submodules/serde/generateIdempotencyToken.d.ts

```typescript
import { v4 as generateIdempotencyToken } from "@smithy/uuid";
export { generateIdempotencyToken };

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/submodules/serde/index.d.ts

```typescript
export * from "./copyDocumentWithTransform";
export * from "./date-utils";
export * from "./generateIdempotencyToken";
export * from "./lazy-json";
export * from "./parse-utils";
export * from "./quote-header";
export * from "./schema-serde-lib/schema-date-utils";
export * from "./split-every";
export * from "./split-header";
export * from "./value/NumericValue";

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/submodules/serde/lazy-json.d.ts

```typescript
/**
 * @public
 *
 * A model field with this type means that you may provide a JavaScript
 * object in lieu of a JSON string, and it will be serialized to JSON
 * automatically before being sent in a request.
 *
 * For responses, you will receive a "LazyJsonString", which is a boxed String object
 * with additional mixin methods.
 * To get the string value, call `.toString()`, or to get the JSON object value,
 * call `.deserializeJSON()` or parse it yourself.
 */
export type AutomaticJsonStringConversion = Parameters<typeof JSON.stringify>[0] | LazyJsonString;
/**
 * @internal
 */
export interface LazyJsonString extends String {
    /**
     * @returns the JSON parsing of the string value.
     */
    deserializeJSON(): any;
    /**
     * @returns the original string value rather than a JSON.stringified value.
     */
    toJSON(): string;
}
/**
 * @internal
 *
 * Extension of the native String class in the previous implementation
 * has negative global performance impact on method dispatch for strings,
 * and is generally discouraged.
 *
 * This current implementation may look strange, but is necessary to preserve the interface and
 * behavior of extending the String class.
 */
export declare const LazyJsonString: {
    new (s: string): LazyJsonString;
    (s: string): LazyJsonString;
    from(s: any): LazyJsonString;
    /**
     * @deprecated use #from.
     */
    fromObject(s: any): LazyJsonString;
};

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/submodules/serde/parse-utils.d.ts

```typescript
/**
 * @internal
 *
 * Give an input string, strictly parses a boolean value.
 *
 * @param value - The boolean string to parse.
 * @returns true for "true", false for "false", otherwise an error is thrown.
 */
export declare const parseBoolean: (value: string) => boolean;
/**
 * @internal
 *
 * Asserts a value is a boolean and returns it.
 * Casts strings and numbers with a warning if there is evidence that they were
 * intended to be booleans.
 *
 * @param value - A value that is expected to be a boolean.
 * @returns The value if it's a boolean, undefined if it's null/undefined,
 *   otherwise an error is thrown.
 */
export declare const expectBoolean: (value: any) => boolean | undefined;
/**
 * @internal
 *
 * Asserts a value is a number and returns it.
 * Casts strings with a warning if the string is a parseable number.
 * This is to unblock slight API definition/implementation inconsistencies.
 *
 * @param value - A value that is expected to be a number.
 * @returns The value if it's a number, undefined if it's null/undefined,
 *   otherwise an error is thrown.
 */
export declare const expectNumber: (value: any) => number | undefined;
/**
 * @internal
 *
 * Asserts a value is a 32-bit float and returns it.
 *
 * @param value - A value that is expected to be a 32-bit float.
 * @returns The value if it's a float, undefined if it's null/undefined,
 *   otherwise an error is thrown.
 */
export declare const expectFloat32: (value: any) => number | undefined;
/**
 * @internal
 *
 * Asserts a value is an integer and returns it.
 *
 * @param value - A value that is expected to be an integer.
 * @returns The value if it's an integer, undefined if it's null/undefined,
 *   otherwise an error is thrown.
 */
export declare const expectLong: (value: any) => number | undefined;
/**
 * @internal
 *
 * @deprecated Use expectLong
 */
export declare const expectInt: (value: any) => number | undefined;
/**
 * @internal
 *
 * Asserts a value is a 32-bit integer and returns it.
 *
 * @param value - A value that is expected to be an integer.
 * @returns The value if it's an integer, undefined if it's null/undefined,
 *   otherwise an error is thrown.
 */
export declare const expectInt32: (value: any) => number | undefined;
/**
 * @internal
 *
 * Asserts a value is a 16-bit integer and returns it.
 *
 * @param value - A value that is expected to be an integer.
 * @returns The value if it's an integer, undefined if it's null/undefined,
 *   otherwise an error is thrown.
 */
export declare const expectShort: (value: any) => number | undefined;
/**
 * @internal
 *
 * Asserts a value is an 8-bit integer and returns it.
 *
 * @param value - A value that is expected to be an integer.
 * @returns The value if it's an integer, undefined if it's null/undefined,
 *   otherwise an error is thrown.
 */
export declare const expectByte: (value: any) => number | undefined;
/**
 * @internal
 *
 * Asserts a value is not null or undefined and returns it, or throws an error.
 *
 * @param value - A value that is expected to be defined
 * @param location - The location where we're expecting to find a defined object (optional)
 * @returns The value if it's not undefined, otherwise throws an error
 */
export declare const expectNonNull: <T>(value: T | null | undefined, location?: string) => T;
/**
 * @internal
 *
 * Asserts a value is an JSON-like object and returns it. This is expected to be used
 * with values parsed from JSON (arrays, objects, numbers, strings, booleans).
 *
 * @param value - A value that is expected to be an object
 * @returns The value if it's an object, undefined if it's null/undefined,
 *   otherwise an error is thrown.
 */
export declare const expectObject: (value: any) => Record<string, any> | undefined;
/**
 * @internal
 *
 * Asserts a value is a string and returns it.
 * Numbers and boolean will be cast to strings with a warning.
 *
 * @param value - A value that is expected to be a string.
 * @returns The value if it's a string, undefined if it's null/undefined,
 *   otherwise an error is thrown.
 */
export declare const expectString: (value: any) => string | undefined;
/**
 * @internal
 *
 * Asserts a value is a JSON-like object with only one non-null/non-undefined key and
 * returns it.
 *
 * @param value - A value that is expected to be an object with exactly one non-null,
 *              non-undefined key.
 * @returns the value if it's a union, undefined if it's null/undefined, otherwise
 *  an error is thrown.
 */
export declare const expectUnion: (value: unknown) => Record<string, any> | undefined;
/**
 * @internal
 *
 * Parses a value into a double. If the value is null or undefined, undefined
 * will be returned. If the value is a string, it will be parsed by the standard
 * parseFloat with one exception: NaN may only be explicitly set as the string
 * "NaN", any implicit Nan values will result in an error being thrown. If any
 * other type is provided, an exception will be thrown.
 *
 * @param value - A number or string representation of a double.
 * @returns The value as a number, or undefined if it's null/undefined.
 */
export declare const strictParseDouble: (value: string | number) => number | undefined;
/**
 * @internal
 *
 * @deprecated Use strictParseDouble
 */
export declare const strictParseFloat: (value: string | number) => number | undefined;
/**
 * @internal
 *
 * Parses a value into a float. If the value is null or undefined, undefined
 * will be returned. If the value is a string, it will be parsed by the standard
 * parseFloat with one exception: NaN may only be explicitly set as the string
 * "NaN", any implicit Nan values will result in an error being thrown. If any
 * other type is provided, an exception will be thrown.
 *
 * @param value - A number or string representation of a float.
 * @returns The value as a number, or undefined if it's null/undefined.
 */
export declare const strictParseFloat32: (value: string | number) => number | undefined;
/**
 * @internal
 *
 * Asserts a value is a number and returns it. If the value is a string
 * representation of a non-numeric number type (NaN, Infinity, -Infinity),
 * the value will be parsed. Any other string value will result in an exception
 * being thrown. Null or undefined will be returned as undefined. Any other
 * type will result in an exception being thrown.
 *
 * @param value - A number or string representation of a non-numeric float.
 * @returns The value as a number, or undefined if it's null/undefined.
 */
export declare const limitedParseDouble: (value: string | number) => number | undefined;
/**
 * @internal
 *
 * @deprecated Use limitedParseDouble
 */
export declare const handleFloat: (value: string | number) => number | undefined;
/**
 * @internal
 *
 * @deprecated Use limitedParseDouble
 */
export declare const limitedParseFloat: (value: string | number) => number | undefined;
/**
 * @internal
 *
 * Asserts a value is a 32-bit float and returns it. If the value is a string
 * representation of a non-numeric number type (NaN, Infinity, -Infinity),
 * the value will be parsed. Any other string value will result in an exception
 * being thrown. Null or undefined will be returned as undefined. Any other
 * type will result in an exception being thrown.
 *
 * @param value - A number or string representation of a non-numeric float.
 * @returns The value as a number, or undefined if it's null/undefined.
 */
export declare const limitedParseFloat32: (value: string | number) => number | undefined;
/**
 * @internal
 *
 * Parses a value into an integer. If the value is null or undefined, undefined
 * will be returned. If the value is a string, it will be parsed by parseFloat
 * and the result will be asserted to be an integer. If the parsed value is not
 * an integer, or the raw value is any type other than a string or number, an
 * exception will be thrown.
 *
 * @param value - A number or string representation of an integer.
 * @returns The value as a number, or undefined if it's null/undefined.
 */
export declare const strictParseLong: (value: string | number) => number | undefined;
/**
 * @internal
 *
 * @deprecated Use strictParseLong
 */
export declare const strictParseInt: (value: string | number) => number | undefined;
/**
 * @internal
 *
 * Parses a value into a 32-bit integer. If the value is null or undefined, undefined
 * will be returned. If the value is a string, it will be parsed by parseFloat
 * and the result will be asserted to be an integer. If the parsed value is not
 * an integer, or the raw value is any type other than a string or number, an
 * exception will be thrown.
 *
 * @param value - A number or string representation of a 32-bit integer.
 * @returns The value as a number, or undefined if it's null/undefined.
 */
export declare const strictParseInt32: (value: string | number) => number | undefined;
/**
 * @internal
 *
 * Parses a value into a 16-bit integer. If the value is null or undefined, undefined
 * will be returned. If the value is a string, it will be parsed by parseFloat
 * and the result will be asserted to be an integer. If the parsed value is not
 * an integer, or the raw value is any type other than a string or number, an
 * exception will be thrown.
 *
 * @param value - A number or string representation of a 16-bit integer.
 * @returns The value as a number, or undefined if it's null/undefined.
 */
export declare const strictParseShort: (value: string | number) => number | undefined;
/**
 * @internal
 *
 * Parses a value into an 8-bit integer. If the value is null or undefined, undefined
 * will be returned. If the value is a string, it will be parsed by parseFloat
 * and the result will be asserted to be an integer. If the parsed value is not
 * an integer, or the raw value is any type other than a string or number, an
 * exception will be thrown.
 *
 * @param value - A number or string representation of an 8-bit integer.
 * @returns The value as a number, or undefined if it's null/undefined.
 */
export declare const strictParseByte: (value: string | number) => number | undefined;
/**
 * @internal
 */
export declare const logger: {
    warn: {
        (...data: any[]): void;
        (message?: any, ...optionalParams: any[]): void;
    };
};

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/submodules/serde/quote-header.d.ts

```typescript
/**
 * @public
 * @param part - header list element
 * @returns quoted string if part contains delimiter.
 */
export declare function quoteHeader(part: string): string;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/submodules/serde/schema-serde-lib/schema-date-utils.d.ts

```typescript
/**
 * @internal
 *
 * Parses a value into a Date. Returns undefined if the input is null or
 * undefined, throws an error if the input is not a number or a parseable string.
 *
 * Input strings must be an integer or floating point number. Fractional seconds are supported.
 *
 * @param value - the value to parse
 * @returns a Date or undefined
 */
export declare const _parseEpochTimestamp: (value: unknown) => Date | undefined;
/**
 * @internal
 *
 * Parses a value into a Date. Returns undefined if the input is null or
 * undefined, throws an error if the input is not a string that can be parsed
 * as an RFC 3339 date.
 *
 * Input strings must conform to RFC3339 section 5.6, and can have a UTC
 * offset. Fractional precision is supported.
 *
 * @see {@link https://xml2rfc.tools.ietf.org/public/rfc/html/rfc3339.html#anchor14}
 *
 * @param value - the value to parse
 * @returns a Date or undefined
 */
export declare const _parseRfc3339DateTimeWithOffset: (value: unknown) => Date | undefined;
/**
 * @internal
 *
 * Parses a value into a Date. Returns undefined if the input is null or
 * undefined, throws an error if the input is not a string that can be parsed
 * as an RFC 7231 date.
 *
 * Input strings must conform to RFC7231 section 7.1.1.1. Fractional seconds are supported.
 *
 * RFC 850 and unix asctime formats are also accepted.
 * todo: practically speaking, are RFC 850 and asctime even used anymore?
 * todo: can we remove those parts?
 *
 * @see {@link https://datatracker.ietf.org/doc/html/rfc7231.html#section-7.1.1.1}
 *
 * @param value - the value to parse.
 * @returns a Date or undefined.
 */
export declare const _parseRfc7231DateTime: (value: unknown) => Date | undefined;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/submodules/serde/split-every.d.ts

```typescript
/**
 * @internal
 *
 * Given an input string, splits based on the delimiter after a given
 * number of delimiters has been encountered.
 *
 * @param value - The input string to split.
 * @param delimiter - The delimiter to split on.
 * @param numDelimiters - The number of delimiters to have encountered to split.
 */
export declare function splitEvery(value: string, delimiter: string, numDelimiters: number): Array<string>;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/submodules/serde/split-header.d.ts

```typescript
/**
 * @param value - header string value.
 * @returns value split by commas that aren't in quotes.
 */
export declare const splitHeader: (value: string) => string[];

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/submodules/serde/value/NumericValue.d.ts

```typescript
/**
 * Types which may be represented by {@link NumericValue}.
 *
 * There is currently only one option, because BigInteger and Long should
 * use JS BigInt directly, and all other numeric types can be contained in JS Number.
 *
 * @public
 */
export type NumericType = "bigDecimal";
/**
 * Serialization container for Smithy simple types that do not have a
 * direct JavaScript runtime representation.
 *
 * This container does not perform numeric mathematical operations.
 * It is a container for discerning a value's true type.
 *
 * It allows storage of numeric types not representable in JS without
 * making a decision on what numeric library to use.
 *
 * @public
 */
export declare class NumericValue {
    readonly string: string;
    readonly type: NumericType;
    constructor(string: string, type: NumericType);
    toString(): string;
    static [Symbol.hasInstance](object: unknown): boolean;
}
/**
 * Serde shortcut.
 * @internal
 */
export declare function nv(input: string | unknown): NumericValue;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/util-identity-and-auth/DefaultIdentityProviderConfig.d.ts

```typescript
import { HttpAuthSchemeId, Identity, IdentityProvider, IdentityProviderConfig } from "@smithy/types";
/**
 * Default implementation of IdentityProviderConfig
 * @internal
 */
export declare class DefaultIdentityProviderConfig implements IdentityProviderConfig {
    private authSchemes;
    /**
     * Creates an IdentityProviderConfig with a record of scheme IDs to identity providers.
     *
     * @param config scheme IDs and identity providers to configure
     */
    constructor(config: Record<HttpAuthSchemeId, IdentityProvider<Identity> | undefined>);
    getIdentityProvider(schemeId: HttpAuthSchemeId): IdentityProvider<Identity> | undefined;
}

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/util-identity-and-auth/httpAuthSchemes/httpApiKeyAuth.d.ts

```typescript
import { HttpRequest } from "@smithy/protocol-http";
import { ApiKeyIdentity, HttpRequest as IHttpRequest, HttpSigner } from "@smithy/types";
/**
 * @internal
 */
export declare class HttpApiKeyAuthSigner implements HttpSigner {
    sign(httpRequest: HttpRequest, identity: ApiKeyIdentity, signingProperties: Record<string, any>): Promise<IHttpRequest>;
}

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/util-identity-and-auth/httpAuthSchemes/httpBearerAuth.d.ts

```typescript
import { HttpRequest } from "@smithy/protocol-http";
import { HttpRequest as IHttpRequest, HttpSigner, TokenIdentity } from "@smithy/types";
/**
 * @internal
 */
export declare class HttpBearerAuthSigner implements HttpSigner {
    sign(httpRequest: HttpRequest, identity: TokenIdentity, signingProperties: Record<string, any>): Promise<IHttpRequest>;
}

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/util-identity-and-auth/httpAuthSchemes/index.d.ts

```typescript
export * from "./httpApiKeyAuth";
export * from "./httpBearerAuth";
export * from "./noAuth";

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/util-identity-and-auth/httpAuthSchemes/noAuth.d.ts

```typescript
import { HttpRequest, HttpSigner, Identity } from "@smithy/types";
/**
 * Signer for the synthetic @smithy.api#noAuth auth scheme.
 * @internal
 */
export declare class NoAuthSigner implements HttpSigner {
    sign(httpRequest: HttpRequest, identity: Identity, signingProperties: Record<string, unknown>): Promise<HttpRequest>;
}

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/util-identity-and-auth/index.d.ts

```typescript
export * from "./DefaultIdentityProviderConfig";
export * from "./httpAuthSchemes";
export * from "./memoizeIdentityProvider";

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/ts3.4/util-identity-and-auth/memoizeIdentityProvider.d.ts

```typescript
import { Identity, IdentityProvider } from "@smithy/types";
/**
 * @internal
 */
export declare const createIsIdentityExpiredFunction: (expirationMs: number) => (identity: Identity) => boolean;
/**
 * @internal
 * This may need to be configurable in the future, but for now it is defaulted to 5min.
 */
export declare const EXPIRATION_MS = 300000;
/**
 * @internal
 */
export declare const isIdentityExpired: (identity: Identity) => boolean;
/**
 * @internal
 */
export declare const doesIdentityRequireRefresh: (identity: Identity) => boolean;
/**
 * @internal
 */
export interface MemoizedIdentityProvider<IdentityT extends Identity> {
    (options?: Record<string, any> & {
        forceRefresh?: boolean;
    }): Promise<IdentityT>;
}
/**
 * @internal
 */
export declare const memoizeIdentityProvider: <IdentityT extends Identity>(provider: IdentityT | IdentityProvider<IdentityT> | undefined, isExpired: (resolved: Identity) => boolean, requiresRefresh: (resolved: Identity) => boolean) => MemoizedIdentityProvider<IdentityT> | undefined;

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/util-identity-and-auth/DefaultIdentityProviderConfig.d.ts

```typescript
import type { HttpAuthSchemeId, Identity, IdentityProvider, IdentityProviderConfig } from "@smithy/types";
/**
 * Default implementation of IdentityProviderConfig
 * @internal
 */
export declare class DefaultIdentityProviderConfig implements IdentityProviderConfig {
    private authSchemes;
    /**
     * Creates an IdentityProviderConfig with a record of scheme IDs to identity providers.
     *
     * @param config scheme IDs and identity providers to configure
     */
    constructor(config: Record<HttpAuthSchemeId, IdentityProvider<Identity> | undefined>);
    getIdentityProvider(schemeId: HttpAuthSchemeId): IdentityProvider<Identity> | undefined;
}

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/util-identity-and-auth/httpAuthSchemes/httpApiKeyAuth.d.ts

```typescript
import { HttpRequest } from "@smithy/protocol-http";
import type { ApiKeyIdentity, HttpRequest as IHttpRequest, HttpSigner } from "@smithy/types";
/**
 * @internal
 */
export declare class HttpApiKeyAuthSigner implements HttpSigner {
    sign(httpRequest: HttpRequest, identity: ApiKeyIdentity, signingProperties: Record<string, any>): Promise<IHttpRequest>;
}

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/util-identity-and-auth/httpAuthSchemes/httpBearerAuth.d.ts

```typescript
import { HttpRequest } from "@smithy/protocol-http";
import type { HttpRequest as IHttpRequest, HttpSigner, TokenIdentity } from "@smithy/types";
/**
 * @internal
 */
export declare class HttpBearerAuthSigner implements HttpSigner {
    sign(httpRequest: HttpRequest, identity: TokenIdentity, signingProperties: Record<string, any>): Promise<IHttpRequest>;
}

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/util-identity-and-auth/httpAuthSchemes/index.d.ts

```typescript
export * from "./httpApiKeyAuth";
export * from "./httpBearerAuth";
export * from "./noAuth";

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/util-identity-and-auth/httpAuthSchemes/noAuth.d.ts

```typescript
import type { HttpRequest, HttpSigner, Identity } from "@smithy/types";
/**
 * Signer for the synthetic @smithy.api#noAuth auth scheme.
 * @internal
 */
export declare class NoAuthSigner implements HttpSigner {
    sign(httpRequest: HttpRequest, identity: Identity, signingProperties: Record<string, unknown>): Promise<HttpRequest>;
}

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/util-identity-and-auth/index.d.ts

```typescript
export * from "./DefaultIdentityProviderConfig";
export * from "./httpAuthSchemes";
export * from "./memoizeIdentityProvider";

```

## ./lib/lambda/node_modules/@smithy/core/dist-types/util-identity-and-auth/memoizeIdentityProvider.d.ts

```typescript
import type { Identity, IdentityProvider } from "@smithy/types";
/**
 * @internal
 */
export declare const createIsIdentityExpiredFunction: (expirationMs: number) => (identity: Identity) => boolean;
/**
 * @internal
 * This may need to be configurable in the future, but for now it is defaulted to 5min.
 */
export declare const EXPIRATION_MS = 300000;
/**
 * @internal
 */
export declare const isIdentityExpired: (identity: Identity) => boolean;
/**
 * @internal
 */
export declare const doesIdentityRequireRefresh: (identity: Identity) => boolean;
/**
 * @internal
 */
export interface MemoizedIdentityProvider<IdentityT extends Identity> {
    (options?: Record<string, any> & {
        forceRefresh?: boolean;
    }): Promise<IdentityT>;
}
/**
 * @internal
 */
export declare const memoizeIdentityProvider: <IdentityT extends Identity>(provider: IdentityT | IdentityProvider<IdentityT> | undefined, isExpired: (resolved: Identity) => boolean, requiresRefresh: (resolved: Identity) => boolean) => MemoizedIdentityProvider<IdentityT> | undefined;

```

## ./lib/lambda/node_modules/@smithy/core/event-streams.d.ts

```typescript
/**
 * Do not edit:
 * This is a compatibility redirect for contexts that do not understand package.json exports field.
 */
declare module "@smithy/core/event-streams" {
  export * from "@smithy/core/dist-types/submodules/event-streams/index.d";
}

```

## ./lib/lambda/node_modules/@smithy/core/package.json

```json
{
  "name": "@smithy/core",
  "version": "3.17.0",
  "scripts": {
    "build": "yarn lint && concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline core",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "rimraf dist-types/ts3.4 && downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "npx eslint -c ../../.eslintrc.js \"src/**/*.ts\" --fix && node ./scripts/lint",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../../.prettierignore --write \"**/*.{ts,md,json}\"",
    "extract:docs": "api-extractor run --local",
    "test:cbor:perf": "node ./scripts/cbor-perf.mjs",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "exports": {
    ".": {
      "types": "./dist-types/index.d.ts",
      "module": "./dist-es/index.js",
      "node": "./dist-cjs/index.js",
      "import": "./dist-es/index.js",
      "require": "./dist-cjs/index.js"
    },
    "./package.json": {
      "module": "./package.json",
      "node": "./package.json",
      "import": "./package.json",
      "require": "./package.json"
    },
    "./cbor": {
      "types": "./dist-types/submodules/cbor/index.d.ts",
      "module": "./dist-es/submodules/cbor/index.js",
      "node": "./dist-cjs/submodules/cbor/index.js",
      "import": "./dist-es/submodules/cbor/index.js",
      "require": "./dist-cjs/submodules/cbor/index.js"
    },
    "./protocols": {
      "types": "./dist-types/submodules/protocols/index.d.ts",
      "module": "./dist-es/submodules/protocols/index.js",
      "node": "./dist-cjs/submodules/protocols/index.js",
      "import": "./dist-es/submodules/protocols/index.js",
      "require": "./dist-cjs/submodules/protocols/index.js"
    },
    "./serde": {
      "types": "./dist-types/submodules/serde/index.d.ts",
      "module": "./dist-es/submodules/serde/index.js",
      "node": "./dist-cjs/submodules/serde/index.js",
      "import": "./dist-es/submodules/serde/index.js",
      "require": "./dist-cjs/submodules/serde/index.js"
    },
    "./schema": {
      "types": "./dist-types/submodules/schema/index.d.ts",
      "module": "./dist-es/submodules/schema/index.js",
      "node": "./dist-cjs/submodules/schema/index.js",
      "import": "./dist-es/submodules/schema/index.js",
      "require": "./dist-cjs/submodules/schema/index.js"
    },
    "./event-streams": {
      "types": "./dist-types/submodules/event-streams/index.d.ts",
      "module": "./dist-es/submodules/event-streams/index.js",
      "node": "./dist-cjs/submodules/event-streams/index.js",
      "import": "./dist-es/submodules/event-streams/index.js",
      "require": "./dist-cjs/submodules/event-streams/index.js"
    }
  },
  "author": {
    "name": "AWS Smithy Team",
    "email": "",
    "url": "https://smithy.io"
  },
  "license": "Apache-2.0",
  "sideEffects": false,
  "dependencies": {
    "@smithy/middleware-serde": "^4.2.3",
    "@smithy/protocol-http": "^5.3.3",
    "@smithy/types": "^4.8.0",
    "@smithy/util-base64": "^4.3.0",
    "@smithy/util-body-length-browser": "^4.2.0",
    "@smithy/util-middleware": "^4.2.3",
    "@smithy/util-stream": "^4.5.3",
    "@smithy/util-utf8": "^4.2.0",
    "@smithy/uuid": "^1.1.0",
    "tslib": "^2.6.2"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "./cbor.d.ts",
    "./cbor.js",
    "./event-streams.d.ts",
    "./event-streams.js",
    "./protocols.d.ts",
    "./protocols.js",
    "./schema.d.ts",
    "./schema.js",
    "./serde.d.ts",
    "./serde.js",
    "dist-*/**"
  ],
  "homepage": "https://github.com/smithy-lang/smithy-typescript/tree/main/packages/core",
  "repository": {
    "type": "git",
    "url": "https://github.com/smithy-lang/smithy-typescript.git",
    "directory": "packages/core"
  },
  "devDependencies": {
    "@smithy/eventstream-serde-node": "^4.2.3",
    "@types/node": "^18.11.9",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "json-bigint": "^1.0.0",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  }
}
```

## ./lib/lambda/node_modules/@smithy/core/protocols.d.ts

```typescript
/**
 * Do not edit:
 * This is a compatibility redirect for contexts that do not understand package.json exports field.
 */
declare module "@smithy/core/protocols" {
  export * from "@smithy/core/dist-types/submodules/protocols/index.d";
}

```

## ./lib/lambda/node_modules/@smithy/core/schema.d.ts

```typescript
/**
 * Do not edit:
 * This is a compatibility redirect for contexts that do not understand package.json exports field.
 */
declare module "@smithy/core/schema" {
  export * from "@smithy/core/dist-types/submodules/schema/index.d";
}

```

## ./lib/lambda/node_modules/@smithy/core/serde.d.ts

```typescript
/**
 * Do not edit:
 * This is a compatibility redirect for contexts that do not understand package.json exports field.
 */
declare module "@smithy/core/serde" {
  export * from "@smithy/core/dist-types/submodules/serde/index.d";
}

```

## ./lib/lambda/node_modules/@smithy/credential-provider-imds/dist-types/config/Endpoint.d.ts

```typescript
/**
 * @internal
 */
export declare enum Endpoint {
    IPv4 = "http://169.254.169.254",
    IPv6 = "http://[fd00:ec2::254]"
}

```

## ./lib/lambda/node_modules/@smithy/credential-provider-imds/dist-types/config/EndpointConfigOptions.d.ts

```typescript
import type { LoadedConfigSelectors } from "@smithy/node-config-provider";
/**
 * @internal
 */
export declare const ENV_ENDPOINT_NAME = "AWS_EC2_METADATA_SERVICE_ENDPOINT";
/**
 * @internal
 */
export declare const CONFIG_ENDPOINT_NAME = "ec2_metadata_service_endpoint";
/**
 * @internal
 */
export declare const ENDPOINT_CONFIG_OPTIONS: LoadedConfigSelectors<string | undefined>;

```

## ./lib/lambda/node_modules/@smithy/credential-provider-imds/dist-types/config/EndpointMode.d.ts

```typescript
/**
 * @internal
 */
export declare enum EndpointMode {
    IPv4 = "IPv4",
    IPv6 = "IPv6"
}

```

## ./lib/lambda/node_modules/@smithy/credential-provider-imds/dist-types/config/EndpointModeConfigOptions.d.ts

```typescript
import type { LoadedConfigSelectors } from "@smithy/node-config-provider";
/**
 * @internal
 */
export declare const ENV_ENDPOINT_MODE_NAME = "AWS_EC2_METADATA_SERVICE_ENDPOINT_MODE";
/**
 * @internal
 */
export declare const CONFIG_ENDPOINT_MODE_NAME = "ec2_metadata_service_endpoint_mode";
/**
 * @internal
 */
export declare const ENDPOINT_MODE_CONFIG_OPTIONS: LoadedConfigSelectors<string | undefined>;

```

## ./lib/lambda/node_modules/@smithy/credential-provider-imds/dist-types/error/InstanceMetadataV1FallbackError.d.ts

```typescript
import { CredentialsProviderError } from "@smithy/property-provider";
/**
 * @public
 *
 * A specific sub-case of CredentialsProviderError, when the IMDSv1 fallback
 * has been attempted but shut off by SDK configuration.
 */
export declare class InstanceMetadataV1FallbackError extends CredentialsProviderError {
    readonly tryNextLink: boolean;
    name: string;
    constructor(message: string, tryNextLink?: boolean);
}

```

## ./lib/lambda/node_modules/@smithy/credential-provider-imds/dist-types/fromContainerMetadata.d.ts

```typescript
import type { AwsCredentialIdentityProvider } from "@smithy/types";
import type { RemoteProviderInit } from "./remoteProvider/RemoteProviderInit";
/**
 * @internal
 */
export declare const ENV_CMDS_FULL_URI = "AWS_CONTAINER_CREDENTIALS_FULL_URI";
/**
 * @internal
 */
export declare const ENV_CMDS_RELATIVE_URI = "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI";
/**
 * @internal
 */
export declare const ENV_CMDS_AUTH_TOKEN = "AWS_CONTAINER_AUTHORIZATION_TOKEN";
/**
 * @internal
 *
 * Creates a credential provider that will source credentials from the ECS
 * Container Metadata Service
 */
export declare const fromContainerMetadata: (init?: RemoteProviderInit) => AwsCredentialIdentityProvider;

```

## ./lib/lambda/node_modules/@smithy/credential-provider-imds/dist-types/fromInstanceMetadata.d.ts

```typescript
import type { Provider } from "@smithy/types";
import type { RemoteProviderInit } from "./remoteProvider/RemoteProviderInit";
import type { InstanceMetadataCredentials } from "./types";
/**
 * @internal
 *
 * Creates a credential provider that will source credentials from the EC2
 * Instance Metadata Service
 */
export declare const fromInstanceMetadata: (init?: RemoteProviderInit) => Provider<InstanceMetadataCredentials>;

```

## ./lib/lambda/node_modules/@smithy/credential-provider-imds/dist-types/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./fromContainerMetadata";
/**
 * @internal
 */
export * from "./fromInstanceMetadata";
/**
 * @internal
 */
export * from "./remoteProvider/RemoteProviderInit";
/**
 * @internal
 */
export * from "./types";
/**
 * @internal
 */
export { httpRequest } from "./remoteProvider/httpRequest";
/**
 * @internal
 */
export { getInstanceMetadataEndpoint } from "./utils/getInstanceMetadataEndpoint";
/**
 * @internal
 */
export { Endpoint } from "./config/Endpoint";

```

## ./lib/lambda/node_modules/@smithy/credential-provider-imds/dist-types/remoteProvider/ImdsCredentials.d.ts

```typescript
import type { AwsCredentialIdentity } from "@smithy/types";
/**
 * @internal
 */
export interface ImdsCredentials {
    AccessKeyId: string;
    SecretAccessKey: string;
    Token: string;
    Expiration: string;
    AccountId?: string;
}
/**
 * @internal
 */
export declare const isImdsCredentials: (arg: any) => arg is ImdsCredentials;
/**
 * @internal
 */
export declare const fromImdsCredentials: (creds: ImdsCredentials) => AwsCredentialIdentity;

```

## ./lib/lambda/node_modules/@smithy/credential-provider-imds/dist-types/remoteProvider/RemoteProviderInit.d.ts

```typescript
import type { Logger } from "@smithy/types";
/**
 * @internal
 */
export declare const DEFAULT_TIMEOUT = 1000;
/**
 * @internal
 */
export declare const DEFAULT_MAX_RETRIES = 0;
/**
 * @public
 */
export interface RemoteProviderConfig {
    /**
     * The connection timeout (in milliseconds)
     */
    timeout: number;
    /**
     * The maximum number of times the HTTP connection should be retried
     */
    maxRetries: number;
}
/**
 * @public
 */
export interface RemoteProviderInit extends Partial<RemoteProviderConfig> {
    logger?: Logger;
    /**
     * Only used in the IMDS credential provider.
     */
    ec2MetadataV1Disabled?: boolean;
    /**
     * AWS_PROFILE.
     */
    profile?: string;
}
/**
 * @internal
 */
export declare const providerConfigFromInit: ({ maxRetries, timeout, }: RemoteProviderInit) => RemoteProviderConfig;

```

## ./lib/lambda/node_modules/@smithy/credential-provider-imds/dist-types/remoteProvider/httpRequest.d.ts

```typescript
import { Buffer } from "buffer";
import type { RequestOptions } from "http";
/**
 * @internal
 */
export declare function httpRequest(options: RequestOptions): Promise<Buffer>;

```

## ./lib/lambda/node_modules/@smithy/credential-provider-imds/dist-types/remoteProvider/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./ImdsCredentials";
/**
 * @internal
 */
export * from "./RemoteProviderInit";

```

## ./lib/lambda/node_modules/@smithy/credential-provider-imds/dist-types/remoteProvider/retry.d.ts

```typescript
/**
 * @internal
 */
export interface RetryableProvider<T> {
    (): Promise<T>;
}
/**
 * @internal
 */
export declare const retry: <T>(toRetry: RetryableProvider<T>, maxRetries: number) => Promise<T>;

```

## ./lib/lambda/node_modules/@smithy/credential-provider-imds/dist-types/ts3.4/config/Endpoint.d.ts

```typescript
/**
 * @internal
 */
export declare enum Endpoint {
    IPv4 = "http://169.254.169.254",
    IPv6 = "http://[fd00:ec2::254]"
}

```

## ./lib/lambda/node_modules/@smithy/credential-provider-imds/dist-types/ts3.4/config/EndpointConfigOptions.d.ts

```typescript
import { LoadedConfigSelectors } from "@smithy/node-config-provider";
/**
 * @internal
 */
export declare const ENV_ENDPOINT_NAME = "AWS_EC2_METADATA_SERVICE_ENDPOINT";
/**
 * @internal
 */
export declare const CONFIG_ENDPOINT_NAME = "ec2_metadata_service_endpoint";
/**
 * @internal
 */
export declare const ENDPOINT_CONFIG_OPTIONS: LoadedConfigSelectors<string | undefined>;

```

## ./lib/lambda/node_modules/@smithy/credential-provider-imds/dist-types/ts3.4/config/EndpointMode.d.ts

```typescript
/**
 * @internal
 */
export declare enum EndpointMode {
    IPv4 = "IPv4",
    IPv6 = "IPv6"
}

```

## ./lib/lambda/node_modules/@smithy/credential-provider-imds/dist-types/ts3.4/config/EndpointModeConfigOptions.d.ts

```typescript
import { LoadedConfigSelectors } from "@smithy/node-config-provider";
/**
 * @internal
 */
export declare const ENV_ENDPOINT_MODE_NAME = "AWS_EC2_METADATA_SERVICE_ENDPOINT_MODE";
/**
 * @internal
 */
export declare const CONFIG_ENDPOINT_MODE_NAME = "ec2_metadata_service_endpoint_mode";
/**
 * @internal
 */
export declare const ENDPOINT_MODE_CONFIG_OPTIONS: LoadedConfigSelectors<string | undefined>;

```

## ./lib/lambda/node_modules/@smithy/credential-provider-imds/dist-types/ts3.4/error/InstanceMetadataV1FallbackError.d.ts

```typescript
import { CredentialsProviderError } from "@smithy/property-provider";
/**
 * @public
 *
 * A specific sub-case of CredentialsProviderError, when the IMDSv1 fallback
 * has been attempted but shut off by SDK configuration.
 */
export declare class InstanceMetadataV1FallbackError extends CredentialsProviderError {
    readonly tryNextLink: boolean;
    name: string;
    constructor(message: string, tryNextLink?: boolean);
}

```

## ./lib/lambda/node_modules/@smithy/credential-provider-imds/dist-types/ts3.4/fromContainerMetadata.d.ts

```typescript
import { AwsCredentialIdentityProvider } from "@smithy/types";
import { RemoteProviderInit } from "./remoteProvider/RemoteProviderInit";
/**
 * @internal
 */
export declare const ENV_CMDS_FULL_URI = "AWS_CONTAINER_CREDENTIALS_FULL_URI";
/**
 * @internal
 */
export declare const ENV_CMDS_RELATIVE_URI = "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI";
/**
 * @internal
 */
export declare const ENV_CMDS_AUTH_TOKEN = "AWS_CONTAINER_AUTHORIZATION_TOKEN";
/**
 * @internal
 *
 * Creates a credential provider that will source credentials from the ECS
 * Container Metadata Service
 */
export declare const fromContainerMetadata: (init?: RemoteProviderInit) => AwsCredentialIdentityProvider;

```

## ./lib/lambda/node_modules/@smithy/credential-provider-imds/dist-types/ts3.4/fromInstanceMetadata.d.ts

```typescript
import { Provider } from "@smithy/types";
import { RemoteProviderInit } from "./remoteProvider/RemoteProviderInit";
import { InstanceMetadataCredentials } from "./types";
/**
 * @internal
 *
 * Creates a credential provider that will source credentials from the EC2
 * Instance Metadata Service
 */
export declare const fromInstanceMetadata: (init?: RemoteProviderInit) => Provider<InstanceMetadataCredentials>;

```

## ./lib/lambda/node_modules/@smithy/credential-provider-imds/dist-types/ts3.4/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./fromContainerMetadata";
/**
 * @internal
 */
export * from "./fromInstanceMetadata";
/**
 * @internal
 */
export * from "./remoteProvider/RemoteProviderInit";
/**
 * @internal
 */
export * from "./types";
/**
 * @internal
 */
export { httpRequest } from "./remoteProvider/httpRequest";
/**
 * @internal
 */
export { getInstanceMetadataEndpoint } from "./utils/getInstanceMetadataEndpoint";
/**
 * @internal
 */
export { Endpoint } from "./config/Endpoint";

```

## ./lib/lambda/node_modules/@smithy/credential-provider-imds/dist-types/ts3.4/remoteProvider/ImdsCredentials.d.ts

```typescript
import { AwsCredentialIdentity } from "@smithy/types";
/**
 * @internal
 */
export interface ImdsCredentials {
    AccessKeyId: string;
    SecretAccessKey: string;
    Token: string;
    Expiration: string;
    AccountId?: string;
}
/**
 * @internal
 */
export declare const isImdsCredentials: (arg: any) => arg is ImdsCredentials;
/**
 * @internal
 */
export declare const fromImdsCredentials: (creds: ImdsCredentials) => AwsCredentialIdentity;

```

## ./lib/lambda/node_modules/@smithy/credential-provider-imds/dist-types/ts3.4/remoteProvider/RemoteProviderInit.d.ts

```typescript
import { Logger } from "@smithy/types";
/**
 * @internal
 */
export declare const DEFAULT_TIMEOUT = 1000;
/**
 * @internal
 */
export declare const DEFAULT_MAX_RETRIES = 0;
/**
 * @public
 */
export interface RemoteProviderConfig {
    /**
     * The connection timeout (in milliseconds)
     */
    timeout: number;
    /**
     * The maximum number of times the HTTP connection should be retried
     */
    maxRetries: number;
}
/**
 * @public
 */
export interface RemoteProviderInit extends Partial<RemoteProviderConfig> {
    logger?: Logger;
    /**
     * Only used in the IMDS credential provider.
     */
    ec2MetadataV1Disabled?: boolean;
    /**
     * AWS_PROFILE.
     */
    profile?: string;
}
/**
 * @internal
 */
export declare const providerConfigFromInit: ({ maxRetries, timeout, }: RemoteProviderInit) => RemoteProviderConfig;

```

## ./lib/lambda/node_modules/@smithy/credential-provider-imds/dist-types/ts3.4/remoteProvider/httpRequest.d.ts

```typescript
import { Buffer } from "buffer";
import { RequestOptions } from "http";
/**
 * @internal
 */
export declare function httpRequest(options: RequestOptions): Promise<Buffer>;

```

## ./lib/lambda/node_modules/@smithy/credential-provider-imds/dist-types/ts3.4/remoteProvider/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./ImdsCredentials";
/**
 * @internal
 */
export * from "./RemoteProviderInit";

```

## ./lib/lambda/node_modules/@smithy/credential-provider-imds/dist-types/ts3.4/remoteProvider/retry.d.ts

```typescript
/**
 * @internal
 */
export interface RetryableProvider<T> {
    (): Promise<T>;
}
/**
 * @internal
 */
export declare const retry: <T>(toRetry: RetryableProvider<T>, maxRetries: number) => Promise<T>;

```

## ./lib/lambda/node_modules/@smithy/credential-provider-imds/dist-types/ts3.4/types.d.ts

```typescript
import { AwsCredentialIdentity } from "@smithy/types";
/**
 * @internal
 */
export interface InstanceMetadataCredentials extends AwsCredentialIdentity {
    readonly originalExpiration?: Date;
}

```

## ./lib/lambda/node_modules/@smithy/credential-provider-imds/dist-types/ts3.4/utils/getExtendedInstanceMetadataCredentials.d.ts

```typescript
import { Logger } from "@smithy/types";
import { InstanceMetadataCredentials } from "../types";
/**
 * @internal
 */
export declare const getExtendedInstanceMetadataCredentials: (credentials: InstanceMetadataCredentials, logger: Logger) => InstanceMetadataCredentials;

```

## ./lib/lambda/node_modules/@smithy/credential-provider-imds/dist-types/ts3.4/utils/getInstanceMetadataEndpoint.d.ts

```typescript
import { Endpoint } from "@smithy/types";
/**
 * Returns the host to use for instance metadata service call.
 *
 * The host is read from endpoint which can be set either in
 * {@link ENV_ENDPOINT_NAME} environment variable or {@link CONFIG_ENDPOINT_NAME}
 * configuration property.
 *
 * If endpoint is not set, then endpoint mode is read either from
 * {@link ENV_ENDPOINT_MODE_NAME} environment variable or {@link CONFIG_ENDPOINT_MODE_NAME}
 * configuration property. If endpoint mode is not set, then default endpoint mode
 * {@link EndpointMode.IPv4} is used.
 *
 * If endpoint mode is set to {@link EndpointMode.IPv4}, then the host is {@link Endpoint.IPv4}.
 * If endpoint mode is set to {@link EndpointMode.IPv6}, then the host is {@link Endpoint.IPv6}.
 *
 * @returns Host to use for instance metadata service call.
 *
 * @internal
 */
export declare const getInstanceMetadataEndpoint: () => Promise<Endpoint>;

```

## ./lib/lambda/node_modules/@smithy/credential-provider-imds/dist-types/ts3.4/utils/staticStabilityProvider.d.ts

```typescript
import { Logger, Provider } from "@smithy/types";
import { InstanceMetadataCredentials } from "../types";
/**
 * @internal
 *
 * IMDS credential supports static stability feature. When used, the expiration
 * of recently issued credentials is extended. The server side allows using
 * the recently expired credentials. This mitigates impact when clients using
 * refreshable credentials are unable to retrieve updates.
 *
 * @param provider Credential provider
 * @returns A credential provider that supports static stability
 */
export declare const staticStabilityProvider: (provider: Provider<InstanceMetadataCredentials>, options?: {
    logger?: Logger;
}) => Provider<InstanceMetadataCredentials>;

```

## ./lib/lambda/node_modules/@smithy/credential-provider-imds/dist-types/types.d.ts

```typescript
import type { AwsCredentialIdentity } from "@smithy/types";
/**
 * @internal
 */
export interface InstanceMetadataCredentials extends AwsCredentialIdentity {
    readonly originalExpiration?: Date;
}

```

## ./lib/lambda/node_modules/@smithy/credential-provider-imds/dist-types/utils/getExtendedInstanceMetadataCredentials.d.ts

```typescript
import type { Logger } from "@smithy/types";
import type { InstanceMetadataCredentials } from "../types";
/**
 * @internal
 */
export declare const getExtendedInstanceMetadataCredentials: (credentials: InstanceMetadataCredentials, logger: Logger) => InstanceMetadataCredentials;

```

## ./lib/lambda/node_modules/@smithy/credential-provider-imds/dist-types/utils/getInstanceMetadataEndpoint.d.ts

```typescript
import type { Endpoint } from "@smithy/types";
/**
 * Returns the host to use for instance metadata service call.
 *
 * The host is read from endpoint which can be set either in
 * {@link ENV_ENDPOINT_NAME} environment variable or {@link CONFIG_ENDPOINT_NAME}
 * configuration property.
 *
 * If endpoint is not set, then endpoint mode is read either from
 * {@link ENV_ENDPOINT_MODE_NAME} environment variable or {@link CONFIG_ENDPOINT_MODE_NAME}
 * configuration property. If endpoint mode is not set, then default endpoint mode
 * {@link EndpointMode.IPv4} is used.
 *
 * If endpoint mode is set to {@link EndpointMode.IPv4}, then the host is {@link Endpoint.IPv4}.
 * If endpoint mode is set to {@link EndpointMode.IPv6}, then the host is {@link Endpoint.IPv6}.
 *
 * @returns Host to use for instance metadata service call.
 *
 * @internal
 */
export declare const getInstanceMetadataEndpoint: () => Promise<Endpoint>;

```

## ./lib/lambda/node_modules/@smithy/credential-provider-imds/dist-types/utils/staticStabilityProvider.d.ts

```typescript
import type { Logger, Provider } from "@smithy/types";
import type { InstanceMetadataCredentials } from "../types";
/**
 * @internal
 *
 * IMDS credential supports static stability feature. When used, the expiration
 * of recently issued credentials is extended. The server side allows using
 * the recently expired credentials. This mitigates impact when clients using
 * refreshable credentials are unable to retrieve updates.
 *
 * @param provider Credential provider
 * @returns A credential provider that supports static stability
 */
export declare const staticStabilityProvider: (provider: Provider<InstanceMetadataCredentials>, options?: {
    logger?: Logger;
}) => Provider<InstanceMetadataCredentials>;

```

## ./lib/lambda/node_modules/@smithy/credential-provider-imds/package.json

```json
{
  "name": "@smithy/credential-provider-imds",
  "version": "4.2.3",
  "description": "AWS credential provider that sources credentials from the EC2 instance metadata service and ECS container metadata service",
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline credential-provider-imds",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "rimraf dist-types/ts3.4 && downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../../.prettierignore --write \"**/*.{ts,md,json}\"",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch"
  },
  "keywords": [
    "aws",
    "credentials"
  ],
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "sideEffects": false,
  "dependencies": {
    "@smithy/node-config-provider": "^4.3.3",
    "@smithy/property-provider": "^4.2.3",
    "@smithy/types": "^4.8.0",
    "@smithy/url-parser": "^4.2.3",
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "@types/node": "^18.11.9",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "types": "./dist-types/index.d.ts",
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/smithy-lang/smithy-typescript/tree/main/packages/credential-provider-imds",
  "repository": {
    "type": "git",
    "url": "https://github.com/smithy-lang/smithy-typescript.git",
    "directory": "packages/credential-provider-imds"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  }
}
```

## ./lib/lambda/node_modules/@smithy/eventstream-codec/dist-types/EventStreamCodec.d.ts

```typescript
import type { AvailableMessage, AvailableMessages, Message, MessageDecoder, MessageEncoder, MessageHeaders } from "@smithy/types";
import type { Decoder, Encoder } from "@smithy/types";
/**
 * A Codec that can convert binary-packed event stream messages into
 * JavaScript objects and back again into their binary format.
 */
export declare class EventStreamCodec implements MessageEncoder, MessageDecoder {
    private readonly headerMarshaller;
    private messageBuffer;
    private isEndOfStream;
    constructor(toUtf8: Encoder, fromUtf8: Decoder);
    feed(message: ArrayBufferView): void;
    endOfStream(): void;
    getMessage(): AvailableMessage;
    getAvailableMessages(): AvailableMessages;
    /**
     * Convert a structured JavaScript object with tagged headers into a binary
     * event stream message.
     */
    encode({ headers: rawHeaders, body }: Message): Uint8Array;
    /**
     * Convert a binary event stream message into a JavaScript object with an
     * opaque, binary body and tagged, parsed headers.
     */
    decode(message: ArrayBufferView): Message;
    /**
     * Convert a structured JavaScript object with tagged headers into a binary
     * event stream message header.
     */
    formatHeaders(rawHeaders: MessageHeaders): Uint8Array;
}

```

## ./lib/lambda/node_modules/@smithy/eventstream-codec/dist-types/HeaderMarshaller.d.ts

```typescript
import type { Decoder, Encoder, MessageHeaders } from "@smithy/types";
/**
 * @internal
 */
export declare class HeaderMarshaller {
    private readonly toUtf8;
    private readonly fromUtf8;
    constructor(toUtf8: Encoder, fromUtf8: Decoder);
    format(headers: MessageHeaders): Uint8Array;
    private formatHeaderValue;
    parse(headers: DataView): MessageHeaders;
}

```

## ./lib/lambda/node_modules/@smithy/eventstream-codec/dist-types/Int64.d.ts

```typescript
import type { Int64 as IInt64 } from "@smithy/types";
export interface Int64 extends IInt64 {
}
/**
 * A lossless representation of a signed, 64-bit integer. Instances of this
 * class may be used in arithmetic expressions as if they were numeric
 * primitives, but the binary representation will be preserved unchanged as the
 * `bytes` property of the object. The bytes should be encoded as big-endian,
 * two's complement integers.
 */
export declare class Int64 {
    readonly bytes: Uint8Array;
    constructor(bytes: Uint8Array);
    static fromNumber(number: number): Int64;
    /**
     * Called implicitly by infix arithmetic operators.
     */
    valueOf(): number;
    toString(): string;
}

```

## ./lib/lambda/node_modules/@smithy/eventstream-codec/dist-types/Message.d.ts

```typescript
import type { Int64 } from "./Int64";
/**
 * An event stream message. The headers and body properties will always be
 * defined, with empty headers represented as an object with no keys and an
 * empty body represented as a zero-length Uint8Array.
 */
export interface Message {
    headers: MessageHeaders;
    body: Uint8Array;
}
export type MessageHeaders = Record<string, MessageHeaderValue>;
type HeaderValue<K extends string, V> = {
    type: K;
    value: V;
};
export type BooleanHeaderValue = HeaderValue<"boolean", boolean>;
export type ByteHeaderValue = HeaderValue<"byte", number>;
export type ShortHeaderValue = HeaderValue<"short", number>;
export type IntegerHeaderValue = HeaderValue<"integer", number>;
export type LongHeaderValue = HeaderValue<"long", Int64>;
export type BinaryHeaderValue = HeaderValue<"binary", Uint8Array>;
export type StringHeaderValue = HeaderValue<"string", string>;
export type TimestampHeaderValue = HeaderValue<"timestamp", Date>;
export type UuidHeaderValue = HeaderValue<"uuid", string>;
export type MessageHeaderValue = BooleanHeaderValue | ByteHeaderValue | ShortHeaderValue | IntegerHeaderValue | LongHeaderValue | BinaryHeaderValue | StringHeaderValue | TimestampHeaderValue | UuidHeaderValue;
export {};

```

## ./lib/lambda/node_modules/@smithy/eventstream-codec/dist-types/MessageDecoderStream.d.ts

```typescript
import type { Message, MessageDecoder } from "@smithy/types";
/**
 * @internal
 */
export interface MessageDecoderStreamOptions {
    inputStream: AsyncIterable<Uint8Array>;
    decoder: MessageDecoder;
}
/**
 * @internal
 */
export declare class MessageDecoderStream implements AsyncIterable<Message> {
    private readonly options;
    constructor(options: MessageDecoderStreamOptions);
    [Symbol.asyncIterator](): AsyncIterator<Message>;
    private asyncIterator;
}

```

## ./lib/lambda/node_modules/@smithy/eventstream-codec/dist-types/MessageEncoderStream.d.ts

```typescript
import type { Message, MessageEncoder } from "@smithy/types";
/**
 * @internal
 */
export interface MessageEncoderStreamOptions {
    messageStream: AsyncIterable<Message>;
    encoder: MessageEncoder;
    includeEndFrame?: boolean;
}
/**
 * @internal
 */
export declare class MessageEncoderStream implements AsyncIterable<Uint8Array> {
    private readonly options;
    constructor(options: MessageEncoderStreamOptions);
    [Symbol.asyncIterator](): AsyncIterator<Uint8Array>;
    private asyncIterator;
}

```

## ./lib/lambda/node_modules/@smithy/eventstream-codec/dist-types/SmithyMessageDecoderStream.d.ts

```typescript
import type { Message } from "@smithy/types";
/**
 * @internal
 */
export interface SmithyMessageDecoderStreamOptions<T> {
    readonly messageStream: AsyncIterable<Message>;
    readonly deserializer: (input: Message) => Promise<T | undefined>;
}
/**
 * @internal
 */
export declare class SmithyMessageDecoderStream<T> implements AsyncIterable<T> {
    private readonly options;
    constructor(options: SmithyMessageDecoderStreamOptions<T>);
    [Symbol.asyncIterator](): AsyncIterator<T>;
    private asyncIterator;
}

```

## ./lib/lambda/node_modules/@smithy/eventstream-codec/dist-types/SmithyMessageEncoderStream.d.ts

```typescript
import type { Message } from "@smithy/types";
/**
 * @internal
 */
export interface SmithyMessageEncoderStreamOptions<T> {
    inputStream: AsyncIterable<T>;
    serializer: (event: T) => Message;
}
/**
 * @internal
 */
export declare class SmithyMessageEncoderStream<T> implements AsyncIterable<Message> {
    private readonly options;
    constructor(options: SmithyMessageEncoderStreamOptions<T>);
    [Symbol.asyncIterator](): AsyncIterator<Message>;
    private asyncIterator;
}

```

## ./lib/lambda/node_modules/@smithy/eventstream-codec/dist-types/TestVectors.fixture.d.ts

```typescript
import type { TestVectors } from "./vectorTypes.fixture";
export declare const vectors: TestVectors;

```

## ./lib/lambda/node_modules/@smithy/eventstream-codec/dist-types/index.d.ts

```typescript
export * from "./EventStreamCodec";
export * from "./HeaderMarshaller";
export * from "./Int64";
export * from "./Message";
export * from "./MessageDecoderStream";
export * from "./MessageEncoderStream";
export * from "./SmithyMessageDecoderStream";
export * from "./SmithyMessageEncoderStream";

```

## ./lib/lambda/node_modules/@smithy/eventstream-codec/dist-types/splitMessage.d.ts

```typescript
/**
 * @internal
 */
export interface MessageParts {
    headers: DataView;
    body: Uint8Array;
}
/**
 * @internal
 */
export declare function splitMessage({ byteLength, byteOffset, buffer }: ArrayBufferView): MessageParts;

```

## ./lib/lambda/node_modules/@smithy/eventstream-codec/dist-types/ts3.4/EventStreamCodec.d.ts

```typescript
import { AvailableMessage, AvailableMessages, Message, MessageDecoder, MessageEncoder, MessageHeaders } from "@smithy/types";
import { Decoder, Encoder } from "@smithy/types";
/**
 * A Codec that can convert binary-packed event stream messages into
 * JavaScript objects and back again into their binary format.
 */
export declare class EventStreamCodec implements MessageEncoder, MessageDecoder {
    private readonly headerMarshaller;
    private messageBuffer;
    private isEndOfStream;
    constructor(toUtf8: Encoder, fromUtf8: Decoder);
    feed(message: ArrayBufferView): void;
    endOfStream(): void;
    getMessage(): AvailableMessage;
    getAvailableMessages(): AvailableMessages;
    /**
     * Convert a structured JavaScript object with tagged headers into a binary
     * event stream message.
     */
    encode({ headers: rawHeaders, body }: Message): Uint8Array;
    /**
     * Convert a binary event stream message into a JavaScript object with an
     * opaque, binary body and tagged, parsed headers.
     */
    decode(message: ArrayBufferView): Message;
    /**
     * Convert a structured JavaScript object with tagged headers into a binary
     * event stream message header.
     */
    formatHeaders(rawHeaders: MessageHeaders): Uint8Array;
}

```

## ./lib/lambda/node_modules/@smithy/eventstream-codec/dist-types/ts3.4/HeaderMarshaller.d.ts

```typescript
import { Decoder, Encoder, MessageHeaders } from "@smithy/types";
/**
 * @internal
 */
export declare class HeaderMarshaller {
    private readonly toUtf8;
    private readonly fromUtf8;
    constructor(toUtf8: Encoder, fromUtf8: Decoder);
    format(headers: MessageHeaders): Uint8Array;
    private formatHeaderValue;
    parse(headers: DataView): MessageHeaders;
}

```

## ./lib/lambda/node_modules/@smithy/eventstream-codec/dist-types/ts3.4/Int64.d.ts

```typescript
import { Int64 as IInt64 } from "@smithy/types";
export interface Int64 extends IInt64 {
}
/**
 * A lossless representation of a signed, 64-bit integer. Instances of this
 * class may be used in arithmetic expressions as if they were numeric
 * primitives, but the binary representation will be preserved unchanged as the
 * `bytes` property of the object. The bytes should be encoded as big-endian,
 * two's complement integers.
 */
export declare class Int64 {
    readonly bytes: Uint8Array;
    constructor(bytes: Uint8Array);
    static fromNumber(number: number): Int64;
    /**
     * Called implicitly by infix arithmetic operators.
     */
    valueOf(): number;
    toString(): string;
}

```

## ./lib/lambda/node_modules/@smithy/eventstream-codec/dist-types/ts3.4/Message.d.ts

```typescript
import { Int64 } from "./Int64";
/**
 * An event stream message. The headers and body properties will always be
 * defined, with empty headers represented as an object with no keys and an
 * empty body represented as a zero-length Uint8Array.
 */
export interface Message {
    headers: MessageHeaders;
    body: Uint8Array;
}
export type MessageHeaders = Record<string, MessageHeaderValue>;
type HeaderValue<K extends string, V> = {
    type: K;
    value: V;
};
export type BooleanHeaderValue = HeaderValue<"boolean", boolean>;
export type ByteHeaderValue = HeaderValue<"byte", number>;
export type ShortHeaderValue = HeaderValue<"short", number>;
export type IntegerHeaderValue = HeaderValue<"integer", number>;
export type LongHeaderValue = HeaderValue<"long", Int64>;
export type BinaryHeaderValue = HeaderValue<"binary", Uint8Array>;
export type StringHeaderValue = HeaderValue<"string", string>;
export type TimestampHeaderValue = HeaderValue<"timestamp", Date>;
export type UuidHeaderValue = HeaderValue<"uuid", string>;
export type MessageHeaderValue = BooleanHeaderValue | ByteHeaderValue | ShortHeaderValue | IntegerHeaderValue | LongHeaderValue | BinaryHeaderValue | StringHeaderValue | TimestampHeaderValue | UuidHeaderValue;
export {};

```

## ./lib/lambda/node_modules/@smithy/eventstream-codec/dist-types/ts3.4/MessageDecoderStream.d.ts

```typescript
import { Message, MessageDecoder } from "@smithy/types";
/**
 * @internal
 */
export interface MessageDecoderStreamOptions {
    inputStream: AsyncIterable<Uint8Array>;
    decoder: MessageDecoder;
}
/**
 * @internal
 */
export declare class MessageDecoderStream implements AsyncIterable<Message> {
    private readonly options;
    constructor(options: MessageDecoderStreamOptions);
    [Symbol.asyncIterator](): AsyncIterator<Message>;
    private asyncIterator;
}

```

## ./lib/lambda/node_modules/@smithy/eventstream-codec/dist-types/ts3.4/MessageEncoderStream.d.ts

```typescript
import { Message, MessageEncoder } from "@smithy/types";
/**
 * @internal
 */
export interface MessageEncoderStreamOptions {
    messageStream: AsyncIterable<Message>;
    encoder: MessageEncoder;
    includeEndFrame?: boolean;
}
/**
 * @internal
 */
export declare class MessageEncoderStream implements AsyncIterable<Uint8Array> {
    private readonly options;
    constructor(options: MessageEncoderStreamOptions);
    [Symbol.asyncIterator](): AsyncIterator<Uint8Array>;
    private asyncIterator;
}

```

## ./lib/lambda/node_modules/@smithy/eventstream-codec/dist-types/ts3.4/SmithyMessageDecoderStream.d.ts

```typescript
import { Message } from "@smithy/types";
/**
 * @internal
 */
export interface SmithyMessageDecoderStreamOptions<T> {
    readonly messageStream: AsyncIterable<Message>;
    readonly deserializer: (input: Message) => Promise<T | undefined>;
}
/**
 * @internal
 */
export declare class SmithyMessageDecoderStream<T> implements AsyncIterable<T> {
    private readonly options;
    constructor(options: SmithyMessageDecoderStreamOptions<T>);
    [Symbol.asyncIterator](): AsyncIterator<T>;
    private asyncIterator;
}

```

## ./lib/lambda/node_modules/@smithy/eventstream-codec/dist-types/ts3.4/SmithyMessageEncoderStream.d.ts

```typescript
import { Message } from "@smithy/types";
/**
 * @internal
 */
export interface SmithyMessageEncoderStreamOptions<T> {
    inputStream: AsyncIterable<T>;
    serializer: (event: T) => Message;
}
/**
 * @internal
 */
export declare class SmithyMessageEncoderStream<T> implements AsyncIterable<Message> {
    private readonly options;
    constructor(options: SmithyMessageEncoderStreamOptions<T>);
    [Symbol.asyncIterator](): AsyncIterator<Message>;
    private asyncIterator;
}

```

## ./lib/lambda/node_modules/@smithy/eventstream-codec/dist-types/ts3.4/TestVectors.fixture.d.ts

```typescript
import { TestVectors } from "./vectorTypes.fixture";
export declare const vectors: TestVectors;

```

## ./lib/lambda/node_modules/@smithy/eventstream-codec/dist-types/ts3.4/index.d.ts

```typescript
export * from "./EventStreamCodec";
export * from "./HeaderMarshaller";
export * from "./Int64";
export * from "./Message";
export * from "./MessageDecoderStream";
export * from "./MessageEncoderStream";
export * from "./SmithyMessageDecoderStream";
export * from "./SmithyMessageEncoderStream";

```

## ./lib/lambda/node_modules/@smithy/eventstream-codec/dist-types/ts3.4/splitMessage.d.ts

```typescript
/**
 * @internal
 */
export interface MessageParts {
    headers: DataView;
    body: Uint8Array;
}
/**
 * @internal
 */
export declare function splitMessage({ byteLength, byteOffset, buffer }: ArrayBufferView): MessageParts;

```

## ./lib/lambda/node_modules/@smithy/eventstream-codec/dist-types/ts3.4/vectorTypes.fixture.d.ts

```typescript
import { Message } from "./Message";
export interface NegativeTestVector {
    expectation: "failure";
    encoded: Uint8Array;
}
export interface PositiveTestVector {
    expectation: "success";
    encoded: Uint8Array;
    decoded: Message;
}
export type TestVector = NegativeTestVector | PositiveTestVector;
export type TestVectors = Record<string, TestVector>;

```

## ./lib/lambda/node_modules/@smithy/eventstream-codec/dist-types/vectorTypes.fixture.d.ts

```typescript
import type { Message } from "./Message";
export interface NegativeTestVector {
    expectation: "failure";
    encoded: Uint8Array;
}
export interface PositiveTestVector {
    expectation: "success";
    encoded: Uint8Array;
    decoded: Message;
}
export type TestVector = NegativeTestVector | PositiveTestVector;
export type TestVectors = Record<string, TestVector>;

```

## ./lib/lambda/node_modules/@smithy/eventstream-codec/package.json

```json
{
  "name": "@smithy/eventstream-codec",
  "version": "4.2.3",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline eventstream-codec",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "rimraf dist-types/ts3.4 && downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../../.prettierignore --write \"**/*.{ts,md,json}\"",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "sideEffects": false,
  "dependencies": {
    "@aws-crypto/crc32": "5.2.0",
    "@smithy/types": "^4.8.0",
    "@smithy/util-hex-encoding": "^4.2.0",
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "@smithy/util-utf8": "^4.2.0",
    "@types/node": "^18.11.9",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/smithy-lang/smithy-typescript/tree/main/packages/eventstream-codec",
  "repository": {
    "type": "git",
    "url": "https://github.com/smithy-lang/smithy-typescript.git",
    "directory": "packages/eventstream-codec"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  },
  "engines": {
    "node": ">=18.0.0"
  }
}
```

## ./lib/lambda/node_modules/@smithy/eventstream-serde-browser/dist-types/EventStreamMarshaller.d.ts

```typescript
import type { Decoder, Encoder, EventStreamMarshaller as IEventStreamMarshaller, Message } from "@smithy/types";
/**
 * @internal
 */
export interface EventStreamMarshaller extends IEventStreamMarshaller {
}
/**
 * @internal
 */
export interface EventStreamMarshallerOptions {
    utf8Encoder: Encoder;
    utf8Decoder: Decoder;
}
/**
 * @internal
 *
 * Utility class used to serialize and deserialize event streams in
 * browsers and ReactNative.
 *
 * In browsers where ReadableStream API is available:
 * * deserialize from ReadableStream to an async iterable of output structure
 * * serialize from async iterable of input structure to ReadableStream
 * In ReactNative where only async iterable API is available:
 * * deserialize from async iterable of binaries to async iterable of output structure
 * * serialize from async iterable of input structure to async iterable of binaries
 *
 * We use ReadableStream API in browsers because of the consistency with other
 * streaming operations, where ReadableStream API is used to denote streaming data.
 * Whereas in ReactNative, ReadableStream API is not available, we use async iterable
 * for streaming data although it has lower throughput.
 */
export declare class EventStreamMarshaller {
    private readonly universalMarshaller;
    constructor({ utf8Encoder, utf8Decoder }: EventStreamMarshallerOptions);
    deserialize<T>(body: ReadableStream<Uint8Array> | AsyncIterable<Uint8Array>, deserializer: (input: Record<string, Message>) => Promise<T>): AsyncIterable<T>;
    /**
     * Generate a stream that serialize events into stream of binary chunks;
     *
     * Caveat is that streaming request payload doesn't work on browser with native
     * xhr or fetch handler currently because they don't support upload streaming.
     * reference:
     * * https://bugs.chromium.org/p/chromium/issues/detail?id=688906
     * * https://bugzilla.mozilla.org/show_bug.cgi?id=1387483
     *
     */
    serialize<T>(input: AsyncIterable<T>, serializer: (event: T) => Message): ReadableStream | AsyncIterable<Uint8Array>;
}

```

## ./lib/lambda/node_modules/@smithy/eventstream-serde-browser/dist-types/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./EventStreamMarshaller";
/**
 * @internal
 */
export * from "./provider";
/**
 * @internal
 */
export * from "./utils";

```

## ./lib/lambda/node_modules/@smithy/eventstream-serde-browser/dist-types/provider.d.ts

```typescript
import type { EventStreamSerdeProvider } from "@smithy/types";
/** browser event stream serde utils provider */
export declare const eventStreamSerdeProvider: EventStreamSerdeProvider;

```

## ./lib/lambda/node_modules/@smithy/eventstream-serde-browser/dist-types/ts3.4/EventStreamMarshaller.d.ts

```typescript
import { Decoder, Encoder, EventStreamMarshaller as IEventStreamMarshaller, Message } from "@smithy/types";
/**
 * @internal
 */
export interface EventStreamMarshaller extends IEventStreamMarshaller {
}
/**
 * @internal
 */
export interface EventStreamMarshallerOptions {
    utf8Encoder: Encoder;
    utf8Decoder: Decoder;
}
/**
 * @internal
 *
 * Utility class used to serialize and deserialize event streams in
 * browsers and ReactNative.
 *
 * In browsers where ReadableStream API is available:
 * * deserialize from ReadableStream to an async iterable of output structure
 * * serialize from async iterable of input structure to ReadableStream
 * In ReactNative where only async iterable API is available:
 * * deserialize from async iterable of binaries to async iterable of output structure
 * * serialize from async iterable of input structure to async iterable of binaries
 *
 * We use ReadableStream API in browsers because of the consistency with other
 * streaming operations, where ReadableStream API is used to denote streaming data.
 * Whereas in ReactNative, ReadableStream API is not available, we use async iterable
 * for streaming data although it has lower throughput.
 */
export declare class EventStreamMarshaller {
    private readonly universalMarshaller;
    constructor({ utf8Encoder, utf8Decoder }: EventStreamMarshallerOptions);
    deserialize<T>(body: ReadableStream<Uint8Array> | AsyncIterable<Uint8Array>, deserializer: (input: Record<string, Message>) => Promise<T>): AsyncIterable<T>;
    /**
     * Generate a stream that serialize events into stream of binary chunks;
     *
     * Caveat is that streaming request payload doesn't work on browser with native
     * xhr or fetch handler currently because they don't support upload streaming.
     * reference:
     * * https://bugs.chromium.org/p/chromium/issues/detail?id=688906
     * * https://bugzilla.mozilla.org/show_bug.cgi?id=1387483
     *
     */
    serialize<T>(input: AsyncIterable<T>, serializer: (event: T) => Message): ReadableStream | AsyncIterable<Uint8Array>;
}

```

## ./lib/lambda/node_modules/@smithy/eventstream-serde-browser/dist-types/ts3.4/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./EventStreamMarshaller";
/**
 * @internal
 */
export * from "./provider";
/**
 * @internal
 */
export * from "./utils";

```

## ./lib/lambda/node_modules/@smithy/eventstream-serde-browser/dist-types/ts3.4/provider.d.ts

```typescript
import { EventStreamSerdeProvider } from "@smithy/types";
/** browser event stream serde utils provider */
export declare const eventStreamSerdeProvider: EventStreamSerdeProvider;

```

## ./lib/lambda/node_modules/@smithy/eventstream-serde-browser/dist-types/ts3.4/utils.d.ts

```typescript
/**
 * @internal
 *
 * A util function converting ReadableStream into an async iterable.
 * Reference: https://jakearchibald.com/2017/async-iterators-and-generators/#making-streams-iterate
 */
export declare const readableStreamtoIterable: <T>(readableStream: ReadableStream<T>) => AsyncIterable<T>;
/**
 * @internal
 *
 * A util function converting async iterable to a ReadableStream.
 */
export declare const iterableToReadableStream: <T>(asyncIterable: AsyncIterable<T>) => ReadableStream<T>;

```

## ./lib/lambda/node_modules/@smithy/eventstream-serde-browser/dist-types/utils.d.ts

```typescript
/**
 * @internal
 *
 * A util function converting ReadableStream into an async iterable.
 * Reference: https://jakearchibald.com/2017/async-iterators-and-generators/#making-streams-iterate
 */
export declare const readableStreamtoIterable: <T>(readableStream: ReadableStream<T>) => AsyncIterable<T>;
/**
 * @internal
 *
 * A util function converting async iterable to a ReadableStream.
 */
export declare const iterableToReadableStream: <T>(asyncIterable: AsyncIterable<T>) => ReadableStream<T>;

```

## ./lib/lambda/node_modules/@smithy/eventstream-serde-browser/package.json

```json
{
  "name": "@smithy/eventstream-serde-browser",
  "version": "4.2.3",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline eventstream-serde-browser",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "rimraf dist-types/ts3.4 && downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../../.prettierignore --write \"**/*.{ts,md,json}\"",
    "test": "exit 0"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "sideEffects": false,
  "dependencies": {
    "@smithy/eventstream-serde-universal": "^4.2.3",
    "@smithy/types": "^4.8.0",
    "tslib": "^2.6.2"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/smithy-lang/smithy-typescript/tree/main/packages/eventstream-serde-browser",
  "repository": {
    "type": "git",
    "url": "https://github.com/smithy-lang/smithy-typescript.git",
    "directory": "packages/eventstream-serde-browser"
  },
  "devDependencies": {
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  }
}
```

## ./lib/lambda/node_modules/@smithy/eventstream-serde-config-resolver/dist-types/EventStreamSerdeConfig.d.ts

```typescript
import type { EventStreamMarshaller, EventStreamSerdeProvider } from "@smithy/types";
/**
 * @public
 */
export interface EventStreamSerdeInputConfig {
}
/**
 * @internal
 */
export interface EventStreamSerdeResolvedConfig {
    eventStreamMarshaller: EventStreamMarshaller;
}
/**
 * @internal
 */
interface PreviouslyResolved {
    /**
     * Provide the event stream marshaller for the given runtime
     * @internal
     */
    eventStreamSerdeProvider: EventStreamSerdeProvider;
}
/**
 * @internal
 */
export declare const resolveEventStreamSerdeConfig: <T>(input: T & PreviouslyResolved & EventStreamSerdeInputConfig) => T & EventStreamSerdeResolvedConfig;
export {};

```

## ./lib/lambda/node_modules/@smithy/eventstream-serde-config-resolver/dist-types/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./EventStreamSerdeConfig";

```

## ./lib/lambda/node_modules/@smithy/eventstream-serde-config-resolver/dist-types/ts3.4/EventStreamSerdeConfig.d.ts

```typescript
import { EventStreamMarshaller, EventStreamSerdeProvider } from "@smithy/types";
/**
 * @public
 */
export interface EventStreamSerdeInputConfig {
}
/**
 * @internal
 */
export interface EventStreamSerdeResolvedConfig {
    eventStreamMarshaller: EventStreamMarshaller;
}
/**
 * @internal
 */
interface PreviouslyResolved {
    /**
     * Provide the event stream marshaller for the given runtime
     * @internal
     */
    eventStreamSerdeProvider: EventStreamSerdeProvider;
}
/**
 * @internal
 */
export declare const resolveEventStreamSerdeConfig: <T>(input: T & PreviouslyResolved & EventStreamSerdeInputConfig) => T & EventStreamSerdeResolvedConfig;
export {};

```

## ./lib/lambda/node_modules/@smithy/eventstream-serde-config-resolver/dist-types/ts3.4/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./EventStreamSerdeConfig";

```

## ./lib/lambda/node_modules/@smithy/eventstream-serde-config-resolver/package.json

```json
{
  "name": "@smithy/eventstream-serde-config-resolver",
  "version": "4.3.3",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline eventstream-serde-config-resolver",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "rimraf dist-types/ts3.4 && downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../../.prettierignore --write \"**/*.{ts,md,json}\"",
    "test": "yarn g:vitest run",
    "extract:docs": "api-extractor run --local",
    "test:watch": "yarn g:vitest watch"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "sideEffects": false,
  "dependencies": {
    "@smithy/types": "^4.8.0",
    "tslib": "^2.6.2"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/smithy-lang/smithy-typescript/tree/main/packages/eventstream-serde-config-resolver",
  "repository": {
    "type": "git",
    "url": "https://github.com/smithy-lang/smithy-typescript.git",
    "directory": "packages/eventstream-serde-config-resolver"
  },
  "devDependencies": {
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  }
}
```

## ./lib/lambda/node_modules/@smithy/eventstream-serde-node/dist-types/EventStreamMarshaller.d.ts

```typescript
import type { Decoder, Encoder, EventStreamMarshaller as IEventStreamMarshaller, Message } from "@smithy/types";
import { Readable } from "stream";
/**
 * @internal
 */
export interface EventStreamMarshaller extends IEventStreamMarshaller {
}
/**
 * @internal
 */
export interface EventStreamMarshallerOptions {
    utf8Encoder: Encoder;
    utf8Decoder: Decoder;
}
/**
 * @internal
 */
export declare class EventStreamMarshaller {
    private readonly universalMarshaller;
    constructor({ utf8Encoder, utf8Decoder }: EventStreamMarshallerOptions);
    deserialize<T>(body: Readable, deserializer: (input: Record<string, Message>) => Promise<T>): AsyncIterable<T>;
    serialize<T>(input: AsyncIterable<T>, serializer: (event: T) => Message): Readable;
}

```

## ./lib/lambda/node_modules/@smithy/eventstream-serde-node/dist-types/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./EventStreamMarshaller";
/**
 * @internal
 */
export * from "./provider";

```

## ./lib/lambda/node_modules/@smithy/eventstream-serde-node/dist-types/provider.d.ts

```typescript
import type { EventStreamSerdeProvider } from "@smithy/types";
/** NodeJS event stream utils provider */
export declare const eventStreamSerdeProvider: EventStreamSerdeProvider;

```

## ./lib/lambda/node_modules/@smithy/eventstream-serde-node/dist-types/ts3.4/EventStreamMarshaller.d.ts

```typescript
import { Decoder, Encoder, EventStreamMarshaller as IEventStreamMarshaller, Message } from "@smithy/types";
import { Readable } from "stream";
/**
 * @internal
 */
export interface EventStreamMarshaller extends IEventStreamMarshaller {
}
/**
 * @internal
 */
export interface EventStreamMarshallerOptions {
    utf8Encoder: Encoder;
    utf8Decoder: Decoder;
}
/**
 * @internal
 */
export declare class EventStreamMarshaller {
    private readonly universalMarshaller;
    constructor({ utf8Encoder, utf8Decoder }: EventStreamMarshallerOptions);
    deserialize<T>(body: Readable, deserializer: (input: Record<string, Message>) => Promise<T>): AsyncIterable<T>;
    serialize<T>(input: AsyncIterable<T>, serializer: (event: T) => Message): Readable;
}

```

## ./lib/lambda/node_modules/@smithy/eventstream-serde-node/dist-types/ts3.4/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./EventStreamMarshaller";
/**
 * @internal
 */
export * from "./provider";

```

## ./lib/lambda/node_modules/@smithy/eventstream-serde-node/dist-types/ts3.4/provider.d.ts

```typescript
import { EventStreamSerdeProvider } from "@smithy/types";
/** NodeJS event stream utils provider */
export declare const eventStreamSerdeProvider: EventStreamSerdeProvider;

```

## ./lib/lambda/node_modules/@smithy/eventstream-serde-node/dist-types/ts3.4/utils.d.ts

```typescript
import { Readable } from "stream";
/**
 * Convert object stream piped in into an async iterable. This
 * daptor should be deprecated when Node stream iterator is stable.
 * Caveat: this adaptor won't have backpressure to inwards stream
 *
 * Reference: https://nodejs.org/docs/latest-v11.x/api/stream.html#stream_readable_symbol_asynciterator
 */
/**
 * @internal
 */
export declare function readabletoIterable<T>(readStream: Readable): AsyncIterable<T>;

```

## ./lib/lambda/node_modules/@smithy/eventstream-serde-node/dist-types/utils.d.ts

```typescript
import type { Readable } from "stream";
/**
 * Convert object stream piped in into an async iterable. This
 * daptor should be deprecated when Node stream iterator is stable.
 * Caveat: this adaptor won't have backpressure to inwards stream
 *
 * Reference: https://nodejs.org/docs/latest-v11.x/api/stream.html#stream_readable_symbol_asynciterator
 */
/**
 * @internal
 */
export declare function readabletoIterable<T>(readStream: Readable): AsyncIterable<T>;

```

## ./lib/lambda/node_modules/@smithy/eventstream-serde-node/package.json

```json
{
  "name": "@smithy/eventstream-serde-node",
  "version": "4.2.3",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline eventstream-serde-node",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "rimraf dist-types/ts3.4 && downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../../.prettierignore --write \"**/*.{ts,md,json}\"",
    "test": "exit 0"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "sideEffects": false,
  "dependencies": {
    "@smithy/eventstream-serde-universal": "^4.2.3",
    "@smithy/types": "^4.8.0",
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "@types/node": "^18.11.9",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/smithy-lang/smithy-typescript/tree/main/packages/eventstream-serde-node",
  "repository": {
    "type": "git",
    "url": "https://github.com/smithy-lang/smithy-typescript.git",
    "directory": "packages/eventstream-serde-node"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  }
}
```

## ./lib/lambda/node_modules/@smithy/eventstream-serde-universal/dist-types/EventStreamMarshaller.d.ts

```typescript
import type { Decoder, Encoder, EventStreamMarshaller as IEventStreamMarshaller, Message } from "@smithy/types";
/**
 * @internal
 */
export interface EventStreamMarshaller extends IEventStreamMarshaller {
}
/**
 * @internal
 */
export interface EventStreamMarshallerOptions {
    utf8Encoder: Encoder;
    utf8Decoder: Decoder;
}
/**
 * @internal
 */
export declare class EventStreamMarshaller {
    private readonly eventStreamCodec;
    private readonly utfEncoder;
    constructor({ utf8Encoder, utf8Decoder }: EventStreamMarshallerOptions);
    deserialize<T>(body: AsyncIterable<Uint8Array>, deserializer: (input: Record<string, Message>) => Promise<T>): AsyncIterable<T>;
    serialize<T>(inputStream: AsyncIterable<T>, serializer: (event: T) => Message): AsyncIterable<Uint8Array>;
}

```

## ./lib/lambda/node_modules/@smithy/eventstream-serde-universal/dist-types/getChunkedStream.d.ts

```typescript
/**
 * @internal
 */
export declare function getChunkedStream(source: AsyncIterable<Uint8Array>): AsyncIterable<Uint8Array>;

```

## ./lib/lambda/node_modules/@smithy/eventstream-serde-universal/dist-types/getUnmarshalledStream.d.ts

```typescript
import type { EventStreamCodec } from "@smithy/eventstream-codec";
import type { Encoder, Message } from "@smithy/types";
/**
 * @internal
 */
export type UnmarshalledStreamOptions<T> = {
    eventStreamCodec: EventStreamCodec;
    deserializer: (input: Record<string, Message>) => Promise<T>;
    toUtf8: Encoder;
};
/**
 * @internal
 */
export declare function getUnmarshalledStream<T extends Record<string, any>>(source: AsyncIterable<Uint8Array>, options: UnmarshalledStreamOptions<T>): AsyncIterable<T>;
/**
 * @internal
 */
export declare function getMessageUnmarshaller<T extends Record<string, any>>(deserializer: (input: Record<string, Message>) => Promise<T>, toUtf8: Encoder): (input: Message) => Promise<T | undefined>;

```

## ./lib/lambda/node_modules/@smithy/eventstream-serde-universal/dist-types/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./EventStreamMarshaller";
/**
 * @internal
 */
export * from "./provider";

```

## ./lib/lambda/node_modules/@smithy/eventstream-serde-universal/dist-types/provider.d.ts

```typescript
import type { EventStreamSerdeProvider } from "@smithy/types";
/** NodeJS event stream utils provider */
export declare const eventStreamSerdeProvider: EventStreamSerdeProvider;

```

## ./lib/lambda/node_modules/@smithy/eventstream-serde-universal/dist-types/ts3.4/EventStreamMarshaller.d.ts

```typescript
import { Decoder, Encoder, EventStreamMarshaller as IEventStreamMarshaller, Message } from "@smithy/types";
/**
 * @internal
 */
export interface EventStreamMarshaller extends IEventStreamMarshaller {
}
/**
 * @internal
 */
export interface EventStreamMarshallerOptions {
    utf8Encoder: Encoder;
    utf8Decoder: Decoder;
}
/**
 * @internal
 */
export declare class EventStreamMarshaller {
    private readonly eventStreamCodec;
    private readonly utfEncoder;
    constructor({ utf8Encoder, utf8Decoder }: EventStreamMarshallerOptions);
    deserialize<T>(body: AsyncIterable<Uint8Array>, deserializer: (input: Record<string, Message>) => Promise<T>): AsyncIterable<T>;
    serialize<T>(inputStream: AsyncIterable<T>, serializer: (event: T) => Message): AsyncIterable<Uint8Array>;
}

```

## ./lib/lambda/node_modules/@smithy/eventstream-serde-universal/dist-types/ts3.4/getChunkedStream.d.ts

```typescript
/**
 * @internal
 */
export declare function getChunkedStream(source: AsyncIterable<Uint8Array>): AsyncIterable<Uint8Array>;

```

## ./lib/lambda/node_modules/@smithy/eventstream-serde-universal/dist-types/ts3.4/getUnmarshalledStream.d.ts

```typescript
import { EventStreamCodec } from "@smithy/eventstream-codec";
import { Encoder, Message } from "@smithy/types";
/**
 * @internal
 */
export type UnmarshalledStreamOptions<T> = {
    eventStreamCodec: EventStreamCodec;
    deserializer: (input: Record<string, Message>) => Promise<T>;
    toUtf8: Encoder;
};
/**
 * @internal
 */
export declare function getUnmarshalledStream<T extends Record<string, any>>(source: AsyncIterable<Uint8Array>, options: UnmarshalledStreamOptions<T>): AsyncIterable<T>;
/**
 * @internal
 */
export declare function getMessageUnmarshaller<T extends Record<string, any>>(deserializer: (input: Record<string, Message>) => Promise<T>, toUtf8: Encoder): (input: Message) => Promise<T | undefined>;

```

## ./lib/lambda/node_modules/@smithy/eventstream-serde-universal/dist-types/ts3.4/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./EventStreamMarshaller";
/**
 * @internal
 */
export * from "./provider";

```

## ./lib/lambda/node_modules/@smithy/eventstream-serde-universal/dist-types/ts3.4/provider.d.ts

```typescript
import { EventStreamSerdeProvider } from "@smithy/types";
/** NodeJS event stream utils provider */
export declare const eventStreamSerdeProvider: EventStreamSerdeProvider;

```

## ./lib/lambda/node_modules/@smithy/eventstream-serde-universal/package.json

```json
{
  "name": "@smithy/eventstream-serde-universal",
  "version": "4.2.3",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline eventstream-serde-universal",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "rimraf dist-types/ts3.4 && downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../../.prettierignore --write \"**/*.{ts,md,json}\"",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch",
    "test:integration": "yarn g:vitest run -c vitest.config.integ.mts",
    "test:integration:watch": "yarn g:vitest watch -c vitest.config.integ.mts"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "sideEffects": false,
  "dependencies": {
    "@smithy/eventstream-codec": "^4.2.3",
    "@smithy/types": "^4.8.0",
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "@smithy/util-utf8": "^4.2.0",
    "@types/node": "^18.11.9",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/smithy-lang/smithy-typescript/tree/main/packages/eventstream-serde-universal",
  "repository": {
    "type": "git",
    "url": "https://github.com/smithy-lang/smithy-typescript.git",
    "directory": "packages/eventstream-serde-universal"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  }
}
```

## ./lib/lambda/node_modules/@smithy/fetch-http-handler/dist-types/create-request.d.ts

```typescript
import type { AdditionalRequestParameters } from "./fetch-http-handler";
/**
 * @internal
 * For mocking/interception.
 */
export declare function createRequest(url: string, requestOptions?: RequestInit & AdditionalRequestParameters): Request;

```

## ./lib/lambda/node_modules/@smithy/fetch-http-handler/dist-types/fetch-http-handler.d.ts

```typescript
import type { HttpHandler, HttpRequest } from "@smithy/protocol-http";
import { HttpResponse } from "@smithy/protocol-http";
import type { FetchHttpHandlerOptions } from "@smithy/types";
import type { HttpHandlerOptions, Provider } from "@smithy/types";
/**
 * @public
 */
export { FetchHttpHandlerOptions };
/**
 * @internal
 * Detection of keepalive support. Can be overridden for testing.
 */
export declare const keepAliveSupport: {
    supported: undefined | boolean;
};
/**
 * @internal
 */
export type AdditionalRequestParameters = {
    duplex?: "half";
};
/**
 * @public
 *
 * HttpHandler implementation using browsers' `fetch` global function.
 */
export declare class FetchHttpHandler implements HttpHandler<FetchHttpHandlerOptions> {
    private config?;
    private configProvider;
    /**
     * @returns the input if it is an HttpHandler of any class,
     * or instantiates a new instance of this handler.
     */
    static create(instanceOrOptions?: HttpHandler<any> | FetchHttpHandlerOptions | Provider<FetchHttpHandlerOptions | void>): FetchHttpHandler | HttpHandler<any>;
    constructor(options?: FetchHttpHandlerOptions | Provider<FetchHttpHandlerOptions | void>);
    destroy(): void;
    handle(request: HttpRequest, { abortSignal, requestTimeout }?: HttpHandlerOptions): Promise<{
        response: HttpResponse;
    }>;
    updateHttpClientConfig(key: keyof FetchHttpHandlerOptions, value: FetchHttpHandlerOptions[typeof key]): void;
    httpHandlerConfigs(): FetchHttpHandlerOptions;
}

```

## ./lib/lambda/node_modules/@smithy/fetch-http-handler/dist-types/index.d.ts

```typescript
export * from "./fetch-http-handler";
export * from "./stream-collector";

```

## ./lib/lambda/node_modules/@smithy/fetch-http-handler/dist-types/request-timeout.d.ts

```typescript
export declare function requestTimeout(timeoutInMs?: number): Promise<never>;

```

## ./lib/lambda/node_modules/@smithy/fetch-http-handler/dist-types/stream-collector.d.ts

```typescript
import type { StreamCollector } from "@smithy/types";
export declare const streamCollector: StreamCollector;

```

## ./lib/lambda/node_modules/@smithy/fetch-http-handler/dist-types/ts3.4/create-request.d.ts

```typescript
import { AdditionalRequestParameters } from "./fetch-http-handler";
/**
 * @internal
 * For mocking/interception.
 */
export declare function createRequest(url: string, requestOptions?: RequestInit & AdditionalRequestParameters): Request;

```

## ./lib/lambda/node_modules/@smithy/fetch-http-handler/dist-types/ts3.4/fetch-http-handler.d.ts

```typescript
import { HttpHandler, HttpRequest } from "@smithy/protocol-http";
import { HttpResponse } from "@smithy/protocol-http";
import { FetchHttpHandlerOptions } from "@smithy/types";
import { HttpHandlerOptions, Provider } from "@smithy/types";
/**
 * @public
 */
export { FetchHttpHandlerOptions };
/**
 * @internal
 * Detection of keepalive support. Can be overridden for testing.
 */
export declare const keepAliveSupport: {
    supported: undefined | boolean;
};
/**
 * @internal
 */
export type AdditionalRequestParameters = {
    duplex?: "half";
};
/**
 * @public
 *
 * HttpHandler implementation using browsers' `fetch` global function.
 */
export declare class FetchHttpHandler implements HttpHandler<FetchHttpHandlerOptions> {
    private config?;
    private configProvider;
    /**
     * @returns the input if it is an HttpHandler of any class,
     * or instantiates a new instance of this handler.
     */
    static create(instanceOrOptions?: HttpHandler<any> | FetchHttpHandlerOptions | Provider<FetchHttpHandlerOptions | void>): FetchHttpHandler | HttpHandler<any>;
    constructor(options?: FetchHttpHandlerOptions | Provider<FetchHttpHandlerOptions | void>);
    destroy(): void;
    handle(request: HttpRequest, { abortSignal, requestTimeout }?: HttpHandlerOptions): Promise<{
        response: HttpResponse;
    }>;
    updateHttpClientConfig(key: keyof FetchHttpHandlerOptions, value: FetchHttpHandlerOptions[typeof key]): void;
    httpHandlerConfigs(): FetchHttpHandlerOptions;
}

```

## ./lib/lambda/node_modules/@smithy/fetch-http-handler/dist-types/ts3.4/index.d.ts

```typescript
export * from "./fetch-http-handler";
export * from "./stream-collector";

```

## ./lib/lambda/node_modules/@smithy/fetch-http-handler/dist-types/ts3.4/request-timeout.d.ts

```typescript
export declare function requestTimeout(timeoutInMs?: number): Promise<never>;

```

## ./lib/lambda/node_modules/@smithy/fetch-http-handler/dist-types/ts3.4/stream-collector.d.ts

```typescript
import { StreamCollector } from "@smithy/types";
export declare const streamCollector: StreamCollector;

```

## ./lib/lambda/node_modules/@smithy/fetch-http-handler/package.json

```json
{
  "name": "@smithy/fetch-http-handler",
  "version": "5.3.4",
  "description": "Provides a way to make requests",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline fetch-http-handler",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "rimraf dist-types/ts3.4 && downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../../.prettierignore --write \"**/*.{ts,md,json}\"",
    "extract:docs": "api-extractor run --local",
    "test": "yarn g:vitest run && yarn test:browser",
    "test:watch": "yarn g:vitest watch",
    "test:browser": "yarn g:vitest run -c vitest.config.browser.mts",
    "test:browser:watch": "yarn g:vitest watch -c vitest.config.browser.mts"
  },
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "sideEffects": false,
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "dependencies": {
    "@smithy/protocol-http": "^5.3.3",
    "@smithy/querystring-builder": "^4.2.3",
    "@smithy/types": "^4.8.0",
    "@smithy/util-base64": "^4.3.0",
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "@smithy/abort-controller": "^4.2.3",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/smithy-lang/smithy-typescript/tree/main/packages/fetch-http-handler",
  "repository": {
    "type": "git",
    "url": "https://github.com/smithy-lang/smithy-typescript.git",
    "directory": "packages/fetch-http-handler"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  },
  "engines": {
    "node": ">=18.0.0"
  }
}
```

## ./lib/lambda/node_modules/@smithy/hash-blob-browser/dist-types/index.d.ts

```typescript
import type { StreamHasher } from "@smithy/types";
/**
 * @internal
 */
export declare const blobHasher: StreamHasher<Blob>;

```

## ./lib/lambda/node_modules/@smithy/hash-blob-browser/dist-types/ts3.4/index.d.ts

```typescript
import { StreamHasher } from "@smithy/types";
/**
 * @internal
 */
export declare const blobHasher: StreamHasher<Blob>;

```

## ./lib/lambda/node_modules/@smithy/hash-blob-browser/package.json

```json
{
  "name": "@smithy/hash-blob-browser",
  "version": "4.2.4",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline hash-blob-browser",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "rimraf dist-types/ts3.4 && downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../../.prettierignore --write \"**/*.{ts,md,json}\"",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "sideEffects": false,
  "dependencies": {
    "@smithy/chunked-blob-reader": "^5.2.0",
    "@smithy/chunked-blob-reader-native": "^4.2.1",
    "@smithy/types": "^4.8.0",
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "@smithy/util-hex-encoding": "^4.2.0",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "react-native": {
    "@smithy/chunked-blob-reader": "@smithy/chunked-blob-reader-native"
  },
  "browser": {
    "@smithy/chunked-blob-reader": "@smithy/chunked-blob-reader"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/smithy-lang/smithy-typescript/tree/main/packages/hash-blob-browser",
  "repository": {
    "type": "git",
    "url": "https://github.com/smithy-lang/smithy-typescript.git",
    "directory": "packages/hash-blob-browser"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  },
  "engines": {
    "node": ">=18.0.0"
  }
}
```

## ./lib/lambda/node_modules/@smithy/hash-node/dist-types/index.d.ts

```typescript
import type { Checksum, SourceData } from "@smithy/types";
/**
 * @internal
 */
export declare class Hash implements Checksum {
    private readonly algorithmIdentifier;
    private readonly secret?;
    private hash;
    constructor(algorithmIdentifier: string, secret?: SourceData);
    update(toHash: SourceData, encoding?: "utf8" | "ascii" | "latin1"): void;
    digest(): Promise<Uint8Array>;
    reset(): void;
}

```

## ./lib/lambda/node_modules/@smithy/hash-node/dist-types/ts3.4/index.d.ts

```typescript
import { Checksum, SourceData } from "@smithy/types";
/**
 * @internal
 */
export declare class Hash implements Checksum {
    private readonly algorithmIdentifier;
    private readonly secret?;
    private hash;
    constructor(algorithmIdentifier: string, secret?: SourceData);
    update(toHash: SourceData, encoding?: "utf8" | "ascii" | "latin1"): void;
    digest(): Promise<Uint8Array>;
    reset(): void;
}

```

## ./lib/lambda/node_modules/@smithy/hash-node/package.json

```json
{
  "name": "@smithy/hash-node",
  "version": "4.2.3",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline hash-node",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "rimraf dist-types/ts3.4 && downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../../.prettierignore --write \"**/*.{ts,md,json}\"",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "sideEffects": false,
  "devDependencies": {
    "@types/node": "^18.11.9",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "hash-test-vectors": "^1.3.2",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "dependencies": {
    "@smithy/types": "^4.8.0",
    "@smithy/util-buffer-from": "^4.2.0",
    "@smithy/util-utf8": "^4.2.0",
    "tslib": "^2.6.2"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/smithy-lang/smithy-typescript/tree/main/packages/hash-node",
  "repository": {
    "type": "git",
    "url": "https://github.com/smithy-lang/smithy-typescript.git",
    "directory": "packages/hash-node"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  }
}
```

## ./lib/lambda/node_modules/@smithy/hash-stream-node/dist-types/HashCalculator.d.ts

```typescript
import type { Checksum, Hash } from "@smithy/types";
import type { WritableOptions } from "stream";
import { Writable } from "stream";
/**
 * @internal
 */
export declare class HashCalculator extends Writable {
    readonly hash: Checksum | Hash;
    constructor(hash: Checksum | Hash, options?: WritableOptions);
    _write(chunk: Buffer, encoding: string, callback: (err?: Error) => void): void;
}

```

## ./lib/lambda/node_modules/@smithy/hash-stream-node/dist-types/fileStreamHasher.d.ts

```typescript
import type { StreamHasher } from "@smithy/types";
import type { Readable } from "stream";
/**
 * @internal
 */
export declare const fileStreamHasher: StreamHasher<Readable>;

```

## ./lib/lambda/node_modules/@smithy/hash-stream-node/dist-types/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./fileStreamHasher";
/**
 * @internal
 */
export * from "./readableStreamHasher";

```

## ./lib/lambda/node_modules/@smithy/hash-stream-node/dist-types/readableStreamHasher.d.ts

```typescript
import type { StreamHasher } from "@smithy/types";
import type { Readable } from "stream";
/**
 * @internal
 */
export declare const readableStreamHasher: StreamHasher<Readable>;

```

## ./lib/lambda/node_modules/@smithy/hash-stream-node/dist-types/ts3.4/HashCalculator.d.ts

```typescript
import { Checksum, Hash } from "@smithy/types";
import { WritableOptions } from "stream";
import { Writable } from "stream";
/**
 * @internal
 */
export declare class HashCalculator extends Writable {
    readonly hash: Checksum | Hash;
    constructor(hash: Checksum | Hash, options?: WritableOptions);
    _write(chunk: Buffer, encoding: string, callback: (err?: Error) => void): void;
}

```

## ./lib/lambda/node_modules/@smithy/hash-stream-node/dist-types/ts3.4/fileStreamHasher.d.ts

```typescript
import { StreamHasher } from "@smithy/types";
import { Readable } from "stream";
/**
 * @internal
 */
export declare const fileStreamHasher: StreamHasher<Readable>;

```

## ./lib/lambda/node_modules/@smithy/hash-stream-node/dist-types/ts3.4/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./fileStreamHasher";
/**
 * @internal
 */
export * from "./readableStreamHasher";

```

## ./lib/lambda/node_modules/@smithy/hash-stream-node/dist-types/ts3.4/readableStreamHasher.d.ts

```typescript
import { StreamHasher } from "@smithy/types";
import { Readable } from "stream";
/**
 * @internal
 */
export declare const readableStreamHasher: StreamHasher<Readable>;

```

## ./lib/lambda/node_modules/@smithy/hash-stream-node/package.json

```json
{
  "name": "@smithy/hash-stream-node",
  "version": "4.2.3",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline hash-stream-node",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "rimraf dist-types/ts3.4 && downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../../.prettierignore --write \"**/*.{ts,md,json}\"",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "sideEffects": false,
  "dependencies": {
    "@smithy/types": "^4.8.0",
    "@smithy/util-utf8": "^4.2.0",
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "@aws-crypto/sha256-js": "5.2.0",
    "@smithy/util-hex-encoding": "^4.2.0",
    "@types/node": "^18.11.9",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/smithy-lang/smithy-typescript/tree/main/packages/hash-stream-node",
  "repository": {
    "type": "git",
    "url": "https://github.com/smithy-lang/smithy-typescript.git",
    "directory": "packages/hash-stream-node"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  }
}
```

## ./lib/lambda/node_modules/@smithy/invalid-dependency/dist-types/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./invalidFunction";
/**
 * @internal
 */
export * from "./invalidProvider";

```

## ./lib/lambda/node_modules/@smithy/invalid-dependency/dist-types/invalidFunction.d.ts

```typescript
/**
 * @internal
 */
export declare const invalidFunction: (message: string) => () => never;

```

## ./lib/lambda/node_modules/@smithy/invalid-dependency/dist-types/invalidProvider.d.ts

```typescript
import type { Provider } from "@smithy/types";
/**
 * @internal
 */
export declare const invalidProvider: (message: string) => Provider<any>;

```

## ./lib/lambda/node_modules/@smithy/invalid-dependency/dist-types/ts3.4/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./invalidFunction";
/**
 * @internal
 */
export * from "./invalidProvider";

```

## ./lib/lambda/node_modules/@smithy/invalid-dependency/dist-types/ts3.4/invalidFunction.d.ts

```typescript
/**
 * @internal
 */
export declare const invalidFunction: (message: string) => () => never;

```

## ./lib/lambda/node_modules/@smithy/invalid-dependency/dist-types/ts3.4/invalidProvider.d.ts

```typescript
import { Provider } from "@smithy/types";
/**
 * @internal
 */
export declare const invalidProvider: (message: string) => Provider<any>;

```

## ./lib/lambda/node_modules/@smithy/invalid-dependency/package.json

```json
{
  "name": "@smithy/invalid-dependency",
  "version": "4.2.3",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline invalid-dependency",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "rimraf dist-types/ts3.4 && downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../../.prettierignore --write \"**/*.{ts,md,json}\"",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "sideEffects": false,
  "dependencies": {
    "@smithy/types": "^4.8.0",
    "tslib": "^2.6.2"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/smithy-lang/smithy-typescript/tree/main/packages/invalid-dependency",
  "repository": {
    "type": "git",
    "url": "https://github.com/smithy-lang/smithy-typescript.git",
    "directory": "packages/invalid-dependency"
  },
  "devDependencies": {
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  },
  "engines": {
    "node": ">=18.0.0"
  }
}
```

## ./lib/lambda/node_modules/@smithy/is-array-buffer/dist-types/index.d.ts

```typescript
/**
 * @internal
 */
export declare const isArrayBuffer: (arg: any) => arg is ArrayBuffer;

```

## ./lib/lambda/node_modules/@smithy/is-array-buffer/dist-types/ts3.4/index.d.ts

```typescript
/**
 * @internal
 */
export declare const isArrayBuffer: (arg: any) => arg is ArrayBuffer;

```

## ./lib/lambda/node_modules/@smithy/is-array-buffer/package.json

```json
{
  "name": "@smithy/is-array-buffer",
  "version": "4.2.0",
  "description": "Provides a function for detecting if an argument is an ArrayBuffer",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline is-array-buffer",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "rimraf dist-types/ts3.4 && downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../../.prettierignore --write \"**/*.{ts,md,json}\"",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch"
  },
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "sideEffects": false,
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "dependencies": {
    "tslib": "^2.6.2"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/smithy-lang/smithy-typescript/tree/main/packages/is-array-buffer",
  "repository": {
    "type": "git",
    "url": "https://github.com/smithy-lang/smithy-typescript.git",
    "directory": "packages/is-array-buffer"
  },
  "devDependencies": {
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  }
}
```

## ./lib/lambda/node_modules/@smithy/md5-js/dist-types/constants.d.ts

```typescript
/**
 * @internal
 */
export declare const BLOCK_SIZE = 64;
/**
 * @internal
 */
export declare const DIGEST_LENGTH = 16;
/**
 * @internal
 */
export declare const INIT: number[];

```

## ./lib/lambda/node_modules/@smithy/md5-js/dist-types/index.d.ts

```typescript
import type { Checksum, SourceData } from "@smithy/types";
/**
 * @internal
 */
export declare class Md5 implements Checksum {
    private state;
    private buffer;
    private bufferLength;
    private bytesHashed;
    private finished;
    constructor();
    update(sourceData: SourceData): void;
    digest(): Promise<Uint8Array>;
    private hashBuffer;
    reset(): void;
}

```

## ./lib/lambda/node_modules/@smithy/md5-js/dist-types/ts3.4/constants.d.ts

```typescript
/**
 * @internal
 */
export declare const BLOCK_SIZE = 64;
/**
 * @internal
 */
export declare const DIGEST_LENGTH = 16;
/**
 * @internal
 */
export declare const INIT: number[];

```

## ./lib/lambda/node_modules/@smithy/md5-js/dist-types/ts3.4/index.d.ts

```typescript
import { Checksum, SourceData } from "@smithy/types";
/**
 * @internal
 */
export declare class Md5 implements Checksum {
    private state;
    private buffer;
    private bufferLength;
    private bytesHashed;
    private finished;
    constructor();
    update(sourceData: SourceData): void;
    digest(): Promise<Uint8Array>;
    private hashBuffer;
    reset(): void;
}

```

## ./lib/lambda/node_modules/@smithy/md5-js/package.json

```json
{
  "name": "@smithy/md5-js",
  "version": "4.2.3",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline md5-js",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "rimraf dist-types/ts3.4 && downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../../.prettierignore --write \"**/*.{ts,md,json}\"",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "sideEffects": false,
  "devDependencies": {
    "@smithy/util-base64": "^4.3.0",
    "@smithy/util-hex-encoding": "^4.2.0",
    "@types/node": "^18.11.9",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "hash-test-vectors": "^1.3.2",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "dependencies": {
    "@smithy/types": "^4.8.0",
    "@smithy/util-utf8": "^4.2.0",
    "tslib": "^2.6.2"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/smithy-lang/smithy-typescript/tree/main/packages/md5-js",
  "repository": {
    "type": "git",
    "url": "https://github.com/smithy-lang/smithy-typescript.git",
    "directory": "packages/md5-js"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  },
  "engines": {
    "node": ">=18.0.0"
  }
}
```

## ./lib/lambda/node_modules/@smithy/middleware-content-length/dist-types/index.d.ts

```typescript
import type { BodyLengthCalculator, BuildHandlerOptions, BuildMiddleware, Pluggable } from "@smithy/types";
export declare function contentLengthMiddleware(bodyLengthChecker: BodyLengthCalculator): BuildMiddleware<any, any>;
export declare const contentLengthMiddlewareOptions: BuildHandlerOptions;
export declare const getContentLengthPlugin: (options: {
    bodyLengthChecker: BodyLengthCalculator;
}) => Pluggable<any, any>;

```

## ./lib/lambda/node_modules/@smithy/middleware-content-length/dist-types/ts3.4/index.d.ts

```typescript
import { BodyLengthCalculator, BuildHandlerOptions, BuildMiddleware, Pluggable } from "@smithy/types";
export declare function contentLengthMiddleware(bodyLengthChecker: BodyLengthCalculator): BuildMiddleware<any, any>;
export declare const contentLengthMiddlewareOptions: BuildHandlerOptions;
export declare const getContentLengthPlugin: (options: {
    bodyLengthChecker: BodyLengthCalculator;
}) => Pluggable<any, any>;

```

## ./lib/lambda/node_modules/@smithy/middleware-content-length/package.json

```json
{
  "name": "@smithy/middleware-content-length",
  "version": "4.2.3",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline middleware-content-length",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "rimraf dist-types/ts3.4 && downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../../.prettierignore --write \"**/*.{ts,md,json}\"",
    "test": "exit 0",
    "test:integration": "yarn g:vitest run -c vitest.config.integ.mts",
    "test:integration:watch": "yarn g:vitest watch -c vitest.config.integ.mts"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "sideEffects": false,
  "dependencies": {
    "@smithy/protocol-http": "^5.3.3",
    "@smithy/types": "^4.8.0",
    "tslib": "^2.6.2"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/smithy-lang/smithy-typescript/tree/main/packages/middleware-content-length",
  "repository": {
    "type": "git",
    "url": "https://github.com/smithy-lang/smithy-typescript.git",
    "directory": "packages/middleware-content-length"
  },
  "devDependencies": {
    "@smithy/util-test": "^0.2.8",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  }
}
```

## ./lib/lambda/node_modules/@smithy/middleware-endpoint/dist-types/adaptors/createConfigValueProvider.d.ts

```typescript
/**
 * Normalize some key of the client config to an async provider.
 * @internal
 *
 * @param configKey - the key to look up in config.
 * @param canonicalEndpointParamKey - this is the name the EndpointRuleSet uses.
 *                                    it will most likely not contain the config
 *                                    value, but we use it as a fallback.
 * @param config - container of the config values.
 *
 * @returns async function that will resolve with the value.
 */
export declare const createConfigValueProvider: <Config extends Record<string, unknown>>(configKey: string, canonicalEndpointParamKey: string, config: Config) => () => Promise<any>;

```

## ./lib/lambda/node_modules/@smithy/middleware-endpoint/dist-types/adaptors/getEndpointFromConfig.browser.d.ts

```typescript
export declare const getEndpointFromConfig: (serviceId: string) => Promise<undefined>;

```

## ./lib/lambda/node_modules/@smithy/middleware-endpoint/dist-types/adaptors/getEndpointFromConfig.d.ts

```typescript
/**
 * @internal
 */
export declare const getEndpointFromConfig: (serviceId?: string) => Promise<string | undefined>;

```

## ./lib/lambda/node_modules/@smithy/middleware-endpoint/dist-types/adaptors/getEndpointFromInstructions.d.ts

```typescript
import type { EndpointParameters, EndpointV2, HandlerExecutionContext } from "@smithy/types";
import type { EndpointResolvedConfig } from "../resolveEndpointConfig";
import type { EndpointParameterInstructions } from "../types";
/**
 * @internal
 */
export type EndpointParameterInstructionsSupplier = Partial<{
    getEndpointParameterInstructions(): EndpointParameterInstructions;
}>;
/**
 * This step in the endpoint resolution process is exposed as a function
 * to allow packages such as signers, lib-upload, etc. to get
 * the V2 Endpoint associated to an instance of some api operation command
 * without needing to send it or resolve its middleware stack.
 *
 * @internal
 * @param commandInput         - the input of the Command in question.
 * @param instructionsSupplier - this is typically a Command constructor. A static function supplying the
 *                               endpoint parameter instructions will exist for commands in services
 *                               having an endpoints ruleset trait.
 * @param clientConfig         - config of the service client.
 * @param context              - optional context.
 */
export declare const getEndpointFromInstructions: <T extends EndpointParameters, CommandInput extends Record<string, unknown>, Config extends Record<string, unknown>>(commandInput: CommandInput, instructionsSupplier: EndpointParameterInstructionsSupplier, clientConfig: Partial<EndpointResolvedConfig<T>> & Config, context?: HandlerExecutionContext) => Promise<EndpointV2>;
/**
 * @internal
 */
export declare const resolveParams: <T extends EndpointParameters, CommandInput extends Record<string, unknown>, Config extends Record<string, unknown>>(commandInput: CommandInput, instructionsSupplier: EndpointParameterInstructionsSupplier, clientConfig: Partial<EndpointResolvedConfig<T>> & Config) => Promise<EndpointParameters>;

```

## ./lib/lambda/node_modules/@smithy/middleware-endpoint/dist-types/adaptors/getEndpointUrlConfig.d.ts

```typescript
import type { LoadedConfigSelectors } from "@smithy/node-config-provider";
export declare const getEndpointUrlConfig: (serviceId: string) => LoadedConfigSelectors<string | undefined>;

```

## ./lib/lambda/node_modules/@smithy/middleware-endpoint/dist-types/adaptors/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./getEndpointFromInstructions";
/**
 * @internal
 */
export * from "./toEndpointV1";

```

## ./lib/lambda/node_modules/@smithy/middleware-endpoint/dist-types/adaptors/toEndpointV1.d.ts

```typescript
import type { Endpoint, EndpointV2 } from "@smithy/types";
/**
 * @internal
 */
export declare const toEndpointV1: (endpoint: string | Endpoint | EndpointV2) => Endpoint;

```

## ./lib/lambda/node_modules/@smithy/middleware-endpoint/dist-types/endpointMiddleware.d.ts

```typescript
import type { EndpointParameters, SerializeMiddleware } from "@smithy/types";
import type { EndpointResolvedConfig } from "./resolveEndpointConfig";
import type { EndpointParameterInstructions } from "./types";
/**
 * @internal
 */
export declare const endpointMiddleware: <T extends EndpointParameters>({ config, instructions, }: {
    config: EndpointResolvedConfig<T>;
    instructions: EndpointParameterInstructions;
}) => SerializeMiddleware<any, any>;

```

## ./lib/lambda/node_modules/@smithy/middleware-endpoint/dist-types/getEndpointPlugin.d.ts

```typescript
import type { EndpointParameters, Pluggable, RelativeMiddlewareOptions, SerializeHandlerOptions } from "@smithy/types";
import type { EndpointResolvedConfig } from "./resolveEndpointConfig";
import type { EndpointParameterInstructions } from "./types";
/**
 * @internal
 */
export declare const endpointMiddlewareOptions: SerializeHandlerOptions & RelativeMiddlewareOptions;
/**
 * @internal
 */
export declare const getEndpointPlugin: <T extends EndpointParameters>(config: EndpointResolvedConfig<T>, instructions: EndpointParameterInstructions) => Pluggable<any, any>;

```

## ./lib/lambda/node_modules/@smithy/middleware-endpoint/dist-types/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./adaptors";
/**
 * @internal
 */
export * from "./endpointMiddleware";
/**
 * @internal
 */
export * from "./getEndpointPlugin";
export * from "./resolveEndpointConfig";
export * from "./resolveEndpointRequiredConfig";
/**
 * @internal
 */
export * from "./types";

```

## ./lib/lambda/node_modules/@smithy/middleware-endpoint/dist-types/resolveEndpointConfig.d.ts

```typescript
import type { Endpoint, EndpointParameters, EndpointV2, Logger, Provider, UrlParser } from "@smithy/types";
/**
 * @public
 *
 * Endpoint config interfaces and resolver for Endpoint v2. They live in separate package to allow per-service onboarding.
 * When all services onboard Endpoint v2, the resolver in config-resolver package can be removed.
 * This interface includes all the endpoint parameters with built-in bindings of "AWS::*" and "SDK::*"
 */
export interface EndpointInputConfig<T extends EndpointParameters = EndpointParameters> {
    /**
     * The fully qualified endpoint of the webservice. This is only for using
     * a custom endpoint (for example, when using a local version of S3).
     *
     * Endpoint transformations such as S3 applying a bucket to the hostname are
     * still applicable to this custom endpoint.
     */
    endpoint?: string | Endpoint | Provider<Endpoint> | EndpointV2 | Provider<EndpointV2>;
    /**
     * Providing a custom endpointProvider will override
     * built-in transformations of the endpoint such as S3 adding the bucket
     * name to the hostname, since they are part of the default endpointProvider.
     */
    endpointProvider?: (params: T, context?: {
        logger?: Logger;
    }) => EndpointV2;
    /**
     * Whether TLS is enabled for requests.
     * @deprecated
     */
    tls?: boolean;
    /**
     * Enables IPv6/IPv4 dualstack endpoint.
     */
    useDualstackEndpoint?: boolean | Provider<boolean>;
    /**
     * Enables FIPS compatible endpoints.
     */
    useFipsEndpoint?: boolean | Provider<boolean>;
    /**
     * @internal
     * This field is used internally so you should not fill any value to this field.
     */
    serviceConfiguredEndpoint?: never;
}
/**
 * @internal
 */
interface PreviouslyResolved<T extends EndpointParameters = EndpointParameters> {
    urlParser: UrlParser;
    endpointProvider: (params: T, context?: {
        logger?: Logger;
    }) => EndpointV2;
    logger?: Logger;
    serviceId?: string;
}
/**
 * @internal
 *
 * This supersedes the similarly named EndpointsResolvedConfig (no parametric types)
 * from resolveEndpointsConfig.ts in \@smithy/config-resolver.
 */
export interface EndpointResolvedConfig<T extends EndpointParameters = EndpointParameters> {
    /**
     * Custom endpoint provided by the user.
     * This is normalized to a single interface from the various acceptable types.
     * This field will be undefined if a custom endpoint is not provided.
     */
    endpoint?: Provider<Endpoint>;
    endpointProvider: (params: T, context?: {
        logger?: Logger;
    }) => EndpointV2;
    /**
     * Whether TLS is enabled for requests.
     * @deprecated
     */
    tls: boolean;
    /**
     * Whether the endpoint is specified by caller.
     * This should be used over checking the existence of `endpoint`, since
     * that may have been set by other means, such as the default regional
     * endpoint provider function.
     *
     * @internal
     */
    isCustomEndpoint?: boolean;
    /**
     * Resolved value for input {@link EndpointsInputConfig.useDualstackEndpoint}
     */
    useDualstackEndpoint: Provider<boolean>;
    /**
     * Resolved value for input {@link EndpointsInputConfig.useFipsEndpoint}
     */
    useFipsEndpoint: Provider<boolean>;
    /**
     * Unique service identifier.
     * @internal
     */
    serviceId?: string;
    /**
     * A configured endpoint global or specific to the service from ENV or AWS SDK configuration files.
     * @internal
     */
    serviceConfiguredEndpoint?: Provider<string | undefined>;
}
/**
 * @internal
 */
export declare const resolveEndpointConfig: <T, P extends EndpointParameters = EndpointParameters>(input: T & EndpointInputConfig<P> & PreviouslyResolved<P>) => T & EndpointResolvedConfig<P>;
export {};

```

## ./lib/lambda/node_modules/@smithy/middleware-endpoint/dist-types/resolveEndpointRequiredConfig.d.ts

```typescript
import type { Endpoint, EndpointV2, Provider } from "@smithy/types";
/**
 * This is an additional config resolver layer for clients using the default
 * endpoints ruleset. It modifies the input and output config types to make
 * the endpoint configuration property required.
 *
 * It must be placed after the `resolveEndpointConfig`
 * resolver. This replaces the "CustomEndpoints" config resolver, which was used
 * prior to default endpoint rulesets.
 *
 * @public
 */
export interface EndpointRequiredInputConfig {
    endpoint: string | Endpoint | Provider<Endpoint> | EndpointV2 | Provider<EndpointV2>;
}
/**
 * @internal
 */
interface PreviouslyResolved {
    endpoint?: Provider<Endpoint>;
}
/**
 * @internal
 */
export interface EndpointRequiredResolvedConfig {
    endpoint: Provider<Endpoint>;
}
/**
 * @internal
 */
export declare const resolveEndpointRequiredConfig: <T>(input: T & EndpointRequiredInputConfig & PreviouslyResolved) => T & EndpointRequiredResolvedConfig;
export {};

```

## ./lib/lambda/node_modules/@smithy/middleware-endpoint/dist-types/service-customizations/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./s3";

```

## ./lib/lambda/node_modules/@smithy/middleware-endpoint/dist-types/service-customizations/s3.d.ts

```typescript
import type { EndpointParameters } from "@smithy/types";
/**
 * @internal
 */
export declare const resolveParamsForS3: (endpointParams: EndpointParameters) => Promise<EndpointParameters>;
/**
 * @internal
 */
export declare const DOT_PATTERN: RegExp;
/**
 * @internal
 */
export declare const S3_HOSTNAME_PATTERN: RegExp;
/**
 * Determines whether a given string is DNS compliant per the rules outlined by
 * S3. Length, capitaization, and leading dot restrictions are enforced by the
 * DOMAIN_PATTERN regular expression.
 * @internal
 *
 * @see https://docs.aws.amazon.com/AmazonS3/latest/dev/BucketRestrictions.html
 */
export declare const isDnsCompatibleBucketName: (bucketName: string) => boolean;
/**
 * @internal
 */
export declare const isArnBucketName: (bucketName: string) => boolean;

```

## ./lib/lambda/node_modules/@smithy/middleware-endpoint/dist-types/ts3.4/adaptors/createConfigValueProvider.d.ts

```typescript
/**
 * Normalize some key of the client config to an async provider.
 * @internal
 *
 * @param configKey - the key to look up in config.
 * @param canonicalEndpointParamKey - this is the name the EndpointRuleSet uses.
 *                                    it will most likely not contain the config
 *                                    value, but we use it as a fallback.
 * @param config - container of the config values.
 *
 * @returns async function that will resolve with the value.
 */
export declare const createConfigValueProvider: <Config extends Record<string, unknown>>(configKey: string, canonicalEndpointParamKey: string, config: Config) => () => Promise<any>;

```

## ./lib/lambda/node_modules/@smithy/middleware-endpoint/dist-types/ts3.4/adaptors/getEndpointFromConfig.browser.d.ts

```typescript
export declare const getEndpointFromConfig: (serviceId: string) => Promise<undefined>;

```

## ./lib/lambda/node_modules/@smithy/middleware-endpoint/dist-types/ts3.4/adaptors/getEndpointFromConfig.d.ts

```typescript
/**
 * @internal
 */
export declare const getEndpointFromConfig: (serviceId?: string) => Promise<string | undefined>;

```

## ./lib/lambda/node_modules/@smithy/middleware-endpoint/dist-types/ts3.4/adaptors/getEndpointFromInstructions.d.ts

```typescript
import { EndpointParameters, EndpointV2, HandlerExecutionContext } from "@smithy/types";
import { EndpointResolvedConfig } from "../resolveEndpointConfig";
import { EndpointParameterInstructions } from "../types";
/**
 * @internal
 */
export type EndpointParameterInstructionsSupplier = Partial<{
    getEndpointParameterInstructions(): EndpointParameterInstructions;
}>;
/**
 * This step in the endpoint resolution process is exposed as a function
 * to allow packages such as signers, lib-upload, etc. to get
 * the V2 Endpoint associated to an instance of some api operation command
 * without needing to send it or resolve its middleware stack.
 *
 * @internal
 * @param commandInput         - the input of the Command in question.
 * @param instructionsSupplier - this is typically a Command constructor. A static function supplying the
 *                               endpoint parameter instructions will exist for commands in services
 *                               having an endpoints ruleset trait.
 * @param clientConfig         - config of the service client.
 * @param context              - optional context.
 */
export declare const getEndpointFromInstructions: <T extends EndpointParameters, CommandInput extends Record<string, unknown>, Config extends Record<string, unknown>>(commandInput: CommandInput, instructionsSupplier: EndpointParameterInstructionsSupplier, clientConfig: Partial<EndpointResolvedConfig<T>> & Config, context?: HandlerExecutionContext) => Promise<EndpointV2>;
/**
 * @internal
 */
export declare const resolveParams: <T extends EndpointParameters, CommandInput extends Record<string, unknown>, Config extends Record<string, unknown>>(commandInput: CommandInput, instructionsSupplier: EndpointParameterInstructionsSupplier, clientConfig: Partial<EndpointResolvedConfig<T>> & Config) => Promise<EndpointParameters>;

```

## ./lib/lambda/node_modules/@smithy/middleware-endpoint/dist-types/ts3.4/adaptors/getEndpointUrlConfig.d.ts

```typescript
import { LoadedConfigSelectors } from "@smithy/node-config-provider";
export declare const getEndpointUrlConfig: (serviceId: string) => LoadedConfigSelectors<string | undefined>;

```

## ./lib/lambda/node_modules/@smithy/middleware-endpoint/dist-types/ts3.4/adaptors/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./getEndpointFromInstructions";
/**
 * @internal
 */
export * from "./toEndpointV1";

```

## ./lib/lambda/node_modules/@smithy/middleware-endpoint/dist-types/ts3.4/adaptors/toEndpointV1.d.ts

```typescript
import { Endpoint, EndpointV2 } from "@smithy/types";
/**
 * @internal
 */
export declare const toEndpointV1: (endpoint: string | Endpoint | EndpointV2) => Endpoint;

```

## ./lib/lambda/node_modules/@smithy/middleware-endpoint/dist-types/ts3.4/endpointMiddleware.d.ts

```typescript
import { EndpointParameters, SerializeMiddleware } from "@smithy/types";
import { EndpointResolvedConfig } from "./resolveEndpointConfig";
import { EndpointParameterInstructions } from "./types";
/**
 * @internal
 */
export declare const endpointMiddleware: <T extends EndpointParameters>({ config, instructions, }: {
    config: EndpointResolvedConfig<T>;
    instructions: EndpointParameterInstructions;
}) => SerializeMiddleware<any, any>;

```

## ./lib/lambda/node_modules/@smithy/middleware-endpoint/dist-types/ts3.4/getEndpointPlugin.d.ts

```typescript
import { EndpointParameters, Pluggable, RelativeMiddlewareOptions, SerializeHandlerOptions } from "@smithy/types";
import { EndpointResolvedConfig } from "./resolveEndpointConfig";
import { EndpointParameterInstructions } from "./types";
/**
 * @internal
 */
export declare const endpointMiddlewareOptions: SerializeHandlerOptions & RelativeMiddlewareOptions;
/**
 * @internal
 */
export declare const getEndpointPlugin: <T extends EndpointParameters>(config: EndpointResolvedConfig<T>, instructions: EndpointParameterInstructions) => Pluggable<any, any>;

```

## ./lib/lambda/node_modules/@smithy/middleware-endpoint/dist-types/ts3.4/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./adaptors";
/**
 * @internal
 */
export * from "./endpointMiddleware";
/**
 * @internal
 */
export * from "./getEndpointPlugin";
export * from "./resolveEndpointConfig";
export * from "./resolveEndpointRequiredConfig";
/**
 * @internal
 */
export * from "./types";

```

## ./lib/lambda/node_modules/@smithy/middleware-endpoint/dist-types/ts3.4/resolveEndpointConfig.d.ts

```typescript
import { Endpoint, EndpointParameters, EndpointV2, Logger, Provider, UrlParser } from "@smithy/types";
/**
 * @public
 *
 * Endpoint config interfaces and resolver for Endpoint v2. They live in separate package to allow per-service onboarding.
 * When all services onboard Endpoint v2, the resolver in config-resolver package can be removed.
 * This interface includes all the endpoint parameters with built-in bindings of "AWS::*" and "SDK::*"
 */
export interface EndpointInputConfig<T extends EndpointParameters = EndpointParameters> {
    /**
     * The fully qualified endpoint of the webservice. This is only for using
     * a custom endpoint (for example, when using a local version of S3).
     *
     * Endpoint transformations such as S3 applying a bucket to the hostname are
     * still applicable to this custom endpoint.
     */
    endpoint?: string | Endpoint | Provider<Endpoint> | EndpointV2 | Provider<EndpointV2>;
    /**
     * Providing a custom endpointProvider will override
     * built-in transformations of the endpoint such as S3 adding the bucket
     * name to the hostname, since they are part of the default endpointProvider.
     */
    endpointProvider?: (params: T, context?: {
        logger?: Logger;
    }) => EndpointV2;
    /**
     * Whether TLS is enabled for requests.
     * @deprecated
     */
    tls?: boolean;
    /**
     * Enables IPv6/IPv4 dualstack endpoint.
     */
    useDualstackEndpoint?: boolean | Provider<boolean>;
    /**
     * Enables FIPS compatible endpoints.
     */
    useFipsEndpoint?: boolean | Provider<boolean>;
    /**
     * @internal
     * This field is used internally so you should not fill any value to this field.
     */
    serviceConfiguredEndpoint?: never;
}
/**
 * @internal
 */
interface PreviouslyResolved<T extends EndpointParameters = EndpointParameters> {
    urlParser: UrlParser;
    endpointProvider: (params: T, context?: {
        logger?: Logger;
    }) => EndpointV2;
    logger?: Logger;
    serviceId?: string;
}
/**
 * @internal
 *
 * This supersedes the similarly named EndpointsResolvedConfig (no parametric types)
 * from resolveEndpointsConfig.ts in \@smithy/config-resolver.
 */
export interface EndpointResolvedConfig<T extends EndpointParameters = EndpointParameters> {
    /**
     * Custom endpoint provided by the user.
     * This is normalized to a single interface from the various acceptable types.
     * This field will be undefined if a custom endpoint is not provided.
     */
    endpoint?: Provider<Endpoint>;
    endpointProvider: (params: T, context?: {
        logger?: Logger;
    }) => EndpointV2;
    /**
     * Whether TLS is enabled for requests.
     * @deprecated
     */
    tls: boolean;
    /**
     * Whether the endpoint is specified by caller.
     * This should be used over checking the existence of `endpoint`, since
     * that may have been set by other means, such as the default regional
     * endpoint provider function.
     *
     * @internal
     */
    isCustomEndpoint?: boolean;
    /**
     * Resolved value for input {@link EndpointsInputConfig.useDualstackEndpoint}
     */
    useDualstackEndpoint: Provider<boolean>;
    /**
     * Resolved value for input {@link EndpointsInputConfig.useFipsEndpoint}
     */
    useFipsEndpoint: Provider<boolean>;
    /**
     * Unique service identifier.
     * @internal
     */
    serviceId?: string;
    /**
     * A configured endpoint global or specific to the service from ENV or AWS SDK configuration files.
     * @internal
     */
    serviceConfiguredEndpoint?: Provider<string | undefined>;
}
/**
 * @internal
 */
export declare const resolveEndpointConfig: <T, P extends EndpointParameters = EndpointParameters>(input: T & EndpointInputConfig<P> & PreviouslyResolved<P>) => T & EndpointResolvedConfig<P>;
export {};

```

## ./lib/lambda/node_modules/@smithy/middleware-endpoint/dist-types/ts3.4/resolveEndpointRequiredConfig.d.ts

```typescript
import { Endpoint, EndpointV2, Provider } from "@smithy/types";
/**
 * This is an additional config resolver layer for clients using the default
 * endpoints ruleset. It modifies the input and output config types to make
 * the endpoint configuration property required.
 *
 * It must be placed after the `resolveEndpointConfig`
 * resolver. This replaces the "CustomEndpoints" config resolver, which was used
 * prior to default endpoint rulesets.
 *
 * @public
 */
export interface EndpointRequiredInputConfig {
    endpoint: string | Endpoint | Provider<Endpoint> | EndpointV2 | Provider<EndpointV2>;
}
/**
 * @internal
 */
interface PreviouslyResolved {
    endpoint?: Provider<Endpoint>;
}
/**
 * @internal
 */
export interface EndpointRequiredResolvedConfig {
    endpoint: Provider<Endpoint>;
}
/**
 * @internal
 */
export declare const resolveEndpointRequiredConfig: <T>(input: T & EndpointRequiredInputConfig & PreviouslyResolved) => T & EndpointRequiredResolvedConfig;
export {};

```

## ./lib/lambda/node_modules/@smithy/middleware-endpoint/dist-types/ts3.4/service-customizations/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./s3";

```

## ./lib/lambda/node_modules/@smithy/middleware-endpoint/dist-types/ts3.4/service-customizations/s3.d.ts

```typescript
import { EndpointParameters } from "@smithy/types";
/**
 * @internal
 */
export declare const resolveParamsForS3: (endpointParams: EndpointParameters) => Promise<EndpointParameters>;
/**
 * @internal
 */
export declare const DOT_PATTERN: RegExp;
/**
 * @internal
 */
export declare const S3_HOSTNAME_PATTERN: RegExp;
/**
 * Determines whether a given string is DNS compliant per the rules outlined by
 * S3. Length, capitaization, and leading dot restrictions are enforced by the
 * DOMAIN_PATTERN regular expression.
 * @internal
 *
 * @see https://docs.aws.amazon.com/AmazonS3/latest/dev/BucketRestrictions.html
 */
export declare const isDnsCompatibleBucketName: (bucketName: string) => boolean;
/**
 * @internal
 */
export declare const isArnBucketName: (bucketName: string) => boolean;

```

## ./lib/lambda/node_modules/@smithy/middleware-endpoint/dist-types/ts3.4/types.d.ts

```typescript
/**
 * @internal
 */
export interface EndpointParameterInstructions {
    [name: string]: BuiltInParamInstruction | ClientContextParamInstruction | StaticContextParamInstruction | ContextParamInstruction | OperationContextParamInstruction;
}
/**
 * @internal
 */
export interface BuiltInParamInstruction {
    type: "builtInParams";
    name: string;
}
/**
 * @internal
 */
export interface ClientContextParamInstruction {
    type: "clientContextParams";
    name: string;
}
/**
 * @internal
 */
export interface StaticContextParamInstruction {
    type: "staticContextParams";
    value: string | boolean;
}
/**
 * @internal
 */
export interface ContextParamInstruction {
    type: "contextParams";
    name: string;
}
/**
 * @internal
 */
export interface OperationContextParamInstruction {
    type: "operationContextParams";
    get(input: any): any;
}

```

## ./lib/lambda/node_modules/@smithy/middleware-endpoint/dist-types/types.d.ts

```typescript
/**
 * @internal
 */
export interface EndpointParameterInstructions {
    [name: string]: BuiltInParamInstruction | ClientContextParamInstruction | StaticContextParamInstruction | ContextParamInstruction | OperationContextParamInstruction;
}
/**
 * @internal
 */
export interface BuiltInParamInstruction {
    type: "builtInParams";
    name: string;
}
/**
 * @internal
 */
export interface ClientContextParamInstruction {
    type: "clientContextParams";
    name: string;
}
/**
 * @internal
 */
export interface StaticContextParamInstruction {
    type: "staticContextParams";
    value: string | boolean;
}
/**
 * @internal
 */
export interface ContextParamInstruction {
    type: "contextParams";
    name: string;
}
/**
 * @internal
 */
export interface OperationContextParamInstruction {
    type: "operationContextParams";
    get(input: any): any;
}

```

## ./lib/lambda/node_modules/@smithy/middleware-endpoint/package.json

```json
{
  "name": "@smithy/middleware-endpoint",
  "version": "4.3.4",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline middleware-endpoint",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "rimraf dist-types/ts3.4 && downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../../.prettierignore --write \"**/*.{ts,md,json}\"",
    "test": "yarn g:vitest run",
    "extract:docs": "api-extractor run --local",
    "test:watch": "yarn g:vitest watch"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "sideEffects": false,
  "dependencies": {
    "@smithy/core": "^3.17.0",
    "@smithy/middleware-serde": "^4.2.3",
    "@smithy/node-config-provider": "^4.3.3",
    "@smithy/shared-ini-file-loader": "^4.3.3",
    "@smithy/types": "^4.8.0",
    "@smithy/url-parser": "^4.2.3",
    "@smithy/util-middleware": "^4.2.3",
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "browser": {
    "./dist-es/adaptors/getEndpointFromConfig": "./dist-es/adaptors/getEndpointFromConfig.browser"
  },
  "react-native": {
    "./dist-es/adaptors/getEndpointFromConfig": "./dist-es/adaptors/getEndpointFromConfig.browser",
    "./dist-cjs/adaptors/getEndpointFromConfig": "./dist-cjs/adaptors/getEndpointFromConfig.browser"
  },
  "homepage": "https://github.com/smithy-lang/smithy-typescript/tree/main/packages/middleware-endpoint",
  "repository": {
    "type": "git",
    "url": "https://github.com/smithy-lang/smithy-typescript.git",
    "directory": "packages/middleware-endpoint"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  }
}
```

## ./lib/lambda/node_modules/@smithy/middleware-retry/dist-types/AdaptiveRetryStrategy.d.ts

```typescript
import type { FinalizeHandler, FinalizeHandlerArguments, MetadataBearer, Provider } from "@smithy/types";
import type { RateLimiter } from "@smithy/util-retry";
import type { StandardRetryStrategyOptions } from "./StandardRetryStrategy";
import { StandardRetryStrategy } from "./StandardRetryStrategy";
/**
 * @public
 * Strategy options to be passed to AdaptiveRetryStrategy
 */
export interface AdaptiveRetryStrategyOptions extends StandardRetryStrategyOptions {
    rateLimiter?: RateLimiter;
}
/**
 * @public
 * @deprecated use AdaptiveRetryStrategy from @smithy/util-retry
 */
export declare class AdaptiveRetryStrategy extends StandardRetryStrategy {
    private rateLimiter;
    constructor(maxAttemptsProvider: Provider<number>, options?: AdaptiveRetryStrategyOptions);
    retry<Input extends object, Ouput extends MetadataBearer>(next: FinalizeHandler<Input, Ouput>, args: FinalizeHandlerArguments<Input>): Promise<{
        response: unknown;
        output: Ouput;
    }>;
}

```

## ./lib/lambda/node_modules/@smithy/middleware-retry/dist-types/StandardRetryStrategy.d.ts

```typescript
import type { FinalizeHandler, FinalizeHandlerArguments, MetadataBearer, Provider, RetryStrategy } from "@smithy/types";
import type { DelayDecider, RetryDecider, RetryQuota } from "./types";
/**
 * Strategy options to be passed to StandardRetryStrategy
 * @public
 * @deprecated use StandardRetryStrategy from @smithy/util-retry
 */
export interface StandardRetryStrategyOptions {
    retryDecider?: RetryDecider;
    delayDecider?: DelayDecider;
    retryQuota?: RetryQuota;
}
/**
 * @public
 * @deprecated use StandardRetryStrategy from @smithy/util-retry
 */
export declare class StandardRetryStrategy implements RetryStrategy {
    private readonly maxAttemptsProvider;
    private retryDecider;
    private delayDecider;
    private retryQuota;
    mode: string;
    constructor(maxAttemptsProvider: Provider<number>, options?: StandardRetryStrategyOptions);
    private shouldRetry;
    private getMaxAttempts;
    retry<Input extends object, Ouput extends MetadataBearer>(next: FinalizeHandler<Input, Ouput>, args: FinalizeHandlerArguments<Input>, options?: {
        beforeRequest: Function;
        afterRequest: Function;
    }): Promise<{
        response: unknown;
        output: Ouput;
    }>;
}

```

## ./lib/lambda/node_modules/@smithy/middleware-retry/dist-types/configurations.d.ts

```typescript
import type { LoadedConfigSelectors } from "@smithy/node-config-provider";
import type { Provider, RetryStrategy, RetryStrategyV2 } from "@smithy/types";
/**
 * @internal
 */
export declare const ENV_MAX_ATTEMPTS = "AWS_MAX_ATTEMPTS";
/**
 * @internal
 */
export declare const CONFIG_MAX_ATTEMPTS = "max_attempts";
/**
 * @internal
 */
export declare const NODE_MAX_ATTEMPT_CONFIG_OPTIONS: LoadedConfigSelectors<number>;
/**
 * @public
 */
export interface RetryInputConfig {
    /**
     * The maximum number of times requests that encounter retryable failures should be attempted.
     */
    maxAttempts?: number | Provider<number>;
    /**
     * The strategy to retry the request. Using built-in exponential backoff strategy by default.
     */
    retryStrategy?: RetryStrategy | RetryStrategyV2;
}
/**
 * @internal
 */
export interface PreviouslyResolved {
    /**
     * Specifies provider for retry algorithm to use.
     * @internal
     */
    retryMode: string | Provider<string>;
}
/**
 * @internal
 */
export interface RetryResolvedConfig {
    /**
     * Resolved value for input config {@link RetryInputConfig.maxAttempts}
     */
    maxAttempts: Provider<number>;
    /**
     * Resolved value for input config {@link RetryInputConfig.retryStrategy}
     */
    retryStrategy: Provider<RetryStrategyV2 | RetryStrategy>;
}
/**
 * @internal
 */
export declare const resolveRetryConfig: <T>(input: T & PreviouslyResolved & RetryInputConfig) => T & RetryResolvedConfig;
/**
 * @internal
 */
export declare const ENV_RETRY_MODE = "AWS_RETRY_MODE";
/**
 * @internal
 */
export declare const CONFIG_RETRY_MODE = "retry_mode";
/**
 * @internal
 */
export declare const NODE_RETRY_MODE_CONFIG_OPTIONS: LoadedConfigSelectors<string>;

```

## ./lib/lambda/node_modules/@smithy/middleware-retry/dist-types/defaultRetryQuota.d.ts

```typescript
import type { RetryQuota } from "./types";
/**
 * @internal
 */
export interface DefaultRetryQuotaOptions {
    /**
     * The total amount of retry token to be incremented from retry token balance
     * if an SDK operation invocation succeeds without requiring a retry request.
     */
    noRetryIncrement?: number;
    /**
     * The total amount of retry tokens to be decremented from retry token balance.
     */
    retryCost?: number;
    /**
     * The total amount of retry tokens to be decremented from retry token balance
     * when a throttling error is encountered.
     */
    timeoutRetryCost?: number;
}
/**
 * @internal
 */
export declare const getDefaultRetryQuota: (initialRetryTokens: number, options?: DefaultRetryQuotaOptions) => RetryQuota;

```

## ./lib/lambda/node_modules/@smithy/middleware-retry/dist-types/delayDecider.d.ts

```typescript
/**
 * @internal
 * Calculate a capped, fully-jittered exponential backoff time.
 */
export declare const defaultDelayDecider: (delayBase: number, attempts: number) => number;

```

## ./lib/lambda/node_modules/@smithy/middleware-retry/dist-types/index.d.ts

```typescript
export * from "./AdaptiveRetryStrategy";
export * from "./StandardRetryStrategy";
export * from "./configurations";
export * from "./delayDecider";
export * from "./omitRetryHeadersMiddleware";
export * from "./retryDecider";
export * from "./retryMiddleware";

```

## ./lib/lambda/node_modules/@smithy/middleware-retry/dist-types/isStreamingPayload/isStreamingPayload.browser.d.ts

```typescript
import type { HttpRequest } from "@smithy/protocol-http";
/**
 * @internal
 */
export declare const isStreamingPayload: (request: HttpRequest) => boolean;

```

## ./lib/lambda/node_modules/@smithy/middleware-retry/dist-types/isStreamingPayload/isStreamingPayload.d.ts

```typescript
import type { HttpRequest } from "@smithy/protocol-http";
/**
 * @internal
 */
export declare const isStreamingPayload: (request: HttpRequest) => boolean;

```

## ./lib/lambda/node_modules/@smithy/middleware-retry/dist-types/omitRetryHeadersMiddleware.d.ts

```typescript
import type { FinalizeHandler, MetadataBearer, Pluggable, RelativeMiddlewareOptions } from "@smithy/types";
/**
 * @internal
 */
export declare const omitRetryHeadersMiddleware: () => <Output extends MetadataBearer = MetadataBearer>(next: FinalizeHandler<any, Output>) => FinalizeHandler<any, Output>;
/**
 * @internal
 */
export declare const omitRetryHeadersMiddlewareOptions: RelativeMiddlewareOptions;
/**
 * @internal
 */
export declare const getOmitRetryHeadersPlugin: (options: unknown) => Pluggable<any, any>;

```

## ./lib/lambda/node_modules/@smithy/middleware-retry/dist-types/retryDecider.d.ts

```typescript
import type { SdkError } from "@smithy/types";
/**
 * @internal
 * @deprecated this is only used in the deprecated StandardRetryStrategy. Do not use in new code.
 */
export declare const defaultRetryDecider: (error: SdkError) => boolean;

```

## ./lib/lambda/node_modules/@smithy/middleware-retry/dist-types/retryMiddleware.d.ts

```typescript
import type { AbsoluteLocation, FinalizeHandler, FinalizeRequestHandlerOptions, HandlerExecutionContext, MetadataBearer, Pluggable } from "@smithy/types";
import type { RetryResolvedConfig } from "./configurations";
/**
 * @internal
 */
export declare const retryMiddleware: (options: RetryResolvedConfig) => <Output extends MetadataBearer = MetadataBearer>(next: FinalizeHandler<any, Output>, context: HandlerExecutionContext) => FinalizeHandler<any, Output>;
/**
 * @internal
 */
export declare const retryMiddlewareOptions: FinalizeRequestHandlerOptions & AbsoluteLocation;
/**
 * @internal
 */
export declare const getRetryPlugin: (options: RetryResolvedConfig) => Pluggable<any, any>;
/**
 * @internal
 */
export declare const getRetryAfterHint: (response: unknown) => Date | undefined;

```

## ./lib/lambda/node_modules/@smithy/middleware-retry/dist-types/ts3.4/AdaptiveRetryStrategy.d.ts

```typescript
import { FinalizeHandler, FinalizeHandlerArguments, MetadataBearer, Provider } from "@smithy/types";
import { RateLimiter } from "@smithy/util-retry";
import { StandardRetryStrategyOptions } from "./StandardRetryStrategy";
import { StandardRetryStrategy } from "./StandardRetryStrategy";
/**
 * @public
 * Strategy options to be passed to AdaptiveRetryStrategy
 */
export interface AdaptiveRetryStrategyOptions extends StandardRetryStrategyOptions {
    rateLimiter?: RateLimiter;
}
/**
 * @public
 * @deprecated use AdaptiveRetryStrategy from @smithy/util-retry
 */
export declare class AdaptiveRetryStrategy extends StandardRetryStrategy {
    private rateLimiter;
    constructor(maxAttemptsProvider: Provider<number>, options?: AdaptiveRetryStrategyOptions);
    retry<Input extends object, Ouput extends MetadataBearer>(next: FinalizeHandler<Input, Ouput>, args: FinalizeHandlerArguments<Input>): Promise<{
        response: unknown;
        output: Ouput;
    }>;
}

```

## ./lib/lambda/node_modules/@smithy/middleware-retry/dist-types/ts3.4/StandardRetryStrategy.d.ts

```typescript
import { FinalizeHandler, FinalizeHandlerArguments, MetadataBearer, Provider, RetryStrategy } from "@smithy/types";
import { DelayDecider, RetryDecider, RetryQuota } from "./types";
/**
 * Strategy options to be passed to StandardRetryStrategy
 * @public
 * @deprecated use StandardRetryStrategy from @smithy/util-retry
 */
export interface StandardRetryStrategyOptions {
    retryDecider?: RetryDecider;
    delayDecider?: DelayDecider;
    retryQuota?: RetryQuota;
}
/**
 * @public
 * @deprecated use StandardRetryStrategy from @smithy/util-retry
 */
export declare class StandardRetryStrategy implements RetryStrategy {
    private readonly maxAttemptsProvider;
    private retryDecider;
    private delayDecider;
    private retryQuota;
    mode: string;
    constructor(maxAttemptsProvider: Provider<number>, options?: StandardRetryStrategyOptions);
    private shouldRetry;
    private getMaxAttempts;
    retry<Input extends object, Ouput extends MetadataBearer>(next: FinalizeHandler<Input, Ouput>, args: FinalizeHandlerArguments<Input>, options?: {
        beforeRequest: Function;
        afterRequest: Function;
    }): Promise<{
        response: unknown;
        output: Ouput;
    }>;
}

```

## ./lib/lambda/node_modules/@smithy/middleware-retry/dist-types/ts3.4/configurations.d.ts

```typescript
import { LoadedConfigSelectors } from "@smithy/node-config-provider";
import { Provider, RetryStrategy, RetryStrategyV2 } from "@smithy/types";
/**
 * @internal
 */
export declare const ENV_MAX_ATTEMPTS = "AWS_MAX_ATTEMPTS";
/**
 * @internal
 */
export declare const CONFIG_MAX_ATTEMPTS = "max_attempts";
/**
 * @internal
 */
export declare const NODE_MAX_ATTEMPT_CONFIG_OPTIONS: LoadedConfigSelectors<number>;
/**
 * @public
 */
export interface RetryInputConfig {
    /**
     * The maximum number of times requests that encounter retryable failures should be attempted.
     */
    maxAttempts?: number | Provider<number>;
    /**
     * The strategy to retry the request. Using built-in exponential backoff strategy by default.
     */
    retryStrategy?: RetryStrategy | RetryStrategyV2;
}
/**
 * @internal
 */
export interface PreviouslyResolved {
    /**
     * Specifies provider for retry algorithm to use.
     * @internal
     */
    retryMode: string | Provider<string>;
}
/**
 * @internal
 */
export interface RetryResolvedConfig {
    /**
     * Resolved value for input config {@link RetryInputConfig.maxAttempts}
     */
    maxAttempts: Provider<number>;
    /**
     * Resolved value for input config {@link RetryInputConfig.retryStrategy}
     */
    retryStrategy: Provider<RetryStrategyV2 | RetryStrategy>;
}
/**
 * @internal
 */
export declare const resolveRetryConfig: <T>(input: T & PreviouslyResolved & RetryInputConfig) => T & RetryResolvedConfig;
/**
 * @internal
 */
export declare const ENV_RETRY_MODE = "AWS_RETRY_MODE";
/**
 * @internal
 */
export declare const CONFIG_RETRY_MODE = "retry_mode";
/**
 * @internal
 */
export declare const NODE_RETRY_MODE_CONFIG_OPTIONS: LoadedConfigSelectors<string>;

```

## ./lib/lambda/node_modules/@smithy/middleware-retry/dist-types/ts3.4/defaultRetryQuota.d.ts

```typescript
import { RetryQuota } from "./types";
/**
 * @internal
 */
export interface DefaultRetryQuotaOptions {
    /**
     * The total amount of retry token to be incremented from retry token balance
     * if an SDK operation invocation succeeds without requiring a retry request.
     */
    noRetryIncrement?: number;
    /**
     * The total amount of retry tokens to be decremented from retry token balance.
     */
    retryCost?: number;
    /**
     * The total amount of retry tokens to be decremented from retry token balance
     * when a throttling error is encountered.
     */
    timeoutRetryCost?: number;
}
/**
 * @internal
 */
export declare const getDefaultRetryQuota: (initialRetryTokens: number, options?: DefaultRetryQuotaOptions) => RetryQuota;

```

## ./lib/lambda/node_modules/@smithy/middleware-retry/dist-types/ts3.4/delayDecider.d.ts

```typescript
/**
 * @internal
 * Calculate a capped, fully-jittered exponential backoff time.
 */
export declare const defaultDelayDecider: (delayBase: number, attempts: number) => number;

```

## ./lib/lambda/node_modules/@smithy/middleware-retry/dist-types/ts3.4/index.d.ts

```typescript
export * from "./AdaptiveRetryStrategy";
export * from "./StandardRetryStrategy";
export * from "./configurations";
export * from "./delayDecider";
export * from "./omitRetryHeadersMiddleware";
export * from "./retryDecider";
export * from "./retryMiddleware";

```

## ./lib/lambda/node_modules/@smithy/middleware-retry/dist-types/ts3.4/isStreamingPayload/isStreamingPayload.browser.d.ts

```typescript
import { HttpRequest } from "@smithy/protocol-http";
/**
 * @internal
 */
export declare const isStreamingPayload: (request: HttpRequest) => boolean;

```

## ./lib/lambda/node_modules/@smithy/middleware-retry/dist-types/ts3.4/isStreamingPayload/isStreamingPayload.d.ts

```typescript
import { HttpRequest } from "@smithy/protocol-http";
/**
 * @internal
 */
export declare const isStreamingPayload: (request: HttpRequest) => boolean;

```

## ./lib/lambda/node_modules/@smithy/middleware-retry/dist-types/ts3.4/omitRetryHeadersMiddleware.d.ts

```typescript
import { FinalizeHandler, MetadataBearer, Pluggable, RelativeMiddlewareOptions } from "@smithy/types";
/**
 * @internal
 */
export declare const omitRetryHeadersMiddleware: () => <Output extends MetadataBearer = MetadataBearer>(next: FinalizeHandler<any, Output>) => FinalizeHandler<any, Output>;
/**
 * @internal
 */
export declare const omitRetryHeadersMiddlewareOptions: RelativeMiddlewareOptions;
/**
 * @internal
 */
export declare const getOmitRetryHeadersPlugin: (options: unknown) => Pluggable<any, any>;

```

## ./lib/lambda/node_modules/@smithy/middleware-retry/dist-types/ts3.4/retryDecider.d.ts

```typescript
import { SdkError } from "@smithy/types";
/**
 * @internal
 * @deprecated this is only used in the deprecated StandardRetryStrategy. Do not use in new code.
 */
export declare const defaultRetryDecider: (error: SdkError) => boolean;

```

## ./lib/lambda/node_modules/@smithy/middleware-retry/dist-types/ts3.4/retryMiddleware.d.ts

```typescript
import { AbsoluteLocation, FinalizeHandler, FinalizeRequestHandlerOptions, HandlerExecutionContext, MetadataBearer, Pluggable } from "@smithy/types";
import { RetryResolvedConfig } from "./configurations";
/**
 * @internal
 */
export declare const retryMiddleware: (options: RetryResolvedConfig) => <Output extends MetadataBearer = MetadataBearer>(next: FinalizeHandler<any, Output>, context: HandlerExecutionContext) => FinalizeHandler<any, Output>;
/**
 * @internal
 */
export declare const retryMiddlewareOptions: FinalizeRequestHandlerOptions & AbsoluteLocation;
/**
 * @internal
 */
export declare const getRetryPlugin: (options: RetryResolvedConfig) => Pluggable<any, any>;
/**
 * @internal
 */
export declare const getRetryAfterHint: (response: unknown) => Date | undefined;

```

## ./lib/lambda/node_modules/@smithy/middleware-retry/dist-types/ts3.4/types.d.ts

```typescript
import { SdkError } from "@smithy/types";
/**
 * Determines whether an error is retryable based on the number of retries
 * already attempted, the HTTP status code, and the error received (if any).
 *
 * @param error - The error encountered.
 *
 * @deprecated
 * @internal
 */
export interface RetryDecider {
    (error: SdkError): boolean;
}
/**
 * Determines the number of milliseconds to wait before retrying an action.
 *
 * @param delayBase - The base delay (in milliseconds).
 * @param attempts - The number of times the action has already been tried.
 *
 * @deprecated
 * @internal
 */
export interface DelayDecider {
    (delayBase: number, attempts: number): number;
}
/**
 * Interface that specifies the retry quota behavior.
 * @deprecated
 * @internal
 */
export interface RetryQuota {
    /**
     * returns true if retry tokens are available from the retry quota bucket.
     */
    hasRetryTokens: (error: SdkError) => boolean;
    /**
     * returns token amount from the retry quota bucket.
     * throws error is retry tokens are not available.
     */
    retrieveRetryTokens: (error: SdkError) => number;
    /**
     * releases tokens back to the retry quota.
     */
    releaseRetryTokens: (releaseCapacityAmount?: number) => void;
}
/**
 * @deprecated
 * @internal
 */
export interface RateLimiter {
    /**
     * If there is sufficient capacity (tokens) available, it immediately returns.
     * If there is not sufficient capacity, it will either sleep a certain amount
     * of time until the rate limiter can retrieve a token from its token bucket
     * or raise an exception indicating there is insufficient capacity.
     */
    getSendToken: () => Promise<void>;
    /**
     * Updates the client sending rate based on response.
     * If the response was successful, the capacity and fill rate are increased.
     * If the response was a throttling response, the capacity and fill rate are
     * decreased. Transient errors do not affect the rate limiter.
     */
    updateClientSendingRate: (response: any) => void;
}

```

## ./lib/lambda/node_modules/@smithy/middleware-retry/dist-types/ts3.4/util.d.ts

```typescript
import { SdkError } from "@smithy/types";
export declare const asSdkError: (error: unknown) => SdkError;

```

## ./lib/lambda/node_modules/@smithy/middleware-retry/dist-types/types.d.ts

```typescript
import type { SdkError } from "@smithy/types";
/**
 * Determines whether an error is retryable based on the number of retries
 * already attempted, the HTTP status code, and the error received (if any).
 *
 * @param error - The error encountered.
 *
 * @deprecated
 * @internal
 */
export interface RetryDecider {
    (error: SdkError): boolean;
}
/**
 * Determines the number of milliseconds to wait before retrying an action.
 *
 * @param delayBase - The base delay (in milliseconds).
 * @param attempts - The number of times the action has already been tried.
 *
 * @deprecated
 * @internal
 */
export interface DelayDecider {
    (delayBase: number, attempts: number): number;
}
/**
 * Interface that specifies the retry quota behavior.
 * @deprecated
 * @internal
 */
export interface RetryQuota {
    /**
     * returns true if retry tokens are available from the retry quota bucket.
     */
    hasRetryTokens: (error: SdkError) => boolean;
    /**
     * returns token amount from the retry quota bucket.
     * throws error is retry tokens are not available.
     */
    retrieveRetryTokens: (error: SdkError) => number;
    /**
     * releases tokens back to the retry quota.
     */
    releaseRetryTokens: (releaseCapacityAmount?: number) => void;
}
/**
 * @deprecated
 * @internal
 */
export interface RateLimiter {
    /**
     * If there is sufficient capacity (tokens) available, it immediately returns.
     * If there is not sufficient capacity, it will either sleep a certain amount
     * of time until the rate limiter can retrieve a token from its token bucket
     * or raise an exception indicating there is insufficient capacity.
     */
    getSendToken: () => Promise<void>;
    /**
     * Updates the client sending rate based on response.
     * If the response was successful, the capacity and fill rate are increased.
     * If the response was a throttling response, the capacity and fill rate are
     * decreased. Transient errors do not affect the rate limiter.
     */
    updateClientSendingRate: (response: any) => void;
}

```

## ./lib/lambda/node_modules/@smithy/middleware-retry/dist-types/util.d.ts

```typescript
import type { SdkError } from "@smithy/types";
export declare const asSdkError: (error: unknown) => SdkError;

```

## ./lib/lambda/node_modules/@smithy/middleware-retry/package.json

```json
{
  "name": "@smithy/middleware-retry",
  "version": "4.4.4",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline middleware-retry",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "rimraf dist-types/ts3.4 && downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../../.prettierignore --write \"**/*.{ts,md,json}\"",
    "extract:docs": "api-extractor run --local",
    "test": "yarn g:vitest run",
    "test:integration": "yarn g:vitest run -c vitest.config.integ.mts",
    "test:watch": "yarn g:vitest watch",
    "test:integration:watch": "yarn g:vitest watch -c vitest.config.integ.mts"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "browser": {
    "./dist-es/isStreamingPayload/isStreamingPayload": "./dist-es/isStreamingPayload/isStreamingPayload.browser"
  },
  "react-native": {
    "./dist-cjs/isStreamingPayload/isStreamingPayload": "./dist-cjs/isStreamingPayload/isStreamingPayload.browser",
    "./dist-es/isStreamingPayload/isStreamingPayload": "./dist-es/isStreamingPayload/isStreamingPayload.browser"
  },
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "sideEffects": false,
  "dependencies": {
    "@smithy/node-config-provider": "^4.3.3",
    "@smithy/protocol-http": "^5.3.3",
    "@smithy/service-error-classification": "^4.2.3",
    "@smithy/smithy-client": "^4.9.0",
    "@smithy/types": "^4.8.0",
    "@smithy/util-middleware": "^4.2.3",
    "@smithy/util-retry": "^4.2.3",
    "@smithy/uuid": "^1.1.0",
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "@smithy/util-test": "^0.2.8",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/smithy-lang/smithy-typescript/tree/main/packages/middleware-retry",
  "repository": {
    "type": "git",
    "url": "https://github.com/smithy-lang/smithy-typescript.git",
    "directory": "packages/middleware-retry"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  }
}
```

## ./lib/lambda/node_modules/@smithy/middleware-serde/dist-types/deserializerMiddleware.d.ts

```typescript
import type { DeserializeMiddleware, ResponseDeserializer, SerdeContext, SerdeFunctions } from "@smithy/types";
/**
 * @internal
 * @deprecated will be replaced by schemaSerdePlugin from core/schema.
 */
export declare const deserializerMiddleware: <Input extends object = any, Output extends object = any, CommandSerdeContext extends SerdeContext = any>(options: SerdeFunctions, deserializer: ResponseDeserializer<any, any, CommandSerdeContext>) => DeserializeMiddleware<Input, Output>;

```

## ./lib/lambda/node_modules/@smithy/middleware-serde/dist-types/index.d.ts

```typescript
export * from "./deserializerMiddleware";
export * from "./serdePlugin";
export * from "./serializerMiddleware";

```

## ./lib/lambda/node_modules/@smithy/middleware-serde/dist-types/serdePlugin.d.ts

```typescript
import type { DeserializeHandlerOptions, Endpoint, MetadataBearer, Pluggable, Provider, RequestSerializer, ResponseDeserializer, SerdeContext, SerdeFunctions, SerializeHandlerOptions, UrlParser } from "@smithy/types";
/**
 * @deprecated will be replaced by schemaSerdePlugin from core/schema.
 */
export declare const deserializerMiddlewareOption: DeserializeHandlerOptions;
/**
 * @deprecated will be replaced by schemaSerdePlugin from core/schema.
 */
export declare const serializerMiddlewareOption: SerializeHandlerOptions;
/**
 * Modifies the EndpointBearer to make it compatible with Endpoints 2.0 change.
 *
 * @internal
 * @deprecated
 */
export type V1OrV2Endpoint = {
    urlParser?: UrlParser;
    endpoint?: Provider<Endpoint>;
};
/**
 * @internal
 * @deprecated will be replaced by schemaSerdePlugin from core/schema.
 */
export declare function getSerdePlugin<InputType extends object = any, CommandSerdeContext extends SerdeContext = any, OutputType extends MetadataBearer = any>(config: SerdeFunctions, serializer: RequestSerializer<any, CommandSerdeContext>, deserializer: ResponseDeserializer<OutputType, any, CommandSerdeContext>): Pluggable<InputType, OutputType>;

```

## ./lib/lambda/node_modules/@smithy/middleware-serde/dist-types/serializerMiddleware.d.ts

```typescript
import type { RequestSerializer, SerdeContext, SerdeFunctions, SerializeMiddleware } from "@smithy/types";
/**
 * @internal
 * @deprecated will be replaced by schemaSerdePlugin from core/schema.
 */
export declare const serializerMiddleware: <Input extends object = any, Output extends object = any, CommandSerdeContext extends SerdeContext = any>(options: SerdeFunctions, serializer: RequestSerializer<any, CommandSerdeContext>) => SerializeMiddleware<Input, Output>;

```

## ./lib/lambda/node_modules/@smithy/middleware-serde/dist-types/ts3.4/deserializerMiddleware.d.ts

```typescript
import { DeserializeMiddleware, ResponseDeserializer, SerdeContext, SerdeFunctions } from "@smithy/types";
/**
 * @internal
 * @deprecated will be replaced by schemaSerdePlugin from core/schema.
 */
export declare const deserializerMiddleware: <Input extends object = any, Output extends object = any, CommandSerdeContext extends SerdeContext = any>(options: SerdeFunctions, deserializer: ResponseDeserializer<any, any, CommandSerdeContext>) => DeserializeMiddleware<Input, Output>;

```

## ./lib/lambda/node_modules/@smithy/middleware-serde/dist-types/ts3.4/index.d.ts

```typescript
export * from "./deserializerMiddleware";
export * from "./serdePlugin";
export * from "./serializerMiddleware";

```

## ./lib/lambda/node_modules/@smithy/middleware-serde/dist-types/ts3.4/serdePlugin.d.ts

```typescript
import { DeserializeHandlerOptions, Endpoint, MetadataBearer, Pluggable, Provider, RequestSerializer, ResponseDeserializer, SerdeContext, SerdeFunctions, SerializeHandlerOptions, UrlParser } from "@smithy/types";
/**
 * @deprecated will be replaced by schemaSerdePlugin from core/schema.
 */
export declare const deserializerMiddlewareOption: DeserializeHandlerOptions;
/**
 * @deprecated will be replaced by schemaSerdePlugin from core/schema.
 */
export declare const serializerMiddlewareOption: SerializeHandlerOptions;
/**
 * Modifies the EndpointBearer to make it compatible with Endpoints 2.0 change.
 *
 * @internal
 * @deprecated
 */
export type V1OrV2Endpoint = {
    urlParser?: UrlParser;
    endpoint?: Provider<Endpoint>;
};
/**
 * @internal
 * @deprecated will be replaced by schemaSerdePlugin from core/schema.
 */
export declare function getSerdePlugin<InputType extends object = any, CommandSerdeContext extends SerdeContext = any, OutputType extends MetadataBearer = any>(config: SerdeFunctions, serializer: RequestSerializer<any, CommandSerdeContext>, deserializer: ResponseDeserializer<OutputType, any, CommandSerdeContext>): Pluggable<InputType, OutputType>;

```

## ./lib/lambda/node_modules/@smithy/middleware-serde/dist-types/ts3.4/serializerMiddleware.d.ts

```typescript
import { RequestSerializer, SerdeContext, SerdeFunctions, SerializeMiddleware } from "@smithy/types";
/**
 * @internal
 * @deprecated will be replaced by schemaSerdePlugin from core/schema.
 */
export declare const serializerMiddleware: <Input extends object = any, Output extends object = any, CommandSerdeContext extends SerdeContext = any>(options: SerdeFunctions, serializer: RequestSerializer<any, CommandSerdeContext>) => SerializeMiddleware<Input, Output>;

```

## ./lib/lambda/node_modules/@smithy/middleware-serde/package.json

```json
{
  "name": "@smithy/middleware-serde",
  "version": "4.2.3",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline middleware-serde",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "rimraf dist-types/ts3.4 && downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../../.prettierignore --write \"**/*.{ts,md,json}\"",
    "test": "yarn g:vitest run",
    "test:integration": "yarn g:vitest run -c vitest.config.integ.mts",
    "test:watch": "yarn g:vitest watch",
    "test:integration:watch": "yarn g:vitest watch -c vitest.config.integ.mts"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "sideEffects": false,
  "dependencies": {
    "@smithy/protocol-http": "^5.3.3",
    "@smithy/types": "^4.8.0",
    "tslib": "^2.6.2"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/smithy-lang/smithy-typescript/tree/main/packages/middleware-serde",
  "repository": {
    "type": "git",
    "url": "https://github.com/smithy-lang/smithy-typescript.git",
    "directory": "packages/middleware-serde"
  },
  "devDependencies": {
    "@smithy/util-test": "^0.2.8",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  }
}
```

## ./lib/lambda/node_modules/@smithy/middleware-stack/dist-types/MiddlewareStack.d.ts

```typescript
import type { MiddlewareStack } from "@smithy/types";
/**
 * @internal
 */
export declare const constructStack: <Input extends object, Output extends object>() => MiddlewareStack<Input, Output>;

```

## ./lib/lambda/node_modules/@smithy/middleware-stack/dist-types/index.d.ts

```typescript
export * from "./MiddlewareStack";

```

## ./lib/lambda/node_modules/@smithy/middleware-stack/dist-types/ts3.4/MiddlewareStack.d.ts

```typescript
import { MiddlewareStack } from "@smithy/types";
/**
 * @internal
 */
export declare const constructStack: <Input extends object, Output extends object>() => MiddlewareStack<Input, Output>;

```

## ./lib/lambda/node_modules/@smithy/middleware-stack/dist-types/ts3.4/index.d.ts

```typescript
export * from "./MiddlewareStack";

```

## ./lib/lambda/node_modules/@smithy/middleware-stack/dist-types/ts3.4/types.d.ts

```typescript
import { AbsoluteLocation, HandlerOptions, MiddlewareType, Priority, RelativeLocation, Step } from "@smithy/types";
export interface MiddlewareEntry<Input extends object, Output extends object> extends HandlerOptions {
    middleware: MiddlewareType<Input, Output>;
}
export interface AbsoluteMiddlewareEntry<Input extends object, Output extends object> extends MiddlewareEntry<Input, Output>, AbsoluteLocation {
    step: Step;
    priority: Priority;
}
export interface RelativeMiddlewareEntry<Input extends object, Output extends object> extends MiddlewareEntry<Input, Output>, RelativeLocation {
}
export type Normalized<T extends MiddlewareEntry<Input, Output>, Input extends object = {}, Output extends object = {}> = T & {
    after: Normalized<RelativeMiddlewareEntry<Input, Output>, Input, Output>[];
    before: Normalized<RelativeMiddlewareEntry<Input, Output>, Input, Output>[];
};
export interface NormalizedRelativeEntry<Input extends object, Output extends object> extends HandlerOptions {
    step: Step;
    middleware: MiddlewareType<Input, Output>;
    next?: NormalizedRelativeEntry<Input, Output>;
    prev?: NormalizedRelativeEntry<Input, Output>;
    priority: null;
}
export type NamedMiddlewareEntriesMap<Input extends object, Output extends object> = Record<string, MiddlewareEntry<Input, Output>>;

```

## ./lib/lambda/node_modules/@smithy/middleware-stack/dist-types/types.d.ts

```typescript
import type { AbsoluteLocation, HandlerOptions, MiddlewareType, Priority, RelativeLocation, Step } from "@smithy/types";
export interface MiddlewareEntry<Input extends object, Output extends object> extends HandlerOptions {
    middleware: MiddlewareType<Input, Output>;
}
export interface AbsoluteMiddlewareEntry<Input extends object, Output extends object> extends MiddlewareEntry<Input, Output>, AbsoluteLocation {
    step: Step;
    priority: Priority;
}
export interface RelativeMiddlewareEntry<Input extends object, Output extends object> extends MiddlewareEntry<Input, Output>, RelativeLocation {
}
export type Normalized<T extends MiddlewareEntry<Input, Output>, Input extends object = {}, Output extends object = {}> = T & {
    after: Normalized<RelativeMiddlewareEntry<Input, Output>, Input, Output>[];
    before: Normalized<RelativeMiddlewareEntry<Input, Output>, Input, Output>[];
};
export interface NormalizedRelativeEntry<Input extends object, Output extends object> extends HandlerOptions {
    step: Step;
    middleware: MiddlewareType<Input, Output>;
    next?: NormalizedRelativeEntry<Input, Output>;
    prev?: NormalizedRelativeEntry<Input, Output>;
    priority: null;
}
export type NamedMiddlewareEntriesMap<Input extends object, Output extends object> = Record<string, MiddlewareEntry<Input, Output>>;

```

## ./lib/lambda/node_modules/@smithy/middleware-stack/package.json

```json
{
  "name": "@smithy/middleware-stack",
  "version": "4.2.3",
  "description": "Provides a means for composing multiple middleware functions into a single handler",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline middleware-stack",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "rimraf dist-types/ts3.4 && downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../../.prettierignore --write \"**/*.{ts,md,json}\"",
    "extract:docs": "api-extractor run --local",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch"
  },
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "email": "",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "sideEffects": false,
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "dependencies": {
    "@smithy/types": "^4.8.0",
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/smithy-lang/smithy-typescript/tree/main/packages/middleware-stack",
  "repository": {
    "type": "git",
    "url": "https://github.com/smithy-lang/smithy-typescript.git",
    "directory": "packages/middleware-stack"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  }
}
```

## ./lib/lambda/node_modules/@smithy/node-config-provider/dist-types/configLoader.d.ts

```typescript
import type { Provider } from "@smithy/types";
import type { EnvOptions, GetterFromEnv } from "./fromEnv";
import type { GetterFromConfig, SharedConfigInit } from "./fromSharedConfigFiles";
import type { FromStaticConfig } from "./fromStatic";
/**
 * @internal
 */
export type LocalConfigOptions = SharedConfigInit & EnvOptions;
/**
 * @internal
 */
export interface LoadedConfigSelectors<T> {
    /**
     * A getter function getting the config values from all the environment
     * variables.
     */
    environmentVariableSelector: GetterFromEnv<T>;
    /**
     * A getter function getting config values associated with the inferred
     * profile from shared INI files
     */
    configFileSelector: GetterFromConfig<T>;
    /**
     * Default value or getter
     */
    default: FromStaticConfig<T>;
}
/**
 * @internal
 */
export declare const loadConfig: <T = string>({ environmentVariableSelector, configFileSelector, default: defaultValue }: LoadedConfigSelectors<T>, configuration?: LocalConfigOptions) => Provider<T>;

```

## ./lib/lambda/node_modules/@smithy/node-config-provider/dist-types/fromEnv.d.ts

```typescript
import type { Logger, Provider } from "@smithy/types";
/**
 * @internal
 */
export interface EnvOptions {
    /**
     * The SigV4 service signing name.
     */
    signingName?: string;
    /**
     * For credential resolution trace logging.
     */
    logger?: Logger;
}
export type GetterFromEnv<T> = (env: Record<string, string | undefined>, options?: EnvOptions) => T | undefined;
/**
 * Get config value given the environment variable name or getter from
 * environment variable.
 */
export declare const fromEnv: <T = string>(envVarSelector: GetterFromEnv<T>, options?: EnvOptions) => Provider<T>;

```

## ./lib/lambda/node_modules/@smithy/node-config-provider/dist-types/fromSharedConfigFiles.d.ts

```typescript
import type { SourceProfileInit } from "@smithy/shared-ini-file-loader";
import type { ParsedIniData, Profile, Provider } from "@smithy/types";
/**
 * @internal
 */
export interface SharedConfigInit extends SourceProfileInit {
    /**
     * The preferred shared ini file to load the config. "config" option refers to
     * the shared config file(defaults to `~/.aws/config`). "credentials" option
     * refers to the shared credentials file(defaults to `~/.aws/credentials`)
     */
    preferredFile?: "config" | "credentials";
}
/**
 * @internal
 */
export type GetterFromConfig<T> = (profile: Profile, configFile?: ParsedIniData) => T | undefined;
/**
 * Get config value from the shared config files with inferred profile name.
 * @internal
 */
export declare const fromSharedConfigFiles: <T = string>(configSelector: GetterFromConfig<T>, { preferredFile, ...init }?: SharedConfigInit) => Provider<T>;

```

## ./lib/lambda/node_modules/@smithy/node-config-provider/dist-types/fromStatic.d.ts

```typescript
import type { Provider } from "@smithy/types";
/**
 * @internal
 */
export type FromStaticConfig<T> = T | (() => T) | Provider<T>;
/**
 * @internal
 */
export declare const fromStatic: <T>(defaultValue: FromStaticConfig<T>) => Provider<T>;

```

## ./lib/lambda/node_modules/@smithy/node-config-provider/dist-types/getSelectorName.d.ts

```typescript
/**
 * Attempts to extract the name of the variable that the functional selector is looking for.
 * Improves readability over the raw Function.toString() value.
 * @internal
 * @param functionString - function's string representation.
 *
 * @returns constant value used within the function.
 */
export declare function getSelectorName(functionString: string): string;

```

## ./lib/lambda/node_modules/@smithy/node-config-provider/dist-types/index.d.ts

```typescript
export * from "./configLoader";
export { EnvOptions, GetterFromEnv } from "./fromEnv";
export { GetterFromConfig, SharedConfigInit } from "./fromSharedConfigFiles";
export { FromStaticConfig } from "./fromStatic";

```

## ./lib/lambda/node_modules/@smithy/node-config-provider/dist-types/ts3.4/configLoader.d.ts

```typescript
import { Provider } from "@smithy/types";
import { EnvOptions, GetterFromEnv } from "./fromEnv";
import { GetterFromConfig, SharedConfigInit } from "./fromSharedConfigFiles";
import { FromStaticConfig } from "./fromStatic";
/**
 * @internal
 */
export type LocalConfigOptions = SharedConfigInit & EnvOptions;
/**
 * @internal
 */
export interface LoadedConfigSelectors<T> {
    /**
     * A getter function getting the config values from all the environment
     * variables.
     */
    environmentVariableSelector: GetterFromEnv<T>;
    /**
     * A getter function getting config values associated with the inferred
     * profile from shared INI files
     */
    configFileSelector: GetterFromConfig<T>;
    /**
     * Default value or getter
     */
    default: FromStaticConfig<T>;
}
/**
 * @internal
 */
export declare const loadConfig: <T = string>({ environmentVariableSelector, configFileSelector, default: defaultValue }: LoadedConfigSelectors<T>, configuration?: LocalConfigOptions) => Provider<T>;

```

## ./lib/lambda/node_modules/@smithy/node-config-provider/dist-types/ts3.4/fromEnv.d.ts

```typescript
import { Logger, Provider } from "@smithy/types";
/**
 * @internal
 */
export interface EnvOptions {
    /**
     * The SigV4 service signing name.
     */
    signingName?: string;
    /**
     * For credential resolution trace logging.
     */
    logger?: Logger;
}
export type GetterFromEnv<T> = (env: Record<string, string | undefined>, options?: EnvOptions) => T | undefined;
/**
 * Get config value given the environment variable name or getter from
 * environment variable.
 */
export declare const fromEnv: <T = string>(envVarSelector: GetterFromEnv<T>, options?: EnvOptions) => Provider<T>;

```

## ./lib/lambda/node_modules/@smithy/node-config-provider/dist-types/ts3.4/fromSharedConfigFiles.d.ts

```typescript
import { SourceProfileInit } from "@smithy/shared-ini-file-loader";
import { ParsedIniData, Profile, Provider } from "@smithy/types";
/**
 * @internal
 */
export interface SharedConfigInit extends SourceProfileInit {
    /**
     * The preferred shared ini file to load the config. "config" option refers to
     * the shared config file(defaults to `~/.aws/config`). "credentials" option
     * refers to the shared credentials file(defaults to `~/.aws/credentials`)
     */
    preferredFile?: "config" | "credentials";
}
/**
 * @internal
 */
export type GetterFromConfig<T> = (profile: Profile, configFile?: ParsedIniData) => T | undefined;
/**
 * Get config value from the shared config files with inferred profile name.
 * @internal
 */
export declare const fromSharedConfigFiles: <T = string>(configSelector: GetterFromConfig<T>, { preferredFile, ...init }?: SharedConfigInit) => Provider<T>;

```

## ./lib/lambda/node_modules/@smithy/node-config-provider/dist-types/ts3.4/fromStatic.d.ts

```typescript
import { Provider } from "@smithy/types";
/**
 * @internal
 */
export type FromStaticConfig<T> = T | (() => T) | Provider<T>;
/**
 * @internal
 */
export declare const fromStatic: <T>(defaultValue: FromStaticConfig<T>) => Provider<T>;

```

## ./lib/lambda/node_modules/@smithy/node-config-provider/dist-types/ts3.4/getSelectorName.d.ts

```typescript
/**
 * Attempts to extract the name of the variable that the functional selector is looking for.
 * Improves readability over the raw Function.toString() value.
 * @internal
 * @param functionString - function's string representation.
 *
 * @returns constant value used within the function.
 */
export declare function getSelectorName(functionString: string): string;

```

## ./lib/lambda/node_modules/@smithy/node-config-provider/dist-types/ts3.4/index.d.ts

```typescript
export * from "./configLoader";
export { EnvOptions, GetterFromEnv } from "./fromEnv";
export { GetterFromConfig, SharedConfigInit } from "./fromSharedConfigFiles";
export { FromStaticConfig } from "./fromStatic";

```

## ./lib/lambda/node_modules/@smithy/node-config-provider/package.json

```json
{
  "name": "@smithy/node-config-provider",
  "version": "4.3.3",
  "description": "Load config default values from ini config files and environmental variable",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline node-config-provider",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "rimraf dist-types/ts3.4 && downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../../.prettierignore --write \"**/*.{ts,md,json}\"",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch"
  },
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "email": "",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "sideEffects": false,
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "dependencies": {
    "@smithy/property-provider": "^4.2.3",
    "@smithy/shared-ini-file-loader": "^4.3.3",
    "@smithy/types": "^4.8.0",
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "@types/node": "^18.11.9",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/smithy-lang/smithy-typescript/tree/main/packages/node-config-provider",
  "repository": {
    "type": "git",
    "url": "https://github.com/smithy-lang/smithy-typescript.git",
    "directory": "packages/node-config-provider"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  }
}
```

## ./lib/lambda/node_modules/@smithy/node-http-handler/dist-types/constants.d.ts

```typescript
/**
 * Node.js system error codes that indicate timeout.
 * @deprecated use NODEJS_TIMEOUT_ERROR_CODES from @smithy/service-error-classification/constants
 */
export declare const NODEJS_TIMEOUT_ERROR_CODES: string[];

```

## ./lib/lambda/node_modules/@smithy/node-http-handler/dist-types/get-transformed-headers.d.ts

```typescript
import type { HeaderBag } from "@smithy/types";
import type { IncomingHttpHeaders } from "http2";
declare const getTransformedHeaders: (headers: IncomingHttpHeaders) => HeaderBag;
export { getTransformedHeaders };

```

## ./lib/lambda/node_modules/@smithy/node-http-handler/dist-types/index.d.ts

```typescript
export * from "./node-http-handler";
export * from "./node-http2-handler";
export * from "./stream-collector";

```

## ./lib/lambda/node_modules/@smithy/node-http-handler/dist-types/node-http-handler.d.ts

```typescript
import type { HttpHandler, HttpRequest } from "@smithy/protocol-http";
import { HttpResponse } from "@smithy/protocol-http";
import type { Logger, NodeHttpHandlerOptions } from "@smithy/types";
import type { HttpHandlerOptions, Provider } from "@smithy/types";
import { Agent as hAgent } from "http";
import { Agent as hsAgent } from "https";
export { NodeHttpHandlerOptions };
/**
 * @public
 * A default of 0 means no timeout.
 */
export declare const DEFAULT_REQUEST_TIMEOUT = 0;
/**
 * @public
 * A request handler that uses the Node.js http and https modules.
 */
export declare class NodeHttpHandler implements HttpHandler<NodeHttpHandlerOptions> {
    private config?;
    private configProvider;
    private socketWarningTimestamp;
    readonly metadata: {
        handlerProtocol: string;
    };
    /**
     * @returns the input if it is an HttpHandler of any class,
     * or instantiates a new instance of this handler.
     */
    static create(instanceOrOptions?: HttpHandler<any> | NodeHttpHandlerOptions | Provider<NodeHttpHandlerOptions | void>): NodeHttpHandler | HttpHandler<any>;
    /**
     * @internal
     *
     * @param agent - http(s) agent in use by the NodeHttpHandler instance.
     * @param socketWarningTimestamp - last socket usage check timestamp.
     * @param logger - channel for the warning.
     * @returns timestamp of last emitted warning.
     */
    static checkSocketUsage(agent: hAgent | hsAgent, socketWarningTimestamp: number, logger?: Logger): number;
    constructor(options?: NodeHttpHandlerOptions | Provider<NodeHttpHandlerOptions | void>);
    private resolveDefaultConfig;
    destroy(): void;
    handle(request: HttpRequest, { abortSignal, requestTimeout }?: HttpHandlerOptions): Promise<{
        response: HttpResponse;
    }>;
    updateHttpClientConfig(key: keyof NodeHttpHandlerOptions, value: NodeHttpHandlerOptions[typeof key]): void;
    httpHandlerConfigs(): NodeHttpHandlerOptions;
}

```

## ./lib/lambda/node_modules/@smithy/node-http-handler/dist-types/node-http2-connection-manager.d.ts

```typescript
import type { RequestContext } from "@smithy/types";
import type { ConnectConfiguration } from "@smithy/types";
import type { ConnectionManager, ConnectionManagerConfiguration } from "@smithy/types";
import type { ClientHttp2Session } from "http2";
/**
 * @public
 */
export declare class NodeHttp2ConnectionManager implements ConnectionManager<ClientHttp2Session> {
    constructor(config: ConnectionManagerConfiguration);
    private config;
    private readonly sessionCache;
    lease(requestContext: RequestContext, connectionConfiguration: ConnectConfiguration): ClientHttp2Session;
    /**
     * Delete a session from the connection pool.
     * @param authority The authority of the session to delete.
     * @param session The session to delete.
     */
    deleteSession(authority: string, session: ClientHttp2Session): void;
    release(requestContext: RequestContext, session: ClientHttp2Session): void;
    destroy(): void;
    setMaxConcurrentStreams(maxConcurrentStreams: number): void;
    setDisableConcurrentStreams(disableConcurrentStreams: boolean): void;
    private getUrlString;
}

```

## ./lib/lambda/node_modules/@smithy/node-http-handler/dist-types/node-http2-connection-pool.d.ts

```typescript
import type { ConnectionPool } from "@smithy/types";
import type { ClientHttp2Session } from "http2";
export declare class NodeHttp2ConnectionPool implements ConnectionPool<ClientHttp2Session> {
    private sessions;
    constructor(sessions?: ClientHttp2Session[]);
    poll(): ClientHttp2Session | void;
    offerLast(session: ClientHttp2Session): void;
    contains(session: ClientHttp2Session): boolean;
    remove(session: ClientHttp2Session): void;
    [Symbol.iterator](): ArrayIterator<ClientHttp2Session>;
    destroy(connection: ClientHttp2Session): void;
}

```

## ./lib/lambda/node_modules/@smithy/node-http-handler/dist-types/node-http2-handler.d.ts

```typescript
import type { HttpHandler, HttpRequest } from "@smithy/protocol-http";
import { HttpResponse } from "@smithy/protocol-http";
import type { HttpHandlerOptions, Provider } from "@smithy/types";
/**
 * Represents the http2 options that can be passed to a node http2 client.
 * @public
 */
export interface NodeHttp2HandlerOptions {
    /**
     * The maximum time in milliseconds that a stream may remain idle before it
     * is closed.
     */
    requestTimeout?: number;
    /**
     * The maximum time in milliseconds that a session or socket may remain idle
     * before it is closed.
     * https://nodejs.org/docs/latest-v12.x/api/http2.html#http2_http2session_and_sockets
     */
    sessionTimeout?: number;
    /**
     * Disables processing concurrent streams on a ClientHttp2Session instance. When set
     * to true, a new session instance is created for each request to a URL.
     * **Default:** false.
     * https://nodejs.org/api/http2.html#http2_class_clienthttp2session
     */
    disableConcurrentStreams?: boolean;
    /**
     * Maximum number of concurrent Http2Stream instances per ClientHttp2Session. Each session
     * may have up to 2^31-1 Http2Stream instances over its lifetime.
     * This value must be greater than or equal to 0.
     * https://nodejs.org/api/http2.html#class-http2stream
     */
    maxConcurrentStreams?: number;
}
/**
 * A request handler using the node:http2 package.
 * @public
 */
export declare class NodeHttp2Handler implements HttpHandler<NodeHttp2HandlerOptions> {
    private config?;
    private configProvider;
    readonly metadata: {
        handlerProtocol: string;
    };
    private readonly connectionManager;
    /**
     * @returns the input if it is an HttpHandler of any class,
     * or instantiates a new instance of this handler.
     */
    static create(instanceOrOptions?: HttpHandler<any> | NodeHttp2HandlerOptions | Provider<NodeHttp2HandlerOptions | void>): HttpHandler<any> | NodeHttp2Handler;
    constructor(options?: NodeHttp2HandlerOptions | Provider<NodeHttp2HandlerOptions | void>);
    destroy(): void;
    handle(request: HttpRequest, { abortSignal, requestTimeout }?: HttpHandlerOptions): Promise<{
        response: HttpResponse;
    }>;
    updateHttpClientConfig(key: keyof NodeHttp2HandlerOptions, value: NodeHttp2HandlerOptions[typeof key]): void;
    httpHandlerConfigs(): NodeHttp2HandlerOptions;
    /**
     * Destroys a session.
     * @param session - the session to destroy.
     */
    private destroySession;
}

```

## ./lib/lambda/node_modules/@smithy/node-http-handler/dist-types/readable.mock.d.ts

```typescript
import type { ReadableOptions } from "stream";
import { Readable } from "stream";
export interface ReadFromBuffersOptions extends ReadableOptions {
    buffers: Buffer[];
    errorAfter?: number;
}
export declare class ReadFromBuffers extends Readable {
    private buffersToRead;
    private numBuffersRead;
    private errorAfter;
    constructor(options: ReadFromBuffersOptions);
    _read(): boolean | undefined;
}

```

## ./lib/lambda/node_modules/@smithy/node-http-handler/dist-types/server.mock.d.ts

```typescript
import type { HttpResponse } from "@smithy/types";
import type { IncomingMessage, Server as HttpServer, ServerResponse } from "http";
import type { Http2Server } from "http2";
import type { Server as HttpsServer } from "https";
export declare const createResponseFunction: (httpResp: HttpResponse) => (request: IncomingMessage, response: ServerResponse) => void;
export declare const createResponseFunctionWithDelay: (httpResp: HttpResponse, delay: number) => (request: IncomingMessage, response: ServerResponse) => void;
export declare const createContinueResponseFunction: (httpResp: HttpResponse) => (request: IncomingMessage, response: ServerResponse) => void;
export declare const createMockHttpsServer: () => HttpsServer;
export declare const createMockHttpServer: () => HttpServer;
export declare const createMockHttp2Server: () => Http2Server;
export declare const createMirrorResponseFunction: (httpResp: HttpResponse) => (request: IncomingMessage, response: ServerResponse) => void;
export declare const getResponseBody: (response: HttpResponse) => Promise<string>;

```

## ./lib/lambda/node_modules/@smithy/node-http-handler/dist-types/set-connection-timeout.d.ts

```typescript
import type { ClientRequest } from "http";
export declare const setConnectionTimeout: (request: ClientRequest, reject: (err: Error) => void, timeoutInMs?: number) => NodeJS.Timeout | number;

```

## ./lib/lambda/node_modules/@smithy/node-http-handler/dist-types/set-request-timeout.d.ts

```typescript
import type { Logger } from "@smithy/types";
import type { ClientRequest } from "http";
/**
 * @internal
 */
export declare const setRequestTimeout: (req: ClientRequest, reject: (err: Error) => void, timeoutInMs?: number, throwOnRequestTimeout?: boolean, logger?: Logger) => number;

```

## ./lib/lambda/node_modules/@smithy/node-http-handler/dist-types/set-socket-keep-alive.d.ts

```typescript
import type { ClientRequest } from "http";
export interface SocketKeepAliveOptions {
    keepAlive: boolean;
    keepAliveMsecs?: number;
}
export declare const setSocketKeepAlive: (request: ClientRequest, { keepAlive, keepAliveMsecs }: SocketKeepAliveOptions, deferTimeMs?: number) => NodeJS.Timeout | number;

```

## ./lib/lambda/node_modules/@smithy/node-http-handler/dist-types/set-socket-timeout.d.ts

```typescript
import type { ClientRequest } from "http";
export declare const setSocketTimeout: (request: ClientRequest, reject: (err: Error) => void, timeoutInMs?: number) => NodeJS.Timeout | number;

```

## ./lib/lambda/node_modules/@smithy/node-http-handler/dist-types/stream-collector/collector.d.ts

```typescript
import { Writable } from "stream";
export declare class Collector extends Writable {
    readonly bufferedBytes: Buffer[];
    _write(chunk: Buffer, encoding: string, callback: (err?: Error) => void): void;
}

```

## ./lib/lambda/node_modules/@smithy/node-http-handler/dist-types/stream-collector/index.d.ts

```typescript
import type { StreamCollector } from "@smithy/types";
/**
 * @internal
 * Converts a stream to a byte array.
 */
export declare const streamCollector: StreamCollector;

```

## ./lib/lambda/node_modules/@smithy/node-http-handler/dist-types/stream-collector/readable.mock.d.ts

```typescript
import type { ReadableOptions } from "stream";
import { Readable } from "stream";
export interface ReadFromBuffersOptions extends ReadableOptions {
    buffers: Buffer[];
    errorAfter?: number;
}
export declare class ReadFromBuffers extends Readable {
    private buffersToRead;
    private numBuffersRead;
    private errorAfter;
    constructor(options: ReadFromBuffersOptions);
    _read(size: number): boolean | undefined;
}

```

## ./lib/lambda/node_modules/@smithy/node-http-handler/dist-types/timing.d.ts

```typescript
/**
 * @internal
 * For test spies.
 */
export declare const timing: {
    setTimeout: (cb: (...ignored: any[]) => void | unknown, ms?: number) => number;
    clearTimeout: (timeoutId: string | number | undefined | unknown) => void;
};

```

## ./lib/lambda/node_modules/@smithy/node-http-handler/dist-types/ts3.4/constants.d.ts

```typescript
/**
 * Node.js system error codes that indicate timeout.
 * @deprecated use NODEJS_TIMEOUT_ERROR_CODES from @smithy/service-error-classification/constants
 */
export declare const NODEJS_TIMEOUT_ERROR_CODES: string[];

```

## ./lib/lambda/node_modules/@smithy/node-http-handler/dist-types/ts3.4/get-transformed-headers.d.ts

```typescript
import { HeaderBag } from "@smithy/types";
import { IncomingHttpHeaders } from "http2";
declare const getTransformedHeaders: (headers: IncomingHttpHeaders) => HeaderBag;
export { getTransformedHeaders };

```

## ./lib/lambda/node_modules/@smithy/node-http-handler/dist-types/ts3.4/index.d.ts

```typescript
export * from "./node-http-handler";
export * from "./node-http2-handler";
export * from "./stream-collector";

```

## ./lib/lambda/node_modules/@smithy/node-http-handler/dist-types/ts3.4/node-http-handler.d.ts

```typescript
import { HttpHandler, HttpRequest } from "@smithy/protocol-http";
import { HttpResponse } from "@smithy/protocol-http";
import { Logger, NodeHttpHandlerOptions } from "@smithy/types";
import { HttpHandlerOptions, Provider } from "@smithy/types";
import { Agent as hAgent } from "http";
import { Agent as hsAgent } from "https";
export { NodeHttpHandlerOptions };
/**
 * @public
 * A default of 0 means no timeout.
 */
export declare const DEFAULT_REQUEST_TIMEOUT = 0;
/**
 * @public
 * A request handler that uses the Node.js http and https modules.
 */
export declare class NodeHttpHandler implements HttpHandler<NodeHttpHandlerOptions> {
    private config?;
    private configProvider;
    private socketWarningTimestamp;
    readonly metadata: {
        handlerProtocol: string;
    };
    /**
     * @returns the input if it is an HttpHandler of any class,
     * or instantiates a new instance of this handler.
     */
    static create(instanceOrOptions?: HttpHandler<any> | NodeHttpHandlerOptions | Provider<NodeHttpHandlerOptions | void>): NodeHttpHandler | HttpHandler<any>;
    /**
     * @internal
     *
     * @param agent - http(s) agent in use by the NodeHttpHandler instance.
     * @param socketWarningTimestamp - last socket usage check timestamp.
     * @param logger - channel for the warning.
     * @returns timestamp of last emitted warning.
     */
    static checkSocketUsage(agent: hAgent | hsAgent, socketWarningTimestamp: number, logger?: Logger): number;
    constructor(options?: NodeHttpHandlerOptions | Provider<NodeHttpHandlerOptions | void>);
    private resolveDefaultConfig;
    destroy(): void;
    handle(request: HttpRequest, { abortSignal, requestTimeout }?: HttpHandlerOptions): Promise<{
        response: HttpResponse;
    }>;
    updateHttpClientConfig(key: keyof NodeHttpHandlerOptions, value: NodeHttpHandlerOptions[typeof key]): void;
    httpHandlerConfigs(): NodeHttpHandlerOptions;
}

```

## ./lib/lambda/node_modules/@smithy/node-http-handler/dist-types/ts3.4/node-http2-connection-manager.d.ts

```typescript
import { RequestContext } from "@smithy/types";
import { ConnectConfiguration } from "@smithy/types";
import { ConnectionManager, ConnectionManagerConfiguration } from "@smithy/types";
import { ClientHttp2Session } from "http2";
/**
 * @public
 */
export declare class NodeHttp2ConnectionManager implements ConnectionManager<ClientHttp2Session> {
    constructor(config: ConnectionManagerConfiguration);
    private config;
    private readonly sessionCache;
    lease(requestContext: RequestContext, connectionConfiguration: ConnectConfiguration): ClientHttp2Session;
    /**
     * Delete a session from the connection pool.
     * @param authority The authority of the session to delete.
     * @param session The session to delete.
     */
    deleteSession(authority: string, session: ClientHttp2Session): void;
    release(requestContext: RequestContext, session: ClientHttp2Session): void;
    destroy(): void;
    setMaxConcurrentStreams(maxConcurrentStreams: number): void;
    setDisableConcurrentStreams(disableConcurrentStreams: boolean): void;
    private getUrlString;
}

```

## ./lib/lambda/node_modules/@smithy/node-http-handler/dist-types/ts3.4/node-http2-connection-pool.d.ts

```typescript
import { ConnectionPool } from "@smithy/types";
import { ClientHttp2Session } from "http2";
export declare class NodeHttp2ConnectionPool implements ConnectionPool<ClientHttp2Session> {
    private sessions;
    constructor(sessions?: ClientHttp2Session[]);
    poll(): ClientHttp2Session | void;
    offerLast(session: ClientHttp2Session): void;
    contains(session: ClientHttp2Session): boolean;
    remove(session: ClientHttp2Session): void;
    [Symbol.iterator](): ArrayIterator<ClientHttp2Session>;
    destroy(connection: ClientHttp2Session): void;
}

```

## ./lib/lambda/node_modules/@smithy/node-http-handler/dist-types/ts3.4/node-http2-handler.d.ts

```typescript
import { HttpHandler, HttpRequest } from "@smithy/protocol-http";
import { HttpResponse } from "@smithy/protocol-http";
import { HttpHandlerOptions, Provider } from "@smithy/types";
/**
 * Represents the http2 options that can be passed to a node http2 client.
 * @public
 */
export interface NodeHttp2HandlerOptions {
    /**
     * The maximum time in milliseconds that a stream may remain idle before it
     * is closed.
     */
    requestTimeout?: number;
    /**
     * The maximum time in milliseconds that a session or socket may remain idle
     * before it is closed.
     * https://nodejs.org/docs/latest-v12.x/api/http2.html#http2_http2session_and_sockets
     */
    sessionTimeout?: number;
    /**
     * Disables processing concurrent streams on a ClientHttp2Session instance. When set
     * to true, a new session instance is created for each request to a URL.
     * **Default:** false.
     * https://nodejs.org/api/http2.html#http2_class_clienthttp2session
     */
    disableConcurrentStreams?: boolean;
    /**
     * Maximum number of concurrent Http2Stream instances per ClientHttp2Session. Each session
     * may have up to 2^31-1 Http2Stream instances over its lifetime.
     * This value must be greater than or equal to 0.
     * https://nodejs.org/api/http2.html#class-http2stream
     */
    maxConcurrentStreams?: number;
}
/**
 * A request handler using the node:http2 package.
 * @public
 */
export declare class NodeHttp2Handler implements HttpHandler<NodeHttp2HandlerOptions> {
    private config?;
    private configProvider;
    readonly metadata: {
        handlerProtocol: string;
    };
    private readonly connectionManager;
    /**
     * @returns the input if it is an HttpHandler of any class,
     * or instantiates a new instance of this handler.
     */
    static create(instanceOrOptions?: HttpHandler<any> | NodeHttp2HandlerOptions | Provider<NodeHttp2HandlerOptions | void>): HttpHandler<any> | NodeHttp2Handler;
    constructor(options?: NodeHttp2HandlerOptions | Provider<NodeHttp2HandlerOptions | void>);
    destroy(): void;
    handle(request: HttpRequest, { abortSignal, requestTimeout }?: HttpHandlerOptions): Promise<{
        response: HttpResponse;
    }>;
    updateHttpClientConfig(key: keyof NodeHttp2HandlerOptions, value: NodeHttp2HandlerOptions[typeof key]): void;
    httpHandlerConfigs(): NodeHttp2HandlerOptions;
    /**
     * Destroys a session.
     * @param session - the session to destroy.
     */
    private destroySession;
}

```

## ./lib/lambda/node_modules/@smithy/node-http-handler/dist-types/ts3.4/readable.mock.d.ts

```typescript
import { ReadableOptions } from "stream";
import { Readable } from "stream";
export interface ReadFromBuffersOptions extends ReadableOptions {
    buffers: Buffer[];
    errorAfter?: number;
}
export declare class ReadFromBuffers extends Readable {
    private buffersToRead;
    private numBuffersRead;
    private errorAfter;
    constructor(options: ReadFromBuffersOptions);
    _read(): boolean | undefined;
}

```

## ./lib/lambda/node_modules/@smithy/node-http-handler/dist-types/ts3.4/server.mock.d.ts

```typescript
import { HttpResponse } from "@smithy/types";
import { IncomingMessage, Server as HttpServer, ServerResponse } from "http";
import { Http2Server } from "http2";
import { Server as HttpsServer } from "https";
export declare const createResponseFunction: (httpResp: HttpResponse) => (request: IncomingMessage, response: ServerResponse) => void;
export declare const createResponseFunctionWithDelay: (httpResp: HttpResponse, delay: number) => (request: IncomingMessage, response: ServerResponse) => void;
export declare const createContinueResponseFunction: (httpResp: HttpResponse) => (request: IncomingMessage, response: ServerResponse) => void;
export declare const createMockHttpsServer: () => HttpsServer;
export declare const createMockHttpServer: () => HttpServer;
export declare const createMockHttp2Server: () => Http2Server;
export declare const createMirrorResponseFunction: (httpResp: HttpResponse) => (request: IncomingMessage, response: ServerResponse) => void;
export declare const getResponseBody: (response: HttpResponse) => Promise<string>;

```

## ./lib/lambda/node_modules/@smithy/node-http-handler/dist-types/ts3.4/set-connection-timeout.d.ts

```typescript
import { ClientRequest } from "http";
export declare const setConnectionTimeout: (request: ClientRequest, reject: (err: Error) => void, timeoutInMs?: number) => NodeJS.Timeout | number;

```

## ./lib/lambda/node_modules/@smithy/node-http-handler/dist-types/ts3.4/set-request-timeout.d.ts

```typescript
import { Logger } from "@smithy/types";
import { ClientRequest } from "http";
/**
 * @internal
 */
export declare const setRequestTimeout: (req: ClientRequest, reject: (err: Error) => void, timeoutInMs?: number, throwOnRequestTimeout?: boolean, logger?: Logger) => number;

```

## ./lib/lambda/node_modules/@smithy/node-http-handler/dist-types/ts3.4/set-socket-keep-alive.d.ts

```typescript
import { ClientRequest } from "http";
export interface SocketKeepAliveOptions {
    keepAlive: boolean;
    keepAliveMsecs?: number;
}
export declare const setSocketKeepAlive: (request: ClientRequest, { keepAlive, keepAliveMsecs }: SocketKeepAliveOptions, deferTimeMs?: number) => NodeJS.Timeout | number;

```

## ./lib/lambda/node_modules/@smithy/node-http-handler/dist-types/ts3.4/set-socket-timeout.d.ts

```typescript
import { ClientRequest } from "http";
export declare const setSocketTimeout: (request: ClientRequest, reject: (err: Error) => void, timeoutInMs?: number) => NodeJS.Timeout | number;

```

## ./lib/lambda/node_modules/@smithy/node-http-handler/dist-types/ts3.4/stream-collector/collector.d.ts

```typescript
import { Writable } from "stream";
export declare class Collector extends Writable {
    readonly bufferedBytes: Buffer[];
    _write(chunk: Buffer, encoding: string, callback: (err?: Error) => void): void;
}

```

## ./lib/lambda/node_modules/@smithy/node-http-handler/dist-types/ts3.4/stream-collector/index.d.ts

```typescript
import { StreamCollector } from "@smithy/types";
/**
 * @internal
 * Converts a stream to a byte array.
 */
export declare const streamCollector: StreamCollector;

```

## ./lib/lambda/node_modules/@smithy/node-http-handler/dist-types/ts3.4/stream-collector/readable.mock.d.ts

```typescript
import { ReadableOptions } from "stream";
import { Readable } from "stream";
export interface ReadFromBuffersOptions extends ReadableOptions {
    buffers: Buffer[];
    errorAfter?: number;
}
export declare class ReadFromBuffers extends Readable {
    private buffersToRead;
    private numBuffersRead;
    private errorAfter;
    constructor(options: ReadFromBuffersOptions);
    _read(size: number): boolean | undefined;
}

```

## ./lib/lambda/node_modules/@smithy/node-http-handler/dist-types/ts3.4/timing.d.ts

```typescript
/**
 * @internal
 * For test spies.
 */
export declare const timing: {
    setTimeout: (cb: (...ignored: any[]) => void | unknown, ms?: number) => number;
    clearTimeout: (timeoutId: string | number | undefined | unknown) => void;
};

```

## ./lib/lambda/node_modules/@smithy/node-http-handler/dist-types/ts3.4/write-request-body.d.ts

```typescript
import { HttpRequest } from "@smithy/types";
import { ClientRequest } from "http";
import { ClientHttp2Stream } from "http2";
/**
 * This resolves when writeBody has been called.
 *
 * @param httpRequest - opened Node.js request.
 * @param request - container with the request body.
 * @param maxContinueTimeoutMs - time to wait for the continue event.
 */
export declare function writeRequestBody(httpRequest: ClientRequest | ClientHttp2Stream, request: HttpRequest, maxContinueTimeoutMs?: number): Promise<void>;

```

## ./lib/lambda/node_modules/@smithy/node-http-handler/dist-types/write-request-body.d.ts

```typescript
import type { HttpRequest } from "@smithy/types";
import type { ClientRequest } from "http";
import type { ClientHttp2Stream } from "http2";
/**
 * This resolves when writeBody has been called.
 *
 * @param httpRequest - opened Node.js request.
 * @param request - container with the request body.
 * @param maxContinueTimeoutMs - time to wait for the continue event.
 */
export declare function writeRequestBody(httpRequest: ClientRequest | ClientHttp2Stream, request: HttpRequest, maxContinueTimeoutMs?: number): Promise<void>;

```

## ./lib/lambda/node_modules/@smithy/node-http-handler/package.json

```json
{
  "name": "@smithy/node-http-handler",
  "version": "4.4.2",
  "description": "Provides a way to make requests",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline node-http-handler",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "rimraf dist-types/ts3.4 && downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../../.prettierignore --write \"**/*.{ts,md,json}\"",
    "extract:docs": "api-extractor run --local",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch"
  },
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "email": "",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "sideEffects": false,
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "dependencies": {
    "@smithy/abort-controller": "^4.2.3",
    "@smithy/protocol-http": "^5.3.3",
    "@smithy/querystring-builder": "^4.2.3",
    "@smithy/types": "^4.8.0",
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "@types/node": "^18.11.9",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/smithy-lang/smithy-typescript/tree/main/packages/node-http-handler",
  "repository": {
    "type": "git",
    "url": "https://github.com/smithy-lang/smithy-typescript.git",
    "directory": "packages/node-http-handler"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  }
}
```

## ./lib/lambda/node_modules/@smithy/property-provider/dist-types/CredentialsProviderError.d.ts

```typescript
import type { ProviderErrorOptionsType } from "./ProviderError";
import { ProviderError } from "./ProviderError";
/**
 * @public
 *
 * An error representing a failure of an individual credential provider.
 *
 * This error class has special meaning to the {@link chain} method. If a
 * provider in the chain is rejected with an error, the chain will only proceed
 * to the next provider if the value of the `tryNextLink` property on the error
 * is truthy. This allows individual providers to halt the chain and also
 * ensures the chain will stop if an entirely unexpected error is encountered.
 */
export declare class CredentialsProviderError extends ProviderError {
    name: string;
    /**
     * @override
     * @deprecated constructor should be given a logger.
     */
    constructor(message: string);
    /**
     * @override
     * @deprecated constructor should be given a logger.
     */
    constructor(message: string, tryNextLink: boolean | undefined);
    /**
     * @override
     * This signature is preferred for logging capability.
     */
    constructor(message: string, options: ProviderErrorOptionsType);
}

```

## ./lib/lambda/node_modules/@smithy/property-provider/dist-types/ProviderError.d.ts

```typescript
import type { Logger } from "@smithy/types";
/**
 * @public
 */
export type ProviderErrorOptionsType = {
    tryNextLink?: boolean | undefined;
    logger?: Logger;
};
/**
 * @public
 *
 * An error representing a failure of an individual provider.
 *
 * This error class has special meaning to the {@link chain} method. If a
 * provider in the chain is rejected with an error, the chain will only proceed
 * to the next provider if the value of the `tryNextLink` property on the error
 * is truthy. This allows individual providers to halt the chain and also
 * ensures the chain will stop if an entirely unexpected error is encountered.
 */
export declare class ProviderError extends Error {
    name: string;
    readonly tryNextLink: boolean;
    /**
     * @deprecated constructor should be given a logger.
     */
    constructor(message: string);
    /**
     * @deprecated constructor should be given a logger.
     */
    constructor(message: string, tryNextLink: boolean | undefined);
    /**
     * This signature is preferred for logging capability.
     */
    constructor(message: string, options: ProviderErrorOptionsType);
    /**
     * @deprecated use new operator.
     */
    static from(error: Error, options?: boolean | ProviderErrorOptionsType): ProviderError;
}

```

## ./lib/lambda/node_modules/@smithy/property-provider/dist-types/TokenProviderError.d.ts

```typescript
import type { ProviderErrorOptionsType } from "./ProviderError";
import { ProviderError } from "./ProviderError";
/**
 * @public
 *
 * An error representing a failure of an individual token provider.
 *
 * This error class has special meaning to the {@link chain} method. If a
 * provider in the chain is rejected with an error, the chain will only proceed
 * to the next provider if the value of the `tryNextLink` property on the error
 * is truthy. This allows individual providers to halt the chain and also
 * ensures the chain will stop if an entirely unexpected error is encountered.
 */
export declare class TokenProviderError extends ProviderError {
    name: string;
    /**
     * @override
     * @deprecated constructor should be given a logger.
     */
    constructor(message: string);
    /**
     * @override
     * @deprecated constructor should be given a logger.
     */
    constructor(message: string, tryNextLink: boolean | undefined);
    /**
     * @override
     * This signature is preferred for logging capability.
     */
    constructor(message: string, options: ProviderErrorOptionsType);
}

```

## ./lib/lambda/node_modules/@smithy/property-provider/dist-types/chain.d.ts

```typescript
import type { Provider } from "@smithy/types";
/**
 * @internal
 *
 * Compose a single credential provider function from multiple credential
 * providers. The first provider in the argument list will always be invoked;
 * subsequent providers in the list will be invoked in the order in which the
 * were received if the preceding provider did not successfully resolve.
 *
 * If no providers were received or no provider resolves successfully, the
 * returned promise will be rejected.
 */
export declare const chain: <T>(...providers: Array<Provider<T>>) => Provider<T>;

```

## ./lib/lambda/node_modules/@smithy/property-provider/dist-types/fromStatic.d.ts

```typescript
import type { Provider } from "@smithy/types";
/**
 * @internal
 */
export declare const fromStatic: <T>(staticValue: T) => Provider<T>;

```

## ./lib/lambda/node_modules/@smithy/property-provider/dist-types/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./CredentialsProviderError";
/**
 * @internal
 */
export * from "./ProviderError";
/**
 * @internal
 */
export * from "./TokenProviderError";
/**
 * @internal
 */
export * from "./chain";
/**
 * @internal
 */
export * from "./fromStatic";
/**
 * @internal
 */
export * from "./memoize";

```

## ./lib/lambda/node_modules/@smithy/property-provider/dist-types/memoize.d.ts

```typescript
import type { MemoizedProvider, Provider } from "@smithy/types";
interface MemoizeOverload {
    /**
     *
     * Decorates a provider function with either static memoization.
     *
     * To create a statically memoized provider, supply a provider as the only
     * argument to this function. The provider will be invoked once, and all
     * invocations of the provider returned by `memoize` will return the same
     * promise object.
     *
     * @param provider The provider whose result should be cached indefinitely.
     */
    <T>(provider: Provider<T>): MemoizedProvider<T>;
    /**
     * Decorates a provider function with refreshing memoization.
     *
     * @param provider          The provider whose result should be cached.
     * @param isExpired         A function that will evaluate the resolved value and
     *                          determine if it is expired. For example, when
     *                          memoizing AWS credential providers, this function
     *                          should return `true` when the credential's
     *                          expiration is in the past (or very near future) and
     *                          `false` otherwise.
     * @param requiresRefresh   A function that will evaluate the resolved value and
     *                          determine if it represents static value or one that
     *                          will eventually need to be refreshed. For example,
     *                          AWS credentials that have no defined expiration will
     *                          never need to be refreshed, so this function would
     *                          return `true` if the credentials resolved by the
     *                          underlying provider had an expiration and `false`
     *                          otherwise.
     */
    <T>(provider: Provider<T>, isExpired: (resolved: T) => boolean, requiresRefresh?: (resolved: T) => boolean): MemoizedProvider<T>;
}
/**
 * @internal
 */
export declare const memoize: MemoizeOverload;
export {};

```

## ./lib/lambda/node_modules/@smithy/property-provider/dist-types/ts3.4/CredentialsProviderError.d.ts

```typescript
import { ProviderErrorOptionsType } from "./ProviderError";
import { ProviderError } from "./ProviderError";
/**
 * @public
 *
 * An error representing a failure of an individual credential provider.
 *
 * This error class has special meaning to the {@link chain} method. If a
 * provider in the chain is rejected with an error, the chain will only proceed
 * to the next provider if the value of the `tryNextLink` property on the error
 * is truthy. This allows individual providers to halt the chain and also
 * ensures the chain will stop if an entirely unexpected error is encountered.
 */
export declare class CredentialsProviderError extends ProviderError {
    name: string;
    /**
     * @override
     * @deprecated constructor should be given a logger.
     */
    constructor(message: string);
    /**
     * @override
     * @deprecated constructor should be given a logger.
     */
    constructor(message: string, tryNextLink: boolean | undefined);
    /**
     * @override
     * This signature is preferred for logging capability.
     */
    constructor(message: string, options: ProviderErrorOptionsType);
}

```

## ./lib/lambda/node_modules/@smithy/property-provider/dist-types/ts3.4/ProviderError.d.ts

```typescript
import { Logger } from "@smithy/types";
/**
 * @public
 */
export type ProviderErrorOptionsType = {
    tryNextLink?: boolean | undefined;
    logger?: Logger;
};
/**
 * @public
 *
 * An error representing a failure of an individual provider.
 *
 * This error class has special meaning to the {@link chain} method. If a
 * provider in the chain is rejected with an error, the chain will only proceed
 * to the next provider if the value of the `tryNextLink` property on the error
 * is truthy. This allows individual providers to halt the chain and also
 * ensures the chain will stop if an entirely unexpected error is encountered.
 */
export declare class ProviderError extends Error {
    name: string;
    readonly tryNextLink: boolean;
    /**
     * @deprecated constructor should be given a logger.
     */
    constructor(message: string);
    /**
     * @deprecated constructor should be given a logger.
     */
    constructor(message: string, tryNextLink: boolean | undefined);
    /**
     * This signature is preferred for logging capability.
     */
    constructor(message: string, options: ProviderErrorOptionsType);
    /**
     * @deprecated use new operator.
     */
    static from(error: Error, options?: boolean | ProviderErrorOptionsType): ProviderError;
}

```

## ./lib/lambda/node_modules/@smithy/property-provider/dist-types/ts3.4/TokenProviderError.d.ts

```typescript
import { ProviderErrorOptionsType } from "./ProviderError";
import { ProviderError } from "./ProviderError";
/**
 * @public
 *
 * An error representing a failure of an individual token provider.
 *
 * This error class has special meaning to the {@link chain} method. If a
 * provider in the chain is rejected with an error, the chain will only proceed
 * to the next provider if the value of the `tryNextLink` property on the error
 * is truthy. This allows individual providers to halt the chain and also
 * ensures the chain will stop if an entirely unexpected error is encountered.
 */
export declare class TokenProviderError extends ProviderError {
    name: string;
    /**
     * @override
     * @deprecated constructor should be given a logger.
     */
    constructor(message: string);
    /**
     * @override
     * @deprecated constructor should be given a logger.
     */
    constructor(message: string, tryNextLink: boolean | undefined);
    /**
     * @override
     * This signature is preferred for logging capability.
     */
    constructor(message: string, options: ProviderErrorOptionsType);
}

```

## ./lib/lambda/node_modules/@smithy/property-provider/dist-types/ts3.4/chain.d.ts

```typescript
import { Provider } from "@smithy/types";
/**
 * @internal
 *
 * Compose a single credential provider function from multiple credential
 * providers. The first provider in the argument list will always be invoked;
 * subsequent providers in the list will be invoked in the order in which the
 * were received if the preceding provider did not successfully resolve.
 *
 * If no providers were received or no provider resolves successfully, the
 * returned promise will be rejected.
 */
export declare const chain: <T>(...providers: Array<Provider<T>>) => Provider<T>;

```

## ./lib/lambda/node_modules/@smithy/property-provider/dist-types/ts3.4/fromStatic.d.ts

```typescript
import { Provider } from "@smithy/types";
/**
 * @internal
 */
export declare const fromStatic: <T>(staticValue: T) => Provider<T>;

```

## ./lib/lambda/node_modules/@smithy/property-provider/dist-types/ts3.4/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./CredentialsProviderError";
/**
 * @internal
 */
export * from "./ProviderError";
/**
 * @internal
 */
export * from "./TokenProviderError";
/**
 * @internal
 */
export * from "./chain";
/**
 * @internal
 */
export * from "./fromStatic";
/**
 * @internal
 */
export * from "./memoize";

```

## ./lib/lambda/node_modules/@smithy/property-provider/dist-types/ts3.4/memoize.d.ts

```typescript
import { MemoizedProvider, Provider } from "@smithy/types";
interface MemoizeOverload {
    /**
     *
     * Decorates a provider function with either static memoization.
     *
     * To create a statically memoized provider, supply a provider as the only
     * argument to this function. The provider will be invoked once, and all
     * invocations of the provider returned by `memoize` will return the same
     * promise object.
     *
     * @param provider The provider whose result should be cached indefinitely.
     */
    <T>(provider: Provider<T>): MemoizedProvider<T>;
    /**
     * Decorates a provider function with refreshing memoization.
     *
     * @param provider          The provider whose result should be cached.
     * @param isExpired         A function that will evaluate the resolved value and
     *                          determine if it is expired. For example, when
     *                          memoizing AWS credential providers, this function
     *                          should return `true` when the credential's
     *                          expiration is in the past (or very near future) and
     *                          `false` otherwise.
     * @param requiresRefresh   A function that will evaluate the resolved value and
     *                          determine if it represents static value or one that
     *                          will eventually need to be refreshed. For example,
     *                          AWS credentials that have no defined expiration will
     *                          never need to be refreshed, so this function would
     *                          return `true` if the credentials resolved by the
     *                          underlying provider had an expiration and `false`
     *                          otherwise.
     */
    <T>(provider: Provider<T>, isExpired: (resolved: T) => boolean, requiresRefresh?: (resolved: T) => boolean): MemoizedProvider<T>;
}
/**
 * @internal
 */
export declare const memoize: MemoizeOverload;
export {};

```

## ./lib/lambda/node_modules/@smithy/property-provider/package.json

```json
{
  "name": "@smithy/property-provider",
  "version": "4.2.3",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline property-provider",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "rimraf dist-types/ts3.4 && downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../../.prettierignore --write \"**/*.{ts,md,json}\"",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "sideEffects": false,
  "dependencies": {
    "@smithy/types": "^4.8.0",
    "tslib": "^2.6.2"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/smithy-lang/smithy-typescript/tree/main/packages/property-provider",
  "repository": {
    "type": "git",
    "url": "https://github.com/smithy-lang/smithy-typescript.git",
    "directory": "packages/property-provider"
  },
  "devDependencies": {
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  }
}
```

## ./lib/lambda/node_modules/@smithy/protocol-http/dist-types/Field.d.ts

```typescript
import type { FieldOptions } from "@smithy/types";
import { FieldPosition } from "@smithy/types";
/**
 * A name-value pair representing a single field
 * transmitted in an HTTP Request or Response.
 *
 * The kind will dictate metadata placement within
 * an HTTP message.
 *
 * All field names are case insensitive and
 * case-variance must be treated as equivalent.
 * Names MAY be normalized but SHOULD be preserved
 * for accuracy during transmission.
 */
export declare class Field {
    readonly name: string;
    readonly kind: FieldPosition;
    values: string[];
    constructor({ name, kind, values }: FieldOptions);
    /**
     * Appends a value to the field.
     *
     * @param value The value to append.
     */
    add(value: string): void;
    /**
     * Overwrite existing field values.
     *
     * @param values The new field values.
     */
    set(values: string[]): void;
    /**
     * Remove all matching entries from list.
     *
     * @param value Value to remove.
     */
    remove(value: string): void;
    /**
     * Get comma-delimited string.
     *
     * @returns String representation of {@link Field}.
     */
    toString(): string;
    /**
     * Get string values as a list
     *
     * @returns Values in {@link Field} as a list.
     */
    get(): string[];
}

```

## ./lib/lambda/node_modules/@smithy/protocol-http/dist-types/Fields.d.ts

```typescript
import type { FieldPosition } from "@smithy/types";
import type { Field } from "./Field";
export type FieldsOptions = {
    fields?: Field[];
    encoding?: string;
};
/**
 * Collection of Field entries mapped by name.
 */
export declare class Fields {
    private readonly entries;
    private readonly encoding;
    constructor({ fields, encoding }: FieldsOptions);
    /**
     * Set entry for a {@link Field} name. The `name`
     * attribute will be used to key the collection.
     *
     * @param field The {@link Field} to set.
     */
    setField(field: Field): void;
    /**
     *  Retrieve {@link Field} entry by name.
     *
     * @param name The name of the {@link Field} entry
     *  to retrieve
     * @returns The {@link Field} if it exists.
     */
    getField(name: string): Field | undefined;
    /**
     * Delete entry from collection.
     *
     * @param name Name of the entry to delete.
     */
    removeField(name: string): void;
    /**
     * Helper function for retrieving specific types of fields.
     * Used to grab all headers or all trailers.
     *
     * @param kind {@link FieldPosition} of entries to retrieve.
     * @returns The {@link Field} entries with the specified
     *  {@link FieldPosition}.
     */
    getByType(kind: FieldPosition): Field[];
}

```

## ./lib/lambda/node_modules/@smithy/protocol-http/dist-types/extensions/httpExtensionConfiguration.d.ts

```typescript
import type { HttpHandler } from "../httpHandler";
/**
 * @internal
 */
export interface HttpHandlerExtensionConfiguration<HandlerConfig extends object = {}> {
    setHttpHandler(handler: HttpHandler<HandlerConfig>): void;
    httpHandler(): HttpHandler<HandlerConfig>;
    updateHttpClientConfig(key: keyof HandlerConfig, value: HandlerConfig[typeof key]): void;
    httpHandlerConfigs(): HandlerConfig;
}
/**
 * @internal
 */
export type HttpHandlerExtensionConfigType<HandlerConfig extends object = {}> = Partial<{
    httpHandler: HttpHandler<HandlerConfig>;
}>;
/**
 * @internal
 *
 * Helper function to resolve default extension configuration from runtime config
 */
export declare const getHttpHandlerExtensionConfiguration: <HandlerConfig extends object = {}>(runtimeConfig: HttpHandlerExtensionConfigType<HandlerConfig>) => {
    setHttpHandler(handler: HttpHandler<HandlerConfig>): void;
    httpHandler(): HttpHandler<HandlerConfig>;
    updateHttpClientConfig(key: keyof HandlerConfig, value: HandlerConfig[typeof key]): void;
    httpHandlerConfigs(): HandlerConfig;
};
/**
 * @internal
 *
 * Helper function to resolve runtime config from default extension configuration
 */
export declare const resolveHttpHandlerRuntimeConfig: <HandlerConfig extends object = {}>(httpHandlerExtensionConfiguration: HttpHandlerExtensionConfiguration<HandlerConfig>) => HttpHandlerExtensionConfigType<HandlerConfig>;

```

## ./lib/lambda/node_modules/@smithy/protocol-http/dist-types/extensions/index.d.ts

```typescript
export * from "./httpExtensionConfiguration";

```

## ./lib/lambda/node_modules/@smithy/protocol-http/dist-types/httpHandler.d.ts

```typescript
import type { FetchHttpHandlerOptions, HttpHandlerOptions, NodeHttpHandlerOptions, RequestHandler } from "@smithy/types";
import type { HttpRequest } from "./httpRequest";
import type { HttpResponse } from "./httpResponse";
/**
 * @internal
 */
export type HttpHandler<HttpHandlerConfig extends object = {}> = RequestHandler<HttpRequest, HttpResponse, HttpHandlerOptions> & {
    /**
     * @internal
     */
    updateHttpClientConfig(key: keyof HttpHandlerConfig, value: HttpHandlerConfig[typeof key]): void;
    /**
     * @internal
     */
    httpHandlerConfigs(): HttpHandlerConfig;
};
/**
 * @public
 *
 * A type representing the accepted user inputs for the `requestHandler` field
 * of a client's constructor object.
 *
 * You may provide an instance of an HttpHandler, or alternatively
 * provide the constructor arguments as an object which will be passed
 * to the constructor of the default request handler.
 *
 * The default class constructor to which your arguments will be passed
 * varies. The Node.js default is the NodeHttpHandler and the browser/react-native
 * default is the FetchHttpHandler. In rarer cases specific clients may be
 * configured to use other default implementations such as Websocket or HTTP2.
 *
 * The fallback type Record<string, unknown> is part of the union to allow
 * passing constructor params to an unknown requestHandler type.
 */
export type HttpHandlerUserInput = HttpHandler | NodeHttpHandlerOptions | FetchHttpHandlerOptions | Record<string, unknown>;

```

## ./lib/lambda/node_modules/@smithy/protocol-http/dist-types/httpRequest.d.ts

```typescript
import type { HeaderBag, HttpMessage, QueryParameterBag, URI } from "@smithy/types";
import { HttpRequest as IHttpRequest } from "@smithy/types";
type HttpRequestOptions = Partial<HttpMessage> & Partial<URI> & {
    method?: string;
};
/**
 * Use the distinct IHttpRequest interface from \@smithy/types instead.
 * This should not be used due to
 * overlapping with the concrete class' name.
 *
 * This is not marked deprecated since that would mark the concrete class
 * deprecated as well.
 *
 * @internal
 */
export interface HttpRequest extends IHttpRequest {
}
/**
 * @public
 */
export { IHttpRequest };
/**
 * @public
 */
export declare class HttpRequest implements HttpMessage, URI {
    method: string;
    protocol: string;
    hostname: string;
    port?: number;
    path: string;
    query: QueryParameterBag;
    headers: HeaderBag;
    username?: string;
    password?: string;
    fragment?: string;
    body?: any;
    constructor(options: HttpRequestOptions);
    /**
     * Note: this does not deep-clone the body.
     */
    static clone(request: IHttpRequest): HttpRequest;
    /**
     * This method only actually asserts that request is the interface {@link IHttpRequest},
     * and not necessarily this concrete class. Left in place for API stability.
     *
     * Do not call instance methods on the input of this function, and
     * do not assume it has the HttpRequest prototype.
     */
    static isInstance(request: unknown): request is HttpRequest;
    /**
     * @deprecated use static HttpRequest.clone(request) instead. It's not safe to call
     * this method because {@link HttpRequest.isInstance} incorrectly
     * asserts that IHttpRequest (interface) objects are of type HttpRequest (class).
     */
    clone(): HttpRequest;
}

```

## ./lib/lambda/node_modules/@smithy/protocol-http/dist-types/httpResponse.d.ts

```typescript
import type { HeaderBag, HttpMessage, HttpResponse as IHttpResponse } from "@smithy/types";
type HttpResponseOptions = Partial<HttpMessage> & {
    statusCode: number;
    reason?: string;
};
/**
 * Use the distinct IHttpResponse interface from \@smithy/types instead.
 * This should not be used due to
 * overlapping with the concrete class' name.
 *
 * This is not marked deprecated since that would mark the concrete class
 * deprecated as well.
 *
 * @internal
 */
export interface HttpResponse extends IHttpResponse {
}
/**
 * @public
 */
export declare class HttpResponse {
    statusCode: number;
    reason?: string;
    headers: HeaderBag;
    body?: any;
    constructor(options: HttpResponseOptions);
    static isInstance(response: unknown): response is HttpResponse;
}
export {};

```

## ./lib/lambda/node_modules/@smithy/protocol-http/dist-types/index.d.ts

```typescript
export * from "./extensions";
export * from "./Field";
export * from "./Fields";
export * from "./httpHandler";
export * from "./httpRequest";
export * from "./httpResponse";
export * from "./isValidHostname";
export * from "./types";

```

## ./lib/lambda/node_modules/@smithy/protocol-http/dist-types/isValidHostname.d.ts

```typescript
export declare function isValidHostname(hostname: string): boolean;

```

## ./lib/lambda/node_modules/@smithy/protocol-http/dist-types/ts3.4/Field.d.ts

```typescript
import { FieldOptions } from "@smithy/types";
import { FieldPosition } from "@smithy/types";
/**
 * A name-value pair representing a single field
 * transmitted in an HTTP Request or Response.
 *
 * The kind will dictate metadata placement within
 * an HTTP message.
 *
 * All field names are case insensitive and
 * case-variance must be treated as equivalent.
 * Names MAY be normalized but SHOULD be preserved
 * for accuracy during transmission.
 */
export declare class Field {
    readonly name: string;
    readonly kind: FieldPosition;
    values: string[];
    constructor({ name, kind, values }: FieldOptions);
    /**
     * Appends a value to the field.
     *
     * @param value The value to append.
     */
    add(value: string): void;
    /**
     * Overwrite existing field values.
     *
     * @param values The new field values.
     */
    set(values: string[]): void;
    /**
     * Remove all matching entries from list.
     *
     * @param value Value to remove.
     */
    remove(value: string): void;
    /**
     * Get comma-delimited string.
     *
     * @returns String representation of {@link Field}.
     */
    toString(): string;
    /**
     * Get string values as a list
     *
     * @returns Values in {@link Field} as a list.
     */
    get(): string[];
}

```

## ./lib/lambda/node_modules/@smithy/protocol-http/dist-types/ts3.4/Fields.d.ts

```typescript
import { FieldPosition } from "@smithy/types";
import { Field } from "./Field";
export type FieldsOptions = {
    fields?: Field[];
    encoding?: string;
};
/**
 * Collection of Field entries mapped by name.
 */
export declare class Fields {
    private readonly entries;
    private readonly encoding;
    constructor({ fields, encoding }: FieldsOptions);
    /**
     * Set entry for a {@link Field} name. The `name`
     * attribute will be used to key the collection.
     *
     * @param field The {@link Field} to set.
     */
    setField(field: Field): void;
    /**
     *  Retrieve {@link Field} entry by name.
     *
     * @param name The name of the {@link Field} entry
     *  to retrieve
     * @returns The {@link Field} if it exists.
     */
    getField(name: string): Field | undefined;
    /**
     * Delete entry from collection.
     *
     * @param name Name of the entry to delete.
     */
    removeField(name: string): void;
    /**
     * Helper function for retrieving specific types of fields.
     * Used to grab all headers or all trailers.
     *
     * @param kind {@link FieldPosition} of entries to retrieve.
     * @returns The {@link Field} entries with the specified
     *  {@link FieldPosition}.
     */
    getByType(kind: FieldPosition): Field[];
}

```

## ./lib/lambda/node_modules/@smithy/protocol-http/dist-types/ts3.4/extensions/httpExtensionConfiguration.d.ts

```typescript
import { HttpHandler } from "../httpHandler";
/**
 * @internal
 */
export interface HttpHandlerExtensionConfiguration<HandlerConfig extends object = {}> {
    setHttpHandler(handler: HttpHandler<HandlerConfig>): void;
    httpHandler(): HttpHandler<HandlerConfig>;
    updateHttpClientConfig(key: keyof HandlerConfig, value: HandlerConfig[typeof key]): void;
    httpHandlerConfigs(): HandlerConfig;
}
/**
 * @internal
 */
export type HttpHandlerExtensionConfigType<HandlerConfig extends object = {}> = Partial<{
    httpHandler: HttpHandler<HandlerConfig>;
}>;
/**
 * @internal
 *
 * Helper function to resolve default extension configuration from runtime config
 */
export declare const getHttpHandlerExtensionConfiguration: <HandlerConfig extends object = {}>(runtimeConfig: HttpHandlerExtensionConfigType<HandlerConfig>) => {
    setHttpHandler(handler: HttpHandler<HandlerConfig>): void;
    httpHandler(): HttpHandler<HandlerConfig>;
    updateHttpClientConfig(key: keyof HandlerConfig, value: HandlerConfig[typeof key]): void;
    httpHandlerConfigs(): HandlerConfig;
};
/**
 * @internal
 *
 * Helper function to resolve runtime config from default extension configuration
 */
export declare const resolveHttpHandlerRuntimeConfig: <HandlerConfig extends object = {}>(httpHandlerExtensionConfiguration: HttpHandlerExtensionConfiguration<HandlerConfig>) => HttpHandlerExtensionConfigType<HandlerConfig>;

```

## ./lib/lambda/node_modules/@smithy/protocol-http/dist-types/ts3.4/extensions/index.d.ts

```typescript
export * from "./httpExtensionConfiguration";

```

## ./lib/lambda/node_modules/@smithy/protocol-http/dist-types/ts3.4/httpHandler.d.ts

```typescript
import { FetchHttpHandlerOptions, HttpHandlerOptions, NodeHttpHandlerOptions, RequestHandler } from "@smithy/types";
import { HttpRequest } from "./httpRequest";
import { HttpResponse } from "./httpResponse";
/**
 * @internal
 */
export type HttpHandler<HttpHandlerConfig extends object = {}> = RequestHandler<HttpRequest, HttpResponse, HttpHandlerOptions> & {
    /**
     * @internal
     */
    updateHttpClientConfig(key: keyof HttpHandlerConfig, value: HttpHandlerConfig[typeof key]): void;
    /**
     * @internal
     */
    httpHandlerConfigs(): HttpHandlerConfig;
};
/**
 * @public
 *
 * A type representing the accepted user inputs for the `requestHandler` field
 * of a client's constructor object.
 *
 * You may provide an instance of an HttpHandler, or alternatively
 * provide the constructor arguments as an object which will be passed
 * to the constructor of the default request handler.
 *
 * The default class constructor to which your arguments will be passed
 * varies. The Node.js default is the NodeHttpHandler and the browser/react-native
 * default is the FetchHttpHandler. In rarer cases specific clients may be
 * configured to use other default implementations such as Websocket or HTTP2.
 *
 * The fallback type Record<string, unknown> is part of the union to allow
 * passing constructor params to an unknown requestHandler type.
 */
export type HttpHandlerUserInput = HttpHandler | NodeHttpHandlerOptions | FetchHttpHandlerOptions | Record<string, unknown>;

```

## ./lib/lambda/node_modules/@smithy/protocol-http/dist-types/ts3.4/httpRequest.d.ts

```typescript
import { HeaderBag, HttpMessage, QueryParameterBag, URI } from "@smithy/types";
import { HttpRequest as IHttpRequest } from "@smithy/types";
type HttpRequestOptions = Partial<HttpMessage> & Partial<URI> & {
    method?: string;
};
/**
 * Use the distinct IHttpRequest interface from \@smithy/types instead.
 * This should not be used due to
 * overlapping with the concrete class' name.
 *
 * This is not marked deprecated since that would mark the concrete class
 * deprecated as well.
 *
 * @internal
 */
export interface HttpRequest extends IHttpRequest {
}
/**
 * @public
 */
export { IHttpRequest };
/**
 * @public
 */
export declare class HttpRequest implements HttpMessage, URI {
    method: string;
    protocol: string;
    hostname: string;
    port?: number;
    path: string;
    query: QueryParameterBag;
    headers: HeaderBag;
    username?: string;
    password?: string;
    fragment?: string;
    body?: any;
    constructor(options: HttpRequestOptions);
    /**
     * Note: this does not deep-clone the body.
     */
    static clone(request: IHttpRequest): HttpRequest;
    /**
     * This method only actually asserts that request is the interface {@link IHttpRequest},
     * and not necessarily this concrete class. Left in place for API stability.
     *
     * Do not call instance methods on the input of this function, and
     * do not assume it has the HttpRequest prototype.
     */
    static isInstance(request: unknown): request is HttpRequest;
    /**
     * @deprecated use static HttpRequest.clone(request) instead. It's not safe to call
     * this method because {@link HttpRequest.isInstance} incorrectly
     * asserts that IHttpRequest (interface) objects are of type HttpRequest (class).
     */
    clone(): HttpRequest;
}

```

## ./lib/lambda/node_modules/@smithy/protocol-http/dist-types/ts3.4/httpResponse.d.ts

```typescript
import { HeaderBag, HttpMessage, HttpResponse as IHttpResponse } from "@smithy/types";
type HttpResponseOptions = Partial<HttpMessage> & {
    statusCode: number;
    reason?: string;
};
/**
 * Use the distinct IHttpResponse interface from \@smithy/types instead.
 * This should not be used due to
 * overlapping with the concrete class' name.
 *
 * This is not marked deprecated since that would mark the concrete class
 * deprecated as well.
 *
 * @internal
 */
export interface HttpResponse extends IHttpResponse {
}
/**
 * @public
 */
export declare class HttpResponse {
    statusCode: number;
    reason?: string;
    headers: HeaderBag;
    body?: any;
    constructor(options: HttpResponseOptions);
    static isInstance(response: unknown): response is HttpResponse;
}
export {};

```

## ./lib/lambda/node_modules/@smithy/protocol-http/dist-types/ts3.4/index.d.ts

```typescript
export * from "./extensions";
export * from "./Field";
export * from "./Fields";
export * from "./httpHandler";
export * from "./httpRequest";
export * from "./httpResponse";
export * from "./isValidHostname";
export * from "./types";

```

## ./lib/lambda/node_modules/@smithy/protocol-http/dist-types/ts3.4/isValidHostname.d.ts

```typescript
export declare function isValidHostname(hostname: string): boolean;

```

## ./lib/lambda/node_modules/@smithy/protocol-http/dist-types/ts3.4/types.d.ts

```typescript
import { FieldOptions as __FieldOptions, FieldPosition as __FieldPosition, HeaderBag as __HeaderBag, HttpHandlerOptions as __HttpHandlerOptions, HttpMessage as __HttpMessage } from "@smithy/types";
/**
 * @deprecated Use FieldOptions from `@smithy/types` instead
 */
export type FieldOptions = __FieldOptions;
/**
 * @deprecated Use FieldPosition from `@smithy/types` instead
 */
export type FieldPosition = __FieldPosition;
/**
 * @deprecated Use HeaderBag from `@smithy/types` instead
 */
export type HeaderBag = __HeaderBag;
/**
 * @deprecated Use HttpMessage from `@smithy/types` instead
 */
export type HttpMessage = __HttpMessage;
/**
 * @deprecated Use HttpHandlerOptions from `@smithy/types` instead
 */
export type HttpHandlerOptions = __HttpHandlerOptions;

```

## ./lib/lambda/node_modules/@smithy/protocol-http/dist-types/types.d.ts

```typescript
import type { FieldOptions as __FieldOptions, FieldPosition as __FieldPosition, HeaderBag as __HeaderBag, HttpHandlerOptions as __HttpHandlerOptions, HttpMessage as __HttpMessage } from "@smithy/types";
/**
 * @deprecated Use FieldOptions from `@smithy/types` instead
 */
export type FieldOptions = __FieldOptions;
/**
 * @deprecated Use FieldPosition from `@smithy/types` instead
 */
export type FieldPosition = __FieldPosition;
/**
 * @deprecated Use HeaderBag from `@smithy/types` instead
 */
export type HeaderBag = __HeaderBag;
/**
 * @deprecated Use HttpMessage from `@smithy/types` instead
 */
export type HttpMessage = __HttpMessage;
/**
 * @deprecated Use HttpHandlerOptions from `@smithy/types` instead
 */
export type HttpHandlerOptions = __HttpHandlerOptions;

```

## ./lib/lambda/node_modules/@smithy/protocol-http/package.json

```json
{
  "name": "@smithy/protocol-http",
  "version": "5.3.3",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline protocol-http",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "rimraf dist-types/ts3.4 && downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../../.prettierignore --write \"**/*.{ts,md,json}\"",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "author": {
    "name": "AWS Smithy Team",
    "email": "",
    "url": "https://smithy.io"
  },
  "license": "Apache-2.0",
  "sideEffects": false,
  "dependencies": {
    "@smithy/types": "^4.8.0",
    "tslib": "^2.6.2"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/smithy-lang/smithy-typescript/tree/main/packages/protocol-http",
  "repository": {
    "type": "git",
    "url": "https://github.com/smithy-lang/smithy-typescript.git",
    "directory": "packages/protocol-http"
  },
  "devDependencies": {
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  }
}
```

## ./lib/lambda/node_modules/@smithy/querystring-builder/dist-types/index.d.ts

```typescript
import type { QueryParameterBag } from "@smithy/types";
/**
 * @internal
 */
export declare function buildQueryString(query: QueryParameterBag): string;

```

## ./lib/lambda/node_modules/@smithy/querystring-builder/dist-types/ts3.4/index.d.ts

```typescript
import { QueryParameterBag } from "@smithy/types";
/**
 * @internal
 */
export declare function buildQueryString(query: QueryParameterBag): string;

```

## ./lib/lambda/node_modules/@smithy/querystring-builder/package.json

```json
{
  "name": "@smithy/querystring-builder",
  "version": "4.2.3",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline querystring-builder",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "rimraf dist-types/ts3.4 && downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../../.prettierignore --write \"**/*.{ts,md,json}\"",
    "test": "exit 0"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "sideEffects": false,
  "dependencies": {
    "@smithy/types": "^4.8.0",
    "@smithy/util-uri-escape": "^4.2.0",
    "tslib": "^2.6.2"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/smithy-lang/smithy-typescript/tree/main/packages/querystring-builder",
  "repository": {
    "type": "git",
    "url": "https://github.com/smithy-lang/smithy-typescript.git",
    "directory": "packages/querystring-builder"
  },
  "devDependencies": {
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  }
}
```

## ./lib/lambda/node_modules/@smithy/querystring-parser/dist-types/index.d.ts

```typescript
import type { QueryParameterBag } from "@smithy/types";
/**
 * @internal
 */
export declare function parseQueryString(querystring: string): QueryParameterBag;

```

## ./lib/lambda/node_modules/@smithy/querystring-parser/dist-types/ts3.4/index.d.ts

```typescript
import { QueryParameterBag } from "@smithy/types";
/**
 * @internal
 */
export declare function parseQueryString(querystring: string): QueryParameterBag;

```

## ./lib/lambda/node_modules/@smithy/querystring-parser/package.json

```json
{
  "name": "@smithy/querystring-parser",
  "version": "4.2.3",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline querystring-parser",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "rimraf dist-types/ts3.4 && downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../../.prettierignore --write \"**/*.{ts,md,json}\"",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "sideEffects": false,
  "dependencies": {
    "@smithy/types": "^4.8.0",
    "tslib": "^2.6.2"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/smithy-lang/smithy-typescript/tree/main/packages/querystring-parser",
  "repository": {
    "type": "git",
    "url": "https://github.com/smithy-lang/smithy-typescript.git",
    "directory": "packages/querystring-parser"
  },
  "devDependencies": {
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  }
}
```

## ./lib/lambda/node_modules/@smithy/service-error-classification/dist-types/constants.d.ts

```typescript
/**
 * Errors encountered when the client clock and server clock cannot agree on the
 * current time.
 *
 * These errors are retryable, assuming the SDK has enabled clock skew
 * correction.
 */
export declare const CLOCK_SKEW_ERROR_CODES: string[];
/**
 * Errors that indicate the SDK is being throttled.
 *
 * These errors are always retryable.
 */
export declare const THROTTLING_ERROR_CODES: string[];
/**
 * Error codes that indicate transient issues
 */
export declare const TRANSIENT_ERROR_CODES: string[];
/**
 * Error codes that indicate transient issues
 */
export declare const TRANSIENT_ERROR_STATUS_CODES: number[];
/**
 * Node.js system error codes that indicate timeout.
 */
export declare const NODEJS_TIMEOUT_ERROR_CODES: string[];
/**
 * Node.js system error codes that indicate network error.
 */
export declare const NODEJS_NETWORK_ERROR_CODES: string[];

```

## ./lib/lambda/node_modules/@smithy/service-error-classification/dist-types/index.d.ts

```typescript
import type { SdkError } from "@smithy/types";
export declare const isRetryableByTrait: (error: SdkError) => boolean;
/**
 * @deprecated use isClockSkewCorrectedError. This is only used in deprecated code.
 */
export declare const isClockSkewError: (error: SdkError) => boolean;
/**
 * @returns whether the error resulted in a systemClockOffset aka clock skew correction.
 */
export declare const isClockSkewCorrectedError: (error: SdkError) => true | undefined;
/**
 *
 * @internal
 */
export declare const isBrowserNetworkError: (error: SdkError) => boolean;
export declare const isThrottlingError: (error: SdkError) => boolean;
/**
 * Though NODEJS_TIMEOUT_ERROR_CODES are platform specific, they are
 * included here because there is an error scenario with unknown root
 * cause where the NodeHttpHandler does not decorate the Error with
 * the name "TimeoutError" to be checked by the TRANSIENT_ERROR_CODES condition.
 */
export declare const isTransientError: (error: SdkError, depth?: number) => boolean;
export declare const isServerError: (error: SdkError) => boolean;

```

## ./lib/lambda/node_modules/@smithy/service-error-classification/dist-types/ts3.4/constants.d.ts

```typescript
/**
 * Errors encountered when the client clock and server clock cannot agree on the
 * current time.
 *
 * These errors are retryable, assuming the SDK has enabled clock skew
 * correction.
 */
export declare const CLOCK_SKEW_ERROR_CODES: string[];
/**
 * Errors that indicate the SDK is being throttled.
 *
 * These errors are always retryable.
 */
export declare const THROTTLING_ERROR_CODES: string[];
/**
 * Error codes that indicate transient issues
 */
export declare const TRANSIENT_ERROR_CODES: string[];
/**
 * Error codes that indicate transient issues
 */
export declare const TRANSIENT_ERROR_STATUS_CODES: number[];
/**
 * Node.js system error codes that indicate timeout.
 */
export declare const NODEJS_TIMEOUT_ERROR_CODES: string[];
/**
 * Node.js system error codes that indicate network error.
 */
export declare const NODEJS_NETWORK_ERROR_CODES: string[];

```

## ./lib/lambda/node_modules/@smithy/service-error-classification/dist-types/ts3.4/index.d.ts

```typescript
import { SdkError } from "@smithy/types";
export declare const isRetryableByTrait: (error: SdkError) => boolean;
/**
 * @deprecated use isClockSkewCorrectedError. This is only used in deprecated code.
 */
export declare const isClockSkewError: (error: SdkError) => boolean;
/**
 * @returns whether the error resulted in a systemClockOffset aka clock skew correction.
 */
export declare const isClockSkewCorrectedError: (error: SdkError) => true | undefined;
/**
 *
 * @internal
 */
export declare const isBrowserNetworkError: (error: SdkError) => boolean;
export declare const isThrottlingError: (error: SdkError) => boolean;
/**
 * Though NODEJS_TIMEOUT_ERROR_CODES are platform specific, they are
 * included here because there is an error scenario with unknown root
 * cause where the NodeHttpHandler does not decorate the Error with
 * the name "TimeoutError" to be checked by the TRANSIENT_ERROR_CODES condition.
 */
export declare const isTransientError: (error: SdkError, depth?: number) => boolean;
export declare const isServerError: (error: SdkError) => boolean;

```

## ./lib/lambda/node_modules/@smithy/service-error-classification/package.json

```json
{
  "name": "@smithy/service-error-classification",
  "version": "4.2.3",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline service-error-classification",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "rimraf dist-types/ts3.4 && downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../../.prettierignore --write \"**/*.{ts,md,json}\"",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "sideEffects": false,
  "devDependencies": {
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/smithy-lang/smithy-typescript/tree/main/packages/service-error-classification",
  "repository": {
    "type": "git",
    "url": "https://github.com/smithy-lang/smithy-typescript.git",
    "directory": "packages/service-error-classification"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  },
  "dependencies": {
    "@smithy/types": "^4.8.0"
  }
}
```

## ./lib/lambda/node_modules/@smithy/shared-ini-file-loader/dist-types/constants.d.ts

```typescript
/**
 * @internal
 */
export declare const CONFIG_PREFIX_SEPARATOR = ".";

```

## ./lib/lambda/node_modules/@smithy/shared-ini-file-loader/dist-types/externalDataInterceptor.d.ts

```typescript
/**
 * @internal
 */
export declare const externalDataInterceptor: {
    getFileRecord(): Record<string, Promise<string>>;
    interceptFile(path: string, contents: string): void;
    getTokenRecord(): Record<string, any>;
    interceptToken(id: string, contents: any): void;
};

```

## ./lib/lambda/node_modules/@smithy/shared-ini-file-loader/dist-types/getConfigData.d.ts

```typescript
import type { ParsedIniData } from "@smithy/types";
/**
 * Returns the config data from parsed ini data.
 * * Returns data for `default`
 * * Returns profile name without prefix.
 * * Returns non-profiles as is.
 */
export declare const getConfigData: (data: ParsedIniData) => ParsedIniData;

```

## ./lib/lambda/node_modules/@smithy/shared-ini-file-loader/dist-types/getConfigFilepath.d.ts

```typescript
export declare const ENV_CONFIG_PATH = "AWS_CONFIG_FILE";
export declare const getConfigFilepath: () => string;

```

## ./lib/lambda/node_modules/@smithy/shared-ini-file-loader/dist-types/getCredentialsFilepath.d.ts

```typescript
export declare const ENV_CREDENTIALS_PATH = "AWS_SHARED_CREDENTIALS_FILE";
export declare const getCredentialsFilepath: () => string;

```

## ./lib/lambda/node_modules/@smithy/shared-ini-file-loader/dist-types/getHomeDir.d.ts

```typescript
/**
 * Get the HOME directory for the current runtime.
 *
 * @internal
 */
export declare const getHomeDir: () => string;

```

## ./lib/lambda/node_modules/@smithy/shared-ini-file-loader/dist-types/getProfileName.d.ts

```typescript
/**
 * @internal
 */
export declare const ENV_PROFILE = "AWS_PROFILE";
/**
 * @internal
 */
export declare const DEFAULT_PROFILE = "default";
/**
 * Returns profile with priority order code - ENV - default.
 * @internal
 */
export declare const getProfileName: (init: {
    profile?: string;
}) => string;

```

## ./lib/lambda/node_modules/@smithy/shared-ini-file-loader/dist-types/getSSOTokenFilepath.d.ts

```typescript
/**
 * Returns the filepath of the file where SSO token is stored.
 * @internal
 */
export declare const getSSOTokenFilepath: (id: string) => string;

```

## ./lib/lambda/node_modules/@smithy/shared-ini-file-loader/dist-types/getSSOTokenFromFile.d.ts

```typescript
/**
 * Cached SSO token retrieved from SSO login flow.
 * @public
 */
export interface SSOToken {
    /**
     * A base64 encoded string returned by the sso-oidc service.
     */
    accessToken: string;
    /**
     * The expiration time of the accessToken as an RFC 3339 formatted timestamp.
     */
    expiresAt: string;
    /**
     * The token used to obtain an access token in the event that the accessToken is invalid or expired.
     */
    refreshToken?: string;
    /**
     * The unique identifier string for each client. The client ID generated when performing the registration
     * portion of the OIDC authorization flow. This is used to refresh the accessToken.
     */
    clientId?: string;
    /**
     * A secret string generated when performing the registration portion of the OIDC authorization flow.
     * This is used to refresh the accessToken.
     */
    clientSecret?: string;
    /**
     * The expiration time of the client registration (clientId and clientSecret) as an RFC 3339 formatted timestamp.
     */
    registrationExpiresAt?: string;
    /**
     * The configured sso_region for the profile that credentials are being resolved for.
     */
    region?: string;
    /**
     * The configured sso_start_url for the profile that credentials are being resolved for.
     */
    startUrl?: string;
}
/**
 * @internal
 */
export declare const tokenIntercept: Record<string, any>;
/**
 * @internal
 * @param id - can be either a start URL or the SSO session name.
 * Returns the SSO token from the file system.
 */
export declare const getSSOTokenFromFile: (id: string) => Promise<any>;

```

## ./lib/lambda/node_modules/@smithy/shared-ini-file-loader/dist-types/getSsoSessionData.d.ts

```typescript
import type { ParsedIniData } from "@smithy/types";
/**
 * Returns the sso-session data from parsed ini data by reading
 * ssoSessionName after sso-session prefix including/excluding quotes
 */
export declare const getSsoSessionData: (data: ParsedIniData) => ParsedIniData;

```

## ./lib/lambda/node_modules/@smithy/shared-ini-file-loader/dist-types/index.d.ts

```typescript
export * from "./getHomeDir";
export * from "./getProfileName";
export * from "./getSSOTokenFilepath";
export { getSSOTokenFromFile, SSOToken } from "./getSSOTokenFromFile";
export * from "./loadSharedConfigFiles";
export * from "./loadSsoSessionData";
export * from "./parseKnownFiles";
export { externalDataInterceptor } from "./externalDataInterceptor";
export * from "./types";

```

## ./lib/lambda/node_modules/@smithy/shared-ini-file-loader/dist-types/loadSharedConfigFiles.d.ts

```typescript
import type { Logger, SharedConfigFiles } from "@smithy/types";
/**
 * @public
 */
export interface SharedConfigInit {
    /**
     * The path at which to locate the ini credentials file. Defaults to the
     * value of the `AWS_SHARED_CREDENTIALS_FILE` environment variable (if
     * defined) or `~/.aws/credentials` otherwise.
     */
    filepath?: string;
    /**
     * The path at which to locate the ini config file. Defaults to the value of
     * the `AWS_CONFIG_FILE` environment variable (if defined) or
     * `~/.aws/config` otherwise.
     */
    configFilepath?: string;
    /**
     * Configuration files are normally cached after the first time they are loaded. When this
     * property is set, the provider will always reload any configuration files loaded before.
     */
    ignoreCache?: boolean;
    /**
     * For credential resolution trace logging.
     */
    logger?: Logger;
}
export { CONFIG_PREFIX_SEPARATOR } from "./constants";
/**
 * Loads the config and credentials files.
 * @internal
 */
export declare const loadSharedConfigFiles: (init?: SharedConfigInit) => Promise<SharedConfigFiles>;

```

## ./lib/lambda/node_modules/@smithy/shared-ini-file-loader/dist-types/loadSsoSessionData.d.ts

```typescript
import type { ParsedIniData } from "@smithy/types";
/**
 * Subset of {@link SharedConfigInit}.
 * @internal
 */
export interface SsoSessionInit {
    /**
     * The path at which to locate the ini config file. Defaults to the value of
     * the `AWS_CONFIG_FILE` environment variable (if defined) or
     * `~/.aws/config` otherwise.
     */
    configFilepath?: string;
}
/**
 * @internal
 */
export declare const loadSsoSessionData: (init?: SsoSessionInit) => Promise<ParsedIniData>;

```

## ./lib/lambda/node_modules/@smithy/shared-ini-file-loader/dist-types/mergeConfigFiles.d.ts

```typescript
import type { ParsedIniData } from "@smithy/types";
/**
 * Merge multiple profile config files such that settings each file are kept together
 *
 * @internal
 */
export declare const mergeConfigFiles: (...files: ParsedIniData[]) => ParsedIniData;

```

## ./lib/lambda/node_modules/@smithy/shared-ini-file-loader/dist-types/parseIni.d.ts

```typescript
import type { ParsedIniData } from "@smithy/types";
export declare const parseIni: (iniData: string) => ParsedIniData;

```

## ./lib/lambda/node_modules/@smithy/shared-ini-file-loader/dist-types/parseKnownFiles.d.ts

```typescript
import type { ParsedIniData } from "@smithy/types";
import type { SharedConfigInit } from "./loadSharedConfigFiles";
/**
 * @public
 */
export interface SourceProfileInit extends SharedConfigInit {
    /**
     * The configuration profile to use.
     */
    profile?: string;
}
/**
 * Load profiles from credentials and config INI files and normalize them into a
 * single profile list.
 *
 * @internal
 */
export declare const parseKnownFiles: (init: SourceProfileInit) => Promise<ParsedIniData>;

```

## ./lib/lambda/node_modules/@smithy/shared-ini-file-loader/dist-types/slurpFile.d.ts

```typescript
export declare const filePromisesHash: Record<string, Promise<string>>;
export declare const fileIntercept: Record<string, Promise<string>>;
interface SlurpFileOptions {
    ignoreCache?: boolean;
}
export declare const slurpFile: (path: string, options?: SlurpFileOptions) => Promise<string>;
export {};

```

## ./lib/lambda/node_modules/@smithy/shared-ini-file-loader/dist-types/ts3.4/constants.d.ts

```typescript
/**
 * @internal
 */
export declare const CONFIG_PREFIX_SEPARATOR = ".";

```

## ./lib/lambda/node_modules/@smithy/shared-ini-file-loader/dist-types/ts3.4/externalDataInterceptor.d.ts

```typescript
/**
 * @internal
 */
export declare const externalDataInterceptor: {
    getFileRecord(): Record<string, Promise<string>>;
    interceptFile(path: string, contents: string): void;
    getTokenRecord(): Record<string, any>;
    interceptToken(id: string, contents: any): void;
};

```

## ./lib/lambda/node_modules/@smithy/shared-ini-file-loader/dist-types/ts3.4/getConfigData.d.ts

```typescript
import { ParsedIniData } from "@smithy/types";
/**
 * Returns the config data from parsed ini data.
 * * Returns data for `default`
 * * Returns profile name without prefix.
 * * Returns non-profiles as is.
 */
export declare const getConfigData: (data: ParsedIniData) => ParsedIniData;

```

## ./lib/lambda/node_modules/@smithy/shared-ini-file-loader/dist-types/ts3.4/getConfigFilepath.d.ts

```typescript
export declare const ENV_CONFIG_PATH = "AWS_CONFIG_FILE";
export declare const getConfigFilepath: () => string;

```

## ./lib/lambda/node_modules/@smithy/shared-ini-file-loader/dist-types/ts3.4/getCredentialsFilepath.d.ts

```typescript
export declare const ENV_CREDENTIALS_PATH = "AWS_SHARED_CREDENTIALS_FILE";
export declare const getCredentialsFilepath: () => string;

```

## ./lib/lambda/node_modules/@smithy/shared-ini-file-loader/dist-types/ts3.4/getHomeDir.d.ts

```typescript
/**
 * Get the HOME directory for the current runtime.
 *
 * @internal
 */
export declare const getHomeDir: () => string;

```

## ./lib/lambda/node_modules/@smithy/shared-ini-file-loader/dist-types/ts3.4/getProfileName.d.ts

```typescript
/**
 * @internal
 */
export declare const ENV_PROFILE = "AWS_PROFILE";
/**
 * @internal
 */
export declare const DEFAULT_PROFILE = "default";
/**
 * Returns profile with priority order code - ENV - default.
 * @internal
 */
export declare const getProfileName: (init: {
    profile?: string;
}) => string;

```

## ./lib/lambda/node_modules/@smithy/shared-ini-file-loader/dist-types/ts3.4/getSSOTokenFilepath.d.ts

```typescript
/**
 * Returns the filepath of the file where SSO token is stored.
 * @internal
 */
export declare const getSSOTokenFilepath: (id: string) => string;

```

## ./lib/lambda/node_modules/@smithy/shared-ini-file-loader/dist-types/ts3.4/getSSOTokenFromFile.d.ts

```typescript
/**
 * Cached SSO token retrieved from SSO login flow.
 * @public
 */
export interface SSOToken {
    /**
     * A base64 encoded string returned by the sso-oidc service.
     */
    accessToken: string;
    /**
     * The expiration time of the accessToken as an RFC 3339 formatted timestamp.
     */
    expiresAt: string;
    /**
     * The token used to obtain an access token in the event that the accessToken is invalid or expired.
     */
    refreshToken?: string;
    /**
     * The unique identifier string for each client. The client ID generated when performing the registration
     * portion of the OIDC authorization flow. This is used to refresh the accessToken.
     */
    clientId?: string;
    /**
     * A secret string generated when performing the registration portion of the OIDC authorization flow.
     * This is used to refresh the accessToken.
     */
    clientSecret?: string;
    /**
     * The expiration time of the client registration (clientId and clientSecret) as an RFC 3339 formatted timestamp.
     */
    registrationExpiresAt?: string;
    /**
     * The configured sso_region for the profile that credentials are being resolved for.
     */
    region?: string;
    /**
     * The configured sso_start_url for the profile that credentials are being resolved for.
     */
    startUrl?: string;
}
/**
 * @internal
 */
export declare const tokenIntercept: Record<string, any>;
/**
 * @internal
 * @param id - can be either a start URL or the SSO session name.
 * Returns the SSO token from the file system.
 */
export declare const getSSOTokenFromFile: (id: string) => Promise<any>;

```

## ./lib/lambda/node_modules/@smithy/shared-ini-file-loader/dist-types/ts3.4/getSsoSessionData.d.ts

```typescript
import { ParsedIniData } from "@smithy/types";
/**
 * Returns the sso-session data from parsed ini data by reading
 * ssoSessionName after sso-session prefix including/excluding quotes
 */
export declare const getSsoSessionData: (data: ParsedIniData) => ParsedIniData;

```

## ./lib/lambda/node_modules/@smithy/shared-ini-file-loader/dist-types/ts3.4/index.d.ts

```typescript
export * from "./getHomeDir";
export * from "./getProfileName";
export * from "./getSSOTokenFilepath";
export { getSSOTokenFromFile, SSOToken } from "./getSSOTokenFromFile";
export * from "./loadSharedConfigFiles";
export * from "./loadSsoSessionData";
export * from "./parseKnownFiles";
export { externalDataInterceptor } from "./externalDataInterceptor";
export * from "./types";

```

## ./lib/lambda/node_modules/@smithy/shared-ini-file-loader/dist-types/ts3.4/loadSharedConfigFiles.d.ts

```typescript
import { Logger, SharedConfigFiles } from "@smithy/types";
/**
 * @public
 */
export interface SharedConfigInit {
    /**
     * The path at which to locate the ini credentials file. Defaults to the
     * value of the `AWS_SHARED_CREDENTIALS_FILE` environment variable (if
     * defined) or `~/.aws/credentials` otherwise.
     */
    filepath?: string;
    /**
     * The path at which to locate the ini config file. Defaults to the value of
     * the `AWS_CONFIG_FILE` environment variable (if defined) or
     * `~/.aws/config` otherwise.
     */
    configFilepath?: string;
    /**
     * Configuration files are normally cached after the first time they are loaded. When this
     * property is set, the provider will always reload any configuration files loaded before.
     */
    ignoreCache?: boolean;
    /**
     * For credential resolution trace logging.
     */
    logger?: Logger;
}
export { CONFIG_PREFIX_SEPARATOR } from "./constants";
/**
 * Loads the config and credentials files.
 * @internal
 */
export declare const loadSharedConfigFiles: (init?: SharedConfigInit) => Promise<SharedConfigFiles>;

```

## ./lib/lambda/node_modules/@smithy/shared-ini-file-loader/dist-types/ts3.4/loadSsoSessionData.d.ts

```typescript
import { ParsedIniData } from "@smithy/types";
/**
 * Subset of {@link SharedConfigInit}.
 * @internal
 */
export interface SsoSessionInit {
    /**
     * The path at which to locate the ini config file. Defaults to the value of
     * the `AWS_CONFIG_FILE` environment variable (if defined) or
     * `~/.aws/config` otherwise.
     */
    configFilepath?: string;
}
/**
 * @internal
 */
export declare const loadSsoSessionData: (init?: SsoSessionInit) => Promise<ParsedIniData>;

```

## ./lib/lambda/node_modules/@smithy/shared-ini-file-loader/dist-types/ts3.4/mergeConfigFiles.d.ts

```typescript
import { ParsedIniData } from "@smithy/types";
/**
 * Merge multiple profile config files such that settings each file are kept together
 *
 * @internal
 */
export declare const mergeConfigFiles: (...files: ParsedIniData[]) => ParsedIniData;

```

## ./lib/lambda/node_modules/@smithy/shared-ini-file-loader/dist-types/ts3.4/parseIni.d.ts

```typescript
import { ParsedIniData } from "@smithy/types";
export declare const parseIni: (iniData: string) => ParsedIniData;

```

## ./lib/lambda/node_modules/@smithy/shared-ini-file-loader/dist-types/ts3.4/parseKnownFiles.d.ts

```typescript
import { ParsedIniData } from "@smithy/types";
import { SharedConfigInit } from "./loadSharedConfigFiles";
/**
 * @public
 */
export interface SourceProfileInit extends SharedConfigInit {
    /**
     * The configuration profile to use.
     */
    profile?: string;
}
/**
 * Load profiles from credentials and config INI files and normalize them into a
 * single profile list.
 *
 * @internal
 */
export declare const parseKnownFiles: (init: SourceProfileInit) => Promise<ParsedIniData>;

```

## ./lib/lambda/node_modules/@smithy/shared-ini-file-loader/dist-types/ts3.4/slurpFile.d.ts

```typescript
export declare const filePromisesHash: Record<string, Promise<string>>;
export declare const fileIntercept: Record<string, Promise<string>>;
interface SlurpFileOptions {
    ignoreCache?: boolean;
}
export declare const slurpFile: (path: string, options?: SlurpFileOptions) => Promise<string>;
export {};

```

## ./lib/lambda/node_modules/@smithy/shared-ini-file-loader/dist-types/ts3.4/types.d.ts

```typescript
import { ParsedIniData as __ParsedIniData, Profile as __Profile, SharedConfigFiles as __SharedConfigFiles } from "@smithy/types";
/**
 * @internal
 * @deprecated Use Profile from "\@smithy/types" instead
 */
export type Profile = __Profile;
/**
 * @internal
 * @deprecated Use ParsedIniData from "\@smithy/types" instead
 */
export type ParsedIniData = __ParsedIniData;
/**
 * @internal
 * @deprecated Use SharedConfigFiles from "\@smithy/types" instead
 */
export type SharedConfigFiles = __SharedConfigFiles;

```

## ./lib/lambda/node_modules/@smithy/shared-ini-file-loader/dist-types/types.d.ts

```typescript
import type { ParsedIniData as __ParsedIniData, Profile as __Profile, SharedConfigFiles as __SharedConfigFiles } from "@smithy/types";
/**
 * @internal
 * @deprecated Use Profile from "\@smithy/types" instead
 */
export type Profile = __Profile;
/**
 * @internal
 * @deprecated Use ParsedIniData from "\@smithy/types" instead
 */
export type ParsedIniData = __ParsedIniData;
/**
 * @internal
 * @deprecated Use SharedConfigFiles from "\@smithy/types" instead
 */
export type SharedConfigFiles = __SharedConfigFiles;

```

## ./lib/lambda/node_modules/@smithy/shared-ini-file-loader/package.json

```json
{
  "name": "@smithy/shared-ini-file-loader",
  "version": "4.3.3",
  "dependencies": {
    "@smithy/types": "^4.8.0",
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "@types/node": "^18.11.9",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline shared-ini-file-loader",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "rimraf dist-types/ts3.4 && downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../../.prettierignore --write \"**/*.{ts,md,json}\"",
    "extract:docs": "api-extractor run --local",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch"
  },
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "sideEffects": false,
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "browser": {
    "./dist-es/getSSOTokenFromFile": false,
    "./dist-es/slurpFile": false
  },
  "react-native": {
    "./dist-cjs/getSSOTokenFromFile": false,
    "./dist-cjs/slurpFile": false,
    "./dist-es/getSSOTokenFromFile": false,
    "./dist-es/slurpFile": false
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/smithy-lang/smithy-typescript/tree/main/packages/shared-ini-file-loader",
  "repository": {
    "type": "git",
    "url": "https://github.com/smithy-lang/smithy-typescript.git",
    "directory": "packages/shared-ini-file-loader"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  }
}
```

## ./lib/lambda/node_modules/@smithy/signature-v4/dist-types/HeaderFormatter.d.ts

```typescript
import type { Int64 as IInt64, MessageHeaders } from "@smithy/types";
/**
 * @internal
 * TODO: duplicated from @smithy/eventstream-codec to break large dependency.
 * TODO: This should be moved to its own deduped submodule in @smithy/core when submodules are implemented.
 */
export declare class HeaderFormatter {
    format(headers: MessageHeaders): Uint8Array;
    private formatHeaderValue;
}
/**
 * TODO: duplicated from @smithy/eventstream-codec to break large dependency.
 * TODO: This should be moved to its own deduped submodule in @smithy/core when submodules are implemented.
 */
export declare class Int64 implements IInt64 {
    readonly bytes: Uint8Array;
    constructor(bytes: Uint8Array);
    static fromNumber(number: number): Int64;
    /**
     * Called implicitly by infix arithmetic operators.
     */
    valueOf(): number;
    toString(): string;
}

```

## ./lib/lambda/node_modules/@smithy/signature-v4/dist-types/SignatureV4.d.ts

```typescript
import type { EventSigner, EventSigningArguments, FormattedEvent, HttpRequest, MessageSigner, RequestPresigner, RequestPresigningArguments, RequestSigner, RequestSigningArguments, SignableMessage, SignedMessage, SigningArguments, StringSigner } from "@smithy/types";
import type { SignatureV4CryptoInit, SignatureV4Init } from "./SignatureV4Base";
import { SignatureV4Base } from "./SignatureV4Base";
/**
 * @public
 */
export declare class SignatureV4 extends SignatureV4Base implements RequestPresigner, RequestSigner, StringSigner, EventSigner, MessageSigner {
    private readonly headerFormatter;
    constructor({ applyChecksum, credentials, region, service, sha256, uriEscapePath, }: SignatureV4Init & SignatureV4CryptoInit);
    presign(originalRequest: HttpRequest, options?: RequestPresigningArguments): Promise<HttpRequest>;
    sign(stringToSign: string, options?: SigningArguments): Promise<string>;
    sign(event: FormattedEvent, options: EventSigningArguments): Promise<string>;
    sign(event: SignableMessage, options: SigningArguments): Promise<SignedMessage>;
    sign(requestToSign: HttpRequest, options?: RequestSigningArguments): Promise<HttpRequest>;
    private signEvent;
    signMessage(signableMessage: SignableMessage, { signingDate, signingRegion, signingService }: SigningArguments): Promise<SignedMessage>;
    private signString;
    private signRequest;
    private getSignature;
    private getSigningKey;
}

```

## ./lib/lambda/node_modules/@smithy/signature-v4/dist-types/SignatureV4Base.d.ts

```typescript
import type { AwsCredentialIdentity, ChecksumConstructor, DateInput, HashConstructor, HeaderBag, HttpRequest, Provider } from "@smithy/types";
/**
 * @public
 */
export interface SignatureV4Init {
    /**
     * The service signing name.
     */
    service: string;
    /**
     * The region name or a function that returns a promise that will be
     * resolved with the region name.
     */
    region: string | Provider<string>;
    /**
     * The credentials with which the request should be signed or a function
     * that returns a promise that will be resolved with credentials.
     */
    credentials: AwsCredentialIdentity | Provider<AwsCredentialIdentity>;
    /**
     * A constructor function for a hash object that will calculate SHA-256 HMAC
     * checksums.
     */
    sha256?: ChecksumConstructor | HashConstructor;
    /**
     * Whether to uri-escape the request URI path as part of computing the
     * canonical request string. This is required for every AWS service, except
     * Amazon S3, as of late 2017.
     *
     * @default [true]
     */
    uriEscapePath?: boolean;
    /**
     * Whether to calculate a checksum of the request body and include it as
     * either a request header (when signing) or as a query string parameter
     * (when presigning). This is required for AWS Glacier and Amazon S3 and optional for
     * every other AWS service as of late 2017.
     *
     * @default [true]
     */
    applyChecksum?: boolean;
}
/**
 * @public
 */
export interface SignatureV4CryptoInit {
    sha256: ChecksumConstructor | HashConstructor;
}
/**
 * @internal
 */
export declare abstract class SignatureV4Base {
    protected readonly service: string;
    protected readonly regionProvider: Provider<string>;
    protected readonly credentialProvider: Provider<AwsCredentialIdentity>;
    protected readonly sha256: ChecksumConstructor | HashConstructor;
    private readonly uriEscapePath;
    protected readonly applyChecksum: boolean;
    protected constructor({ applyChecksum, credentials, region, service, sha256, uriEscapePath, }: SignatureV4Init & SignatureV4CryptoInit);
    protected createCanonicalRequest(request: HttpRequest, canonicalHeaders: HeaderBag, payloadHash: string): string;
    protected createStringToSign(longDate: string, credentialScope: string, canonicalRequest: string, algorithmIdentifier: string): Promise<string>;
    private getCanonicalPath;
    protected validateResolvedCredentials(credentials: unknown): void;
    protected formatDate(now: DateInput): {
        longDate: string;
        shortDate: string;
    };
    protected getCanonicalHeaderList(headers: object): string;
}

```

## ./lib/lambda/node_modules/@smithy/signature-v4/dist-types/constants.d.ts

```typescript
export declare const ALGORITHM_QUERY_PARAM = "X-Amz-Algorithm";
export declare const CREDENTIAL_QUERY_PARAM = "X-Amz-Credential";
export declare const AMZ_DATE_QUERY_PARAM = "X-Amz-Date";
export declare const SIGNED_HEADERS_QUERY_PARAM = "X-Amz-SignedHeaders";
export declare const EXPIRES_QUERY_PARAM = "X-Amz-Expires";
export declare const SIGNATURE_QUERY_PARAM = "X-Amz-Signature";
export declare const TOKEN_QUERY_PARAM = "X-Amz-Security-Token";
export declare const REGION_SET_PARAM = "X-Amz-Region-Set";
export declare const AUTH_HEADER = "authorization";
export declare const AMZ_DATE_HEADER: string;
export declare const DATE_HEADER = "date";
export declare const GENERATED_HEADERS: string[];
export declare const SIGNATURE_HEADER: string;
export declare const SHA256_HEADER = "x-amz-content-sha256";
export declare const TOKEN_HEADER: string;
export declare const HOST_HEADER = "host";
export declare const ALWAYS_UNSIGNABLE_HEADERS: {
    authorization: boolean;
    "cache-control": boolean;
    connection: boolean;
    expect: boolean;
    from: boolean;
    "keep-alive": boolean;
    "max-forwards": boolean;
    pragma: boolean;
    referer: boolean;
    te: boolean;
    trailer: boolean;
    "transfer-encoding": boolean;
    upgrade: boolean;
    "user-agent": boolean;
    "x-amzn-trace-id": boolean;
};
export declare const PROXY_HEADER_PATTERN: RegExp;
export declare const SEC_HEADER_PATTERN: RegExp;
export declare const UNSIGNABLE_PATTERNS: RegExp[];
export declare const ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256";
export declare const ALGORITHM_IDENTIFIER_V4A = "AWS4-ECDSA-P256-SHA256";
export declare const EVENT_ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256-PAYLOAD";
export declare const UNSIGNED_PAYLOAD = "UNSIGNED-PAYLOAD";
export declare const MAX_CACHE_SIZE = 50;
export declare const KEY_TYPE_IDENTIFIER = "aws4_request";
export declare const MAX_PRESIGNED_TTL: number;

```

## ./lib/lambda/node_modules/@smithy/signature-v4/dist-types/credentialDerivation.d.ts

```typescript
import type { AwsCredentialIdentity, ChecksumConstructor, HashConstructor } from "@smithy/types";
/**
 * Create a string describing the scope of credentials used to sign a request.
 *
 * @internal
 *
 * @param shortDate - the current calendar date in the form YYYYMMDD.
 * @param region    - the AWS region in which the service resides.
 * @param service   - the service to which the signed request is being sent.
 */
export declare const createScope: (shortDate: string, region: string, service: string) => string;
/**
 * Derive a signing key from its composite parts.
 *
 * @internal
 *
 * @param sha256Constructor - a constructor function that can instantiate SHA-256
 *                          hash objects.
 * @param credentials       - the credentials with which the request will be
 *                          signed.
 * @param shortDate         - the current calendar date in the form YYYYMMDD.
 * @param region            - the AWS region in which the service resides.
 * @param service           - the service to which the signed request is being
 *                          sent.
 */
export declare const getSigningKey: (sha256Constructor: ChecksumConstructor | HashConstructor, credentials: AwsCredentialIdentity, shortDate: string, region: string, service: string) => Promise<Uint8Array>;
/**
 * @internal
 */
export declare const clearCredentialCache: () => void;

```

## ./lib/lambda/node_modules/@smithy/signature-v4/dist-types/getCanonicalHeaders.d.ts

```typescript
import type { HeaderBag, HttpRequest } from "@smithy/types";
/**
 * @internal
 */
export declare const getCanonicalHeaders: ({ headers }: HttpRequest, unsignableHeaders?: Set<string>, signableHeaders?: Set<string>) => HeaderBag;

```

## ./lib/lambda/node_modules/@smithy/signature-v4/dist-types/getCanonicalQuery.d.ts

```typescript
import type { HttpRequest } from "@smithy/types";
/**
 * @internal
 */
export declare const getCanonicalQuery: ({ query }: HttpRequest) => string;

```

## ./lib/lambda/node_modules/@smithy/signature-v4/dist-types/getPayloadHash.d.ts

```typescript
import type { ChecksumConstructor, HashConstructor, HttpRequest } from "@smithy/types";
/**
 * @internal
 */
export declare const getPayloadHash: ({ headers, body }: HttpRequest, hashConstructor: ChecksumConstructor | HashConstructor) => Promise<string>;

```

## ./lib/lambda/node_modules/@smithy/signature-v4/dist-types/headerUtil.d.ts

```typescript
import type { HeaderBag } from "@smithy/types";
export declare const hasHeader: (soughtHeader: string, headers: HeaderBag) => boolean;
export declare const getHeaderValue: (soughtHeader: string, headers: HeaderBag) => string | undefined;
export declare const deleteHeader: (soughtHeader: string, headers: HeaderBag) => void;

```

## ./lib/lambda/node_modules/@smithy/signature-v4/dist-types/index.d.ts

```typescript
export * from "./SignatureV4";
export * from "./constants";
export { getCanonicalHeaders } from "./getCanonicalHeaders";
export { getCanonicalQuery } from "./getCanonicalQuery";
export { getPayloadHash } from "./getPayloadHash";
export { moveHeadersToQuery } from "./moveHeadersToQuery";
export { prepareRequest } from "./prepareRequest";
export * from "./credentialDerivation";
export { SignatureV4Init, SignatureV4CryptoInit, SignatureV4Base } from "./SignatureV4Base";
export { hasHeader } from "./headerUtil";
export * from "./signature-v4a-container";

```

## ./lib/lambda/node_modules/@smithy/signature-v4/dist-types/moveHeadersToQuery.d.ts

```typescript
import type { HttpRequest as IHttpRequest, QueryParameterBag } from "@smithy/types";
/**
 * @internal
 */
export declare const moveHeadersToQuery: (request: IHttpRequest, options?: {
    unhoistableHeaders?: Set<string>;
    hoistableHeaders?: Set<string>;
}) => IHttpRequest & {
    query: QueryParameterBag;
};

```

## ./lib/lambda/node_modules/@smithy/signature-v4/dist-types/prepareRequest.d.ts

```typescript
import type { HttpRequest as IHttpRequest } from "@smithy/types";
/**
 * @internal
 */
export declare const prepareRequest: (request: IHttpRequest) => IHttpRequest;

```

## ./lib/lambda/node_modules/@smithy/signature-v4/dist-types/signature-v4a-container.d.ts

```typescript
import type { RequestSigner } from "@smithy/types";
/**
 * @public
 */
export type OptionalSigV4aSigner = {
    /**
     * This constructor is not typed so as not to require a type import
     * from the signature-v4a package.
     *
     * The true type is SignatureV4a from @smithy/signature-v4a.
     */
    new (options: any): RequestSigner;
};
/**
 * @public
 *
 * \@smithy/signature-v4a will install the constructor in this
 * container if it's installed.
 *
 * This avoids a runtime-require being interpreted statically by bundlers.
 */
export declare const signatureV4aContainer: {
    SignatureV4a: null | OptionalSigV4aSigner;
};

```

## ./lib/lambda/node_modules/@smithy/signature-v4/dist-types/suite.fixture.d.ts

```typescript
import type { HttpRequest } from "@smithy/types";
export interface TestCase {
    name: string;
    request: HttpRequest;
    authorization: string;
}
export declare const region = "us-east-1";
export declare const service = "service";
export declare const credentials: {
    accessKeyId: string;
    secretAccessKey: string;
};
export declare const signingDate: Date;
export declare const requests: Array<TestCase>;

```

## ./lib/lambda/node_modules/@smithy/signature-v4/dist-types/ts3.4/HeaderFormatter.d.ts

```typescript
import { Int64 as IInt64, MessageHeaders } from "@smithy/types";
/**
 * @internal
 * TODO: duplicated from @smithy/eventstream-codec to break large dependency.
 * TODO: This should be moved to its own deduped submodule in @smithy/core when submodules are implemented.
 */
export declare class HeaderFormatter {
    format(headers: MessageHeaders): Uint8Array;
    private formatHeaderValue;
}
/**
 * TODO: duplicated from @smithy/eventstream-codec to break large dependency.
 * TODO: This should be moved to its own deduped submodule in @smithy/core when submodules are implemented.
 */
export declare class Int64 implements IInt64 {
    readonly bytes: Uint8Array;
    constructor(bytes: Uint8Array);
    static fromNumber(number: number): Int64;
    /**
     * Called implicitly by infix arithmetic operators.
     */
    valueOf(): number;
    toString(): string;
}

```

## ./lib/lambda/node_modules/@smithy/signature-v4/dist-types/ts3.4/SignatureV4.d.ts

```typescript
import { EventSigner, EventSigningArguments, FormattedEvent, HttpRequest, MessageSigner, RequestPresigner, RequestPresigningArguments, RequestSigner, RequestSigningArguments, SignableMessage, SignedMessage, SigningArguments, StringSigner } from "@smithy/types";
import { SignatureV4CryptoInit, SignatureV4Init } from "./SignatureV4Base";
import { SignatureV4Base } from "./SignatureV4Base";
/**
 * @public
 */
export declare class SignatureV4 extends SignatureV4Base implements RequestPresigner, RequestSigner, StringSigner, EventSigner, MessageSigner {
    private readonly headerFormatter;
    constructor({ applyChecksum, credentials, region, service, sha256, uriEscapePath, }: SignatureV4Init & SignatureV4CryptoInit);
    presign(originalRequest: HttpRequest, options?: RequestPresigningArguments): Promise<HttpRequest>;
    sign(stringToSign: string, options?: SigningArguments): Promise<string>;
    sign(event: FormattedEvent, options: EventSigningArguments): Promise<string>;
    sign(event: SignableMessage, options: SigningArguments): Promise<SignedMessage>;
    sign(requestToSign: HttpRequest, options?: RequestSigningArguments): Promise<HttpRequest>;
    private signEvent;
    signMessage(signableMessage: SignableMessage, { signingDate, signingRegion, signingService }: SigningArguments): Promise<SignedMessage>;
    private signString;
    private signRequest;
    private getSignature;
    private getSigningKey;
}

```

## ./lib/lambda/node_modules/@smithy/signature-v4/dist-types/ts3.4/SignatureV4Base.d.ts

```typescript
import { AwsCredentialIdentity, ChecksumConstructor, DateInput, HashConstructor, HeaderBag, HttpRequest, Provider } from "@smithy/types";
/**
 * @public
 */
export interface SignatureV4Init {
    /**
     * The service signing name.
     */
    service: string;
    /**
     * The region name or a function that returns a promise that will be
     * resolved with the region name.
     */
    region: string | Provider<string>;
    /**
     * The credentials with which the request should be signed or a function
     * that returns a promise that will be resolved with credentials.
     */
    credentials: AwsCredentialIdentity | Provider<AwsCredentialIdentity>;
    /**
     * A constructor function for a hash object that will calculate SHA-256 HMAC
     * checksums.
     */
    sha256?: ChecksumConstructor | HashConstructor;
    /**
     * Whether to uri-escape the request URI path as part of computing the
     * canonical request string. This is required for every AWS service, except
     * Amazon S3, as of late 2017.
     *
     * @default [true]
     */
    uriEscapePath?: boolean;
    /**
     * Whether to calculate a checksum of the request body and include it as
     * either a request header (when signing) or as a query string parameter
     * (when presigning). This is required for AWS Glacier and Amazon S3 and optional for
     * every other AWS service as of late 2017.
     *
     * @default [true]
     */
    applyChecksum?: boolean;
}
/**
 * @public
 */
export interface SignatureV4CryptoInit {
    sha256: ChecksumConstructor | HashConstructor;
}
/**
 * @internal
 */
export declare abstract class SignatureV4Base {
    protected readonly service: string;
    protected readonly regionProvider: Provider<string>;
    protected readonly credentialProvider: Provider<AwsCredentialIdentity>;
    protected readonly sha256: ChecksumConstructor | HashConstructor;
    private readonly uriEscapePath;
    protected readonly applyChecksum: boolean;
    protected constructor({ applyChecksum, credentials, region, service, sha256, uriEscapePath, }: SignatureV4Init & SignatureV4CryptoInit);
    protected createCanonicalRequest(request: HttpRequest, canonicalHeaders: HeaderBag, payloadHash: string): string;
    protected createStringToSign(longDate: string, credentialScope: string, canonicalRequest: string, algorithmIdentifier: string): Promise<string>;
    private getCanonicalPath;
    protected validateResolvedCredentials(credentials: unknown): void;
    protected formatDate(now: DateInput): {
        longDate: string;
        shortDate: string;
    };
    protected getCanonicalHeaderList(headers: object): string;
}

```

## ./lib/lambda/node_modules/@smithy/signature-v4/dist-types/ts3.4/constants.d.ts

```typescript
export declare const ALGORITHM_QUERY_PARAM = "X-Amz-Algorithm";
export declare const CREDENTIAL_QUERY_PARAM = "X-Amz-Credential";
export declare const AMZ_DATE_QUERY_PARAM = "X-Amz-Date";
export declare const SIGNED_HEADERS_QUERY_PARAM = "X-Amz-SignedHeaders";
export declare const EXPIRES_QUERY_PARAM = "X-Amz-Expires";
export declare const SIGNATURE_QUERY_PARAM = "X-Amz-Signature";
export declare const TOKEN_QUERY_PARAM = "X-Amz-Security-Token";
export declare const REGION_SET_PARAM = "X-Amz-Region-Set";
export declare const AUTH_HEADER = "authorization";
export declare const AMZ_DATE_HEADER: string;
export declare const DATE_HEADER = "date";
export declare const GENERATED_HEADERS: string[];
export declare const SIGNATURE_HEADER: string;
export declare const SHA256_HEADER = "x-amz-content-sha256";
export declare const TOKEN_HEADER: string;
export declare const HOST_HEADER = "host";
export declare const ALWAYS_UNSIGNABLE_HEADERS: {
    authorization: boolean;
    "cache-control": boolean;
    connection: boolean;
    expect: boolean;
    from: boolean;
    "keep-alive": boolean;
    "max-forwards": boolean;
    pragma: boolean;
    referer: boolean;
    te: boolean;
    trailer: boolean;
    "transfer-encoding": boolean;
    upgrade: boolean;
    "user-agent": boolean;
    "x-amzn-trace-id": boolean;
};
export declare const PROXY_HEADER_PATTERN: RegExp;
export declare const SEC_HEADER_PATTERN: RegExp;
export declare const UNSIGNABLE_PATTERNS: RegExp[];
export declare const ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256";
export declare const ALGORITHM_IDENTIFIER_V4A = "AWS4-ECDSA-P256-SHA256";
export declare const EVENT_ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256-PAYLOAD";
export declare const UNSIGNED_PAYLOAD = "UNSIGNED-PAYLOAD";
export declare const MAX_CACHE_SIZE = 50;
export declare const KEY_TYPE_IDENTIFIER = "aws4_request";
export declare const MAX_PRESIGNED_TTL: number;

```

## ./lib/lambda/node_modules/@smithy/signature-v4/dist-types/ts3.4/credentialDerivation.d.ts

```typescript
import { AwsCredentialIdentity, ChecksumConstructor, HashConstructor } from "@smithy/types";
/**
 * Create a string describing the scope of credentials used to sign a request.
 *
 * @internal
 *
 * @param shortDate - the current calendar date in the form YYYYMMDD.
 * @param region    - the AWS region in which the service resides.
 * @param service   - the service to which the signed request is being sent.
 */
export declare const createScope: (shortDate: string, region: string, service: string) => string;
/**
 * Derive a signing key from its composite parts.
 *
 * @internal
 *
 * @param sha256Constructor - a constructor function that can instantiate SHA-256
 *                          hash objects.
 * @param credentials       - the credentials with which the request will be
 *                          signed.
 * @param shortDate         - the current calendar date in the form YYYYMMDD.
 * @param region            - the AWS region in which the service resides.
 * @param service           - the service to which the signed request is being
 *                          sent.
 */
export declare const getSigningKey: (sha256Constructor: ChecksumConstructor | HashConstructor, credentials: AwsCredentialIdentity, shortDate: string, region: string, service: string) => Promise<Uint8Array>;
/**
 * @internal
 */
export declare const clearCredentialCache: () => void;

```

## ./lib/lambda/node_modules/@smithy/signature-v4/dist-types/ts3.4/getCanonicalHeaders.d.ts

```typescript
import { HeaderBag, HttpRequest } from "@smithy/types";
/**
 * @internal
 */
export declare const getCanonicalHeaders: ({ headers }: HttpRequest, unsignableHeaders?: Set<string>, signableHeaders?: Set<string>) => HeaderBag;

```

## ./lib/lambda/node_modules/@smithy/signature-v4/dist-types/ts3.4/getCanonicalQuery.d.ts

```typescript
import { HttpRequest } from "@smithy/types";
/**
 * @internal
 */
export declare const getCanonicalQuery: ({ query }: HttpRequest) => string;

```

## ./lib/lambda/node_modules/@smithy/signature-v4/dist-types/ts3.4/getPayloadHash.d.ts

```typescript
import { ChecksumConstructor, HashConstructor, HttpRequest } from "@smithy/types";
/**
 * @internal
 */
export declare const getPayloadHash: ({ headers, body }: HttpRequest, hashConstructor: ChecksumConstructor | HashConstructor) => Promise<string>;

```

## ./lib/lambda/node_modules/@smithy/signature-v4/dist-types/ts3.4/headerUtil.d.ts

```typescript
import { HeaderBag } from "@smithy/types";
export declare const hasHeader: (soughtHeader: string, headers: HeaderBag) => boolean;
export declare const getHeaderValue: (soughtHeader: string, headers: HeaderBag) => string | undefined;
export declare const deleteHeader: (soughtHeader: string, headers: HeaderBag) => void;

```

## ./lib/lambda/node_modules/@smithy/signature-v4/dist-types/ts3.4/index.d.ts

```typescript
export * from "./SignatureV4";
export * from "./constants";
export { getCanonicalHeaders } from "./getCanonicalHeaders";
export { getCanonicalQuery } from "./getCanonicalQuery";
export { getPayloadHash } from "./getPayloadHash";
export { moveHeadersToQuery } from "./moveHeadersToQuery";
export { prepareRequest } from "./prepareRequest";
export * from "./credentialDerivation";
export { SignatureV4Init, SignatureV4CryptoInit, SignatureV4Base } from "./SignatureV4Base";
export { hasHeader } from "./headerUtil";
export * from "./signature-v4a-container";

```

## ./lib/lambda/node_modules/@smithy/signature-v4/dist-types/ts3.4/moveHeadersToQuery.d.ts

```typescript
import { HttpRequest as IHttpRequest, QueryParameterBag } from "@smithy/types";
/**
 * @internal
 */
export declare const moveHeadersToQuery: (request: IHttpRequest, options?: {
    unhoistableHeaders?: Set<string>;
    hoistableHeaders?: Set<string>;
}) => IHttpRequest & {
    query: QueryParameterBag;
};

```

## ./lib/lambda/node_modules/@smithy/signature-v4/dist-types/ts3.4/prepareRequest.d.ts

```typescript
import { HttpRequest as IHttpRequest } from "@smithy/types";
/**
 * @internal
 */
export declare const prepareRequest: (request: IHttpRequest) => IHttpRequest;

```

## ./lib/lambda/node_modules/@smithy/signature-v4/dist-types/ts3.4/signature-v4a-container.d.ts

```typescript
import { RequestSigner } from "@smithy/types";
/**
 * @public
 */
export type OptionalSigV4aSigner = {
    /**
     * This constructor is not typed so as not to require a type import
     * from the signature-v4a package.
     *
     * The true type is SignatureV4a from @smithy/signature-v4a.
     */
    new (options: any): RequestSigner;
};
/**
 * @public
 *
 * \@smithy/signature-v4a will install the constructor in this
 * container if it's installed.
 *
 * This avoids a runtime-require being interpreted statically by bundlers.
 */
export declare const signatureV4aContainer: {
    SignatureV4a: null | OptionalSigV4aSigner;
};

```

## ./lib/lambda/node_modules/@smithy/signature-v4/dist-types/ts3.4/suite.fixture.d.ts

```typescript
import { HttpRequest } from "@smithy/types";
export interface TestCase {
    name: string;
    request: HttpRequest;
    authorization: string;
}
export declare const region = "us-east-1";
export declare const service = "service";
export declare const credentials: {
    accessKeyId: string;
    secretAccessKey: string;
};
export declare const signingDate: Date;
export declare const requests: Array<TestCase>;

```

## ./lib/lambda/node_modules/@smithy/signature-v4/dist-types/ts3.4/utilDate.d.ts

```typescript
export declare const iso8601: (time: number | string | Date) => string;
export declare const toDate: (time: number | string | Date) => Date;

```

## ./lib/lambda/node_modules/@smithy/signature-v4/dist-types/utilDate.d.ts

```typescript
export declare const iso8601: (time: number | string | Date) => string;
export declare const toDate: (time: number | string | Date) => Date;

```

## ./lib/lambda/node_modules/@smithy/signature-v4/package.json

```json
{
  "name": "@smithy/signature-v4",
  "version": "5.3.3",
  "description": "A standalone implementation of the AWS Signature V4 request signing algorithm",
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline signature-v4",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "rimraf dist-types/ts3.4 && downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../../.prettierignore --write \"**/*.{ts,md,json}\"",
    "extract:docs": "api-extractor run --local",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch"
  },
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "sideEffects": false,
  "dependencies": {
    "@smithy/is-array-buffer": "^4.2.0",
    "@smithy/protocol-http": "^5.3.3",
    "@smithy/types": "^4.8.0",
    "@smithy/util-hex-encoding": "^4.2.0",
    "@smithy/util-middleware": "^4.2.3",
    "@smithy/util-uri-escape": "^4.2.0",
    "@smithy/util-utf8": "^4.2.0",
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "@aws-crypto/sha256-js": "5.2.0",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/smithy-lang/smithy-typescript/tree/main/packages/signature-v4",
  "repository": {
    "type": "git",
    "url": "https://github.com/smithy-lang/smithy-typescript.git",
    "directory": "packages/signature-v4"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  }
}
```

## ./lib/lambda/node_modules/@smithy/smithy-client/dist-types/NoOpLogger.d.ts

```typescript
import type { Logger } from "@smithy/types";
/**
 * @internal
 */
export declare class NoOpLogger implements Logger {
    trace(): void;
    debug(): void;
    info(): void;
    warn(): void;
    error(): void;
}

```

## ./lib/lambda/node_modules/@smithy/smithy-client/dist-types/client.d.ts

```typescript
import type { Client as IClient, Command, FetchHttpHandlerOptions, MetadataBearer, MiddlewareStack, NodeHttpHandlerOptions, RequestHandler } from "@smithy/types";
/**
 * @public
 */
export interface SmithyConfiguration<HandlerOptions> {
    requestHandler: RequestHandler<any, any, HandlerOptions> | NodeHttpHandlerOptions | FetchHttpHandlerOptions | Record<string, unknown>;
    /**
     * The API version set internally by the SDK, and is
     * not planned to be used by customer code.
     * @internal
     */
    readonly apiVersion: string;
    /**
     * @public
     *
     * Default false.
     *
     * When true, the client will only resolve the middleware stack once per
     * Command class. This means modifying the middlewareStack of the
     * command or client after requests have been made will not be
     * recognized.
     *
     * Calling client.destroy() also clears this cache.
     *
     * Enable this only if needing the additional time saved (0-1ms per request)
     * and not needing middleware modifications between requests.
     */
    cacheMiddleware?: boolean;
}
/**
 * @internal
 */
export type SmithyResolvedConfiguration<HandlerOptions> = {
    requestHandler: RequestHandler<any, any, HandlerOptions>;
    readonly apiVersion: string;
    cacheMiddleware?: boolean;
};
/**
 * @public
 */
export declare class Client<HandlerOptions, ClientInput extends object, ClientOutput extends MetadataBearer, ResolvedClientConfiguration extends SmithyResolvedConfiguration<HandlerOptions>> implements IClient<ClientInput, ClientOutput, ResolvedClientConfiguration> {
    readonly config: ResolvedClientConfiguration;
    middlewareStack: MiddlewareStack<ClientInput, ClientOutput>;
    /**
     * Holds an object reference to the initial configuration object.
     * Used to check that the config resolver stack does not create
     * dangling instances of an intermediate form of the configuration object.
     *
     * @internal
     */
    initConfig?: object;
    /**
     * May be used to cache the resolved handler function for a Command class.
     */
    private handlers?;
    constructor(config: ResolvedClientConfiguration);
    send<InputType extends ClientInput, OutputType extends ClientOutput>(command: Command<ClientInput, InputType, ClientOutput, OutputType, SmithyResolvedConfiguration<HandlerOptions>>, options?: HandlerOptions): Promise<OutputType>;
    send<InputType extends ClientInput, OutputType extends ClientOutput>(command: Command<ClientInput, InputType, ClientOutput, OutputType, SmithyResolvedConfiguration<HandlerOptions>>, cb: (err: any, data?: OutputType) => void): void;
    send<InputType extends ClientInput, OutputType extends ClientOutput>(command: Command<ClientInput, InputType, ClientOutput, OutputType, SmithyResolvedConfiguration<HandlerOptions>>, options: HandlerOptions, cb: (err: any, data?: OutputType) => void): void;
    destroy(): void;
}

```

## ./lib/lambda/node_modules/@smithy/smithy-client/dist-types/collect-stream-body.d.ts

```typescript
/**
 * @internal
 * Backwards compatibility re-export.
 */
export { collectBody } from "@smithy/core/protocols";

```

## ./lib/lambda/node_modules/@smithy/smithy-client/dist-types/command.d.ts

```typescript
import type { EndpointParameterInstructions } from "@smithy/middleware-endpoint";
import type { Command as ICommand, Handler, HandlerExecutionContext, HttpRequest as IHttpRequest, HttpResponse as IHttpResponse, Logger, MetadataBearer, MiddlewareStack as IMiddlewareStack, OperationSchema, OptionalParameter, Pluggable, RequestHandler, SerdeContext, StaticOperationSchema } from "@smithy/types";
/**
 * @public
 */
export declare abstract class Command<Input extends ClientInput, Output extends ClientOutput, ResolvedClientConfiguration, ClientInput extends object = any, ClientOutput extends MetadataBearer = any> implements ICommand<ClientInput, Input, ClientOutput, Output, ResolvedClientConfiguration> {
    abstract input: Input;
    readonly middlewareStack: IMiddlewareStack<Input, Output>;
    readonly schema?: OperationSchema | StaticOperationSchema;
    /**
     * Factory for Command ClassBuilder.
     * @internal
     */
    static classBuilder<I extends SI, O extends SO, C extends {
        logger: Logger;
        requestHandler: RequestHandler<any, any, any>;
    }, SI extends object = any, SO extends MetadataBearer = any>(): ClassBuilder<I, O, C, SI, SO>;
    abstract resolveMiddleware(stack: IMiddlewareStack<ClientInput, ClientOutput>, configuration: ResolvedClientConfiguration, options: any): Handler<Input, Output>;
    /**
     * @internal
     */
    resolveMiddlewareWithContext(clientStack: IMiddlewareStack<any, any>, configuration: {
        logger: Logger;
        requestHandler: RequestHandler<any, any, any>;
    }, options: any, { middlewareFn, clientName, commandName, inputFilterSensitiveLog, outputFilterSensitiveLog, smithyContext, additionalContext, CommandCtor, }: ResolveMiddlewareContextArgs): import("@smithy/types").InitializeHandler<any, Output>;
}
/**
 * @internal
 */
type ResolveMiddlewareContextArgs = {
    middlewareFn: (CommandCtor: any, clientStack: any, config: any, options: any) => Pluggable<any, any>[];
    clientName: string;
    commandName: string;
    smithyContext: Record<string, unknown>;
    additionalContext: HandlerExecutionContext;
    inputFilterSensitiveLog: (_: any) => any;
    outputFilterSensitiveLog: (_: any) => any;
    CommandCtor: any;
};
/**
 * @internal
 */
declare class ClassBuilder<I extends SI, O extends SO, C extends {
    logger: Logger;
    requestHandler: RequestHandler<any, any, any>;
}, SI extends object = any, SO extends MetadataBearer = any> {
    private _init;
    private _ep;
    private _middlewareFn;
    private _commandName;
    private _clientName;
    private _additionalContext;
    private _smithyContext;
    private _inputFilterSensitiveLog;
    private _outputFilterSensitiveLog;
    private _serializer;
    private _deserializer;
    private _operationSchema?;
    /**
     * Optional init callback.
     */
    init(cb: (_: Command<I, O, C, SI, SO>) => void): void;
    /**
     * Set the endpoint parameter instructions.
     */
    ep(endpointParameterInstructions: EndpointParameterInstructions): ClassBuilder<I, O, C, SI, SO>;
    /**
     * Add any number of middleware.
     */
    m(middlewareSupplier: (CommandCtor: any, clientStack: any, config: any, options: any) => Pluggable<any, any>[]): ClassBuilder<I, O, C, SI, SO>;
    /**
     * Set the initial handler execution context Smithy field.
     */
    s(service: string, operation: string, smithyContext?: Record<string, unknown>): ClassBuilder<I, O, C, SI, SO>;
    /**
     * Set the initial handler execution context.
     */
    c(additionalContext?: HandlerExecutionContext): ClassBuilder<I, O, C, SI, SO>;
    /**
     * Set constant string identifiers for the operation.
     */
    n(clientName: string, commandName: string): ClassBuilder<I, O, C, SI, SO>;
    /**
     * Set the input and output sensistive log filters.
     */
    f(inputFilter?: (_: any) => any, outputFilter?: (_: any) => any): ClassBuilder<I, O, C, SI, SO>;
    /**
     * Sets the serializer.
     */
    ser(serializer: (input: I, context?: SerdeContext | any) => Promise<IHttpRequest>): ClassBuilder<I, O, C, SI, SO>;
    /**
     * Sets the deserializer.
     */
    de(deserializer: (output: IHttpResponse, context?: SerdeContext | any) => Promise<O>): ClassBuilder<I, O, C, SI, SO>;
    /**
     * Sets input/output schema for the operation.
     */
    sc(operation: OperationSchema | StaticOperationSchema): ClassBuilder<I, O, C, SI, SO>;
    /**
     * @returns a Command class with the classBuilder properties.
     */
    build(): {
        new (input: I): CommandImpl<I, O, C, SI, SO>;
        new (...[input]: OptionalParameter<I>): CommandImpl<I, O, C, SI, SO>;
        getEndpointParameterInstructions(): EndpointParameterInstructions;
    };
}
/**
 * A concrete implementation of ICommand with no abstract members.
 * @public
 */
export interface CommandImpl<I extends SI, O extends SO, C extends {
    logger: Logger;
    requestHandler: RequestHandler<any, any, any>;
}, SI extends object = any, SO extends MetadataBearer = any> extends Command<I, O, C, SI, SO> {
    readonly input: I;
    resolveMiddleware(stack: IMiddlewareStack<SI, SO>, configuration: C, options: any): Handler<I, O>;
}
export {};

```

## ./lib/lambda/node_modules/@smithy/smithy-client/dist-types/constants.d.ts

```typescript
/**
 * @internal
 */
export declare const SENSITIVE_STRING = "***SensitiveInformation***";

```

## ./lib/lambda/node_modules/@smithy/smithy-client/dist-types/create-aggregated-client.d.ts

```typescript
import type { Client } from "./client";
/**
 * @internal
 *
 * @param commands - command lookup container.
 * @param client - client instance on which to add aggregated methods.
 * @returns an aggregated client with dynamically created methods.
 */
export declare const createAggregatedClient: (commands: Record<string, any>, Client: {
    new (...args: any): Client<any, any, any, any>;
}) => void;

```

## ./lib/lambda/node_modules/@smithy/smithy-client/dist-types/default-error-handler.d.ts

```typescript
/**
 * Always throws an error with the given `exceptionCtor` and other arguments.
 * This is only called from an error handling code path.
 *
 * @internal
 */
export declare const throwDefaultError: ({ output, parsedBody, exceptionCtor, errorCode }: any) => never;
/**
 * @internal
 *
 * Creates {@link throwDefaultError} with bound ExceptionCtor.
 */
export declare const withBaseException: (ExceptionCtor: {
    new (...args: any): any;
}) => any;

```

## ./lib/lambda/node_modules/@smithy/smithy-client/dist-types/defaults-mode.d.ts

```typescript
/**
 * @internal
 */
export declare const loadConfigsForDefaultMode: (mode: ResolvedDefaultsMode) => DefaultsModeConfigs;
/**
 * Option determining how certain default configuration options are resolved in the SDK. It can be one of the value listed below:
 * * `"standard"`: <p>The STANDARD mode provides the latest recommended default values that should be safe to run in most scenarios</p><p>Note that the default values vended from this mode might change as best practices may evolve. As a result, it is encouraged to perform tests when upgrading the SDK</p>
 * * `"in-region"`: <p>The IN_REGION mode builds on the standard mode and includes optimization tailored for applications which call AWS services from within the same AWS region</p><p>Note that the default values vended from this mode might change as best practices may evolve. As a result, it is encouraged to perform tests when upgrading the SDK</p>
 * * `"cross-region"`: <p>The CROSS_REGION mode builds on the standard mode and includes optimization tailored for applications which call AWS services in a different region</p><p>Note that the default values vended from this mode might change as best practices may evolve. As a result, it is encouraged to perform tests when upgrading the SDK</p>
 * * `"mobile"`: <p>The MOBILE mode builds on the standard mode and includes optimization tailored for mobile applications</p><p>Note that the default values vended from this mode might change as best practices may evolve. As a result, it is encouraged to perform tests when upgrading the SDK</p>
 * * `"auto"`: <p>The AUTO mode is an experimental mode that builds on the standard mode. The SDK will attempt to discover the execution environment to determine the appropriate settings automatically.</p><p>Note that the auto detection is heuristics-based and does not guarantee 100% accuracy. STANDARD mode will be used if the execution environment cannot be determined. The auto detection might query <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html">EC2 Instance Metadata service</a>, which might introduce latency. Therefore we recommend choosing an explicit defaults_mode instead if startup latency is critical to your application</p>
 * * `"legacy"`: <p>The LEGACY mode provides default settings that vary per SDK and were used prior to establishment of defaults_mode</p>
 *
 * @defaultValue "legacy"
 */
export type DefaultsMode = "standard" | "in-region" | "cross-region" | "mobile" | "auto" | "legacy";
/**
 * @internal
 */
export type ResolvedDefaultsMode = Exclude<DefaultsMode, "auto">;
/**
 * @internal
 */
export interface DefaultsModeConfigs {
    retryMode?: string;
    connectionTimeout?: number;
    requestTimeout?: number;
}

```

## ./lib/lambda/node_modules/@smithy/smithy-client/dist-types/emitWarningIfUnsupportedVersion.d.ts

```typescript
/**
 * @internal
 *
 * Emits warning if the provided Node.js version string is pending deprecation.
 *
 * @param version - The Node.js version string.
 */
export declare const emitWarningIfUnsupportedVersion: (version: string) => void;

```

## ./lib/lambda/node_modules/@smithy/smithy-client/dist-types/exceptions.d.ts

```typescript
import type { HttpResponse, MetadataBearer, ResponseMetadata, RetryableTrait, SmithyException } from "@smithy/types";
/**
 * The type of the exception class constructor parameter. The returned type contains the properties
 * in the `ExceptionType` but not in the `BaseExceptionType`. If the `BaseExceptionType` contains
 * `$metadata` and `message` properties, it's also included in the returned type.
 * @internal
 */
export type ExceptionOptionType<ExceptionType extends Error, BaseExceptionType extends Error> = Omit<ExceptionType, Exclude<keyof BaseExceptionType, "$metadata" | "message">>;
/**
 * @public
 */
export interface ServiceExceptionOptions extends SmithyException, MetadataBearer {
    message?: string;
}
/**
 * @public
 *
 * Base exception class for the exceptions from the server-side.
 */
export declare class ServiceException extends Error implements SmithyException, MetadataBearer {
    readonly $fault: "client" | "server";
    $response?: HttpResponse;
    $retryable?: RetryableTrait;
    $metadata: ResponseMetadata;
    constructor(options: ServiceExceptionOptions);
    /**
     * Checks if a value is an instance of ServiceException (duck typed)
     */
    static isInstance(value: unknown): value is ServiceException;
    /**
     * Custom instanceof check to support the operator for ServiceException base class
     */
    static [Symbol.hasInstance](instance: unknown): boolean;
}
/**
 * This method inject unmodeled member to a deserialized SDK exception,
 * and load the error message from different possible keys('message',
 * 'Message').
 *
 * @internal
 */
export declare const decorateServiceException: <E extends ServiceException>(exception: E, additions?: Record<string, any>) => E;

```

## ./lib/lambda/node_modules/@smithy/smithy-client/dist-types/extended-encode-uri-component.d.ts

```typescript
/**
 * @internal
 * Backwards compatibility re-export.
 */
export { extendedEncodeURIComponent } from "@smithy/core/protocols";

```

## ./lib/lambda/node_modules/@smithy/smithy-client/dist-types/extensions/checksum.d.ts

```typescript
import type { ChecksumAlgorithm, ChecksumConfiguration, ChecksumConstructor, HashConstructor } from "@smithy/types";
import { AlgorithmId } from "@smithy/types";
export { AlgorithmId, ChecksumAlgorithm, ChecksumConfiguration };
/**
 * @internal
 */
export type PartialChecksumRuntimeConfigType = Partial<{
    sha256: ChecksumConstructor | HashConstructor;
    md5: ChecksumConstructor | HashConstructor;
    crc32: ChecksumConstructor | HashConstructor;
    crc32c: ChecksumConstructor | HashConstructor;
    sha1: ChecksumConstructor | HashConstructor;
}>;
/**
 * @internal
 */
export declare const getChecksumConfiguration: (runtimeConfig: PartialChecksumRuntimeConfigType) => {
    addChecksumAlgorithm(algo: ChecksumAlgorithm): void;
    checksumAlgorithms(): ChecksumAlgorithm[];
};
/**
 * @internal
 */
export declare const resolveChecksumRuntimeConfig: (clientConfig: ChecksumConfiguration) => PartialChecksumRuntimeConfigType;

```

## ./lib/lambda/node_modules/@smithy/smithy-client/dist-types/extensions/defaultExtensionConfiguration.d.ts

```typescript
import type { DefaultExtensionConfiguration } from "@smithy/types";
import type { PartialChecksumRuntimeConfigType } from "./checksum";
import type { PartialRetryRuntimeConfigType } from "./retry";
/**
 * @internal
 */
export type DefaultExtensionRuntimeConfigType = PartialRetryRuntimeConfigType & PartialChecksumRuntimeConfigType;
/**
 * @internal
 *
 * Helper function to resolve default extension configuration from runtime config
 */
export declare const getDefaultExtensionConfiguration: (runtimeConfig: DefaultExtensionRuntimeConfigType) => {
    addChecksumAlgorithm(algo: import("@smithy/types").ChecksumAlgorithm): void;
    checksumAlgorithms(): import("@smithy/types").ChecksumAlgorithm[];
} & {
    setRetryStrategy(retryStrategy: import("@smithy/types").Provider<import("@smithy/types").RetryStrategyV2 | import("@smithy/types").RetryStrategy>): void;
    retryStrategy(): import("@smithy/types").Provider<import("@smithy/types").RetryStrategyV2 | import("@smithy/types").RetryStrategy>;
};
/**
 * @deprecated use getDefaultExtensionConfiguration
 * @internal
 *
 * Helper function to resolve default extension configuration from runtime config
 */
export declare const getDefaultClientConfiguration: (runtimeConfig: DefaultExtensionRuntimeConfigType) => {
    addChecksumAlgorithm(algo: import("@smithy/types").ChecksumAlgorithm): void;
    checksumAlgorithms(): import("@smithy/types").ChecksumAlgorithm[];
} & {
    setRetryStrategy(retryStrategy: import("@smithy/types").Provider<import("@smithy/types").RetryStrategyV2 | import("@smithy/types").RetryStrategy>): void;
    retryStrategy(): import("@smithy/types").Provider<import("@smithy/types").RetryStrategyV2 | import("@smithy/types").RetryStrategy>;
};
/**
 * @internal
 *
 * Helper function to resolve runtime config from default extension configuration
 */
export declare const resolveDefaultRuntimeConfig: (config: DefaultExtensionConfiguration) => DefaultExtensionRuntimeConfigType;

```

## ./lib/lambda/node_modules/@smithy/smithy-client/dist-types/extensions/index.d.ts

```typescript
export * from "./defaultExtensionConfiguration";

```

## ./lib/lambda/node_modules/@smithy/smithy-client/dist-types/extensions/retry.d.ts

```typescript
import type { Provider, RetryStrategy, RetryStrategyConfiguration, RetryStrategyV2 } from "@smithy/types";
/**
 * @internal
 */
export type PartialRetryRuntimeConfigType = Partial<{
    retryStrategy: Provider<RetryStrategyV2 | RetryStrategy>;
}>;
/**
 * @internal
 */
export declare const getRetryConfiguration: (runtimeConfig: PartialRetryRuntimeConfigType) => {
    setRetryStrategy(retryStrategy: Provider<RetryStrategyV2 | RetryStrategy>): void;
    retryStrategy(): Provider<RetryStrategyV2 | RetryStrategy>;
};
/**
 * @internal
 */
export declare const resolveRetryRuntimeConfig: (retryStrategyConfiguration: RetryStrategyConfiguration) => PartialRetryRuntimeConfigType;

```

## ./lib/lambda/node_modules/@smithy/smithy-client/dist-types/get-array-if-single-item.d.ts

```typescript
/**
 * @internal
 *
 * The XML parser will set one K:V for a member that could
 * return multiple entries but only has one.
 */
export declare const getArrayIfSingleItem: <T>(mayBeArray: T) => T | T[];

```

## ./lib/lambda/node_modules/@smithy/smithy-client/dist-types/get-value-from-text-node.d.ts

```typescript
/**
 * @internal
 *
 * Recursively parses object and populates value is node from
 * "#text" key if it's available
 */
export declare const getValueFromTextNode: (obj: any) => any;

```

## ./lib/lambda/node_modules/@smithy/smithy-client/dist-types/index.d.ts

```typescript
export type { DocumentType, SdkError, SmithyException } from "@smithy/types";
export * from "./client";
export * from "./collect-stream-body";
export * from "./command";
export * from "./constants";
export * from "./create-aggregated-client";
export * from "./default-error-handler";
export * from "./defaults-mode";
export * from "./emitWarningIfUnsupportedVersion";
export * from "./exceptions";
export * from "./extended-encode-uri-component";
export * from "./extensions";
export * from "./get-array-if-single-item";
export * from "./get-value-from-text-node";
export * from "./is-serializable-header-value";
export * from "./NoOpLogger";
export * from "./object-mapping";
export * from "./resolve-path";
export * from "./ser-utils";
export * from "./serde-json";
export * from "@smithy/core/serde";

```

## ./lib/lambda/node_modules/@smithy/smithy-client/dist-types/is-serializable-header-value.d.ts

```typescript
/**
 * @internal
 * @returns whether the header value is serializable.
 */
export declare const isSerializableHeaderValue: (value: any) => boolean;

```

## ./lib/lambda/node_modules/@smithy/smithy-client/dist-types/object-mapping.d.ts

```typescript
/**
 * @internal
 *
 * A set of instructions for multiple keys.
 * The aim is to provide a concise yet readable way to map and filter values
 * onto a target object.
 *
 * @example
 * ```javascript
 * const example: ObjectMappingInstructions = {
 *   lazyValue1: [, () => 1],
 *   lazyValue2: [, () => 2],
 *   lazyValue3: [, () => 3],
 *   lazyConditionalValue1: [() => true, () => 4],
 *   lazyConditionalValue2: [() => true, () => 5],
 *   lazyConditionalValue3: [true, () => 6],
 *   lazyConditionalValue4: [false, () => 44],
 *   lazyConditionalValue5: [() => false, () => 55],
 *   lazyConditionalValue6: ["", () => 66],
 *   simpleValue1: [, 7],
 *   simpleValue2: [, 8],
 *   simpleValue3: [, 9],
 *   conditionalValue1: [() => true, 10],
 *   conditionalValue2: [() => true, 11],
 *   conditionalValue3: [{}, 12],
 *   conditionalValue4: [false, 110],
 *   conditionalValue5: [() => false, 121],
 *   conditionalValue6: ["", 132],
 * };
 *
 * const exampleResult: Record<string, any> = {
 *   lazyValue1: 1,
 *   lazyValue2: 2,
 *   lazyValue3: 3,
 *   lazyConditionalValue1: 4,
 *   lazyConditionalValue2: 5,
 *   lazyConditionalValue3: 6,
 *   simpleValue1: 7,
 *   simpleValue2: 8,
 *   simpleValue3: 9,
 *   conditionalValue1: 10,
 *   conditionalValue2: 11,
 *   conditionalValue3: 12,
 * };
 * ```
 */
export type ObjectMappingInstructions = Record<string, ObjectMappingInstruction>;
/**
 * @internal
 *
 * A variant of the object mapping instruction for the `take` function.
 * In this case, the source value is provided to the value function, turning it
 * from a supplier into a mapper.
 */
export type SourceMappingInstructions = Record<string, ValueMapper | SourceMappingInstruction>;
/**
 * @internal
 *
 * An instruction set for assigning a value to a target object.
 */
export type ObjectMappingInstruction = LazyValueInstruction | ConditionalLazyValueInstruction | SimpleValueInstruction | ConditionalValueInstruction | UnfilteredValue;
/**
 * @internal
 *
 * non-array
 */
export type UnfilteredValue = any;
/**
 * @internal
 */
export type LazyValueInstruction = [FilterStatus, ValueSupplier];
/**
 * @internal
 */
export type ConditionalLazyValueInstruction = [FilterStatusSupplier, ValueSupplier];
/**
 * @internal
 */
export type SimpleValueInstruction = [FilterStatus, Value];
/**
 * @internal
 */
export type ConditionalValueInstruction = [ValueFilteringFunction, Value];
/**
 * @internal
 */
export type SourceMappingInstruction = [(ValueFilteringFunction | FilterStatus)?, ValueMapper?, string?];
/**
 * @internal
 *
 * Filter is considered passed if
 * 1. It is a boolean true.
 * 2. It is not undefined and is itself truthy.
 * 3. It is undefined and the corresponding _value_ is neither null nor undefined.
 */
export type FilterStatus = boolean | unknown | void;
/**
 * @internal
 *
 * Supplies the filter check but not against any value as input.
 */
export type FilterStatusSupplier = () => boolean;
/**
 * @internal
 *
 * Filter check with the given value.
 */
export type ValueFilteringFunction = (value: any) => boolean;
/**
 * @internal
 *
 * Supplies the value for lazy evaluation.
 */
export type ValueSupplier = () => any;
/**
 * @internal
 *
 * A function that maps the source value to the target value.
 * Defaults to pass-through with nullish check.
 */
export type ValueMapper = (value: any) => any;
/**
 * @internal
 *
 * A non-function value.
 */
export type Value = any;
/**
 * @internal
 * Internal/Private, for codegen use only.
 *
 * Transfer a set of keys from [instructions] to [target].
 *
 * For each instruction in the record, the target key will be the instruction key.
 * The target assignment will be conditional on the instruction's filter.
 * The target assigned value will be supplied by the instructions as an evaluable function or non-function value.
 *
 * @see ObjectMappingInstructions for an example.
 */
export declare function map(target: any, filter: (value: any) => boolean, instructions: Record<string, ValueSupplier | Value>): typeof target;
/**
 * @internal
 */
export declare function map(instructions: ObjectMappingInstructions): any;
/**
 * @internal
 */
export declare function map(target: any, instructions: ObjectMappingInstructions): typeof target;
/**
 * Convert a regular object `{ k: v }` to `{ k: [, v] }` mapping instruction set with default
 * filter.
 *
 * @internal
 */
export declare const convertMap: (target: any) => Record<string, any>;
/**
 * @param source - original object with data.
 * @param instructions - how to map the data.
 * @returns new object mapped from the source object.
 * @internal
 */
export declare const take: (source: any, instructions: SourceMappingInstructions) => any;

```

## ./lib/lambda/node_modules/@smithy/smithy-client/dist-types/resolve-path.d.ts

```typescript
/**
 * @internal
 * Backwards compatibility re-export.
 */
export { resolvedPath } from "@smithy/core/protocols";

```

## ./lib/lambda/node_modules/@smithy/smithy-client/dist-types/schemaLogFilter.d.ts

```typescript
import type { SchemaRef } from "@smithy/types";
/**
 * Redacts sensitive parts of any data object using its schema, for logging.
 *
 * @internal
 * @param schema - with filtering traits.
 * @param data - to be logged.
 */
export declare function schemaLogFilter(schema: SchemaRef, data: unknown): any;

```

## ./lib/lambda/node_modules/@smithy/smithy-client/dist-types/ser-utils.d.ts

```typescript
/**
 * @internal
 *
 * Serializes a number, turning non-numeric values into strings.
 *
 * @param value - The number to serialize.
 * @returns A number, or a string if the given number was non-numeric.
 */
export declare const serializeFloat: (value: number) => string | number;
/**
 * @internal
 * @param date - to be serialized.
 * @returns https://smithy.io/2.0/spec/protocol-traits.html#timestampformat-trait date-time format.
 */
export declare const serializeDateTime: (date: Date) => string;

```

## ./lib/lambda/node_modules/@smithy/smithy-client/dist-types/serde-json.d.ts

```typescript
/**
 * @internal
 *
 * Maps an object through the default JSON serde behavior.
 * This means removing nullish fields and un-sparsifying lists.
 *
 * This is also used by Smithy RPCv2 CBOR as the default serde behavior.
 *
 * @param obj - to be checked.
 * @returns same object with default serde behavior applied.
 */
export declare const _json: (obj: any) => any;

```

## ./lib/lambda/node_modules/@smithy/smithy-client/dist-types/ts3.4/NoOpLogger.d.ts

```typescript
import { Logger } from "@smithy/types";
/**
 * @internal
 */
export declare class NoOpLogger implements Logger {
    trace(): void;
    debug(): void;
    info(): void;
    warn(): void;
    error(): void;
}

```

## ./lib/lambda/node_modules/@smithy/smithy-client/dist-types/ts3.4/client.d.ts

```typescript
import { Client as IClient, Command, FetchHttpHandlerOptions, MetadataBearer, MiddlewareStack, NodeHttpHandlerOptions, RequestHandler } from "@smithy/types";
/**
 * @public
 */
export interface SmithyConfiguration<HandlerOptions> {
    requestHandler: RequestHandler<any, any, HandlerOptions> | NodeHttpHandlerOptions | FetchHttpHandlerOptions | Record<string, unknown>;
    /**
     * The API version set internally by the SDK, and is
     * not planned to be used by customer code.
     * @internal
     */
    readonly apiVersion: string;
    /**
     * @public
     *
     * Default false.
     *
     * When true, the client will only resolve the middleware stack once per
     * Command class. This means modifying the middlewareStack of the
     * command or client after requests have been made will not be
     * recognized.
     *
     * Calling client.destroy() also clears this cache.
     *
     * Enable this only if needing the additional time saved (0-1ms per request)
     * and not needing middleware modifications between requests.
     */
    cacheMiddleware?: boolean;
}
/**
 * @internal
 */
export type SmithyResolvedConfiguration<HandlerOptions> = {
    requestHandler: RequestHandler<any, any, HandlerOptions>;
    readonly apiVersion: string;
    cacheMiddleware?: boolean;
};
/**
 * @public
 */
export declare class Client<HandlerOptions, ClientInput extends object, ClientOutput extends MetadataBearer, ResolvedClientConfiguration extends SmithyResolvedConfiguration<HandlerOptions>> implements IClient<ClientInput, ClientOutput, ResolvedClientConfiguration> {
    readonly config: ResolvedClientConfiguration;
    middlewareStack: MiddlewareStack<ClientInput, ClientOutput>;
    /**
     * Holds an object reference to the initial configuration object.
     * Used to check that the config resolver stack does not create
     * dangling instances of an intermediate form of the configuration object.
     *
     * @internal
     */
    initConfig?: object;
    /**
     * May be used to cache the resolved handler function for a Command class.
     */
    private handlers?;
    constructor(config: ResolvedClientConfiguration);
    send<InputType extends ClientInput, OutputType extends ClientOutput>(command: Command<ClientInput, InputType, ClientOutput, OutputType, SmithyResolvedConfiguration<HandlerOptions>>, options?: HandlerOptions): Promise<OutputType>;
    send<InputType extends ClientInput, OutputType extends ClientOutput>(command: Command<ClientInput, InputType, ClientOutput, OutputType, SmithyResolvedConfiguration<HandlerOptions>>, cb: (err: any, data?: OutputType) => void): void;
    send<InputType extends ClientInput, OutputType extends ClientOutput>(command: Command<ClientInput, InputType, ClientOutput, OutputType, SmithyResolvedConfiguration<HandlerOptions>>, options: HandlerOptions, cb: (err: any, data?: OutputType) => void): void;
    destroy(): void;
}

```

## ./lib/lambda/node_modules/@smithy/smithy-client/dist-types/ts3.4/collect-stream-body.d.ts

```typescript
/**
 * @internal
 * Backwards compatibility re-export.
 */
export { collectBody } from "@smithy/core/protocols";

```

## ./lib/lambda/node_modules/@smithy/smithy-client/dist-types/ts3.4/command.d.ts

```typescript
import { EndpointParameterInstructions } from "@smithy/middleware-endpoint";
import { Command as ICommand, Handler, HandlerExecutionContext, HttpRequest as IHttpRequest, HttpResponse as IHttpResponse, Logger, MetadataBearer, MiddlewareStack as IMiddlewareStack, OperationSchema, OptionalParameter, Pluggable, RequestHandler, SerdeContext, StaticOperationSchema } from "@smithy/types";
/**
 * @public
 */
export declare abstract class Command<Input extends ClientInput, Output extends ClientOutput, ResolvedClientConfiguration, ClientInput extends object = any, ClientOutput extends MetadataBearer = any> implements ICommand<ClientInput, Input, ClientOutput, Output, ResolvedClientConfiguration> {
    abstract input: Input;
    readonly middlewareStack: IMiddlewareStack<Input, Output>;
    readonly schema?: OperationSchema | StaticOperationSchema;
    /**
     * Factory for Command ClassBuilder.
     * @internal
     */
    static classBuilder<I extends SI, O extends SO, C extends {
        logger: Logger;
        requestHandler: RequestHandler<any, any, any>;
    }, SI extends object = any, SO extends MetadataBearer = any>(): ClassBuilder<I, O, C, SI, SO>;
    abstract resolveMiddleware(stack: IMiddlewareStack<ClientInput, ClientOutput>, configuration: ResolvedClientConfiguration, options: any): Handler<Input, Output>;
    /**
     * @internal
     */
    resolveMiddlewareWithContext(clientStack: IMiddlewareStack<any, any>, configuration: {
        logger: Logger;
        requestHandler: RequestHandler<any, any, any>;
    }, options: any, { middlewareFn, clientName, commandName, inputFilterSensitiveLog, outputFilterSensitiveLog, smithyContext, additionalContext, CommandCtor, }: ResolveMiddlewareContextArgs): import("@smithy/types").InitializeHandler<any, Output>;
}
/**
 * @internal
 */
type ResolveMiddlewareContextArgs = {
    middlewareFn: (CommandCtor: any, clientStack: any, config: any, options: any) => Pluggable<any, any>[];
    clientName: string;
    commandName: string;
    smithyContext: Record<string, unknown>;
    additionalContext: HandlerExecutionContext;
    inputFilterSensitiveLog: (_: any) => any;
    outputFilterSensitiveLog: (_: any) => any;
    CommandCtor: any;
};
/**
 * @internal
 */
declare class ClassBuilder<I extends SI, O extends SO, C extends {
    logger: Logger;
    requestHandler: RequestHandler<any, any, any>;
}, SI extends object = any, SO extends MetadataBearer = any> {
    private _init;
    private _ep;
    private _middlewareFn;
    private _commandName;
    private _clientName;
    private _additionalContext;
    private _smithyContext;
    private _inputFilterSensitiveLog;
    private _outputFilterSensitiveLog;
    private _serializer;
    private _deserializer;
    private _operationSchema?;
    /**
     * Optional init callback.
     */
    init(cb: (_: Command<I, O, C, SI, SO>) => void): void;
    /**
     * Set the endpoint parameter instructions.
     */
    ep(endpointParameterInstructions: EndpointParameterInstructions): ClassBuilder<I, O, C, SI, SO>;
    /**
     * Add any number of middleware.
     */
    m(middlewareSupplier: (CommandCtor: any, clientStack: any, config: any, options: any) => Pluggable<any, any>[]): ClassBuilder<I, O, C, SI, SO>;
    /**
     * Set the initial handler execution context Smithy field.
     */
    s(service: string, operation: string, smithyContext?: Record<string, unknown>): ClassBuilder<I, O, C, SI, SO>;
    /**
     * Set the initial handler execution context.
     */
    c(additionalContext?: HandlerExecutionContext): ClassBuilder<I, O, C, SI, SO>;
    /**
     * Set constant string identifiers for the operation.
     */
    n(clientName: string, commandName: string): ClassBuilder<I, O, C, SI, SO>;
    /**
     * Set the input and output sensistive log filters.
     */
    f(inputFilter?: (_: any) => any, outputFilter?: (_: any) => any): ClassBuilder<I, O, C, SI, SO>;
    /**
     * Sets the serializer.
     */
    ser(serializer: (input: I, context?: SerdeContext | any) => Promise<IHttpRequest>): ClassBuilder<I, O, C, SI, SO>;
    /**
     * Sets the deserializer.
     */
    de(deserializer: (output: IHttpResponse, context?: SerdeContext | any) => Promise<O>): ClassBuilder<I, O, C, SI, SO>;
    /**
     * Sets input/output schema for the operation.
     */
    sc(operation: OperationSchema | StaticOperationSchema): ClassBuilder<I, O, C, SI, SO>;
    /**
     * @returns a Command class with the classBuilder properties.
     */
    build(): {
        new (input: I): CommandImpl<I, O, C, SI, SO>;
        new (...[input]: OptionalParameter<I>): CommandImpl<I, O, C, SI, SO>;
        getEndpointParameterInstructions(): EndpointParameterInstructions;
    };
}
/**
 * A concrete implementation of ICommand with no abstract members.
 * @public
 */
export interface CommandImpl<I extends SI, O extends SO, C extends {
    logger: Logger;
    requestHandler: RequestHandler<any, any, any>;
}, SI extends object = any, SO extends MetadataBearer = any> extends Command<I, O, C, SI, SO> {
    readonly input: I;
    resolveMiddleware(stack: IMiddlewareStack<SI, SO>, configuration: C, options: any): Handler<I, O>;
}
export {};

```

## ./lib/lambda/node_modules/@smithy/smithy-client/dist-types/ts3.4/constants.d.ts

```typescript
/**
 * @internal
 */
export declare const SENSITIVE_STRING = "***SensitiveInformation***";

```

## ./lib/lambda/node_modules/@smithy/smithy-client/dist-types/ts3.4/create-aggregated-client.d.ts

```typescript
import { Client } from "./client";
/**
 * @internal
 *
 * @param commands - command lookup container.
 * @param client - client instance on which to add aggregated methods.
 * @returns an aggregated client with dynamically created methods.
 */
export declare const createAggregatedClient: (commands: Record<string, any>, Client: {
    new (...args: any): Client<any, any, any, any>;
}) => void;

```

## ./lib/lambda/node_modules/@smithy/smithy-client/dist-types/ts3.4/default-error-handler.d.ts

```typescript
/**
 * Always throws an error with the given `exceptionCtor` and other arguments.
 * This is only called from an error handling code path.
 *
 * @internal
 */
export declare const throwDefaultError: ({ output, parsedBody, exceptionCtor, errorCode }: any) => never;
/**
 * @internal
 *
 * Creates {@link throwDefaultError} with bound ExceptionCtor.
 */
export declare const withBaseException: (ExceptionCtor: {
    new (...args: any): any;
}) => any;

```

## ./lib/lambda/node_modules/@smithy/smithy-client/dist-types/ts3.4/defaults-mode.d.ts

```typescript
/**
 * @internal
 */
export declare const loadConfigsForDefaultMode: (mode: ResolvedDefaultsMode) => DefaultsModeConfigs;
/**
 * Option determining how certain default configuration options are resolved in the SDK. It can be one of the value listed below:
 * * `"standard"`: <p>The STANDARD mode provides the latest recommended default values that should be safe to run in most scenarios</p><p>Note that the default values vended from this mode might change as best practices may evolve. As a result, it is encouraged to perform tests when upgrading the SDK</p>
 * * `"in-region"`: <p>The IN_REGION mode builds on the standard mode and includes optimization tailored for applications which call AWS services from within the same AWS region</p><p>Note that the default values vended from this mode might change as best practices may evolve. As a result, it is encouraged to perform tests when upgrading the SDK</p>
 * * `"cross-region"`: <p>The CROSS_REGION mode builds on the standard mode and includes optimization tailored for applications which call AWS services in a different region</p><p>Note that the default values vended from this mode might change as best practices may evolve. As a result, it is encouraged to perform tests when upgrading the SDK</p>
 * * `"mobile"`: <p>The MOBILE mode builds on the standard mode and includes optimization tailored for mobile applications</p><p>Note that the default values vended from this mode might change as best practices may evolve. As a result, it is encouraged to perform tests when upgrading the SDK</p>
 * * `"auto"`: <p>The AUTO mode is an experimental mode that builds on the standard mode. The SDK will attempt to discover the execution environment to determine the appropriate settings automatically.</p><p>Note that the auto detection is heuristics-based and does not guarantee 100% accuracy. STANDARD mode will be used if the execution environment cannot be determined. The auto detection might query <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html">EC2 Instance Metadata service</a>, which might introduce latency. Therefore we recommend choosing an explicit defaults_mode instead if startup latency is critical to your application</p>
 * * `"legacy"`: <p>The LEGACY mode provides default settings that vary per SDK and were used prior to establishment of defaults_mode</p>
 *
 * @defaultValue "legacy"
 */
export type DefaultsMode = "standard" | "in-region" | "cross-region" | "mobile" | "auto" | "legacy";
/**
 * @internal
 */
export type ResolvedDefaultsMode = Exclude<DefaultsMode, "auto">;
/**
 * @internal
 */
export interface DefaultsModeConfigs {
    retryMode?: string;
    connectionTimeout?: number;
    requestTimeout?: number;
}

```

## ./lib/lambda/node_modules/@smithy/smithy-client/dist-types/ts3.4/emitWarningIfUnsupportedVersion.d.ts

```typescript
/**
 * @internal
 *
 * Emits warning if the provided Node.js version string is pending deprecation.
 *
 * @param version - The Node.js version string.
 */
export declare const emitWarningIfUnsupportedVersion: (version: string) => void;

```

## ./lib/lambda/node_modules/@smithy/smithy-client/dist-types/ts3.4/exceptions.d.ts

```typescript
import { HttpResponse, MetadataBearer, ResponseMetadata, RetryableTrait, SmithyException } from "@smithy/types";
/**
 * The type of the exception class constructor parameter. The returned type contains the properties
 * in the `ExceptionType` but not in the `BaseExceptionType`. If the `BaseExceptionType` contains
 * `$metadata` and `message` properties, it's also included in the returned type.
 * @internal
 */
export type ExceptionOptionType<ExceptionType extends Error, BaseExceptionType extends Error> = Pick<ExceptionType, Exclude<keyof ExceptionType, Exclude<keyof BaseExceptionType, "$metadata" | "message">>>;
/**
 * @public
 */
export interface ServiceExceptionOptions extends SmithyException, MetadataBearer {
    message?: string;
}
/**
 * @public
 *
 * Base exception class for the exceptions from the server-side.
 */
export declare class ServiceException extends Error implements SmithyException, MetadataBearer {
    readonly $fault: "client" | "server";
    $response?: HttpResponse;
    $retryable?: RetryableTrait;
    $metadata: ResponseMetadata;
    constructor(options: ServiceExceptionOptions);
    /**
     * Checks if a value is an instance of ServiceException (duck typed)
     */
    static isInstance(value: unknown): value is ServiceException;
    /**
     * Custom instanceof check to support the operator for ServiceException base class
     */
    static [Symbol.hasInstance](instance: unknown): boolean;
}
/**
 * This method inject unmodeled member to a deserialized SDK exception,
 * and load the error message from different possible keys('message',
 * 'Message').
 *
 * @internal
 */
export declare const decorateServiceException: <E extends ServiceException>(exception: E, additions?: Record<string, any>) => E;

```

## ./lib/lambda/node_modules/@smithy/smithy-client/dist-types/ts3.4/extended-encode-uri-component.d.ts

```typescript
/**
 * @internal
 * Backwards compatibility re-export.
 */
export { extendedEncodeURIComponent } from "@smithy/core/protocols";

```

## ./lib/lambda/node_modules/@smithy/smithy-client/dist-types/ts3.4/extensions/checksum.d.ts

```typescript
import { ChecksumAlgorithm, ChecksumConfiguration, ChecksumConstructor, HashConstructor } from "@smithy/types";
import { AlgorithmId } from "@smithy/types";
export { AlgorithmId, ChecksumAlgorithm, ChecksumConfiguration };
/**
 * @internal
 */
export type PartialChecksumRuntimeConfigType = Partial<{
    sha256: ChecksumConstructor | HashConstructor;
    md5: ChecksumConstructor | HashConstructor;
    crc32: ChecksumConstructor | HashConstructor;
    crc32c: ChecksumConstructor | HashConstructor;
    sha1: ChecksumConstructor | HashConstructor;
}>;
/**
 * @internal
 */
export declare const getChecksumConfiguration: (runtimeConfig: PartialChecksumRuntimeConfigType) => {
    addChecksumAlgorithm(algo: ChecksumAlgorithm): void;
    checksumAlgorithms(): ChecksumAlgorithm[];
};
/**
 * @internal
 */
export declare const resolveChecksumRuntimeConfig: (clientConfig: ChecksumConfiguration) => PartialChecksumRuntimeConfigType;

```

## ./lib/lambda/node_modules/@smithy/smithy-client/dist-types/ts3.4/extensions/defaultExtensionConfiguration.d.ts

```typescript
import { DefaultExtensionConfiguration } from "@smithy/types";
import { PartialChecksumRuntimeConfigType } from "./checksum";
import { PartialRetryRuntimeConfigType } from "./retry";
/**
 * @internal
 */
export type DefaultExtensionRuntimeConfigType = PartialRetryRuntimeConfigType & PartialChecksumRuntimeConfigType;
/**
 * @internal
 *
 * Helper function to resolve default extension configuration from runtime config
 */
export declare const getDefaultExtensionConfiguration: (runtimeConfig: DefaultExtensionRuntimeConfigType) => {
    addChecksumAlgorithm(algo: import("@smithy/types").ChecksumAlgorithm): void;
    checksumAlgorithms(): import("@smithy/types").ChecksumAlgorithm[];
} & {
    setRetryStrategy(retryStrategy: import("@smithy/types").Provider<import("@smithy/types").RetryStrategyV2 | import("@smithy/types").RetryStrategy>): void;
    retryStrategy(): import("@smithy/types").Provider<import("@smithy/types").RetryStrategyV2 | import("@smithy/types").RetryStrategy>;
};
/**
 * @deprecated use getDefaultExtensionConfiguration
 * @internal
 *
 * Helper function to resolve default extension configuration from runtime config
 */
export declare const getDefaultClientConfiguration: (runtimeConfig: DefaultExtensionRuntimeConfigType) => {
    addChecksumAlgorithm(algo: import("@smithy/types").ChecksumAlgorithm): void;
    checksumAlgorithms(): import("@smithy/types").ChecksumAlgorithm[];
} & {
    setRetryStrategy(retryStrategy: import("@smithy/types").Provider<import("@smithy/types").RetryStrategyV2 | import("@smithy/types").RetryStrategy>): void;
    retryStrategy(): import("@smithy/types").Provider<import("@smithy/types").RetryStrategyV2 | import("@smithy/types").RetryStrategy>;
};
/**
 * @internal
 *
 * Helper function to resolve runtime config from default extension configuration
 */
export declare const resolveDefaultRuntimeConfig: (config: DefaultExtensionConfiguration) => DefaultExtensionRuntimeConfigType;

```

## ./lib/lambda/node_modules/@smithy/smithy-client/dist-types/ts3.4/extensions/index.d.ts

```typescript
export * from "./defaultExtensionConfiguration";

```

## ./lib/lambda/node_modules/@smithy/smithy-client/dist-types/ts3.4/extensions/retry.d.ts

```typescript
import { Provider, RetryStrategy, RetryStrategyConfiguration, RetryStrategyV2 } from "@smithy/types";
/**
 * @internal
 */
export type PartialRetryRuntimeConfigType = Partial<{
    retryStrategy: Provider<RetryStrategyV2 | RetryStrategy>;
}>;
/**
 * @internal
 */
export declare const getRetryConfiguration: (runtimeConfig: PartialRetryRuntimeConfigType) => {
    setRetryStrategy(retryStrategy: Provider<RetryStrategyV2 | RetryStrategy>): void;
    retryStrategy(): Provider<RetryStrategyV2 | RetryStrategy>;
};
/**
 * @internal
 */
export declare const resolveRetryRuntimeConfig: (retryStrategyConfiguration: RetryStrategyConfiguration) => PartialRetryRuntimeConfigType;

```

## ./lib/lambda/node_modules/@smithy/smithy-client/dist-types/ts3.4/get-array-if-single-item.d.ts

```typescript
/**
 * @internal
 *
 * The XML parser will set one K:V for a member that could
 * return multiple entries but only has one.
 */
export declare const getArrayIfSingleItem: <T>(mayBeArray: T) => T | T[];

```

## ./lib/lambda/node_modules/@smithy/smithy-client/dist-types/ts3.4/get-value-from-text-node.d.ts

```typescript
/**
 * @internal
 *
 * Recursively parses object and populates value is node from
 * "#text" key if it's available
 */
export declare const getValueFromTextNode: (obj: any) => any;

```

## ./lib/lambda/node_modules/@smithy/smithy-client/dist-types/ts3.4/index.d.ts

```typescript
export { DocumentType, SdkError, SmithyException } from "@smithy/types";
export * from "./client";
export * from "./collect-stream-body";
export * from "./command";
export * from "./constants";
export * from "./create-aggregated-client";
export * from "./default-error-handler";
export * from "./defaults-mode";
export * from "./emitWarningIfUnsupportedVersion";
export * from "./exceptions";
export * from "./extended-encode-uri-component";
export * from "./extensions";
export * from "./get-array-if-single-item";
export * from "./get-value-from-text-node";
export * from "./is-serializable-header-value";
export * from "./NoOpLogger";
export * from "./object-mapping";
export * from "./resolve-path";
export * from "./ser-utils";
export * from "./serde-json";
export * from "@smithy/core/serde";

```

## ./lib/lambda/node_modules/@smithy/smithy-client/dist-types/ts3.4/is-serializable-header-value.d.ts

```typescript
/**
 * @internal
 * @returns whether the header value is serializable.
 */
export declare const isSerializableHeaderValue: (value: any) => boolean;

```

## ./lib/lambda/node_modules/@smithy/smithy-client/dist-types/ts3.4/object-mapping.d.ts

```typescript
/**
 * @internal
 *
 * A set of instructions for multiple keys.
 * The aim is to provide a concise yet readable way to map and filter values
 * onto a target object.
 *
 * @example
 * ```javascript
 * const example: ObjectMappingInstructions = {
 *   lazyValue1: [, () => 1],
 *   lazyValue2: [, () => 2],
 *   lazyValue3: [, () => 3],
 *   lazyConditionalValue1: [() => true, () => 4],
 *   lazyConditionalValue2: [() => true, () => 5],
 *   lazyConditionalValue3: [true, () => 6],
 *   lazyConditionalValue4: [false, () => 44],
 *   lazyConditionalValue5: [() => false, () => 55],
 *   lazyConditionalValue6: ["", () => 66],
 *   simpleValue1: [, 7],
 *   simpleValue2: [, 8],
 *   simpleValue3: [, 9],
 *   conditionalValue1: [() => true, 10],
 *   conditionalValue2: [() => true, 11],
 *   conditionalValue3: [{}, 12],
 *   conditionalValue4: [false, 110],
 *   conditionalValue5: [() => false, 121],
 *   conditionalValue6: ["", 132],
 * };
 *
 * const exampleResult: Record<string, any> = {
 *   lazyValue1: 1,
 *   lazyValue2: 2,
 *   lazyValue3: 3,
 *   lazyConditionalValue1: 4,
 *   lazyConditionalValue2: 5,
 *   lazyConditionalValue3: 6,
 *   simpleValue1: 7,
 *   simpleValue2: 8,
 *   simpleValue3: 9,
 *   conditionalValue1: 10,
 *   conditionalValue2: 11,
 *   conditionalValue3: 12,
 * };
 * ```
 */
export type ObjectMappingInstructions = Record<string, ObjectMappingInstruction>;
/**
 * @internal
 *
 * A variant of the object mapping instruction for the `take` function.
 * In this case, the source value is provided to the value function, turning it
 * from a supplier into a mapper.
 */
export type SourceMappingInstructions = Record<string, ValueMapper | SourceMappingInstruction>;
/**
 * @internal
 *
 * An instruction set for assigning a value to a target object.
 */
export type ObjectMappingInstruction = LazyValueInstruction | ConditionalLazyValueInstruction | SimpleValueInstruction | ConditionalValueInstruction | UnfilteredValue;
/**
 * @internal
 *
 * non-array
 */
export type UnfilteredValue = any;
/**
 * @internal
 */
export type LazyValueInstruction = [
    FilterStatus,
    ValueSupplier
];
/**
 * @internal
 */
export type ConditionalLazyValueInstruction = [
    FilterStatusSupplier,
    ValueSupplier
];
/**
 * @internal
 */
export type SimpleValueInstruction = [
    FilterStatus,
    Value
];
/**
 * @internal
 */
export type ConditionalValueInstruction = [
    ValueFilteringFunction,
    Value
];
/**
 * @internal
 */
export type SourceMappingInstruction = [
    (ValueFilteringFunction | FilterStatus)?,
    ValueMapper?,
    string?
];
/**
 * @internal
 *
 * Filter is considered passed if
 * 1. It is a boolean true.
 * 2. It is not undefined and is itself truthy.
 * 3. It is undefined and the corresponding _value_ is neither null nor undefined.
 */
export type FilterStatus = boolean | unknown | void;
/**
 * @internal
 *
 * Supplies the filter check but not against any value as input.
 */
export type FilterStatusSupplier = () => boolean;
/**
 * @internal
 *
 * Filter check with the given value.
 */
export type ValueFilteringFunction = (value: any) => boolean;
/**
 * @internal
 *
 * Supplies the value for lazy evaluation.
 */
export type ValueSupplier = () => any;
/**
 * @internal
 *
 * A function that maps the source value to the target value.
 * Defaults to pass-through with nullish check.
 */
export type ValueMapper = (value: any) => any;
/**
 * @internal
 *
 * A non-function value.
 */
export type Value = any;
/**
 * @internal
 * Internal/Private, for codegen use only.
 *
 * Transfer a set of keys from [instructions] to [target].
 *
 * For each instruction in the record, the target key will be the instruction key.
 * The target assignment will be conditional on the instruction's filter.
 * The target assigned value will be supplied by the instructions as an evaluable function or non-function value.
 *
 * @see ObjectMappingInstructions for an example.
 */
export declare function map(target: any, filter: (value: any) => boolean, instructions: Record<string, ValueSupplier | Value>): typeof target;
/**
 * @internal
 */
export declare function map(instructions: ObjectMappingInstructions): any;
/**
 * @internal
 */
export declare function map(target: any, instructions: ObjectMappingInstructions): typeof target;
/**
 * Convert a regular object `{ k: v }` to `{ k: [, v] }` mapping instruction set with default
 * filter.
 *
 * @internal
 */
export declare const convertMap: (target: any) => Record<string, any>;
/**
 * @param source - original object with data.
 * @param instructions - how to map the data.
 * @returns new object mapped from the source object.
 * @internal
 */
export declare const take: (source: any, instructions: SourceMappingInstructions) => any;

```

## ./lib/lambda/node_modules/@smithy/smithy-client/dist-types/ts3.4/resolve-path.d.ts

```typescript
/**
 * @internal
 * Backwards compatibility re-export.
 */
export { resolvedPath } from "@smithy/core/protocols";

```

## ./lib/lambda/node_modules/@smithy/smithy-client/dist-types/ts3.4/schemaLogFilter.d.ts

```typescript
import { SchemaRef } from "@smithy/types";
/**
 * Redacts sensitive parts of any data object using its schema, for logging.
 *
 * @internal
 * @param schema - with filtering traits.
 * @param data - to be logged.
 */
export declare function schemaLogFilter(schema: SchemaRef, data: unknown): any;

```

## ./lib/lambda/node_modules/@smithy/smithy-client/dist-types/ts3.4/ser-utils.d.ts

```typescript
/**
 * @internal
 *
 * Serializes a number, turning non-numeric values into strings.
 *
 * @param value - The number to serialize.
 * @returns A number, or a string if the given number was non-numeric.
 */
export declare const serializeFloat: (value: number) => string | number;
/**
 * @internal
 * @param date - to be serialized.
 * @returns https://smithy.io/2.0/spec/protocol-traits.html#timestampformat-trait date-time format.
 */
export declare const serializeDateTime: (date: Date) => string;

```

## ./lib/lambda/node_modules/@smithy/smithy-client/dist-types/ts3.4/serde-json.d.ts

```typescript
/**
 * @internal
 *
 * Maps an object through the default JSON serde behavior.
 * This means removing nullish fields and un-sparsifying lists.
 *
 * This is also used by Smithy RPCv2 CBOR as the default serde behavior.
 *
 * @param obj - to be checked.
 * @returns same object with default serde behavior applied.
 */
export declare const _json: (obj: any) => any;

```

## ./lib/lambda/node_modules/@smithy/smithy-client/package.json

```json
{
  "name": "@smithy/smithy-client",
  "version": "4.9.0",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline smithy-client",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "rimraf dist-types/ts3.4 && downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../../.prettierignore --write \"**/*.{ts,md,json}\"",
    "extract:docs": "node ./scripts/fix-api-extractor && api-extractor run --local && node ./scripts/fix-api-extractor --unset",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "sideEffects": false,
  "dependencies": {
    "@smithy/core": "^3.17.0",
    "@smithy/middleware-endpoint": "^4.3.4",
    "@smithy/middleware-stack": "^4.2.3",
    "@smithy/protocol-http": "^5.3.3",
    "@smithy/types": "^4.8.0",
    "@smithy/util-stream": "^4.5.3",
    "tslib": "^2.6.2"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/smithy-lang/smithy-typescript/tree/main/packages/smithy-client",
  "repository": {
    "type": "git",
    "url": "https://github.com/smithy-lang/smithy-typescript.git",
    "directory": "packages/smithy-client"
  },
  "devDependencies": {
    "@types/node": "^18.11.9",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  }
}
```

## ./lib/lambda/node_modules/@smithy/types/dist-types/abort-handler.d.ts

```typescript
import type { AbortSignal as DeprecatedAbortSignal } from "./abort";
/**
 * @public
 */
export interface AbortHandler {
    (this: AbortSignal | DeprecatedAbortSignal, ev: any): any;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/abort.d.ts

```typescript
import type { AbortHandler } from "./abort-handler";
/**
 * @public
 */
export { AbortHandler };
/**
 * @public
 * @deprecated use platform (global) type for AbortSignal.
 *
 * Holders of an AbortSignal object may query if the associated operation has
 * been aborted and register an onabort handler.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal
 */
export interface AbortSignal {
    /**
     * Whether the action represented by this signal has been cancelled.
     */
    readonly aborted: boolean;
    /**
     * A function to be invoked when the action represented by this signal has
     * been cancelled.
     */
    onabort: AbortHandler | Function | null;
}
/**
 * @public
 * @deprecated use platform (global) type for AbortController.
 *
 * The AWS SDK uses a Controller/Signal model to allow for cooperative
 * cancellation of asynchronous operations. When initiating such an operation,
 * the caller can create an AbortController and then provide linked signal to
 * subtasks. This allows a single source to communicate to multiple consumers
 * that an action has been aborted without dictating how that cancellation
 * should be handled.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/AbortController
 */
export interface AbortController {
    /**
     * An object that reports whether the action associated with this
     * `AbortController` has been cancelled.
     */
    readonly signal: AbortSignal;
    /**
     * Declares the operation associated with this AbortController to have been
     * cancelled.
     */
    abort(): void;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/auth/HttpApiKeyAuth.d.ts

```typescript
/**
 * @internal
 */
export declare enum HttpApiKeyAuthLocation {
    HEADER = "header",
    QUERY = "query"
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/auth/HttpAuthScheme.d.ts

```typescript
import type { Identity, IdentityProvider } from "../identity/identity";
import type { HandlerExecutionContext } from "../middleware";
import type { HttpSigner } from "./HttpSigner";
import type { IdentityProviderConfig } from "./IdentityProviderConfig";
/**
 * ID for {@link HttpAuthScheme}
 * @internal
 */
export type HttpAuthSchemeId = string;
/**
 * Interface that defines an HttpAuthScheme
 * @internal
 */
export interface HttpAuthScheme {
    /**
     * ID for an HttpAuthScheme, typically the absolute shape ID of a Smithy auth trait.
     */
    schemeId: HttpAuthSchemeId;
    /**
     * Gets the IdentityProvider corresponding to an HttpAuthScheme.
     */
    identityProvider(config: IdentityProviderConfig): IdentityProvider<Identity> | undefined;
    /**
     * HttpSigner corresponding to an HttpAuthScheme.
     */
    signer: HttpSigner;
}
/**
 * Interface that defines the identity and signing properties when selecting
 * an HttpAuthScheme.
 * @internal
 */
export interface HttpAuthOption {
    schemeId: HttpAuthSchemeId;
    identityProperties?: Record<string, unknown>;
    signingProperties?: Record<string, unknown>;
    propertiesExtractor?: <TConfig extends object, TContext extends HandlerExecutionContext>(config: TConfig, context: TContext) => {
        identityProperties?: Record<string, unknown>;
        signingProperties?: Record<string, unknown>;
    };
}
/**
 * @internal
 */
export interface SelectedHttpAuthScheme {
    httpAuthOption: HttpAuthOption;
    identity: Identity;
    signer: HttpSigner;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/auth/HttpAuthSchemeProvider.d.ts

```typescript
import type { HandlerExecutionContext } from "../middleware";
import type { HttpAuthOption } from "./HttpAuthScheme";
/**
 * @internal
 */
export interface HttpAuthSchemeParameters {
    operation?: string;
}
/**
 * @internal
 */
export interface HttpAuthSchemeProvider<TParameters extends HttpAuthSchemeParameters> {
    (authParameters: TParameters): HttpAuthOption[];
}
/**
 * @internal
 */
export interface HttpAuthSchemeParametersProvider<TConfig extends object, TContext extends HandlerExecutionContext, TParameters extends HttpAuthSchemeParameters, TInput extends object> {
    (config: TConfig, context: TContext, input: TInput): Promise<TParameters>;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/auth/HttpSigner.d.ts

```typescript
import type { HttpRequest, HttpResponse } from "../http";
import type { Identity } from "../identity/identity";
/**
 * @internal
 */
export interface ErrorHandler {
    (signingProperties: Record<string, unknown>): <E extends Error>(error: E) => never;
}
/**
 * @internal
 */
export interface SuccessHandler {
    (httpResponse: HttpResponse | unknown, signingProperties: Record<string, unknown>): void;
}
/**
 * Interface to sign identity and signing properties.
 * @internal
 */
export interface HttpSigner {
    /**
     * Signs an HttpRequest with an identity and signing properties.
     * @param httpRequest request to sign
     * @param identity identity to sing the request with
     * @param signingProperties property bag for signing
     * @returns signed request in a promise
     */
    sign(httpRequest: HttpRequest, identity: Identity, signingProperties: Record<string, unknown>): Promise<HttpRequest>;
    /**
     * Handler that executes after the {@link HttpSigner.sign} invocation and corresponding
     * middleware throws an error.
     * The error handler is expected to throw the error it receives, so the return type of the error handler is `never`.
     * @internal
     */
    errorHandler?: ErrorHandler;
    /**
     * Handler that executes after the {@link HttpSigner.sign} invocation and corresponding
     * middleware succeeds.
     * @internal
     */
    successHandler?: SuccessHandler;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/auth/IdentityProviderConfig.d.ts

```typescript
import type { Identity, IdentityProvider } from "../identity/identity";
import type { HttpAuthSchemeId } from "./HttpAuthScheme";
/**
 * Interface to get an IdentityProvider for a specified HttpAuthScheme
 * @internal
 */
export interface IdentityProviderConfig {
    /**
     * Get the IdentityProvider for a specified HttpAuthScheme.
     * @param schemeId schemeId of the HttpAuthScheme
     * @returns IdentityProvider or undefined if HttpAuthScheme is not found
     */
    getIdentityProvider(schemeId: HttpAuthSchemeId): IdentityProvider<Identity> | undefined;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/auth/auth.d.ts

```typescript
/**
 * @internal
 *
 * Authentication schemes represent a way that the service will authenticate the customers identity.
 */
export interface AuthScheme {
    /**
     * @example "sigv4a" or "sigv4"
     */
    name: "sigv4" | "sigv4a" | string;
    /**
     * @example "s3"
     */
    signingName: string;
    /**
     * @example "us-east-1"
     */
    signingRegion: string;
    /**
     * @example ["*"]
     * @example ["us-west-2", "us-east-1"]
     */
    signingRegionSet?: string[];
    /**
     * @deprecated this field was renamed to signingRegion.
     */
    signingScope?: never;
    properties: Record<string, unknown>;
}
/**
 * @internal
 * @deprecated
 */
export interface HttpAuthDefinition {
    /**
     * Defines the location of where the Auth is serialized.
     */
    in: HttpAuthLocation;
    /**
     * Defines the name of the HTTP header or query string parameter
     * that contains the Auth.
     */
    name: string;
    /**
     * Defines the security scheme to use on the `Authorization` header value.
     * This can only be set if the "in" property is set to {@link HttpAuthLocation.HEADER}.
     */
    scheme?: string;
}
/**
 * @internal
 * @deprecated
 */
export declare enum HttpAuthLocation {
    HEADER = "header",
    QUERY = "query"
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/auth/index.d.ts

```typescript
export * from "./auth";
export * from "./HttpApiKeyAuth";
export * from "./HttpAuthScheme";
export * from "./HttpAuthSchemeProvider";
export * from "./HttpSigner";
export * from "./IdentityProviderConfig";

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/blob/blob-payload-input-types.d.ts

```typescript
import type { Readable } from "stream";
import type { BlobOptionalType, ReadableStreamOptionalType } from "../externals-check/browser-externals-check";
/**
 * @public
 *
 * A union of types that can be used as inputs for the service model
 * "blob" type when it represents the request's entire payload or body.
 *
 * For example, in Lambda::invoke, the payload is modeled as a blob type
 * and this union applies to it.
 * In contrast, in Lambda::createFunction the Zip file option is a blob type,
 * but is not the (entire) payload and this union does not apply.
 *
 * Note: not all types are signable by the standard SignatureV4 signer when
 * used as the request body. For example, in Node.js a Readable stream
 * is not signable by the default signer.
 * They are included in the union because it may work in some cases,
 * but the expected types are primarily string and Uint8Array.
 *
 * Additional details may be found in the internal
 * function "getPayloadHash" in the SignatureV4 module.
 */
export type BlobPayloadInputTypes = string | ArrayBuffer | ArrayBufferView | Uint8Array | NodeJsRuntimeBlobTypes | BrowserRuntimeBlobTypes;
/**
 * @public
 *
 * Additional blob types for the Node.js environment.
 */
export type NodeJsRuntimeBlobTypes = Readable | Buffer;
/**
 * @public
 *
 * Additional blob types for the browser environment.
 */
export type BrowserRuntimeBlobTypes = BlobOptionalType | ReadableStreamOptionalType;
/**
 * @internal
 * @deprecated renamed to BlobPayloadInputTypes.
 */
export type BlobTypes = BlobPayloadInputTypes;

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/checksum.d.ts

```typescript
import type { SourceData } from "./crypto";
/**
 * @public
 *
 * An object that provides a checksum of data provided in chunks to `update`.
 * The checksum may be performed incrementally as chunks are received or all
 * at once when the checksum is finalized, depending on the underlying
 * implementation.
 *
 * It's recommended to compute checksum incrementally to avoid reading the
 * entire payload in memory.
 *
 * A class that implements this interface may accept an optional secret key in its
 * constructor while computing checksum value, when using HMAC. If provided,
 * this secret key would be used when computing checksum.
 */
export interface Checksum {
    /**
     * Constant length of the digest created by the algorithm in bytes.
     */
    digestLength?: number;
    /**
     * Creates a new checksum object that contains a deep copy of the internal
     * state of the current `Checksum` object.
     */
    copy?(): Checksum;
    /**
     * Returns the digest of all of the data passed.
     */
    digest(): Promise<Uint8Array>;
    /**
     * Allows marking a checksum for checksums that support the ability
     * to mark and reset.
     *
     * @param readLimit - The maximum limit of bytes that can be read
     *   before the mark position becomes invalid.
     */
    mark?(readLimit: number): void;
    /**
     * Resets the checksum to its initial value.
     */
    reset(): void;
    /**
     * Adds a chunk of data for which checksum needs to be computed.
     * This can be called many times with new data as it is streamed.
     *
     * Implementations may override this method which passes second param
     * which makes Checksum object stateless.
     *
     * @param chunk - The buffer to update checksum with.
     */
    update(chunk: Uint8Array): void;
}
/**
 * @public
 *
 * A constructor for a Checksum that may be used to calculate an HMAC. Implementing
 * classes should not directly hold the provided key in memory beyond the
 * lexical scope of the constructor.
 */
export interface ChecksumConstructor {
    new (secret?: SourceData): Checksum;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/client.d.ts

```typescript
import type { Command } from "./command";
import type { MiddlewareStack } from "./middleware";
import type { MetadataBearer } from "./response";
import type { OptionalParameter } from "./util";
/**
 * @public
 *
 * A type which checks if the client configuration is optional.
 * If all entries of the client configuration are optional, it allows client creation without passing any config.
 */
export type CheckOptionalClientConfig<T> = OptionalParameter<T>;
/**
 * @public
 *
 * function definition for different overrides of client's 'send' function.
 */
export interface InvokeFunction<InputTypes extends object, OutputTypes extends MetadataBearer, ResolvedClientConfiguration> {
    <InputType extends InputTypes, OutputType extends OutputTypes>(command: Command<InputTypes, InputType, OutputTypes, OutputType, ResolvedClientConfiguration>, options?: any): Promise<OutputType>;
    <InputType extends InputTypes, OutputType extends OutputTypes>(command: Command<InputTypes, InputType, OutputTypes, OutputType, ResolvedClientConfiguration>, cb: (err: any, data?: OutputType) => void): void;
    <InputType extends InputTypes, OutputType extends OutputTypes>(command: Command<InputTypes, InputType, OutputTypes, OutputType, ResolvedClientConfiguration>, options: any, cb: (err: any, data?: OutputType) => void): void;
    <InputType extends InputTypes, OutputType extends OutputTypes>(command: Command<InputTypes, InputType, OutputTypes, OutputType, ResolvedClientConfiguration>, options?: any, cb?: (err: any, data?: OutputType) => void): Promise<OutputType> | void;
}
/**
 * @public
 *
 * Signature that appears on aggregated clients' methods.
 */
export interface InvokeMethod<InputType extends object, OutputType extends MetadataBearer> {
    (input: InputType, options?: any): Promise<OutputType>;
    (input: InputType, cb: (err: any, data?: OutputType) => void): void;
    (input: InputType, options: any, cb: (err: any, data?: OutputType) => void): void;
    (input: InputType, options?: any, cb?: (err: any, data?: OutputType) => void): Promise<OutputType> | void;
}
/**
 * @public
 *
 * Signature that appears on aggregated clients' methods when argument is optional.
 */
export interface InvokeMethodOptionalArgs<InputType extends object, OutputType extends MetadataBearer> {
    (): Promise<OutputType>;
    (input: InputType, options?: any): Promise<OutputType>;
    (input: InputType, cb: (err: any, data?: OutputType) => void): void;
    (input: InputType, options: any, cb: (err: any, data?: OutputType) => void): void;
    (input: InputType, options?: any, cb?: (err: any, data?: OutputType) => void): Promise<OutputType> | void;
}
/**
 * A general interface for service clients, idempotent to browser or node clients
 * This type corresponds to SmithyClient(https://github.com/aws/aws-sdk-js-v3/blob/main/packages/smithy-client/src/client.ts).
 * It's provided for using without importing the SmithyClient class.
 * @internal
 */
export interface Client<Input extends object, Output extends MetadataBearer, ResolvedClientConfiguration> {
    readonly config: ResolvedClientConfiguration;
    middlewareStack: MiddlewareStack<Input, Output>;
    send: InvokeFunction<Input, Output, ResolvedClientConfiguration>;
    destroy: () => void;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/command.d.ts

```typescript
import type { Handler, MiddlewareStack } from "./middleware";
import type { MetadataBearer } from "./response";
/**
 * @public
 */
export interface Command<ClientInput extends object, InputType extends ClientInput, ClientOutput extends MetadataBearer, OutputType extends ClientOutput, ResolvedConfiguration> extends CommandIO<InputType, OutputType> {
    readonly input: InputType;
    readonly middlewareStack: MiddlewareStack<InputType, OutputType>;
    /**
     * This should be OperationSchema from @smithy/types, but would
     * create problems with the client transform type adaptors.
     */
    readonly schema?: any;
    resolveMiddleware(stack: MiddlewareStack<ClientInput, ClientOutput>, configuration: ResolvedConfiguration, options: any): Handler<InputType, OutputType>;
}
/**
 * @internal
 *
 * This is a subset of the Command type used only to detect the i/o types.
 */
export interface CommandIO<InputType extends object, OutputType extends MetadataBearer> {
    readonly input: InputType;
    resolveMiddleware(stack: any, configuration: any, options: any): Handler<InputType, OutputType>;
}
/**
 * @internal
 */
export type GetOutputType<Command> = Command extends CommandIO<any, infer O> ? O : never;

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/connection/config.d.ts

```typescript
/**
 * @public
 */
export interface ConnectConfiguration {
    /**
     * The maximum time in milliseconds that the connection phase of a request
     * may take before the connection attempt is abandoned.
     */
    requestTimeout?: number;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/connection/index.d.ts

```typescript
export * from "./config";
export * from "./manager";
export * from "./pool";

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/connection/manager.d.ts

```typescript
import type { RequestContext } from "../transfer";
import type { ConnectConfiguration } from "./config";
/**
 * @public
 */
export interface ConnectionManagerConfiguration {
    /**
     * Maximum number of allowed concurrent requests per connection.
     */
    maxConcurrency?: number;
    /**
     * Disables concurrent requests per connection.
     */
    disableConcurrency?: boolean;
}
/**
 * @public
 */
export interface ConnectionManager<T> {
    /**
     * Retrieves a connection from the connection pool if available,
     * otherwise establish a new connection
     */
    lease(requestContext: RequestContext, connectionConfiguration: ConnectConfiguration): T;
    /**
     * Releases the connection back to the pool making it potentially
     * re-usable by other requests.
     */
    release(requestContext: RequestContext, connection: T): void;
    /**
     * Destroys the connection manager. All connections will be closed.
     */
    destroy(): void;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/connection/pool.d.ts

```typescript
/**
 * @public
 */
export interface ConnectionPool<T> {
    /**
     * Retrieve the first connection in the pool
     */
    poll(): T | void;
    /**
     * Release the connection back to the pool making it potentially
     * re-usable by other requests.
     */
    offerLast(connection: T): void;
    /**
     * Removes the connection from the pool, and destroys it.
     */
    destroy(connection: T): void;
    /**
     * Implements the iterable protocol and allows arrays to be consumed
     * by most syntaxes expecting iterables, such as the spread syntax
     * and for...of loops
     */
    [Symbol.iterator](): Iterator<T>;
}
/**
 * Unused.
 * @internal
 * @deprecated
 */
export interface CacheKey {
    destination: string;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/crypto.d.ts

```typescript
/**
 * @public
 */
export type SourceData = string | ArrayBuffer | ArrayBufferView;
/**
 * @public
 *
 * An object that provides a hash of data provided in chunks to `update`. The
 * hash may be performed incrementally as chunks are received or all at once
 * when the hash is finalized, depending on the underlying implementation.
 *
 * @deprecated use {@link Checksum}
 */
export interface Hash {
    /**
     * Adds a chunk of data to the hash. If a buffer is provided, the `encoding`
     * argument will be ignored. If a string is provided without a specified
     * encoding, implementations must assume UTF-8 encoding.
     *
     * Not all encodings are supported on all platforms, though all must support
     * UTF-8.
     */
    update(toHash: SourceData, encoding?: "utf8" | "ascii" | "latin1"): void;
    /**
     * Finalizes the hash and provides a promise that will be fulfilled with the
     * raw bytes of the calculated hash.
     */
    digest(): Promise<Uint8Array>;
}
/**
 * @public
 *
 * A constructor for a hash that may be used to calculate an HMAC. Implementing
 * classes should not directly hold the provided key in memory beyond the
 * lexical scope of the constructor.
 *
 * @deprecated use {@link ChecksumConstructor}
 */
export interface HashConstructor {
    new (secret?: SourceData): Hash;
}
/**
 * @public
 *
 * A function that calculates the hash of a data stream. Determining the hash
 * will consume the stream, so only replayable streams should be provided to an
 * implementation of this interface.
 */
export interface StreamHasher<StreamType = any> {
    (hashCtor: HashConstructor, stream: StreamType): Promise<Uint8Array>;
}
/**
 * @public
 *
 * A function that returns a promise fulfilled with bytes from a
 * cryptographically secure pseudorandom number generator.
 */
export interface randomValues {
    (byteLength: number): Promise<Uint8Array>;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/downlevel-ts3.4/transform/type-transform.d.ts

```typescript
/**
 * @public
 *
 * Transforms any members of the object T having type FromType
 * to ToType. This applies only to exact type matches.
 *
 * This is for the case where FromType is a union and only those fields
 * matching the same union should be transformed.
 */
export type Transform<T, FromType, ToType> = RecursiveTransformExact<T, FromType, ToType>;
/**
 * @internal
 *
 * Returns ToType if T matches exactly with FromType.
 */
type TransformExact<T, FromType, ToType> = [T] extends [FromType] ? ([FromType] extends [T] ? ToType : T) : T;
/**
 * @internal
 *
 * Applies TransformExact to members of an object recursively.
 */
type RecursiveTransformExact<T, FromType, ToType> = T extends Function ? T : T extends object ? {
    [key in keyof T]: [T[key]] extends [FromType] ? [FromType] extends [T[key]] ? ToType : RecursiveTransformExact<T[key], FromType, ToType> : RecursiveTransformExact<T[key], FromType, ToType>;
} : TransformExact<T, FromType, ToType>;
export {};

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/encode.d.ts

```typescript
import type { Message } from "./eventStream";
/**
 * @public
 */
export interface MessageEncoder {
    encode(message: Message): Uint8Array;
}
/**
 * @public
 */
export interface MessageDecoder {
    decode(message: ArrayBufferView): Message;
    feed(message: ArrayBufferView): void;
    endOfStream(): void;
    getMessage(): AvailableMessage;
    getAvailableMessages(): AvailableMessages;
}
/**
 * @public
 */
export interface AvailableMessage {
    getMessage(): Message | undefined;
    isEndOfStream(): boolean;
}
/**
 * @public
 */
export interface AvailableMessages {
    getMessages(): Message[];
    isEndOfStream(): boolean;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/endpoint.d.ts

```typescript
import type { AuthScheme } from "./auth/auth";
/**
 * @public
 */
export interface EndpointPartition {
    name: string;
    dnsSuffix: string;
    dualStackDnsSuffix: string;
    supportsFIPS: boolean;
    supportsDualStack: boolean;
}
/**
 * @public
 */
export interface EndpointARN {
    partition: string;
    service: string;
    region: string;
    accountId: string;
    resourceId: Array<string>;
}
/**
 * @public
 */
export declare enum EndpointURLScheme {
    HTTP = "http",
    HTTPS = "https"
}
/**
 * @public
 */
export interface EndpointURL {
    /**
     * The URL scheme such as http or https.
     */
    scheme: EndpointURLScheme;
    /**
     * The authority is the host and optional port component of the URL.
     */
    authority: string;
    /**
     * The parsed path segment of the URL.
     * This value is as-is as provided by the user.
     */
    path: string;
    /**
     * The parsed path segment of the URL.
     * This value is guranteed to start and end with a "/".
     */
    normalizedPath: string;
    /**
     * A boolean indicating whether the authority is an IP address.
     */
    isIp: boolean;
}
/**
 * @public
 */
export type EndpointObjectProperty = string | boolean | {
    [key: string]: EndpointObjectProperty;
} | EndpointObjectProperty[];
/**
 * @public
 */
export interface EndpointV2 {
    url: URL;
    properties?: {
        authSchemes?: AuthScheme[];
    } & Record<string, EndpointObjectProperty>;
    headers?: Record<string, string[]>;
}
/**
 * @public
 */
export type EndpointParameters = {
    [name: string]: undefined | boolean | string | string[];
};

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/endpoints/EndpointRuleObject.d.ts

```typescript
import type { EndpointObjectProperty } from "../endpoint";
import type { ConditionObject, Expression } from "./shared";
/**
 * @public
 */
export type EndpointObjectProperties = Record<string, EndpointObjectProperty>;
/**
 * @public
 */
export type EndpointObjectHeaders = Record<string, Expression[]>;
/**
 * @public
 */
export type EndpointObject = {
    url: Expression;
    properties?: EndpointObjectProperties;
    headers?: EndpointObjectHeaders;
};
/**
 * @public
 */
export type EndpointRuleObject = {
    type: "endpoint";
    conditions?: ConditionObject[];
    endpoint: EndpointObject;
    documentation?: string;
};

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/endpoints/ErrorRuleObject.d.ts

```typescript
import type { ConditionObject, Expression } from "./shared";
/**
 * @public
 */
export type ErrorRuleObject = {
    type: "error";
    conditions?: ConditionObject[];
    error: Expression;
    documentation?: string;
};

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/endpoints/RuleSetObject.d.ts

```typescript
import type { RuleSetRules } from "./TreeRuleObject";
/**
 * @public
 */
export type DeprecatedObject = {
    message?: string;
    since?: string;
};
/**
 * @public
 */
export type ParameterObject = {
    type: "String" | "string" | "Boolean" | "boolean";
    default?: string | boolean;
    required?: boolean;
    documentation?: string;
    builtIn?: string;
    deprecated?: DeprecatedObject;
};
/**
 * @public
 */
export type RuleSetObject = {
    version: string;
    serviceId?: string;
    parameters: Record<string, ParameterObject>;
    rules: RuleSetRules;
};

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/endpoints/TreeRuleObject.d.ts

```typescript
import type { EndpointRuleObject } from "./EndpointRuleObject";
import type { ErrorRuleObject } from "./ErrorRuleObject";
import type { ConditionObject } from "./shared";
/**
 * @public
 */
export type RuleSetRules = Array<EndpointRuleObject | ErrorRuleObject | TreeRuleObject>;
/**
 * @public
 */
export type TreeRuleObject = {
    type: "tree";
    conditions?: ConditionObject[];
    rules: RuleSetRules;
    documentation?: string;
};

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/endpoints/index.d.ts

```typescript
export * from "./EndpointRuleObject";
export * from "./ErrorRuleObject";
export * from "./RuleSetObject";
export * from "./shared";
export * from "./TreeRuleObject";

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/endpoints/shared.d.ts

```typescript
import type { Logger } from "../logger";
/**
 * @public
 */
export type ReferenceObject = {
    ref: string;
};
/**
 * @public
 */
export type FunctionObject = {
    fn: string;
    argv: FunctionArgv;
};
/**
 * @public
 */
export type FunctionArgv = Array<Expression | boolean | number>;
/**
 * @public
 */
export type FunctionReturn = string | boolean | number | {
    [key: string]: FunctionReturn;
};
/**
 * @public
 */
export type ConditionObject = FunctionObject & {
    assign?: string;
};
/**
 * @public
 */
export type Expression = string | ReferenceObject | FunctionObject;
/**
 * @public
 */
export type EndpointParams = Record<string, string | boolean>;
/**
 * @public
 */
export type EndpointResolverOptions = {
    endpointParams: EndpointParams;
    logger?: Logger;
};
/**
 * @public
 */
export type ReferenceRecord = Record<string, FunctionReturn>;
/**
 * @public
 */
export type EvaluateOptions = EndpointResolverOptions & {
    referenceRecord: ReferenceRecord;
};

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/eventStream.d.ts

```typescript
import type { HttpRequest } from "./http";
import type { FinalizeHandler, FinalizeHandlerArguments, FinalizeHandlerOutput, HandlerExecutionContext } from "./middleware";
import type { MetadataBearer } from "./response";
/**
 * @public
 *
 * An event stream message. The headers and body properties will always be
 * defined, with empty headers represented as an object with no keys and an
 * empty body represented as a zero-length Uint8Array.
 */
export interface Message {
    headers: MessageHeaders;
    body: Uint8Array;
}
/**
 * @public
 */
export type MessageHeaders = Record<string, MessageHeaderValue>;
/**
 * @public
 */
export type HeaderValue<K extends string, V> = {
    type: K;
    value: V;
};
/**
 * @public
 */
export type BooleanHeaderValue = HeaderValue<"boolean", boolean>;
/**
 * @public
 */
export type ByteHeaderValue = HeaderValue<"byte", number>;
/**
 * @public
 */
export type ShortHeaderValue = HeaderValue<"short", number>;
/**
 * @public
 */
export type IntegerHeaderValue = HeaderValue<"integer", number>;
/**
 * @public
 */
export type LongHeaderValue = HeaderValue<"long", Int64>;
/**
 * @public
 */
export type BinaryHeaderValue = HeaderValue<"binary", Uint8Array>;
/**
 * @public
 */
export type StringHeaderValue = HeaderValue<"string", string>;
/**
 * @public
 */
export type TimestampHeaderValue = HeaderValue<"timestamp", Date>;
/**
 * @public
 */
export type UuidHeaderValue = HeaderValue<"uuid", string>;
/**
 * @public
 */
export type MessageHeaderValue = BooleanHeaderValue | ByteHeaderValue | ShortHeaderValue | IntegerHeaderValue | LongHeaderValue | BinaryHeaderValue | StringHeaderValue | TimestampHeaderValue | UuidHeaderValue;
/**
 * @public
 */
export interface Int64 {
    readonly bytes: Uint8Array;
    valueOf: () => number;
    toString: () => string;
}
/**
 * @public
 *
 * Util functions for serializing or deserializing event stream
 */
export interface EventStreamSerdeContext {
    eventStreamMarshaller: EventStreamMarshaller;
}
/**
 * @public
 *
 * A function which deserializes binary event stream message into modeled shape.
 */
export interface EventStreamMarshallerDeserFn<StreamType> {
    <T>(body: StreamType, deserializer: (input: Record<string, Message>) => Promise<T>): AsyncIterable<T>;
}
/**
 * @public
 *
 * A function that serializes modeled shape into binary stream message.
 */
export interface EventStreamMarshallerSerFn<StreamType> {
    <T>(input: AsyncIterable<T>, serializer: (event: T) => Message): StreamType;
}
/**
 * @public
 *
 * An interface which provides functions for serializing and deserializing binary event stream
 * to/from corresponsing modeled shape.
 */
export interface EventStreamMarshaller<StreamType = any> {
    deserialize: EventStreamMarshallerDeserFn<StreamType>;
    serialize: EventStreamMarshallerSerFn<StreamType>;
}
/**
 * @public
 */
export interface EventStreamRequestSigner {
    sign(request: HttpRequest): Promise<HttpRequest>;
}
/**
 * @public
 */
export interface EventStreamPayloadHandler {
    handle: <Input extends object, Output extends MetadataBearer>(next: FinalizeHandler<Input, Output>, args: FinalizeHandlerArguments<Input>, context?: HandlerExecutionContext) => Promise<FinalizeHandlerOutput<Output>>;
}
/**
 * @public
 */
export interface EventStreamPayloadHandlerProvider {
    (options: any): EventStreamPayloadHandler;
}
/**
 * @public
 */
export interface EventStreamSerdeProvider {
    (options: any): EventStreamMarshaller;
}
/**
 * @public
 */
export interface EventStreamSignerProvider {
    (options: any): EventStreamRequestSigner;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/extensions/checksum.d.ts

```typescript
import type { ChecksumConstructor } from "../checksum";
import type { HashConstructor } from "../crypto";
/**
 * @internal
 */
export declare enum AlgorithmId {
    MD5 = "md5",
    CRC32 = "crc32",
    CRC32C = "crc32c",
    SHA1 = "sha1",
    SHA256 = "sha256"
}
/**
 * @internal
 */
export interface ChecksumAlgorithm {
    algorithmId(): AlgorithmId;
    checksumConstructor(): ChecksumConstructor | HashConstructor;
}
/**
 * @deprecated unused.
 * @internal
 */
type ChecksumConfigurationLegacy = {
    [other in string | number]: any;
};
/**
 * @internal
 */
export interface ChecksumConfiguration extends ChecksumConfigurationLegacy {
    addChecksumAlgorithm(algo: ChecksumAlgorithm): void;
    checksumAlgorithms(): ChecksumAlgorithm[];
}
/**
 * @deprecated will be removed for implicit type.
 * @internal
 */
type GetChecksumConfigurationType = (runtimeConfig: Partial<{
    sha256: ChecksumConstructor | HashConstructor;
    md5: ChecksumConstructor | HashConstructor;
}>) => ChecksumConfiguration;
/**
 * @internal
 * @deprecated will be moved to smithy-client.
 */
export declare const getChecksumConfiguration: GetChecksumConfigurationType;
/**
 * @internal
 * @deprecated will be removed for implicit type.
 */
type ResolveChecksumRuntimeConfigType = (clientConfig: ChecksumConfiguration) => any;
/**
 * @internal
 *
 * @deprecated will be moved to smithy-client.
 */
export declare const resolveChecksumRuntimeConfig: ResolveChecksumRuntimeConfigType;
export {};

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/extensions/defaultClientConfiguration.d.ts

```typescript
import type { ChecksumConfiguration } from "./checksum";
/**
 * @deprecated will be replaced by DefaultExtensionConfiguration.
 * @internal
 *
 * Default client configuration consisting various configurations for modifying a service client
 */
export interface DefaultClientConfiguration extends ChecksumConfiguration {
}
/**
 * @deprecated will be removed for implicit type.
 */
type GetDefaultConfigurationType = (runtimeConfig: any) => DefaultClientConfiguration;
/**
 * @deprecated moving to @smithy/smithy-client.
 * @internal
 *
 * Helper function to resolve default client configuration from runtime config
 *
 */
export declare const getDefaultClientConfiguration: GetDefaultConfigurationType;
/**
 * @deprecated will be removed for implicit type.
 */
type ResolveDefaultRuntimeConfigType = (clientConfig: DefaultClientConfiguration) => any;
/**
 * @deprecated moving to @smithy/smithy-client.
 * @internal
 *
 * Helper function to resolve runtime config from default client configuration
 */
export declare const resolveDefaultRuntimeConfig: ResolveDefaultRuntimeConfigType;
export {};

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/extensions/defaultExtensionConfiguration.d.ts

```typescript
import type { ChecksumConfiguration } from "./checksum";
import type { RetryStrategyConfiguration } from "./retry";
/**
 * @internal
 *
 * Default extension configuration consisting various configurations for modifying a service client
 */
export interface DefaultExtensionConfiguration extends ChecksumConfiguration, RetryStrategyConfiguration {
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/extensions/index.d.ts

```typescript
export * from "./defaultClientConfiguration";
export * from "./defaultExtensionConfiguration";
export { AlgorithmId, ChecksumAlgorithm, ChecksumConfiguration } from "./checksum";
export { RetryStrategyConfiguration } from "./retry";

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/extensions/retry.d.ts

```typescript
import type { RetryStrategyV2 } from "../retry";
import type { Provider, RetryStrategy } from "../util";
/**
 * A configuration interface with methods called by runtime extension
 * @internal
 */
export interface RetryStrategyConfiguration {
    /**
     * Set retry strategy used for all http requests
     * @param retryStrategy
     */
    setRetryStrategy(retryStrategy: Provider<RetryStrategyV2 | RetryStrategy>): void;
    /**
     * Get retry strategy used for all http requests
     * @param retryStrategy
     */
    retryStrategy(): Provider<RetryStrategyV2 | RetryStrategy>;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/externals-check/browser-externals-check.d.ts

```typescript
import type { Exact } from "../transform/exact";
/**
 * @public
 *
 * A checked type that resolves to Blob if it is defined as more than a stub, otherwise
 * resolves to 'never' so as not to widen the type of unions containing Blob
 * excessively.
 */
export type BlobOptionalType = BlobDefined extends true ? Blob : Unavailable;
/**
 * @public
 *
 * A checked type that resolves to ReadableStream if it is defined as more than a stub, otherwise
 * resolves to 'never' so as not to widen the type of unions containing ReadableStream
 * excessively.
 */
export type ReadableStreamOptionalType = ReadableStreamDefined extends true ? ReadableStream : Unavailable;
/**
 * @public
 *
 * Indicates a type is unavailable if it resolves to this.
 */
export type Unavailable = never;
/**
 * @internal
 *
 * Whether the global types define more than a stub for ReadableStream.
 */
export type ReadableStreamDefined = Exact<ReadableStream, {}> extends true ? false : true;
/**
 * @internal
 *
 * Whether the global types define more than a stub for Blob.
 */
export type BlobDefined = Exact<Blob, {}> extends true ? false : true;

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/feature-ids.d.ts

```typescript
/**
 * @internal
 */
export type SmithyFeatures = Partial<{
    RESOURCE_MODEL: "A";
    WAITER: "B";
    PAGINATOR: "C";
    RETRY_MODE_LEGACY: "D";
    RETRY_MODE_STANDARD: "E";
    RETRY_MODE_ADAPTIVE: "F";
    GZIP_REQUEST_COMPRESSION: "L";
    PROTOCOL_RPC_V2_CBOR: "M";
    ENDPOINT_OVERRIDE: "N";
    SIGV4A_SIGNING: "S";
    CREDENTIALS_CODE: "e";
}>;

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/http/httpHandlerInitialization.d.ts

```typescript
import type { Agent as hAgent, AgentOptions as hAgentOptions } from "http";
import type { Agent as hsAgent, AgentOptions as hsAgentOptions } from "https";
import type { HttpRequest as IHttpRequest } from "../http";
import type { Logger } from "../logger";
/**
 *
 * This type represents an alternate client constructor option for the entry
 * "requestHandler". Instead of providing an instance of a requestHandler, the user
 * may provide the requestHandler's constructor options for either the
 * NodeHttpHandler or FetchHttpHandler.
 *
 * For other RequestHandlers like HTTP2 or WebSocket,
 * constructor parameter passthrough is not currently available.
 *
 * @public
 */
export type RequestHandlerParams = NodeHttpHandlerOptions | FetchHttpHandlerOptions;
/**
 * Represents the http options that can be passed to a node http client.
 * @public
 */
export interface NodeHttpHandlerOptions {
    /**
     * The maximum time in milliseconds that the connection phase of a request
     * may take before the connection attempt is abandoned.
     * Defaults to 0, which disables the timeout.
     */
    connectionTimeout?: number;
    /**
     * The maximum number of milliseconds request & response should take.
     * Defaults to 0, which disables the timeout.
     *
     * If exceeded, a warning will be emitted unless throwOnRequestTimeout=true,
     * in which case a TimeoutError will be thrown.
     */
    requestTimeout?: number;
    /**
     * Because requestTimeout was for a long time incorrectly being set as a socket idle timeout,
     * users must also opt-in for request timeout thrown errors.
     * Without this setting, a breach of the request timeout will be logged as a warning.
     */
    throwOnRequestTimeout?: boolean;
    /**
     * The maximum time in milliseconds that a socket may remain idle before it
     * is closed. Defaults to 0, which means no maximum.
     *
     * This does not affect the server, which may still close the connection due to an idle socket.
     */
    socketTimeout?: number;
    /**
     * Delay before the NodeHttpHandler checks for socket exhaustion,
     * and emits a warning if the active sockets and enqueued request count is greater than
     * 2x the maxSockets count.
     *
     * Defaults to connectionTimeout + requestTimeout or 3000ms if those are not set.
     */
    socketAcquisitionWarningTimeout?: number;
    /**
     * You can pass http.Agent or its constructor options.
     */
    httpAgent?: hAgent | hAgentOptions;
    /**
     * You can pass https.Agent or its constructor options.
     */
    httpsAgent?: hsAgent | hsAgentOptions;
    /**
     * Optional logger.
     */
    logger?: Logger;
}
/**
 * Represents the http options that can be passed to a browser http client.
 * @public
 */
export interface FetchHttpHandlerOptions {
    /**
     * The number of milliseconds a request can take before being automatically
     * terminated.
     */
    requestTimeout?: number;
    /**
     * Whether to allow the request to outlive the page. Default value is false.
     *
     * There may be limitations to the payload size, number of concurrent requests,
     * request duration etc. when using keepalive in browsers.
     *
     * These may change over time, so look for up to date information about
     * these limitations before enabling keepalive.
     */
    keepAlive?: boolean;
    /**
     * A string indicating whether credentials will be sent with the request always, never, or
     * only when sent to a same-origin URL.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials
     */
    credentials?: "include" | "omit" | "same-origin" | undefined | string;
    /**
     * Cache settings for fetch.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Request/cache
     */
    cache?: "default" | "force-cache" | "no-cache" | "no-store" | "only-if-cached" | "reload";
    /**
     * An optional function that produces additional RequestInit
     * parameters for each httpRequest.
     *
     * This is applied last via merging with Object.assign() and overwrites other values
     * set from other sources.
     *
     * @example
     * ```js
     * new Client({
     *   requestHandler: {
     *     requestInit(httpRequest) {
     *       return { cache: "no-store" };
     *     }
     *   }
     * });
     * ```
     */
    requestInit?: (httpRequest: IHttpRequest) => RequestInit;
}
declare global {
    /**
     * interface merging stub.
     */
    interface RequestInit {
    }
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/http.d.ts

```typescript
import type { AbortSignal as DeprecatedAbortSignal } from "./abort";
import type { URI } from "./uri";
/**
 * @public
 *
 * @deprecated use {@link EndpointV2} from `@smithy/types`.
 */
export interface Endpoint {
    protocol: string;
    hostname: string;
    port?: number;
    path: string;
    query?: QueryParameterBag;
}
/**
 * @public
 *
 * Interface an HTTP request class. Contains
 * addressing information in addition to standard message properties.
 */
export interface HttpRequest extends HttpMessage, URI {
    method: string;
}
/**
 * @public
 *
 * Represents an HTTP message as received in reply to a request. Contains a
 * numeric status code in addition to standard message properties.
 */
export interface HttpResponse extends HttpMessage {
    statusCode: number;
    reason?: string;
}
/**
 * @public
 *
 * Represents an HTTP message with headers and an optional static or streaming
 * body. body: ArrayBuffer | ArrayBufferView | string | Uint8Array | Readable | ReadableStream;
 */
export interface HttpMessage {
    headers: HeaderBag;
    body?: any;
}
/**
 * @public
 *
 * A mapping of query parameter names to strings or arrays of strings, with the
 * second being used when a parameter contains a list of values. Value can be set
 * to null when query is not in key-value pairs shape
 */
export type QueryParameterBag = Record<string, string | Array<string> | null>;
/**
 * @public
 */
export type FieldOptions = {
    name: string;
    kind?: FieldPosition;
    values?: string[];
};
/**
 * @public
 */
export declare enum FieldPosition {
    HEADER = 0,
    TRAILER = 1
}
/**
 * @public
 *
 * A mapping of header names to string values. Multiple values for the same
 * header should be represented as a single string with values separated by
 * `, `.
 *
 * Keys should be considered case insensitive, even if this is not enforced by a
 * particular implementation. For example, given the following HeaderBag, where
 * keys differ only in case:
 *
 * ```json
 *    {
 *        'x-request-date': '2000-01-01T00:00:00Z',
 *        'X-Request-Date': '2001-01-01T00:00:00Z'
 *    }
 * ```
 *
 * The SDK may at any point during processing remove one of the object
 * properties in favor of the other. The headers may or may not be combined, and
 * the SDK will not deterministically select which header candidate to use.
 */
export type HeaderBag = Record<string, string>;
/**
 * @public
 *
 * Represents an HTTP message with headers and an optional static or streaming
 * body. bode: ArrayBuffer | ArrayBufferView | string | Uint8Array | Readable | ReadableStream;
 */
export interface HttpMessage {
    headers: HeaderBag;
    body?: any;
}
/**
 * @public
 *
 * Represents the options that may be passed to an Http Handler.
 */
export interface HttpHandlerOptions {
    abortSignal?: AbortSignal | DeprecatedAbortSignal;
    /**
     * The maximum time in milliseconds that the connection phase of a request
     * may take before the connection attempt is abandoned.
     */
    requestTimeout?: number;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/identity/apiKeyIdentity.d.ts

```typescript
import type { Identity, IdentityProvider } from "../identity/identity";
/**
 * @public
 */
export interface ApiKeyIdentity extends Identity {
    /**
     * The literal API Key
     */
    readonly apiKey: string;
}
/**
 * @public
 */
export type ApiKeyIdentityProvider = IdentityProvider<ApiKeyIdentity>;

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/identity/awsCredentialIdentity.d.ts

```typescript
import type { Identity, IdentityProvider } from "./identity";
/**
 * @public
 */
export interface AwsCredentialIdentity extends Identity {
    /**
     * AWS access key ID
     */
    readonly accessKeyId: string;
    /**
     * AWS secret access key
     */
    readonly secretAccessKey: string;
    /**
     * A security or session token to use with these credentials. Usually
     * present for temporary credentials.
     */
    readonly sessionToken?: string;
    /**
     * AWS credential scope for this set of credentials.
     */
    readonly credentialScope?: string;
    /**
     * AWS accountId.
     */
    readonly accountId?: string;
}
/**
 * @public
 */
export type AwsCredentialIdentityProvider = IdentityProvider<AwsCredentialIdentity>;

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/identity/identity.d.ts

```typescript
/**
 * @public
 */
export interface Identity {
    /**
     * A `Date` when the identity or credential will no longer be accepted.
     */
    readonly expiration?: Date;
}
/**
 * @public
 */
export interface IdentityProvider<IdentityT extends Identity> {
    (identityProperties?: Record<string, any>): Promise<IdentityT>;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/identity/index.d.ts

```typescript
export * from "./apiKeyIdentity";
export * from "./awsCredentialIdentity";
export * from "./identity";
export * from "./tokenIdentity";

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/identity/tokenIdentity.d.ts

```typescript
import type { Identity, IdentityProvider } from "../identity/identity";
/**
 * @internal
 */
export interface TokenIdentity extends Identity {
    /**
     * The literal token string
     */
    readonly token: string;
}
/**
 * @internal
 */
export type TokenIdentityProvider = IdentityProvider<TokenIdentity>;

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/index.d.ts

```typescript
export * from "./abort";
export * from "./auth";
export * from "./blob/blob-payload-input-types";
export * from "./checksum";
export * from "./client";
export * from "./command";
export * from "./connection";
export * from "./crypto";
export * from "./encode";
export * from "./endpoint";
export * from "./endpoints";
export * from "./eventStream";
export * from "./extensions";
export * from "./feature-ids";
export * from "./http";
export * from "./http/httpHandlerInitialization";
export * from "./identity";
export * from "./logger";
export * from "./middleware";
export * from "./pagination";
export * from "./profile";
export * from "./response";
export * from "./retry";
export * from "./schema/schema";
export * from "./schema/schema-deprecated";
export * from "./schema/sentinels";
export * from "./schema/static-schemas";
export * from "./serde";
export * from "./shapes";
export * from "./signature";
export * from "./stream";
export * from "./streaming-payload/streaming-blob-common-types";
export * from "./streaming-payload/streaming-blob-payload-input-types";
export * from "./streaming-payload/streaming-blob-payload-output-types";
export * from "./transfer";
export * from "./transform/client-payload-blob-type-narrow";
export * from "./transform/mutable";
export * from "./transform/no-undefined";
export * from "./transform/type-transform";
export * from "./uri";
export * from "./util";
export * from "./waiter";

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/logger.d.ts

```typescript
/**
 * @public
 *
 * Represents a logger object that is available in HandlerExecutionContext
 * throughout the middleware stack.
 */
export interface Logger {
    trace?: (...content: any[]) => void;
    debug: (...content: any[]) => void;
    info: (...content: any[]) => void;
    warn: (...content: any[]) => void;
    error: (...content: any[]) => void;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/middleware.d.ts

```typescript
import type { AuthScheme, HttpAuthDefinition } from "./auth/auth";
import type { SelectedHttpAuthScheme } from "./auth/HttpAuthScheme";
import type { Command } from "./command";
import type { EndpointV2 } from "./endpoint";
import type { SmithyFeatures } from "./feature-ids";
import type { Logger } from "./logger";
import type { UserAgent } from "./util";
/**
 * @public
 */
export interface InitializeHandlerArguments<Input extends object> {
    /**
     * User input to a command. Reflects the userland representation of the
     * union of data types the command can effectively handle.
     */
    input: Input;
}
/**
 * @public
 */
export interface InitializeHandlerOutput<Output extends object> extends DeserializeHandlerOutput<Output> {
    output: Output;
}
/**
 * @public
 */
export interface SerializeHandlerArguments<Input extends object> extends InitializeHandlerArguments<Input> {
    /**
     * The user input serialized as a request object. The request object is unknown,
     * so you cannot modify it directly. When work with request, you need to guard its
     * type to e.g. HttpRequest with 'instanceof' operand
     *
     * During the build phase of the execution of a middleware stack, a built
     * request may or may not be available.
     */
    request?: unknown;
}
/**
 * @public
 */
export interface SerializeHandlerOutput<Output extends object> extends InitializeHandlerOutput<Output> {
}
/**
 * @public
 */
export interface BuildHandlerArguments<Input extends object> extends FinalizeHandlerArguments<Input> {
}
/**
 * @public
 */
export interface BuildHandlerOutput<Output extends object> extends InitializeHandlerOutput<Output> {
}
/**
 * @public
 */
export interface FinalizeHandlerArguments<Input extends object> extends SerializeHandlerArguments<Input> {
    /**
     * The user input serialized as a request.
     */
    request: unknown;
}
/**
 * @public
 */
export interface FinalizeHandlerOutput<Output extends object> extends InitializeHandlerOutput<Output> {
}
/**
 * @public
 */
export interface DeserializeHandlerArguments<Input extends object> extends FinalizeHandlerArguments<Input> {
}
/**
 * @public
 */
export interface DeserializeHandlerOutput<Output extends object> {
    /**
     * The raw response object from runtime is deserialized to structured output object.
     * The response object is unknown so you cannot modify it directly. When work with
     * response, you need to guard its type to e.g. HttpResponse with 'instanceof' operand.
     *
     * During the deserialize phase of the execution of a middleware stack, a deserialized
     * response may or may not be available
     */
    response: unknown;
    output?: Output;
}
/**
 * @public
 */
export interface InitializeHandler<Input extends object, Output extends object> {
    /**
     * Asynchronously converts an input object into an output object.
     *
     * @param args - An object containing a input to the command as well as any
     *              associated or previously generated execution artifacts.
     */
    (args: InitializeHandlerArguments<Input>): Promise<InitializeHandlerOutput<Output>>;
}
/**
 * @public
 */
export type Handler<Input extends object, Output extends object> = InitializeHandler<Input, Output>;
/**
 * @public
 */
export interface SerializeHandler<Input extends object, Output extends object> {
    /**
     * Asynchronously converts an input object into an output object.
     *
     * @param args - An object containing a input to the command as well as any
     *              associated or previously generated execution artifacts.
     */
    (args: SerializeHandlerArguments<Input>): Promise<SerializeHandlerOutput<Output>>;
}
/**
 * @public
 */
export interface FinalizeHandler<Input extends object, Output extends object> {
    /**
     * Asynchronously converts an input object into an output object.
     *
     * @param args - An object containing a input to the command as well as any
     *              associated or previously generated execution artifacts.
     */
    (args: FinalizeHandlerArguments<Input>): Promise<FinalizeHandlerOutput<Output>>;
}
/**
 * @public
 */
export interface BuildHandler<Input extends object, Output extends object> {
    (args: BuildHandlerArguments<Input>): Promise<BuildHandlerOutput<Output>>;
}
/**
 * @public
 */
export interface DeserializeHandler<Input extends object, Output extends object> {
    (args: DeserializeHandlerArguments<Input>): Promise<DeserializeHandlerOutput<Output>>;
}
/**
 * @public
 *
 * A factory function that creates functions implementing the `Handler`
 * interface.
 */
export interface InitializeMiddleware<Input extends object, Output extends object> {
    /**
     * @param next - The handler to invoke after this middleware has operated on
     * the user input and before this middleware operates on the output.
     *
     * @param context - Invariant data and functions for use by the handler.
     */
    (next: InitializeHandler<Input, Output>, context: HandlerExecutionContext): InitializeHandler<Input, Output>;
}
/**
 * @public
 *
 * A factory function that creates functions implementing the `BuildHandler`
 * interface.
 */
export interface SerializeMiddleware<Input extends object, Output extends object> {
    /**
     * @param next - The handler to invoke after this middleware has operated on
     * the user input and before this middleware operates on the output.
     *
     * @param context - Invariant data and functions for use by the handler.
     */
    (next: SerializeHandler<Input, Output>, context: HandlerExecutionContext): SerializeHandler<Input, Output>;
}
/**
 * @public
 *
 * A factory function that creates functions implementing the `FinalizeHandler`
 * interface.
 */
export interface FinalizeRequestMiddleware<Input extends object, Output extends object> {
    /**
     * @param next - The handler to invoke after this middleware has operated on
     * the user input and before this middleware operates on the output.
     *
     * @param context - Invariant data and functions for use by the handler.
     */
    (next: FinalizeHandler<Input, Output>, context: HandlerExecutionContext): FinalizeHandler<Input, Output>;
}
/**
 * @public
 */
export interface BuildMiddleware<Input extends object, Output extends object> {
    (next: BuildHandler<Input, Output>, context: HandlerExecutionContext): BuildHandler<Input, Output>;
}
/**
 * @public
 */
export interface DeserializeMiddleware<Input extends object, Output extends object> {
    (next: DeserializeHandler<Input, Output>, context: HandlerExecutionContext): DeserializeHandler<Input, Output>;
}
/**
 * @public
 */
export type MiddlewareType<Input extends object, Output extends object> = InitializeMiddleware<Input, Output> | SerializeMiddleware<Input, Output> | BuildMiddleware<Input, Output> | FinalizeRequestMiddleware<Input, Output> | DeserializeMiddleware<Input, Output>;
/**
 * @public
 *
 * A factory function that creates the terminal handler atop which a middleware
 * stack sits.
 */
export interface Terminalware {
    <Input extends object, Output extends object>(context: HandlerExecutionContext): DeserializeHandler<Input, Output>;
}
/**
 * @public
 */
export type Step = "initialize" | "serialize" | "build" | "finalizeRequest" | "deserialize";
/**
 * @public
 */
export type Priority = "high" | "normal" | "low";
/**
 * @public
 */
export interface HandlerOptions {
    /**
     * Handlers are ordered using a "step" that describes the stage of command
     * execution at which the handler will be executed. The available steps are:
     *
     * - initialize: The input is being prepared. Examples of typical
     *      initialization tasks include injecting default options computing
     *      derived parameters.
     * - serialize: The input is complete and ready to be serialized. Examples
     *      of typical serialization tasks include input validation and building
     *      an HTTP request from user input.
     * - build: The input has been serialized into an HTTP request, but that
     *      request may require further modification. Any request alterations
     *      will be applied to all retries. Examples of typical build tasks
     *      include injecting HTTP headers that describe a stable aspect of the
     *      request, such as `Content-Length` or a body checksum.
     * - finalizeRequest: The request is being prepared to be sent over the wire. The
     *      request in this stage should already be semantically complete and
     *      should therefore only be altered as match the recipient's
     *      expectations. Examples of typical finalization tasks include request
     *      signing and injecting hop-by-hop headers.
     * - deserialize: The response has arrived, the middleware here will deserialize
     *      the raw response object to structured response
     *
     *      Unlike initialization and build handlers, which are executed once
     *      per operation execution, finalization and deserialize handlers will be
     *      executed foreach HTTP request sent.
     *
     * @defaultValue 'initialize'
     */
    step?: Step;
    /**
     * A list of strings to any that identify the general purpose or important
     * characteristics of a given handler.
     */
    tags?: Array<string>;
    /**
     * A unique name to refer to a middleware
     */
    name?: string;
    /**
     * @internal
     * Aliases allows for middleware to be found by multiple names besides {@link HandlerOptions.name}.
     * This allows for references to replaced middleware to continue working, e.g. replacing
     * multiple auth-specific middleware with a single generic auth middleware.
     */
    aliases?: Array<string>;
    /**
     * A flag to override the existing middleware with the same name. Without
     * setting it, adding middleware with duplicated name will throw an exception.
     * @internal
     */
    override?: boolean;
}
/**
 * @public
 */
export interface AbsoluteLocation {
    /**
     * By default middleware will be added to individual step in un-guaranteed order.
     * In the case that
     *
     * @defaultValue 'normal'
     */
    priority?: Priority;
}
/**
 * @public
 */
export type Relation = "before" | "after";
/**
 * @public
 */
export interface RelativeLocation {
    /**
     * Specify the relation to be before or after a know middleware.
     */
    relation: Relation;
    /**
     * A known middleware name to indicate inserting middleware's location.
     */
    toMiddleware: string;
}
/**
 * @public
 */
export type RelativeMiddlewareOptions = RelativeLocation & Omit<HandlerOptions, "step">;
/**
 * @public
 */
export interface InitializeHandlerOptions extends HandlerOptions {
    step?: "initialize";
}
/**
 * @public
 */
export interface SerializeHandlerOptions extends HandlerOptions {
    step: "serialize";
}
/**
 * @public
 */
export interface BuildHandlerOptions extends HandlerOptions {
    step: "build";
}
/**
 * @public
 */
export interface FinalizeRequestHandlerOptions extends HandlerOptions {
    step: "finalizeRequest";
}
/**
 * @public
 */
export interface DeserializeHandlerOptions extends HandlerOptions {
    step: "deserialize";
}
/**
 * @public
 *
 * A stack storing middleware. It can be resolved into a handler. It supports 2
 * approaches for adding middleware:
 * 1. Adding middleware to specific step with `add()`. The order of middleware
 *    added into same step is determined by order of adding them. If one middleware
 *    needs to be executed at the front of the step or at the end of step, set
 *    `priority` options to `high` or `low`.
 * 2. Adding middleware to location relative to known middleware with `addRelativeTo()`.
 *    This is useful when given middleware must be executed before or after specific
 *    middleware(`toMiddleware`). You can add a middleware relatively to another
 *    middleware which also added relatively. But eventually, this relative middleware
 *    chain **must** be 'anchored' by a middleware that added using `add()` API
 *    with absolute `step` and `priority`. This mothod will throw if specified
 *    `toMiddleware` is not found.
 */
export interface MiddlewareStack<Input extends object, Output extends object> extends Pluggable<Input, Output> {
    /**
     * Add middleware to the stack to be executed during the "initialize" step,
     * optionally specifying a priority, tags and name
     */
    add(middleware: InitializeMiddleware<Input, Output>, options?: InitializeHandlerOptions & AbsoluteLocation): void;
    /**
     * Add middleware to the stack to be executed during the "serialize" step,
     * optionally specifying a priority, tags and name
     */
    add(middleware: SerializeMiddleware<Input, Output>, options: SerializeHandlerOptions & AbsoluteLocation): void;
    /**
     * Add middleware to the stack to be executed during the "build" step,
     * optionally specifying a priority, tags and name
     */
    add(middleware: BuildMiddleware<Input, Output>, options: BuildHandlerOptions & AbsoluteLocation): void;
    /**
     * Add middleware to the stack to be executed during the "finalizeRequest" step,
     * optionally specifying a priority, tags and name
     */
    add(middleware: FinalizeRequestMiddleware<Input, Output>, options: FinalizeRequestHandlerOptions & AbsoluteLocation): void;
    /**
     * Add middleware to the stack to be executed during the "deserialize" step,
     * optionally specifying a priority, tags and name
     */
    add(middleware: DeserializeMiddleware<Input, Output>, options: DeserializeHandlerOptions & AbsoluteLocation): void;
    /**
     * Add middleware to a stack position before or after a known middlewareoptionally
     * specifying name and tags.
     */
    addRelativeTo(middleware: MiddlewareType<Input, Output>, options: RelativeMiddlewareOptions): void;
    /**
     * Apply a customization function to mutate the middleware stack, often
     * used for customizations that requires mutating multiple middleware.
     */
    use(pluggable: Pluggable<Input, Output>): void;
    /**
     * Create a shallow clone of this stack. Step bindings and handler priorities
     * and tags are preserved in the copy.
     */
    clone(): MiddlewareStack<Input, Output>;
    /**
     * Removes middleware from the stack.
     *
     * If a string is provided, it will be treated as middleware name. If a middleware
     * is inserted with the given name, it will be removed.
     *
     * If a middleware class is provided, all usages thereof will be removed.
     */
    remove(toRemove: MiddlewareType<Input, Output> | string): boolean;
    /**
     * Removes middleware that contains given tag
     *
     * Multiple middleware will potentially be removed
     */
    removeByTag(toRemove: string): boolean;
    /**
     * Create a stack containing the middlewares in this stack as well as the
     * middlewares in the `from` stack. Neither source is modified, and step
     * bindings and handler priorities and tags are preserved in the copy.
     */
    concat<InputType extends Input, OutputType extends Output>(from: MiddlewareStack<InputType, OutputType>): MiddlewareStack<InputType, OutputType>;
    /**
     * Returns a list of the current order of middleware in the stack.
     * This does not execute the middleware functions, nor does it
     * provide a reference to the stack itself.
     */
    identify(): string[];
    /**
     * @internal
     *
     * When an operation is called using this stack,
     * it will log its list of middleware to the console using
     * the identify function.
     *
     * @param toggle - set whether to log on resolve.
     *                 If no argument given, returns the current value.
     */
    identifyOnResolve(toggle?: boolean): boolean;
    /**
     * Builds a single handler function from zero or more middleware classes and
     * a core handler. The core handler is meant to send command objects to AWS
     * services and return promises that will resolve with the operation result
     * or be rejected with an error.
     *
     * When a composed handler is invoked, the arguments will pass through all
     * middleware in a defined order, and the return from the innermost handler
     * will pass through all middleware in the reverse of that order.
     */
    resolve<InputType extends Input, OutputType extends Output>(handler: DeserializeHandler<InputType, OutputType>, context: HandlerExecutionContext): InitializeHandler<InputType, OutputType>;
}
/**
 * @internal
 */
export declare const SMITHY_CONTEXT_KEY = "__smithy_context";
/**
 * @public
 *
 * Data and helper objects that are not expected to change from one execution of
 * a composed handler to another.
 */
export interface HandlerExecutionContext {
    /**
     * A logger that may be invoked by any handler during execution of an
     * operation.
     */
    logger?: Logger;
    /**
     * Name of the service the operation is being sent to.
     */
    clientName?: string;
    /**
     * Name of the operation being executed.
     */
    commandName?: string;
    /**
     * Additional user agent that inferred by middleware. It can be used to save
     * the internal user agent sections without overriding the `customUserAgent`
     * config in clients.
     */
    userAgent?: UserAgent;
    /**
     * Resolved by the endpointMiddleware function of `@smithy/middleware-endpoint`
     * in the serialization stage.
     */
    endpointV2?: EndpointV2;
    /**
     * Set at the same time as endpointV2.
     */
    authSchemes?: AuthScheme[];
    /**
     * The current auth configuration that has been set by any auth middleware and
     * that will prevent from being set more than once.
     */
    currentAuthConfig?: HttpAuthDefinition;
    /**
     * @deprecated do not extend this field, it is a carryover from AWS SDKs.
     * Used by DynamoDbDocumentClient.
     */
    dynamoDbDocumentClientOptions?: Partial<{
        overrideInputFilterSensitiveLog(...args: any[]): string | void;
        overrideOutputFilterSensitiveLog(...args: any[]): string | void;
    }>;
    /**
     * @internal
     * Context for Smithy properties.
     */
    [SMITHY_CONTEXT_KEY]?: {
        service?: string;
        operation?: string;
        commandInstance?: Command<any, any, any, any, any>;
        selectedHttpAuthScheme?: SelectedHttpAuthScheme;
        features?: SmithyFeatures;
        /**
         * @deprecated
         * Do not assign arbitrary members to the Smithy Context,
         * fields should be explicitly declared here to avoid collisions.
         */
        [key: string]: unknown;
    };
    /**
     * @deprecated
     * Do not assign arbitrary members to the context, since
     * they can interfere with existing functionality.
     *
     * Additional members should instead be declared on the SMITHY_CONTEXT_KEY
     * or other reserved keys.
     */
    [key: string]: any;
}
/**
 * @public
 */
export interface Pluggable<Input extends object, Output extends object> {
    /**
     * A function that mutate the passed in middleware stack. Functions implementing
     * this interface can add, remove, modify existing middleware stack from clients
     * or commands
     */
    applyToStack: (stack: MiddlewareStack<Input, Output>) => void;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/pagination.d.ts

```typescript
import type { Client } from "./client";
import type { Command } from "./command";
/**
 * @public
 *
 * Expected type definition of a paginator.
 */
export type Paginator<T> = AsyncGenerator<T, undefined, unknown>;
/**
 * @public
 *
 * Expected paginator configuration passed to an operation. Services will extend
 * this interface definition and may type client further.
 */
export interface PaginationConfiguration {
    client: Client<any, any, any>;
    pageSize?: number;
    startingToken?: any;
    /**
     * For some APIs, such as CloudWatchLogs events, the next page token will always
     * be present.
     *
     * When true, this config field will have the paginator stop when the token doesn't change
     * instead of when it is not present.
     */
    stopOnSameToken?: boolean;
    /**
     * @param command - reference to the instantiated command. This callback is executed
     *                  prior to sending the command with the paginator's client.
     * @returns the original command or a replacement, defaulting to the original command object.
     */
    withCommand?: (command: Command<any, any, any, any, any>) => typeof command | undefined;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/profile.d.ts

```typescript
/**
 * @public
 */
export declare enum IniSectionType {
    PROFILE = "profile",
    SSO_SESSION = "sso-session",
    SERVICES = "services"
}
/**
 * @public
 */
export type IniSection = Record<string, string | undefined>;
/**
 * @public
 *
 * @deprecated Please use {@link IniSection}
 */
export interface Profile extends IniSection {
}
/**
 * @public
 */
export type ParsedIniData = Record<string, IniSection>;
/**
 * @public
 */
export interface SharedConfigFiles {
    credentialsFile: ParsedIniData;
    configFile: ParsedIniData;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/response.d.ts

```typescript
/**
 * @public
 */
export interface ResponseMetadata {
    /**
     * The status code of the last HTTP response received for this operation.
     */
    httpStatusCode?: number;
    /**
     * A unique identifier for the last request sent for this operation. Often
     * requested by AWS service teams to aid in debugging.
     */
    requestId?: string;
    /**
     * A secondary identifier for the last request sent. Used for debugging.
     */
    extendedRequestId?: string;
    /**
     * A tertiary identifier for the last request sent. Used for debugging.
     */
    cfId?: string;
    /**
     * The number of times this operation was attempted.
     */
    attempts?: number;
    /**
     * The total amount of time (in milliseconds) that was spent waiting between
     * retry attempts.
     */
    totalRetryDelay?: number;
}
/**
 * @public
 */
export interface MetadataBearer {
    /**
     * Metadata pertaining to this request.
     */
    $metadata: ResponseMetadata;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/retry.d.ts

```typescript
import type { SdkError } from "./shapes";
/**
 * @public
 */
export type RetryErrorType = 
/**
 * This is a connection level error such as a socket timeout, socket connect
 * error, tls negotiation timeout etc...
 * Typically these should never be applied for non-idempotent request types
 * since in this scenario, it's impossible to know whether the operation had
 * a side effect on the server.
 */
"TRANSIENT"
/**
 * This is an error where the server explicitly told the client to back off,
 * such as a 429 or 503 Http error.
 */
 | "THROTTLING"
/**
 * This is a server error that isn't explicitly throttling but is considered
 * by the client to be something that should be retried.
 */
 | "SERVER_ERROR"
/**
 * Doesn't count against any budgets. This could be something like a 401
 * challenge in Http.
 */
 | "CLIENT_ERROR";
/**
 * @public
 */
export interface RetryErrorInfo {
    /**
     * The error thrown during the initial request, if available.
     */
    error?: SdkError;
    errorType: RetryErrorType;
    /**
     * Protocol hint. This could come from Http's 'retry-after' header or
     * something from MQTT or any other protocol that has the ability to convey
     * retry info from a peer.
     *
     * The Date after which a retry should be attempted.
     */
    retryAfterHint?: Date;
}
/**
 * @public
 */
export interface RetryBackoffStrategy {
    /**
     * @returns the number of milliseconds to wait before retrying an action.
     */
    computeNextBackoffDelay(retryAttempt: number): number;
}
/**
 * @public
 */
export interface StandardRetryBackoffStrategy extends RetryBackoffStrategy {
    /**
     * Sets the delayBase used to compute backoff delays.
     * @param delayBase -
     */
    setDelayBase(delayBase: number): void;
}
/**
 * @public
 */
export interface RetryStrategyOptions {
    backoffStrategy: RetryBackoffStrategy;
    maxRetriesBase: number;
}
/**
 * @public
 */
export interface RetryToken {
    /**
     * @returns the current count of retry.
     */
    getRetryCount(): number;
    /**
     * @returns the number of milliseconds to wait before retrying an action.
     */
    getRetryDelay(): number;
}
/**
 * @public
 */
export interface StandardRetryToken extends RetryToken {
    /**
     * @returns the cost of the last retry attempt.
     */
    getRetryCost(): number | undefined;
}
/**
 * @public
 */
export interface RetryStrategyV2 {
    /**
     * Called before any retries (for the first call to the operation). It either
     * returns a retry token or an error upon the failure to acquire a token prior.
     *
     * tokenScope is arbitrary and out of scope for this component. However,
     * adding it here offers us a lot of future flexibility for outage detection.
     * For example, it could be "us-east-1" on a shared retry strategy, or
     * "us-west-2-c:dynamodb".
     */
    acquireInitialRetryToken(retryTokenScope: string): Promise<RetryToken>;
    /**
     * After a failed operation call, this function is invoked to refresh the
     * retryToken returned by acquireInitialRetryToken(). This function can
     * either choose to allow another retry and send a new or updated token,
     * or reject the retry attempt and report the error either in an exception
     * or returning an error.
     */
    refreshRetryTokenForRetry(tokenToRenew: RetryToken, errorInfo: RetryErrorInfo): Promise<RetryToken>;
    /**
     * Upon successful completion of the operation, this function is called
     * to record that the operation was successful.
     */
    recordSuccess(token: RetryToken): void;
}
/**
 * @public
 */
export type ExponentialBackoffJitterType = "DEFAULT" | "NONE" | "FULL" | "DECORRELATED";
/**
 * @public
 */
export interface ExponentialBackoffStrategyOptions {
    jitterType: ExponentialBackoffJitterType;
    backoffScaleValue?: number;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/schema/schema-deprecated.d.ts

```typescript
import type { EndpointV2 } from "../endpoint";
import type { HandlerExecutionContext } from "../middleware";
import type { MetadataBearer } from "../response";
import type { EndpointBearer, SerdeFunctions } from "../serde";
import type { ConfigurableSerdeContext, NormalizedSchema, SchemaTraits, SimpleSchema, UnitSchema } from "./schema";
import type { StaticSchema } from "./static-schemas";
/**
 * A schema is an object or value that describes how to serialize/deserialize data.
 * @public
 * @deprecated use $Schema
 */
export type Schema = UnitSchema | TraitsSchema | SimpleSchema | ListSchema | MapSchema | StructureSchema | MemberSchema | OperationSchema | StaticSchema | NormalizedSchema;
/**
 * A schema "reference" is either a schema or a function that
 * provides a schema. This is useful for lazy loading, and to allow
 * code generation to define schema out of dependency order.
 * @public
 * @deprecated use $SchemaRef
 */
export type SchemaRef = Schema | (() => Schema);
/**
 * A schema that has traits.
 *
 * @public
 * @deprecated use static schema.
 */
export interface TraitsSchema {
    namespace: string;
    name: string;
    traits: SchemaTraits;
}
/**
 * Indicates the schema is a member of a parent Structure schema.
 * It may also have a set of member traits distinct from its target shape's traits.
 * @public
 * @deprecated use $MemberSchema
 */
export type MemberSchema = [SchemaRef, SchemaTraits];
/**
 * Schema for the structure aggregate type.
 * @public
 * @deprecated use static schema.
 */
export interface StructureSchema extends TraitsSchema {
    memberNames: string[];
    memberList: SchemaRef[];
    /**
     * @deprecated structure member iteration will be linear on the memberNames and memberList arrays.
     * It can be collected into a hashmap form on an ad-hoc basis, but will not initialize as such.
     */
    members?: Record<string, [SchemaRef, SchemaTraits]> | undefined;
}
/**
 * Schema for the list aggregate type.
 * @public
 * @deprecated use static schema.
 */
export interface ListSchema extends TraitsSchema {
    valueSchema: SchemaRef;
}
/**
 * Schema for the map aggregate type.
 * @public
 * @deprecated use static schema.
 */
export interface MapSchema extends TraitsSchema {
    keySchema: SchemaRef;
    valueSchema: SchemaRef;
}
/**
 * Schema for an operation.
 * @public
 * @deprecated use StaticOperationSchema or $OperationSchema
 */
export interface OperationSchema {
    namespace: string;
    name: string;
    traits: SchemaTraits;
    input: SchemaRef;
    output: SchemaRef;
}
/**
 * Turns a serialization into a data object.
 * @public
 * @deprecated use $ShapeDeserializer
 */
export interface ShapeDeserializer<SerializationType = Uint8Array> extends ConfigurableSerdeContext {
    /**
     * Optionally async.
     */
    read(schema: Schema, data: SerializationType): any | Promise<any>;
}
/**
 * Turns a data object into a serialization.
 * @public
 * @deprecated use $ShapeSerializer
 */
export interface ShapeSerializer<SerializationType = Uint8Array> extends ConfigurableSerdeContext {
    write(schema: Schema, value: unknown): void;
    flush(): SerializationType;
}
/**
 * A codec creates serializers and deserializers for some format such as JSON, XML, or CBOR.
 *
 * @public
 * @deprecated use $Codec
 */
export interface Codec<S, D> extends ConfigurableSerdeContext {
    createSerializer(): ShapeSerializer<S>;
    createDeserializer(): ShapeDeserializer<D>;
}
/**
 * A client protocol defines how to convert a message (e.g. HTTP request/response) to and from a data object.
 * @public
 * @deprecated use $ClientProtocol
 */
export interface ClientProtocol<Request, Response> extends ConfigurableSerdeContext {
    /**
     * @returns the Smithy qualified shape id.
     */
    getShapeId(): string;
    getRequestType(): {
        new (...args: any[]): Request;
    };
    getResponseType(): {
        new (...args: any[]): Response;
    };
    /**
     * @returns the payload codec if the requests/responses have a symmetric format.
     * It otherwise may return null.
     */
    getPayloadCodec(): Codec<any, any>;
    serializeRequest<Input extends object>(operationSchema: OperationSchema, input: Input, context: HandlerExecutionContext & SerdeFunctions & EndpointBearer): Promise<Request>;
    updateServiceEndpoint(request: Request, endpoint: EndpointV2): Request;
    deserializeResponse<Output extends MetadataBearer>(operationSchema: OperationSchema, context: HandlerExecutionContext & SerdeFunctions, response: Response): Promise<Output>;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/schema/schema.d.ts

```typescript
import type { EndpointV2 } from "../endpoint";
import type { HandlerExecutionContext } from "../middleware";
import type { MetadataBearer } from "../response";
import type { EndpointBearer, SerdeFunctions } from "../serde";
import type { BigDecimalSchema, BigIntegerSchema, BlobSchema, BooleanSchema, DocumentSchema, NumericSchema, StreamingBlobSchema, StringSchema, TimestampDateTimeSchema, TimestampDefaultSchema, TimestampEpochSecondsSchema, TimestampHttpDateSchema } from "./sentinels";
import type { StaticSchema } from "./static-schemas";
import type { TraitBitVector } from "./traits";
/**
 * A schema is an object or value that describes how to serialize/deserialize data.
 * @alpha
 */
export type $Schema = UnitSchema | SimpleSchema | $MemberSchema | StaticSchema | NormalizedSchema;
/**
 * Traits attached to schema objects.
 *
 * When this is a number, it refers to a pre-allocated
 * trait combination that is equivalent to one of the
 * object type's variations.
 *
 * @public
 */
export type SchemaTraits = TraitBitVector | SchemaTraitsObject;
/**
 * Simple schemas are those corresponding to simple Smithy types.
 * @see https://smithy.io/2.0/spec/simple-types.html
 * @public
 */
export type SimpleSchema = BlobSchemas | StringSchema | BooleanSchema | NumericSchema | BigIntegerSchema | BigDecimalSchema | DocumentSchema | TimestampSchemas | number;
/**
 * Sentinel value for Timestamp schema.
 * "Default" means unspecified and to use the protocol serializer's default format.
 *
 * @public
 */
export type TimestampSchemas = TimestampDefaultSchema | TimestampDateTimeSchema | TimestampHttpDateSchema | TimestampEpochSecondsSchema;
/**
 * Sentinel values for Blob schema.
 * @public
 */
export type BlobSchemas = BlobSchema | StreamingBlobSchema;
/**
 * Signal value for the Smithy void value. Typically used for
 * operation input and outputs.
 *
 * @alpha
 */
export type UnitSchema = "unit";
/**
 * See https://smithy.io/2.0/trait-index.html for individual definitions.
 *
 * @public
 */
export type SchemaTraitsObject = {
    idempotent?: 1;
    idempotencyToken?: 1;
    sensitive?: 1;
    sparse?: 1;
    /**
     * timestampFormat is expressed by the schema sentinel values of 4, 5, 6, and 7,
     * and not contained in trait objects.
     * @deprecated use schema value.
     */
    timestampFormat?: never;
    httpLabel?: 1;
    httpHeader?: string;
    httpQuery?: string;
    httpPrefixHeaders?: string;
    httpQueryParams?: 1;
    httpPayload?: 1;
    /**
     * [method, path, statusCode]
     */
    http?: [string, string, number];
    httpResponseCode?: 1;
    /**
     * [hostPrefix]
     */
    endpoint?: [string];
    xmlAttribute?: 1;
    xmlName?: string;
    /**
     * [prefix, uri]
     */
    xmlNamespace?: [string, string];
    xmlFlattened?: 1;
    jsonName?: string;
    mediaType?: string;
    error?: "client" | "server";
    streaming?: 1;
    eventHeader?: 1;
    eventPayload?: 1;
    [traitName: string]: unknown;
};
/**
 * Indicates the schema is a member of a parent Structure schema.
 * It may also have a set of member traits distinct from its target shape's traits.
 * @alpha
 */
export type $MemberSchema = [$SchemaRef, SchemaTraits];
/**
 * Schema for an operation.
 * @alpha
 */
export interface $OperationSchema {
    namespace: string;
    name: string;
    traits: SchemaTraits;
    input: $SchemaRef;
    output: $SchemaRef;
}
/**
 * Normalization wrapper for various schema data objects.
 * @public
 */
export interface NormalizedSchema {
    getSchema(): $Schema;
    getName(): string | undefined;
    isMemberSchema(): boolean;
    isListSchema(): boolean;
    isMapSchema(): boolean;
    isStructSchema(): boolean;
    isBlobSchema(): boolean;
    isTimestampSchema(): boolean;
    isStringSchema(): boolean;
    isBooleanSchema(): boolean;
    isNumericSchema(): boolean;
    isBigIntegerSchema(): boolean;
    isBigDecimalSchema(): boolean;
    isStreaming(): boolean;
    getMergedTraits(): SchemaTraitsObject;
    getMemberTraits(): SchemaTraitsObject;
    getOwnTraits(): SchemaTraitsObject;
    /**
     * For list/set/map.
     */
    getValueSchema(): NormalizedSchema;
    /**
     * For struct/union.
     */
    getMemberSchema(member: string): NormalizedSchema | undefined;
    structIterator(): Generator<[string, NormalizedSchema], undefined, undefined>;
}
/**
 * A schema "reference" is either a schema or a function that
 * provides a schema. This is useful for lazy loading, and to allow
 * code generation to define schema out of dependency order.
 * @alpha
 */
export type $SchemaRef = $Schema | (() => $Schema);
/**
 * A codec creates serializers and deserializers for some format such as JSON, XML, or CBOR.
 *
 * @public
 */
export interface $Codec<S, D> extends ConfigurableSerdeContext {
    createSerializer(): $ShapeSerializer<S>;
    createDeserializer(): $ShapeDeserializer<D>;
}
/**
 * Configuration for codecs. Different protocols may share codecs, but require different behaviors from them.
 *
 * @public
 */
export type CodecSettings = {
    timestampFormat: {
        /**
         * Whether to use member timestamp format traits.
         */
        useTrait: boolean;
        /**
         * Default timestamp format.
         */
        default: TimestampDateTimeSchema | TimestampHttpDateSchema | TimestampEpochSecondsSchema;
    };
    /**
     * Whether to use HTTP binding traits.
     */
    httpBindings?: boolean;
};
/**
 * Turns a serialization into a data object.
 * @public
 */
export interface $ShapeDeserializer<SerializationType = Uint8Array> extends ConfigurableSerdeContext {
    /**
     * Optionally async.
     */
    read(schema: $Schema, data: SerializationType): any | Promise<any>;
}
/**
 * Turns a data object into a serialization.
 * @public
 */
export interface $ShapeSerializer<SerializationType = Uint8Array> extends ConfigurableSerdeContext {
    write(schema: $Schema, value: unknown): void;
    flush(): SerializationType;
}
/**
 * A client protocol defines how to convert a message (e.g. HTTP request/response) to and from a data object.
 * @public
 */
export interface $ClientProtocol<Request, Response> extends ConfigurableSerdeContext {
    /**
     * @returns the Smithy qualified shape id.
     */
    getShapeId(): string;
    getRequestType(): {
        new (...args: any[]): Request;
    };
    getResponseType(): {
        new (...args: any[]): Response;
    };
    /**
     * @returns the payload codec if the requests/responses have a symmetric format.
     * It otherwise may return null.
     */
    getPayloadCodec(): $Codec<any, any>;
    serializeRequest<Input extends object>(operationSchema: $OperationSchema, input: Input, context: HandlerExecutionContext & SerdeFunctions & EndpointBearer): Promise<Request>;
    updateServiceEndpoint(request: Request, endpoint: EndpointV2): Request;
    deserializeResponse<Output extends MetadataBearer>(operationSchema: $OperationSchema, context: HandlerExecutionContext & SerdeFunctions, response: Response): Promise<Output>;
}
/**
 * Allows a protocol, codec, or serde utility to accept the serdeContext
 * from a client configuration or request/response handlerExecutionContext.
 *
 * @public
 */
export interface ConfigurableSerdeContext {
    setSerdeContext(serdeContext: SerdeFunctions): void;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/schema/sentinels.d.ts

```typescript
/**
 * The blob Smithy type, in JS as Uint8Array and other representations
 * such as Buffer, string, or Readable(Stream) depending on circumstances.
 * @public
 */
export type BlobSchema = 21;
/**
 * @public
 */
export type StreamingBlobSchema = 42;
/**
 * @public
 */
export type BooleanSchema = 2;
/**
 * Includes string and enum Smithy types.
 * @public
 */
export type StringSchema = 0;
/**
 * Includes all numeric Smithy types except bigInteger and bigDecimal.
 * byte, short, integer, long, float, double, intEnum.
 *
 * @public
 */
export type NumericSchema = 1;
/**
 * @public
 */
export type BigIntegerSchema = 17;
/**
 * @public
 */
export type BigDecimalSchema = 19;
/**
 * @public
 */
export type DocumentSchema = 15;
/**
 * Smithy type timestamp, in JS as native Date object.
 * @public
 */
export type TimestampDefaultSchema = 4;
/**
 * @public
 */
export type TimestampDateTimeSchema = 5;
/**
 * @public
 */
export type TimestampHttpDateSchema = 6;
/**
 * @public
 */
export type TimestampEpochSecondsSchema = 7;
/**
 * Additional bit indicating the type is a list.
 * @public
 */
export type ListSchemaModifier = 64;
/**
 * Additional bit indicating the type is a map.
 * @public
 */
export type MapSchemaModifier = 128;

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/schema/static-schemas.d.ts

```typescript
import type { $SchemaRef, SchemaTraits } from "../schema/schema";
/**
 * @alpha
 */
export type StaticSchemaIdSimple = 0;
/**
 * @alpha
 */
export type StaticSchemaIdList = 1;
/**
 * @alpha
 */
export type StaticSchemaIdMap = 2;
/**
 * @alpha
 */
export type StaticSchemaIdStruct = 3;
/**
 * @alpha
 */
export type StaticSchemaIdError = -3;
/**
 * @alpha
 */
export type StaticSchemaIdOperation = 9;
/**
 * @alpha
 */
export type StaticSchema = StaticSimpleSchema | StaticListSchema | StaticMapSchema | StaticStructureSchema | StaticErrorSchema | StaticOperationSchema;
/**
 * @alpha
 */
export type ShapeName = string;
/**
 * @alpha
 */
export type ShapeNamespace = string;
/**
 * @alpha
 */
export type StaticSimpleSchema = [StaticSchemaIdSimple, ShapeNamespace, ShapeName, SchemaTraits, $SchemaRef];
/**
 * @alpha
 */
export type StaticListSchema = [StaticSchemaIdList, ShapeNamespace, ShapeName, SchemaTraits, $SchemaRef];
/**
 * @alpha
 */
export type StaticMapSchema = [StaticSchemaIdMap, ShapeNamespace, ShapeName, SchemaTraits, $SchemaRef, $SchemaRef];
/**
 * @alpha
 */
export type StaticStructureSchema = [
    StaticSchemaIdStruct,
    ShapeNamespace,
    ShapeName,
    SchemaTraits,
    string[],
    $SchemaRef[]
];
/**
 * @alpha
 */
export type StaticErrorSchema = [
    StaticSchemaIdError,
    ShapeNamespace,
    ShapeName,
    SchemaTraits,
    string[],
    $SchemaRef[]
];
/**
 * @alpha
 */
export type StaticOperationSchema = [
    StaticSchemaIdOperation,
    ShapeNamespace,
    ShapeName,
    SchemaTraits,
    $SchemaRef,
    $SchemaRef
];

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/schema/traits.d.ts

```typescript
/**
 * A bitvector representing a traits object.
 *
 * Vector index to trait:
 * 0 - httpLabel
 * 1 - idempotent
 * 2 - idempotencyToken
 * 3 - sensitive
 * 4 - httpPayload
 * 5 - httpResponseCode
 * 6 - httpQueryParams
 *
 * The singular trait values are enumerated for quick identification, but
 * combination values are left to the `number` union type.
 *
 * @public
 */
export type TraitBitVector = HttpLabelBitMask | IdempotentBitMask | IdempotencyTokenBitMask | SensitiveBitMask | HttpPayloadBitMask | HttpResponseCodeBitMask | HttpQueryParamsBitMask | number;
/**
 * @public
 */
export type HttpLabelBitMask = 1;
/**
 * @public
 */
export type IdempotentBitMask = 2;
/**
 * @public
 */
export type IdempotencyTokenBitMask = 4;
/**
 * @public
 */
export type SensitiveBitMask = 8;
/**
 * @public
 */
export type HttpPayloadBitMask = 16;
/**
 * @public
 */
export type HttpResponseCodeBitMask = 32;
/**
 * @public
 */
export type HttpQueryParamsBitMask = 64;

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/serde.d.ts

```typescript
import type { Endpoint } from "./http";
import type { $ClientProtocol } from "./schema/schema";
import type { RequestHandler } from "./transfer";
import type { Decoder, Encoder, Provider } from "./util";
/**
 * @public
 *
 * Interface for object requires an Endpoint set.
 */
export interface EndpointBearer {
    endpoint: Provider<Endpoint>;
}
/**
 * @public
 */
export interface StreamCollector {
    /**
     * A function that converts a stream into an array of bytes.
     *
     * @param stream - The low-level native stream from browser or Nodejs runtime
     */
    (stream: any): Promise<Uint8Array>;
}
/**
 * @public
 *
 * Request and Response serde util functions and settings for AWS services
 */
export interface SerdeContext extends SerdeFunctions, EndpointBearer {
    requestHandler: RequestHandler<any, any>;
    disableHostPrefix: boolean;
    protocol?: $ClientProtocol<any, any>;
}
/**
 * @public
 *
 * Serde functions from the client config.
 */
export interface SerdeFunctions {
    base64Encoder: Encoder;
    base64Decoder: Decoder;
    utf8Encoder: Encoder;
    utf8Decoder: Decoder;
    streamCollector: StreamCollector;
}
/**
 * @public
 */
export interface RequestSerializer<Request, Context extends EndpointBearer = any> {
    /**
     * Converts the provided `input` into a request object
     *
     * @param input - The user input to serialize.
     *
     * @param context - Context containing runtime-specific util functions.
     */
    (input: any, context: Context): Promise<Request>;
}
/**
 * @public
 */
export interface ResponseDeserializer<OutputType, ResponseType = any, Context = any> {
    /**
     * Converts the output of an operation into JavaScript types.
     *
     * @param output - The HTTP response received from the service
     *
     * @param context - context containing runtime-specific util functions.
     */
    (output: ResponseType, context: Context): Promise<OutputType>;
}
/**
 * The interface contains mix-in utility functions to transfer the runtime-specific
 * stream implementation to specified format. Each stream can ONLY be transformed
 * once.
 * @public
 */
export interface SdkStreamMixin {
    transformToByteArray: () => Promise<Uint8Array>;
    transformToString: (encoding?: string) => Promise<string>;
    transformToWebStream: () => ReadableStream;
}
/**
 * @public
 *
 * The type describing a runtime-specific stream implementation with mix-in
 * utility functions.
 */
export type SdkStream<BaseStream> = BaseStream & SdkStreamMixin;
/**
 * @public
 *
 * Indicates that the member of type T with
 * key StreamKey have been extended
 * with the SdkStreamMixin helper methods.
 */
export type WithSdkStreamMixin<T, StreamKey extends keyof T> = {
    [key in keyof T]: key extends StreamKey ? SdkStream<T[StreamKey]> : T[key];
};
/**
 * Interface for internal function to inject stream utility functions
 * implementation
 *
 * @internal
 */
export interface SdkStreamMixinInjector {
    (stream: unknown): SdkStreamMixin;
}
/**
 * @internal
 */
export interface SdkStreamSerdeContext {
    sdkStreamMixin: SdkStreamMixinInjector;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/shapes.d.ts

```typescript
import type { HttpResponse } from "./http";
import type { MetadataBearer } from "./response";
/**
 * @public
 *
 * A document type represents an untyped JSON-like value.
 *
 * Not all protocols support document types, and the serialization format of a
 * document type is protocol specific. All JSON protocols SHOULD support
 * document types and they SHOULD serialize document types inline as normal
 * JSON values.
 */
export type DocumentType = null | boolean | number | string | DocumentType[] | {
    [prop: string]: DocumentType;
};
/**
 * @public
 *
 * A structure shape with the error trait.
 * https://smithy.io/2.0/spec/behavior-traits.html#smithy-api-retryable-trait
 */
export interface RetryableTrait {
    /**
     * Indicates that the error is a retryable throttling error.
     */
    readonly throttling?: boolean;
}
/**
 * @public
 *
 * Type that is implemented by all Smithy shapes marked with the
 * error trait.
 * @deprecated
 */
export interface SmithyException {
    /**
     * The shape ID name of the exception.
     */
    readonly name: string;
    /**
     * Whether the client or server are at fault.
     */
    readonly $fault: "client" | "server";
    /**
     * The service that encountered the exception.
     */
    readonly $service?: string;
    /**
     * Indicates that an error MAY be retried by the client.
     */
    readonly $retryable?: RetryableTrait;
    /**
     * Reference to low-level HTTP response object.
     */
    readonly $response?: HttpResponse;
}
/**
 * @public
 *
 * @deprecated See {@link https://aws.amazon.com/blogs/developer/service-error-handling-modular-aws-sdk-js/}
 *
 * This type should not be used in your application.
 * Users of the AWS SDK for JavaScript v3 service clients should prefer to
 * use the specific Exception classes corresponding to each operation.
 * These can be found as code in the deserializer for the operation's Command class,
 * or as declarations in the service model file in codegen/sdk-codegen/aws-models.
 *
 * If no exceptions are enumerated by a particular Command operation,
 * the base exception for the service should be used. Each client exports
 * a base ServiceException prefixed with the service name.
 */
export type SdkError = Error & Partial<SmithyException> & Partial<MetadataBearer> & {
    $metadata?: Partial<MetadataBearer>["$metadata"] & {
        /**
         * If present, will have value of true and indicates that the error resulted in a
         * correction of the clock skew, a.k.a. config.systemClockOffset.
         * This is specific to AWS SDK and sigv4.
         */
        readonly clockSkewCorrected?: true;
    };
    cause?: Error;
};

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/signature.d.ts

```typescript
import type { Message } from "./eventStream";
import type { HttpRequest } from "./http";
/**
 * @public
 *
 * A `Date` object, a unix (epoch) timestamp in seconds, or a string that can be
 * understood by the JavaScript `Date` constructor.
 */
export type DateInput = number | string | Date;
/**
 * @public
 */
export interface SigningArguments {
    /**
     * The date and time to be used as signature metadata. This value should be
     * a Date object, a unix (epoch) timestamp, or a string that can be
     * understood by the JavaScript `Date` constructor.If not supplied, the
     * value returned by `new Date()` will be used.
     */
    signingDate?: DateInput;
    /**
     * The service signing name. It will override the service name of the signer
     * in current invocation
     */
    signingService?: string;
    /**
     * The region name to sign the request. It will override the signing region of the
     * signer in current invocation
     */
    signingRegion?: string;
}
/**
 * @public
 */
export interface RequestSigningArguments extends SigningArguments {
    /**
     * A set of strings whose members represents headers that cannot be signed.
     * All headers in the provided request will have their names converted to
     * lower case and then checked for existence in the unsignableHeaders set.
     */
    unsignableHeaders?: Set<string>;
    /**
     * A set of strings whose members represents headers that should be signed.
     * Any values passed here will override those provided via unsignableHeaders,
     * allowing them to be signed.
     *
     * All headers in the provided request will have their names converted to
     * lower case before signing.
     */
    signableHeaders?: Set<string>;
}
/**
 * @public
 */
export interface RequestPresigningArguments extends RequestSigningArguments {
    /**
     * The number of seconds before the presigned URL expires
     */
    expiresIn?: number;
    /**
     * A set of strings whose representing headers that should not be hoisted
     * to presigned request's query string. If not supplied, the presigner
     * moves all the AWS-specific headers (starting with `x-amz-`) to the request
     * query string. If supplied, these headers remain in the presigned request's
     * header.
     * All headers in the provided request will have their names converted to
     * lower case and then checked for existence in the unhoistableHeaders set.
     */
    unhoistableHeaders?: Set<string>;
    /**
     * This overrides any headers with the same name(s) set by unhoistableHeaders.
     * These headers will be hoisted into the query string and signed.
     */
    hoistableHeaders?: Set<string>;
}
/**
 * @public
 */
export interface EventSigningArguments extends SigningArguments {
    priorSignature: string;
}
/**
 * @public
 */
export interface RequestPresigner {
    /**
     * Signs a request for future use.
     *
     * The request will be valid until either the provided `expiration` time has
     * passed or the underlying credentials have expired.
     *
     * @param requestToSign - The request that should be signed.
     * @param options - Additional signing options.
     */
    presign(requestToSign: HttpRequest, options?: RequestPresigningArguments): Promise<HttpRequest>;
}
/**
 * @public
 *
 * An object that signs request objects with AWS credentials using one of the
 * AWS authentication protocols.
 */
export interface RequestSigner {
    /**
     * Sign the provided request for immediate dispatch.
     */
    sign(requestToSign: HttpRequest, options?: RequestSigningArguments): Promise<HttpRequest>;
}
/**
 * @public
 */
export interface StringSigner {
    /**
     * Sign the provided `stringToSign` for use outside of the context of
     * request signing. Typical uses include signed policy generation.
     */
    sign(stringToSign: string, options?: SigningArguments): Promise<string>;
}
/**
 * @public
 */
export interface FormattedEvent {
    headers: Uint8Array;
    payload: Uint8Array;
}
/**
 * @public
 */
export interface EventSigner {
    /**
     * Sign the individual event of the event stream.
     */
    sign(event: FormattedEvent, options: EventSigningArguments): Promise<string>;
}
/**
 * @public
 */
export interface SignableMessage {
    message: Message;
    priorSignature: string;
}
/**
 * @public
 */
export interface SignedMessage {
    message: Message;
    signature: string;
}
/**
 * @public
 */
export interface MessageSigner {
    signMessage(message: SignableMessage, args: SigningArguments): Promise<SignedMessage>;
    sign(event: SignableMessage, options: SigningArguments): Promise<SignedMessage>;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/stream.d.ts

```typescript
import type { ChecksumConstructor } from "./checksum";
import type { HashConstructor, StreamHasher } from "./crypto";
import type { BodyLengthCalculator, Encoder } from "./util";
/**
 * @public
 */
export interface GetAwsChunkedEncodingStreamOptions {
    base64Encoder?: Encoder;
    bodyLengthChecker: BodyLengthCalculator;
    checksumAlgorithmFn?: ChecksumConstructor | HashConstructor;
    checksumLocationName?: string;
    streamHasher?: StreamHasher;
}
/**
 * @public
 *
 * A function that returns Readable Stream which follows aws-chunked encoding stream.
 * It optionally adds checksum if options are provided.
 */
export interface GetAwsChunkedEncodingStream<StreamType = any> {
    (readableStream: StreamType, options: GetAwsChunkedEncodingStreamOptions): StreamType;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/streaming-payload/streaming-blob-common-types.d.ts

```typescript
import type { Readable } from "stream";
import type { BlobOptionalType, ReadableStreamOptionalType } from "../externals-check/browser-externals-check";
/**
 * @public
 *
 * This is the union representing the modeled blob type with streaming trait
 * in a generic format that does not relate to HTTP input or output payloads.
 *
 * Note: the non-streaming blob type is represented by Uint8Array, but because
 * the streaming blob type is always in the request/response paylod, it has
 * historically been handled with different types.
 *
 * @see https://smithy.io/2.0/spec/simple-types.html#blob
 *
 * For compatibility with its historical representation, it must contain at least
 * Readble (Node.js), Blob (browser), and ReadableStream (browser).
 *
 * @see StreamingPayloadInputTypes for FAQ about mixing types from multiple environments.
 */
export type StreamingBlobTypes = NodeJsRuntimeStreamingBlobTypes | BrowserRuntimeStreamingBlobTypes;
/**
 * @public
 *
 * Node.js streaming blob type.
 */
export type NodeJsRuntimeStreamingBlobTypes = Readable;
/**
 * @public
 *
 * Browser streaming blob types.
 */
export type BrowserRuntimeStreamingBlobTypes = ReadableStreamOptionalType | BlobOptionalType;

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/streaming-payload/streaming-blob-payload-input-types.d.ts

```typescript
import type { Readable } from "stream";
import type { BlobOptionalType, ReadableStreamOptionalType } from "../externals-check/browser-externals-check";
/**
 * @public
 *
 * This union represents a superset of the compatible types you
 * can use for streaming payload inputs.
 *
 * FAQ:
 * Why does the type union mix mutually exclusive runtime types, namely
 * Node.js and browser types?
 *
 * There are several reasons:
 * 1. For backwards compatibility.
 * 2. As a convenient compromise solution so that users in either environment may use the types
 *    without customization.
 * 3. The SDK does not have static type information about the exact implementation
 *    of the HTTP RequestHandler being used in your client(s) (e.g. fetch, XHR, node:http, or node:http2),
 *    given that it is chosen at runtime. There are multiple possible request handlers
 *    in both the Node.js and browser runtime environments.
 *
 *    Rather than restricting the type to a known common format (Uint8Array, for example)
 *    which doesn't include a universal streaming format in the currently supported Node.js versions,
 *    the type declaration is widened to multiple possible formats.
 *    It is up to the user to ultimately select a compatible format with the
 *    runtime and HTTP handler implementation they are using.
 *
 * Usage:
 *    The typical solution we expect users to have is to manually narrow the
 *    type when needed, picking the appropriate one out of the union according to the
 *    runtime environment and specific request handler.
 *    There is also the type utility "NodeJsClient", "BrowserClient" and more
 *    exported from this package. These can be applied at the client level
 *    to pre-narrow these streaming payload blobs. For usage see the readme.md
 *    in the root of the \@smithy/types NPM package.
 */
export type StreamingBlobPayloadInputTypes = NodeJsRuntimeStreamingBlobPayloadInputTypes | BrowserRuntimeStreamingBlobPayloadInputTypes;
/**
 * @public
 *
 * Streaming payload input types in the Node.js environment.
 * These are derived from the types compatible with the request body used by node:http.
 *
 * Note: not all types are signable by the standard SignatureV4 signer when
 * used as the request body. For example, in Node.js a Readable stream
 * is not signable by the default signer.
 * They are included in the union because it may be intended in some cases,
 * but the expected types are primarily string, Uint8Array, and Buffer.
 *
 * Additional details may be found in the internal
 * function "getPayloadHash" in the SignatureV4 module.
 */
export type NodeJsRuntimeStreamingBlobPayloadInputTypes = string | Uint8Array | Buffer | Readable;
/**
 * @public
 *
 * Streaming payload input types in the browser environment.
 * These are derived from the types compatible with fetch's Request.body.
 */
export type BrowserRuntimeStreamingBlobPayloadInputTypes = string | Uint8Array | ReadableStreamOptionalType | BlobOptionalType;

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/streaming-payload/streaming-blob-payload-output-types.d.ts

```typescript
import type { IncomingMessage } from "http";
import type { Readable } from "stream";
import type { BlobOptionalType, ReadableStreamOptionalType } from "../externals-check/browser-externals-check";
import type { SdkStream } from "../serde";
/**
 * @public
 *
 * This union represents a superset of the types you may receive
 * in streaming payload outputs.
 *
 * @see StreamingPayloadInputTypes for FAQ about mixing types from multiple environments.
 *
 * To highlight the upstream docs about the SdkStream mixin:
 *
 * The interface contains mix-in (via Object.assign) methods to transform the runtime-specific
 * stream implementation to specified format. Each stream can ONLY be transformed
 * once.
 *
 * The available methods are described on the SdkStream type via SdkStreamMixin.
 */
export type StreamingBlobPayloadOutputTypes = NodeJsRuntimeStreamingBlobPayloadOutputTypes | BrowserRuntimeStreamingBlobPayloadOutputTypes;
/**
 * @public
 *
 * Streaming payload output types in the Node.js environment.
 *
 * This is by default the IncomingMessage type from node:http responses when
 * using the default node-http-handler in Node.js environments.
 *
 * It can be other Readable types like node:http2's ClientHttp2Stream
 * such as when using the node-http2-handler.
 *
 * The SdkStreamMixin adds methods on this type to help transform (collect) it to
 * other formats.
 */
export type NodeJsRuntimeStreamingBlobPayloadOutputTypes = SdkStream<IncomingMessage | Readable>;
/**
 * @public
 *
 * Streaming payload output types in the browser environment.
 *
 * This is by default fetch's Response.body type (ReadableStream) when using
 * the default fetch-http-handler in browser-like environments.
 *
 * It may be a Blob, such as when using the XMLHttpRequest handler
 * and receiving an arraybuffer response body.
 *
 * The SdkStreamMixin adds methods on this type to help transform (collect) it to
 * other formats.
 */
export type BrowserRuntimeStreamingBlobPayloadOutputTypes = SdkStream<ReadableStreamOptionalType | BlobOptionalType>;

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/transfer.d.ts

```typescript
/**
 * @public
 */
export type RequestHandlerOutput<ResponseType> = {
    response: ResponseType;
};
/**
 * @public
 */
export interface RequestHandler<RequestType, ResponseType, HandlerOptions = {}> {
    /**
     * metadata contains information of a handler. For example
     * 'h2' refers this handler is for handling HTTP/2 requests,
     * whereas 'h1' refers handling HTTP1 requests
     */
    metadata?: RequestHandlerMetadata;
    destroy?: () => void;
    handle: (request: RequestType, handlerOptions?: HandlerOptions) => Promise<RequestHandlerOutput<ResponseType>>;
}
/**
 * @public
 */
export interface RequestHandlerMetadata {
    handlerProtocol: RequestHandlerProtocol | string;
}
/**
 * @public
 * Values from ALPN Protocol IDs.
 * @see https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids
 */
export declare enum RequestHandlerProtocol {
    HTTP_0_9 = "http/0.9",
    HTTP_1_0 = "http/1.0",
    TDS_8_0 = "tds/8.0"
}
/**
 * @public
 */
export interface RequestContext {
    destination: URL;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/transform/client-method-transforms.d.ts

```typescript
import type { CommandIO } from "../command";
import type { MetadataBearer } from "../response";
import type { StreamingBlobPayloadOutputTypes } from "../streaming-payload/streaming-blob-payload-output-types";
import type { Transform } from "./type-transform";
/**
 * @internal
 *
 * Narrowed version of InvokeFunction used in Client::send.
 */
export interface NarrowedInvokeFunction<NarrowType, HttpHandlerOptions, InputTypes extends object, OutputTypes extends MetadataBearer> {
    <InputType extends InputTypes, OutputType extends OutputTypes>(command: CommandIO<InputType, OutputType>, options?: HttpHandlerOptions): Promise<Transform<OutputType, StreamingBlobPayloadOutputTypes | undefined, NarrowType>>;
    <InputType extends InputTypes, OutputType extends OutputTypes>(command: CommandIO<InputType, OutputType>, cb: (err: unknown, data?: Transform<OutputType, StreamingBlobPayloadOutputTypes | undefined, NarrowType>) => void): void;
    <InputType extends InputTypes, OutputType extends OutputTypes>(command: CommandIO<InputType, OutputType>, options: HttpHandlerOptions, cb: (err: unknown, data?: Transform<OutputType, StreamingBlobPayloadOutputTypes | undefined, NarrowType>) => void): void;
    <InputType extends InputTypes, OutputType extends OutputTypes>(command: CommandIO<InputType, OutputType>, options?: HttpHandlerOptions, cb?: (err: unknown, data?: Transform<OutputType, StreamingBlobPayloadOutputTypes | undefined, NarrowType>) => void): Promise<Transform<OutputType, StreamingBlobPayloadOutputTypes | undefined, NarrowType>> | void;
}
/**
 * @internal
 *
 * Narrowed version of InvokeMethod used in aggregated Client methods.
 */
export interface NarrowedInvokeMethod<NarrowType, HttpHandlerOptions, InputType extends object, OutputType extends MetadataBearer> {
    (input: InputType, options?: HttpHandlerOptions): Promise<Transform<OutputType, StreamingBlobPayloadOutputTypes | undefined, NarrowType>>;
    (input: InputType, cb: (err: unknown, data?: Transform<OutputType, StreamingBlobPayloadOutputTypes | undefined, NarrowType>) => void): void;
    (input: InputType, options: HttpHandlerOptions, cb: (err: unknown, data?: Transform<OutputType, StreamingBlobPayloadOutputTypes | undefined, NarrowType>) => void): void;
    (input: InputType, options?: HttpHandlerOptions, cb?: (err: unknown, data?: OutputType) => void): Promise<Transform<OutputType, StreamingBlobPayloadOutputTypes | undefined, NarrowType>> | void;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/transform/client-payload-blob-type-narrow.d.ts

```typescript
import type { IncomingMessage } from "http";
import type { ClientHttp2Stream } from "http2";
import type { InvokeMethod } from "../client";
import type { GetOutputType } from "../command";
import type { HttpHandlerOptions } from "../http";
import type { SdkStream } from "../serde";
import type { BrowserRuntimeStreamingBlobPayloadInputTypes, NodeJsRuntimeStreamingBlobPayloadInputTypes, StreamingBlobPayloadInputTypes } from "../streaming-payload/streaming-blob-payload-input-types";
import type { StreamingBlobPayloadOutputTypes } from "../streaming-payload/streaming-blob-payload-output-types";
import type { NarrowedInvokeMethod } from "./client-method-transforms";
import type { Transform } from "./type-transform";
/**
 * @public
 *
 * Creates a type with a given client type that narrows payload blob output
 * types to SdkStream<IncomingMessage>.
 *
 * This can be used for clients with the NodeHttpHandler requestHandler,
 * the default in Node.js when not using HTTP2.
 *
 * Usage example:
 * ```typescript
 * const client = new YourClient({}) as NodeJsClient<YourClient>;
 * ```
 */
export type NodeJsClient<ClientType extends object> = NarrowPayloadBlobTypes<NodeJsRuntimeStreamingBlobPayloadInputTypes, SdkStream<IncomingMessage>, ClientType>;
/**
 * @public
 * Variant of NodeJsClient for node:http2.
 */
export type NodeJsHttp2Client<ClientType extends object> = NarrowPayloadBlobTypes<NodeJsRuntimeStreamingBlobPayloadInputTypes, SdkStream<ClientHttp2Stream>, ClientType>;
/**
 * @public
 *
 * Creates a type with a given client type that narrows payload blob output
 * types to SdkStream<ReadableStream>.
 *
 * This can be used for clients with the FetchHttpHandler requestHandler,
 * which is the default in browser environments.
 *
 * Usage example:
 * ```typescript
 * const client = new YourClient({}) as BrowserClient<YourClient>;
 * ```
 */
export type BrowserClient<ClientType extends object> = NarrowPayloadBlobTypes<BrowserRuntimeStreamingBlobPayloadInputTypes, SdkStream<ReadableStream>, ClientType>;
/**
 * @public
 *
 * Variant of BrowserClient for XMLHttpRequest.
 */
export type BrowserXhrClient<ClientType extends object> = NarrowPayloadBlobTypes<BrowserRuntimeStreamingBlobPayloadInputTypes, SdkStream<ReadableStream | Blob>, ClientType>;
/**
 * @public
 *
 * @deprecated use NarrowPayloadBlobTypes<I, O, ClientType>.
 *
 * Narrow a given Client's blob payload outputs to the given type T.
 */
export type NarrowPayloadBlobOutputType<T, ClientType extends object> = {
    [key in keyof ClientType]: [ClientType[key]] extends [
        InvokeMethod<infer FunctionInputTypes, infer FunctionOutputTypes>
    ] ? NarrowedInvokeMethod<T, HttpHandlerOptions, FunctionInputTypes, FunctionOutputTypes> : ClientType[key];
} & {
    send<Command>(command: Command, options?: any): Promise<Transform<GetOutputType<Command>, StreamingBlobPayloadOutputTypes | undefined, T>>;
};
/**
 * @public
 *
 * Narrow a Client's blob payload input and output types to I and O.
 */
export type NarrowPayloadBlobTypes<I, O, ClientType extends object> = {
    [key in keyof ClientType]: [ClientType[key]] extends [
        InvokeMethod<infer FunctionInputTypes, infer FunctionOutputTypes>
    ] ? NarrowedInvokeMethod<O, HttpHandlerOptions, Transform<FunctionInputTypes, StreamingBlobPayloadInputTypes | undefined, I>, FunctionOutputTypes> : ClientType[key];
} & {
    send<Command>(command: Command, options?: any): Promise<Transform<GetOutputType<Command>, StreamingBlobPayloadOutputTypes | undefined, O>>;
};

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/transform/exact.d.ts

```typescript
/**
 * @internal
 *
 * Checks that A and B extend each other.
 */
export type Exact<A, B> = [A] extends [B] ? ([B] extends [A] ? true : false) : false;

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/transform/mutable.d.ts

```typescript
/**
 * @internal
 */
export type Mutable<Type> = {
    -readonly [Property in keyof Type]: Type[Property];
};

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/transform/no-undefined.d.ts

```typescript
import type { InvokeMethod, InvokeMethodOptionalArgs } from "../client";
import type { GetOutputType } from "../command";
import type { DocumentType } from "../shapes";
/**
 * @public
 *
 * This type is intended as a type helper for generated clients.
 * When initializing client, cast it to this type by passing
 * the client constructor type as the type parameter.
 *
 * It will then recursively remove "undefined" as a union type from all
 * input and output shapes' members. Note, this does not affect
 * any member that is optional (?) such as outputs with no required members.
 *
 * @example
 * ```ts
 * const client = new Client({}) as AssertiveClient<Client>;
 * ```
 */
export type AssertiveClient<Client extends object> = NarrowClientIOTypes<Client>;
/**
 * @public
 *
 * This is similar to AssertiveClient but additionally changes all
 * output types to (recursive) Required<T> so as to bypass all output nullability guards.
 */
export type UncheckedClient<Client extends object> = UncheckedClientOutputTypes<Client>;
/**
 * @internal
 *
 * Excludes undefined recursively.
 */
export type NoUndefined<T> = T extends Function ? T : T extends DocumentType ? T : [T] extends [object] ? {
    [key in keyof T]: NoUndefined<T[key]>;
} : Exclude<T, undefined>;
/**
 * @internal
 *
 * Excludes undefined and optional recursively.
 */
export type RecursiveRequired<T> = T extends Function ? T : T extends DocumentType ? T : [T] extends [object] ? {
    [key in keyof T]-?: RecursiveRequired<T[key]>;
} : Exclude<T, undefined>;
/**
 * @internal
 *
 * Removes undefined from unions.
 */
type NarrowClientIOTypes<ClientType extends object> = {
    [key in keyof ClientType]: [ClientType[key]] extends [
        InvokeMethodOptionalArgs<infer FunctionInputTypes, infer FunctionOutputTypes>
    ] ? InvokeMethodOptionalArgs<NoUndefined<FunctionInputTypes>, NoUndefined<FunctionOutputTypes>> : [ClientType[key]] extends [InvokeMethod<infer FunctionInputTypes, infer FunctionOutputTypes>] ? InvokeMethod<NoUndefined<FunctionInputTypes>, NoUndefined<FunctionOutputTypes>> : ClientType[key];
} & {
    send<Command>(command: Command, options?: any): Promise<NoUndefined<GetOutputType<Command>>>;
};
/**
 * @internal
 *
 * Removes undefined from unions and adds yolo output types.
 */
type UncheckedClientOutputTypes<ClientType extends object> = {
    [key in keyof ClientType]: [ClientType[key]] extends [
        InvokeMethodOptionalArgs<infer FunctionInputTypes, infer FunctionOutputTypes>
    ] ? InvokeMethodOptionalArgs<NoUndefined<FunctionInputTypes>, RecursiveRequired<FunctionOutputTypes>> : [ClientType[key]] extends [InvokeMethod<infer FunctionInputTypes, infer FunctionOutputTypes>] ? InvokeMethod<NoUndefined<FunctionInputTypes>, RecursiveRequired<FunctionOutputTypes>> : ClientType[key];
} & {
    send<Command>(command: Command, options?: any): Promise<RecursiveRequired<NoUndefined<GetOutputType<Command>>>>;
};
export {};

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/transform/type-transform.d.ts

```typescript
/**
 * @public
 *
 * Transforms any members of the object T having type FromType
 * to ToType. This applies only to exact type matches.
 *
 * This is for the case where FromType is a union and only those fields
 * matching the same union should be transformed.
 */
export type Transform<T, FromType, ToType> = ConditionalRecursiveTransformExact<T, FromType, ToType>;
/**
 * @internal
 *
 * Returns ToType if T matches exactly with FromType.
 */
type TransformExact<T, FromType, ToType> = [T] extends [FromType] ? ([FromType] extends [T] ? ToType : T) : T;
/**
 * @internal
 *
 * Applies TransformExact to members of an object recursively.
 */
type RecursiveTransformExact<T, FromType, ToType> = T extends Function ? T : T extends object ? {
    [key in keyof T]: [T[key]] extends [FromType] ? [FromType] extends [T[key]] ? ToType : ConditionalRecursiveTransformExact<T[key], FromType, ToType> : ConditionalRecursiveTransformExact<T[key], FromType, ToType>;
} : TransformExact<T, FromType, ToType>;
/**
 * @internal
 *
 * Same as RecursiveTransformExact but does not assign to an object
 * unless there is a matching transformed member.
 */
type ConditionalRecursiveTransformExact<T, FromType, ToType> = [T] extends [
    RecursiveTransformExact<T, FromType, ToType>
] ? [RecursiveTransformExact<T, FromType, ToType>] extends [T] ? T : RecursiveTransformExact<T, FromType, ToType> : RecursiveTransformExact<T, FromType, ToType>;
export {};

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/abort-handler.d.ts

```typescript
import { AbortSignal as DeprecatedAbortSignal } from "./abort";
/**
 * @public
 */
export interface AbortHandler {
    (this: AbortSignal | DeprecatedAbortSignal, ev: any): any;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/abort.d.ts

```typescript
import { AbortHandler } from "./abort-handler";
/**
 * @public
 */
export { AbortHandler };
/**
 * @public
 * @deprecated use platform (global) type for AbortSignal.
 *
 * Holders of an AbortSignal object may query if the associated operation has
 * been aborted and register an onabort handler.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal
 */
export interface AbortSignal {
    /**
     * Whether the action represented by this signal has been cancelled.
     */
    readonly aborted: boolean;
    /**
     * A function to be invoked when the action represented by this signal has
     * been cancelled.
     */
    onabort: AbortHandler | Function | null;
}
/**
 * @public
 * @deprecated use platform (global) type for AbortController.
 *
 * The AWS SDK uses a Controller/Signal model to allow for cooperative
 * cancellation of asynchronous operations. When initiating such an operation,
 * the caller can create an AbortController and then provide linked signal to
 * subtasks. This allows a single source to communicate to multiple consumers
 * that an action has been aborted without dictating how that cancellation
 * should be handled.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/AbortController
 */
export interface AbortController {
    /**
     * An object that reports whether the action associated with this
     * `AbortController` has been cancelled.
     */
    readonly signal: AbortSignal;
    /**
     * Declares the operation associated with this AbortController to have been
     * cancelled.
     */
    abort(): void;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/auth/HttpApiKeyAuth.d.ts

```typescript
/**
 * @internal
 */
export declare enum HttpApiKeyAuthLocation {
    HEADER = "header",
    QUERY = "query"
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/auth/HttpAuthScheme.d.ts

```typescript
import { Identity, IdentityProvider } from "../identity/identity";
import { HandlerExecutionContext } from "../middleware";
import { HttpSigner } from "./HttpSigner";
import { IdentityProviderConfig } from "./IdentityProviderConfig";
/**
 * ID for {@link HttpAuthScheme}
 * @internal
 */
export type HttpAuthSchemeId = string;
/**
 * Interface that defines an HttpAuthScheme
 * @internal
 */
export interface HttpAuthScheme {
    /**
     * ID for an HttpAuthScheme, typically the absolute shape ID of a Smithy auth trait.
     */
    schemeId: HttpAuthSchemeId;
    /**
     * Gets the IdentityProvider corresponding to an HttpAuthScheme.
     */
    identityProvider(config: IdentityProviderConfig): IdentityProvider<Identity> | undefined;
    /**
     * HttpSigner corresponding to an HttpAuthScheme.
     */
    signer: HttpSigner;
}
/**
 * Interface that defines the identity and signing properties when selecting
 * an HttpAuthScheme.
 * @internal
 */
export interface HttpAuthOption {
    schemeId: HttpAuthSchemeId;
    identityProperties?: Record<string, unknown>;
    signingProperties?: Record<string, unknown>;
    propertiesExtractor?: <TConfig extends object, TContext extends HandlerExecutionContext>(config: TConfig, context: TContext) => {
        identityProperties?: Record<string, unknown>;
        signingProperties?: Record<string, unknown>;
    };
}
/**
 * @internal
 */
export interface SelectedHttpAuthScheme {
    httpAuthOption: HttpAuthOption;
    identity: Identity;
    signer: HttpSigner;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/auth/HttpAuthSchemeProvider.d.ts

```typescript
import { HandlerExecutionContext } from "../middleware";
import { HttpAuthOption } from "./HttpAuthScheme";
/**
 * @internal
 */
export interface HttpAuthSchemeParameters {
    operation?: string;
}
/**
 * @internal
 */
export interface HttpAuthSchemeProvider<TParameters extends HttpAuthSchemeParameters> {
    (authParameters: TParameters): HttpAuthOption[];
}
/**
 * @internal
 */
export interface HttpAuthSchemeParametersProvider<TConfig extends object, TContext extends HandlerExecutionContext, TParameters extends HttpAuthSchemeParameters, TInput extends object> {
    (config: TConfig, context: TContext, input: TInput): Promise<TParameters>;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/auth/HttpSigner.d.ts

```typescript
import { HttpRequest, HttpResponse } from "../http";
import { Identity } from "../identity/identity";
/**
 * @internal
 */
export interface ErrorHandler {
    (signingProperties: Record<string, unknown>): <E extends Error>(error: E) => never;
}
/**
 * @internal
 */
export interface SuccessHandler {
    (httpResponse: HttpResponse | unknown, signingProperties: Record<string, unknown>): void;
}
/**
 * Interface to sign identity and signing properties.
 * @internal
 */
export interface HttpSigner {
    /**
     * Signs an HttpRequest with an identity and signing properties.
     * @param httpRequest request to sign
     * @param identity identity to sing the request with
     * @param signingProperties property bag for signing
     * @returns signed request in a promise
     */
    sign(httpRequest: HttpRequest, identity: Identity, signingProperties: Record<string, unknown>): Promise<HttpRequest>;
    /**
     * Handler that executes after the {@link HttpSigner.sign} invocation and corresponding
     * middleware throws an error.
     * The error handler is expected to throw the error it receives, so the return type of the error handler is `never`.
     * @internal
     */
    errorHandler?: ErrorHandler;
    /**
     * Handler that executes after the {@link HttpSigner.sign} invocation and corresponding
     * middleware succeeds.
     * @internal
     */
    successHandler?: SuccessHandler;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/auth/IdentityProviderConfig.d.ts

```typescript
import { Identity, IdentityProvider } from "../identity/identity";
import { HttpAuthSchemeId } from "./HttpAuthScheme";
/**
 * Interface to get an IdentityProvider for a specified HttpAuthScheme
 * @internal
 */
export interface IdentityProviderConfig {
    /**
     * Get the IdentityProvider for a specified HttpAuthScheme.
     * @param schemeId schemeId of the HttpAuthScheme
     * @returns IdentityProvider or undefined if HttpAuthScheme is not found
     */
    getIdentityProvider(schemeId: HttpAuthSchemeId): IdentityProvider<Identity> | undefined;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/auth/auth.d.ts

```typescript
/**
 * @internal
 *
 * Authentication schemes represent a way that the service will authenticate the customers identity.
 */
export interface AuthScheme {
    /**
     * @example "sigv4a" or "sigv4"
     */
    name: "sigv4" | "sigv4a" | string;
    /**
     * @example "s3"
     */
    signingName: string;
    /**
     * @example "us-east-1"
     */
    signingRegion: string;
    /**
     * @example ["*"]
     * @example ["us-west-2", "us-east-1"]
     */
    signingRegionSet?: string[];
    /**
     * @deprecated this field was renamed to signingRegion.
     */
    signingScope?: never;
    properties: Record<string, unknown>;
}
/**
 * @internal
 * @deprecated
 */
export interface HttpAuthDefinition {
    /**
     * Defines the location of where the Auth is serialized.
     */
    in: HttpAuthLocation;
    /**
     * Defines the name of the HTTP header or query string parameter
     * that contains the Auth.
     */
    name: string;
    /**
     * Defines the security scheme to use on the `Authorization` header value.
     * This can only be set if the "in" property is set to {@link HttpAuthLocation.HEADER}.
     */
    scheme?: string;
}
/**
 * @internal
 * @deprecated
 */
export declare enum HttpAuthLocation {
    HEADER = "header",
    QUERY = "query"
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/auth/index.d.ts

```typescript
export * from "./auth";
export * from "./HttpApiKeyAuth";
export * from "./HttpAuthScheme";
export * from "./HttpAuthSchemeProvider";
export * from "./HttpSigner";
export * from "./IdentityProviderConfig";

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/blob/blob-payload-input-types.d.ts

```typescript
import { Readable } from "stream";
import { BlobOptionalType, ReadableStreamOptionalType } from "../externals-check/browser-externals-check";
/**
 * @public
 *
 * A union of types that can be used as inputs for the service model
 * "blob" type when it represents the request's entire payload or body.
 *
 * For example, in Lambda::invoke, the payload is modeled as a blob type
 * and this union applies to it.
 * In contrast, in Lambda::createFunction the Zip file option is a blob type,
 * but is not the (entire) payload and this union does not apply.
 *
 * Note: not all types are signable by the standard SignatureV4 signer when
 * used as the request body. For example, in Node.js a Readable stream
 * is not signable by the default signer.
 * They are included in the union because it may work in some cases,
 * but the expected types are primarily string and Uint8Array.
 *
 * Additional details may be found in the internal
 * function "getPayloadHash" in the SignatureV4 module.
 */
export type BlobPayloadInputTypes = string | ArrayBuffer | ArrayBufferView | Uint8Array | NodeJsRuntimeBlobTypes | BrowserRuntimeBlobTypes;
/**
 * @public
 *
 * Additional blob types for the Node.js environment.
 */
export type NodeJsRuntimeBlobTypes = Readable | Buffer;
/**
 * @public
 *
 * Additional blob types for the browser environment.
 */
export type BrowserRuntimeBlobTypes = BlobOptionalType | ReadableStreamOptionalType;
/**
 * @internal
 * @deprecated renamed to BlobPayloadInputTypes.
 */
export type BlobTypes = BlobPayloadInputTypes;

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/checksum.d.ts

```typescript
import { SourceData } from "./crypto";
/**
 * @public
 *
 * An object that provides a checksum of data provided in chunks to `update`.
 * The checksum may be performed incrementally as chunks are received or all
 * at once when the checksum is finalized, depending on the underlying
 * implementation.
 *
 * It's recommended to compute checksum incrementally to avoid reading the
 * entire payload in memory.
 *
 * A class that implements this interface may accept an optional secret key in its
 * constructor while computing checksum value, when using HMAC. If provided,
 * this secret key would be used when computing checksum.
 */
export interface Checksum {
    /**
     * Constant length of the digest created by the algorithm in bytes.
     */
    digestLength?: number;
    /**
     * Creates a new checksum object that contains a deep copy of the internal
     * state of the current `Checksum` object.
     */
    copy?(): Checksum;
    /**
     * Returns the digest of all of the data passed.
     */
    digest(): Promise<Uint8Array>;
    /**
     * Allows marking a checksum for checksums that support the ability
     * to mark and reset.
     *
     * @param readLimit - The maximum limit of bytes that can be read
     *   before the mark position becomes invalid.
     */
    mark?(readLimit: number): void;
    /**
     * Resets the checksum to its initial value.
     */
    reset(): void;
    /**
     * Adds a chunk of data for which checksum needs to be computed.
     * This can be called many times with new data as it is streamed.
     *
     * Implementations may override this method which passes second param
     * which makes Checksum object stateless.
     *
     * @param chunk - The buffer to update checksum with.
     */
    update(chunk: Uint8Array): void;
}
/**
 * @public
 *
 * A constructor for a Checksum that may be used to calculate an HMAC. Implementing
 * classes should not directly hold the provided key in memory beyond the
 * lexical scope of the constructor.
 */
export interface ChecksumConstructor {
    new (secret?: SourceData): Checksum;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/client.d.ts

```typescript
import { Command } from "./command";
import { MiddlewareStack } from "./middleware";
import { MetadataBearer } from "./response";
import { OptionalParameter } from "./util";
/**
 * @public
 *
 * A type which checks if the client configuration is optional.
 * If all entries of the client configuration are optional, it allows client creation without passing any config.
 */
export type CheckOptionalClientConfig<T> = OptionalParameter<T>;
/**
 * @public
 *
 * function definition for different overrides of client's 'send' function.
 */
export interface InvokeFunction<InputTypes extends object, OutputTypes extends MetadataBearer, ResolvedClientConfiguration> {
    <InputType extends InputTypes, OutputType extends OutputTypes>(command: Command<InputTypes, InputType, OutputTypes, OutputType, ResolvedClientConfiguration>, options?: any): Promise<OutputType>;
    <InputType extends InputTypes, OutputType extends OutputTypes>(command: Command<InputTypes, InputType, OutputTypes, OutputType, ResolvedClientConfiguration>, cb: (err: any, data?: OutputType) => void): void;
    <InputType extends InputTypes, OutputType extends OutputTypes>(command: Command<InputTypes, InputType, OutputTypes, OutputType, ResolvedClientConfiguration>, options: any, cb: (err: any, data?: OutputType) => void): void;
    <InputType extends InputTypes, OutputType extends OutputTypes>(command: Command<InputTypes, InputType, OutputTypes, OutputType, ResolvedClientConfiguration>, options?: any, cb?: (err: any, data?: OutputType) => void): Promise<OutputType> | void;
}
/**
 * @public
 *
 * Signature that appears on aggregated clients' methods.
 */
export interface InvokeMethod<InputType extends object, OutputType extends MetadataBearer> {
    (input: InputType, options?: any): Promise<OutputType>;
    (input: InputType, cb: (err: any, data?: OutputType) => void): void;
    (input: InputType, options: any, cb: (err: any, data?: OutputType) => void): void;
    (input: InputType, options?: any, cb?: (err: any, data?: OutputType) => void): Promise<OutputType> | void;
}
/**
 * @public
 *
 * Signature that appears on aggregated clients' methods when argument is optional.
 */
export interface InvokeMethodOptionalArgs<InputType extends object, OutputType extends MetadataBearer> {
    (): Promise<OutputType>;
    (input: InputType, options?: any): Promise<OutputType>;
    (input: InputType, cb: (err: any, data?: OutputType) => void): void;
    (input: InputType, options: any, cb: (err: any, data?: OutputType) => void): void;
    (input: InputType, options?: any, cb?: (err: any, data?: OutputType) => void): Promise<OutputType> | void;
}
/**
 * A general interface for service clients, idempotent to browser or node clients
 * This type corresponds to SmithyClient(https://github.com/aws/aws-sdk-js-v3/blob/main/packages/smithy-client/src/client.ts).
 * It's provided for using without importing the SmithyClient class.
 * @internal
 */
export interface Client<Input extends object, Output extends MetadataBearer, ResolvedClientConfiguration> {
    readonly config: ResolvedClientConfiguration;
    middlewareStack: MiddlewareStack<Input, Output>;
    send: InvokeFunction<Input, Output, ResolvedClientConfiguration>;
    destroy: () => void;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/command.d.ts

```typescript
import { Handler, MiddlewareStack } from "./middleware";
import { MetadataBearer } from "./response";
/**
 * @public
 */
export interface Command<ClientInput extends object, InputType extends ClientInput, ClientOutput extends MetadataBearer, OutputType extends ClientOutput, ResolvedConfiguration> extends CommandIO<InputType, OutputType> {
    readonly input: InputType;
    readonly middlewareStack: MiddlewareStack<InputType, OutputType>;
    /**
     * This should be OperationSchema from @smithy/types, but would
     * create problems with the client transform type adaptors.
     */
    readonly schema?: any;
    resolveMiddleware(stack: MiddlewareStack<ClientInput, ClientOutput>, configuration: ResolvedConfiguration, options: any): Handler<InputType, OutputType>;
}
/**
 * @internal
 *
 * This is a subset of the Command type used only to detect the i/o types.
 */
export interface CommandIO<InputType extends object, OutputType extends MetadataBearer> {
    readonly input: InputType;
    resolveMiddleware(stack: any, configuration: any, options: any): Handler<InputType, OutputType>;
}
/**
 * @internal
 */
export type GetOutputType<Command> = Command extends CommandIO<any, infer O> ? O : never;

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/connection/config.d.ts

```typescript
/**
 * @public
 */
export interface ConnectConfiguration {
    /**
     * The maximum time in milliseconds that the connection phase of a request
     * may take before the connection attempt is abandoned.
     */
    requestTimeout?: number;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/connection/index.d.ts

```typescript
export * from "./config";
export * from "./manager";
export * from "./pool";

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/connection/manager.d.ts

```typescript
import { RequestContext } from "../transfer";
import { ConnectConfiguration } from "./config";
/**
 * @public
 */
export interface ConnectionManagerConfiguration {
    /**
     * Maximum number of allowed concurrent requests per connection.
     */
    maxConcurrency?: number;
    /**
     * Disables concurrent requests per connection.
     */
    disableConcurrency?: boolean;
}
/**
 * @public
 */
export interface ConnectionManager<T> {
    /**
     * Retrieves a connection from the connection pool if available,
     * otherwise establish a new connection
     */
    lease(requestContext: RequestContext, connectionConfiguration: ConnectConfiguration): T;
    /**
     * Releases the connection back to the pool making it potentially
     * re-usable by other requests.
     */
    release(requestContext: RequestContext, connection: T): void;
    /**
     * Destroys the connection manager. All connections will be closed.
     */
    destroy(): void;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/connection/pool.d.ts

```typescript
/**
 * @public
 */
export interface ConnectionPool<T> {
    /**
     * Retrieve the first connection in the pool
     */
    poll(): T | void;
    /**
     * Release the connection back to the pool making it potentially
     * re-usable by other requests.
     */
    offerLast(connection: T): void;
    /**
     * Removes the connection from the pool, and destroys it.
     */
    destroy(connection: T): void;
    /**
     * Implements the iterable protocol and allows arrays to be consumed
     * by most syntaxes expecting iterables, such as the spread syntax
     * and for...of loops
     */
    [Symbol.iterator](): Iterator<T>;
}
/**
 * Unused.
 * @internal
 * @deprecated
 */
export interface CacheKey {
    destination: string;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/crypto.d.ts

```typescript
/**
 * @public
 */
export type SourceData = string | ArrayBuffer | ArrayBufferView;
/**
 * @public
 *
 * An object that provides a hash of data provided in chunks to `update`. The
 * hash may be performed incrementally as chunks are received or all at once
 * when the hash is finalized, depending on the underlying implementation.
 *
 * @deprecated use {@link Checksum}
 */
export interface Hash {
    /**
     * Adds a chunk of data to the hash. If a buffer is provided, the `encoding`
     * argument will be ignored. If a string is provided without a specified
     * encoding, implementations must assume UTF-8 encoding.
     *
     * Not all encodings are supported on all platforms, though all must support
     * UTF-8.
     */
    update(toHash: SourceData, encoding?: "utf8" | "ascii" | "latin1"): void;
    /**
     * Finalizes the hash and provides a promise that will be fulfilled with the
     * raw bytes of the calculated hash.
     */
    digest(): Promise<Uint8Array>;
}
/**
 * @public
 *
 * A constructor for a hash that may be used to calculate an HMAC. Implementing
 * classes should not directly hold the provided key in memory beyond the
 * lexical scope of the constructor.
 *
 * @deprecated use {@link ChecksumConstructor}
 */
export interface HashConstructor {
    new (secret?: SourceData): Hash;
}
/**
 * @public
 *
 * A function that calculates the hash of a data stream. Determining the hash
 * will consume the stream, so only replayable streams should be provided to an
 * implementation of this interface.
 */
export interface StreamHasher<StreamType = any> {
    (hashCtor: HashConstructor, stream: StreamType): Promise<Uint8Array>;
}
/**
 * @public
 *
 * A function that returns a promise fulfilled with bytes from a
 * cryptographically secure pseudorandom number generator.
 */
export interface randomValues {
    (byteLength: number): Promise<Uint8Array>;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/downlevel-ts3.4/transform/type-transform.d.ts

```typescript
/**
 * @public
 *
 * Transforms any members of the object T having type FromType
 * to ToType. This applies only to exact type matches.
 *
 * This is for the case where FromType is a union and only those fields
 * matching the same union should be transformed.
 */
export type Transform<T, FromType, ToType> = RecursiveTransformExact<T, FromType, ToType>;
/**
 * @internal
 *
 * Returns ToType if T matches exactly with FromType.
 */
type TransformExact<T, FromType, ToType> = [
    T
] extends [
    FromType
] ? ([
    FromType
] extends [
    T
] ? ToType : T) : T;
/**
 * @internal
 *
 * Applies TransformExact to members of an object recursively.
 */
type RecursiveTransformExact<T, FromType, ToType> = T extends Function ? T : T extends object ? {
    [key in keyof T]: [
        T[key]
    ] extends [
        FromType
    ] ? [
        FromType
    ] extends [
        T[key]
    ] ? ToType : RecursiveTransformExact<T[key], FromType, ToType> : RecursiveTransformExact<T[key], FromType, ToType>;
} : TransformExact<T, FromType, ToType>;
export {};

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/encode.d.ts

```typescript
import { Message } from "./eventStream";
/**
 * @public
 */
export interface MessageEncoder {
    encode(message: Message): Uint8Array;
}
/**
 * @public
 */
export interface MessageDecoder {
    decode(message: ArrayBufferView): Message;
    feed(message: ArrayBufferView): void;
    endOfStream(): void;
    getMessage(): AvailableMessage;
    getAvailableMessages(): AvailableMessages;
}
/**
 * @public
 */
export interface AvailableMessage {
    getMessage(): Message | undefined;
    isEndOfStream(): boolean;
}
/**
 * @public
 */
export interface AvailableMessages {
    getMessages(): Message[];
    isEndOfStream(): boolean;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/endpoint.d.ts

```typescript
import { AuthScheme } from "./auth/auth";
/**
 * @public
 */
export interface EndpointPartition {
    name: string;
    dnsSuffix: string;
    dualStackDnsSuffix: string;
    supportsFIPS: boolean;
    supportsDualStack: boolean;
}
/**
 * @public
 */
export interface EndpointARN {
    partition: string;
    service: string;
    region: string;
    accountId: string;
    resourceId: Array<string>;
}
/**
 * @public
 */
export declare enum EndpointURLScheme {
    HTTP = "http",
    HTTPS = "https"
}
/**
 * @public
 */
export interface EndpointURL {
    /**
     * The URL scheme such as http or https.
     */
    scheme: EndpointURLScheme;
    /**
     * The authority is the host and optional port component of the URL.
     */
    authority: string;
    /**
     * The parsed path segment of the URL.
     * This value is as-is as provided by the user.
     */
    path: string;
    /**
     * The parsed path segment of the URL.
     * This value is guranteed to start and end with a "/".
     */
    normalizedPath: string;
    /**
     * A boolean indicating whether the authority is an IP address.
     */
    isIp: boolean;
}
/**
 * @public
 */
export type EndpointObjectProperty = string | boolean | {
    [key: string]: EndpointObjectProperty;
} | EndpointObjectProperty[];
/**
 * @public
 */
export interface EndpointV2 {
    url: URL;
    properties?: {
        authSchemes?: AuthScheme[];
    } & Record<string, EndpointObjectProperty>;
    headers?: Record<string, string[]>;
}
/**
 * @public
 */
export type EndpointParameters = {
    [name: string]: undefined | boolean | string | string[];
};

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/endpoints/EndpointRuleObject.d.ts

```typescript
import { EndpointObjectProperty } from "../endpoint";
import { ConditionObject, Expression } from "./shared";
/**
 * @public
 */
export type EndpointObjectProperties = Record<string, EndpointObjectProperty>;
/**
 * @public
 */
export type EndpointObjectHeaders = Record<string, Expression[]>;
/**
 * @public
 */
export type EndpointObject = {
    url: Expression;
    properties?: EndpointObjectProperties;
    headers?: EndpointObjectHeaders;
};
/**
 * @public
 */
export type EndpointRuleObject = {
    type: "endpoint";
    conditions?: ConditionObject[];
    endpoint: EndpointObject;
    documentation?: string;
};

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/endpoints/ErrorRuleObject.d.ts

```typescript
import { ConditionObject, Expression } from "./shared";
/**
 * @public
 */
export type ErrorRuleObject = {
    type: "error";
    conditions?: ConditionObject[];
    error: Expression;
    documentation?: string;
};

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/endpoints/RuleSetObject.d.ts

```typescript
import { RuleSetRules } from "./TreeRuleObject";
/**
 * @public
 */
export type DeprecatedObject = {
    message?: string;
    since?: string;
};
/**
 * @public
 */
export type ParameterObject = {
    type: "String" | "string" | "Boolean" | "boolean";
    default?: string | boolean;
    required?: boolean;
    documentation?: string;
    builtIn?: string;
    deprecated?: DeprecatedObject;
};
/**
 * @public
 */
export type RuleSetObject = {
    version: string;
    serviceId?: string;
    parameters: Record<string, ParameterObject>;
    rules: RuleSetRules;
};

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/endpoints/TreeRuleObject.d.ts

```typescript
import { EndpointRuleObject } from "./EndpointRuleObject";
import { ErrorRuleObject } from "./ErrorRuleObject";
import { ConditionObject } from "./shared";
/**
 * @public
 */
export type RuleSetRules = Array<EndpointRuleObject | ErrorRuleObject | TreeRuleObject>;
/**
 * @public
 */
export type TreeRuleObject = {
    type: "tree";
    conditions?: ConditionObject[];
    rules: RuleSetRules;
    documentation?: string;
};

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/endpoints/index.d.ts

```typescript
export * from "./EndpointRuleObject";
export * from "./ErrorRuleObject";
export * from "./RuleSetObject";
export * from "./shared";
export * from "./TreeRuleObject";

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/endpoints/shared.d.ts

```typescript
import { Logger } from "../logger";
/**
 * @public
 */
export type ReferenceObject = {
    ref: string;
};
/**
 * @public
 */
export type FunctionObject = {
    fn: string;
    argv: FunctionArgv;
};
/**
 * @public
 */
export type FunctionArgv = Array<Expression | boolean | number>;
/**
 * @public
 */
export type FunctionReturn = string | boolean | number | {
    [key: string]: FunctionReturn;
};
/**
 * @public
 */
export type ConditionObject = FunctionObject & {
    assign?: string;
};
/**
 * @public
 */
export type Expression = string | ReferenceObject | FunctionObject;
/**
 * @public
 */
export type EndpointParams = Record<string, string | boolean>;
/**
 * @public
 */
export type EndpointResolverOptions = {
    endpointParams: EndpointParams;
    logger?: Logger;
};
/**
 * @public
 */
export type ReferenceRecord = Record<string, FunctionReturn>;
/**
 * @public
 */
export type EvaluateOptions = EndpointResolverOptions & {
    referenceRecord: ReferenceRecord;
};

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/eventStream.d.ts

```typescript
import { HttpRequest } from "./http";
import { FinalizeHandler, FinalizeHandlerArguments, FinalizeHandlerOutput, HandlerExecutionContext } from "./middleware";
import { MetadataBearer } from "./response";
/**
 * @public
 *
 * An event stream message. The headers and body properties will always be
 * defined, with empty headers represented as an object with no keys and an
 * empty body represented as a zero-length Uint8Array.
 */
export interface Message {
    headers: MessageHeaders;
    body: Uint8Array;
}
/**
 * @public
 */
export type MessageHeaders = Record<string, MessageHeaderValue>;
/**
 * @public
 */
export type HeaderValue<K extends string, V> = {
    type: K;
    value: V;
};
/**
 * @public
 */
export type BooleanHeaderValue = HeaderValue<"boolean", boolean>;
/**
 * @public
 */
export type ByteHeaderValue = HeaderValue<"byte", number>;
/**
 * @public
 */
export type ShortHeaderValue = HeaderValue<"short", number>;
/**
 * @public
 */
export type IntegerHeaderValue = HeaderValue<"integer", number>;
/**
 * @public
 */
export type LongHeaderValue = HeaderValue<"long", Int64>;
/**
 * @public
 */
export type BinaryHeaderValue = HeaderValue<"binary", Uint8Array>;
/**
 * @public
 */
export type StringHeaderValue = HeaderValue<"string", string>;
/**
 * @public
 */
export type TimestampHeaderValue = HeaderValue<"timestamp", Date>;
/**
 * @public
 */
export type UuidHeaderValue = HeaderValue<"uuid", string>;
/**
 * @public
 */
export type MessageHeaderValue = BooleanHeaderValue | ByteHeaderValue | ShortHeaderValue | IntegerHeaderValue | LongHeaderValue | BinaryHeaderValue | StringHeaderValue | TimestampHeaderValue | UuidHeaderValue;
/**
 * @public
 */
export interface Int64 {
    readonly bytes: Uint8Array;
    valueOf: () => number;
    toString: () => string;
}
/**
 * @public
 *
 * Util functions for serializing or deserializing event stream
 */
export interface EventStreamSerdeContext {
    eventStreamMarshaller: EventStreamMarshaller;
}
/**
 * @public
 *
 * A function which deserializes binary event stream message into modeled shape.
 */
export interface EventStreamMarshallerDeserFn<StreamType> {
    <T>(body: StreamType, deserializer: (input: Record<string, Message>) => Promise<T>): AsyncIterable<T>;
}
/**
 * @public
 *
 * A function that serializes modeled shape into binary stream message.
 */
export interface EventStreamMarshallerSerFn<StreamType> {
    <T>(input: AsyncIterable<T>, serializer: (event: T) => Message): StreamType;
}
/**
 * @public
 *
 * An interface which provides functions for serializing and deserializing binary event stream
 * to/from corresponsing modeled shape.
 */
export interface EventStreamMarshaller<StreamType = any> {
    deserialize: EventStreamMarshallerDeserFn<StreamType>;
    serialize: EventStreamMarshallerSerFn<StreamType>;
}
/**
 * @public
 */
export interface EventStreamRequestSigner {
    sign(request: HttpRequest): Promise<HttpRequest>;
}
/**
 * @public
 */
export interface EventStreamPayloadHandler {
    handle: <Input extends object, Output extends MetadataBearer>(next: FinalizeHandler<Input, Output>, args: FinalizeHandlerArguments<Input>, context?: HandlerExecutionContext) => Promise<FinalizeHandlerOutput<Output>>;
}
/**
 * @public
 */
export interface EventStreamPayloadHandlerProvider {
    (options: any): EventStreamPayloadHandler;
}
/**
 * @public
 */
export interface EventStreamSerdeProvider {
    (options: any): EventStreamMarshaller;
}
/**
 * @public
 */
export interface EventStreamSignerProvider {
    (options: any): EventStreamRequestSigner;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/extensions/checksum.d.ts

```typescript
import { ChecksumConstructor } from "../checksum";
import { HashConstructor } from "../crypto";
/**
 * @internal
 */
export declare enum AlgorithmId {
    MD5 = "md5",
    CRC32 = "crc32",
    CRC32C = "crc32c",
    SHA1 = "sha1",
    SHA256 = "sha256"
}
/**
 * @internal
 */
export interface ChecksumAlgorithm {
    algorithmId(): AlgorithmId;
    checksumConstructor(): ChecksumConstructor | HashConstructor;
}
/**
 * @deprecated unused.
 * @internal
 */
type ChecksumConfigurationLegacy = {
    [other in string | number]: any;
};
/**
 * @internal
 */
export interface ChecksumConfiguration extends ChecksumConfigurationLegacy {
    addChecksumAlgorithm(algo: ChecksumAlgorithm): void;
    checksumAlgorithms(): ChecksumAlgorithm[];
}
/**
 * @deprecated will be removed for implicit type.
 * @internal
 */
type GetChecksumConfigurationType = (runtimeConfig: Partial<{
    sha256: ChecksumConstructor | HashConstructor;
    md5: ChecksumConstructor | HashConstructor;
}>) => ChecksumConfiguration;
/**
 * @internal
 * @deprecated will be moved to smithy-client.
 */
export declare const getChecksumConfiguration: GetChecksumConfigurationType;
/**
 * @internal
 * @deprecated will be removed for implicit type.
 */
type ResolveChecksumRuntimeConfigType = (clientConfig: ChecksumConfiguration) => any;
/**
 * @internal
 *
 * @deprecated will be moved to smithy-client.
 */
export declare const resolveChecksumRuntimeConfig: ResolveChecksumRuntimeConfigType;
export {};

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/extensions/defaultClientConfiguration.d.ts

```typescript
import { ChecksumConfiguration } from "./checksum";
/**
 * @deprecated will be replaced by DefaultExtensionConfiguration.
 * @internal
 *
 * Default client configuration consisting various configurations for modifying a service client
 */
export interface DefaultClientConfiguration extends ChecksumConfiguration {
}
/**
 * @deprecated will be removed for implicit type.
 */
type GetDefaultConfigurationType = (runtimeConfig: any) => DefaultClientConfiguration;
/**
 * @deprecated moving to @smithy/smithy-client.
 * @internal
 *
 * Helper function to resolve default client configuration from runtime config
 *
 */
export declare const getDefaultClientConfiguration: GetDefaultConfigurationType;
/**
 * @deprecated will be removed for implicit type.
 */
type ResolveDefaultRuntimeConfigType = (clientConfig: DefaultClientConfiguration) => any;
/**
 * @deprecated moving to @smithy/smithy-client.
 * @internal
 *
 * Helper function to resolve runtime config from default client configuration
 */
export declare const resolveDefaultRuntimeConfig: ResolveDefaultRuntimeConfigType;
export {};

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/extensions/defaultExtensionConfiguration.d.ts

```typescript
import { ChecksumConfiguration } from "./checksum";
import { RetryStrategyConfiguration } from "./retry";
/**
 * @internal
 *
 * Default extension configuration consisting various configurations for modifying a service client
 */
export interface DefaultExtensionConfiguration extends ChecksumConfiguration, RetryStrategyConfiguration {
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/extensions/index.d.ts

```typescript
export * from "./defaultClientConfiguration";
export * from "./defaultExtensionConfiguration";
export { AlgorithmId, ChecksumAlgorithm, ChecksumConfiguration } from "./checksum";
export { RetryStrategyConfiguration } from "./retry";

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/extensions/retry.d.ts

```typescript
import { RetryStrategyV2 } from "../retry";
import { Provider, RetryStrategy } from "../util";
/**
 * A configuration interface with methods called by runtime extension
 * @internal
 */
export interface RetryStrategyConfiguration {
    /**
     * Set retry strategy used for all http requests
     * @param retryStrategy
     */
    setRetryStrategy(retryStrategy: Provider<RetryStrategyV2 | RetryStrategy>): void;
    /**
     * Get retry strategy used for all http requests
     * @param retryStrategy
     */
    retryStrategy(): Provider<RetryStrategyV2 | RetryStrategy>;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/externals-check/browser-externals-check.d.ts

```typescript
import { Exact } from "../transform/exact";
/**
 * @public
 *
 * A checked type that resolves to Blob if it is defined as more than a stub, otherwise
 * resolves to 'never' so as not to widen the type of unions containing Blob
 * excessively.
 */
export type BlobOptionalType = BlobDefined extends true ? Blob : Unavailable;
/**
 * @public
 *
 * A checked type that resolves to ReadableStream if it is defined as more than a stub, otherwise
 * resolves to 'never' so as not to widen the type of unions containing ReadableStream
 * excessively.
 */
export type ReadableStreamOptionalType = ReadableStreamDefined extends true ? ReadableStream : Unavailable;
/**
 * @public
 *
 * Indicates a type is unavailable if it resolves to this.
 */
export type Unavailable = never;
/**
 * @internal
 *
 * Whether the global types define more than a stub for ReadableStream.
 */
export type ReadableStreamDefined = Exact<ReadableStream, {}> extends true ? false : true;
/**
 * @internal
 *
 * Whether the global types define more than a stub for Blob.
 */
export type BlobDefined = Exact<Blob, {}> extends true ? false : true;

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/feature-ids.d.ts

```typescript
/**
 * @internal
 */
export type SmithyFeatures = Partial<{
    RESOURCE_MODEL: "A";
    WAITER: "B";
    PAGINATOR: "C";
    RETRY_MODE_LEGACY: "D";
    RETRY_MODE_STANDARD: "E";
    RETRY_MODE_ADAPTIVE: "F";
    GZIP_REQUEST_COMPRESSION: "L";
    PROTOCOL_RPC_V2_CBOR: "M";
    ENDPOINT_OVERRIDE: "N";
    SIGV4A_SIGNING: "S";
    CREDENTIALS_CODE: "e";
}>;

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/http/httpHandlerInitialization.d.ts

```typescript
import { Agent as hAgent, AgentOptions as hAgentOptions } from "http";
import { Agent as hsAgent, AgentOptions as hsAgentOptions } from "https";
import { HttpRequest as IHttpRequest } from "../http";
import { Logger } from "../logger";
/**
 *
 * This type represents an alternate client constructor option for the entry
 * "requestHandler". Instead of providing an instance of a requestHandler, the user
 * may provide the requestHandler's constructor options for either the
 * NodeHttpHandler or FetchHttpHandler.
 *
 * For other RequestHandlers like HTTP2 or WebSocket,
 * constructor parameter passthrough is not currently available.
 *
 * @public
 */
export type RequestHandlerParams = NodeHttpHandlerOptions | FetchHttpHandlerOptions;
/**
 * Represents the http options that can be passed to a node http client.
 * @public
 */
export interface NodeHttpHandlerOptions {
    /**
     * The maximum time in milliseconds that the connection phase of a request
     * may take before the connection attempt is abandoned.
     * Defaults to 0, which disables the timeout.
     */
    connectionTimeout?: number;
    /**
     * The maximum number of milliseconds request & response should take.
     * Defaults to 0, which disables the timeout.
     *
     * If exceeded, a warning will be emitted unless throwOnRequestTimeout=true,
     * in which case a TimeoutError will be thrown.
     */
    requestTimeout?: number;
    /**
     * Because requestTimeout was for a long time incorrectly being set as a socket idle timeout,
     * users must also opt-in for request timeout thrown errors.
     * Without this setting, a breach of the request timeout will be logged as a warning.
     */
    throwOnRequestTimeout?: boolean;
    /**
     * The maximum time in milliseconds that a socket may remain idle before it
     * is closed. Defaults to 0, which means no maximum.
     *
     * This does not affect the server, which may still close the connection due to an idle socket.
     */
    socketTimeout?: number;
    /**
     * Delay before the NodeHttpHandler checks for socket exhaustion,
     * and emits a warning if the active sockets and enqueued request count is greater than
     * 2x the maxSockets count.
     *
     * Defaults to connectionTimeout + requestTimeout or 3000ms if those are not set.
     */
    socketAcquisitionWarningTimeout?: number;
    /**
     * You can pass http.Agent or its constructor options.
     */
    httpAgent?: hAgent | hAgentOptions;
    /**
     * You can pass https.Agent or its constructor options.
     */
    httpsAgent?: hsAgent | hsAgentOptions;
    /**
     * Optional logger.
     */
    logger?: Logger;
}
/**
 * Represents the http options that can be passed to a browser http client.
 * @public
 */
export interface FetchHttpHandlerOptions {
    /**
     * The number of milliseconds a request can take before being automatically
     * terminated.
     */
    requestTimeout?: number;
    /**
     * Whether to allow the request to outlive the page. Default value is false.
     *
     * There may be limitations to the payload size, number of concurrent requests,
     * request duration etc. when using keepalive in browsers.
     *
     * These may change over time, so look for up to date information about
     * these limitations before enabling keepalive.
     */
    keepAlive?: boolean;
    /**
     * A string indicating whether credentials will be sent with the request always, never, or
     * only when sent to a same-origin URL.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials
     */
    credentials?: "include" | "omit" | "same-origin" | undefined | string;
    /**
     * Cache settings for fetch.
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Request/cache
     */
    cache?: "default" | "force-cache" | "no-cache" | "no-store" | "only-if-cached" | "reload";
    /**
     * An optional function that produces additional RequestInit
     * parameters for each httpRequest.
     *
     * This is applied last via merging with Object.assign() and overwrites other values
     * set from other sources.
     *
     * @example
     * ```js
     * new Client({
     *   requestHandler: {
     *     requestInit(httpRequest) {
     *       return { cache: "no-store" };
     *     }
     *   }
     * });
     * ```
     */
    requestInit?: (httpRequest: IHttpRequest) => RequestInit;
}
declare global {
    /**
     * interface merging stub.
     */
    interface RequestInit {
    }
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/http.d.ts

```typescript
import { AbortSignal as DeprecatedAbortSignal } from "./abort";
import { URI } from "./uri";
/**
 * @public
 *
 * @deprecated use {@link EndpointV2} from `@smithy/types`.
 */
export interface Endpoint {
    protocol: string;
    hostname: string;
    port?: number;
    path: string;
    query?: QueryParameterBag;
}
/**
 * @public
 *
 * Interface an HTTP request class. Contains
 * addressing information in addition to standard message properties.
 */
export interface HttpRequest extends HttpMessage, URI {
    method: string;
}
/**
 * @public
 *
 * Represents an HTTP message as received in reply to a request. Contains a
 * numeric status code in addition to standard message properties.
 */
export interface HttpResponse extends HttpMessage {
    statusCode: number;
    reason?: string;
}
/**
 * @public
 *
 * Represents an HTTP message with headers and an optional static or streaming
 * body. body: ArrayBuffer | ArrayBufferView | string | Uint8Array | Readable | ReadableStream;
 */
export interface HttpMessage {
    headers: HeaderBag;
    body?: any;
}
/**
 * @public
 *
 * A mapping of query parameter names to strings or arrays of strings, with the
 * second being used when a parameter contains a list of values. Value can be set
 * to null when query is not in key-value pairs shape
 */
export type QueryParameterBag = Record<string, string | Array<string> | null>;
/**
 * @public
 */
export type FieldOptions = {
    name: string;
    kind?: FieldPosition;
    values?: string[];
};
/**
 * @public
 */
export declare enum FieldPosition {
    HEADER = 0,
    TRAILER = 1
}
/**
 * @public
 *
 * A mapping of header names to string values. Multiple values for the same
 * header should be represented as a single string with values separated by
 * `, `.
 *
 * Keys should be considered case insensitive, even if this is not enforced by a
 * particular implementation. For example, given the following HeaderBag, where
 * keys differ only in case:
 *
 * ```json
 *    {
 *        'x-request-date': '2000-01-01T00:00:00Z',
 *        'X-Request-Date': '2001-01-01T00:00:00Z'
 *    }
 * ```
 *
 * The SDK may at any point during processing remove one of the object
 * properties in favor of the other. The headers may or may not be combined, and
 * the SDK will not deterministically select which header candidate to use.
 */
export type HeaderBag = Record<string, string>;
/**
 * @public
 *
 * Represents an HTTP message with headers and an optional static or streaming
 * body. bode: ArrayBuffer | ArrayBufferView | string | Uint8Array | Readable | ReadableStream;
 */
export interface HttpMessage {
    headers: HeaderBag;
    body?: any;
}
/**
 * @public
 *
 * Represents the options that may be passed to an Http Handler.
 */
export interface HttpHandlerOptions {
    abortSignal?: AbortSignal | DeprecatedAbortSignal;
    /**
     * The maximum time in milliseconds that the connection phase of a request
     * may take before the connection attempt is abandoned.
     */
    requestTimeout?: number;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/identity/apiKeyIdentity.d.ts

```typescript
import { Identity, IdentityProvider } from "../identity/identity";
/**
 * @public
 */
export interface ApiKeyIdentity extends Identity {
    /**
     * The literal API Key
     */
    readonly apiKey: string;
}
/**
 * @public
 */
export type ApiKeyIdentityProvider = IdentityProvider<ApiKeyIdentity>;

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/identity/awsCredentialIdentity.d.ts

```typescript
import { Identity, IdentityProvider } from "./identity";
/**
 * @public
 */
export interface AwsCredentialIdentity extends Identity {
    /**
     * AWS access key ID
     */
    readonly accessKeyId: string;
    /**
     * AWS secret access key
     */
    readonly secretAccessKey: string;
    /**
     * A security or session token to use with these credentials. Usually
     * present for temporary credentials.
     */
    readonly sessionToken?: string;
    /**
     * AWS credential scope for this set of credentials.
     */
    readonly credentialScope?: string;
    /**
     * AWS accountId.
     */
    readonly accountId?: string;
}
/**
 * @public
 */
export type AwsCredentialIdentityProvider = IdentityProvider<AwsCredentialIdentity>;

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/identity/identity.d.ts

```typescript
/**
 * @public
 */
export interface Identity {
    /**
     * A `Date` when the identity or credential will no longer be accepted.
     */
    readonly expiration?: Date;
}
/**
 * @public
 */
export interface IdentityProvider<IdentityT extends Identity> {
    (identityProperties?: Record<string, any>): Promise<IdentityT>;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/identity/index.d.ts

```typescript
export * from "./apiKeyIdentity";
export * from "./awsCredentialIdentity";
export * from "./identity";
export * from "./tokenIdentity";

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/identity/tokenIdentity.d.ts

```typescript
import { Identity, IdentityProvider } from "../identity/identity";
/**
 * @internal
 */
export interface TokenIdentity extends Identity {
    /**
     * The literal token string
     */
    readonly token: string;
}
/**
 * @internal
 */
export type TokenIdentityProvider = IdentityProvider<TokenIdentity>;

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/index.d.ts

```typescript
export * from "./abort";
export * from "./auth";
export * from "./blob/blob-payload-input-types";
export * from "./checksum";
export * from "./client";
export * from "./command";
export * from "./connection";
export * from "./crypto";
export * from "./encode";
export * from "./endpoint";
export * from "./endpoints";
export * from "./eventStream";
export * from "./extensions";
export * from "./feature-ids";
export * from "./http";
export * from "./http/httpHandlerInitialization";
export * from "./identity";
export * from "./logger";
export * from "./middleware";
export * from "./pagination";
export * from "./profile";
export * from "./response";
export * from "./retry";
export * from "./schema/schema";
export * from "./schema/schema-deprecated";
export * from "./schema/sentinels";
export * from "./schema/static-schemas";
export * from "./serde";
export * from "./shapes";
export * from "./signature";
export * from "./stream";
export * from "./streaming-payload/streaming-blob-common-types";
export * from "./streaming-payload/streaming-blob-payload-input-types";
export * from "./streaming-payload/streaming-blob-payload-output-types";
export * from "./transfer";
export * from "./transform/client-payload-blob-type-narrow";
export * from "./transform/mutable";
export * from "./transform/no-undefined";
export * from "./transform/type-transform";
export * from "./uri";
export * from "./util";
export * from "./waiter";

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/logger.d.ts

```typescript
/**
 * @public
 *
 * Represents a logger object that is available in HandlerExecutionContext
 * throughout the middleware stack.
 */
export interface Logger {
    trace?: (...content: any[]) => void;
    debug: (...content: any[]) => void;
    info: (...content: any[]) => void;
    warn: (...content: any[]) => void;
    error: (...content: any[]) => void;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/middleware.d.ts

```typescript
import { AuthScheme, HttpAuthDefinition } from "./auth/auth";
import { SelectedHttpAuthScheme } from "./auth/HttpAuthScheme";
import { Command } from "./command";
import { EndpointV2 } from "./endpoint";
import { SmithyFeatures } from "./feature-ids";
import { Logger } from "./logger";
import { UserAgent } from "./util";
/**
 * @public
 */
export interface InitializeHandlerArguments<Input extends object> {
    /**
     * User input to a command. Reflects the userland representation of the
     * union of data types the command can effectively handle.
     */
    input: Input;
}
/**
 * @public
 */
export interface InitializeHandlerOutput<Output extends object> extends DeserializeHandlerOutput<Output> {
    output: Output;
}
/**
 * @public
 */
export interface SerializeHandlerArguments<Input extends object> extends InitializeHandlerArguments<Input> {
    /**
     * The user input serialized as a request object. The request object is unknown,
     * so you cannot modify it directly. When work with request, you need to guard its
     * type to e.g. HttpRequest with 'instanceof' operand
     *
     * During the build phase of the execution of a middleware stack, a built
     * request may or may not be available.
     */
    request?: unknown;
}
/**
 * @public
 */
export interface SerializeHandlerOutput<Output extends object> extends InitializeHandlerOutput<Output> {
}
/**
 * @public
 */
export interface BuildHandlerArguments<Input extends object> extends FinalizeHandlerArguments<Input> {
}
/**
 * @public
 */
export interface BuildHandlerOutput<Output extends object> extends InitializeHandlerOutput<Output> {
}
/**
 * @public
 */
export interface FinalizeHandlerArguments<Input extends object> extends SerializeHandlerArguments<Input> {
    /**
     * The user input serialized as a request.
     */
    request: unknown;
}
/**
 * @public
 */
export interface FinalizeHandlerOutput<Output extends object> extends InitializeHandlerOutput<Output> {
}
/**
 * @public
 */
export interface DeserializeHandlerArguments<Input extends object> extends FinalizeHandlerArguments<Input> {
}
/**
 * @public
 */
export interface DeserializeHandlerOutput<Output extends object> {
    /**
     * The raw response object from runtime is deserialized to structured output object.
     * The response object is unknown so you cannot modify it directly. When work with
     * response, you need to guard its type to e.g. HttpResponse with 'instanceof' operand.
     *
     * During the deserialize phase of the execution of a middleware stack, a deserialized
     * response may or may not be available
     */
    response: unknown;
    output?: Output;
}
/**
 * @public
 */
export interface InitializeHandler<Input extends object, Output extends object> {
    /**
     * Asynchronously converts an input object into an output object.
     *
     * @param args - An object containing a input to the command as well as any
     *              associated or previously generated execution artifacts.
     */
    (args: InitializeHandlerArguments<Input>): Promise<InitializeHandlerOutput<Output>>;
}
/**
 * @public
 */
export type Handler<Input extends object, Output extends object> = InitializeHandler<Input, Output>;
/**
 * @public
 */
export interface SerializeHandler<Input extends object, Output extends object> {
    /**
     * Asynchronously converts an input object into an output object.
     *
     * @param args - An object containing a input to the command as well as any
     *              associated or previously generated execution artifacts.
     */
    (args: SerializeHandlerArguments<Input>): Promise<SerializeHandlerOutput<Output>>;
}
/**
 * @public
 */
export interface FinalizeHandler<Input extends object, Output extends object> {
    /**
     * Asynchronously converts an input object into an output object.
     *
     * @param args - An object containing a input to the command as well as any
     *              associated or previously generated execution artifacts.
     */
    (args: FinalizeHandlerArguments<Input>): Promise<FinalizeHandlerOutput<Output>>;
}
/**
 * @public
 */
export interface BuildHandler<Input extends object, Output extends object> {
    (args: BuildHandlerArguments<Input>): Promise<BuildHandlerOutput<Output>>;
}
/**
 * @public
 */
export interface DeserializeHandler<Input extends object, Output extends object> {
    (args: DeserializeHandlerArguments<Input>): Promise<DeserializeHandlerOutput<Output>>;
}
/**
 * @public
 *
 * A factory function that creates functions implementing the `Handler`
 * interface.
 */
export interface InitializeMiddleware<Input extends object, Output extends object> {
    /**
     * @param next - The handler to invoke after this middleware has operated on
     * the user input and before this middleware operates on the output.
     *
     * @param context - Invariant data and functions for use by the handler.
     */
    (next: InitializeHandler<Input, Output>, context: HandlerExecutionContext): InitializeHandler<Input, Output>;
}
/**
 * @public
 *
 * A factory function that creates functions implementing the `BuildHandler`
 * interface.
 */
export interface SerializeMiddleware<Input extends object, Output extends object> {
    /**
     * @param next - The handler to invoke after this middleware has operated on
     * the user input and before this middleware operates on the output.
     *
     * @param context - Invariant data and functions for use by the handler.
     */
    (next: SerializeHandler<Input, Output>, context: HandlerExecutionContext): SerializeHandler<Input, Output>;
}
/**
 * @public
 *
 * A factory function that creates functions implementing the `FinalizeHandler`
 * interface.
 */
export interface FinalizeRequestMiddleware<Input extends object, Output extends object> {
    /**
     * @param next - The handler to invoke after this middleware has operated on
     * the user input and before this middleware operates on the output.
     *
     * @param context - Invariant data and functions for use by the handler.
     */
    (next: FinalizeHandler<Input, Output>, context: HandlerExecutionContext): FinalizeHandler<Input, Output>;
}
/**
 * @public
 */
export interface BuildMiddleware<Input extends object, Output extends object> {
    (next: BuildHandler<Input, Output>, context: HandlerExecutionContext): BuildHandler<Input, Output>;
}
/**
 * @public
 */
export interface DeserializeMiddleware<Input extends object, Output extends object> {
    (next: DeserializeHandler<Input, Output>, context: HandlerExecutionContext): DeserializeHandler<Input, Output>;
}
/**
 * @public
 */
export type MiddlewareType<Input extends object, Output extends object> = InitializeMiddleware<Input, Output> | SerializeMiddleware<Input, Output> | BuildMiddleware<Input, Output> | FinalizeRequestMiddleware<Input, Output> | DeserializeMiddleware<Input, Output>;
/**
 * @public
 *
 * A factory function that creates the terminal handler atop which a middleware
 * stack sits.
 */
export interface Terminalware {
    <Input extends object, Output extends object>(context: HandlerExecutionContext): DeserializeHandler<Input, Output>;
}
/**
 * @public
 */
export type Step = "initialize" | "serialize" | "build" | "finalizeRequest" | "deserialize";
/**
 * @public
 */
export type Priority = "high" | "normal" | "low";
/**
 * @public
 */
export interface HandlerOptions {
    /**
     * Handlers are ordered using a "step" that describes the stage of command
     * execution at which the handler will be executed. The available steps are:
     *
     * - initialize: The input is being prepared. Examples of typical
     *      initialization tasks include injecting default options computing
     *      derived parameters.
     * - serialize: The input is complete and ready to be serialized. Examples
     *      of typical serialization tasks include input validation and building
     *      an HTTP request from user input.
     * - build: The input has been serialized into an HTTP request, but that
     *      request may require further modification. Any request alterations
     *      will be applied to all retries. Examples of typical build tasks
     *      include injecting HTTP headers that describe a stable aspect of the
     *      request, such as `Content-Length` or a body checksum.
     * - finalizeRequest: The request is being prepared to be sent over the wire. The
     *      request in this stage should already be semantically complete and
     *      should therefore only be altered as match the recipient's
     *      expectations. Examples of typical finalization tasks include request
     *      signing and injecting hop-by-hop headers.
     * - deserialize: The response has arrived, the middleware here will deserialize
     *      the raw response object to structured response
     *
     *      Unlike initialization and build handlers, which are executed once
     *      per operation execution, finalization and deserialize handlers will be
     *      executed foreach HTTP request sent.
     *
     * @defaultValue 'initialize'
     */
    step?: Step;
    /**
     * A list of strings to any that identify the general purpose or important
     * characteristics of a given handler.
     */
    tags?: Array<string>;
    /**
     * A unique name to refer to a middleware
     */
    name?: string;
    /**
     * @internal
     * Aliases allows for middleware to be found by multiple names besides {@link HandlerOptions.name}.
     * This allows for references to replaced middleware to continue working, e.g. replacing
     * multiple auth-specific middleware with a single generic auth middleware.
     */
    aliases?: Array<string>;
    /**
     * A flag to override the existing middleware with the same name. Without
     * setting it, adding middleware with duplicated name will throw an exception.
     * @internal
     */
    override?: boolean;
}
/**
 * @public
 */
export interface AbsoluteLocation {
    /**
     * By default middleware will be added to individual step in un-guaranteed order.
     * In the case that
     *
     * @defaultValue 'normal'
     */
    priority?: Priority;
}
/**
 * @public
 */
export type Relation = "before" | "after";
/**
 * @public
 */
export interface RelativeLocation {
    /**
     * Specify the relation to be before or after a know middleware.
     */
    relation: Relation;
    /**
     * A known middleware name to indicate inserting middleware's location.
     */
    toMiddleware: string;
}
/**
 * @public
 */
export type RelativeMiddlewareOptions = RelativeLocation & Pick<HandlerOptions, Exclude<keyof HandlerOptions, "step">>;
/**
 * @public
 */
export interface InitializeHandlerOptions extends HandlerOptions {
    step?: "initialize";
}
/**
 * @public
 */
export interface SerializeHandlerOptions extends HandlerOptions {
    step: "serialize";
}
/**
 * @public
 */
export interface BuildHandlerOptions extends HandlerOptions {
    step: "build";
}
/**
 * @public
 */
export interface FinalizeRequestHandlerOptions extends HandlerOptions {
    step: "finalizeRequest";
}
/**
 * @public
 */
export interface DeserializeHandlerOptions extends HandlerOptions {
    step: "deserialize";
}
/**
 * @public
 *
 * A stack storing middleware. It can be resolved into a handler. It supports 2
 * approaches for adding middleware:
 * 1. Adding middleware to specific step with `add()`. The order of middleware
 *    added into same step is determined by order of adding them. If one middleware
 *    needs to be executed at the front of the step or at the end of step, set
 *    `priority` options to `high` or `low`.
 * 2. Adding middleware to location relative to known middleware with `addRelativeTo()`.
 *    This is useful when given middleware must be executed before or after specific
 *    middleware(`toMiddleware`). You can add a middleware relatively to another
 *    middleware which also added relatively. But eventually, this relative middleware
 *    chain **must** be 'anchored' by a middleware that added using `add()` API
 *    with absolute `step` and `priority`. This mothod will throw if specified
 *    `toMiddleware` is not found.
 */
export interface MiddlewareStack<Input extends object, Output extends object> extends Pluggable<Input, Output> {
    /**
     * Add middleware to the stack to be executed during the "initialize" step,
     * optionally specifying a priority, tags and name
     */
    add(middleware: InitializeMiddleware<Input, Output>, options?: InitializeHandlerOptions & AbsoluteLocation): void;
    /**
     * Add middleware to the stack to be executed during the "serialize" step,
     * optionally specifying a priority, tags and name
     */
    add(middleware: SerializeMiddleware<Input, Output>, options: SerializeHandlerOptions & AbsoluteLocation): void;
    /**
     * Add middleware to the stack to be executed during the "build" step,
     * optionally specifying a priority, tags and name
     */
    add(middleware: BuildMiddleware<Input, Output>, options: BuildHandlerOptions & AbsoluteLocation): void;
    /**
     * Add middleware to the stack to be executed during the "finalizeRequest" step,
     * optionally specifying a priority, tags and name
     */
    add(middleware: FinalizeRequestMiddleware<Input, Output>, options: FinalizeRequestHandlerOptions & AbsoluteLocation): void;
    /**
     * Add middleware to the stack to be executed during the "deserialize" step,
     * optionally specifying a priority, tags and name
     */
    add(middleware: DeserializeMiddleware<Input, Output>, options: DeserializeHandlerOptions & AbsoluteLocation): void;
    /**
     * Add middleware to a stack position before or after a known middlewareoptionally
     * specifying name and tags.
     */
    addRelativeTo(middleware: MiddlewareType<Input, Output>, options: RelativeMiddlewareOptions): void;
    /**
     * Apply a customization function to mutate the middleware stack, often
     * used for customizations that requires mutating multiple middleware.
     */
    use(pluggable: Pluggable<Input, Output>): void;
    /**
     * Create a shallow clone of this stack. Step bindings and handler priorities
     * and tags are preserved in the copy.
     */
    clone(): MiddlewareStack<Input, Output>;
    /**
     * Removes middleware from the stack.
     *
     * If a string is provided, it will be treated as middleware name. If a middleware
     * is inserted with the given name, it will be removed.
     *
     * If a middleware class is provided, all usages thereof will be removed.
     */
    remove(toRemove: MiddlewareType<Input, Output> | string): boolean;
    /**
     * Removes middleware that contains given tag
     *
     * Multiple middleware will potentially be removed
     */
    removeByTag(toRemove: string): boolean;
    /**
     * Create a stack containing the middlewares in this stack as well as the
     * middlewares in the `from` stack. Neither source is modified, and step
     * bindings and handler priorities and tags are preserved in the copy.
     */
    concat<InputType extends Input, OutputType extends Output>(from: MiddlewareStack<InputType, OutputType>): MiddlewareStack<InputType, OutputType>;
    /**
     * Returns a list of the current order of middleware in the stack.
     * This does not execute the middleware functions, nor does it
     * provide a reference to the stack itself.
     */
    identify(): string[];
    /**
     * @internal
     *
     * When an operation is called using this stack,
     * it will log its list of middleware to the console using
     * the identify function.
     *
     * @param toggle - set whether to log on resolve.
     *                 If no argument given, returns the current value.
     */
    identifyOnResolve(toggle?: boolean): boolean;
    /**
     * Builds a single handler function from zero or more middleware classes and
     * a core handler. The core handler is meant to send command objects to AWS
     * services and return promises that will resolve with the operation result
     * or be rejected with an error.
     *
     * When a composed handler is invoked, the arguments will pass through all
     * middleware in a defined order, and the return from the innermost handler
     * will pass through all middleware in the reverse of that order.
     */
    resolve<InputType extends Input, OutputType extends Output>(handler: DeserializeHandler<InputType, OutputType>, context: HandlerExecutionContext): InitializeHandler<InputType, OutputType>;
}
/**
 * @internal
 */
export declare const SMITHY_CONTEXT_KEY = "__smithy_context";
/**
 * @public
 *
 * Data and helper objects that are not expected to change from one execution of
 * a composed handler to another.
 */
export interface HandlerExecutionContext {
    /**
     * A logger that may be invoked by any handler during execution of an
     * operation.
     */
    logger?: Logger;
    /**
     * Name of the service the operation is being sent to.
     */
    clientName?: string;
    /**
     * Name of the operation being executed.
     */
    commandName?: string;
    /**
     * Additional user agent that inferred by middleware. It can be used to save
     * the internal user agent sections without overriding the `customUserAgent`
     * config in clients.
     */
    userAgent?: UserAgent;
    /**
     * Resolved by the endpointMiddleware function of `@smithy/middleware-endpoint`
     * in the serialization stage.
     */
    endpointV2?: EndpointV2;
    /**
     * Set at the same time as endpointV2.
     */
    authSchemes?: AuthScheme[];
    /**
     * The current auth configuration that has been set by any auth middleware and
     * that will prevent from being set more than once.
     */
    currentAuthConfig?: HttpAuthDefinition;
    /**
     * @deprecated do not extend this field, it is a carryover from AWS SDKs.
     * Used by DynamoDbDocumentClient.
     */
    dynamoDbDocumentClientOptions?: Partial<{
        overrideInputFilterSensitiveLog(...args: any[]): string | void;
        overrideOutputFilterSensitiveLog(...args: any[]): string | void;
    }>;
    /**
     * @internal
     * Context for Smithy properties.
     */
    [SMITHY_CONTEXT_KEY]?: {
        service?: string;
        operation?: string;
        commandInstance?: Command<any, any, any, any, any>;
        selectedHttpAuthScheme?: SelectedHttpAuthScheme;
        features?: SmithyFeatures;
        /**
         * @deprecated
         * Do not assign arbitrary members to the Smithy Context,
         * fields should be explicitly declared here to avoid collisions.
         */
        [key: string]: unknown;
    };
    /**
     * @deprecated
     * Do not assign arbitrary members to the context, since
     * they can interfere with existing functionality.
     *
     * Additional members should instead be declared on the SMITHY_CONTEXT_KEY
     * or other reserved keys.
     */
    [key: string]: any;
}
/**
 * @public
 */
export interface Pluggable<Input extends object, Output extends object> {
    /**
     * A function that mutate the passed in middleware stack. Functions implementing
     * this interface can add, remove, modify existing middleware stack from clients
     * or commands
     */
    applyToStack: (stack: MiddlewareStack<Input, Output>) => void;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/pagination.d.ts

```typescript
import { Client } from "./client";
import { Command } from "./command";
/**
 * @public
 *
 * Expected type definition of a paginator.
 */
export type Paginator<T> = AsyncGenerator<T, undefined, unknown>;
/**
 * @public
 *
 * Expected paginator configuration passed to an operation. Services will extend
 * this interface definition and may type client further.
 */
export interface PaginationConfiguration {
    client: Client<any, any, any>;
    pageSize?: number;
    startingToken?: any;
    /**
     * For some APIs, such as CloudWatchLogs events, the next page token will always
     * be present.
     *
     * When true, this config field will have the paginator stop when the token doesn't change
     * instead of when it is not present.
     */
    stopOnSameToken?: boolean;
    /**
     * @param command - reference to the instantiated command. This callback is executed
     *                  prior to sending the command with the paginator's client.
     * @returns the original command or a replacement, defaulting to the original command object.
     */
    withCommand?: (command: Command<any, any, any, any, any>) => typeof command | undefined;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/profile.d.ts

```typescript
/**
 * @public
 */
export declare enum IniSectionType {
    PROFILE = "profile",
    SSO_SESSION = "sso-session",
    SERVICES = "services"
}
/**
 * @public
 */
export type IniSection = Record<string, string | undefined>;
/**
 * @public
 *
 * @deprecated Please use {@link IniSection}
 */
export interface Profile extends IniSection {
}
/**
 * @public
 */
export type ParsedIniData = Record<string, IniSection>;
/**
 * @public
 */
export interface SharedConfigFiles {
    credentialsFile: ParsedIniData;
    configFile: ParsedIniData;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/response.d.ts

```typescript
/**
 * @public
 */
export interface ResponseMetadata {
    /**
     * The status code of the last HTTP response received for this operation.
     */
    httpStatusCode?: number;
    /**
     * A unique identifier for the last request sent for this operation. Often
     * requested by AWS service teams to aid in debugging.
     */
    requestId?: string;
    /**
     * A secondary identifier for the last request sent. Used for debugging.
     */
    extendedRequestId?: string;
    /**
     * A tertiary identifier for the last request sent. Used for debugging.
     */
    cfId?: string;
    /**
     * The number of times this operation was attempted.
     */
    attempts?: number;
    /**
     * The total amount of time (in milliseconds) that was spent waiting between
     * retry attempts.
     */
    totalRetryDelay?: number;
}
/**
 * @public
 */
export interface MetadataBearer {
    /**
     * Metadata pertaining to this request.
     */
    $metadata: ResponseMetadata;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/retry.d.ts

```typescript
import { SdkError } from "./shapes";
/**
 * @public
 */
export type RetryErrorType = 
/**
 * This is a connection level error such as a socket timeout, socket connect
 * error, tls negotiation timeout etc...
 * Typically these should never be applied for non-idempotent request types
 * since in this scenario, it's impossible to know whether the operation had
 * a side effect on the server.
 */
"TRANSIENT"
/**
 * This is an error where the server explicitly told the client to back off,
 * such as a 429 or 503 Http error.
 */
 | "THROTTLING"
/**
 * This is a server error that isn't explicitly throttling but is considered
 * by the client to be something that should be retried.
 */
 | "SERVER_ERROR"
/**
 * Doesn't count against any budgets. This could be something like a 401
 * challenge in Http.
 */
 | "CLIENT_ERROR";
/**
 * @public
 */
export interface RetryErrorInfo {
    /**
     * The error thrown during the initial request, if available.
     */
    error?: SdkError;
    errorType: RetryErrorType;
    /**
     * Protocol hint. This could come from Http's 'retry-after' header or
     * something from MQTT or any other protocol that has the ability to convey
     * retry info from a peer.
     *
     * The Date after which a retry should be attempted.
     */
    retryAfterHint?: Date;
}
/**
 * @public
 */
export interface RetryBackoffStrategy {
    /**
     * @returns the number of milliseconds to wait before retrying an action.
     */
    computeNextBackoffDelay(retryAttempt: number): number;
}
/**
 * @public
 */
export interface StandardRetryBackoffStrategy extends RetryBackoffStrategy {
    /**
     * Sets the delayBase used to compute backoff delays.
     * @param delayBase -
     */
    setDelayBase(delayBase: number): void;
}
/**
 * @public
 */
export interface RetryStrategyOptions {
    backoffStrategy: RetryBackoffStrategy;
    maxRetriesBase: number;
}
/**
 * @public
 */
export interface RetryToken {
    /**
     * @returns the current count of retry.
     */
    getRetryCount(): number;
    /**
     * @returns the number of milliseconds to wait before retrying an action.
     */
    getRetryDelay(): number;
}
/**
 * @public
 */
export interface StandardRetryToken extends RetryToken {
    /**
     * @returns the cost of the last retry attempt.
     */
    getRetryCost(): number | undefined;
}
/**
 * @public
 */
export interface RetryStrategyV2 {
    /**
     * Called before any retries (for the first call to the operation). It either
     * returns a retry token or an error upon the failure to acquire a token prior.
     *
     * tokenScope is arbitrary and out of scope for this component. However,
     * adding it here offers us a lot of future flexibility for outage detection.
     * For example, it could be "us-east-1" on a shared retry strategy, or
     * "us-west-2-c:dynamodb".
     */
    acquireInitialRetryToken(retryTokenScope: string): Promise<RetryToken>;
    /**
     * After a failed operation call, this function is invoked to refresh the
     * retryToken returned by acquireInitialRetryToken(). This function can
     * either choose to allow another retry and send a new or updated token,
     * or reject the retry attempt and report the error either in an exception
     * or returning an error.
     */
    refreshRetryTokenForRetry(tokenToRenew: RetryToken, errorInfo: RetryErrorInfo): Promise<RetryToken>;
    /**
     * Upon successful completion of the operation, this function is called
     * to record that the operation was successful.
     */
    recordSuccess(token: RetryToken): void;
}
/**
 * @public
 */
export type ExponentialBackoffJitterType = "DEFAULT" | "NONE" | "FULL" | "DECORRELATED";
/**
 * @public
 */
export interface ExponentialBackoffStrategyOptions {
    jitterType: ExponentialBackoffJitterType;
    backoffScaleValue?: number;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/schema/schema-deprecated.d.ts

```typescript
import { EndpointV2 } from "../endpoint";
import { HandlerExecutionContext } from "../middleware";
import { MetadataBearer } from "../response";
import { EndpointBearer, SerdeFunctions } from "../serde";
import { ConfigurableSerdeContext, NormalizedSchema, SchemaTraits, SimpleSchema, UnitSchema } from "./schema";
import { StaticSchema } from "./static-schemas";
/**
 * A schema is an object or value that describes how to serialize/deserialize data.
 * @public
 * @deprecated use $Schema
 */
export type Schema = UnitSchema | TraitsSchema | SimpleSchema | ListSchema | MapSchema | StructureSchema | MemberSchema | OperationSchema | StaticSchema | NormalizedSchema;
/**
 * A schema "reference" is either a schema or a function that
 * provides a schema. This is useful for lazy loading, and to allow
 * code generation to define schema out of dependency order.
 * @public
 * @deprecated use $SchemaRef
 */
export type SchemaRef = Schema | (() => Schema);
/**
 * A schema that has traits.
 *
 * @public
 * @deprecated use static schema.
 */
export interface TraitsSchema {
    namespace: string;
    name: string;
    traits: SchemaTraits;
}
/**
 * Indicates the schema is a member of a parent Structure schema.
 * It may also have a set of member traits distinct from its target shape's traits.
 * @public
 * @deprecated use $MemberSchema
 */
export type MemberSchema = [
    SchemaRef,
    SchemaTraits
];
/**
 * Schema for the structure aggregate type.
 * @public
 * @deprecated use static schema.
 */
export interface StructureSchema extends TraitsSchema {
    memberNames: string[];
    memberList: SchemaRef[];
    /**
     * @deprecated structure member iteration will be linear on the memberNames and memberList arrays.
     * It can be collected into a hashmap form on an ad-hoc basis, but will not initialize as such.
     */
    members?: Record<string, [
        SchemaRef,
        SchemaTraits
    ]> | undefined;
}
/**
 * Schema for the list aggregate type.
 * @public
 * @deprecated use static schema.
 */
export interface ListSchema extends TraitsSchema {
    valueSchema: SchemaRef;
}
/**
 * Schema for the map aggregate type.
 * @public
 * @deprecated use static schema.
 */
export interface MapSchema extends TraitsSchema {
    keySchema: SchemaRef;
    valueSchema: SchemaRef;
}
/**
 * Schema for an operation.
 * @public
 * @deprecated use StaticOperationSchema or $OperationSchema
 */
export interface OperationSchema {
    namespace: string;
    name: string;
    traits: SchemaTraits;
    input: SchemaRef;
    output: SchemaRef;
}
/**
 * Turns a serialization into a data object.
 * @public
 * @deprecated use $ShapeDeserializer
 */
export interface ShapeDeserializer<SerializationType = Uint8Array> extends ConfigurableSerdeContext {
    /**
     * Optionally async.
     */
    read(schema: Schema, data: SerializationType): any | Promise<any>;
}
/**
 * Turns a data object into a serialization.
 * @public
 * @deprecated use $ShapeSerializer
 */
export interface ShapeSerializer<SerializationType = Uint8Array> extends ConfigurableSerdeContext {
    write(schema: Schema, value: unknown): void;
    flush(): SerializationType;
}
/**
 * A codec creates serializers and deserializers for some format such as JSON, XML, or CBOR.
 *
 * @public
 * @deprecated use $Codec
 */
export interface Codec<S, D> extends ConfigurableSerdeContext {
    createSerializer(): ShapeSerializer<S>;
    createDeserializer(): ShapeDeserializer<D>;
}
/**
 * A client protocol defines how to convert a message (e.g. HTTP request/response) to and from a data object.
 * @public
 * @deprecated use $ClientProtocol
 */
export interface ClientProtocol<Request, Response> extends ConfigurableSerdeContext {
    /**
     * @returns the Smithy qualified shape id.
     */
    getShapeId(): string;
    getRequestType(): {
        new (...args: any[]): Request;
    };
    getResponseType(): {
        new (...args: any[]): Response;
    };
    /**
     * @returns the payload codec if the requests/responses have a symmetric format.
     * It otherwise may return null.
     */
    getPayloadCodec(): Codec<any, any>;
    serializeRequest<Input extends object>(operationSchema: OperationSchema, input: Input, context: HandlerExecutionContext & SerdeFunctions & EndpointBearer): Promise<Request>;
    updateServiceEndpoint(request: Request, endpoint: EndpointV2): Request;
    deserializeResponse<Output extends MetadataBearer>(operationSchema: OperationSchema, context: HandlerExecutionContext & SerdeFunctions, response: Response): Promise<Output>;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/schema/schema.d.ts

```typescript
import { EndpointV2 } from "../endpoint";
import { HandlerExecutionContext } from "../middleware";
import { MetadataBearer } from "../response";
import { EndpointBearer, SerdeFunctions } from "../serde";
import { BigDecimalSchema, BigIntegerSchema, BlobSchema, BooleanSchema, DocumentSchema, NumericSchema, StreamingBlobSchema, StringSchema, TimestampDateTimeSchema, TimestampDefaultSchema, TimestampEpochSecondsSchema, TimestampHttpDateSchema } from "./sentinels";
import { StaticSchema } from "./static-schemas";
import { TraitBitVector } from "./traits";
/**
 * A schema is an object or value that describes how to serialize/deserialize data.
 * @alpha
 */
export type $Schema = UnitSchema | SimpleSchema | $MemberSchema | StaticSchema | NormalizedSchema;
/**
 * Traits attached to schema objects.
 *
 * When this is a number, it refers to a pre-allocated
 * trait combination that is equivalent to one of the
 * object type's variations.
 *
 * @public
 */
export type SchemaTraits = TraitBitVector | SchemaTraitsObject;
/**
 * Simple schemas are those corresponding to simple Smithy types.
 * @see https://smithy.io/2.0/spec/simple-types.html
 * @public
 */
export type SimpleSchema = BlobSchemas | StringSchema | BooleanSchema | NumericSchema | BigIntegerSchema | BigDecimalSchema | DocumentSchema | TimestampSchemas | number;
/**
 * Sentinel value for Timestamp schema.
 * "Default" means unspecified and to use the protocol serializer's default format.
 *
 * @public
 */
export type TimestampSchemas = TimestampDefaultSchema | TimestampDateTimeSchema | TimestampHttpDateSchema | TimestampEpochSecondsSchema;
/**
 * Sentinel values for Blob schema.
 * @public
 */
export type BlobSchemas = BlobSchema | StreamingBlobSchema;
/**
 * Signal value for the Smithy void value. Typically used for
 * operation input and outputs.
 *
 * @alpha
 */
export type UnitSchema = "unit";
/**
 * See https://smithy.io/2.0/trait-index.html for individual definitions.
 *
 * @public
 */
export type SchemaTraitsObject = {
    idempotent?: 1;
    idempotencyToken?: 1;
    sensitive?: 1;
    sparse?: 1;
    /**
     * timestampFormat is expressed by the schema sentinel values of 4, 5, 6, and 7,
     * and not contained in trait objects.
     * @deprecated use schema value.
     */
    timestampFormat?: never;
    httpLabel?: 1;
    httpHeader?: string;
    httpQuery?: string;
    httpPrefixHeaders?: string;
    httpQueryParams?: 1;
    httpPayload?: 1;
    /**
     * [method, path, statusCode]
     */
    http?: [
        string,
        string,
        number
    ];
    httpResponseCode?: 1;
    /**
     * [hostPrefix]
     */
    endpoint?: [
        string
    ];
    xmlAttribute?: 1;
    xmlName?: string;
    /**
     * [prefix, uri]
     */
    xmlNamespace?: [
        string,
        string
    ];
    xmlFlattened?: 1;
    jsonName?: string;
    mediaType?: string;
    error?: "client" | "server";
    streaming?: 1;
    eventHeader?: 1;
    eventPayload?: 1;
    [traitName: string]: unknown;
};
/**
 * Indicates the schema is a member of a parent Structure schema.
 * It may also have a set of member traits distinct from its target shape's traits.
 * @alpha
 */
export type $MemberSchema = [
    $SchemaRef,
    SchemaTraits
];
/**
 * Schema for an operation.
 * @alpha
 */
export interface $OperationSchema {
    namespace: string;
    name: string;
    traits: SchemaTraits;
    input: $SchemaRef;
    output: $SchemaRef;
}
/**
 * Normalization wrapper for various schema data objects.
 * @public
 */
export interface NormalizedSchema {
    getSchema(): $Schema;
    getName(): string | undefined;
    isMemberSchema(): boolean;
    isListSchema(): boolean;
    isMapSchema(): boolean;
    isStructSchema(): boolean;
    isBlobSchema(): boolean;
    isTimestampSchema(): boolean;
    isStringSchema(): boolean;
    isBooleanSchema(): boolean;
    isNumericSchema(): boolean;
    isBigIntegerSchema(): boolean;
    isBigDecimalSchema(): boolean;
    isStreaming(): boolean;
    getMergedTraits(): SchemaTraitsObject;
    getMemberTraits(): SchemaTraitsObject;
    getOwnTraits(): SchemaTraitsObject;
    /**
     * For list/set/map.
     */
    getValueSchema(): NormalizedSchema;
    /**
     * For struct/union.
     */
    getMemberSchema(member: string): NormalizedSchema | undefined;
    structIterator(): Generator<[
        string,
        NormalizedSchema
    ], undefined, undefined>;
}
/**
 * A schema "reference" is either a schema or a function that
 * provides a schema. This is useful for lazy loading, and to allow
 * code generation to define schema out of dependency order.
 * @alpha
 */
export type $SchemaRef = $Schema | (() => $Schema);
/**
 * A codec creates serializers and deserializers for some format such as JSON, XML, or CBOR.
 *
 * @public
 */
export interface $Codec<S, D> extends ConfigurableSerdeContext {
    createSerializer(): $ShapeSerializer<S>;
    createDeserializer(): $ShapeDeserializer<D>;
}
/**
 * Configuration for codecs. Different protocols may share codecs, but require different behaviors from them.
 *
 * @public
 */
export type CodecSettings = {
    timestampFormat: {
        /**
         * Whether to use member timestamp format traits.
         */
        useTrait: boolean;
        /**
         * Default timestamp format.
         */
        default: TimestampDateTimeSchema | TimestampHttpDateSchema | TimestampEpochSecondsSchema;
    };
    /**
     * Whether to use HTTP binding traits.
     */
    httpBindings?: boolean;
};
/**
 * Turns a serialization into a data object.
 * @public
 */
export interface $ShapeDeserializer<SerializationType = Uint8Array> extends ConfigurableSerdeContext {
    /**
     * Optionally async.
     */
    read(schema: $Schema, data: SerializationType): any | Promise<any>;
}
/**
 * Turns a data object into a serialization.
 * @public
 */
export interface $ShapeSerializer<SerializationType = Uint8Array> extends ConfigurableSerdeContext {
    write(schema: $Schema, value: unknown): void;
    flush(): SerializationType;
}
/**
 * A client protocol defines how to convert a message (e.g. HTTP request/response) to and from a data object.
 * @public
 */
export interface $ClientProtocol<Request, Response> extends ConfigurableSerdeContext {
    /**
     * @returns the Smithy qualified shape id.
     */
    getShapeId(): string;
    getRequestType(): {
        new (...args: any[]): Request;
    };
    getResponseType(): {
        new (...args: any[]): Response;
    };
    /**
     * @returns the payload codec if the requests/responses have a symmetric format.
     * It otherwise may return null.
     */
    getPayloadCodec(): $Codec<any, any>;
    serializeRequest<Input extends object>(operationSchema: $OperationSchema, input: Input, context: HandlerExecutionContext & SerdeFunctions & EndpointBearer): Promise<Request>;
    updateServiceEndpoint(request: Request, endpoint: EndpointV2): Request;
    deserializeResponse<Output extends MetadataBearer>(operationSchema: $OperationSchema, context: HandlerExecutionContext & SerdeFunctions, response: Response): Promise<Output>;
}
/**
 * Allows a protocol, codec, or serde utility to accept the serdeContext
 * from a client configuration or request/response handlerExecutionContext.
 *
 * @public
 */
export interface ConfigurableSerdeContext {
    setSerdeContext(serdeContext: SerdeFunctions): void;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/schema/sentinels.d.ts

```typescript
/**
 * The blob Smithy type, in JS as Uint8Array and other representations
 * such as Buffer, string, or Readable(Stream) depending on circumstances.
 * @public
 */
export type BlobSchema = 21;
/**
 * @public
 */
export type StreamingBlobSchema = 42;
/**
 * @public
 */
export type BooleanSchema = 2;
/**
 * Includes string and enum Smithy types.
 * @public
 */
export type StringSchema = 0;
/**
 * Includes all numeric Smithy types except bigInteger and bigDecimal.
 * byte, short, integer, long, float, double, intEnum.
 *
 * @public
 */
export type NumericSchema = 1;
/**
 * @public
 */
export type BigIntegerSchema = 17;
/**
 * @public
 */
export type BigDecimalSchema = 19;
/**
 * @public
 */
export type DocumentSchema = 15;
/**
 * Smithy type timestamp, in JS as native Date object.
 * @public
 */
export type TimestampDefaultSchema = 4;
/**
 * @public
 */
export type TimestampDateTimeSchema = 5;
/**
 * @public
 */
export type TimestampHttpDateSchema = 6;
/**
 * @public
 */
export type TimestampEpochSecondsSchema = 7;
/**
 * Additional bit indicating the type is a list.
 * @public
 */
export type ListSchemaModifier = 64;
/**
 * Additional bit indicating the type is a map.
 * @public
 */
export type MapSchemaModifier = 128;

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/schema/static-schemas.d.ts

```typescript
import { $SchemaRef, SchemaTraits } from "../schema/schema";
/**
 * @alpha
 */
export type StaticSchemaIdSimple = 0;
/**
 * @alpha
 */
export type StaticSchemaIdList = 1;
/**
 * @alpha
 */
export type StaticSchemaIdMap = 2;
/**
 * @alpha
 */
export type StaticSchemaIdStruct = 3;
/**
 * @alpha
 */
export type StaticSchemaIdError = -3;
/**
 * @alpha
 */
export type StaticSchemaIdOperation = 9;
/**
 * @alpha
 */
export type StaticSchema = StaticSimpleSchema | StaticListSchema | StaticMapSchema | StaticStructureSchema | StaticErrorSchema | StaticOperationSchema;
/**
 * @alpha
 */
export type ShapeName = string;
/**
 * @alpha
 */
export type ShapeNamespace = string;
/**
 * @alpha
 */
export type StaticSimpleSchema = [
    StaticSchemaIdSimple,
    ShapeNamespace,
    ShapeName,
    SchemaTraits,
    $SchemaRef
];
/**
 * @alpha
 */
export type StaticListSchema = [
    StaticSchemaIdList,
    ShapeNamespace,
    ShapeName,
    SchemaTraits,
    $SchemaRef
];
/**
 * @alpha
 */
export type StaticMapSchema = [
    StaticSchemaIdMap,
    ShapeNamespace,
    ShapeName,
    SchemaTraits,
    $SchemaRef,
    $SchemaRef
];
/**
 * @alpha
 */
export type StaticStructureSchema = [
    StaticSchemaIdStruct,
    ShapeNamespace,
    ShapeName,
    SchemaTraits,
    string[],
    $SchemaRef[]
];
/**
 * @alpha
 */
export type StaticErrorSchema = [
    StaticSchemaIdError,
    ShapeNamespace,
    ShapeName,
    SchemaTraits,
    string[],
    $SchemaRef[]
];
/**
 * @alpha
 */
export type StaticOperationSchema = [
    StaticSchemaIdOperation,
    ShapeNamespace,
    ShapeName,
    SchemaTraits,
    $SchemaRef,
    $SchemaRef
];

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/schema/traits.d.ts

```typescript
/**
 * A bitvector representing a traits object.
 *
 * Vector index to trait:
 * 0 - httpLabel
 * 1 - idempotent
 * 2 - idempotencyToken
 * 3 - sensitive
 * 4 - httpPayload
 * 5 - httpResponseCode
 * 6 - httpQueryParams
 *
 * The singular trait values are enumerated for quick identification, but
 * combination values are left to the `number` union type.
 *
 * @public
 */
export type TraitBitVector = HttpLabelBitMask | IdempotentBitMask | IdempotencyTokenBitMask | SensitiveBitMask | HttpPayloadBitMask | HttpResponseCodeBitMask | HttpQueryParamsBitMask | number;
/**
 * @public
 */
export type HttpLabelBitMask = 1;
/**
 * @public
 */
export type IdempotentBitMask = 2;
/**
 * @public
 */
export type IdempotencyTokenBitMask = 4;
/**
 * @public
 */
export type SensitiveBitMask = 8;
/**
 * @public
 */
export type HttpPayloadBitMask = 16;
/**
 * @public
 */
export type HttpResponseCodeBitMask = 32;
/**
 * @public
 */
export type HttpQueryParamsBitMask = 64;

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/serde.d.ts

```typescript
import { Endpoint } from "./http";
import { $ClientProtocol } from "./schema/schema";
import { RequestHandler } from "./transfer";
import { Decoder, Encoder, Provider } from "./util";
/**
 * @public
 *
 * Interface for object requires an Endpoint set.
 */
export interface EndpointBearer {
    endpoint: Provider<Endpoint>;
}
/**
 * @public
 */
export interface StreamCollector {
    /**
     * A function that converts a stream into an array of bytes.
     *
     * @param stream - The low-level native stream from browser or Nodejs runtime
     */
    (stream: any): Promise<Uint8Array>;
}
/**
 * @public
 *
 * Request and Response serde util functions and settings for AWS services
 */
export interface SerdeContext extends SerdeFunctions, EndpointBearer {
    requestHandler: RequestHandler<any, any>;
    disableHostPrefix: boolean;
    protocol?: $ClientProtocol<any, any>;
}
/**
 * @public
 *
 * Serde functions from the client config.
 */
export interface SerdeFunctions {
    base64Encoder: Encoder;
    base64Decoder: Decoder;
    utf8Encoder: Encoder;
    utf8Decoder: Decoder;
    streamCollector: StreamCollector;
}
/**
 * @public
 */
export interface RequestSerializer<Request, Context extends EndpointBearer = any> {
    /**
     * Converts the provided `input` into a request object
     *
     * @param input - The user input to serialize.
     *
     * @param context - Context containing runtime-specific util functions.
     */
    (input: any, context: Context): Promise<Request>;
}
/**
 * @public
 */
export interface ResponseDeserializer<OutputType, ResponseType = any, Context = any> {
    /**
     * Converts the output of an operation into JavaScript types.
     *
     * @param output - The HTTP response received from the service
     *
     * @param context - context containing runtime-specific util functions.
     */
    (output: ResponseType, context: Context): Promise<OutputType>;
}
/**
 * The interface contains mix-in utility functions to transfer the runtime-specific
 * stream implementation to specified format. Each stream can ONLY be transformed
 * once.
 * @public
 */
export interface SdkStreamMixin {
    transformToByteArray: () => Promise<Uint8Array>;
    transformToString: (encoding?: string) => Promise<string>;
    transformToWebStream: () => ReadableStream;
}
/**
 * @public
 *
 * The type describing a runtime-specific stream implementation with mix-in
 * utility functions.
 */
export type SdkStream<BaseStream> = BaseStream & SdkStreamMixin;
/**
 * @public
 *
 * Indicates that the member of type T with
 * key StreamKey have been extended
 * with the SdkStreamMixin helper methods.
 */
export type WithSdkStreamMixin<T, StreamKey extends keyof T> = {
    [key in keyof T]: key extends StreamKey ? SdkStream<T[StreamKey]> : T[key];
};
/**
 * Interface for internal function to inject stream utility functions
 * implementation
 *
 * @internal
 */
export interface SdkStreamMixinInjector {
    (stream: unknown): SdkStreamMixin;
}
/**
 * @internal
 */
export interface SdkStreamSerdeContext {
    sdkStreamMixin: SdkStreamMixinInjector;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/shapes.d.ts

```typescript
import { HttpResponse } from "./http";
import { MetadataBearer } from "./response";
/**
 * @public
 *
 * A document type represents an untyped JSON-like value.
 *
 * Not all protocols support document types, and the serialization format of a
 * document type is protocol specific. All JSON protocols SHOULD support
 * document types and they SHOULD serialize document types inline as normal
 * JSON values.
 */
export type DocumentType = null | boolean | number | string | DocumentType[] | {
    [prop: string]: DocumentType;
};
/**
 * @public
 *
 * A structure shape with the error trait.
 * https://smithy.io/2.0/spec/behavior-traits.html#smithy-api-retryable-trait
 */
export interface RetryableTrait {
    /**
     * Indicates that the error is a retryable throttling error.
     */
    readonly throttling?: boolean;
}
/**
 * @public
 *
 * Type that is implemented by all Smithy shapes marked with the
 * error trait.
 * @deprecated
 */
export interface SmithyException {
    /**
     * The shape ID name of the exception.
     */
    readonly name: string;
    /**
     * Whether the client or server are at fault.
     */
    readonly $fault: "client" | "server";
    /**
     * The service that encountered the exception.
     */
    readonly $service?: string;
    /**
     * Indicates that an error MAY be retried by the client.
     */
    readonly $retryable?: RetryableTrait;
    /**
     * Reference to low-level HTTP response object.
     */
    readonly $response?: HttpResponse;
}
/**
 * @public
 *
 * @deprecated See {@link https://aws.amazon.com/blogs/developer/service-error-handling-modular-aws-sdk-js/}
 *
 * This type should not be used in your application.
 * Users of the AWS SDK for JavaScript v3 service clients should prefer to
 * use the specific Exception classes corresponding to each operation.
 * These can be found as code in the deserializer for the operation's Command class,
 * or as declarations in the service model file in codegen/sdk-codegen/aws-models.
 *
 * If no exceptions are enumerated by a particular Command operation,
 * the base exception for the service should be used. Each client exports
 * a base ServiceException prefixed with the service name.
 */
export type SdkError = Error & Partial<SmithyException> & Partial<MetadataBearer> & {
    $metadata?: Partial<MetadataBearer>["$metadata"] & {
        /**
         * If present, will have value of true and indicates that the error resulted in a
         * correction of the clock skew, a.k.a. config.systemClockOffset.
         * This is specific to AWS SDK and sigv4.
         */
        readonly clockSkewCorrected?: true;
    };
    cause?: Error;
};

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/signature.d.ts

```typescript
import { Message } from "./eventStream";
import { HttpRequest } from "./http";
/**
 * @public
 *
 * A `Date` object, a unix (epoch) timestamp in seconds, or a string that can be
 * understood by the JavaScript `Date` constructor.
 */
export type DateInput = number | string | Date;
/**
 * @public
 */
export interface SigningArguments {
    /**
     * The date and time to be used as signature metadata. This value should be
     * a Date object, a unix (epoch) timestamp, or a string that can be
     * understood by the JavaScript `Date` constructor.If not supplied, the
     * value returned by `new Date()` will be used.
     */
    signingDate?: DateInput;
    /**
     * The service signing name. It will override the service name of the signer
     * in current invocation
     */
    signingService?: string;
    /**
     * The region name to sign the request. It will override the signing region of the
     * signer in current invocation
     */
    signingRegion?: string;
}
/**
 * @public
 */
export interface RequestSigningArguments extends SigningArguments {
    /**
     * A set of strings whose members represents headers that cannot be signed.
     * All headers in the provided request will have their names converted to
     * lower case and then checked for existence in the unsignableHeaders set.
     */
    unsignableHeaders?: Set<string>;
    /**
     * A set of strings whose members represents headers that should be signed.
     * Any values passed here will override those provided via unsignableHeaders,
     * allowing them to be signed.
     *
     * All headers in the provided request will have their names converted to
     * lower case before signing.
     */
    signableHeaders?: Set<string>;
}
/**
 * @public
 */
export interface RequestPresigningArguments extends RequestSigningArguments {
    /**
     * The number of seconds before the presigned URL expires
     */
    expiresIn?: number;
    /**
     * A set of strings whose representing headers that should not be hoisted
     * to presigned request's query string. If not supplied, the presigner
     * moves all the AWS-specific headers (starting with `x-amz-`) to the request
     * query string. If supplied, these headers remain in the presigned request's
     * header.
     * All headers in the provided request will have their names converted to
     * lower case and then checked for existence in the unhoistableHeaders set.
     */
    unhoistableHeaders?: Set<string>;
    /**
     * This overrides any headers with the same name(s) set by unhoistableHeaders.
     * These headers will be hoisted into the query string and signed.
     */
    hoistableHeaders?: Set<string>;
}
/**
 * @public
 */
export interface EventSigningArguments extends SigningArguments {
    priorSignature: string;
}
/**
 * @public
 */
export interface RequestPresigner {
    /**
     * Signs a request for future use.
     *
     * The request will be valid until either the provided `expiration` time has
     * passed or the underlying credentials have expired.
     *
     * @param requestToSign - The request that should be signed.
     * @param options - Additional signing options.
     */
    presign(requestToSign: HttpRequest, options?: RequestPresigningArguments): Promise<HttpRequest>;
}
/**
 * @public
 *
 * An object that signs request objects with AWS credentials using one of the
 * AWS authentication protocols.
 */
export interface RequestSigner {
    /**
     * Sign the provided request for immediate dispatch.
     */
    sign(requestToSign: HttpRequest, options?: RequestSigningArguments): Promise<HttpRequest>;
}
/**
 * @public
 */
export interface StringSigner {
    /**
     * Sign the provided `stringToSign` for use outside of the context of
     * request signing. Typical uses include signed policy generation.
     */
    sign(stringToSign: string, options?: SigningArguments): Promise<string>;
}
/**
 * @public
 */
export interface FormattedEvent {
    headers: Uint8Array;
    payload: Uint8Array;
}
/**
 * @public
 */
export interface EventSigner {
    /**
     * Sign the individual event of the event stream.
     */
    sign(event: FormattedEvent, options: EventSigningArguments): Promise<string>;
}
/**
 * @public
 */
export interface SignableMessage {
    message: Message;
    priorSignature: string;
}
/**
 * @public
 */
export interface SignedMessage {
    message: Message;
    signature: string;
}
/**
 * @public
 */
export interface MessageSigner {
    signMessage(message: SignableMessage, args: SigningArguments): Promise<SignedMessage>;
    sign(event: SignableMessage, options: SigningArguments): Promise<SignedMessage>;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/stream.d.ts

```typescript
import { ChecksumConstructor } from "./checksum";
import { HashConstructor, StreamHasher } from "./crypto";
import { BodyLengthCalculator, Encoder } from "./util";
/**
 * @public
 */
export interface GetAwsChunkedEncodingStreamOptions {
    base64Encoder?: Encoder;
    bodyLengthChecker: BodyLengthCalculator;
    checksumAlgorithmFn?: ChecksumConstructor | HashConstructor;
    checksumLocationName?: string;
    streamHasher?: StreamHasher;
}
/**
 * @public
 *
 * A function that returns Readable Stream which follows aws-chunked encoding stream.
 * It optionally adds checksum if options are provided.
 */
export interface GetAwsChunkedEncodingStream<StreamType = any> {
    (readableStream: StreamType, options: GetAwsChunkedEncodingStreamOptions): StreamType;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/streaming-payload/streaming-blob-common-types.d.ts

```typescript
import { Readable } from "stream";
import { BlobOptionalType, ReadableStreamOptionalType } from "../externals-check/browser-externals-check";
/**
 * @public
 *
 * This is the union representing the modeled blob type with streaming trait
 * in a generic format that does not relate to HTTP input or output payloads.
 *
 * Note: the non-streaming blob type is represented by Uint8Array, but because
 * the streaming blob type is always in the request/response paylod, it has
 * historically been handled with different types.
 *
 * @see https://smithy.io/2.0/spec/simple-types.html#blob
 *
 * For compatibility with its historical representation, it must contain at least
 * Readble (Node.js), Blob (browser), and ReadableStream (browser).
 *
 * @see StreamingPayloadInputTypes for FAQ about mixing types from multiple environments.
 */
export type StreamingBlobTypes = NodeJsRuntimeStreamingBlobTypes | BrowserRuntimeStreamingBlobTypes;
/**
 * @public
 *
 * Node.js streaming blob type.
 */
export type NodeJsRuntimeStreamingBlobTypes = Readable;
/**
 * @public
 *
 * Browser streaming blob types.
 */
export type BrowserRuntimeStreamingBlobTypes = ReadableStreamOptionalType | BlobOptionalType;

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/streaming-payload/streaming-blob-payload-input-types.d.ts

```typescript
import { Readable } from "stream";
import { BlobOptionalType, ReadableStreamOptionalType } from "../externals-check/browser-externals-check";
/**
 * @public
 *
 * This union represents a superset of the compatible types you
 * can use for streaming payload inputs.
 *
 * FAQ:
 * Why does the type union mix mutually exclusive runtime types, namely
 * Node.js and browser types?
 *
 * There are several reasons:
 * 1. For backwards compatibility.
 * 2. As a convenient compromise solution so that users in either environment may use the types
 *    without customization.
 * 3. The SDK does not have static type information about the exact implementation
 *    of the HTTP RequestHandler being used in your client(s) (e.g. fetch, XHR, node:http, or node:http2),
 *    given that it is chosen at runtime. There are multiple possible request handlers
 *    in both the Node.js and browser runtime environments.
 *
 *    Rather than restricting the type to a known common format (Uint8Array, for example)
 *    which doesn't include a universal streaming format in the currently supported Node.js versions,
 *    the type declaration is widened to multiple possible formats.
 *    It is up to the user to ultimately select a compatible format with the
 *    runtime and HTTP handler implementation they are using.
 *
 * Usage:
 *    The typical solution we expect users to have is to manually narrow the
 *    type when needed, picking the appropriate one out of the union according to the
 *    runtime environment and specific request handler.
 *    There is also the type utility "NodeJsClient", "BrowserClient" and more
 *    exported from this package. These can be applied at the client level
 *    to pre-narrow these streaming payload blobs. For usage see the readme.md
 *    in the root of the \@smithy/types NPM package.
 */
export type StreamingBlobPayloadInputTypes = NodeJsRuntimeStreamingBlobPayloadInputTypes | BrowserRuntimeStreamingBlobPayloadInputTypes;
/**
 * @public
 *
 * Streaming payload input types in the Node.js environment.
 * These are derived from the types compatible with the request body used by node:http.
 *
 * Note: not all types are signable by the standard SignatureV4 signer when
 * used as the request body. For example, in Node.js a Readable stream
 * is not signable by the default signer.
 * They are included in the union because it may be intended in some cases,
 * but the expected types are primarily string, Uint8Array, and Buffer.
 *
 * Additional details may be found in the internal
 * function "getPayloadHash" in the SignatureV4 module.
 */
export type NodeJsRuntimeStreamingBlobPayloadInputTypes = string | Uint8Array | Buffer | Readable;
/**
 * @public
 *
 * Streaming payload input types in the browser environment.
 * These are derived from the types compatible with fetch's Request.body.
 */
export type BrowserRuntimeStreamingBlobPayloadInputTypes = string | Uint8Array | ReadableStreamOptionalType | BlobOptionalType;

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/streaming-payload/streaming-blob-payload-output-types.d.ts

```typescript
import { IncomingMessage } from "http";
import { Readable } from "stream";
import { BlobOptionalType, ReadableStreamOptionalType } from "../externals-check/browser-externals-check";
import { SdkStream } from "../serde";
/**
 * @public
 *
 * This union represents a superset of the types you may receive
 * in streaming payload outputs.
 *
 * @see StreamingPayloadInputTypes for FAQ about mixing types from multiple environments.
 *
 * To highlight the upstream docs about the SdkStream mixin:
 *
 * The interface contains mix-in (via Object.assign) methods to transform the runtime-specific
 * stream implementation to specified format. Each stream can ONLY be transformed
 * once.
 *
 * The available methods are described on the SdkStream type via SdkStreamMixin.
 */
export type StreamingBlobPayloadOutputTypes = NodeJsRuntimeStreamingBlobPayloadOutputTypes | BrowserRuntimeStreamingBlobPayloadOutputTypes;
/**
 * @public
 *
 * Streaming payload output types in the Node.js environment.
 *
 * This is by default the IncomingMessage type from node:http responses when
 * using the default node-http-handler in Node.js environments.
 *
 * It can be other Readable types like node:http2's ClientHttp2Stream
 * such as when using the node-http2-handler.
 *
 * The SdkStreamMixin adds methods on this type to help transform (collect) it to
 * other formats.
 */
export type NodeJsRuntimeStreamingBlobPayloadOutputTypes = SdkStream<IncomingMessage | Readable>;
/**
 * @public
 *
 * Streaming payload output types in the browser environment.
 *
 * This is by default fetch's Response.body type (ReadableStream) when using
 * the default fetch-http-handler in browser-like environments.
 *
 * It may be a Blob, such as when using the XMLHttpRequest handler
 * and receiving an arraybuffer response body.
 *
 * The SdkStreamMixin adds methods on this type to help transform (collect) it to
 * other formats.
 */
export type BrowserRuntimeStreamingBlobPayloadOutputTypes = SdkStream<ReadableStreamOptionalType | BlobOptionalType>;

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/transfer.d.ts

```typescript
/**
 * @public
 */
export type RequestHandlerOutput<ResponseType> = {
    response: ResponseType;
};
/**
 * @public
 */
export interface RequestHandler<RequestType, ResponseType, HandlerOptions = {}> {
    /**
     * metadata contains information of a handler. For example
     * 'h2' refers this handler is for handling HTTP/2 requests,
     * whereas 'h1' refers handling HTTP1 requests
     */
    metadata?: RequestHandlerMetadata;
    destroy?: () => void;
    handle: (request: RequestType, handlerOptions?: HandlerOptions) => Promise<RequestHandlerOutput<ResponseType>>;
}
/**
 * @public
 */
export interface RequestHandlerMetadata {
    handlerProtocol: RequestHandlerProtocol | string;
}
/**
 * @public
 * Values from ALPN Protocol IDs.
 * @see https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids
 */
export declare enum RequestHandlerProtocol {
    HTTP_0_9 = "http/0.9",
    HTTP_1_0 = "http/1.0",
    TDS_8_0 = "tds/8.0"
}
/**
 * @public
 */
export interface RequestContext {
    destination: URL;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/transform/client-method-transforms.d.ts

```typescript
import { CommandIO } from "../command";
import { MetadataBearer } from "../response";
import { StreamingBlobPayloadOutputTypes } from "../streaming-payload/streaming-blob-payload-output-types";
import { Transform } from "./type-transform";
/**
 * @internal
 *
 * Narrowed version of InvokeFunction used in Client::send.
 */
export interface NarrowedInvokeFunction<NarrowType, HttpHandlerOptions, InputTypes extends object, OutputTypes extends MetadataBearer> {
    <InputType extends InputTypes, OutputType extends OutputTypes>(command: CommandIO<InputType, OutputType>, options?: HttpHandlerOptions): Promise<Transform<OutputType, StreamingBlobPayloadOutputTypes | undefined, NarrowType>>;
    <InputType extends InputTypes, OutputType extends OutputTypes>(command: CommandIO<InputType, OutputType>, cb: (err: unknown, data?: Transform<OutputType, StreamingBlobPayloadOutputTypes | undefined, NarrowType>) => void): void;
    <InputType extends InputTypes, OutputType extends OutputTypes>(command: CommandIO<InputType, OutputType>, options: HttpHandlerOptions, cb: (err: unknown, data?: Transform<OutputType, StreamingBlobPayloadOutputTypes | undefined, NarrowType>) => void): void;
    <InputType extends InputTypes, OutputType extends OutputTypes>(command: CommandIO<InputType, OutputType>, options?: HttpHandlerOptions, cb?: (err: unknown, data?: Transform<OutputType, StreamingBlobPayloadOutputTypes | undefined, NarrowType>) => void): Promise<Transform<OutputType, StreamingBlobPayloadOutputTypes | undefined, NarrowType>> | void;
}
/**
 * @internal
 *
 * Narrowed version of InvokeMethod used in aggregated Client methods.
 */
export interface NarrowedInvokeMethod<NarrowType, HttpHandlerOptions, InputType extends object, OutputType extends MetadataBearer> {
    (input: InputType, options?: HttpHandlerOptions): Promise<Transform<OutputType, StreamingBlobPayloadOutputTypes | undefined, NarrowType>>;
    (input: InputType, cb: (err: unknown, data?: Transform<OutputType, StreamingBlobPayloadOutputTypes | undefined, NarrowType>) => void): void;
    (input: InputType, options: HttpHandlerOptions, cb: (err: unknown, data?: Transform<OutputType, StreamingBlobPayloadOutputTypes | undefined, NarrowType>) => void): void;
    (input: InputType, options?: HttpHandlerOptions, cb?: (err: unknown, data?: OutputType) => void): Promise<Transform<OutputType, StreamingBlobPayloadOutputTypes | undefined, NarrowType>> | void;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/transform/client-payload-blob-type-narrow.d.ts

```typescript
import { IncomingMessage } from "http";
import { ClientHttp2Stream } from "http2";
import { InvokeMethod } from "../client";
import { GetOutputType } from "../command";
import { HttpHandlerOptions } from "../http";
import { SdkStream } from "../serde";
import { BrowserRuntimeStreamingBlobPayloadInputTypes, NodeJsRuntimeStreamingBlobPayloadInputTypes, StreamingBlobPayloadInputTypes } from "../streaming-payload/streaming-blob-payload-input-types";
import { StreamingBlobPayloadOutputTypes } from "../streaming-payload/streaming-blob-payload-output-types";
import { NarrowedInvokeMethod } from "./client-method-transforms";
import { Transform } from "./type-transform";
/**
 * @public
 *
 * Creates a type with a given client type that narrows payload blob output
 * types to SdkStream<IncomingMessage>.
 *
 * This can be used for clients with the NodeHttpHandler requestHandler,
 * the default in Node.js when not using HTTP2.
 *
 * Usage example:
 * ```typescript
 * const client = new YourClient({}) as NodeJsClient<YourClient>;
 * ```
 */
export type NodeJsClient<ClientType extends object> = NarrowPayloadBlobTypes<NodeJsRuntimeStreamingBlobPayloadInputTypes, SdkStream<IncomingMessage>, ClientType>;
/**
 * @public
 * Variant of NodeJsClient for node:http2.
 */
export type NodeJsHttp2Client<ClientType extends object> = NarrowPayloadBlobTypes<NodeJsRuntimeStreamingBlobPayloadInputTypes, SdkStream<ClientHttp2Stream>, ClientType>;
/**
 * @public
 *
 * Creates a type with a given client type that narrows payload blob output
 * types to SdkStream<ReadableStream>.
 *
 * This can be used for clients with the FetchHttpHandler requestHandler,
 * which is the default in browser environments.
 *
 * Usage example:
 * ```typescript
 * const client = new YourClient({}) as BrowserClient<YourClient>;
 * ```
 */
export type BrowserClient<ClientType extends object> = NarrowPayloadBlobTypes<BrowserRuntimeStreamingBlobPayloadInputTypes, SdkStream<ReadableStream>, ClientType>;
/**
 * @public
 *
 * Variant of BrowserClient for XMLHttpRequest.
 */
export type BrowserXhrClient<ClientType extends object> = NarrowPayloadBlobTypes<BrowserRuntimeStreamingBlobPayloadInputTypes, SdkStream<ReadableStream | Blob>, ClientType>;
/**
 * @public
 *
 * @deprecated use NarrowPayloadBlobTypes<I, O, ClientType>.
 *
 * Narrow a given Client's blob payload outputs to the given type T.
 */
export type NarrowPayloadBlobOutputType<T, ClientType extends object> = {
    [key in keyof ClientType]: [
        ClientType[key]
    ] extends [
        InvokeMethod<infer FunctionInputTypes, infer FunctionOutputTypes>
    ] ? NarrowedInvokeMethod<T, HttpHandlerOptions, FunctionInputTypes, FunctionOutputTypes> : ClientType[key];
} & {
    send<Command>(command: Command, options?: any): Promise<Transform<GetOutputType<Command>, StreamingBlobPayloadOutputTypes | undefined, T>>;
};
/**
 * @public
 *
 * Narrow a Client's blob payload input and output types to I and O.
 */
export type NarrowPayloadBlobTypes<I, O, ClientType extends object> = {
    [key in keyof ClientType]: [
        ClientType[key]
    ] extends [
        InvokeMethod<infer FunctionInputTypes, infer FunctionOutputTypes>
    ] ? NarrowedInvokeMethod<O, HttpHandlerOptions, Transform<FunctionInputTypes, StreamingBlobPayloadInputTypes | undefined, I>, FunctionOutputTypes> : ClientType[key];
} & {
    send<Command>(command: Command, options?: any): Promise<Transform<GetOutputType<Command>, StreamingBlobPayloadOutputTypes | undefined, O>>;
};

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/transform/exact.d.ts

```typescript
/**
 * @internal
 *
 * Checks that A and B extend each other.
 */
export type Exact<A, B> = [
    A
] extends [
    B
] ? ([
    B
] extends [
    A
] ? true : false) : false;

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/transform/mutable.d.ts

```typescript
/**
 * @internal
 */
export type Mutable<Type> = {
    -readonly [Property in keyof Type]: Type[Property];
};

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/transform/no-undefined.d.ts

```typescript
import { InvokeMethod, InvokeMethodOptionalArgs } from "../client";
import { GetOutputType } from "../command";
import { DocumentType } from "../shapes";
/**
 * @public
 *
 * This type is intended as a type helper for generated clients.
 * When initializing client, cast it to this type by passing
 * the client constructor type as the type parameter.
 *
 * It will then recursively remove "undefined" as a union type from all
 * input and output shapes' members. Note, this does not affect
 * any member that is optional (?) such as outputs with no required members.
 *
 * @example
 * ```ts
 * const client = new Client({}) as AssertiveClient<Client>;
 * ```
 */
export type AssertiveClient<Client extends object> = NarrowClientIOTypes<Client>;
/**
 * @public
 *
 * This is similar to AssertiveClient but additionally changes all
 * output types to (recursive) Required<T> so as to bypass all output nullability guards.
 */
export type UncheckedClient<Client extends object> = UncheckedClientOutputTypes<Client>;
/**
 * @internal
 *
 * Excludes undefined recursively.
 */
export type NoUndefined<T> = T extends Function ? T : T extends DocumentType ? T : [
    T
] extends [
    object
] ? {
    [key in keyof T]: NoUndefined<T[key]>;
} : Exclude<T, undefined>;
/**
 * @internal
 *
 * Excludes undefined and optional recursively.
 */
export type RecursiveRequired<T> = T extends Function ? T : T extends DocumentType ? T : [
    T
] extends [
    object
] ? {
    [key in keyof T]-?: RecursiveRequired<T[key]>;
} : Exclude<T, undefined>;
/**
 * @internal
 *
 * Removes undefined from unions.
 */
type NarrowClientIOTypes<ClientType extends object> = {
    [key in keyof ClientType]: [
        ClientType[key]
    ] extends [
        InvokeMethodOptionalArgs<infer FunctionInputTypes, infer FunctionOutputTypes>
    ] ? InvokeMethodOptionalArgs<NoUndefined<FunctionInputTypes>, NoUndefined<FunctionOutputTypes>> : [
        ClientType[key]
    ] extends [
        InvokeMethod<infer FunctionInputTypes, infer FunctionOutputTypes>
    ] ? InvokeMethod<NoUndefined<FunctionInputTypes>, NoUndefined<FunctionOutputTypes>> : ClientType[key];
} & {
    send<Command>(command: Command, options?: any): Promise<NoUndefined<GetOutputType<Command>>>;
};
/**
 * @internal
 *
 * Removes undefined from unions and adds yolo output types.
 */
type UncheckedClientOutputTypes<ClientType extends object> = {
    [key in keyof ClientType]: [
        ClientType[key]
    ] extends [
        InvokeMethodOptionalArgs<infer FunctionInputTypes, infer FunctionOutputTypes>
    ] ? InvokeMethodOptionalArgs<NoUndefined<FunctionInputTypes>, RecursiveRequired<FunctionOutputTypes>> : [
        ClientType[key]
    ] extends [
        InvokeMethod<infer FunctionInputTypes, infer FunctionOutputTypes>
    ] ? InvokeMethod<NoUndefined<FunctionInputTypes>, RecursiveRequired<FunctionOutputTypes>> : ClientType[key];
} & {
    send<Command>(command: Command, options?: any): Promise<RecursiveRequired<NoUndefined<GetOutputType<Command>>>>;
};
export {};

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/transform/type-transform.d.ts

```typescript
/**
 * @public
 *
 * Transforms any members of the object T having type FromType
 * to ToType. This applies only to exact type matches.
 *
 * This is for the case where FromType is a union and only those fields
 * matching the same union should be transformed.
 */
export type Transform<T, FromType, ToType> = RecursiveTransformExact<T, FromType, ToType>;
/**
 * @internal
 *
 * Returns ToType if T matches exactly with FromType.
 */
type TransformExact<T, FromType, ToType> = [
    T
] extends [
    FromType
] ? ([
    FromType
] extends [
    T
] ? ToType : T) : T;
/**
 * @internal
 *
 * Applies TransformExact to members of an object recursively.
 */
type RecursiveTransformExact<T, FromType, ToType> = T extends Function ? T : T extends object ? {
    [key in keyof T]: [
        T[key]
    ] extends [
        FromType
    ] ? [
        FromType
    ] extends [
        T[key]
    ] ? ToType : RecursiveTransformExact<T[key], FromType, ToType> : RecursiveTransformExact<T[key], FromType, ToType>;
} : TransformExact<T, FromType, ToType>;
export {};

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/uri.d.ts

```typescript
import { QueryParameterBag } from "./http";
/**
 * @internal
 *
 * Represents the components parts of a Uniform Resource Identifier used to
 * construct the target location of a Request.
 */
export type URI = {
    protocol: string;
    hostname: string;
    port?: number;
    path: string;
    query?: QueryParameterBag;
    username?: string;
    password?: string;
    fragment?: string;
};

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/util.d.ts

```typescript
import { Endpoint } from "./http";
import { FinalizeHandler, FinalizeHandlerArguments, FinalizeHandlerOutput } from "./middleware";
import { MetadataBearer } from "./response";
/**
 * @public
 *
 * A generic which checks if Type1 is exactly same as Type2.
 */
export type Exact<Type1, Type2> = [
    Type1
] extends [
    Type2
] ? ([
    Type2
] extends [
    Type1
] ? true : false) : false;
/**
 * @public
 *
 * A function that, given a Uint8Array of bytes, can produce a string
 * representation thereof. The function may optionally attempt to
 * convert other input types to Uint8Array before encoding.
 *
 * @example An encoder function that converts bytes to hexadecimal
 * representation would return `'hello'` when given
 * `new Uint8Array([104, 101, 108, 108, 111])`.
 */
export interface Encoder {
    /**
     * Caution: the `any` type on the input is for backwards compatibility.
     * Runtime support is limited to Uint8Array and string by default.
     *
     * You may choose to support more encoder input types if overriding the default
     * implementations.
     */
    (input: Uint8Array | string | any): string;
}
/**
 * @public
 *
 * A function that, given a string, can derive the bytes represented by that
 * string.
 *
 * @example A decoder function that converts bytes to hexadecimal
 * representation would return `new Uint8Array([104, 101, 108, 108, 111])` when
 * given the string `'hello'`.
 */
export interface Decoder {
    (input: string): Uint8Array;
}
/**
 * @public
 *
 * A function that, when invoked, returns a promise that will be fulfilled with
 * a value of type T.
 *
 * @example A function that reads credentials from shared SDK configuration
 * files, assuming roles and collecting MFA tokens as necessary.
 */
export interface Provider<T> {
    (): Promise<T>;
}
/**
 * @public
 *
 * A tuple that represents an API name and optional version
 * of a library built using the AWS SDK.
 */
export type UserAgentPair = [
    /*name*/ string,
    /*version*/ string
];
/**
 * @public
 *
 * User agent data that to be put into the request's user
 * agent.
 */
export type UserAgent = UserAgentPair[];
/**
 * @public
 *
 * Parses a URL in string form into an Endpoint object.
 */
export interface UrlParser {
    (url: string | URL): Endpoint;
}
/**
 * @public
 *
 * A function that, when invoked, returns a promise that will be fulfilled with
 * a value of type T. It memoizes the result from the previous invocation
 * instead of calling the underlying resources every time.
 *
 * You can force the provider to refresh the memoized value by invoke the
 * function with optional parameter hash with `forceRefresh` boolean key and
 * value `true`.
 *
 * @example A function that reads credentials from IMDS service that could
 * return expired credentials. The SDK will keep using the expired credentials
 * until an unretryable service error requiring a force refresh of the
 * credentials.
 */
export interface MemoizedProvider<T> {
    (options?: {
        forceRefresh?: boolean;
    }): Promise<T>;
}
/**
 * @public
 *
 * A function that, given a request body, determines the
 * length of the body. This is used to determine the Content-Length
 * that should be sent with a request.
 *
 * @example A function that reads a file stream and calculates
 * the size of the file.
 */
export interface BodyLengthCalculator {
    (body: any): number | undefined;
}
/**
 * @public
 *
 * Object containing regionalization information of
 * AWS services.
 */
export interface RegionInfo {
    hostname: string;
    partition: string;
    path?: string;
    signingService?: string;
    signingRegion?: string;
}
/**
 * @public
 *
 * Options to pass when calling {@link RegionInfoProvider}
 */
export interface RegionInfoProviderOptions {
    /**
     * Enables IPv6/IPv4 dualstack endpoint.
     * @defaultValue false
     */
    useDualstackEndpoint: boolean;
    /**
     * Enables FIPS compatible endpoints.
     * @defaultValue false
     */
    useFipsEndpoint: boolean;
}
/**
 * @public
 *
 * Function returns designated service's regionalization
 * information from given region. Each service client
 * comes with its regionalization provider. it serves
 * to provide the default values of related configurations
 */
export interface RegionInfoProvider {
    (region: string, options?: RegionInfoProviderOptions): Promise<RegionInfo | undefined>;
}
/**
 * @public
 *
 * Interface that specifies the retry behavior
 */
export interface RetryStrategy {
    /**
     * The retry mode describing how the retry strategy control the traffic flow.
     */
    mode?: string;
    /**
     * the retry behavior the will invoke the next handler and handle the retry accordingly.
     * This function should also update the $metadata from the response accordingly.
     * @see {@link ResponseMetadata}
     */
    retry: <Input extends object, Output extends MetadataBearer>(next: FinalizeHandler<Input, Output>, args: FinalizeHandlerArguments<Input>) => Promise<FinalizeHandlerOutput<Output>>;
}
/**
 * @public
 *
 * Indicates the parameter may be omitted if the parameter object T
 * is equivalent to a Partial<T>, i.e. all properties optional.
 */
export type OptionalParameter<T> = Exact<Partial<T>, T> extends true ? [
] | [
    T
] : [
    T
];

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/ts3.4/waiter.d.ts

```typescript
import { AbortController as DeprecatedAbortController } from "./abort";
/**
 * @public
 */
export interface WaiterConfiguration<Client> {
    /**
     * Required service client
     */
    client: Client;
    /**
     * The amount of time in seconds a user is willing to wait for a waiter to complete.
     */
    maxWaitTime: number;
    /**
     * @deprecated Use abortSignal
     * Abort controller. Used for ending the waiter early.
     */
    abortController?: AbortController | DeprecatedAbortController;
    /**
     * Abort Signal. Used for ending the waiter early.
     */
    abortSignal?: AbortController["signal"] | DeprecatedAbortController["signal"];
    /**
     * The minimum amount of time to delay between retries in seconds. This is the
     * floor of the exponential backoff. This value defaults to service default
     * if not specified. This value MUST be less than or equal to maxDelay and greater than 0.
     */
    minDelay?: number;
    /**
     * The maximum amount of time to delay between retries in seconds. This is the
     * ceiling of the exponential backoff. This value defaults to service default
     * if not specified. If specified, this value MUST be greater than or equal to 1.
     */
    maxDelay?: number;
}

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/uri.d.ts

```typescript
import type { QueryParameterBag } from "./http";
/**
 * @internal
 *
 * Represents the components parts of a Uniform Resource Identifier used to
 * construct the target location of a Request.
 */
export type URI = {
    protocol: string;
    hostname: string;
    port?: number;
    path: string;
    query?: QueryParameterBag;
    username?: string;
    password?: string;
    fragment?: string;
};

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/util.d.ts

```typescript
import type { Endpoint } from "./http";
import type { FinalizeHandler, FinalizeHandlerArguments, FinalizeHandlerOutput } from "./middleware";
import type { MetadataBearer } from "./response";
/**
 * @public
 *
 * A generic which checks if Type1 is exactly same as Type2.
 */
export type Exact<Type1, Type2> = [Type1] extends [Type2] ? ([Type2] extends [Type1] ? true : false) : false;
/**
 * @public
 *
 * A function that, given a Uint8Array of bytes, can produce a string
 * representation thereof. The function may optionally attempt to
 * convert other input types to Uint8Array before encoding.
 *
 * @example An encoder function that converts bytes to hexadecimal
 * representation would return `'hello'` when given
 * `new Uint8Array([104, 101, 108, 108, 111])`.
 */
export interface Encoder {
    /**
     * Caution: the `any` type on the input is for backwards compatibility.
     * Runtime support is limited to Uint8Array and string by default.
     *
     * You may choose to support more encoder input types if overriding the default
     * implementations.
     */
    (input: Uint8Array | string | any): string;
}
/**
 * @public
 *
 * A function that, given a string, can derive the bytes represented by that
 * string.
 *
 * @example A decoder function that converts bytes to hexadecimal
 * representation would return `new Uint8Array([104, 101, 108, 108, 111])` when
 * given the string `'hello'`.
 */
export interface Decoder {
    (input: string): Uint8Array;
}
/**
 * @public
 *
 * A function that, when invoked, returns a promise that will be fulfilled with
 * a value of type T.
 *
 * @example A function that reads credentials from shared SDK configuration
 * files, assuming roles and collecting MFA tokens as necessary.
 */
export interface Provider<T> {
    (): Promise<T>;
}
/**
 * @public
 *
 * A tuple that represents an API name and optional version
 * of a library built using the AWS SDK.
 */
export type UserAgentPair = [name: string, version?: string];
/**
 * @public
 *
 * User agent data that to be put into the request's user
 * agent.
 */
export type UserAgent = UserAgentPair[];
/**
 * @public
 *
 * Parses a URL in string form into an Endpoint object.
 */
export interface UrlParser {
    (url: string | URL): Endpoint;
}
/**
 * @public
 *
 * A function that, when invoked, returns a promise that will be fulfilled with
 * a value of type T. It memoizes the result from the previous invocation
 * instead of calling the underlying resources every time.
 *
 * You can force the provider to refresh the memoized value by invoke the
 * function with optional parameter hash with `forceRefresh` boolean key and
 * value `true`.
 *
 * @example A function that reads credentials from IMDS service that could
 * return expired credentials. The SDK will keep using the expired credentials
 * until an unretryable service error requiring a force refresh of the
 * credentials.
 */
export interface MemoizedProvider<T> {
    (options?: {
        forceRefresh?: boolean;
    }): Promise<T>;
}
/**
 * @public
 *
 * A function that, given a request body, determines the
 * length of the body. This is used to determine the Content-Length
 * that should be sent with a request.
 *
 * @example A function that reads a file stream and calculates
 * the size of the file.
 */
export interface BodyLengthCalculator {
    (body: any): number | undefined;
}
/**
 * @public
 *
 * Object containing regionalization information of
 * AWS services.
 */
export interface RegionInfo {
    hostname: string;
    partition: string;
    path?: string;
    signingService?: string;
    signingRegion?: string;
}
/**
 * @public
 *
 * Options to pass when calling {@link RegionInfoProvider}
 */
export interface RegionInfoProviderOptions {
    /**
     * Enables IPv6/IPv4 dualstack endpoint.
     * @defaultValue false
     */
    useDualstackEndpoint: boolean;
    /**
     * Enables FIPS compatible endpoints.
     * @defaultValue false
     */
    useFipsEndpoint: boolean;
}
/**
 * @public
 *
 * Function returns designated service's regionalization
 * information from given region. Each service client
 * comes with its regionalization provider. it serves
 * to provide the default values of related configurations
 */
export interface RegionInfoProvider {
    (region: string, options?: RegionInfoProviderOptions): Promise<RegionInfo | undefined>;
}
/**
 * @public
 *
 * Interface that specifies the retry behavior
 */
export interface RetryStrategy {
    /**
     * The retry mode describing how the retry strategy control the traffic flow.
     */
    mode?: string;
    /**
     * the retry behavior the will invoke the next handler and handle the retry accordingly.
     * This function should also update the $metadata from the response accordingly.
     * @see {@link ResponseMetadata}
     */
    retry: <Input extends object, Output extends MetadataBearer>(next: FinalizeHandler<Input, Output>, args: FinalizeHandlerArguments<Input>) => Promise<FinalizeHandlerOutput<Output>>;
}
/**
 * @public
 *
 * Indicates the parameter may be omitted if the parameter object T
 * is equivalent to a Partial<T>, i.e. all properties optional.
 */
export type OptionalParameter<T> = Exact<Partial<T>, T> extends true ? [] | [T] : [T];

```

## ./lib/lambda/node_modules/@smithy/types/dist-types/waiter.d.ts

```typescript
import type { AbortController as DeprecatedAbortController } from "./abort";
/**
 * @public
 */
export interface WaiterConfiguration<Client> {
    /**
     * Required service client
     */
    client: Client;
    /**
     * The amount of time in seconds a user is willing to wait for a waiter to complete.
     */
    maxWaitTime: number;
    /**
     * @deprecated Use abortSignal
     * Abort controller. Used for ending the waiter early.
     */
    abortController?: AbortController | DeprecatedAbortController;
    /**
     * Abort Signal. Used for ending the waiter early.
     */
    abortSignal?: AbortController["signal"] | DeprecatedAbortController["signal"];
    /**
     * The minimum amount of time to delay between retries in seconds. This is the
     * floor of the exponential backoff. This value defaults to service default
     * if not specified. This value MUST be less than or equal to maxDelay and greater than 0.
     */
    minDelay?: number;
    /**
     * The maximum amount of time to delay between retries in seconds. This is the
     * ceiling of the exponential backoff. This value defaults to service default
     * if not specified. If specified, this value MUST be greater than or equal to 1.
     */
    maxDelay?: number;
}

```

## ./lib/lambda/node_modules/@smithy/types/package.json

```json
{
  "name": "@smithy/types",
  "version": "4.8.0",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline types",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "rimraf dist-types/ts3.4 && downlevel-dts dist-types dist-types/ts3.4 && node scripts/downlevel",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../../.prettierignore --write \"**/*.{ts,md,json}\"",
    "test": "yarn g:tsc -p tsconfig.test.json",
    "extract:docs": "api-extractor run --local"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "author": {
    "name": "AWS Smithy Team",
    "email": "",
    "url": "https://smithy.io"
  },
  "license": "Apache-2.0",
  "sideEffects": false,
  "dependencies": {
    "tslib": "^2.6.2"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<=4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/smithy-lang/smithy-typescript/tree/main/packages/types",
  "repository": {
    "type": "git",
    "url": "https://github.com/smithy-lang/smithy-typescript.git",
    "directory": "packages/types"
  },
  "devDependencies": {
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  }
}
```

## ./lib/lambda/node_modules/@smithy/url-parser/dist-types/index.d.ts

```typescript
import type { UrlParser } from "@smithy/types";
/**
 * @internal
 */
export declare const parseUrl: UrlParser;

```

## ./lib/lambda/node_modules/@smithy/url-parser/dist-types/ts3.4/index.d.ts

```typescript
import { UrlParser } from "@smithy/types";
/**
 * @internal
 */
export declare const parseUrl: UrlParser;

```

## ./lib/lambda/node_modules/@smithy/url-parser/package.json

```json
{
  "name": "@smithy/url-parser",
  "version": "4.2.3",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline url-parser",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "rimraf dist-types/ts3.4 && downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../../.prettierignore --write \"**/*.{ts,md,json}\"",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "sideEffects": false,
  "dependencies": {
    "@smithy/querystring-parser": "^4.2.3",
    "@smithy/types": "^4.8.0",
    "tslib": "^2.6.2"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/smithy-lang/smithy-typescript/tree/main/packages/url-parser",
  "repository": {
    "type": "git",
    "url": "https://github.com/smithy-lang/smithy-typescript.git",
    "directory": "packages/url-parser"
  },
  "devDependencies": {
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  },
  "engines": {
    "node": ">=18.0.0"
  }
}
```

## ./lib/lambda/node_modules/@smithy/util-base64/dist-types/constants.browser.d.ts

```typescript
export declare const alphabetByEncoding: Record<string, number>;
export declare const alphabetByValue: Array<string>;
export declare const bitsPerLetter = 6;
export declare const bitsPerByte = 8;
export declare const maxLetterValue = 63;

```

## ./lib/lambda/node_modules/@smithy/util-base64/dist-types/fromBase64.browser.d.ts

```typescript
/**
 * Converts a base-64 encoded string to a Uint8Array of bytes.
 *
 * @param input The base-64 encoded string
 *
 * @see https://tools.ietf.org/html/rfc4648#section-4
 */
export declare const fromBase64: (input: string) => Uint8Array;

```

## ./lib/lambda/node_modules/@smithy/util-base64/dist-types/fromBase64.d.ts

```typescript
/**
 * Converts a base-64 encoded string to a Uint8Array of bytes using Node.JS's
 * `buffer` module.
 *
 * @param input The base-64 encoded string
 */
export declare const fromBase64: (input: string) => Uint8Array;

```

## ./lib/lambda/node_modules/@smithy/util-base64/dist-types/index.d.ts

```typescript
export * from "./fromBase64";
export * from "./toBase64";

```

## ./lib/lambda/node_modules/@smithy/util-base64/dist-types/toBase64.browser.d.ts

```typescript
/**
 * Converts a Uint8Array of binary data or a utf-8 string to a base-64 encoded string.
 *
 * @param _input - the binary data or string to encode.
 * @returns base64 string.
 *
 * @see https://tools.ietf.org/html/rfc4648#section-4
 */
export declare function toBase64(_input: Uint8Array | string): string;

```

## ./lib/lambda/node_modules/@smithy/util-base64/dist-types/toBase64.d.ts

```typescript
/**
 * Converts a Uint8Array of binary data or a utf-8 string to a base-64 encoded string using
 * Node.JS's `buffer` module.
 *
 * @param _input - the binary data or string to encode.
 * @returns base64 string.
 */
export declare const toBase64: (_input: Uint8Array | string) => string;

```

## ./lib/lambda/node_modules/@smithy/util-base64/dist-types/ts3.4/constants.browser.d.ts

```typescript
export declare const alphabetByEncoding: Record<string, number>;
export declare const alphabetByValue: Array<string>;
export declare const bitsPerLetter = 6;
export declare const bitsPerByte = 8;
export declare const maxLetterValue = 63;

```

## ./lib/lambda/node_modules/@smithy/util-base64/dist-types/ts3.4/fromBase64.browser.d.ts

```typescript
/**
 * Converts a base-64 encoded string to a Uint8Array of bytes.
 *
 * @param input The base-64 encoded string
 *
 * @see https://tools.ietf.org/html/rfc4648#section-4
 */
export declare const fromBase64: (input: string) => Uint8Array;

```

## ./lib/lambda/node_modules/@smithy/util-base64/dist-types/ts3.4/fromBase64.d.ts

```typescript
/**
 * Converts a base-64 encoded string to a Uint8Array of bytes using Node.JS's
 * `buffer` module.
 *
 * @param input The base-64 encoded string
 */
export declare const fromBase64: (input: string) => Uint8Array;

```

## ./lib/lambda/node_modules/@smithy/util-base64/dist-types/ts3.4/index.d.ts

```typescript
export * from "./fromBase64";
export * from "./toBase64";

```

## ./lib/lambda/node_modules/@smithy/util-base64/dist-types/ts3.4/toBase64.browser.d.ts

```typescript
/**
 * Converts a Uint8Array of binary data or a utf-8 string to a base-64 encoded string.
 *
 * @param _input - the binary data or string to encode.
 * @returns base64 string.
 *
 * @see https://tools.ietf.org/html/rfc4648#section-4
 */
export declare function toBase64(_input: Uint8Array | string): string;

```

## ./lib/lambda/node_modules/@smithy/util-base64/dist-types/ts3.4/toBase64.d.ts

```typescript
/**
 * Converts a Uint8Array of binary data or a utf-8 string to a base-64 encoded string using
 * Node.JS's `buffer` module.
 *
 * @param _input - the binary data or string to encode.
 * @returns base64 string.
 */
export declare const toBase64: (_input: Uint8Array | string) => string;

```

## ./lib/lambda/node_modules/@smithy/util-base64/package.json

```json
{
  "name": "@smithy/util-base64",
  "version": "4.3.0",
  "description": "A Base64 <-> UInt8Array converter",
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline util-base64",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "rimraf dist-types/ts3.4 && downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../../.prettierignore --write \"**/*.{ts,md,json}\"",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch"
  },
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "sideEffects": false,
  "dependencies": {
    "@smithy/util-buffer-from": "^4.2.0",
    "@smithy/util-utf8": "^4.2.0",
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "@types/node": "^18.11.9",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "types": "./dist-types/index.d.ts",
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "browser": {
    "./dist-es/fromBase64": "./dist-es/fromBase64.browser",
    "./dist-es/toBase64": "./dist-es/toBase64.browser"
  },
  "react-native": {
    "./dist-es/fromBase64": "./dist-es/fromBase64.browser",
    "./dist-es/toBase64": "./dist-es/toBase64.browser",
    "./dist-cjs/fromBase64": "./dist-cjs/fromBase64.browser",
    "./dist-cjs/toBase64": "./dist-cjs/toBase64.browser"
  },
  "homepage": "https://github.com/smithy-lang/smithy-typescript/tree/main/packages/util-base64",
  "repository": {
    "type": "git",
    "url": "https://github.com/smithy-lang/smithy-typescript.git",
    "directory": "packages/util-base64"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  }
}
```

## ./lib/lambda/node_modules/@smithy/util-body-length-browser/dist-types/calculateBodyLength.d.ts

```typescript
/**
 * @internal
 */
export declare const calculateBodyLength: (body: any) => number | undefined;

```

## ./lib/lambda/node_modules/@smithy/util-body-length-browser/dist-types/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./calculateBodyLength";

```

## ./lib/lambda/node_modules/@smithy/util-body-length-browser/dist-types/ts3.4/calculateBodyLength.d.ts

```typescript
/**
 * @internal
 */
export declare const calculateBodyLength: (body: any) => number | undefined;

```

## ./lib/lambda/node_modules/@smithy/util-body-length-browser/dist-types/ts3.4/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./calculateBodyLength";

```

## ./lib/lambda/node_modules/@smithy/util-body-length-browser/package.json

```json
{
  "name": "@smithy/util-body-length-browser",
  "description": "Determines the length of a request body in browsers",
  "version": "4.2.0",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline util-body-length-browser",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "rimraf dist-types/ts3.4 && downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../../.prettierignore --write \"**/*.{ts,md,json}\"",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "sideEffects": false,
  "dependencies": {
    "tslib": "^2.6.2"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/smithy-lang/smithy-typescript/tree/main/packages/util-body-length-browser",
  "repository": {
    "type": "git",
    "url": "https://github.com/smithy-lang/smithy-typescript.git",
    "directory": "packages/util-body-length-browser"
  },
  "devDependencies": {
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  },
  "engines": {
    "node": ">=18.0.0"
  }
}
```

## ./lib/lambda/node_modules/@smithy/util-body-length-node/dist-types/calculateBodyLength.d.ts

```typescript
/**
 * @internal
 */
export declare const calculateBodyLength: (body: any) => number | undefined;

```

## ./lib/lambda/node_modules/@smithy/util-body-length-node/dist-types/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./calculateBodyLength";

```

## ./lib/lambda/node_modules/@smithy/util-body-length-node/dist-types/ts3.4/calculateBodyLength.d.ts

```typescript
/**
 * @internal
 */
export declare const calculateBodyLength: (body: any) => number | undefined;

```

## ./lib/lambda/node_modules/@smithy/util-body-length-node/dist-types/ts3.4/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./calculateBodyLength";

```

## ./lib/lambda/node_modules/@smithy/util-body-length-node/package.json

```json
{
  "name": "@smithy/util-body-length-node",
  "description": "Determines the length of a request body in node.js",
  "version": "4.2.1",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline util-body-length-node",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "rimraf dist-types/ts3.4 && downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../../.prettierignore --write \"**/*.{ts,md,json}\"",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch"
  },
  "devDependencies": {
    "@types/node": "^18.11.9",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "sideEffects": false,
  "dependencies": {
    "tslib": "^2.6.2"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/smithy-lang/smithy-typescript/tree/main/packages/util-body-length-node",
  "repository": {
    "type": "git",
    "url": "https://github.com/smithy-lang/smithy-typescript.git",
    "directory": "packages/util-body-length-node"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  }
}
```

## ./lib/lambda/node_modules/@smithy/util-buffer-from/dist-types/index.d.ts

```typescript
import { Buffer } from "buffer";
/**
 * @internal
 */
export declare const fromArrayBuffer: (input: ArrayBuffer, offset?: number, length?: number) => Buffer;
/**
 * @internal
 */
export type StringEncoding = "ascii" | "utf8" | "utf16le" | "ucs2" | "base64" | "latin1" | "binary" | "hex";
/**
 * @internal
 */
export declare const fromString: (input: string, encoding?: StringEncoding) => Buffer;

```

## ./lib/lambda/node_modules/@smithy/util-buffer-from/dist-types/ts3.4/index.d.ts

```typescript
import { Buffer } from "buffer";
/**
 * @internal
 */
export declare const fromArrayBuffer: (input: ArrayBuffer, offset?: number, length?: number) => Buffer;
/**
 * @internal
 */
export type StringEncoding = "ascii" | "utf8" | "utf16le" | "ucs2" | "base64" | "latin1" | "binary" | "hex";
/**
 * @internal
 */
export declare const fromString: (input: string, encoding?: StringEncoding) => Buffer;

```

## ./lib/lambda/node_modules/@smithy/util-buffer-from/package.json

```json
{
  "name": "@smithy/util-buffer-from",
  "version": "4.2.0",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline util-buffer-from",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "rimraf dist-types/ts3.4 && downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../../.prettierignore --write \"**/*.{ts,md,json}\"",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch"
  },
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "sideEffects": false,
  "dependencies": {
    "@smithy/is-array-buffer": "^4.2.0",
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "@types/node": "^18.11.9",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/smithy-lang/smithy-typescript/tree/main/packages/util-buffer-from",
  "repository": {
    "type": "git",
    "url": "https://github.com/smithy-lang/smithy-typescript.git",
    "directory": "packages/util-buffer-from"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  }
}
```

## ./lib/lambda/node_modules/@smithy/util-config-provider/dist-types/booleanSelector.d.ts

```typescript
import type { SelectorType } from "./types";
/**
 * Returns boolean value true/false for string value "true"/"false",
 * if the string is defined in obj[key]
 * Returns undefined, if obj[key] is not defined.
 * Throws error for all other cases.
 *
 * @internal
 */
export declare const booleanSelector: (obj: Record<string, string | undefined>, key: string, type: SelectorType) => boolean | undefined;

```

## ./lib/lambda/node_modules/@smithy/util-config-provider/dist-types/index.d.ts

```typescript
export * from "./booleanSelector";
export * from "./numberSelector";
export * from "./types";

```

## ./lib/lambda/node_modules/@smithy/util-config-provider/dist-types/numberSelector.d.ts

```typescript
import type { SelectorType } from "./types";
/**
 * Returns number value for string value, if the string is defined in obj[key].
 * Returns undefined, if obj[key] is not defined.
 * Throws error for all other cases.
 *
 * @internal
 */
export declare const numberSelector: (obj: Record<string, string | undefined>, key: string, type: SelectorType) => number | undefined;

```

## ./lib/lambda/node_modules/@smithy/util-config-provider/dist-types/ts3.4/booleanSelector.d.ts

```typescript
import { SelectorType } from "./types";
/**
 * Returns boolean value true/false for string value "true"/"false",
 * if the string is defined in obj[key]
 * Returns undefined, if obj[key] is not defined.
 * Throws error for all other cases.
 *
 * @internal
 */
export declare const booleanSelector: (obj: Record<string, string | undefined>, key: string, type: SelectorType) => boolean | undefined;

```

## ./lib/lambda/node_modules/@smithy/util-config-provider/dist-types/ts3.4/index.d.ts

```typescript
export * from "./booleanSelector";
export * from "./numberSelector";
export * from "./types";

```

## ./lib/lambda/node_modules/@smithy/util-config-provider/dist-types/ts3.4/numberSelector.d.ts

```typescript
import { SelectorType } from "./types";
/**
 * Returns number value for string value, if the string is defined in obj[key].
 * Returns undefined, if obj[key] is not defined.
 * Throws error for all other cases.
 *
 * @internal
 */
export declare const numberSelector: (obj: Record<string, string | undefined>, key: string, type: SelectorType) => number | undefined;

```

## ./lib/lambda/node_modules/@smithy/util-config-provider/dist-types/ts3.4/types.d.ts

```typescript
export declare enum SelectorType {
    ENV = "env",
    CONFIG = "shared config entry"
}

```

## ./lib/lambda/node_modules/@smithy/util-config-provider/dist-types/types.d.ts

```typescript
export declare enum SelectorType {
    ENV = "env",
    CONFIG = "shared config entry"
}

```

## ./lib/lambda/node_modules/@smithy/util-config-provider/package.json

```json
{
  "name": "@smithy/util-config-provider",
  "version": "4.2.0",
  "description": "Utilities package for configuration providers",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline util-config-provider",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "rimraf dist-types/ts3.4 && downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../../.prettierignore --write \"**/*.{ts,md,json}\"",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch"
  },
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "email": "",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "sideEffects": false,
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "dependencies": {
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "@types/node": "^18.11.9",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/smithy-lang/smithy-typescript/tree/main/packages/util-config-provider",
  "repository": {
    "type": "git",
    "url": "https://github.com/smithy-lang/smithy-typescript.git",
    "directory": "packages/util-config-provider"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  }
}
```

## ./lib/lambda/node_modules/@smithy/util-defaults-mode-browser/dist-types/constants.d.ts

```typescript
import type { DefaultsMode } from "@smithy/smithy-client";
import type { Provider } from "@smithy/types";
/**
 * @internal
 */
export declare const DEFAULTS_MODE_OPTIONS: string[];
/**
 * @internal
 */
export interface ResolveDefaultsModeConfigOptions {
    defaultsMode?: DefaultsMode | Provider<DefaultsMode>;
}

```

## ./lib/lambda/node_modules/@smithy/util-defaults-mode-browser/dist-types/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./resolveDefaultsModeConfig";

```

## ./lib/lambda/node_modules/@smithy/util-defaults-mode-browser/dist-types/resolveDefaultsModeConfig.d.ts

```typescript
import type { DefaultsMode, ResolvedDefaultsMode } from "@smithy/smithy-client";
import type { Provider } from "@smithy/types";
/**
 * @internal
 */
export interface ResolveDefaultsModeConfigOptions {
    defaultsMode?: DefaultsMode | Provider<DefaultsMode>;
}
/**
 * Validate the defaultsMode configuration. If the value is set to "auto", it
 * resolves the value to "mobile" if the app is running in a mobile browser,
 * otherwise it resolves to "standard".
 *
 * @default "legacy"
 * @internal
 */
export declare const resolveDefaultsModeConfig: ({ defaultsMode, }?: ResolveDefaultsModeConfigOptions) => Provider<ResolvedDefaultsMode>;

```

## ./lib/lambda/node_modules/@smithy/util-defaults-mode-browser/dist-types/resolveDefaultsModeConfig.native.d.ts

```typescript
import type { DefaultsMode, ResolvedDefaultsMode } from "@smithy/smithy-client";
import type { Provider } from "@smithy/types";
/**
 * @internal
 */
export interface ResolveDefaultsModeConfigOptions {
    defaultsMode?: DefaultsMode | Provider<DefaultsMode>;
}
/**
 * Validate the defaultsMode configuration. If the value is set to "auto", it
 * resolves the value to "mobile".
 *
 * @default "legacy"
 * @internal
 */
export declare const resolveDefaultsModeConfig: ({ defaultsMode, }?: ResolveDefaultsModeConfigOptions) => Provider<ResolvedDefaultsMode>;

```

## ./lib/lambda/node_modules/@smithy/util-defaults-mode-browser/dist-types/ts3.4/constants.d.ts

```typescript
import { DefaultsMode } from "@smithy/smithy-client";
import { Provider } from "@smithy/types";
/**
 * @internal
 */
export declare const DEFAULTS_MODE_OPTIONS: string[];
/**
 * @internal
 */
export interface ResolveDefaultsModeConfigOptions {
    defaultsMode?: DefaultsMode | Provider<DefaultsMode>;
}

```

## ./lib/lambda/node_modules/@smithy/util-defaults-mode-browser/dist-types/ts3.4/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./resolveDefaultsModeConfig";

```

## ./lib/lambda/node_modules/@smithy/util-defaults-mode-browser/dist-types/ts3.4/resolveDefaultsModeConfig.d.ts

```typescript
import { DefaultsMode, ResolvedDefaultsMode } from "@smithy/smithy-client";
import { Provider } from "@smithy/types";
/**
 * @internal
 */
export interface ResolveDefaultsModeConfigOptions {
    defaultsMode?: DefaultsMode | Provider<DefaultsMode>;
}
/**
 * Validate the defaultsMode configuration. If the value is set to "auto", it
 * resolves the value to "mobile" if the app is running in a mobile browser,
 * otherwise it resolves to "standard".
 *
 * @default "legacy"
 * @internal
 */
export declare const resolveDefaultsModeConfig: ({ defaultsMode, }?: ResolveDefaultsModeConfigOptions) => Provider<ResolvedDefaultsMode>;

```

## ./lib/lambda/node_modules/@smithy/util-defaults-mode-browser/dist-types/ts3.4/resolveDefaultsModeConfig.native.d.ts

```typescript
import { DefaultsMode, ResolvedDefaultsMode } from "@smithy/smithy-client";
import { Provider } from "@smithy/types";
/**
 * @internal
 */
export interface ResolveDefaultsModeConfigOptions {
    defaultsMode?: DefaultsMode | Provider<DefaultsMode>;
}
/**
 * Validate the defaultsMode configuration. If the value is set to "auto", it
 * resolves the value to "mobile".
 *
 * @default "legacy"
 * @internal
 */
export declare const resolveDefaultsModeConfig: ({ defaultsMode, }?: ResolveDefaultsModeConfigOptions) => Provider<ResolvedDefaultsMode>;

```

## ./lib/lambda/node_modules/@smithy/util-defaults-mode-browser/package.json

```json
{
  "name": "@smithy/util-defaults-mode-browser",
  "version": "4.3.3",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline util-defaults-mode-browser",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "rimraf dist-types/ts3.4 && downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../../.prettierignore --write \"**/*.{ts,md,json}\"",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "sideEffects": false,
  "dependencies": {
    "@smithy/property-provider": "^4.2.3",
    "@smithy/smithy-client": "^4.9.0",
    "@smithy/types": "^4.8.0",
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "@types/node": "^18.11.9",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "react-native": {},
  "browser": {},
  "homepage": "https://github.com/smithy-lang/smithy-typescript/tree/main/packages/util-defaults-mode-node",
  "repository": {
    "type": "git",
    "url": "https://github.com/smithy-lang/smithy-typescript.git",
    "directory": "packages/util-defaults-mode-node"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  }
}
```

## ./lib/lambda/node_modules/@smithy/util-defaults-mode-node/dist-types/constants.d.ts

```typescript
/**
 * @internal
 */
export declare const AWS_EXECUTION_ENV = "AWS_EXECUTION_ENV";
/**
 * @internal
 */
export declare const AWS_REGION_ENV = "AWS_REGION";
/**
 * @internal
 */
export declare const AWS_DEFAULT_REGION_ENV = "AWS_DEFAULT_REGION";
/**
 * @internal
 */
export declare const ENV_IMDS_DISABLED = "AWS_EC2_METADATA_DISABLED";
/**
 * @internal
 */
export declare const DEFAULTS_MODE_OPTIONS: string[];
/**
 * @internal
 */
export declare const IMDS_REGION_PATH = "/latest/meta-data/placement/region";

```

## ./lib/lambda/node_modules/@smithy/util-defaults-mode-node/dist-types/defaultsModeConfig.d.ts

```typescript
import type { LoadedConfigSelectors } from "@smithy/node-config-provider";
import type { DefaultsMode } from "@smithy/smithy-client";
/**
 * @internal
 */
export declare const NODE_DEFAULTS_MODE_CONFIG_OPTIONS: LoadedConfigSelectors<DefaultsMode>;

```

## ./lib/lambda/node_modules/@smithy/util-defaults-mode-node/dist-types/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./resolveDefaultsModeConfig";

```

## ./lib/lambda/node_modules/@smithy/util-defaults-mode-node/dist-types/resolveDefaultsModeConfig.d.ts

```typescript
import type { DefaultsMode, ResolvedDefaultsMode } from "@smithy/smithy-client";
import type { Provider } from "@smithy/types";
/**
 * @internal
 */
export interface ResolveDefaultsModeConfigOptions {
    defaultsMode?: DefaultsMode | Provider<DefaultsMode>;
    region?: string | Provider<string>;
}
/**
 * Validate the defaultsMode configuration. If the value is set to "auto", it
 * resolves the value to "in-region", "cross-region", or "standard".
 *
 * @default "legacy"
 * @internal
 */
export declare const resolveDefaultsModeConfig: ({ region, defaultsMode, }?: ResolveDefaultsModeConfigOptions) => Provider<ResolvedDefaultsMode>;

```

## ./lib/lambda/node_modules/@smithy/util-defaults-mode-node/dist-types/ts3.4/constants.d.ts

```typescript
/**
 * @internal
 */
export declare const AWS_EXECUTION_ENV = "AWS_EXECUTION_ENV";
/**
 * @internal
 */
export declare const AWS_REGION_ENV = "AWS_REGION";
/**
 * @internal
 */
export declare const AWS_DEFAULT_REGION_ENV = "AWS_DEFAULT_REGION";
/**
 * @internal
 */
export declare const ENV_IMDS_DISABLED = "AWS_EC2_METADATA_DISABLED";
/**
 * @internal
 */
export declare const DEFAULTS_MODE_OPTIONS: string[];
/**
 * @internal
 */
export declare const IMDS_REGION_PATH = "/latest/meta-data/placement/region";

```

## ./lib/lambda/node_modules/@smithy/util-defaults-mode-node/dist-types/ts3.4/defaultsModeConfig.d.ts

```typescript
import { LoadedConfigSelectors } from "@smithy/node-config-provider";
import { DefaultsMode } from "@smithy/smithy-client";
/**
 * @internal
 */
export declare const NODE_DEFAULTS_MODE_CONFIG_OPTIONS: LoadedConfigSelectors<DefaultsMode>;

```

## ./lib/lambda/node_modules/@smithy/util-defaults-mode-node/dist-types/ts3.4/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./resolveDefaultsModeConfig";

```

## ./lib/lambda/node_modules/@smithy/util-defaults-mode-node/dist-types/ts3.4/resolveDefaultsModeConfig.d.ts

```typescript
import { DefaultsMode, ResolvedDefaultsMode } from "@smithy/smithy-client";
import { Provider } from "@smithy/types";
/**
 * @internal
 */
export interface ResolveDefaultsModeConfigOptions {
    defaultsMode?: DefaultsMode | Provider<DefaultsMode>;
    region?: string | Provider<string>;
}
/**
 * Validate the defaultsMode configuration. If the value is set to "auto", it
 * resolves the value to "in-region", "cross-region", or "standard".
 *
 * @default "legacy"
 * @internal
 */
export declare const resolveDefaultsModeConfig: ({ region, defaultsMode, }?: ResolveDefaultsModeConfigOptions) => Provider<ResolvedDefaultsMode>;

```

## ./lib/lambda/node_modules/@smithy/util-defaults-mode-node/package.json

```json
{
  "name": "@smithy/util-defaults-mode-node",
  "version": "4.2.4",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline util-defaults-mode-node",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "rimraf dist-types/ts3.4 && downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../../.prettierignore --write \"**/*.{ts,md,json}\"",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "sideEffects": false,
  "dependencies": {
    "@smithy/config-resolver": "^4.3.3",
    "@smithy/credential-provider-imds": "^4.2.3",
    "@smithy/node-config-provider": "^4.3.3",
    "@smithy/property-provider": "^4.2.3",
    "@smithy/smithy-client": "^4.9.0",
    "@smithy/types": "^4.8.0",
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "@types/node": "^18.11.9",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/smithy-lang/smithy-typescript/tree/main/packages/util-defaults-mode-node",
  "repository": {
    "type": "git",
    "url": "https://github.com/smithy-lang/smithy-typescript.git",
    "directory": "packages/util-defaults-mode-node"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  }
}
```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/cache/EndpointCache.d.ts

```typescript
import type { EndpointParams, EndpointV2 } from "@smithy/types";
/**
 * @internal
 *
 * Cache for endpoint ruleSet resolution.
 */
export declare class EndpointCache {
    private capacity;
    private data;
    private parameters;
    /**
     * @param [size] - desired average maximum capacity. A buffer of 10 additional keys will be allowed
     *                 before keys are dropped.
     * @param [params] - list of params to consider as part of the cache key.
     *
     * If the params list is not populated, no caching will happen.
     * This may be out of order depending on how the object is created and arrives to this class.
     */
    constructor({ size, params }: {
        size?: number;
        params?: string[];
    });
    /**
     * @param endpointParams - query for endpoint.
     * @param resolver - provider of the value if not present.
     * @returns endpoint corresponding to the query.
     */
    get(endpointParams: EndpointParams, resolver: () => EndpointV2): EndpointV2;
    size(): number;
    /**
     * @returns cache key or false if not cachable.
     */
    private hash;
}

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/debug/debugId.d.ts

```typescript
export declare const debugId = "endpoints";

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/debug/index.d.ts

```typescript
export * from "./debugId";
export * from "./toDebugString";

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/debug/toDebugString.d.ts

```typescript
import type { EndpointParameters, EndpointV2 } from "@smithy/types";
import type { GetAttrValue } from "../lib";
import type { EndpointObject, FunctionObject, FunctionReturn } from "../types";
export declare function toDebugString(input: EndpointParameters): string;
export declare function toDebugString(input: EndpointV2): string;
export declare function toDebugString(input: GetAttrValue): string;
export declare function toDebugString(input: FunctionObject): string;
export declare function toDebugString(input: FunctionReturn): string;
export declare function toDebugString(input: EndpointObject): string;

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/getEndpointUrlConfig.d.ts

```typescript
import type { LoadedConfigSelectors } from "@smithy/node-config-provider";
export declare const getEndpointUrlConfig: (serviceId: string) => LoadedConfigSelectors<string | undefined>;

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/index.d.ts

```typescript
export * from "./cache/EndpointCache";
export * from "./lib/isIpAddress";
export * from "./lib/isValidHostLabel";
export * from "./utils/customEndpointFunctions";
export * from "./resolveEndpoint";
export * from "./types";

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/lib/booleanEquals.d.ts

```typescript
/**
 * Evaluates two boolean values value1 and value2 for equality and returns
 * true if both values match.
 */
export declare const booleanEquals: (value1: boolean, value2: boolean) => boolean;

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/lib/getAttr.d.ts

```typescript
export type GetAttrValue = string | boolean | {
    [key: string]: GetAttrValue;
} | Array<GetAttrValue>;
/**
 * Returns value corresponding to pathing string for an array or object.
 */
export declare const getAttr: (value: GetAttrValue, path: string) => GetAttrValue;

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/lib/getAttrPathList.d.ts

```typescript
/**
 * Parses path as a getAttr expression, returning a list of strings.
 */
export declare const getAttrPathList: (path: string) => Array<string>;

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/lib/index.d.ts

```typescript
export * from "./booleanEquals";
export * from "./getAttr";
export * from "./isSet";
export * from "./isValidHostLabel";
export * from "./not";
export * from "./parseURL";
export * from "./stringEquals";
export * from "./substring";
export * from "./uriEncode";

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/lib/isIpAddress.d.ts

```typescript
/**
 * Validates if the provided value is an IP address.
 */
export declare const isIpAddress: (value: string) => boolean;

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/lib/isSet.d.ts

```typescript
/**
 * Evaluates whether a value is set (aka not null or undefined).
 * Returns true if the value is set, otherwise returns false.
 */
export declare const isSet: (value: unknown) => value is {};

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/lib/isValidHostLabel.d.ts

```typescript
/**
 * Evaluates whether one or more string values are valid host labels per RFC 1123.
 *
 * If allowSubDomains is true, then the provided value may be zero or more dotted
 * subdomains which are each validated per RFC 1123.
 */
export declare const isValidHostLabel: (value: string, allowSubDomains?: boolean) => boolean;

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/lib/not.d.ts

```typescript
/**
 * Performs logical negation on the provided boolean value,
 * returning the negated value.
 */
export declare const not: (value: boolean) => boolean;

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/lib/parseURL.d.ts

```typescript
import type { Endpoint, EndpointURL } from "@smithy/types";
/**
 * Parses a string, URL, or Endpoint into its Endpoint URL components.
 */
export declare const parseURL: (value: string | URL | Endpoint) => EndpointURL | null;

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/lib/stringEquals.d.ts

```typescript
/**
 * Evaluates two string values value1 and value2 for equality and returns
 * true if both values match.
 */
export declare const stringEquals: (value1: string, value2: string) => boolean;

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/lib/substring.d.ts

```typescript
/**
 * Computes the substring of a given string, conditionally indexing from the end of the string.
 * When the string is long enough to fully include the substring, return the substring.
 * Otherwise, return None. The start index is inclusive and the stop index is exclusive.
 * The length of the returned string will always be stop-start.
 */
export declare const substring: (input: string, start: number, stop: number, reverse: boolean) => string | null;

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/lib/uriEncode.d.ts

```typescript
/**
 * Performs percent-encoding per RFC3986 section 2.1
 */
export declare const uriEncode: (value: string) => string;

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/resolveEndpoint.d.ts

```typescript
import type { EndpointV2 } from "@smithy/types";
import type { EndpointResolverOptions, RuleSetObject } from "./types";
/**
 * Resolves an endpoint URL by processing the endpoints ruleset and options.
 */
export declare const resolveEndpoint: (ruleSetObject: RuleSetObject, options: EndpointResolverOptions) => EndpointV2;

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/ts3.4/cache/EndpointCache.d.ts

```typescript
import { EndpointParams, EndpointV2 } from "@smithy/types";
/**
 * @internal
 *
 * Cache for endpoint ruleSet resolution.
 */
export declare class EndpointCache {
    private capacity;
    private data;
    private parameters;
    /**
     * @param [size] - desired average maximum capacity. A buffer of 10 additional keys will be allowed
     *                 before keys are dropped.
     * @param [params] - list of params to consider as part of the cache key.
     *
     * If the params list is not populated, no caching will happen.
     * This may be out of order depending on how the object is created and arrives to this class.
     */
    constructor({ size, params }: {
        size?: number;
        params?: string[];
    });
    /**
     * @param endpointParams - query for endpoint.
     * @param resolver - provider of the value if not present.
     * @returns endpoint corresponding to the query.
     */
    get(endpointParams: EndpointParams, resolver: () => EndpointV2): EndpointV2;
    size(): number;
    /**
     * @returns cache key or false if not cachable.
     */
    private hash;
}

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/ts3.4/debug/debugId.d.ts

```typescript
export declare const debugId = "endpoints";

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/ts3.4/debug/index.d.ts

```typescript
export * from "./debugId";
export * from "./toDebugString";

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/ts3.4/debug/toDebugString.d.ts

```typescript
import { EndpointParameters, EndpointV2 } from "@smithy/types";
import { GetAttrValue } from "../lib";
import { EndpointObject, FunctionObject, FunctionReturn } from "../types";
export declare function toDebugString(input: EndpointParameters): string;
export declare function toDebugString(input: EndpointV2): string;
export declare function toDebugString(input: GetAttrValue): string;
export declare function toDebugString(input: FunctionObject): string;
export declare function toDebugString(input: FunctionReturn): string;
export declare function toDebugString(input: EndpointObject): string;

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/ts3.4/getEndpointUrlConfig.d.ts

```typescript
import { LoadedConfigSelectors } from "@smithy/node-config-provider";
export declare const getEndpointUrlConfig: (serviceId: string) => LoadedConfigSelectors<string | undefined>;

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/ts3.4/index.d.ts

```typescript
export * from "./cache/EndpointCache";
export * from "./lib/isIpAddress";
export * from "./lib/isValidHostLabel";
export * from "./utils/customEndpointFunctions";
export * from "./resolveEndpoint";
export * from "./types";

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/ts3.4/lib/booleanEquals.d.ts

```typescript
/**
 * Evaluates two boolean values value1 and value2 for equality and returns
 * true if both values match.
 */
export declare const booleanEquals: (value1: boolean, value2: boolean) => boolean;

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/ts3.4/lib/getAttr.d.ts

```typescript
export type GetAttrValue = string | boolean | {
    [key: string]: GetAttrValue;
} | Array<GetAttrValue>;
/**
 * Returns value corresponding to pathing string for an array or object.
 */
export declare const getAttr: (value: GetAttrValue, path: string) => GetAttrValue;

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/ts3.4/lib/getAttrPathList.d.ts

```typescript
/**
 * Parses path as a getAttr expression, returning a list of strings.
 */
export declare const getAttrPathList: (path: string) => Array<string>;

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/ts3.4/lib/index.d.ts

```typescript
export * from "./booleanEquals";
export * from "./getAttr";
export * from "./isSet";
export * from "./isValidHostLabel";
export * from "./not";
export * from "./parseURL";
export * from "./stringEquals";
export * from "./substring";
export * from "./uriEncode";

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/ts3.4/lib/isIpAddress.d.ts

```typescript
/**
 * Validates if the provided value is an IP address.
 */
export declare const isIpAddress: (value: string) => boolean;

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/ts3.4/lib/isSet.d.ts

```typescript
/**
 * Evaluates whether a value is set (aka not null or undefined).
 * Returns true if the value is set, otherwise returns false.
 */
export declare const isSet: (value: unknown) => value is {};

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/ts3.4/lib/isValidHostLabel.d.ts

```typescript
/**
 * Evaluates whether one or more string values are valid host labels per RFC 1123.
 *
 * If allowSubDomains is true, then the provided value may be zero or more dotted
 * subdomains which are each validated per RFC 1123.
 */
export declare const isValidHostLabel: (value: string, allowSubDomains?: boolean) => boolean;

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/ts3.4/lib/not.d.ts

```typescript
/**
 * Performs logical negation on the provided boolean value,
 * returning the negated value.
 */
export declare const not: (value: boolean) => boolean;

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/ts3.4/lib/parseURL.d.ts

```typescript
import { Endpoint, EndpointURL } from "@smithy/types";
/**
 * Parses a string, URL, or Endpoint into its Endpoint URL components.
 */
export declare const parseURL: (value: string | URL | Endpoint) => EndpointURL | null;

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/ts3.4/lib/stringEquals.d.ts

```typescript
/**
 * Evaluates two string values value1 and value2 for equality and returns
 * true if both values match.
 */
export declare const stringEquals: (value1: string, value2: string) => boolean;

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/ts3.4/lib/substring.d.ts

```typescript
/**
 * Computes the substring of a given string, conditionally indexing from the end of the string.
 * When the string is long enough to fully include the substring, return the substring.
 * Otherwise, return None. The start index is inclusive and the stop index is exclusive.
 * The length of the returned string will always be stop-start.
 */
export declare const substring: (input: string, start: number, stop: number, reverse: boolean) => string | null;

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/ts3.4/lib/uriEncode.d.ts

```typescript
/**
 * Performs percent-encoding per RFC3986 section 2.1
 */
export declare const uriEncode: (value: string) => string;

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/ts3.4/resolveEndpoint.d.ts

```typescript
import { EndpointV2 } from "@smithy/types";
import { EndpointResolverOptions, RuleSetObject } from "./types";
/**
 * Resolves an endpoint URL by processing the endpoints ruleset and options.
 */
export declare const resolveEndpoint: (ruleSetObject: RuleSetObject, options: EndpointResolverOptions) => EndpointV2;

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/ts3.4/types/EndpointError.d.ts

```typescript
export declare class EndpointError extends Error {
    constructor(message: string);
}

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/ts3.4/types/EndpointFunctions.d.ts

```typescript
import { FunctionReturn } from "./shared";
export type EndpointFunctions = Record<string, (...args: any[]) => FunctionReturn>;

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/ts3.4/types/EndpointRuleObject.d.ts

```typescript
import { EndpointObject as __EndpointObject, EndpointObjectHeaders as __EndpointObjectHeaders, EndpointObjectProperties as __EndpointObjectProperties, EndpointRuleObject as __EndpointRuleObject } from "@smithy/types";
export type EndpointObjectProperties = __EndpointObjectProperties;
export type EndpointObjectHeaders = __EndpointObjectHeaders;
export type EndpointObject = __EndpointObject;
export type EndpointRuleObject = __EndpointRuleObject;

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/ts3.4/types/ErrorRuleObject.d.ts

```typescript
import { ErrorRuleObject as __ErrorRuleObject } from "@smithy/types";
export type ErrorRuleObject = __ErrorRuleObject;

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/ts3.4/types/RuleSetObject.d.ts

```typescript
import { DeprecatedObject as __DeprecatedObject, ParameterObject as __ParameterObject, RuleSetObject as __RuleSetObject } from "@smithy/types";
export type DeprecatedObject = __DeprecatedObject;
export type ParameterObject = __ParameterObject;
export type RuleSetObject = __RuleSetObject;

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/ts3.4/types/TreeRuleObject.d.ts

```typescript
import { RuleSetRules as __RuleSetRules, TreeRuleObject as __TreeRuleObject } from "@smithy/types";
export type RuleSetRules = __RuleSetRules;
export type TreeRuleObject = __TreeRuleObject;

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/ts3.4/types/index.d.ts

```typescript
export * from "./EndpointError";
export * from "./EndpointFunctions";
export * from "./EndpointRuleObject";
export * from "./ErrorRuleObject";
export * from "./RuleSetObject";
export * from "./TreeRuleObject";
export * from "./shared";

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/ts3.4/types/shared.d.ts

```typescript
import { EndpointARN, EndpointPartition, Logger } from "@smithy/types";
export type ReferenceObject = {
    ref: string;
};
export type FunctionObject = {
    fn: string;
    argv: FunctionArgv;
};
export type FunctionArgv = Array<Expression | boolean | number>;
export type FunctionReturn = string | boolean | number | EndpointARN | EndpointPartition | {
    [key: string]: FunctionReturn;
} | null;
export type ConditionObject = FunctionObject & {
    assign?: string;
};
export type Expression = string | ReferenceObject | FunctionObject;
export type EndpointParams = Record<string, string | boolean>;
export type EndpointResolverOptions = {
    endpointParams: EndpointParams;
    logger?: Logger;
};
export type ReferenceRecord = Record<string, FunctionReturn>;
export type EvaluateOptions = EndpointResolverOptions & {
    referenceRecord: ReferenceRecord;
};

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/ts3.4/utils/callFunction.d.ts

```typescript
export { callFunction } from "./evaluateExpression";

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/ts3.4/utils/customEndpointFunctions.d.ts

```typescript
import { EndpointFunctions } from "../types/EndpointFunctions";
export declare const customEndpointFunctions: {
    [key: string]: EndpointFunctions;
};

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/ts3.4/utils/endpointFunctions.d.ts

```typescript
export declare const endpointFunctions: {
    booleanEquals: (value1: boolean, value2: boolean) => boolean;
    getAttr: (value: import("../lib").GetAttrValue, path: string) => import("../lib").GetAttrValue;
    isSet: (value: unknown) => value is {};
    isValidHostLabel: (value: string, allowSubDomains?: boolean) => boolean;
    not: (value: boolean) => boolean;
    parseURL: (value: string | URL | import("@smithy/types").Endpoint) => import("@smithy/types").EndpointURL | null;
    stringEquals: (value1: string, value2: string) => boolean;
    substring: (input: string, start: number, stop: number, reverse: boolean) => string | null;
    uriEncode: (value: string) => string;
};

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/ts3.4/utils/evaluateCondition.d.ts

```typescript
import { ConditionObject, EvaluateOptions } from "../types";
export declare const evaluateCondition: ({ assign, ...fnArgs }: ConditionObject, options: EvaluateOptions) => {
    toAssign?: {
        name: string;
        value: import("../types").FunctionReturn;
    } | undefined;
    result: boolean;
};

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/ts3.4/utils/evaluateConditions.d.ts

```typescript
import { ConditionObject, EvaluateOptions, FunctionReturn } from "../types";
export declare const evaluateConditions: (conditions: ConditionObject[] | undefined, options: EvaluateOptions) => {
    result: false;
    referenceRecord?: undefined;
} | {
    result: boolean;
    referenceRecord: Record<string, FunctionReturn>;
};

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/ts3.4/utils/evaluateEndpointRule.d.ts

```typescript
import { EndpointV2 } from "@smithy/types";
import { EndpointRuleObject, EvaluateOptions } from "../types";
export declare const evaluateEndpointRule: (endpointRule: EndpointRuleObject, options: EvaluateOptions) => EndpointV2 | undefined;

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/ts3.4/utils/evaluateErrorRule.d.ts

```typescript
import { ErrorRuleObject, EvaluateOptions } from "../types";
export declare const evaluateErrorRule: (errorRule: ErrorRuleObject, options: EvaluateOptions) => void;

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/ts3.4/utils/evaluateExpression.d.ts

```typescript
import { EvaluateOptions, Expression, FunctionObject, FunctionReturn } from "../types";
export declare const evaluateExpression: (obj: Expression, keyName: string, options: EvaluateOptions) => FunctionReturn;
export declare const callFunction: ({ fn, argv }: FunctionObject, options: EvaluateOptions) => FunctionReturn;
export declare const group: {
    evaluateExpression: (obj: Expression, keyName: string, options: EvaluateOptions) => FunctionReturn;
    callFunction: ({ fn, argv }: FunctionObject, options: EvaluateOptions) => FunctionReturn;
};

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/ts3.4/utils/evaluateRules.d.ts

```typescript
import { EndpointV2 } from "@smithy/types";
import { EvaluateOptions, RuleSetRules, TreeRuleObject } from "../types";
export declare const evaluateRules: (rules: RuleSetRules, options: EvaluateOptions) => EndpointV2;
export declare const evaluateTreeRule: (treeRule: TreeRuleObject, options: EvaluateOptions) => EndpointV2 | undefined;
export declare const group: {
    evaluateRules: (rules: RuleSetRules, options: EvaluateOptions) => EndpointV2;
    evaluateTreeRule: (treeRule: TreeRuleObject, options: EvaluateOptions) => EndpointV2 | undefined;
};

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/ts3.4/utils/evaluateTemplate.d.ts

```typescript
import { EvaluateOptions } from "../types";
export declare const evaluateTemplate: (template: string, options: EvaluateOptions) => string;

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/ts3.4/utils/evaluateTreeRule.d.ts

```typescript
export { evaluateTreeRule } from "./evaluateRules";

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/ts3.4/utils/getEndpointHeaders.d.ts

```typescript
import { EndpointObjectHeaders, EvaluateOptions } from "../types";
export declare const getEndpointHeaders: (headers: EndpointObjectHeaders, options: EvaluateOptions) => {};

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/ts3.4/utils/getEndpointProperties.d.ts

```typescript
import { EndpointObjectProperty } from "@smithy/types";
import { EndpointObjectProperties, EvaluateOptions } from "../types";
export declare const getEndpointProperties: (properties: EndpointObjectProperties, options: EvaluateOptions) => {};
export declare const getEndpointProperty: (property: EndpointObjectProperty, options: EvaluateOptions) => EndpointObjectProperty;
export declare const group: {
    getEndpointProperty: (property: EndpointObjectProperty, options: EvaluateOptions) => EndpointObjectProperty;
    getEndpointProperties: (properties: EndpointObjectProperties, options: EvaluateOptions) => {};
};

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/ts3.4/utils/getEndpointProperty.d.ts

```typescript
export { getEndpointProperty } from "./getEndpointProperties";

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/ts3.4/utils/getEndpointUrl.d.ts

```typescript
import { EvaluateOptions, Expression } from "../types";
export declare const getEndpointUrl: (endpointUrl: Expression, options: EvaluateOptions) => URL;

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/ts3.4/utils/getReferenceValue.d.ts

```typescript
import { EvaluateOptions, ReferenceObject } from "../types";
export declare const getReferenceValue: ({ ref }: ReferenceObject, options: EvaluateOptions) => import("../types").FunctionReturn;

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/ts3.4/utils/index.d.ts

```typescript
export * from "./customEndpointFunctions";
export * from "./evaluateRules";

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/types/EndpointError.d.ts

```typescript
export declare class EndpointError extends Error {
    constructor(message: string);
}

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/types/EndpointFunctions.d.ts

```typescript
import type { FunctionReturn } from "./shared";
export type EndpointFunctions = Record<string, (...args: any[]) => FunctionReturn>;

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/types/EndpointRuleObject.d.ts

```typescript
import type { EndpointObject as __EndpointObject, EndpointObjectHeaders as __EndpointObjectHeaders, EndpointObjectProperties as __EndpointObjectProperties, EndpointRuleObject as __EndpointRuleObject } from "@smithy/types";
export type EndpointObjectProperties = __EndpointObjectProperties;
export type EndpointObjectHeaders = __EndpointObjectHeaders;
export type EndpointObject = __EndpointObject;
export type EndpointRuleObject = __EndpointRuleObject;

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/types/ErrorRuleObject.d.ts

```typescript
import type { ErrorRuleObject as __ErrorRuleObject } from "@smithy/types";
export type ErrorRuleObject = __ErrorRuleObject;

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/types/RuleSetObject.d.ts

```typescript
import type { DeprecatedObject as __DeprecatedObject, ParameterObject as __ParameterObject, RuleSetObject as __RuleSetObject } from "@smithy/types";
export type DeprecatedObject = __DeprecatedObject;
export type ParameterObject = __ParameterObject;
export type RuleSetObject = __RuleSetObject;

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/types/TreeRuleObject.d.ts

```typescript
import type { RuleSetRules as __RuleSetRules, TreeRuleObject as __TreeRuleObject } from "@smithy/types";
export type RuleSetRules = __RuleSetRules;
export type TreeRuleObject = __TreeRuleObject;

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/types/index.d.ts

```typescript
export * from "./EndpointError";
export * from "./EndpointFunctions";
export * from "./EndpointRuleObject";
export * from "./ErrorRuleObject";
export * from "./RuleSetObject";
export * from "./TreeRuleObject";
export * from "./shared";

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/types/shared.d.ts

```typescript
import type { EndpointARN, EndpointPartition, Logger } from "@smithy/types";
export type ReferenceObject = {
    ref: string;
};
export type FunctionObject = {
    fn: string;
    argv: FunctionArgv;
};
export type FunctionArgv = Array<Expression | boolean | number>;
export type FunctionReturn = string | boolean | number | EndpointARN | EndpointPartition | {
    [key: string]: FunctionReturn;
} | null;
export type ConditionObject = FunctionObject & {
    assign?: string;
};
export type Expression = string | ReferenceObject | FunctionObject;
export type EndpointParams = Record<string, string | boolean>;
export type EndpointResolverOptions = {
    endpointParams: EndpointParams;
    logger?: Logger;
};
export type ReferenceRecord = Record<string, FunctionReturn>;
export type EvaluateOptions = EndpointResolverOptions & {
    referenceRecord: ReferenceRecord;
};

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/utils/callFunction.d.ts

```typescript
export { callFunction } from "./evaluateExpression";

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/utils/customEndpointFunctions.d.ts

```typescript
import type { EndpointFunctions } from "../types/EndpointFunctions";
export declare const customEndpointFunctions: {
    [key: string]: EndpointFunctions;
};

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/utils/endpointFunctions.d.ts

```typescript
export declare const endpointFunctions: {
    booleanEquals: (value1: boolean, value2: boolean) => boolean;
    getAttr: (value: import("../lib").GetAttrValue, path: string) => import("../lib").GetAttrValue;
    isSet: (value: unknown) => value is {};
    isValidHostLabel: (value: string, allowSubDomains?: boolean) => boolean;
    not: (value: boolean) => boolean;
    parseURL: (value: string | URL | import("@smithy/types").Endpoint) => import("@smithy/types").EndpointURL | null;
    stringEquals: (value1: string, value2: string) => boolean;
    substring: (input: string, start: number, stop: number, reverse: boolean) => string | null;
    uriEncode: (value: string) => string;
};

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/utils/evaluateCondition.d.ts

```typescript
import type { ConditionObject, EvaluateOptions } from "../types";
export declare const evaluateCondition: ({ assign, ...fnArgs }: ConditionObject, options: EvaluateOptions) => {
    toAssign?: {
        name: string;
        value: import("../types").FunctionReturn;
    } | undefined;
    result: boolean;
};

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/utils/evaluateConditions.d.ts

```typescript
import type { ConditionObject, EvaluateOptions, FunctionReturn } from "../types";
export declare const evaluateConditions: (conditions: ConditionObject[] | undefined, options: EvaluateOptions) => {
    result: false;
    referenceRecord?: undefined;
} | {
    result: boolean;
    referenceRecord: Record<string, FunctionReturn>;
};

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/utils/evaluateEndpointRule.d.ts

```typescript
import type { EndpointV2 } from "@smithy/types";
import type { EndpointRuleObject, EvaluateOptions } from "../types";
export declare const evaluateEndpointRule: (endpointRule: EndpointRuleObject, options: EvaluateOptions) => EndpointV2 | undefined;

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/utils/evaluateErrorRule.d.ts

```typescript
import type { ErrorRuleObject, EvaluateOptions } from "../types";
export declare const evaluateErrorRule: (errorRule: ErrorRuleObject, options: EvaluateOptions) => void;

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/utils/evaluateExpression.d.ts

```typescript
import type { EvaluateOptions, Expression, FunctionObject, FunctionReturn } from "../types";
export declare const evaluateExpression: (obj: Expression, keyName: string, options: EvaluateOptions) => FunctionReturn;
export declare const callFunction: ({ fn, argv }: FunctionObject, options: EvaluateOptions) => FunctionReturn;
export declare const group: {
    evaluateExpression: (obj: Expression, keyName: string, options: EvaluateOptions) => FunctionReturn;
    callFunction: ({ fn, argv }: FunctionObject, options: EvaluateOptions) => FunctionReturn;
};

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/utils/evaluateRules.d.ts

```typescript
import type { EndpointV2 } from "@smithy/types";
import type { EvaluateOptions, RuleSetRules, TreeRuleObject } from "../types";
export declare const evaluateRules: (rules: RuleSetRules, options: EvaluateOptions) => EndpointV2;
export declare const evaluateTreeRule: (treeRule: TreeRuleObject, options: EvaluateOptions) => EndpointV2 | undefined;
export declare const group: {
    evaluateRules: (rules: RuleSetRules, options: EvaluateOptions) => EndpointV2;
    evaluateTreeRule: (treeRule: TreeRuleObject, options: EvaluateOptions) => EndpointV2 | undefined;
};

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/utils/evaluateTemplate.d.ts

```typescript
import type { EvaluateOptions } from "../types";
export declare const evaluateTemplate: (template: string, options: EvaluateOptions) => string;

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/utils/evaluateTreeRule.d.ts

```typescript
export { evaluateTreeRule } from "./evaluateRules";

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/utils/getEndpointHeaders.d.ts

```typescript
import type { EndpointObjectHeaders, EvaluateOptions } from "../types";
export declare const getEndpointHeaders: (headers: EndpointObjectHeaders, options: EvaluateOptions) => {};

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/utils/getEndpointProperties.d.ts

```typescript
import type { EndpointObjectProperty } from "@smithy/types";
import type { EndpointObjectProperties, EvaluateOptions } from "../types";
export declare const getEndpointProperties: (properties: EndpointObjectProperties, options: EvaluateOptions) => {};
export declare const getEndpointProperty: (property: EndpointObjectProperty, options: EvaluateOptions) => EndpointObjectProperty;
export declare const group: {
    getEndpointProperty: (property: EndpointObjectProperty, options: EvaluateOptions) => EndpointObjectProperty;
    getEndpointProperties: (properties: EndpointObjectProperties, options: EvaluateOptions) => {};
};

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/utils/getEndpointProperty.d.ts

```typescript
export { getEndpointProperty } from "./getEndpointProperties";

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/utils/getEndpointUrl.d.ts

```typescript
import type { EvaluateOptions, Expression } from "../types";
export declare const getEndpointUrl: (endpointUrl: Expression, options: EvaluateOptions) => URL;

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/utils/getReferenceValue.d.ts

```typescript
import type { EvaluateOptions, ReferenceObject } from "../types";
export declare const getReferenceValue: ({ ref }: ReferenceObject, options: EvaluateOptions) => import("../types").FunctionReturn;

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/dist-types/utils/index.d.ts

```typescript
export * from "./customEndpointFunctions";
export * from "./evaluateRules";

```

## ./lib/lambda/node_modules/@smithy/util-endpoints/package.json

```json
{
  "name": "@smithy/util-endpoints",
  "version": "3.2.3",
  "description": "Utilities to help with endpoint resolution.",
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline util-endpoints",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "rimraf dist-types/ts3.4 && downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../../.prettierignore --write \"**/*.{ts,md,json}\"",
    "test": "yarn g:vitest run",
    "test:integration": "yarn g:vitest run -c vitest.config.integ.mts",
    "test:watch": "yarn g:vitest watch",
    "test:integration:watch": "yarn g:vitest watch -c vitest.config.integ.mts"
  },
  "keywords": [
    "endpoint"
  ],
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "sideEffects": false,
  "dependencies": {
    "@smithy/node-config-provider": "^4.3.3",
    "@smithy/types": "^4.8.0",
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "@types/node": "^18.11.9",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "types": "./dist-types/index.d.ts",
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "types/*": [
        "types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/smithy-lang/smithy-typescript/tree/master/packages/util-endpoints",
  "repository": {
    "type": "git",
    "url": "https://github.com/smithy-lang/smithy-typescript.git",
    "directory": "packages/util-endpoints"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  }
}
```

## ./lib/lambda/node_modules/@smithy/util-hex-encoding/dist-types/index.d.ts

```typescript
/**
 * Converts a hexadecimal encoded string to a Uint8Array of bytes.
 *
 * @param encoded The hexadecimal encoded string
 */
export declare function fromHex(encoded: string): Uint8Array;
/**
 * Converts a Uint8Array of binary data to a hexadecimal encoded string.
 *
 * @param bytes The binary data to encode
 */
export declare function toHex(bytes: Uint8Array): string;

```

## ./lib/lambda/node_modules/@smithy/util-hex-encoding/dist-types/ts3.4/index.d.ts

```typescript
/**
 * Converts a hexadecimal encoded string to a Uint8Array of bytes.
 *
 * @param encoded The hexadecimal encoded string
 */
export declare function fromHex(encoded: string): Uint8Array;
/**
 * Converts a Uint8Array of binary data to a hexadecimal encoded string.
 *
 * @param bytes The binary data to encode
 */
export declare function toHex(bytes: Uint8Array): string;

```

## ./lib/lambda/node_modules/@smithy/util-hex-encoding/package.json

```json
{
  "name": "@smithy/util-hex-encoding",
  "version": "4.2.0",
  "description": "Converts binary buffers to and from lowercase hexadecimal encoding",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline util-hex-encoding",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "rimraf dist-types/ts3.4 && downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../../.prettierignore --write \"**/*.{ts,md,json}\"",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch"
  },
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "sideEffects": false,
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "dependencies": {
    "tslib": "^2.6.2"
  },
  "types": "./dist-types/index.d.ts",
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/smithy-lang/smithy-typescript/tree/main/packages/util-hex-encoding",
  "repository": {
    "type": "git",
    "url": "https://github.com/smithy-lang/smithy-typescript.git",
    "directory": "packages/util-hex-encoding"
  },
  "devDependencies": {
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  }
}
```

## ./lib/lambda/node_modules/@smithy/util-middleware/dist-types/getSmithyContext.d.ts

```typescript
import type { HandlerExecutionContext } from "@smithy/types";
/**
 * @internal
 */
export declare const getSmithyContext: (context: HandlerExecutionContext) => Record<string, unknown>;

```

## ./lib/lambda/node_modules/@smithy/util-middleware/dist-types/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./getSmithyContext";
/**
 * @internal
 */
export * from "./normalizeProvider";

```

## ./lib/lambda/node_modules/@smithy/util-middleware/dist-types/normalizeProvider.d.ts

```typescript
import type { Provider } from "@smithy/types";
/**
 * @internal
 *
 * @returns a provider function for the input value if it isn't already one.
 */
export declare const normalizeProvider: <T>(input: T | Provider<T>) => Provider<T>;

```

## ./lib/lambda/node_modules/@smithy/util-middleware/dist-types/ts3.4/getSmithyContext.d.ts

```typescript
import { HandlerExecutionContext } from "@smithy/types";
/**
 * @internal
 */
export declare const getSmithyContext: (context: HandlerExecutionContext) => Record<string, unknown>;

```

## ./lib/lambda/node_modules/@smithy/util-middleware/dist-types/ts3.4/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./getSmithyContext";
/**
 * @internal
 */
export * from "./normalizeProvider";

```

## ./lib/lambda/node_modules/@smithy/util-middleware/dist-types/ts3.4/normalizeProvider.d.ts

```typescript
import { Provider } from "@smithy/types";
/**
 * @internal
 *
 * @returns a provider function for the input value if it isn't already one.
 */
export declare const normalizeProvider: <T>(input: T | Provider<T>) => Provider<T>;

```

## ./lib/lambda/node_modules/@smithy/util-middleware/package.json

```json
{
  "name": "@smithy/util-middleware",
  "version": "4.2.3",
  "description": "Shared utilities for to be used in middleware packages.",
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline util-middleware",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "rimraf dist-types/ts3.4 && downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../../.prettierignore --write \"**/*.{ts,md,json}\"",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch"
  },
  "keywords": [
    "aws",
    "middleware"
  ],
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "sideEffects": false,
  "dependencies": {
    "@smithy/types": "^4.8.0",
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "@types/node": "^18.11.9",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "types": "./dist-types/index.d.ts",
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "types/*": [
        "types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/smithy-lang/smithy-typescript/tree/master/packages/util-middleware",
  "repository": {
    "type": "git",
    "url": "https://github.com/smithy-lang/smithy-typescript.git",
    "directory": "packages/util-middleware"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  }
}
```

## ./lib/lambda/node_modules/@smithy/util-retry/dist-types/AdaptiveRetryStrategy.d.ts

```typescript
import type { Provider, RetryErrorInfo, RetryStrategyV2, RetryToken, StandardRetryToken } from "@smithy/types";
import type { RateLimiter } from "./types";
/**
 * @public
 *
 * Strategy options to be passed to AdaptiveRetryStrategy
 */
export interface AdaptiveRetryStrategyOptions {
    rateLimiter?: RateLimiter;
}
/**
 * @public
 *
 * The AdaptiveRetryStrategy is a retry strategy for executing against a very
 * resource constrained set of resources. Care should be taken when using this
 * retry strategy. By default, it uses a dynamic backoff delay based on load
 * currently perceived against the downstream resource and performs circuit
 * breaking to disable retries in the event of high downstream failures using
 * the DefaultRateLimiter.
 *
 * @see {@link StandardRetryStrategy}
 * @see {@link DefaultRateLimiter }
 */
export declare class AdaptiveRetryStrategy implements RetryStrategyV2 {
    private readonly maxAttemptsProvider;
    private rateLimiter;
    private standardRetryStrategy;
    readonly mode: string;
    constructor(maxAttemptsProvider: Provider<number>, options?: AdaptiveRetryStrategyOptions);
    acquireInitialRetryToken(retryTokenScope: string): Promise<RetryToken>;
    refreshRetryTokenForRetry(tokenToRenew: StandardRetryToken, errorInfo: RetryErrorInfo): Promise<RetryToken>;
    recordSuccess(token: StandardRetryToken): void;
}

```

## ./lib/lambda/node_modules/@smithy/util-retry/dist-types/ConfiguredRetryStrategy.d.ts

```typescript
import type { Provider, RetryBackoffStrategy, RetryErrorInfo, RetryStrategyV2, StandardRetryToken } from "@smithy/types";
import { StandardRetryStrategy } from "./StandardRetryStrategy";
/**
 * @public
 *
 * This extension of the StandardRetryStrategy allows customizing the
 * backoff computation.
 */
export declare class ConfiguredRetryStrategy extends StandardRetryStrategy implements RetryStrategyV2 {
    private readonly computeNextBackoffDelay;
    /**
     * @param maxAttempts - the maximum number of retry attempts allowed.
     *                      e.g., if set to 3, then 4 total requests are possible.
     * @param computeNextBackoffDelay - a millisecond delay for each retry or a function that takes the retry attempt
     *                                  and returns the delay.
     *
     * @example exponential backoff.
     * ```js
     * new Client({
     *   retryStrategy: new ConfiguredRetryStrategy(3, (attempt) => attempt ** 2)
     * });
     * ```
     * @example constant delay.
     * ```js
     * new Client({
     *   retryStrategy: new ConfiguredRetryStrategy(3, 2000)
     * });
     * ```
     */
    constructor(maxAttempts: number | Provider<number>, computeNextBackoffDelay?: number | RetryBackoffStrategy["computeNextBackoffDelay"]);
    refreshRetryTokenForRetry(tokenToRenew: StandardRetryToken, errorInfo: RetryErrorInfo): Promise<StandardRetryToken>;
}

```

## ./lib/lambda/node_modules/@smithy/util-retry/dist-types/DefaultRateLimiter.d.ts

```typescript
import type { RateLimiter } from "./types";
/**
 * @public
 */
export interface DefaultRateLimiterOptions {
    beta?: number;
    minCapacity?: number;
    minFillRate?: number;
    scaleConstant?: number;
    smooth?: number;
}
/**
 * @public
 */
export declare class DefaultRateLimiter implements RateLimiter {
    /**
     * Only used in testing.
     */
    private static setTimeoutFn;
    private beta;
    private minCapacity;
    private minFillRate;
    private scaleConstant;
    private smooth;
    private currentCapacity;
    private enabled;
    private lastMaxRate;
    private measuredTxRate;
    private requestCount;
    private fillRate;
    private lastThrottleTime;
    private lastTimestamp;
    private lastTxRateBucket;
    private maxCapacity;
    private timeWindow;
    constructor(options?: DefaultRateLimiterOptions);
    private getCurrentTimeInSeconds;
    getSendToken(): Promise<void>;
    private acquireTokenBucket;
    private refillTokenBucket;
    updateClientSendingRate(response: any): void;
    private calculateTimeWindow;
    private cubicThrottle;
    private cubicSuccess;
    private enableTokenBucket;
    private updateTokenBucketRate;
    private updateMeasuredRate;
    private getPrecise;
}

```

## ./lib/lambda/node_modules/@smithy/util-retry/dist-types/StandardRetryStrategy.d.ts

```typescript
import type { Provider, RetryErrorInfo, RetryStrategyV2, StandardRetryToken } from "@smithy/types";
/**
 * @public
 */
export declare class StandardRetryStrategy implements RetryStrategyV2 {
    private readonly maxAttempts;
    readonly mode: string;
    private capacity;
    private readonly retryBackoffStrategy;
    private readonly maxAttemptsProvider;
    constructor(maxAttempts: number);
    constructor(maxAttemptsProvider: Provider<number>);
    acquireInitialRetryToken(retryTokenScope: string): Promise<StandardRetryToken>;
    refreshRetryTokenForRetry(token: StandardRetryToken, errorInfo: RetryErrorInfo): Promise<StandardRetryToken>;
    recordSuccess(token: StandardRetryToken): void;
    /**
     * @returns the current available retry capacity.
     *
     * This number decreases when retries are executed and refills when requests or retries succeed.
     */
    getCapacity(): number;
    private getMaxAttempts;
    private shouldRetry;
    private getCapacityCost;
    private isRetryableError;
}

```

## ./lib/lambda/node_modules/@smithy/util-retry/dist-types/config.d.ts

```typescript
/**
 * @public
 */
export declare enum RETRY_MODES {
    STANDARD = "standard",
    ADAPTIVE = "adaptive"
}
/**
 * @public
 *
 * The default value for how many HTTP requests an SDK should make for a
 * single SDK operation invocation before giving up
 */
export declare const DEFAULT_MAX_ATTEMPTS = 3;
/**
 * @public
 *
 * The default retry algorithm to use.
 */
export declare const DEFAULT_RETRY_MODE = RETRY_MODES.STANDARD;

```

## ./lib/lambda/node_modules/@smithy/util-retry/dist-types/constants.d.ts

```typescript
/**
 * @public
 *
 * The base number of milliseconds to use in calculating a suitable cool-down
 * time when a retryable error is encountered.
 */
export declare const DEFAULT_RETRY_DELAY_BASE = 100;
/**
 * @public
 *
 * The maximum amount of time (in milliseconds) that will be used as a delay
 * between retry attempts.
 */
export declare const MAXIMUM_RETRY_DELAY: number;
/**
 * @public
 *
 * The retry delay base (in milliseconds) to use when a throttling error is
 * encountered.
 */
export declare const THROTTLING_RETRY_DELAY_BASE = 500;
/**
 * @public
 *
 * Initial number of retry tokens in Retry Quota
 */
export declare const INITIAL_RETRY_TOKENS = 500;
/**
 * @public
 *
 * The total amount of retry tokens to be decremented from retry token balance.
 */
export declare const RETRY_COST = 5;
/**
 * @public
 *
 * The total amount of retry tokens to be decremented from retry token balance
 * when a throttling error is encountered.
 */
export declare const TIMEOUT_RETRY_COST = 10;
/**
 * @public
 *
 * The total amount of retry token to be incremented from retry token balance
 * if an SDK operation invocation succeeds without requiring a retry request.
 */
export declare const NO_RETRY_INCREMENT = 1;
/**
 * @public
 *
 * Header name for SDK invocation ID
 */
export declare const INVOCATION_ID_HEADER = "amz-sdk-invocation-id";
/**
 * @public
 *
 * Header name for request retry information.
 */
export declare const REQUEST_HEADER = "amz-sdk-request";

```

## ./lib/lambda/node_modules/@smithy/util-retry/dist-types/defaultRetryBackoffStrategy.d.ts

```typescript
import type { StandardRetryBackoffStrategy } from "@smithy/types";
/**
 * @internal
 */
export declare const getDefaultRetryBackoffStrategy: () => StandardRetryBackoffStrategy;

```

## ./lib/lambda/node_modules/@smithy/util-retry/dist-types/defaultRetryToken.d.ts

```typescript
import type { StandardRetryToken } from "@smithy/types";
/**
 * @internal
 */
export declare const createDefaultRetryToken: ({ retryDelay, retryCount, retryCost, }: {
    retryDelay: number;
    retryCount: number;
    retryCost?: number;
}) => StandardRetryToken;

```

## ./lib/lambda/node_modules/@smithy/util-retry/dist-types/index.d.ts

```typescript
export * from "./AdaptiveRetryStrategy";
export * from "./ConfiguredRetryStrategy";
export * from "./DefaultRateLimiter";
export * from "./StandardRetryStrategy";
export * from "./config";
export * from "./constants";
export * from "./types";

```

## ./lib/lambda/node_modules/@smithy/util-retry/dist-types/ts3.4/AdaptiveRetryStrategy.d.ts

```typescript
import { Provider, RetryErrorInfo, RetryStrategyV2, RetryToken, StandardRetryToken } from "@smithy/types";
import { RateLimiter } from "./types";
/**
 * @public
 *
 * Strategy options to be passed to AdaptiveRetryStrategy
 */
export interface AdaptiveRetryStrategyOptions {
    rateLimiter?: RateLimiter;
}
/**
 * @public
 *
 * The AdaptiveRetryStrategy is a retry strategy for executing against a very
 * resource constrained set of resources. Care should be taken when using this
 * retry strategy. By default, it uses a dynamic backoff delay based on load
 * currently perceived against the downstream resource and performs circuit
 * breaking to disable retries in the event of high downstream failures using
 * the DefaultRateLimiter.
 *
 * @see {@link StandardRetryStrategy}
 * @see {@link DefaultRateLimiter }
 */
export declare class AdaptiveRetryStrategy implements RetryStrategyV2 {
    private readonly maxAttemptsProvider;
    private rateLimiter;
    private standardRetryStrategy;
    readonly mode: string;
    constructor(maxAttemptsProvider: Provider<number>, options?: AdaptiveRetryStrategyOptions);
    acquireInitialRetryToken(retryTokenScope: string): Promise<RetryToken>;
    refreshRetryTokenForRetry(tokenToRenew: StandardRetryToken, errorInfo: RetryErrorInfo): Promise<RetryToken>;
    recordSuccess(token: StandardRetryToken): void;
}

```

## ./lib/lambda/node_modules/@smithy/util-retry/dist-types/ts3.4/ConfiguredRetryStrategy.d.ts

```typescript
import { Provider, RetryBackoffStrategy, RetryErrorInfo, RetryStrategyV2, StandardRetryToken } from "@smithy/types";
import { StandardRetryStrategy } from "./StandardRetryStrategy";
/**
 * @public
 *
 * This extension of the StandardRetryStrategy allows customizing the
 * backoff computation.
 */
export declare class ConfiguredRetryStrategy extends StandardRetryStrategy implements RetryStrategyV2 {
    private readonly computeNextBackoffDelay;
    /**
     * @param maxAttempts - the maximum number of retry attempts allowed.
     *                      e.g., if set to 3, then 4 total requests are possible.
     * @param computeNextBackoffDelay - a millisecond delay for each retry or a function that takes the retry attempt
     *                                  and returns the delay.
     *
     * @example exponential backoff.
     * ```js
     * new Client({
     *   retryStrategy: new ConfiguredRetryStrategy(3, (attempt) => attempt ** 2)
     * });
     * ```
     * @example constant delay.
     * ```js
     * new Client({
     *   retryStrategy: new ConfiguredRetryStrategy(3, 2000)
     * });
     * ```
     */
    constructor(maxAttempts: number | Provider<number>, computeNextBackoffDelay?: number | RetryBackoffStrategy["computeNextBackoffDelay"]);
    refreshRetryTokenForRetry(tokenToRenew: StandardRetryToken, errorInfo: RetryErrorInfo): Promise<StandardRetryToken>;
}

```

## ./lib/lambda/node_modules/@smithy/util-retry/dist-types/ts3.4/DefaultRateLimiter.d.ts

```typescript
import { RateLimiter } from "./types";
/**
 * @public
 */
export interface DefaultRateLimiterOptions {
    beta?: number;
    minCapacity?: number;
    minFillRate?: number;
    scaleConstant?: number;
    smooth?: number;
}
/**
 * @public
 */
export declare class DefaultRateLimiter implements RateLimiter {
    /**
     * Only used in testing.
     */
    private static setTimeoutFn;
    private beta;
    private minCapacity;
    private minFillRate;
    private scaleConstant;
    private smooth;
    private currentCapacity;
    private enabled;
    private lastMaxRate;
    private measuredTxRate;
    private requestCount;
    private fillRate;
    private lastThrottleTime;
    private lastTimestamp;
    private lastTxRateBucket;
    private maxCapacity;
    private timeWindow;
    constructor(options?: DefaultRateLimiterOptions);
    private getCurrentTimeInSeconds;
    getSendToken(): Promise<void>;
    private acquireTokenBucket;
    private refillTokenBucket;
    updateClientSendingRate(response: any): void;
    private calculateTimeWindow;
    private cubicThrottle;
    private cubicSuccess;
    private enableTokenBucket;
    private updateTokenBucketRate;
    private updateMeasuredRate;
    private getPrecise;
}

```

## ./lib/lambda/node_modules/@smithy/util-retry/dist-types/ts3.4/StandardRetryStrategy.d.ts

```typescript
import { Provider, RetryErrorInfo, RetryStrategyV2, StandardRetryToken } from "@smithy/types";
/**
 * @public
 */
export declare class StandardRetryStrategy implements RetryStrategyV2 {
    private readonly maxAttempts;
    readonly mode: string;
    private capacity;
    private readonly retryBackoffStrategy;
    private readonly maxAttemptsProvider;
    constructor(maxAttempts: number);
    constructor(maxAttemptsProvider: Provider<number>);
    acquireInitialRetryToken(retryTokenScope: string): Promise<StandardRetryToken>;
    refreshRetryTokenForRetry(token: StandardRetryToken, errorInfo: RetryErrorInfo): Promise<StandardRetryToken>;
    recordSuccess(token: StandardRetryToken): void;
    /**
     * @returns the current available retry capacity.
     *
     * This number decreases when retries are executed and refills when requests or retries succeed.
     */
    getCapacity(): number;
    private getMaxAttempts;
    private shouldRetry;
    private getCapacityCost;
    private isRetryableError;
}

```

## ./lib/lambda/node_modules/@smithy/util-retry/dist-types/ts3.4/config.d.ts

```typescript
/**
 * @public
 */
export declare enum RETRY_MODES {
    STANDARD = "standard",
    ADAPTIVE = "adaptive"
}
/**
 * @public
 *
 * The default value for how many HTTP requests an SDK should make for a
 * single SDK operation invocation before giving up
 */
export declare const DEFAULT_MAX_ATTEMPTS = 3;
/**
 * @public
 *
 * The default retry algorithm to use.
 */
export declare const DEFAULT_RETRY_MODE = RETRY_MODES.STANDARD;

```

## ./lib/lambda/node_modules/@smithy/util-retry/dist-types/ts3.4/constants.d.ts

```typescript
/**
 * @public
 *
 * The base number of milliseconds to use in calculating a suitable cool-down
 * time when a retryable error is encountered.
 */
export declare const DEFAULT_RETRY_DELAY_BASE = 100;
/**
 * @public
 *
 * The maximum amount of time (in milliseconds) that will be used as a delay
 * between retry attempts.
 */
export declare const MAXIMUM_RETRY_DELAY: number;
/**
 * @public
 *
 * The retry delay base (in milliseconds) to use when a throttling error is
 * encountered.
 */
export declare const THROTTLING_RETRY_DELAY_BASE = 500;
/**
 * @public
 *
 * Initial number of retry tokens in Retry Quota
 */
export declare const INITIAL_RETRY_TOKENS = 500;
/**
 * @public
 *
 * The total amount of retry tokens to be decremented from retry token balance.
 */
export declare const RETRY_COST = 5;
/**
 * @public
 *
 * The total amount of retry tokens to be decremented from retry token balance
 * when a throttling error is encountered.
 */
export declare const TIMEOUT_RETRY_COST = 10;
/**
 * @public
 *
 * The total amount of retry token to be incremented from retry token balance
 * if an SDK operation invocation succeeds without requiring a retry request.
 */
export declare const NO_RETRY_INCREMENT = 1;
/**
 * @public
 *
 * Header name for SDK invocation ID
 */
export declare const INVOCATION_ID_HEADER = "amz-sdk-invocation-id";
/**
 * @public
 *
 * Header name for request retry information.
 */
export declare const REQUEST_HEADER = "amz-sdk-request";

```

## ./lib/lambda/node_modules/@smithy/util-retry/dist-types/ts3.4/defaultRetryBackoffStrategy.d.ts

```typescript
import { StandardRetryBackoffStrategy } from "@smithy/types";
/**
 * @internal
 */
export declare const getDefaultRetryBackoffStrategy: () => StandardRetryBackoffStrategy;

```

## ./lib/lambda/node_modules/@smithy/util-retry/dist-types/ts3.4/defaultRetryToken.d.ts

```typescript
import { StandardRetryToken } from "@smithy/types";
/**
 * @internal
 */
export declare const createDefaultRetryToken: ({ retryDelay, retryCount, retryCost, }: {
    retryDelay: number;
    retryCount: number;
    retryCost?: number;
}) => StandardRetryToken;

```

## ./lib/lambda/node_modules/@smithy/util-retry/dist-types/ts3.4/index.d.ts

```typescript
export * from "./AdaptiveRetryStrategy";
export * from "./ConfiguredRetryStrategy";
export * from "./DefaultRateLimiter";
export * from "./StandardRetryStrategy";
export * from "./config";
export * from "./constants";
export * from "./types";

```

## ./lib/lambda/node_modules/@smithy/util-retry/dist-types/ts3.4/types.d.ts

```typescript
/**
 * @internal
 */
export interface RateLimiter {
    /**
     * If there is sufficient capacity (tokens) available, it immediately returns.
     * If there is not sufficient capacity, it will either sleep a certain amount
     * of time until the rate limiter can retrieve a token from its token bucket
     * or raise an exception indicating there is insufficient capacity.
     */
    getSendToken: () => Promise<void>;
    /**
     * Updates the client sending rate based on response.
     * If the response was successful, the capacity and fill rate are increased.
     * If the response was a throttling response, the capacity and fill rate are
     * decreased. Transient errors do not affect the rate limiter.
     */
    updateClientSendingRate: (response: any) => void;
}

```

## ./lib/lambda/node_modules/@smithy/util-retry/dist-types/types.d.ts

```typescript
/**
 * @internal
 */
export interface RateLimiter {
    /**
     * If there is sufficient capacity (tokens) available, it immediately returns.
     * If there is not sufficient capacity, it will either sleep a certain amount
     * of time until the rate limiter can retrieve a token from its token bucket
     * or raise an exception indicating there is insufficient capacity.
     */
    getSendToken: () => Promise<void>;
    /**
     * Updates the client sending rate based on response.
     * If the response was successful, the capacity and fill rate are increased.
     * If the response was a throttling response, the capacity and fill rate are
     * decreased. Transient errors do not affect the rate limiter.
     */
    updateClientSendingRate: (response: any) => void;
}

```

## ./lib/lambda/node_modules/@smithy/util-retry/package.json

```json
{
  "name": "@smithy/util-retry",
  "version": "4.2.3",
  "description": "Shared retry utilities to be used in middleware packages.",
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline util-retry",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "rimraf dist-types/ts3.4 && downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../../.prettierignore --write \"**/*.{ts,md,json}\"",
    "extract:docs": "api-extractor run --local",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch",
    "test:integration": "yarn g:vitest run -c vitest.config.integ.mts",
    "test:integration:watch": "yarn g:vitest watch -c vitest.config.integ.mts"
  },
  "keywords": [
    "aws",
    "retry"
  ],
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "sideEffects": false,
  "dependencies": {
    "@smithy/service-error-classification": "^4.2.3",
    "@smithy/types": "^4.8.0",
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "@types/node": "^18.11.9",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "types": "./dist-types/index.d.ts",
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "types/*": [
        "types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/smithy-lang/smithy-typescript/tree/master/packages/util-retry",
  "repository": {
    "type": "git",
    "url": "https://github.com/smithy-lang/smithy-typescript.git",
    "directory": "packages/util-retry"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  }
}
```

## ./lib/lambda/node_modules/@smithy/util-stream/dist-types/ByteArrayCollector.d.ts

```typescript
/**
 * Aggregates byteArrays on demand.
 * @internal
 */
export declare class ByteArrayCollector {
    readonly allocByteArray: (size: number) => Uint8Array;
    byteLength: number;
    private byteArrays;
    constructor(allocByteArray: (size: number) => Uint8Array);
    push(byteArray: Uint8Array): void;
    flush(): Uint8Array;
    private reset;
}

```

## ./lib/lambda/node_modules/@smithy/util-stream/dist-types/blob/Uint8ArrayBlobAdapter.d.ts

```typescript
/**
 * Adapter for conversions of the native Uint8Array type.
 * @public
 */
export declare class Uint8ArrayBlobAdapter extends Uint8Array {
    /**
     * @param source - such as a string or Stream.
     * @param encoding - utf-8 or base64.
     * @returns a new Uint8ArrayBlobAdapter extending Uint8Array.
     */
    static fromString(source: string, encoding?: string): Uint8ArrayBlobAdapter;
    /**
     * @param source - Uint8Array to be mutated.
     * @returns the same Uint8Array but with prototype switched to Uint8ArrayBlobAdapter.
     */
    static mutate(source: Uint8Array): Uint8ArrayBlobAdapter;
    /**
     * @param encoding - default 'utf-8'.
     * @returns the blob as string.
     */
    transformToString(encoding?: string): string;
}

```

## ./lib/lambda/node_modules/@smithy/util-stream/dist-types/checksum/ChecksumStream.browser.d.ts

```typescript
import type { Checksum, Encoder } from "@smithy/types";
/**
 * @internal
 */
export interface ChecksumStreamInit {
    /**
     * Base64 value of the expected checksum.
     */
    expectedChecksum: string;
    /**
     * For error messaging, the location from which the checksum value was read.
     */
    checksumSourceLocation: string;
    /**
     * The checksum calculator.
     */
    checksum: Checksum;
    /**
     * The stream to be checked.
     */
    source: ReadableStream;
    /**
     * Optional base 64 encoder if calling from a request context.
     */
    base64Encoder?: Encoder;
}
declare const ChecksumStream_base: any;
/**
 * This stub exists so that the readable returned by createChecksumStream
 * identifies as "ChecksumStream" in alignment with the Node.js
 * implementation.
 *
 * @extends ReadableStream
 */
export declare class ChecksumStream extends ChecksumStream_base {
}
export {};

```

## ./lib/lambda/node_modules/@smithy/util-stream/dist-types/checksum/ChecksumStream.d.ts

```typescript
import type { Checksum, Encoder } from "@smithy/types";
import type { Readable } from "stream";
import { Duplex } from "stream";
/**
 * @internal
 */
export interface ChecksumStreamInit<T extends Readable | ReadableStream> {
    /**
     * Base64 value of the expected checksum.
     */
    expectedChecksum: string;
    /**
     * For error messaging, the location from which the checksum value was read.
     */
    checksumSourceLocation: string;
    /**
     * The checksum calculator.
     */
    checksum: Checksum;
    /**
     * The stream to be checked.
     */
    source: T;
    /**
     * Optional base 64 encoder if calling from a request context.
     */
    base64Encoder?: Encoder;
}
/**
 * @internal
 *
 * Wrapper for throwing checksum errors for streams without
 * buffering the stream.
 *
 */
export declare class ChecksumStream extends Duplex {
    private expectedChecksum;
    private checksumSourceLocation;
    private checksum;
    private source?;
    private base64Encoder;
    constructor({ expectedChecksum, checksum, source, checksumSourceLocation, base64Encoder, }: ChecksumStreamInit<Readable>);
    /**
     * @internal do not call this directly.
     */
    _read(size: number): void;
    /**
     * @internal do not call this directly.
     *
     * When the upstream source flows data to this stream,
     * calculate a step update of the checksum.
     */
    _write(chunk: Buffer, encoding: string, callback: (err?: Error) => void): void;
    /**
     * @internal do not call this directly.
     *
     * When the upstream source finishes, perform the checksum comparison.
     */
    _final(callback: (err?: Error) => void): Promise<void>;
}

```

## ./lib/lambda/node_modules/@smithy/util-stream/dist-types/checksum/createChecksumStream.browser.d.ts

```typescript
import type { ChecksumStreamInit } from "./ChecksumStream.browser";
/**
 * @internal
 * Alias prevents compiler from turning
 * ReadableStream into ReadableStream<any>, which is incompatible
 * with the NodeJS.ReadableStream global type.
 */
export type ReadableStreamType = ReadableStream;
/**
 * @internal
 *
 * Creates a stream adapter for throwing checksum errors for streams without
 * buffering the stream.
 */
export declare const createChecksumStream: ({ expectedChecksum, checksum, source, checksumSourceLocation, base64Encoder, }: ChecksumStreamInit) => ReadableStreamType;

```

## ./lib/lambda/node_modules/@smithy/util-stream/dist-types/checksum/createChecksumStream.d.ts

```typescript
import type { Readable } from "stream";
import type { ChecksumStreamInit } from "./ChecksumStream";
import type { ReadableStreamType } from "./createChecksumStream.browser";
/**
 * @internal
 *
 * Creates a stream mirroring the input stream's interface, but
 * performs checksumming when reading to the end of the stream.
 */
export declare function createChecksumStream(init: ChecksumStreamInit<ReadableStreamType>): ReadableStreamType;
export declare function createChecksumStream(init: ChecksumStreamInit<Readable>): Readable;

```

## ./lib/lambda/node_modules/@smithy/util-stream/dist-types/createBufferedReadable.d.ts

```typescript
import type { Logger } from "@smithy/types";
import { Readable } from "node:stream";
/**
 * @internal
 * @param upstream - any Readable or ReadableStream.
 * @param size - byte or character length minimum. Buffering occurs when a chunk fails to meet this value.
 * @param onBuffer - for emitting warnings when buffering occurs.
 * @returns another stream of the same data and stream class, but buffers chunks until
 * the minimum size is met, except for the last chunk.
 */
export declare function createBufferedReadable(upstream: Readable, size: number, logger?: Logger): Readable;
export declare function createBufferedReadable(upstream: ReadableStream, size: number, logger?: Logger): ReadableStream;

```

## ./lib/lambda/node_modules/@smithy/util-stream/dist-types/createBufferedReadableStream.d.ts

```typescript
import type { Logger } from "@smithy/types";
import { ByteArrayCollector } from "./ByteArrayCollector";
export type BufferStore = [string, ByteArrayCollector, ByteArrayCollector?];
export type BufferUnion = string | Uint8Array;
export type Modes = 0 | 1 | 2;
/**
 * @internal
 * @param upstream - any ReadableStream.
 * @param size - byte or character length minimum. Buffering occurs when a chunk fails to meet this value.
 * @param logger - for emitting warnings when buffering occurs.
 * @returns another stream of the same data, but buffers chunks until
 * the minimum size is met, except for the last chunk.
 */
export declare function createBufferedReadableStream(upstream: ReadableStream, size: number, logger?: Logger): ReadableStream;
/**
 * Replaces R/RS polymorphic implementation in environments with only ReadableStream.
 * @internal
 */
export declare const createBufferedReadable: typeof createBufferedReadableStream;
/**
 * @internal
 * @param buffers
 * @param mode
 * @param chunk
 * @returns the new buffer size after merging the chunk with its appropriate buffer.
 */
export declare function merge(buffers: BufferStore, mode: Modes, chunk: string | Uint8Array): number;
/**
 * @internal
 * @param buffers
 * @param mode
 * @returns the buffer matching the mode.
 */
export declare function flush(buffers: BufferStore, mode: Modes | -1): BufferUnion;
/**
 * @internal
 * @param chunk
 * @returns size of the chunk in bytes or characters.
 */
export declare function sizeOf(chunk?: {
    byteLength?: number;
    length?: number;
}): number;
/**
 * @internal
 * @param chunk - from upstream Readable.
 * @param allowBuffer - allow mode 2 (Buffer), otherwise Buffer will return mode 1.
 * @returns type index of the chunk.
 */
export declare function modeOf(chunk: BufferUnion, allowBuffer?: boolean): Modes | -1;

```

## ./lib/lambda/node_modules/@smithy/util-stream/dist-types/getAwsChunkedEncodingStream.browser.d.ts

```typescript
import type { GetAwsChunkedEncodingStream } from "@smithy/types";
/**
 * @internal
 */
export declare const getAwsChunkedEncodingStream: GetAwsChunkedEncodingStream<ReadableStream>;

```

## ./lib/lambda/node_modules/@smithy/util-stream/dist-types/getAwsChunkedEncodingStream.d.ts

```typescript
import type { GetAwsChunkedEncodingStream } from "@smithy/types";
import { Readable } from "stream";
/**
 * @internal
 */
export declare const getAwsChunkedEncodingStream: GetAwsChunkedEncodingStream<Readable>;

```

## ./lib/lambda/node_modules/@smithy/util-stream/dist-types/headStream.browser.d.ts

```typescript
/**
 * @internal
 * @param stream
 * @param bytes - read head bytes from the stream and discard the rest of it.
 *
 * Caution: the input stream must be destroyed separately, this function does not do so.
 */
export declare function headStream(stream: ReadableStream, bytes: number): Promise<Uint8Array>;

```

## ./lib/lambda/node_modules/@smithy/util-stream/dist-types/headStream.d.ts

```typescript
import type { Readable } from "stream";
/**
 * @internal
 * @param stream - to be read.
 * @param bytes - read head bytes from the stream and discard the rest of it.
 *
 * Caution: the input stream must be destroyed separately, this function does not do so.
 */
export declare const headStream: (stream: Readable | ReadableStream, bytes: number) => Promise<Uint8Array>;

```

## ./lib/lambda/node_modules/@smithy/util-stream/dist-types/index.d.ts

```typescript
export * from "./blob/Uint8ArrayBlobAdapter";
export * from "./checksum/ChecksumStream";
export * from "./checksum/createChecksumStream";
export * from "./createBufferedReadable";
export * from "./getAwsChunkedEncodingStream";
export * from "./headStream";
export * from "./sdk-stream-mixin";
export * from "./splitStream";
export * from "./stream-type-check";

```

## ./lib/lambda/node_modules/@smithy/util-stream/dist-types/sdk-stream-mixin.browser.d.ts

```typescript
import type { SdkStream } from "@smithy/types";
/**
 * The stream handling utility functions for browsers and React Native
 *
 * @internal
 */
export declare const sdkStreamMixin: (stream: unknown) => SdkStream<ReadableStream | Blob>;

```

## ./lib/lambda/node_modules/@smithy/util-stream/dist-types/sdk-stream-mixin.d.ts

```typescript
import type { SdkStream } from "@smithy/types";
import { Readable } from "stream";
/**
 * The function that mixes in the utility functions to help consuming runtime-specific payload stream.
 *
 * @internal
 */
export declare const sdkStreamMixin: (stream: unknown) => SdkStream<ReadableStream | Blob> | SdkStream<Readable>;

```

## ./lib/lambda/node_modules/@smithy/util-stream/dist-types/splitStream.browser.d.ts

```typescript
/**
 * @param stream
 * @returns stream split into two identical streams.
 */
export declare function splitStream(stream: ReadableStream | Blob): Promise<[ReadableStream, ReadableStream]>;

```

## ./lib/lambda/node_modules/@smithy/util-stream/dist-types/splitStream.d.ts

```typescript
import type { Readable } from "stream";
/**
 * @internal
 * @param stream - to be split.
 * @returns stream split into two identical streams.
 */
export declare function splitStream(stream: Readable): Promise<[Readable, Readable]>;
export declare function splitStream(stream: ReadableStream): Promise<[ReadableStream, ReadableStream]>;

```

## ./lib/lambda/node_modules/@smithy/util-stream/dist-types/stream-type-check.d.ts

```typescript
/**
 * @internal
 * Alias prevents compiler from turning
 * ReadableStream into ReadableStream<any>, which is incompatible
 * with the NodeJS.ReadableStream global type.
 */
type ReadableStreamType = ReadableStream;
/**
 * @internal
 */
export declare const isReadableStream: (stream: unknown) => stream is ReadableStreamType;
/**
 * @internal
 */
export declare const isBlob: (blob: unknown) => blob is Blob;
export {};

```

## ./lib/lambda/node_modules/@smithy/util-stream/dist-types/ts3.4/ByteArrayCollector.d.ts

```typescript
/**
 * Aggregates byteArrays on demand.
 * @internal
 */
export declare class ByteArrayCollector {
    readonly allocByteArray: (size: number) => Uint8Array;
    byteLength: number;
    private byteArrays;
    constructor(allocByteArray: (size: number) => Uint8Array);
    push(byteArray: Uint8Array): void;
    flush(): Uint8Array;
    private reset;
}

```

## ./lib/lambda/node_modules/@smithy/util-stream/dist-types/ts3.4/blob/Uint8ArrayBlobAdapter.d.ts

```typescript
/**
 * Adapter for conversions of the native Uint8Array type.
 * @public
 */
export declare class Uint8ArrayBlobAdapter extends Uint8Array {
    /**
     * @param source - such as a string or Stream.
     * @param encoding - utf-8 or base64.
     * @returns a new Uint8ArrayBlobAdapter extending Uint8Array.
     */
    static fromString(source: string, encoding?: string): Uint8ArrayBlobAdapter;
    /**
     * @param source - Uint8Array to be mutated.
     * @returns the same Uint8Array but with prototype switched to Uint8ArrayBlobAdapter.
     */
    static mutate(source: Uint8Array): Uint8ArrayBlobAdapter;
    /**
     * @param encoding - default 'utf-8'.
     * @returns the blob as string.
     */
    transformToString(encoding?: string): string;
}

```

## ./lib/lambda/node_modules/@smithy/util-stream/dist-types/ts3.4/checksum/ChecksumStream.browser.d.ts

```typescript
import { Checksum, Encoder } from "@smithy/types";
/**
 * @internal
 */
export interface ChecksumStreamInit {
    /**
     * Base64 value of the expected checksum.
     */
    expectedChecksum: string;
    /**
     * For error messaging, the location from which the checksum value was read.
     */
    checksumSourceLocation: string;
    /**
     * The checksum calculator.
     */
    checksum: Checksum;
    /**
     * The stream to be checked.
     */
    source: ReadableStream;
    /**
     * Optional base 64 encoder if calling from a request context.
     */
    base64Encoder?: Encoder;
}
declare const ChecksumStream_base: any;
/**
 * This stub exists so that the readable returned by createChecksumStream
 * identifies as "ChecksumStream" in alignment with the Node.js
 * implementation.
 *
 * @extends ReadableStream
 */
export declare class ChecksumStream extends ChecksumStream_base {
}
export {};

```

## ./lib/lambda/node_modules/@smithy/util-stream/dist-types/ts3.4/checksum/ChecksumStream.d.ts

```typescript
import { Checksum, Encoder } from "@smithy/types";
import { Readable } from "stream";
import { Duplex } from "stream";
/**
 * @internal
 */
export interface ChecksumStreamInit<T extends Readable | ReadableStream> {
    /**
     * Base64 value of the expected checksum.
     */
    expectedChecksum: string;
    /**
     * For error messaging, the location from which the checksum value was read.
     */
    checksumSourceLocation: string;
    /**
     * The checksum calculator.
     */
    checksum: Checksum;
    /**
     * The stream to be checked.
     */
    source: T;
    /**
     * Optional base 64 encoder if calling from a request context.
     */
    base64Encoder?: Encoder;
}
/**
 * @internal
 *
 * Wrapper for throwing checksum errors for streams without
 * buffering the stream.
 *
 */
export declare class ChecksumStream extends Duplex {
    private expectedChecksum;
    private checksumSourceLocation;
    private checksum;
    private source?;
    private base64Encoder;
    constructor({ expectedChecksum, checksum, source, checksumSourceLocation, base64Encoder, }: ChecksumStreamInit<Readable>);
    /**
     * @internal do not call this directly.
     */
    _read(size: number): void;
    /**
     * @internal do not call this directly.
     *
     * When the upstream source flows data to this stream,
     * calculate a step update of the checksum.
     */
    _write(chunk: Buffer, encoding: string, callback: (err?: Error) => void): void;
    /**
     * @internal do not call this directly.
     *
     * When the upstream source finishes, perform the checksum comparison.
     */
    _final(callback: (err?: Error) => void): Promise<void>;
}

```

## ./lib/lambda/node_modules/@smithy/util-stream/dist-types/ts3.4/checksum/createChecksumStream.browser.d.ts

```typescript
import { ChecksumStreamInit } from "./ChecksumStream.browser";
/**
 * @internal
 * Alias prevents compiler from turning
 * ReadableStream into ReadableStream<any>, which is incompatible
 * with the NodeJS.ReadableStream global type.
 */
export type ReadableStreamType = ReadableStream;
/**
 * @internal
 *
 * Creates a stream adapter for throwing checksum errors for streams without
 * buffering the stream.
 */
export declare const createChecksumStream: ({ expectedChecksum, checksum, source, checksumSourceLocation, base64Encoder, }: ChecksumStreamInit) => ReadableStreamType;

```

## ./lib/lambda/node_modules/@smithy/util-stream/dist-types/ts3.4/checksum/createChecksumStream.d.ts

```typescript
import { Readable } from "stream";
import { ChecksumStreamInit } from "./ChecksumStream";
import { ReadableStreamType } from "./createChecksumStream.browser";
/**
 * @internal
 *
 * Creates a stream mirroring the input stream's interface, but
 * performs checksumming when reading to the end of the stream.
 */
export declare function createChecksumStream(init: ChecksumStreamInit<ReadableStreamType>): ReadableStreamType;
export declare function createChecksumStream(init: ChecksumStreamInit<Readable>): Readable;

```

## ./lib/lambda/node_modules/@smithy/util-stream/dist-types/ts3.4/createBufferedReadable.d.ts

```typescript
import { Logger } from "@smithy/types";
import { Readable } from "node:stream";
/**
 * @internal
 * @param upstream - any Readable or ReadableStream.
 * @param size - byte or character length minimum. Buffering occurs when a chunk fails to meet this value.
 * @param onBuffer - for emitting warnings when buffering occurs.
 * @returns another stream of the same data and stream class, but buffers chunks until
 * the minimum size is met, except for the last chunk.
 */
export declare function createBufferedReadable(upstream: Readable, size: number, logger?: Logger): Readable;
export declare function createBufferedReadable(upstream: ReadableStream, size: number, logger?: Logger): ReadableStream;

```

## ./lib/lambda/node_modules/@smithy/util-stream/dist-types/ts3.4/createBufferedReadableStream.d.ts

```typescript
import { Logger } from "@smithy/types";
import { ByteArrayCollector } from "./ByteArrayCollector";
export type BufferStore = [
    string,
    ByteArrayCollector,
    ByteArrayCollector?
];
export type BufferUnion = string | Uint8Array;
export type Modes = 0 | 1 | 2;
/**
 * @internal
 * @param upstream - any ReadableStream.
 * @param size - byte or character length minimum. Buffering occurs when a chunk fails to meet this value.
 * @param logger - for emitting warnings when buffering occurs.
 * @returns another stream of the same data, but buffers chunks until
 * the minimum size is met, except for the last chunk.
 */
export declare function createBufferedReadableStream(upstream: ReadableStream, size: number, logger?: Logger): ReadableStream;
/**
 * Replaces R/RS polymorphic implementation in environments with only ReadableStream.
 * @internal
 */
export declare const createBufferedReadable: typeof createBufferedReadableStream;
/**
 * @internal
 * @param buffers
 * @param mode
 * @param chunk
 * @returns the new buffer size after merging the chunk with its appropriate buffer.
 */
export declare function merge(buffers: BufferStore, mode: Modes, chunk: string | Uint8Array): number;
/**
 * @internal
 * @param buffers
 * @param mode
 * @returns the buffer matching the mode.
 */
export declare function flush(buffers: BufferStore, mode: Modes | -1): BufferUnion;
/**
 * @internal
 * @param chunk
 * @returns size of the chunk in bytes or characters.
 */
export declare function sizeOf(chunk?: {
    byteLength?: number;
    length?: number;
}): number;
/**
 * @internal
 * @param chunk - from upstream Readable.
 * @param allowBuffer - allow mode 2 (Buffer), otherwise Buffer will return mode 1.
 * @returns type index of the chunk.
 */
export declare function modeOf(chunk: BufferUnion, allowBuffer?: boolean): Modes | -1;

```

## ./lib/lambda/node_modules/@smithy/util-stream/dist-types/ts3.4/getAwsChunkedEncodingStream.browser.d.ts

```typescript
import { GetAwsChunkedEncodingStream } from "@smithy/types";
/**
 * @internal
 */
export declare const getAwsChunkedEncodingStream: GetAwsChunkedEncodingStream<ReadableStream>;

```

## ./lib/lambda/node_modules/@smithy/util-stream/dist-types/ts3.4/getAwsChunkedEncodingStream.d.ts

```typescript
import { GetAwsChunkedEncodingStream } from "@smithy/types";
import { Readable } from "stream";
/**
 * @internal
 */
export declare const getAwsChunkedEncodingStream: GetAwsChunkedEncodingStream<Readable>;

```

## ./lib/lambda/node_modules/@smithy/util-stream/dist-types/ts3.4/headStream.browser.d.ts

```typescript
/**
 * @internal
 * @param stream
 * @param bytes - read head bytes from the stream and discard the rest of it.
 *
 * Caution: the input stream must be destroyed separately, this function does not do so.
 */
export declare function headStream(stream: ReadableStream, bytes: number): Promise<Uint8Array>;

```

## ./lib/lambda/node_modules/@smithy/util-stream/dist-types/ts3.4/headStream.d.ts

```typescript
import { Readable } from "stream";
/**
 * @internal
 * @param stream - to be read.
 * @param bytes - read head bytes from the stream and discard the rest of it.
 *
 * Caution: the input stream must be destroyed separately, this function does not do so.
 */
export declare const headStream: (stream: Readable | ReadableStream, bytes: number) => Promise<Uint8Array>;

```

## ./lib/lambda/node_modules/@smithy/util-stream/dist-types/ts3.4/index.d.ts

```typescript
export * from "./blob/Uint8ArrayBlobAdapter";
export * from "./checksum/ChecksumStream";
export * from "./checksum/createChecksumStream";
export * from "./createBufferedReadable";
export * from "./getAwsChunkedEncodingStream";
export * from "./headStream";
export * from "./sdk-stream-mixin";
export * from "./splitStream";
export * from "./stream-type-check";

```

## ./lib/lambda/node_modules/@smithy/util-stream/dist-types/ts3.4/sdk-stream-mixin.browser.d.ts

```typescript
import { SdkStream } from "@smithy/types";
/**
 * The stream handling utility functions for browsers and React Native
 *
 * @internal
 */
export declare const sdkStreamMixin: (stream: unknown) => SdkStream<ReadableStream | Blob>;

```

## ./lib/lambda/node_modules/@smithy/util-stream/dist-types/ts3.4/sdk-stream-mixin.d.ts

```typescript
import { SdkStream } from "@smithy/types";
import { Readable } from "stream";
/**
 * The function that mixes in the utility functions to help consuming runtime-specific payload stream.
 *
 * @internal
 */
export declare const sdkStreamMixin: (stream: unknown) => SdkStream<ReadableStream | Blob> | SdkStream<Readable>;

```

## ./lib/lambda/node_modules/@smithy/util-stream/dist-types/ts3.4/splitStream.browser.d.ts

```typescript
/**
 * @param stream
 * @returns stream split into two identical streams.
 */
export declare function splitStream(stream: ReadableStream | Blob): Promise<[
    ReadableStream,
    ReadableStream
]>;

```

## ./lib/lambda/node_modules/@smithy/util-stream/dist-types/ts3.4/splitStream.d.ts

```typescript
import { Readable } from "stream";
/**
 * @internal
 * @param stream - to be split.
 * @returns stream split into two identical streams.
 */
export declare function splitStream(stream: Readable): Promise<[
    Readable,
    Readable
]>;
export declare function splitStream(stream: ReadableStream): Promise<[
    ReadableStream,
    ReadableStream
]>;

```

## ./lib/lambda/node_modules/@smithy/util-stream/dist-types/ts3.4/stream-type-check.d.ts

```typescript
/**
 * @internal
 * Alias prevents compiler from turning
 * ReadableStream into ReadableStream<any>, which is incompatible
 * with the NodeJS.ReadableStream global type.
 */
type ReadableStreamType = ReadableStream;
/**
 * @internal
 */
export declare const isReadableStream: (stream: unknown) => stream is ReadableStreamType;
/**
 * @internal
 */
export declare const isBlob: (blob: unknown) => blob is Blob;
export {};

```

## ./lib/lambda/node_modules/@smithy/util-stream/package.json

```json
{
  "name": "@smithy/util-stream",
  "version": "4.5.3",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline util-stream",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "rimraf dist-types/ts3.4 && downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../../.prettierignore --write \"**/*.{ts,md,json}\"",
    "extract:docs": "api-extractor run --local",
    "test": "yarn g:vitest run && yarn test:browser",
    "test:integration": "yarn g:vitest run -c vitest.config.integ.mts",
    "test:watch": "yarn g:vitest watch",
    "test:integration:watch": "yarn g:vitest watch -c vitest.config.integ.mts",
    "test:browser": "yarn g:vitest run -c vitest.config.browser.mts",
    "test:browser:watch": "yarn g:vitest watch -c vitest.config.browser.mts"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "sideEffects": false,
  "dependencies": {
    "@smithy/fetch-http-handler": "^5.3.4",
    "@smithy/node-http-handler": "^4.4.2",
    "@smithy/types": "^4.8.0",
    "@smithy/util-base64": "^4.3.0",
    "@smithy/util-buffer-from": "^4.2.0",
    "@smithy/util-hex-encoding": "^4.2.0",
    "@smithy/util-utf8": "^4.2.0",
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "@smithy/util-test": "^0.2.8",
    "@types/node": "^18.11.9",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "browser": {
    "./dist-es/checksum/ChecksumStream": "./dist-es/checksum/ChecksumStream.browser",
    "./dist-es/checksum/createChecksumStream": "./dist-es/checksum/createChecksumStream.browser",
    "./dist-es/createBufferedReadable": "./dist-es/createBufferedReadableStream",
    "./dist-es/getAwsChunkedEncodingStream": "./dist-es/getAwsChunkedEncodingStream.browser",
    "./dist-es/headStream": "./dist-es/headStream.browser",
    "./dist-es/sdk-stream-mixin": "./dist-es/sdk-stream-mixin.browser",
    "./dist-es/splitStream": "./dist-es/splitStream.browser"
  },
  "react-native": {
    "./dist-es/checksum/createChecksumStream": "./dist-es/checksum/createChecksumStream.browser",
    "./dist-es/checksum/ChecksumStream": "./dist-es/checksum/ChecksumStream.browser",
    "./dist-es/getAwsChunkedEncodingStream": "./dist-es/getAwsChunkedEncodingStream.browser",
    "./dist-es/sdk-stream-mixin": "./dist-es/sdk-stream-mixin.browser",
    "./dist-es/headStream": "./dist-es/headStream.browser",
    "./dist-es/splitStream": "./dist-es/splitStream.browser",
    "./dist-es/createBufferedReadable": "./dist-es/createBufferedReadableStream",
    "./dist-cjs/checksum/createChecksumStream": "./dist-cjs/checksum/createChecksumStream.browser",
    "./dist-cjs/checksum/ChecksumStream": "./dist-cjs/checksum/ChecksumStream.browser",
    "./dist-cjs/getAwsChunkedEncodingStream": "./dist-cjs/getAwsChunkedEncodingStream.browser",
    "./dist-cjs/sdk-stream-mixin": "./dist-cjs/sdk-stream-mixin.browser",
    "./dist-cjs/headStream": "./dist-cjs/headStream.browser",
    "./dist-cjs/splitStream": "./dist-cjs/splitStream.browser",
    "./dist-cjs/createBufferedReadable": "./dist-cjs/createBufferedReadableStream"
  },
  "homepage": "https://github.com/smithy-lang/smithy-typescript/tree/main/packages/util-stream",
  "repository": {
    "type": "git",
    "url": "https://github.com/smithy-lang/smithy-typescript.git",
    "directory": "packages/util-stream"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  }
}
```

## ./lib/lambda/node_modules/@smithy/util-uri-escape/dist-types/escape-uri-path.d.ts

```typescript
/**
 * @internal
 */
export declare const escapeUriPath: (uri: string) => string;

```

## ./lib/lambda/node_modules/@smithy/util-uri-escape/dist-types/escape-uri.d.ts

```typescript
/**
 * @internal
 */
export declare const escapeUri: (uri: string) => string;

```

## ./lib/lambda/node_modules/@smithy/util-uri-escape/dist-types/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./escape-uri";
/**
 * @internal
 */
export * from "./escape-uri-path";

```

## ./lib/lambda/node_modules/@smithy/util-uri-escape/dist-types/ts3.4/escape-uri-path.d.ts

```typescript
/**
 * @internal
 */
export declare const escapeUriPath: (uri: string) => string;

```

## ./lib/lambda/node_modules/@smithy/util-uri-escape/dist-types/ts3.4/escape-uri.d.ts

```typescript
/**
 * @internal
 */
export declare const escapeUri: (uri: string) => string;

```

## ./lib/lambda/node_modules/@smithy/util-uri-escape/dist-types/ts3.4/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./escape-uri";
/**
 * @internal
 */
export * from "./escape-uri-path";

```

## ./lib/lambda/node_modules/@smithy/util-uri-escape/package.json

```json
{
  "name": "@smithy/util-uri-escape",
  "version": "4.2.0",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline util-uri-escape",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "rimraf dist-types/ts3.4 && downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../../.prettierignore --write \"**/*.{ts,md,json}\"",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch"
  },
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "sideEffects": false,
  "dependencies": {
    "tslib": "^2.6.2"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/smithy-lang/smithy-typescript/tree/main/packages/util-uri-escape",
  "repository": {
    "type": "git",
    "url": "https://github.com/smithy-lang/smithy-typescript.git",
    "directory": "packages/util-uri-escape"
  },
  "devDependencies": {
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  }
}
```

## ./lib/lambda/node_modules/@smithy/util-utf8/dist-types/fromUtf8.browser.d.ts

```typescript
export declare const fromUtf8: (input: string) => Uint8Array;

```

## ./lib/lambda/node_modules/@smithy/util-utf8/dist-types/fromUtf8.d.ts

```typescript
export declare const fromUtf8: (input: string) => Uint8Array;

```

## ./lib/lambda/node_modules/@smithy/util-utf8/dist-types/index.d.ts

```typescript
export * from "./fromUtf8";
export * from "./toUint8Array";
export * from "./toUtf8";

```

## ./lib/lambda/node_modules/@smithy/util-utf8/dist-types/toUint8Array.d.ts

```typescript
export declare const toUint8Array: (data: string | ArrayBuffer | ArrayBufferView) => Uint8Array;

```

## ./lib/lambda/node_modules/@smithy/util-utf8/dist-types/toUtf8.browser.d.ts

```typescript
/**
 *
 * This does not convert non-utf8 strings to utf8, it only passes through strings if
 * a string is received instead of a Uint8Array.
 *
 */
export declare const toUtf8: (input: Uint8Array | string) => string;

```

## ./lib/lambda/node_modules/@smithy/util-utf8/dist-types/toUtf8.d.ts

```typescript
/**
 *
 * This does not convert non-utf8 strings to utf8, it only passes through strings if
 * a string is received instead of a Uint8Array.
 *
 */
export declare const toUtf8: (input: Uint8Array | string) => string;

```

## ./lib/lambda/node_modules/@smithy/util-utf8/dist-types/ts3.4/fromUtf8.browser.d.ts

```typescript
export declare const fromUtf8: (input: string) => Uint8Array;

```

## ./lib/lambda/node_modules/@smithy/util-utf8/dist-types/ts3.4/fromUtf8.d.ts

```typescript
export declare const fromUtf8: (input: string) => Uint8Array;

```

## ./lib/lambda/node_modules/@smithy/util-utf8/dist-types/ts3.4/index.d.ts

```typescript
export * from "./fromUtf8";
export * from "./toUint8Array";
export * from "./toUtf8";

```

## ./lib/lambda/node_modules/@smithy/util-utf8/dist-types/ts3.4/toUint8Array.d.ts

```typescript
export declare const toUint8Array: (data: string | ArrayBuffer | ArrayBufferView) => Uint8Array;

```

## ./lib/lambda/node_modules/@smithy/util-utf8/dist-types/ts3.4/toUtf8.browser.d.ts

```typescript
/**
 *
 * This does not convert non-utf8 strings to utf8, it only passes through strings if
 * a string is received instead of a Uint8Array.
 *
 */
export declare const toUtf8: (input: Uint8Array | string) => string;

```

## ./lib/lambda/node_modules/@smithy/util-utf8/dist-types/ts3.4/toUtf8.d.ts

```typescript
/**
 *
 * This does not convert non-utf8 strings to utf8, it only passes through strings if
 * a string is received instead of a Uint8Array.
 *
 */
export declare const toUtf8: (input: Uint8Array | string) => string;

```

## ./lib/lambda/node_modules/@smithy/util-utf8/package.json

```json
{
  "name": "@smithy/util-utf8",
  "version": "4.2.0",
  "description": "A UTF-8 string <-> UInt8Array converter",
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline util-utf8",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "rimraf dist-types/ts3.4 && downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../../.prettierignore --write \"**/*.{ts,md,json}\"",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch"
  },
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "sideEffects": false,
  "dependencies": {
    "@smithy/util-buffer-from": "^4.2.0",
    "tslib": "^2.6.2"
  },
  "devDependencies": {
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "types": "./dist-types/index.d.ts",
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "browser": {
    "./dist-es/fromUtf8": "./dist-es/fromUtf8.browser",
    "./dist-es/toUtf8": "./dist-es/toUtf8.browser"
  },
  "react-native": {},
  "homepage": "https://github.com/smithy-lang/smithy-typescript/tree/main/packages/util-utf8",
  "repository": {
    "type": "git",
    "url": "https://github.com/smithy-lang/smithy-typescript.git",
    "directory": "packages/util-utf8"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  }
}
```

## ./lib/lambda/node_modules/@smithy/util-waiter/dist-types/createWaiter.d.ts

```typescript
import type { WaiterOptions, WaiterResult } from "./waiter";
/**
 * Create a waiter promise that only resolves when:
 * 1. Abort controller is signaled
 * 2. Max wait time is reached
 * 3. `acceptorChecks` succeeds, or fails
 * Otherwise, it invokes `acceptorChecks` with exponential-backoff delay.
 *
 * @internal
 */
export declare const createWaiter: <Client, Input>(options: WaiterOptions<Client>, input: Input, acceptorChecks: (client: Client, input: Input) => Promise<WaiterResult>) => Promise<WaiterResult>;

```

## ./lib/lambda/node_modules/@smithy/util-waiter/dist-types/index.d.ts

```typescript
export * from "./createWaiter";
export * from "./waiter";

```

## ./lib/lambda/node_modules/@smithy/util-waiter/dist-types/poller.d.ts

```typescript
import type { WaiterOptions, WaiterResult } from "./waiter";
/**
 * Function that runs polling as part of waiters. This will make one inital attempt and then
 * subsequent attempts with an increasing delay.
 * @param params - options passed to the waiter.
 * @param client - AWS SDK Client
 * @param input - client input
 * @param stateChecker - function that checks the acceptor states on each poll.
 */
export declare const runPolling: <Client, Input>({ minDelay, maxDelay, maxWaitTime, abortController, client, abortSignal }: WaiterOptions<Client>, input: Input, acceptorChecks: (client: Client, input: Input) => Promise<WaiterResult>) => Promise<WaiterResult>;

```

## ./lib/lambda/node_modules/@smithy/util-waiter/dist-types/ts3.4/createWaiter.d.ts

```typescript
import { WaiterOptions, WaiterResult } from "./waiter";
/**
 * Create a waiter promise that only resolves when:
 * 1. Abort controller is signaled
 * 2. Max wait time is reached
 * 3. `acceptorChecks` succeeds, or fails
 * Otherwise, it invokes `acceptorChecks` with exponential-backoff delay.
 *
 * @internal
 */
export declare const createWaiter: <Client, Input>(options: WaiterOptions<Client>, input: Input, acceptorChecks: (client: Client, input: Input) => Promise<WaiterResult>) => Promise<WaiterResult>;

```

## ./lib/lambda/node_modules/@smithy/util-waiter/dist-types/ts3.4/index.d.ts

```typescript
export * from "./createWaiter";
export * from "./waiter";

```

## ./lib/lambda/node_modules/@smithy/util-waiter/dist-types/ts3.4/poller.d.ts

```typescript
import { WaiterOptions, WaiterResult } from "./waiter";
/**
 * Function that runs polling as part of waiters. This will make one inital attempt and then
 * subsequent attempts with an increasing delay.
 * @param params - options passed to the waiter.
 * @param client - AWS SDK Client
 * @param input - client input
 * @param stateChecker - function that checks the acceptor states on each poll.
 */
export declare const runPolling: <Client, Input>({ minDelay, maxDelay, maxWaitTime, abortController, client, abortSignal }: WaiterOptions<Client>, input: Input, acceptorChecks: (client: Client, input: Input) => Promise<WaiterResult>) => Promise<WaiterResult>;

```

## ./lib/lambda/node_modules/@smithy/util-waiter/dist-types/ts3.4/utils/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./sleep";
/**
 * @internal
 */
export * from "./validate";

```

## ./lib/lambda/node_modules/@smithy/util-waiter/dist-types/ts3.4/utils/sleep.d.ts

```typescript
/**
 * @internal
 */
export declare const sleep: (seconds: number) => Promise<unknown>;

```

## ./lib/lambda/node_modules/@smithy/util-waiter/dist-types/ts3.4/utils/validate.d.ts

```typescript
import { WaiterOptions } from "../waiter";
/**
 * @internal
 *
 * Validates that waiter options are passed correctly
 * @param options - a waiter configuration object
 */
export declare const validateWaiterOptions: <Client>(options: WaiterOptions<Client>) => void;

```

## ./lib/lambda/node_modules/@smithy/util-waiter/dist-types/ts3.4/waiter.d.ts

```typescript
import { WaiterConfiguration as WaiterConfiguration__ } from "@smithy/types";
/**
 * @internal
 */
export interface WaiterConfiguration<T> extends WaiterConfiguration__<T> {
}
/**
 * @internal
 */
export declare const waiterServiceDefaults: {
    minDelay: number;
    maxDelay: number;
};
/**
 * @internal
 */
export type WaiterOptions<Client> = WaiterConfiguration<Client> & Required<Pick<WaiterConfiguration<Client>, "minDelay" | "maxDelay">>;
/**
 * @internal
 */
export declare enum WaiterState {
    ABORTED = "ABORTED",
    FAILURE = "FAILURE",
    SUCCESS = "SUCCESS",
    RETRY = "RETRY",
    TIMEOUT = "TIMEOUT"
}
/**
 * @internal
 */
export type WaiterResult = {
    state: WaiterState;
    /**
     * (optional) Indicates a reason for why a waiter has reached its state.
     */
    reason?: any;
    /**
     * Responses observed by the waiter during its polling, where the value
     * is the count.
     */
    observedResponses?: Record<string, number>;
};
/**
 * @internal
 *
 * Handles and throws exceptions resulting from the waiterResult
 * @param result - WaiterResult
 */
export declare const checkExceptions: (result: WaiterResult) => WaiterResult;

```

## ./lib/lambda/node_modules/@smithy/util-waiter/dist-types/utils/index.d.ts

```typescript
/**
 * @internal
 */
export * from "./sleep";
/**
 * @internal
 */
export * from "./validate";

```

## ./lib/lambda/node_modules/@smithy/util-waiter/dist-types/utils/sleep.d.ts

```typescript
/**
 * @internal
 */
export declare const sleep: (seconds: number) => Promise<unknown>;

```

## ./lib/lambda/node_modules/@smithy/util-waiter/dist-types/utils/validate.d.ts

```typescript
import type { WaiterOptions } from "../waiter";
/**
 * @internal
 *
 * Validates that waiter options are passed correctly
 * @param options - a waiter configuration object
 */
export declare const validateWaiterOptions: <Client>(options: WaiterOptions<Client>) => void;

```

## ./lib/lambda/node_modules/@smithy/util-waiter/dist-types/waiter.d.ts

```typescript
import type { WaiterConfiguration as WaiterConfiguration__ } from "@smithy/types";
/**
 * @internal
 */
export interface WaiterConfiguration<T> extends WaiterConfiguration__<T> {
}
/**
 * @internal
 */
export declare const waiterServiceDefaults: {
    minDelay: number;
    maxDelay: number;
};
/**
 * @internal
 */
export type WaiterOptions<Client> = WaiterConfiguration<Client> & Required<Pick<WaiterConfiguration<Client>, "minDelay" | "maxDelay">>;
/**
 * @internal
 */
export declare enum WaiterState {
    ABORTED = "ABORTED",
    FAILURE = "FAILURE",
    SUCCESS = "SUCCESS",
    RETRY = "RETRY",
    TIMEOUT = "TIMEOUT"
}
/**
 * @internal
 */
export type WaiterResult = {
    state: WaiterState;
    /**
     * (optional) Indicates a reason for why a waiter has reached its state.
     */
    reason?: any;
    /**
     * Responses observed by the waiter during its polling, where the value
     * is the count.
     */
    observedResponses?: Record<string, number>;
};
/**
 * @internal
 *
 * Handles and throws exceptions resulting from the waiterResult
 * @param result - WaiterResult
 */
export declare const checkExceptions: (result: WaiterResult) => WaiterResult;

```

## ./lib/lambda/node_modules/@smithy/util-waiter/package.json

```json
{
  "name": "@smithy/util-waiter",
  "version": "4.2.3",
  "description": "Shared utilities for client waiters for the AWS SDK",
  "dependencies": {
    "@smithy/abort-controller": "^4.2.3",
    "@smithy/types": "^4.8.0",
    "tslib": "^2.6.2"
  },
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline util-waiter",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "rimraf dist-types/ts3.4 && downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../../.prettierignore --write \"**/*.{ts,md,json}\"",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch"
  },
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "sideEffects": false,
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/smithy-lang/smithy-typescript/tree/main/packages/util-waiter",
  "repository": {
    "type": "git",
    "url": "https://github.com/smithy-lang/smithy-typescript.git",
    "directory": "packages/util-waiter"
  },
  "devDependencies": {
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  }
}
```

## ./lib/lambda/node_modules/@smithy/uuid/dist-types/index.d.ts

```typescript
export * from "./v4";

```

## ./lib/lambda/node_modules/@smithy/uuid/dist-types/randomUUID.browser.d.ts

```typescript
export declare const randomUUID: false | (() => `${string}-${string}-${string}-${string}-${string}`);

```

## ./lib/lambda/node_modules/@smithy/uuid/dist-types/randomUUID.d.ts

```typescript
import crypto from "crypto";
export declare const randomUUID: typeof crypto.randomUUID;

```

## ./lib/lambda/node_modules/@smithy/uuid/dist-types/randomUUID.native.d.ts

```typescript
export declare const randomUUID: false | (() => `${string}-${string}-${string}-${string}-${string}`);

```

## ./lib/lambda/node_modules/@smithy/uuid/dist-types/ts3.4/index.d.ts

```typescript
export * from "./v4";

```

## ./lib/lambda/node_modules/@smithy/uuid/dist-types/ts3.4/randomUUID.browser.d.ts

```typescript
export declare const randomUUID: false | (() => `${string}-${string}-${string}-${string}-${string}`);

```

## ./lib/lambda/node_modules/@smithy/uuid/dist-types/ts3.4/randomUUID.d.ts

```typescript
import crypto from "crypto";
export declare const randomUUID: typeof crypto.randomUUID;

```

## ./lib/lambda/node_modules/@smithy/uuid/dist-types/ts3.4/randomUUID.native.d.ts

```typescript
export declare const randomUUID: false | (() => `${string}-${string}-${string}-${string}-${string}`);

```

## ./lib/lambda/node_modules/@smithy/uuid/dist-types/ts3.4/v4.d.ts

```typescript
/**
 * Generates a RFC4122 version 4 UUID
 *
 * This function generates a random UUID using one of two methods:
 * 1. The native randomUUID() function if available
 * 2. A fallback implementation using crypto.getRandomValues()
 *
 * The fallback implementation:
 * - Generates 16 random bytes using crypto.getRandomValues()
 * - Sets the version bits to indicate version 4
 * - Sets the variant bits to indicate RFC4122
 * - Formats the bytes as a UUID string with dashes
 *
 * @returns A version 4 UUID string in the format: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx
 * where x is any hexadecimal digit and y is one of 8, 9, a, or b.
 *
 * @internal
 */
export declare const v4: () => string;

```

## ./lib/lambda/node_modules/@smithy/uuid/dist-types/v4.d.ts

```typescript
/**
 * Generates a RFC4122 version 4 UUID
 *
 * This function generates a random UUID using one of two methods:
 * 1. The native randomUUID() function if available
 * 2. A fallback implementation using crypto.getRandomValues()
 *
 * The fallback implementation:
 * - Generates 16 random bytes using crypto.getRandomValues()
 * - Sets the version bits to indicate version 4
 * - Sets the variant bits to indicate RFC4122
 * - Formats the bytes as a UUID string with dashes
 *
 * @returns A version 4 UUID string in the format: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx
 * where x is any hexadecimal digit and y is one of 8, 9, a, or b.
 *
 * @internal
 */
export declare const v4: () => string;

```

## ./lib/lambda/node_modules/@smithy/uuid/package.json

```json
{
  "name": "@smithy/uuid",
  "version": "1.1.0",
  "description": "Polyfill for generating UUID v4",
  "dependencies": {
    "tslib": "^2.6.2"
  },
  "scripts": {
    "build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types && yarn build:types:downlevel'",
    "build:cjs": "node ../../scripts/inline uuid",
    "build:es": "yarn g:tsc -p tsconfig.es.json",
    "build:types": "yarn g:tsc -p tsconfig.types.json",
    "build:types:downlevel": "rimraf dist-types/ts3.4 && downlevel-dts dist-types dist-types/ts3.4",
    "stage-release": "rimraf ./.release && yarn pack && mkdir ./.release && tar zxvf ./package.tgz --directory ./.release && rm ./package.tgz",
    "clean": "rimraf ./dist-* && rimraf *.tsbuildinfo || exit 0",
    "lint": "eslint -c ../../.eslintrc.js \"src/**/*.ts\"",
    "format": "prettier --config ../../prettier.config.js --ignore-path ../../.prettierignore --write \"**/*.{ts,md,json}\"",
    "test": "yarn g:vitest run",
    "test:watch": "yarn g:vitest watch"
  },
  "author": {
    "name": "AWS SDK for JavaScript Team",
    "url": "https://aws.amazon.com/javascript/"
  },
  "license": "Apache-2.0",
  "sideEffects": false,
  "main": "./dist-cjs/index.js",
  "module": "./dist-es/index.js",
  "types": "./dist-types/index.d.ts",
  "engines": {
    "node": ">=18.0.0"
  },
  "typesVersions": {
    "<4.0": {
      "dist-types/*": [
        "dist-types/ts3.4/*"
      ]
    }
  },
  "files": [
    "dist-*/**"
  ],
  "homepage": "https://github.com/smithy-lang/smithy-typescript/tree/main/packages/uuid",
  "repository": {
    "type": "git",
    "url": "https://github.com/smithy-lang/smithy-typescript.git",
    "directory": "packages/uuid"
  },
  "browser": {
    "./dist-es/randomUUID": "./dist-es/randomUUID.browser"
  },
  "react-native": {},
  "devDependencies": {
    "@types/node": "^18.11.9",
    "concurrently": "7.0.0",
    "downlevel-dts": "0.10.1",
    "rimraf": "3.0.2",
    "typedoc": "0.23.23"
  },
  "typedoc": {
    "entryPoint": "src/index.ts"
  },
  "publishConfig": {
    "directory": ".release/package"
  }
}
```

## ./lib/lambda/node_modules/@types/aws-lambda/common/api-gateway.d.ts

```typescript
// Types shared between trigger/api-gateway-authorizer.d.ts and api-gateway-proxy.d.ts

// Poorly documented, but API Gateway will just fail internally if
// the context type does not match this.
// Note that although non-string types will be accepted, they will be
// coerced to strings on the other side.
export interface APIGatewayAuthorizerResultContext {
    [name: string]: string | number | boolean | null | undefined;
}

// Default authorizer type, prefer using a specific type with the "...WithAuthorizer..." variant types.
// Note that this doesn't have to be a context from a custom lambda outhorizer, AWS also has a cognito
// authorizer type and could add more, so the property won't always be a string.
export type APIGatewayEventDefaultAuthorizerContext =
    | undefined
    | null
    | {
        [name: string]: any;
    };

export type APIGatewayEventRequestContext = APIGatewayEventRequestContextWithAuthorizer<
    APIGatewayEventDefaultAuthorizerContext
>;

// The requestContext property of both request authorizer and proxy integration events.
export interface APIGatewayEventRequestContextWithAuthorizer<TAuthorizerContext> {
    accountId: string;
    apiId: string;
    // This one is a bit confusing: it is not actually present in authorizer calls
    // and proxy calls without an authorizer. We model this by allowing undefined in the type,
    // since it ends up the same and avoids breaking users that are testing the property.
    // This lets us allow parameterizing the authorizer for proxy events that know what authorizer
    // context values they have.
    authorizer: TAuthorizerContext;
    connectedAt?: number | undefined;
    connectionId?: string | undefined;
    domainName?: string | undefined;
    domainPrefix?: string | undefined;
    eventType?: string | undefined;
    extendedRequestId?: string | undefined;
    protocol: string;
    httpMethod: string;
    identity: APIGatewayEventIdentity;
    messageDirection?: string | undefined;
    messageId?: string | null | undefined;
    path: string;
    stage: string;
    requestId: string;
    requestTime?: string | undefined;
    requestTimeEpoch: number;
    resourceId: string;
    resourcePath: string;
    routeKey?: string | undefined;
}

export interface APIGatewayEventClientCertificate {
    clientCertPem: string;
    serialNumber: string;
    subjectDN: string;
    issuerDN: string;
    validity: {
        notAfter: string;
        notBefore: string;
    };
}

export interface APIGatewayEventIdentity {
    accessKey: string | null;
    accountId: string | null;
    apiKey: string | null;
    apiKeyId: string | null;
    caller: string | null;
    clientCert: APIGatewayEventClientCertificate | null;
    cognitoAuthenticationProvider: string | null;
    cognitoAuthenticationType: string | null;
    cognitoIdentityId: string | null;
    cognitoIdentityPoolId: string | null;
    principalOrgId: string | null;
    sourceIp: string;
    user: string | null;
    userAgent: string | null;
    userArn: string | null;
}

```

## ./lib/lambda/node_modules/@types/aws-lambda/common/cloudfront.d.ts

```typescript
/**
 * CloudFront events
 * http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/lambda-event-structure.html
 * Bear in mind that the "example" event structure in the page above includes
 * both an S3 and a Custom origin, which is not strictly allowed. Only one
 * of these per event may be present.
 */
export interface CloudFrontHeaders {
    [name: string]: Array<{
        key?: string | undefined;
        value: string;
    }>;
}

export type CloudFrontOrigin =
    | { s3: CloudFrontS3Origin; custom?: never | undefined }
    | { custom: CloudFrontCustomOrigin; s3?: never | undefined };

export interface CloudFrontCustomOrigin {
    customHeaders: CloudFrontHeaders;
    domainName: string;
    keepaliveTimeout: number;
    path: string;
    port: number;
    protocol: "http" | "https";
    readTimeout: number;
    sslProtocols: string[];
}

export type CloudFrontS3Origin =
    | CloudFrontS3OriginAuthMethodNone
    | CloudFrontS3OriginAuthMethodOriginAccessIdentity;

export interface CloudFrontS3OriginBase {
    authMethod: "origin-access-identity" | "none";
    customHeaders: CloudFrontHeaders;
    domainName: string;
    path: string;
}

export interface CloudFrontS3OriginAuthMethodNone extends CloudFrontS3OriginBase {
    authMethod: "none";
    region?: never;
}

export interface CloudFrontS3OriginAuthMethodOriginAccessIdentity extends CloudFrontS3OriginBase {
    authMethod: "origin-access-identity";
    region: string;
}

export interface CloudFrontResponse {
    status: string;
    statusDescription: string;
    headers: CloudFrontHeaders;
}

export interface CloudFrontRequest {
    body?:
        | {
            action: "read-only" | "replace";
            data: string;
            encoding: "base64" | "text";
            readonly inputTruncated: boolean;
        }
        | undefined;
    readonly clientIp: string;
    readonly method: string;
    uri: string;
    querystring: string;
    headers: CloudFrontHeaders;
    origin?: CloudFrontOrigin | undefined;
}

export interface CloudFrontEvent {
    config: {
        readonly distributionDomainName: string;
        readonly distributionId: string;
        readonly eventType: "origin-request" | "origin-response" | "viewer-request" | "viewer-response";
        readonly requestId: string;
    };
}

/**
 * Generated HTTP response in viewer request event or origin request event
 *
 * https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/lambda-generating-http-responses-in-requests.html#lambda-generating-http-responses-object
 */
export interface CloudFrontResultResponse {
    status: string;
    statusDescription?: string | undefined;
    headers?: CloudFrontHeaders | undefined;
    bodyEncoding?: "text" | "base64" | undefined;
    body?: string | undefined;
}

/** @see https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/functions-event-structure.html#functions-event-structure-query-header-cookie */
export interface CloudFrontFunctionsCookies {
    [key: string]: {
        value: string;
        attributes?: string;
        multiValue?: Array<{ value: string; attributes?: string }>;
    };
}

/** @see https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/functions-event-structure.html#functions-event-structure-query-header-cookie */
export interface CloudFrontFunctionsQuerystring {
    [key: string]: { value: string; multiValue?: Array<{ value: string }> };
}

/** @see https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/functions-event-structure.html#functions-event-structure-query-header-cookie */
export interface CloudFrontFunctionsHeaders {
    [key: string]: { value: string; multiValue?: Array<{ value: string }> };
}

/**
 * @see https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/functions-event-structure.html
 *
 * @usage
 * ```ts
 * export const handler = async (event: CloudFrontFunctionsEvent) => {
 *   var response = event.response;
 *   var headers = response.headers;
 *   // Set the cache-control header
 *   headers["cache-control"] = { value: "public,max-age=31536000,immutable" };
 *   // Return response to viewers
 *   return response
 * };
 * ```
 */
export interface CloudFrontFunctionsEvent {
    /**
     * ## Version field
     * The version field contains a string that specifies the version of the
     * CloudFront Functions event object. The current version is 1.0.
     */
    version: string;
    /**
     * ## Context object
     * The `context` object contains contextual information about the event. It includes the following fields:
     * - `distributionDomainName`
     * - `distributionId`
     * - `eventType`
     * - `requestId`
     */
    context: {
        /** The CloudFront domain name (for example, d111111abcdef8.cloudfront.net) of the distribution thats associated with the event. */
        distributionDomainName: string;
        /** The ID of the distribution (for example, EDFDVBD6EXAMPLE) thats associated with the event. */
        distributionId: string;
        /** The event type, either `viewer-request` or `viewer-response`. */
        eventType: "viewer-request" | "viewer-response";
        /** A string that uniquely identifies a CloudFront request (and its associated response). */
        requestId: string;
    };
    /**
     * ## Viewer object
     * The `viewer` object contains an `ip` field whose value is the IP address of the viewer (client) that sent the request.
     * If the viewer request came through an HTTP proxy or a load balancer, the value is the IP address of the proxy or load balancer.
     */
    viewer: {
        ip: string;
    };
    /**
     * ## Request object
     * The `request` object contains a representation of a viewer-to-CloudFront HTTP request.
     * In the `event` object thats passed to your function, the `request` object represents the
     * actual request that CloudFront received from the viewer.
     *
     * If your function code returns a `request` object to CloudFront, it must use this same structure.
     *
     * The `request` object contains the following fields:
     * - `method`
     * - `uri`
     * - `querystring`
     * - `headers`
     * - `cookies`
     */
    request: {
        /** The HTTP method of the request. If your function code returns a `request`, it cannot modify this field. This is the only read-only field in the `request` object. */
        method: string;
        /**
         * The relative path of the requested object. If your function modifies the `uri value, note the following:
         * - The new `uri` value must begin with a forward slash (`/`)`.
         * - When a function changes the `uri` value, it changes the object that the viewer is requesting.
         * - When a function changes the `uri` value, it doesnt change the cache behavior for the request or the origin that an origin request is sent to.
         */
        uri: string;
        /**
         * An object that represents the query string in the request. If the request doesnt include a query string,
         * the `request` object still includes an empty `querystring` object.
         *
         * The `querystring` object contains one field for each query string parameter in the request.
         * Query string parameter names are converted to lowercase.
         */
        querystring: CloudFrontFunctionsQuerystring;
        /**
         * An object that represents the HTTP headers in the request. If the request contains any `Cookie` headers,
         * those headers are not part of the `headers` object. Cookies are represented separately in the `cookies` object.
         *
         * The `headers` object contains one field for each header in the request. Header names are converted to lowercase.
         */
        headers: CloudFrontFunctionsHeaders;
        /**
         * An object that represents the cookies in the request (`Cookie` headers).
         *
         * The `cookies` object contains one field for each cookie in the request. Cookie names are converted to lowercase.
         */
        cookies: CloudFrontFunctionsCookies;
    };
    /**
     * ## Response object
     *
     * The `response` object contains a representation of a CloudFront-to-viewer HTTP response.
     * In the `event` object thats passed to your function, the `response` object represents CloudFronts actual response to a viewer request.
     *
     * If your function code returns a `response` object, it must use this same structure.
     *
     * The `response` object contains the following fields:
     */
    response: {
        /**
         * The HTTP status code of the response. This value is an integer, not a string.
         *
         * If the function is associated with a _viewer response_ event type, your function code cannot change
         * the `statusCode` that it received. If the function is associated with a _viewer request_ event type
         * and [generates an HTTP response](https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/writing-function-code.html#function-code-generate-response),
         * your function code can set the `statusCode`.
         */
        statusCode: number;
        /** The HTTP status description of the response. If your function code generates a response, this field is optional. */
        statusDescription?: string;
        /**
         * An object that represents the HTTP headers in the response. If the response contains any `Set-Cookie` headers,
         * those `headers` are not part of the headers object. Cookies are represented separately in the `cookies` object.
         *
         * The `headers` object contains one field for each header in the response. Header names are converted to lowercase.
         */
        headers: CloudFrontFunctionsHeaders;
        /**
         * An object that represents the cookies in the response (`Set-Cookie` headers).
         * The `cookies` object contains one field for each cookie in the response. Cookie names are converted to lowercase.
         */
        cookies: CloudFrontFunctionsCookies;
    };
}

```

## ./lib/lambda/node_modules/@types/aws-lambda/handler.d.ts

```typescript
import type { Writable } from "node:stream";
/**
 * The interface that AWS Lambda will invoke your handler with.
 * There are more specialized types for many cases where AWS services
 * invoke your lambda, but you can directly use this type for when you are invoking
 * your lambda directly.
 *
 * See the {@link http://docs.aws.amazon.com/lambda/latest/dg/nodejs-prog-model-handler.html AWS documentation}
 * for more information about the runtime behavior, and the
 * {@link https://aws.amazon.com/blogs/compute/node-js-8-10-runtime-now-available-in-aws-lambda/ AWS Blog post}
 * introducing the async handler behavior in the 8.10 runtime.
 *
 * @example <caption>Defining a custom handler type</caption>
 * import { Handler } from 'aws-lambda'
 *
 * interface NameEvent {
 *     fullName: string
 * }
 * interface NameResult {
 *     firstName: string
 *     middleNames: string
 *     lastName: string
 * }
 * type PersonHandler = Handler<NameEvent, NameResult>
 *
 * export const handler: PersonHandler = async (event) => {
 *   const names = event.fullName.split(' ')
 *   const firstName = names.shift()
 *   const lastName = names.pop()
 *   return { firstName, middleNames: names, lastName }
 * }
 *
 * @example <caption>Logs the contents of the event object and returns the location of the logs</caption>
 * import { Handler } from 'aws-lambda'
 *
 * export const handler: Handler = async (event, context) => {
 *   console.log("EVENT: \n" + JSON.stringify(event, null, 2))
 *   return context.logStreamName
 * }
 *
 * @example <caption>AWS SDK with Async Function and Promises</caption>
 * import { Handler } from 'aws-lambda'
 * import AWS from 'aws-sdk'
 *
 * const s3 = new AWS.S3()
 *
 * export const handler: Handler = async (event) => {
 *   const response = await s3.listBuckets().promise()
 *   return response?.Buckets.map((bucket) => bucket.Name)
 * }
 *
 * @example <caption>HTTP Request with Callback</caption>
 * import { Handler } from 'aws-lambda'
 * import https from 'https'
 *
 * let url = "https://docs.aws.amazon.com/lambda/latest/dg/welcome.html"
 *
 * export const handler: Handler<void, number> = (event, context, callback) => {
 *  https.get(url, (res) => {
 *    callback(null, res.statusCode)
 *  }).on('error', (e) => {
 *    callback(Error(e))
 *  })
 * }
 *
 * @param event
 *      Parsed JSON data in the lambda request payload. For an AWS service triggered
 *      lambda this should be in the format of a type ending in Event, for example the
 *      S3Handler receives an event of type S3Event.
 * @param context
 *      Runtime contextual information of the current invocation, for example the caller
 *      identity, available memory and time remaining, legacy completion callbacks, and
 *      a mutable property controlling when the lambda execution completes.
 * @param callback
 *      NodeJS-style completion callback that the AWS Lambda runtime will provide that can
 *      be used to provide the lambda result payload value, or any execution error. Can
 *      instead return a promise that resolves with the result payload value or rejects
 *      with the execution error.
 * @return
 *      A promise that resolves with the lambda result payload value, or rejects with the
 *      execution error. Note that if you implement your handler as an async function,
 *      you will automatically return a promise that will resolve with a returned value,
 *      or reject with a thrown value.
 */
export type Handler<TEvent = any, TResult = any> = (
    event: TEvent,
    context: Context,
    callback: Callback<TResult>,
    // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
) => void | Promise<TResult>;

/**
 * {@link Handler} context parameter.
 * See {@link https://docs.aws.amazon.com/lambda/latest/dg/nodejs-prog-model-context.html AWS documentation}.
 */
export interface Context {
    callbackWaitsForEmptyEventLoop: boolean;
    functionName: string;
    functionVersion: string;
    invokedFunctionArn: string;
    memoryLimitInMB: string;
    awsRequestId: string;
    logGroupName: string;
    logStreamName: string;
    identity?: CognitoIdentity | undefined;
    clientContext?: ClientContext | undefined;
    tenantId?: string | undefined;

    getRemainingTimeInMillis(): number;

    // Functions for compatibility with earlier Node.js Runtime v0.10.42
    // No longer documented, so they are deprecated, but they still work
    // as of the 12.x runtime, so they are not removed from the types.

    /** @deprecated Use handler callback or promise result */
    done(error?: Error, result?: any): void;
    /** @deprecated Use handler callback with first argument or reject a promise result */
    fail(error: Error | string): void;
    /** @deprecated Use handler callback with second argument or resolve a promise result */
    succeed(messageOrObject: any): void;
    // Unclear what behavior this is supposed to have, I couldn't find any still extant reference,
    // and it behaves like the above, ignoring the object parameter.
    /** @deprecated Use handler callback or promise result */
    succeed(message: string, object: any): void;
}

export interface CognitoIdentity {
    cognitoIdentityId: string;
    cognitoIdentityPoolId: string;
}

export interface ClientContext {
    client: ClientContextClient;
    Custom?: any;
    env: ClientContextEnv;
}

export interface ClientContextClient {
    installationId: string;
    appTitle: string;
    appVersionName: string;
    appVersionCode: string;
    appPackageName: string;
}

export interface ClientContextEnv {
    platformVersion: string;
    platform: string;
    make: string;
    model: string;
    locale: string;
}

/**
 * NodeJS-style callback parameter for the {@link Handler} type.
 * Can be used instead of returning a promise, see the
 * {@link https://docs.aws.amazon.com/lambda/latest/dg/nodejs-prog-model-handler.html AWS documentation}
 * for the handler programming model.
 *
 * @param error
 *   Parameter to use to provide the error payload for a failed lambda execution.
 *   See {@link https://docs.aws.amazon.com/lambda/latest/dg/nodejs-prog-mode-exceptions.html AWS documentation}
 *   for error handling.
 *   If an Error instance is passed, the error payload uses the `name` property as the `errorType`,
 *   the `message` property as the `errorMessage`, and parses the `stack` property string into
 *   the `trace` array.
 *   For other values, the `errorType` is `typeof value`, the `errorMessage` is `String(value)`, and
 *   `trace` is an empty array.
 *
 * @param result
 *   Parameter to use to provide the result payload for a successful lambda execution.
 *   Pass `null` or `undefined` for the `error` parameter to use this parameter.
 */
export type Callback<TResult = any> = (error?: Error | string | null, result?: TResult) => void;

/**
 * Interface for using response streaming from AWS Lambda.
 * To indicate to the runtime that Lambda should stream your functions responses, you must wrap your function handler with the `awslambda.streamifyResponse()` decorator.
 *
 * The `streamifyResponse` decorator accepts the following additional parameter, `responseStream`, besides the default node handler parameters, `event`, and `context`.
 * The new `responseStream` object provides a stream object that your function can write data to. Data written to this stream is sent immediately to the client. You can optionally set the Content-Type header of the response to pass additional metadata to your client about the contents of the stream.
 *
 * {@link https://aws.amazon.com/blogs/compute/introducing-aws-lambda-response-streaming/ AWS blog post}
 * {@link https://docs.aws.amazon.com/lambda/latest/dg/config-rs-write-functions.html AWS documentation}
 *
 * @example <caption>Writing to the response stream</caption>
 * import 'aws-lambda';
 *
 * export const handler = awslambda.streamifyResponse(
 *   async (event, responseStream, context) => {
 *       responseStream.setContentType("text/plain");
 *       responseStream.write("Hello, world!");
 *       responseStream.end();
 *   }
 * );
 *
 * @example <caption>Using pipeline</caption>
 * import 'aws-lambda';
 * import { Readable } from 'stream';
 * import { pipeline } from 'stream/promises';
 * import zlib from 'zlib';
 *
 * export const handler = awslambda.streamifyResponse(
 *   async (event, responseStream, context) => {
 *     // As an example, convert event to a readable stream.
 *     const requestStream = Readable.from(Buffer.from(JSON.stringify(event)));
 *
 *     await pipeline(requestStream, zlib.createGzip(), responseStream);
 *   }
 * );
 */
export type StreamifyHandler<TEvent = any, TResult = any> = (
    event: TEvent,
    responseStream: awslambda.HttpResponseStream,
    context: Context,
) => TResult | Promise<TResult>;

declare global {
    namespace awslambda {
        class HttpResponseStream extends Writable {
            static from(
                writable: Writable,
                metadata: Record<string, unknown>,
            ): HttpResponseStream;
            setContentType: (contentType: string) => void;
        }

        /**
         * Decorator for using response streaming from AWS Lambda.
         * To indicate to the runtime that Lambda should stream your functions responses, you must wrap your function handler with the `awslambda.streamifyResponse()` decorator.
         *
         * The `streamifyResponse` decorator accepts the following additional parameter, `responseStream`, besides the default node handler parameters, `event`, and `context`.
         * The new `responseStream` object provides a stream object that your function can write data to. Data written to this stream is sent immediately to the client. You can optionally set the Content-Type header of the response to pass additional metadata to your client about the contents of the stream.
         *
         * {@link https://aws.amazon.com/blogs/compute/introducing-aws-lambda-response-streaming/ AWS blog post}
         * {@link https://docs.aws.amazon.com/lambda/latest/dg/config-rs-write-functions.html AWS documentation}
         *
         * @example <caption>Writing to the response stream</caption>
         * import 'aws-lambda';
         *
         * export const handler = awslambda.streamifyResponse(
         *   async (event, responseStream, context) => {
         *       responseStream.setContentType("text/plain");
         *       responseStream.write("Hello, world!");
         *       responseStream.end();
         *   }
         * );
         *
         * @example <caption>Using pipeline</caption>
         * import 'aws-lambda';
         * import { Readable } from 'stream';
         * import { pipeline } from 'stream/promises';
         * import zlib from 'zlib';
         *
         * export const handler = awslambda.streamifyResponse(
         *   async (event, responseStream, context) => {
         *     // As an example, convert event to a readable stream.
         *     const requestStream = Readable.from(Buffer.from(JSON.stringify(event)));
         *
         *     await pipeline(requestStream, zlib.createGzip(), responseStream);
         *   }
         * );
         */
        function streamifyResponse<TEvent = any, TResult = void>(
            handler: StreamifyHandler<TEvent, TResult>,
        ): StreamifyHandler<TEvent, TResult>;
    }
}

```

## ./lib/lambda/node_modules/@types/aws-lambda/index.d.ts

```typescript
export * from "./common/api-gateway";
export * from "./common/cloudfront";
export * from "./handler";
export * from "./trigger/alb";
// TODO: export * from "./trigger/alexa";
export * from "./trigger/api-gateway-authorizer";
export * from "./trigger/api-gateway-proxy";
export * from "./trigger/appsync-resolver";
export * from "./trigger/autoscaling";
// CloudTrail section just describes using S3 to trigger on cloudtrail changes.
export * from "./trigger/cdk-custom-resource";
export * from "./trigger/cloudformation-custom-resource";
export * from "./trigger/cloudfront-request";
export * from "./trigger/cloudfront-response";
export * from "./trigger/cloudwatch-alarm";
export * from "./trigger/cloudwatch-events";
export * from "./trigger/cloudwatch-logs";
export * from "./trigger/codebuild-cloudwatch-state";
export * from "./trigger/codecommit";
export * from "./trigger/codepipeline";
export * from "./trigger/codepipeline-cloudwatch";
export * from "./trigger/codepipeline-cloudwatch-action";
export * from "./trigger/codepipeline-cloudwatch-pipeline";
export * from "./trigger/codepipeline-cloudwatch-stage";
// TODO: export * from "./trigger/cognito-sync";
export * from "./trigger/cognito-user-pool-trigger/";
export * from "./trigger/connect-contact-flow";
// TODO: export * from "./trigger/config";
export * from "./trigger/dynamodb-stream";
export * from "./trigger/eventbridge";
// ElastiCache section just describes using lambdas in an ElastiCache context (VPC issues, etc.)
// EC2 events are delivered using cloudwatch events...
export * from "./trigger/guard-duty-event-notification";
export * from "./trigger/iot";
export * from "./trigger/iot-authorizer";
export * from "./trigger/kinesis-firehose-transformation";
export * from "./trigger/kinesis-stream";
export * from "./trigger/lambda-function-url";
export * from "./trigger/lex";
export * from "./trigger/lex-v2";
// RDS events are delivered using SNS events...
export * from "./trigger/amplify-resolver";
export * from "./trigger/msk";
export * from "./trigger/s3";
export * from "./trigger/s3-batch";
export * from "./trigger/s3-event-notification";
export * from "./trigger/secretsmanager";
export * from "./trigger/self-managed-kafka";
export * from "./trigger/ses";
export * from "./trigger/sns";
export * from "./trigger/sqs";
export * from "./trigger/transfer-family-authorizer";

export as namespace AWSLambda;

```

## ./lib/lambda/node_modules/@types/aws-lambda/package.json

```json
{
    "name": "@types/aws-lambda",
    "version": "8.10.156",
    "description": "TypeScript definitions for aws-lambda",
    "homepage": "https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/aws-lambda",
    "license": "MIT",
    "contributors": [
        {
            "name": "James Darbyshire",
            "githubUsername": "darbio",
            "url": "https://github.com/darbio"
        },
        {
            "name": "Michael Skarum",
            "githubUsername": "skarum",
            "url": "https://github.com/skarum"
        },
        {
            "name": "Stef Heyenrath",
            "githubUsername": "StefH",
            "url": "https://github.com/StefH"
        },
        {
            "name": "Rich Buggy",
            "githubUsername": "buggy",
            "url": "https://github.com/buggy"
        },
        {
            "name": "wwwy3y3",
            "githubUsername": "wwwy3y3",
            "url": "https://github.com/wwwy3y3"
        },
        {
            "name": "Ishaan Malhi",
            "githubUsername": "OrthoDex",
            "url": "https://github.com/OrthoDex"
        },
        {
            "name": "Michael Marner",
            "githubUsername": "MichaelMarner",
            "url": "https://github.com/MichaelMarner"
        },
        {
            "name": "Daniel Cottone",
            "githubUsername": "daniel-cottone",
            "url": "https://github.com/daniel-cottone"
        },
        {
            "name": "Kostya Misura",
            "githubUsername": "kostya-misura",
            "url": "https://github.com/kostya-misura"
        },
        {
            "name": "Markus Tacker",
            "githubUsername": "coderbyheart",
            "url": "https://github.com/coderbyheart"
        },
        {
            "name": "Palmi Valgeirsson",
            "githubUsername": "palmithor",
            "url": "https://github.com/palmithor"
        },
        {
            "name": "Danilo Raisi",
            "githubUsername": "daniloraisi",
            "url": "https://github.com/daniloraisi"
        },
        {
            "name": "Simon Buchan",
            "githubUsername": "simonbuchan",
            "url": "https://github.com/simonbuchan"
        },
        {
            "name": "David Hayden",
            "githubUsername": "Haydabase",
            "url": "https://github.com/Haydabase"
        },
        {
            "name": "Chris Redekop",
            "githubUsername": "repl-chris",
            "url": "https://github.com/repl-chris"
        },
        {
            "name": "Aneil Mallavarapu",
            "githubUsername": "aneilbaboo",
            "url": "https://github.com/aneilbaboo"
        },
        {
            "name": "Jeremy Nagel",
            "githubUsername": "jeznag",
            "url": "https://github.com/jeznag"
        },
        {
            "name": "Louis Larry",
            "githubUsername": "louislarry",
            "url": "https://github.com/louislarry"
        },
        {
            "name": "Daniel Papukchiev",
            "githubUsername": "dpapukchiev",
            "url": "https://github.com/dpapukchiev"
        },
        {
            "name": "Oliver Hookins",
            "githubUsername": "ohookins",
            "url": "https://github.com/ohookins"
        },
        {
            "name": "Trevor Leach",
            "githubUsername": "trevor-leach",
            "url": "https://github.com/trevor-leach"
        },
        {
            "name": "James Gregory",
            "githubUsername": "jagregory",
            "url": "https://github.com/jagregory"
        },
        {
            "name": "Erik Daln",
            "githubUsername": "dalen",
            "url": "https://github.com/dalen"
        },
        {
            "name": "Lok Gaonac'h",
            "githubUsername": "loikg",
            "url": "https://github.com/loikg"
        },
        {
            "name": "Roberto Zen",
            "githubUsername": "skyzenr",
            "url": "https://github.com/skyzenr"
        },
        {
            "name": "Grzegorz Redlicki",
            "githubUsername": "redlickigrzegorz",
            "url": "https://github.com/redlickigrzegorz"
        },
        {
            "name": "Juan Carbonel",
            "githubUsername": "juancarbonel",
            "url": "https://github.com/juancarbonel"
        },
        {
            "name": "Peter McIntyre",
            "githubUsername": "pwmcintyre",
            "url": "https://github.com/pwmcintyre"
        },
        {
            "name": "Alex Bolenok",
            "githubUsername": "alex-bolenok-centralreach",
            "url": "https://github.com/alex-bolenok-centralreach"
        },
        {
            "name": "Marian Zange",
            "githubUsername": "marianzange",
            "url": "https://github.com/marianzange"
        },
        {
            "name": "Alessandro Palumbo",
            "githubUsername": "apalumbo",
            "url": "https://github.com/apalumbo"
        },
        {
            "name": "Sachin Shekhar",
            "githubUsername": "SachinShekhar",
            "url": "https://github.com/SachinShekhar"
        },
        {
            "name": "Ivan Martos",
            "githubUsername": "ivanmartos",
            "url": "https://github.com/ivanmartos"
        },
        {
            "name": "Zach Anthony",
            "githubUsername": "zach-anthony",
            "url": "https://github.com/zach-anthony"
        },
        {
            "name": "Peter Savnik",
            "githubUsername": "savnik",
            "url": "https://github.com/savnik"
        },
        {
            "name": "Benoit Boure",
            "githubUsername": "bboure",
            "url": "https://github.com/bboure"
        },
        {
            "name": "James Lakin",
            "githubUsername": "jamesorlakin",
            "url": "https://github.com/jamesorlakin"
        },
        {
            "name": "Ross Gerbasi",
            "githubUsername": "aphex",
            "url": "https://github.com/aphex"
        },
        {
            "name": "Joey Kilpatrick",
            "githubUsername": "joeykilpatrick",
            "url": "https://github.com/joeykilpatrick"
        },
        {
            "name": "Luciano Manerich Junior",
            "githubUsername": "lmanerich",
            "url": "https://github.com/lmanerich"
        },
        {
            "name": "Luciano M. Taranto",
            "githubUsername": "LucianoTaranto",
            "url": "https://github.com/LucianoTaranto"
        }
    ],
    "main": "",
    "types": "index.d.ts",
    "repository": {
        "type": "git",
        "url": "https://github.com/DefinitelyTyped/DefinitelyTyped.git",
        "directory": "types/aws-lambda"
    },
    "scripts": {},
    "dependencies": {},
    "peerDependencies": {},
    "typesPublisherContentHash": "0556b7d1e9e8a8a40adbcec3318362112e1e08991f7325b45d51dc76c4913bb8",
    "typeScriptVersion": "5.2"
}
```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/alb.d.ts

```typescript
import { Callback, Handler } from "../handler";

export type ALBHandler = Handler<ALBEvent, ALBResult>;
export type ALBCallback = Callback<ALBResult>;

// https://docs.aws.amazon.com/elasticloadbalancing/latest/application/lambda-functions.html
export interface ALBEventRequestContext {
    elb: {
        targetGroupArn: string;
    };
}

export interface ALBEventQueryStringParameters {
    [name: string]: string | undefined;
}

export interface ALBEventHeaders {
    [name: string]: string | undefined;
}

export interface ALBEventMultiValueHeaders {
    [name: string]: string[] | undefined;
}

export interface ALBEventMultiValueQueryStringParameters {
    [name: string]: string[] | undefined;
}

export interface ALBEvent {
    requestContext: ALBEventRequestContext;
    httpMethod: string;
    path: string;
    queryStringParameters?: ALBEventQueryStringParameters | undefined; // URL encoded
    headers?: ALBEventHeaders | undefined;
    multiValueQueryStringParameters?: ALBEventMultiValueQueryStringParameters | undefined; // URL encoded
    multiValueHeaders?: ALBEventMultiValueHeaders | undefined;
    body: string | null;
    isBase64Encoded: boolean;
}

export interface ALBResult {
    statusCode: number;
    statusDescription?: string | undefined;
    headers?: { [header: string]: boolean | number | string } | undefined;
    multiValueHeaders?: { [header: string]: Array<boolean | number | string> } | undefined;
    body?: string | undefined;
    isBase64Encoded?: boolean | undefined;
}

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/amplify-resolver.d.ts

```typescript
import { Handler } from "../handler";
import { AppSyncIdentity, AppSyncResolverEventHeaders } from "./appsync-resolver";

/**
 * An AWS Amplify GraphQL resolver event. It differs slightly from a native ('direct') AppSync resolver event.
 *
 * @see https://docs.amplify.aws/cli/graphql/custom-business-logic/#structure-of-the-function-event
 */
export interface AmplifyGraphQlResolverEvent<TArguments = Record<string, any>, TSource = Record<string, any>> {
    /** The name of the parent object type (data model) of the field being resolved. */
    typeName: string;
    /** The field within the given type to resolve. */
    fieldName: string;
    /** A map of GraphQL arguments passed to the field being resolved. */
    arguments: TArguments;
    /** The identity used to authenticate the request to AppSync. */
    identity?: AppSyncIdentity;
    /** The parent object's value if resolving a nested field. */
    source: TSource;
    /** The request headers  */
    request: {
        headers: AppSyncResolverEventHeaders;
        domainName: string | null;
    };
    /** The object returned by a possible previous pipeline resolver function. */
    prev: { result: { [key: string]: any } } | null;
}

/**
 * A handler for Amplify GraphQL Lambda resolvers. The returned result will be resolved as the value (no need to convert to a JSON string).
 *
 * @see https://docs.amplify.aws/cli/graphql/custom-business-logic/#structure-of-the-function-event
 */
export type AmplifyGraphQlResolverHandler<
    TArguments = Record<string, any>,
    TSource = Record<string, any>,
    TResult = any,
> = Handler<AmplifyGraphQlResolverEvent<TArguments, TSource>, TResult>;

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/api-gateway-authorizer.d.ts

```typescript
import {
    APIGatewayAuthorizerResultContext,
    APIGatewayEventDefaultAuthorizerContext,
    APIGatewayEventRequestContextWithAuthorizer,
} from "../common/api-gateway";
import { Callback, Handler } from "../handler";
import { APIGatewayEventRequestContextV2 } from "./api-gateway-proxy";

export type APIGatewayAuthorizerHandler = Handler<APIGatewayAuthorizerEvent, APIGatewayAuthorizerResult>;
export type APIGatewayAuthorizerWithContextHandler<TAuthorizerContext extends APIGatewayAuthorizerResultContext> =
    Handler<APIGatewayAuthorizerEvent, APIGatewayAuthorizerWithContextResult<TAuthorizerContext>>;

export type APIGatewayAuthorizerCallback = Callback<APIGatewayAuthorizerResult>;
export type APIGatewayAuthorizerWithContextCallback<TAuthorizerContext extends APIGatewayAuthorizerResultContext> =
    Callback<APIGatewayAuthorizerWithContextResult<TAuthorizerContext>>;

export type APIGatewayTokenAuthorizerHandler = Handler<APIGatewayTokenAuthorizerEvent, APIGatewayAuthorizerResult>;
export type APIGatewayTokenAuthorizerWithContextHandler<TAuthorizerContext extends APIGatewayAuthorizerResultContext> =
    Handler<APIGatewayTokenAuthorizerEvent, APIGatewayAuthorizerWithContextResult<TAuthorizerContext>>;

export type APIGatewayRequestAuthorizerHandler = Handler<APIGatewayRequestAuthorizerEvent, APIGatewayAuthorizerResult>;
export type APIGatewayRequestAuthorizerWithContextHandler<
    TAuthorizerContext extends APIGatewayAuthorizerResultContext,
> = Handler<APIGatewayRequestAuthorizerEvent, APIGatewayAuthorizerWithContextResult<TAuthorizerContext>>;

export type APIGatewayAuthorizerEvent = APIGatewayTokenAuthorizerEvent | APIGatewayRequestAuthorizerEvent;

export interface APIGatewayTokenAuthorizerEvent {
    type: "TOKEN";
    methodArn: string;
    authorizationToken: string;
}

export interface APIGatewayRequestAuthorizerEventV2 {
    version: string;
    type: "REQUEST";
    routeArn: string;
    identitySource: string[];
    routeKey: string;
    rawPath: string;
    rawQueryString: string;
    cookies: string[];
    headers?: APIGatewayRequestAuthorizerEventHeaders;
    queryStringParameters?: APIGatewayRequestAuthorizerEventQueryStringParameters;
    requestContext: APIGatewayEventRequestContextV2;
    pathParameters?: APIGatewayRequestAuthorizerEventPathParameters;
    stageVariables?: APIGatewayRequestAuthorizerEventStageVariables;
}

export interface APIGatewayRequestAuthorizerEventHeaders {
    [name: string]: string | undefined;
}

export interface APIGatewayRequestAuthorizerEventMultiValueHeaders {
    [name: string]: string[] | undefined;
}

export interface APIGatewayRequestAuthorizerEventPathParameters {
    [name: string]: string | undefined;
}

export interface APIGatewayRequestAuthorizerEventQueryStringParameters {
    [name: string]: string | undefined;
}

export interface APIGatewayRequestAuthorizerEventMultiValueQueryStringParameters {
    [name: string]: string[] | undefined;
}

export interface APIGatewayRequestAuthorizerEventStageVariables {
    [name: string]: string | undefined;
}

// Note, when invoked by the tester in the AWS web console, the map values can be null,
// but they will be empty objects in the real object.
// Worse, it will include "body" and "isBase64Encoded" properties, unlike the real call!
// See https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-lambda-authorizer-input.html for the
// formal definition.
export interface APIGatewayRequestAuthorizerEvent {
    type: "REQUEST";
    methodArn: string;
    resource: string;
    path: string;
    httpMethod: string;
    headers: APIGatewayRequestAuthorizerEventHeaders | null;
    multiValueHeaders: APIGatewayRequestAuthorizerEventMultiValueHeaders | null;
    pathParameters: APIGatewayRequestAuthorizerEventPathParameters | null;
    queryStringParameters: APIGatewayRequestAuthorizerEventQueryStringParameters | null;
    multiValueQueryStringParameters: APIGatewayRequestAuthorizerEventMultiValueQueryStringParameters | null;
    stageVariables: APIGatewayRequestAuthorizerEventStageVariables | null;
    requestContext: APIGatewayEventRequestContextWithAuthorizer<undefined>;
}

export interface APIGatewayAuthorizerResult {
    principalId: string;
    policyDocument: PolicyDocument;
    context?: APIGatewayAuthorizerResultContext | null | undefined;
    usageIdentifierKey?: string | null | undefined;
}

// Separate type so the context property is required, without pulling complex type magic.
export interface APIGatewayAuthorizerWithContextResult<TAuthorizerContext extends APIGatewayAuthorizerResultContext> {
    principalId: string;
    policyDocument: PolicyDocument;
    context: TAuthorizerContext;
    usageIdentifierKey?: string | null | undefined;
}

/**
 * IAM Authorizer Types
 */
export interface APIGatewayIAMAuthorizerResult {
    principalId: string;
    policyDocument: PolicyDocument;
    context?: APIGatewayAuthorizerResultContext | null | undefined;
    usageIdentifierKey?: string | null | undefined;
}

export interface APIGatewayIAMAuthorizerWithContextResult<
    TAuthorizerContext extends APIGatewayAuthorizerResultContext,
> {
    principalId: string;
    policyDocument: PolicyDocument;
    context: TAuthorizerContext;
    usageIdentifierKey?: string | null | undefined;
}

export type APIGatewayRequestIAMAuthorizerHandlerV2 = Handler<
    APIGatewayRequestAuthorizerEventV2,
    APIGatewayIAMAuthorizerResult
>;

export type APIGatewayRequestIAMAuthorizerV2WithContextHandler<
    TAuthorizerContext extends APIGatewayAuthorizerResultContext,
> = Handler<APIGatewayRequestAuthorizerEventV2, APIGatewayIAMAuthorizerWithContextResult<TAuthorizerContext>>;

/**
 * Simple Lambda Authorizer Types V2 spec with simple response
 * @see - https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html
 */
export interface APIGatewaySimpleAuthorizerResult {
    isAuthorized: boolean;
}

export interface APIGatewaySimpleAuthorizerWithContextResult<TAuthorizerContext>
    extends APIGatewaySimpleAuthorizerResult
{
    context: TAuthorizerContext;
}

export type APIGatewayRequestSimpleAuthorizerHandlerV2 = Handler<
    APIGatewayRequestAuthorizerEventV2,
    APIGatewaySimpleAuthorizerResult
>;

export type APIGatewayRequestSimpleAuthorizerHandlerV2WithContext<TAuthorizerContext> = Handler<
    APIGatewayRequestAuthorizerEventV2,
    APIGatewaySimpleAuthorizerWithContextResult<TAuthorizerContext>
>;

// Legacy event / names

/** @deprecated Use APIGatewayAuthorizerHandler or a subtype */
export type CustomAuthorizerHandler = Handler<CustomAuthorizerEvent, APIGatewayAuthorizerResult>;

// This one is actually fine.
export type CustomAuthorizerCallback = APIGatewayAuthorizerCallback;

/** @deprecated Use APIGatewayAuthorizerEvent or a subtype */
export interface CustomAuthorizerEvent {
    type: string;
    methodArn: string;
    authorizationToken?: string | undefined;
    resource?: string | undefined;
    path?: string | undefined;
    httpMethod?: string | undefined;
    headers?: { [name: string]: string } | undefined;
    multiValueHeaders?: { [name: string]: string[] } | undefined;
    pathParameters?: { [name: string]: string } | null | undefined;
    queryStringParameters?: { [name: string]: string } | null | undefined;
    multiValueQueryStringParameters?: { [name: string]: string[] } | null | undefined;
    stageVariables?: { [name: string]: string } | undefined;
    requestContext?: APIGatewayEventRequestContextWithAuthorizer<APIGatewayEventDefaultAuthorizerContext> | undefined;
    domainName?: string | undefined;
    apiId?: string | undefined;
}

export type CustomAuthorizerResult = APIGatewayAuthorizerResult;
export type AuthResponse = APIGatewayAuthorizerResult;
export type AuthResponseContext = APIGatewayAuthorizerResultContext;

/**
 * API Gateway CustomAuthorizer AuthResponse.PolicyDocument.
 * https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-lambda-authorizer-output.html
 * https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements.html#Condition
 */
export interface PolicyDocument {
    Version: string;
    Id?: string | undefined;
    Statement: Statement[];
}

/**
 * API Gateway CustomAuthorizer AuthResponse.PolicyDocument.Condition.
 * https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-control-access-policy-language-overview.html
 * https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_condition.html
 */
export interface ConditionBlock {
    [condition: string]: Condition | Condition[];
}

export interface Condition {
    [key: string]: string | string[];
}

/**
 * API Gateway CustomAuthorizer AuthResponse.PolicyDocument.Statement.
 * https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-control-access-policy-language-overview.html
 * https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements.html
 */
export type Statement = BaseStatement & StatementAction & (StatementResource | StatementPrincipal);

export type StatementEffect = "Allow" | "Deny";

export interface BaseStatement {
    Effect: StatementEffect;
    Sid?: string | undefined;
    Condition?: ConditionBlock | undefined;
}

export type PrincipalValue = { [key: string]: string | string[] } | string | string[];
export interface MaybeStatementPrincipal {
    Principal?: PrincipalValue | undefined;
    NotPrincipal?: PrincipalValue | undefined;
}
export interface MaybeStatementResource {
    Resource?: string | string[] | undefined;
    NotResource?: string | string[] | undefined;
}
export type StatementAction = { Action: string | string[] } | { NotAction: string | string[] };
export type StatementResource =
    & MaybeStatementPrincipal
    & ({ Resource: string | string[] } | { NotResource: string | string[] });
export type StatementPrincipal =
    & MaybeStatementResource
    & ({ Principal: PrincipalValue } | { NotPrincipal: PrincipalValue });

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/api-gateway-proxy.d.ts

```typescript
import {
    APIGatewayEventClientCertificate,
    APIGatewayEventDefaultAuthorizerContext,
    APIGatewayEventRequestContextWithAuthorizer,
} from "../common/api-gateway";
import { Callback, CognitoIdentity, Handler } from "../handler";

/**
 * Works with Lambda Proxy Integration for Rest API or HTTP API integration Payload Format version 1.0
 * @see - https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html
 */
export type APIGatewayProxyHandler = Handler<APIGatewayProxyEvent, APIGatewayProxyResult>;
/**
 * Works with Lambda Proxy Integration for Rest API or HTTP API integration Payload Format version 1.0
 * @see - https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html
 */
export type APIGatewayProxyCallback = Callback<APIGatewayProxyResult>;

/**
 * Works with HTTP API integration Payload Format version 2.0
 * @see - https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html
 */
export type APIGatewayProxyHandlerV2<T = never> = Handler<APIGatewayProxyEventV2, APIGatewayProxyResultV2<T>>;

/**
 * Works with HTTP API integration Payload Format version 2.0
 * @see - https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-integration-requests.html
 * @see - https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-mapping-template-reference.html
 */
export type APIGatewayProxyWebsocketHandlerV2<T = never> = Handler<
    APIGatewayProxyWebsocketEventV2,
    APIGatewayProxyResultV2<T>
>;

/**
 * Works with HTTP API integration Payload Format version 2.0 adds JWT Authroizer to RequestContext
 * @see - https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html
 */
export type APIGatewayProxyHandlerV2WithJWTAuthorizer<T = never> = Handler<
    APIGatewayProxyEventV2WithJWTAuthorizer,
    APIGatewayProxyResultV2<T>
>;

/**
 * Works with HTTP API integration Payload Format version 2.0 adds Lambda Authroizer to RequestContext
 * @see - https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html
 */
export type APIGatewayProxyHandlerV2WithLambdaAuthorizer<TAuthorizerContext, T = never> = Handler<
    APIGatewayProxyEventV2WithLambdaAuthorizer<TAuthorizerContext>,
    APIGatewayProxyResultV2<T>
>;

/**
 * Works with HTTP API integration Payload Format version 2.0 adds IAM Authroizer to RequestContext
 * @see - https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html
 */
export type APIGatewayProxyHandlerV2WithIAMAuthorizer<T = never> = Handler<
    APIGatewayProxyEventV2WithIAMAuthorizer,
    APIGatewayProxyResultV2<T>
>;

/**
 * Works with HTTP API integration Payload Format version 2.0
 * @see - https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html
 */
export type APIGatewayProxyCallbackV2 = Callback<APIGatewayProxyResultV2>;

/**
 * Works with Lambda Proxy Integration for Rest API or HTTP API integration Payload Format version 1.0
 * @see - https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html
 */
export type APIGatewayProxyEvent = APIGatewayProxyEventBase<APIGatewayEventDefaultAuthorizerContext>;

export type APIGatewayProxyWithLambdaAuthorizerHandler<TAuthorizerContext> = Handler<
    APIGatewayProxyWithLambdaAuthorizerEvent<TAuthorizerContext>,
    APIGatewayProxyResult
>;

export type APIGatewayProxyWithCognitoAuthorizerHandler = Handler<
    APIGatewayProxyWithCognitoAuthorizerEvent,
    APIGatewayProxyResult
>;

export type APIGatewayProxyWithLambdaAuthorizerEvent<TAuthorizerContext> = APIGatewayProxyEventBase<
    APIGatewayEventLambdaAuthorizerContext<TAuthorizerContext>
>;

export type APIGatewayProxyWithLambdaAuthorizerEventRequestContext<TAuthorizerContext> =
    APIGatewayEventRequestContextWithAuthorizer<APIGatewayEventLambdaAuthorizerContext<TAuthorizerContext>>;

// API Gateway proxy integration mangles the context from a custom authorizer,
// converting all number or boolean properties to string, and adding some extra properties.
export type APIGatewayEventLambdaAuthorizerContext<TAuthorizerContext> =
    & {
        [P in keyof TAuthorizerContext]: TAuthorizerContext[P] extends null ? null : string;
    }
    & {
        principalId: string;
        integrationLatency: number;
    };

export type APIGatewayProxyWithCognitoAuthorizerEvent = APIGatewayProxyEventBase<APIGatewayProxyCognitoAuthorizer>;

// All claims are coerced into strings.
export interface APIGatewayProxyCognitoAuthorizer {
    claims: {
        [name: string]: string;
    };
}

export interface APIGatewayProxyEventHeaders {
    [name: string]: string | undefined;
}

export interface APIGatewayProxyEventMultiValueHeaders {
    [name: string]: string[] | undefined;
}

export interface APIGatewayProxyEventPathParameters {
    [name: string]: string | undefined;
}

export interface APIGatewayProxyEventQueryStringParameters {
    [name: string]: string | undefined;
}

export interface APIGatewayProxyEventMultiValueQueryStringParameters {
    [name: string]: string[] | undefined;
}

export interface APIGatewayProxyEventStageVariables {
    [name: string]: string | undefined;
}

export interface APIGatewayProxyEventBase<TAuthorizerContext> {
    body: string | null;
    headers: APIGatewayProxyEventHeaders;
    multiValueHeaders: APIGatewayProxyEventMultiValueHeaders;
    httpMethod: string;
    isBase64Encoded: boolean;
    path: string;
    pathParameters: APIGatewayProxyEventPathParameters | null;
    queryStringParameters: APIGatewayProxyEventQueryStringParameters | null;
    multiValueQueryStringParameters: APIGatewayProxyEventMultiValueQueryStringParameters | null;
    stageVariables: APIGatewayProxyEventStageVariables | null;
    requestContext: APIGatewayEventRequestContextWithAuthorizer<TAuthorizerContext>;
    resource: string;
}

/**
 * Works with Lambda Proxy Integration for Rest API or HTTP API integration Payload Format version 1.0
 * @see - https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html
 */
export interface APIGatewayProxyResult {
    statusCode: number;
    headers?:
        | {
            [header: string]: boolean | number | string;
        }
        | undefined;
    multiValueHeaders?:
        | {
            [header: string]: Array<boolean | number | string>;
        }
        | undefined;
    body: string;
    isBase64Encoded?: boolean | undefined;
}

/**
 * Works with HTTP API integration Payload Format version 2.0
 * @see - https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html
 */
export interface APIGatewayEventRequestContextV2 {
    accountId: string;
    apiId: string;
    authentication?: {
        clientCert: APIGatewayEventClientCertificate;
    };
    domainName: string;
    domainPrefix: string;
    http: {
        method: string;
        path: string;
        protocol: string;
        sourceIp: string;
        userAgent: string;
    };
    requestId: string;
    routeKey: string;
    stage: string;
    time: string;
    timeEpoch: number;
}
/**
 * Works with Websocket API integration Payload Format version 2.0
 * @see - https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-integration-requests.html
 * @see - https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api-mapping-template-reference.html
 */
export interface APIGatewayEventWebsocketRequestContextV2 {
    routeKey: string;
    messageId: string;
    eventType: "CONNECT" | "MESSAGE" | "DISCONNECT";
    extendedRequestId: string;
    requestTime: string;
    messageDirection: "IN";
    stage: string;
    connectedAt: number;
    requestTimeEpoch: number;
    requestId: string;
    domainName: string;
    connectionId: string;
    apiId: string;
}

/**
 * Proxy Event with adaptable requestContext for different authorizer scenarios
 */
export interface APIGatewayProxyEventV2WithRequestContext<TRequestContext> {
    version: string;
    routeKey: string;
    rawPath: string;
    rawQueryString: string;
    cookies?: string[];
    headers: APIGatewayProxyEventHeaders;
    queryStringParameters?: APIGatewayProxyEventQueryStringParameters;
    requestContext: TRequestContext;
    body?: string;
    pathParameters?: APIGatewayProxyEventPathParameters;
    isBase64Encoded: boolean;
    stageVariables?: APIGatewayProxyEventStageVariables;
}

/**
 * Proxy Websocket Event with adaptable requestContext for different authorizer scenarios
 */
export interface APIGatewayProxyWebsocketEventV2WithRequestContext<TRequestContext> {
    requestContext: TRequestContext;
    body?: string;
    isBase64Encoded: boolean;
    stageVariables?: APIGatewayProxyEventStageVariables;
}

/**
 * Lambda Authorizer Payload
 */
export interface APIGatewayEventRequestContextLambdaAuthorizer<TAuthorizerContext> {
    lambda: TAuthorizerContext;
}

/**
 * JWT Authorizer Payload
 */
export interface APIGatewayEventRequestContextJWTAuthorizer {
    principalId: string;
    integrationLatency: number;
    jwt: {
        claims: { [name: string]: string | number | boolean | string[] };
        scopes: string[];
    };
}

/**
 * IAM Authorizer Payload
 */
export interface APIGatewayEventRequestContextIAMAuthorizer {
    iam: {
        accessKey: string;
        accountId: string;
        callerId: string;
        cognitoIdentity: null;
        principalOrgId: string;
        userArn: string;
        userId: string;
    };
}

export type APIGatewayProxyEventV2WithJWTAuthorizer = APIGatewayProxyEventV2WithRequestContext<
    APIGatewayEventRequestContextV2WithAuthorizer<APIGatewayEventRequestContextJWTAuthorizer>
>;

export type APIGatewayProxyEventV2WithLambdaAuthorizer<TAuthorizerContext> = APIGatewayProxyEventV2WithRequestContext<
    APIGatewayEventRequestContextV2WithAuthorizer<APIGatewayEventRequestContextLambdaAuthorizer<TAuthorizerContext>>
>;

/**
 * Event type when invoking Lambda function URLs with IAM authorizer
 */
export type APIGatewayProxyEventV2WithIAMAuthorizer = APIGatewayProxyEventV2WithRequestContext<
    APIGatewayEventRequestContextV2WithAuthorizer<APIGatewayEventRequestContextIAMAuthorizer>
>;

export interface APIGatewayEventRequestContextV2WithAuthorizer<TAuthorizer> extends APIGatewayEventRequestContextV2 {
    authorizer: TAuthorizer;
}

/**
 * Default Proxy event with no Authorizer
 */
export type APIGatewayProxyEventV2 = APIGatewayProxyEventV2WithRequestContext<APIGatewayEventRequestContextV2>;

/**
 * Default Websocket Proxy event with no Authorizer
 */
export type APIGatewayProxyWebsocketEventV2 = APIGatewayProxyWebsocketEventV2WithRequestContext<
    APIGatewayEventWebsocketRequestContextV2
>;

/**
 * Works with HTTP API integration Payload Format version 2.0
 * @see - https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html
 */
export type APIGatewayProxyResultV2<T = never> = APIGatewayProxyStructuredResultV2 | string | T;

/**
 * Interface for structured response with `statusCode` and`headers`
 * Works with HTTP API integration Payload Format version 2.0
 * @see - https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html
 */
export interface APIGatewayProxyStructuredResultV2 {
    statusCode?: number | undefined;
    headers?:
        | {
            [header: string]: boolean | number | string;
        }
        | undefined;
    body?: string | undefined;
    isBase64Encoded?: boolean | undefined;
    cookies?: string[] | undefined;
}

// Legacy names
export type ProxyHandler = APIGatewayProxyHandler;
export type ProxyCallback = APIGatewayProxyCallback;
export type APIGatewayEvent = APIGatewayProxyEvent;
export type ProxyResult = APIGatewayProxyResult;

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/appsync-resolver.d.ts

```typescript
import { Handler } from "../handler";

export type AppSyncResolverHandler<TArguments, TResult, TSource = Record<string, any> | null> = Handler<
    AppSyncResolverEvent<TArguments, TSource>,
    TResult
>;

// https:docs.aws.amazon.com/appsync/latest/devguide/tutorial-lambda-resolvers.html#advanced-use-case-batching
export type AppSyncBatchResolverHandler<TArguments, TResult, TSource = Record<string, any> | null> = Handler<
    Array<AppSyncResolverEvent<TArguments, TSource>>,
    TResult[]
>;

/**
 * @deprecated Use {@link AppSyncAuthorizerHandler}
 */
export type AppSyncAuthorizerHander<TResolverContext = undefined> = AppSyncAuthorizerHandler<TResolverContext>;

/**
 * See https://docs.aws.amazon.com/appsync/latest/devguide/security-authz.html#aws-lambda-authorization
 *
 * @param TResolverContext type of the resolverContext object that you can return from the handler
 */
export type AppSyncAuthorizerHandler<TResolverContext = undefined> = Handler<
    AppSyncAuthorizerEvent,
    AppSyncAuthorizerResult<TResolverContext>
>;

export interface AppSyncResolverEventHeaders {
    [name: string]: string | undefined;
}

export interface AppSyncAuthorizerEventHeaders {
    [name: string]: string | undefined;
}

export type AppSyncIdentity =
    | AppSyncIdentityIAM
    | AppSyncIdentityCognito
    | AppSyncIdentityOIDC
    | AppSyncIdentityLambda
    | undefined
    | null;

/**
 * See https://docs.aws.amazon.com/appsync/latest/devguide/resolver-context-reference.html
 *
 * @param TArguments type of the arguments
 * @param TSource type of the source
 */
// Maintainer's note: Some of these properties are shared with the Amplify resolver.
// It may be worth checking if changes here may be applicable there too.
export interface AppSyncResolverEvent<TArguments, TSource = Record<string, any> | null> {
    arguments: TArguments;
    identity?: AppSyncIdentity;
    source: TSource;
    request: {
        headers: AppSyncResolverEventHeaders;
        /** The API's custom domain if used for the request. */
        domainName: string | null;
    };
    info: {
        selectionSetList: string[];
        selectionSetGraphQL: string;
        parentTypeName: string;
        fieldName: string;
        variables: { [key: string]: any };
    };
    prev: { result: { [key: string]: any } } | null;
    stash: { [key: string]: any };
}

export interface AppSyncAuthorizerEvent {
    authorizationToken: string;
    requestContext: {
        apiId: string;
        accountId: string;
        requestId: string;
        queryString: string;
        operationName?: string;
        variables: { [key: string]: any };
    };
    requestHeaders: AppSyncAuthorizerEventHeaders;
}

export interface AppSyncAuthorizerResult<TResolverContext = undefined> {
    isAuthorized: boolean;
    resolverContext?: TResolverContext;
    deniedFields?: string[];
    ttlOverride?: number;
}
export interface AppSyncIdentityIAM {
    accountId: string;
    cognitoIdentityPoolId: string;
    cognitoIdentityId: string;
    sourceIp: string[];
    username: string;
    userArn: string;
    cognitoIdentityAuthType: string;
    cognitoIdentityAuthProvider: string;
}

export interface AppSyncIdentityCognito {
    sub: string;
    issuer: string;
    username: string;
    claims: any;
    sourceIp: string[];
    defaultAuthStrategy: string;
    groups: string[] | null;
}

export interface AppSyncIdentityOIDC {
    claims: any;
    issuer: string;
    sub: string;
}

export interface AppSyncIdentityLambda {
    resolverContext: any;
}

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/autoscaling.d.ts

```typescript
import { Callback, Handler } from "../handler";

export type AutoScalingScaleInHandler = Handler<AutoScalingScaleInEvent, AutoScalingScaleInResult>;
export type AutoScalingScaleInCallback = Callback<AutoScalingScaleInResult>;

export type AutoScalingInstanceMarketOption = "spot" | "on-demand";

export type AutoScalingScaleInCause = "SCALE_IN" | "INSTANCE_REFRESH" | "MAX_INSTANCE_LIFETIME" | "REBALANCE";

export interface AutoScalingTerminationRequest {
    AvailabilityZone: string;
    Capacity: number;
    InstanceMarketOption: AutoScalingInstanceMarketOption;
}

export interface AutoScalingInstanceRecord {
    AvailabilityZone: string;
    InstanceId: string;
    InstanceType: string;
    InstanceMarketOption: AutoScalingInstanceMarketOption;
}

/**
 * An Auto Scaling Group may trigger a Scale In Event when you have attached
 * a custom termination policy function. This event and the expected response are
 * described in the Auto Scaling docs at:
 *
 * https://docs.aws.amazon.com/autoscaling/ec2/userguide/lambda-custom-termination-policy.html
 */
export interface AutoScalingScaleInEvent {
    AutoScalingGroupARN: string;
    AutoScalingGroupName: string;
    CapacityToTerminate: AutoScalingTerminationRequest[];
    Instances: AutoScalingInstanceRecord[];
    Cause: AutoScalingScaleInCause;
    HasMoreInstances?: boolean;
}

export interface AutoScalingScaleInResult {
    InstanceIDs: string[];
}

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/cdk-custom-resource.d.ts

```typescript
import { Callback, Handler } from "../handler";
import {
    CloudFormationCustomResourceEvent,
    CloudFormationCustomResourceResourcePropertiesCommon,
} from "./cloudformation-custom-resource";

/**
 * Request event sent to the Lambda `OnEvent` handler for a CDK Custom Resource
 * Reference: https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.custom_resources-readme.html#handling-lifecycle-events-onevent
 * @template TResourceProperties User-defined input properties passed to the Custom Resource as part of any invocation
 * @template TOldResourceProperties User-defined input properties passed to the Custom Resource as part of an `Update` invocation
 */
export type CdkCustomResourceEvent<
    TResourceProperties = CloudFormationCustomResourceResourcePropertiesCommon,
    TOldResourceProperties = TResourceProperties,
> =
    & CloudFormationCustomResourceEvent<TResourceProperties, TOldResourceProperties>
    & {
        /**
         * The response URL identifies a presigned S3 bucket that receives responses from the custom resource provider to AWS CloudFormation.
         *
         * **This URL should not be used.**
         * The CDK Provider Framework will call this URL automatically based on the response produced by the Lambda handler.
         */
        ResponseURL: string;
    };

/**
 * Lambda handler function for the `OnEvent` CDK Custom Resource
 * Reference: https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.custom_resources-readme.html#handling-lifecycle-events-onevent
 *
 * NOTE: this is not to be confused with traditional CloudFormation custom resources.
 * @template TResourceProperties User-defined input properties passed to the Custom Resource as part of any invocation
 * @template TData User-defined output properties that are retuned from any invocation
 * @template TOldResourceProperties User-defined input properties passed to the Custom Resource as part of an `Update` invocation
 */
export type CdkCustomResourceHandler<
    TResourceProperties = CloudFormationCustomResourceResourcePropertiesCommon,
    TData extends Record<string, any> = Record<string, any>,
    TOldResourceProperties = TResourceProperties,
> = Handler<CdkCustomResourceEvent<TResourceProperties, TOldResourceProperties>, CdkCustomResourceResponse<TData>>;

/**
 * Lambda `OnEvent` callback function for a CDK Custom Resource
 * @template TData User-defined output properties that are retuned from any invocation
 */
export type CdkCustomResourceCallback<TData extends Record<string, any>> = Callback<CdkCustomResourceResponse<TData>>;

/**
 * Response from the `OnEvent` Lambda handler for a CDK Custom Resource
 * Reference: https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.custom_resources-readme.html#handling-lifecycle-events-onevent
 * @template TData User-defined output properties that are retuned from any invocation
 */
export interface CdkCustomResourceResponse<TData extends Record<string, any> = Record<string, any>> {
    /**
     * This value should be an identifier unique to the custom resource vendor, and can be up to 1 KB in size. The value must be a non-empty string and must be identical for all responses for the same resource.
     * The value returned for a `PhysicalResourceId` can change custom resource update operations. If the value returned is the same, it is considered a normal update. If the value returned is different, AWS CloudFormation recognizes the update as a replacement and sends a delete request to the old resource.
     *
     * If omitted for `Create` events, the event's `RequestId` will be used.
     * For `Update`, the current physical ID will be used. If a different value is returned, CloudFormation will follow with a subsequent `Delete` for the previous ID (resource replacement).
     * For `Delete`, it will always return the current physical resource ID, and if the user returns a different one, an error will occur.
     */
    PhysicalResourceId?: string;

    /**
     * The custom resource provider-defined name-value pairs to send with the response. You can access the values provided here by name in the template with `Fn::GetAtt`.
     * NOTE: If the name-value pairs contain sensitive information, you should use the `NoEcho` field to mask the output of the custom resource. Otherwise, the values are visible through APIs that surface property values (such as `DescribeStackEvents`).
     */
    Data?: TData;

    /**
     * Indicates whether to mask the output of the custom resource when retrieved by using the `Fn::GetAtt` function. If set to `true`, all returned values are masked with asterisks (*****), __except for those stored in the `Metadata` section of the template__. AWS CloudFormation does not transform, modify, or redact any information you include in the `Metadata` section. The default value is `false`.
     */
    NoEcho?: boolean;

    /**
     * Any other field included in the response will be passed through to `isComplete`. This can sometimes be useful to pass state between the handlers.
     */
    [Key: string]: any;
}

/**
 * Request event sent to the Lambda `IsComplete` handler for an asynchronous CDK Custom Resource
 * The input event to isComplete includes all request fields, combined with all fields returned from onEvent. If PhysicalResourceId has not been explicitly returned from onEvent, it's value will be calculated based on heuristics.
 * Reference: https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.custom_resources-readme.html#asynchronous-providers-iscomplete
 * @template TResourceProperties User-defined input properties passed to the Custom Resource as part of any invocation
 * @template TData User-defined output properties that are retuned from any invocation
 * @template TOldResourceProperties User-defined input properties passed to the Custom Resource as part of an `Update` invocation
 */
export type CdkCustomResourceIsCompleteEvent<
    TResourceProperties = CloudFormationCustomResourceResourcePropertiesCommon,
    TData extends Record<string, any> = Record<string, any>,
    TOldResourceProperties = TResourceProperties,
> = CdkCustomResourceEvent<TResourceProperties, TOldResourceProperties> & CdkCustomResourceResponse<TData>;

/**
 * Common response properties from the `IsComplete` Lambda handler for a CDK Custom Resource
 * Reference: https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.custom_resources-readme.html#asynchronous-providers-iscomplete
 * @template TData User-defined output properties that are retuned from any invocation
 */
export type CdkCustomResourceIsCompleteResponse<TData extends Record<string, any> = Record<string, any>> =
    | CdkCustomResourceIsCompleteResponseSuccess<TData>
    | CdkCustomResourceIsCompleteResponseWaiting;

/**
 * Response properties that are specifically for a successful `IsComplete` response for a CDK Custom Resource
 * Reference: https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.custom_resources-readme.html#asynchronous-providers-iscomplete
 * @template TData User-defined output properties that are retuned from any invocation
 */
export interface CdkCustomResourceIsCompleteResponseSuccess<TData extends Record<string, any> = Record<string, any>> {
    /**
     * Indicates the operation has finished.
     */
    IsComplete: true;

    /**
     * The custom resource provider-defined name-value pairs to send with the response. You can access the values provided here by name in the template with `Fn::GetAtt`.
     * These attributes will be **merged** with the ones returned from `onEvent`.
     */
    Data?: TData;
}

/**
 * Response properties that are specifically for a still waiting `IsComplete` response for a CDK Custom Resource
 * Reference: https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.custom_resources-readme.html#asynchronous-providers-iscomplete
 */
export interface CdkCustomResourceIsCompleteResponseWaiting {
    /**
     * Indicates the operation has not finished.
     */
    IsComplete: false;
}

/**
 * Lambda `IsComplete` handler function for asynchronous CDK Custom Resources
 * Reference: https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.custom_resources-readme.html#asynchronous-providers-iscomplete
 * @template TResourceProperties User-defined input properties passed to the Custom Resource as part of any invocation
 * @template TOnEventData User-defined output properties that are retuned from any invocation of the `OnEvent` function
 * @template TOldResourceProperties User-defined input properties passed to the Custom Resource as part of an `Update` invocation
 * @template TIsCompleteData User-defined output properties that are retuned from any invocation of the `IsComplete` function
 */
export type CdkCustomResourceIsCompleteHandler<
    TResourceProperties = CloudFormationCustomResourceResourcePropertiesCommon,
    TOnEventData extends Record<string, any> = Record<string, any>,
    TOldResourceProperties = TResourceProperties,
    TIsCompleteData extends Record<string, any> = TOnEventData,
> = Handler<
    CdkCustomResourceIsCompleteEvent<TResourceProperties, TOnEventData, TOldResourceProperties>,
    CdkCustomResourceIsCompleteResponse<TIsCompleteData>
>;

/**
 * Lambda `IsComplete` callback function for a CDK Custom Resource
 * @template TData User-defined output properties that are retuned from any invocation
 */
export type CdkCustomResourceIsCompleteCallback<TData extends Record<string, any> = Record<string, any>> = Callback<
    CdkCustomResourceIsCompleteResponse<TData>
>;

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/cloudformation-custom-resource.d.ts

```typescript
import { Handler } from "../handler";

/**
 * Named service-defined resource properties
 * Reference: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/crpg-ref-requests.html#crpg-ref-request-properties
 */
export interface CloudFormationCustomResourceResourcePropertiesCommon extends Record<string, any> {
    /**
     * The service token, such as an Amazon SNS topic ARN or Lambda function ARN. The service token must be from the same Region as the stack.
     */
    ServiceToken: string;

    /**
     * The maximum time, in seconds, that can elapse before a custom resource operation times out.
     * The value must be an integer from 1 to 3600. The default value is 3600 seconds (1 hour).
     */
    ServiceTimeout?: string;
}

/**
 * Lambda handler function for a Lambda-backed CloudFormation Custom Resource
 *
 * NOTE: responses are *not* returned from the Lambda handler but rather they are sent to the event ResponseURL.
 * @template TResourceProperties User-defined input properties passed to the Custom Resource as part of any invocation
 * @template TOldResourceProperties User-defined input properties passed to the Custom Resource as part of an `Update` invocation
 */
export type CloudFormationCustomResourceHandler<
    TResourceProperties = CloudFormationCustomResourceResourcePropertiesCommon,
    TOldResourceProperties = TResourceProperties,
> = Handler<CloudFormationCustomResourceEvent<TResourceProperties, TOldResourceProperties>, void>;

/**
 * Request event sent to the Lambda handler for a Lambda-backed CloudFormation Custom Resource
 * Reference: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/crpg-ref-requests.html#crpg-ref-request-fields
 * @template TResourceProperties User-defined input properties passed to the Custom Resource as part of any invocation
 * @template TOldResourceProperties User-defined input properties passed to the Custom Resource as part of an `Update` invocation
 */
export type CloudFormationCustomResourceEvent<
    TResourceProperties = CloudFormationCustomResourceResourcePropertiesCommon,
    TOldResourceProperties = TResourceProperties,
> =
    | CloudFormationCustomResourceCreateEvent<TResourceProperties>
    | CloudFormationCustomResourceUpdateEvent<TResourceProperties, TOldResourceProperties>
    | CloudFormationCustomResourceDeleteEvent<TResourceProperties>;

/**
 * Response from a Lambda handler for a Lambda-backed CloudFormation Custom Resource
 * Reference: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/crpg-ref-responses.html
 *
 * NOTE: responses are *not* returned from the Lambda handler but rather they are sent to the event ResponseURL.
 * @template TData User-defined output properties that are retuned from any invocation
 */
export type CloudFormationCustomResourceResponse<TData extends Record<string, any> = Record<string, any>> =
    | CloudFormationCustomResourceSuccessResponse<TData>
    | CloudFormationCustomResourceFailedResponse<TData>;

/**
 * Request properties that are common to all invocations of a Lambda-backed CloudFormation Custom Resource
 * Reference: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/crpg-ref-requests.html#crpg-ref-request-fields
 * @template TResourceProperties User-defined input properties passed to the Custom Resource as part of any invocation
 */
export interface CloudFormationCustomResourceEventCommon<
    TResourceProperties = CloudFormationCustomResourceResourcePropertiesCommon,
> {
    /**
     * The service token, such as an Amazon SNS topic ARN or Lambda function ARN. The service token must be from the same Region as the stack.
     */
    ServiceToken: string;

    /**
     * The response URL identifies a presigned S3 bucket that receives responses from the custom resource provider to AWS CloudFormation.
     */
    ResponseURL: string;

    /**
     * The Amazon Resource Name (ARN) that identifies the stack that contains the custom resource.
     * Combining the `StackId` with the `RequestId` forms a value that you can use to uniquely identify a request on a particular custom resource.
     */
    StackId: string;

    /**
     * A unique ID for the request.
     * Combining the `StackId` with the `RequestId` forms a value that you can use to uniquely identify a request on a particular custom resource.
     */
    RequestId: string;

    /**
     * The template developer-chosen name (logical ID) of the custom resource in the AWS CloudFormation template. This is provided to facilitate communication between the custom resource provider and the template developer.
     */
    LogicalResourceId: string;

    /**
     * The template developer-chosen resource type of the custom resource in the CloudFormation template. Custom resource type names can be up to 60 characters long and can include alphanumeric and the following characters: `_@-`.
     */
    ResourceType: string;

    /**
     * This field contains the contents of the `Properties` object sent by the template developer. Its contents are defined by the custom resource provider.
     */
    ResourceProperties: TResourceProperties & CloudFormationCustomResourceResourcePropertiesCommon;
}

/**
 * Request properties specifically for the `Create` invocation of a Lambda-backed CloudFormation Custom Resource
 * @template TResourceProperties User-defined input properties passed to the Custom Resource as part of any invocation
 */
export interface CloudFormationCustomResourceCreateEvent<
    TResourceProperties = CloudFormationCustomResourceResourcePropertiesCommon,
> extends CloudFormationCustomResourceEventCommon<TResourceProperties> {
    /**
     * The request type is set by the CloudFormation stack operation (create-stack, update-stack, or delete-stack) that was initiated by the template developer for the stack that contains the custom resource.
     */
    RequestType: "Create";
}

/**
 * Request properties specifically for the `Update` invocation of a Lambda-backed CloudFormation Custom Resource
 * @template TResourceProperties User-defined input properties passed to the Custom Resource as part of any invocation
 * @template TOldResourceProperties User-defined input properties passed to the Custom Resource as part of an `Update` invocation
 */
export interface CloudFormationCustomResourceUpdateEvent<
    TResourceProperties = CloudFormationCustomResourceResourcePropertiesCommon,
    TOldResourceProperties = TResourceProperties,
> extends CloudFormationCustomResourceEventCommon<TResourceProperties> {
    /**
     * The request type is set by the CloudFormation stack operation (create-stack, update-stack, or delete-stack) that was initiated by the template developer for the stack that contains the custom resource.
     */
    RequestType: "Update";

    /**
     * A required custom resource provider-defined physical ID that is unique for that provider.
     * The value returned for a `PhysicalResourceId` can change custom resource update operations. If the value returned is the same, it is considered a normal update. If the value returned is different, AWS CloudFormation recognizes the update as a replacement and sends a delete request to the old resource.
     */
    PhysicalResourceId: string;

    /**
     * Used only for `Update` requests. Contains the resource properties that were declared previous to the update request.
     */
    OldResourceProperties: TOldResourceProperties;
}

/**
 * Request properties specifically for the `Delete` invocation of a Lambda-backed CloudFormation Custom Resource
 * @template TResourceProperties User-defined input properties passed to the Custom Resource as part of any invocation
 */
export interface CloudFormationCustomResourceDeleteEvent<
    TResourceProperties = CloudFormationCustomResourceResourcePropertiesCommon,
> extends CloudFormationCustomResourceEventCommon<TResourceProperties> {
    /**
     * The request type is set by the CloudFormation stack operation (create-stack, update-stack, or delete-stack) that was initiated by the template developer for the stack that contains the custom resource.
     */
    RequestType: "Delete";

    /**
     * A required custom resource provider-defined physical ID that is unique for that provider.
     * The value returned for a `PhysicalResourceId` can change custom resource update operations. If the value returned is the same, it is considered a normal update. If the value returned is different, AWS CloudFormation recognizes the update as a replacement and sends a delete request to the old resource.
     */
    PhysicalResourceId: string;
}

/**
 * Response properties that are common to all invocations of a Lambda-backed CloudFormation Custom Resource
 * Reference: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/crpg-ref-responses.html
 * @template TData User-defined output properties that are retuned from any invocation
 */
export interface CloudFormationCustomResourceResponseCommon<TData extends Record<string, any> = Record<string, any>> {
    /**
     * This value should be an identifier unique to the custom resource vendor, and can be up to 1 KB in size. The value must be a non-empty string and must be identical for all responses for the same resource.
     * The value returned for a `PhysicalResourceId` can change custom resource update operations. If the value returned is the same, it is considered a normal update. If the value returned is different, AWS CloudFormation recognizes the update as a replacement and sends a delete request to the old resource.
     */
    PhysicalResourceId: string;

    /**
     * The Amazon Resource Name (ARN) that identifies the stack that contains the custom resource. This response value should be copied verbatim from the request.
     */
    StackId: string;

    /**
     * A unique ID for the request. This response value should be copied verbatim from the request.
     */
    RequestId: string;

    /**
     * The template developer-chosen name (logical ID) of the custom resource in the AWS CloudFormation template. This response value should be copied verbatim from the request.
     */
    LogicalResourceId: string;

    /**
     * The custom resource provider-defined name-value pairs to send with the response. You can access the values provided here by name in the template with `Fn::GetAtt`.
     * NOTE: If the name-value pairs contain sensitive information, you should use the `NoEcho` field to mask the output of the custom resource. Otherwise, the values are visible through APIs that surface property values (such as `DescribeStackEvents`).
     */
    Data?: TData | undefined;

    /**
     * Indicates whether to mask the output of the custom resource when retrieved by using the `Fn::GetAtt` function. If set to `true`, all returned values are masked with asterisks (*****), __except for those stored in the `Metadata` section of the template__. AWS CloudFormation does not transform, modify, or redact any information you include in the `Metadata` section. The default value is `false`.
     */
    NoEcho?: boolean | undefined;
}

/**
 * Response properties that are specifically for a response indicating succesful invocation of a Lambda-backed CloudFormation Custom Resource
 * Reference: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/crpg-ref-responses.html
 * @template TData User-defined output properties that are retuned from any invocation
 */
export interface CloudFormationCustomResourceSuccessResponse<TData extends Record<string, any> = Record<string, any>>
    extends CloudFormationCustomResourceResponseCommon<TData>
{
    /**
     * The status value sent by the custom resource provider in response to an AWS CloudFormation-generated request.
     */
    Status: "SUCCESS";

    /**
     * Describes the reason for a failure response.
     */
    Reason?: string | undefined;
}

/**
 * Response properties that are specifically for a response indicating failed invocation of a Lambda-backed CloudFormation Custom Resource
 * Reference: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/crpg-ref-responses.html
 * @template TData User-defined output properties that are retuned from any invocation
 */
export interface CloudFormationCustomResourceFailedResponse<TData extends Record<string, any> = Record<string, any>>
    extends CloudFormationCustomResourceResponseCommon<TData>
{
    /**
     * The status value sent by the custom resource provider in response to an AWS CloudFormation-generated request.
     */
    Status: "FAILED";

    /**
     * Describes the reason for a failure response.
     */
    Reason: string;
}

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/cloudfront-request.d.ts

```typescript
import type { CloudFrontEvent, CloudFrontRequest, CloudFrontResultResponse } from "../common/cloudfront";
import type { Callback, Handler } from "../handler";

export type CloudFrontRequestHandler = Handler<CloudFrontRequestEvent, CloudFrontRequestResult>;
export type CloudFrontRequestCallback = Callback<CloudFrontRequestResult>;

export interface CloudFrontRequestEventRecord {
    cf: CloudFrontEvent & {
        request: CloudFrontRequest;
    };
}

/**
 * CloudFront viewer request or origin request event
 *
 * https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/lambda-event-structure.html#lambda-event-structure-request
 */
export interface CloudFrontRequestEvent {
    Records: CloudFrontRequestEventRecord[];
}

export type CloudFrontRequestResult = undefined | null | CloudFrontResultResponse | CloudFrontRequest;

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/cloudfront-response.d.ts

```typescript
import { CloudFrontEvent, CloudFrontRequest, CloudFrontResponse, CloudFrontResultResponse } from "../common/cloudfront";
import { Callback, Handler } from "../handler";

export type CloudFrontResponseHandler = Handler<CloudFrontResponseEvent, CloudFrontResponseResult>;
export type CloudFrontResponseCallback = Callback<CloudFrontResponseResult>;

export interface CloudFrontResponseEventRecord {
    cf: CloudFrontEvent & {
        readonly request: Pick<CloudFrontRequest, Exclude<keyof CloudFrontRequest, "body">>;
        response: CloudFrontResponse;
    };
}

/**
 * CloudFront viewer response or origin response event
 *
 * https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/lambda-event-structure.html#lambda-event-structure-response
 */
export interface CloudFrontResponseEvent {
    Records: CloudFrontResponseEventRecord[];
}

export type CloudFrontResponseResult = undefined | null | CloudFrontResultResponse;

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/cloudwatch-alarm.d.ts

```typescript
import { Handler } from "../handler";

export type CloudWatchAlarmHandler = Handler<CloudWatchAlarmEvent, void>;

export interface CloudWatchAlarmEvent {
    source: string;
    alarmArn: string;
    accountId: string;
    time: string;
    region: string;
    alarmData: CloudWatchAlarmData;
}

export interface CloudWatchAlarmState {
    value: string;
    reason: string;
    timestamp: string;
    reasonData?: string;
    actionsSuppressedBy?: string;
    actionsSuppressedReason?: string;
}

export interface CloudWatchMetric {
    namespace: string;
    name: string;
    dimensions?: Record<string, string>;
}

export interface CloudWatchMetricStat {
    metric: CloudWatchMetric;
    period: number;
    stat: string;
    unit?: string;
}

export interface CloudWatchAlarmMetric {
    id: string;
    metricStat: CloudWatchMetricStat;
    returnData: boolean;
}

export interface CloudWatchAlarmExpression {
    id: string;
    expression: string;
    label: string;
    returnData: boolean;
}

export type CloudWatchAlarmMetricDataQuery = CloudWatchAlarmMetric | CloudWatchAlarmExpression;

export interface CloudWatchAlarmConfiguration {
    metrics: CloudWatchAlarmMetricDataQuery[];
    description?: string;
}

export interface CloudWatchAlarmCompositeConfiguration {
    alarmRule: string;
    description?: string;
    actionsSuppressor?: string;
    actionsSuppressorWaitPeriod?: number;
    actionsSuppressorExtensionPeriod?: number;
}

export interface CloudWatchAlarmData {
    alarmName: string;
    state: CloudWatchAlarmState;
    previousState: CloudWatchAlarmState;
    configuration: CloudWatchAlarmConfiguration | CloudWatchAlarmCompositeConfiguration;
}

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/cloudwatch-events.d.ts

```typescript
import { EventBridgeEvent, EventBridgeHandler } from "../trigger/eventbridge";

export type ScheduledHandler<TDetail = any> = EventBridgeHandler<"Scheduled Event", TDetail, void>;

/**
 * https://docs.aws.amazon.com/lambda/latest/dg/with-scheduled-events.html
 */
export interface ScheduledEvent<TDetail = any> extends EventBridgeEvent<"Scheduled Event", TDetail> {}

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/cloudwatch-logs.d.ts

```typescript
import { Handler } from "../handler";

export type CloudWatchLogsHandler = Handler<CloudWatchLogsEvent, void>;

/**
 * See http://docs.aws.amazon.com/lambda/latest/dg/eventsources.html#eventsources-cloudwatch-logs
 */
export interface CloudWatchLogsEvent {
    awslogs: CloudWatchLogsEventData;
}

export interface CloudWatchLogsEventData {
    data: string;
}

export interface CloudWatchLogsDecodedData {
    owner: string;
    logGroup: string;
    logStream: string;
    subscriptionFilters: string[];
    messageType: string;
    logEvents: CloudWatchLogsLogEvent[];
}

export interface CloudWatchLogsLogEventExtractedFields {
    [name: string]: string | undefined;
}

/**
 * See http://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/SubscriptionFilters.html#LambdaFunctionExample
 */
export interface CloudWatchLogsLogEvent {
    id: string;
    timestamp: number;
    message: string;
    extractedFields?: CloudWatchLogsLogEventExtractedFields | undefined;
}

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/codebuild-cloudwatch-state.d.ts

```typescript
import { EventBridgeEvent, EventBridgeHandler } from "./eventbridge";

export type CodeBuildCloudWatchStateHandler = EventBridgeHandler<
    "CodeBuild Build State Change",
    CodeBuildStateEventDetail,
    void
>;

export type CodeBuildStateType = "IN_PROGRESS" | "SUCCEEDED" | "FAILED" | "STOPPED";
export type CodeBuildPhaseType =
    | "COMPLETED"
    | "FINALIZING"
    | "UPLOAD_ARTIFACTS"
    | "POST_BUILD"
    | "BUILD"
    | "PRE_BUILD"
    | "INSTALL"
    | "QUEUED"
    | "DOWNLOAD_SOURCE"
    | "PROVISIONING"
    | "SUBMITTED";
export type CodeBuildPhaseStatusType = "TIMED_OUT" | "STOPPED" | "FAILED" | "SUCCEEDED" | "FAULT" | "CLIENT_ERROR";
export type CodeBuildCacheType = "NO_CACHE" | "LOCAL" | "S3";
export type CodeBuildSourceLocationType =
    | "CODECOMMIT"
    | "CODEPIPELINE"
    | "GITHUB"
    | "GITHUB_ENTERPRISE"
    | "BITBUCKET"
    | "S3"
    | "NO_SOURCE";
export type CodeBuildEnvironmentType =
    | "LINUX_CONTAINER"
    | "LINUX_GPU_CONTAINER"
    | "WINDOWS_CONTAINER"
    | "ARM_CONTAINER";
export type CodeBuildEnvironmentPullCredentialsType = "CODEBUILD" | "SERVICE_ROLE";
export type CodeBuildEnvironmentComputeType =
    | "BUILD_GENERAL1_SMALL"
    | "BUILD_GENERAL1_MEDIUM"
    | "BUILD_GENERAL1_LARGE"
    | "BUILD_GENERAL1_2XLARGE";
export type CodeBuildEnvironmentVariableType = "PARAMETER_STORE" | "PLAINTEXT" | "SECRETS_MANAGER";

export interface CodeBuildStateEventDetail {
    "build-status": CodeBuildStateType;
    "project-name": string;
    "build-id": string;
    "current-phase": CodeBuildPhaseType;
    "current-phase-context": string;
    version: string;
    "additional-information": {
        cache: {
            type: CodeBuildCacheType;
        };
        "build-number": number;
        "timeout-in-minutes": number;
        "build-complete": boolean;
        initiator: string;
        "build-start-time": string;
        source: {
            buildspec: string;
            location: string;
            type: CodeBuildSourceLocationType;
        };
        "source-version": string;
        artifact: {
            location: string;
        };
        environment: {
            image: string;
            "privileged-mode": boolean;
            "image-pull-credentials-type"?: CodeBuildEnvironmentPullCredentialsType | undefined;
            "compute-type": CodeBuildEnvironmentComputeType;
            type: CodeBuildEnvironmentType;
            "environment-variables": Array<{
                name: string;
                type?: CodeBuildEnvironmentVariableType | undefined;
                value: string;
            }>;
        };
        "project-file-system-locations": [];
        logs: {
            "group-name": string;
            "stream-name": string;
            "deep-link": string;
        };
        phases: Array<{
            "phase-context"?: string[] | undefined; // Not available for COMPLETED phase-type
            "start-time": string;
            "end-time"?: string | undefined; // Not available for COMPLETED phase-type
            "duration-in-seconds"?: number | undefined; // Not available for COMPLETED phase-type
            "phase-type": CodeBuildPhaseType;
            "phase-status"?: CodeBuildPhaseStatusType | undefined; // Not available for COMPLETED phase-type
        }>;
        "queued-timeout-in-minutes": number;
    };
}

export interface CodeBuildCloudWatchStateEvent
    extends EventBridgeEvent<"CodeBuild Build State Change", CodeBuildStateEventDetail>
{
    source: "aws.codebuild";
}

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/codecommit.d.ts

```typescript
import { Handler } from "../handler";

export type CodeCommitHandler = Handler<CodeCommitTrigger, void>;

/**
 * CodeCommit events
 * https://docs.aws.amazon.com/lambda/latest/dg/services-codecommit.html
 */
export interface CodeCommitTrigger {
    awsRegion: string;
    codecommit: {
        references: Array<{
            commit: string;
            created?: boolean;
            deleted?: boolean;
            ref: string;
        }>;
    };
    customData?: string;
    eventId: string;
    eventName: string;
    eventPartNumber: number;
    eventSource: string;
    eventSourceARN: string;
    eventTime: string;
    eventTotalParts: number;
    eventTriggerConfigId: string;
    eventTriggerName: string;
    eventVersion: string;
    userIdentityARN: string;
}

export interface CodeCommitTriggerEvent {
    Records: CodeCommitTrigger[];
}

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/codepipeline-cloudwatch-action.d.ts

```typescript
import { Handler } from "../handler";

export type CodePipelineCloudWatchActionHandler = Handler<CodePipelineCloudWatchActionEvent, void>;

export type CodePipelineActionCategory = "Approval" | "Build" | "Deploy" | "Invoke" | "Source" | "Test";
export type CodePipelineActionState = "STARTED" | "SUCCEEDED" | "FAILED" | "CANCELED";

export interface CodePipelineCloudWatchActionEvent {
    version: string;
    id: string;
    "detail-type": "CodePipeline Action Execution State Change";
    source: "aws.codepipeline";
    account: string;
    time: string;
    region: string;
    resources: string[];
    detail: {
        pipeline: string;
        version: number;
        "execution-id": string;
        stage: string;
        action: string;
        state: CodePipelineActionState;
        type: {
            owner: "AWS" | "Custom" | "ThirdParty";
            category: CodePipelineActionCategory;
            provider: string;
            version: number;
        };
    };
}

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/codepipeline-cloudwatch-pipeline.d.ts

```typescript
import { Handler } from "../handler";

export type CodePipelineCloudWatchPipelineHandler = Handler<CodePipelineCloudWatchPipelineEvent, void>;

export type CodePipelineState = "STARTED" | "SUCCEEDED" | "RESUMED" | "FAILED" | "CANCELED" | "SUPERSEDED";

/**
 * CodePipeline CloudWatch Events
 * https://docs.aws.amazon.com/codepipeline/latest/userguide/detect-state-changes-cloudwatch-events.html
 *
 * The above CodePipelineEvent is when a lambda is invoked by a CodePipeline.
 * These events are when you subscribe to CodePipeline events in CloudWatch.
 *
 * Their documentation says that detail.version is a string, but it is actually an integer
 */

export interface CodePipelineCloudWatchPipelineEvent {
    version: string;
    id: string;
    "detail-type": "CodePipeline Pipeline Execution State Change";
    source: "aws.codepipeline";
    account: string;
    time: string;
    region: string;
    resources: string[];
    detail: {
        pipeline: string;
        version: number;
        state: CodePipelineState;
        "execution-id": string;
    };
}

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/codepipeline-cloudwatch-stage.d.ts

```typescript
import { Handler } from "../handler";

export type CodePipelineCloudWatchStageHandler = Handler<CodePipelineCloudWatchStageEvent, void>;

export type CodePipelineStageState = "STARTED" | "SUCCEEDED" | "RESUMED" | "FAILED" | "CANCELED";

export interface CodePipelineCloudWatchStageEvent {
    version: string;
    id: string;
    "detail-type": "CodePipeline Stage Execution State Change";
    source: "aws.codepipeline";
    account: string;
    time: string;
    region: string;
    resources: string[];
    detail: {
        pipeline: string;
        version: number;
        "execution-id": string;
        stage: string;
        state: CodePipelineStageState;
    };
}

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/codepipeline-cloudwatch.d.ts

```typescript
import { Handler } from "../handler";
import { CodePipelineCloudWatchActionEvent } from "./codepipeline-cloudwatch-action";
import { CodePipelineCloudWatchPipelineEvent } from "./codepipeline-cloudwatch-pipeline";
import { CodePipelineCloudWatchStageEvent } from "./codepipeline-cloudwatch-stage";

export type CodePipelineCloudWatchHandler = Handler<CodePipelineCloudWatchEvent, void>;

export type CodePipelineCloudWatchEvent =
    | CodePipelineCloudWatchPipelineEvent
    | CodePipelineCloudWatchStageEvent
    | CodePipelineCloudWatchActionEvent;

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/codepipeline.d.ts

```typescript
import { Handler } from "../handler";

export type CodePipelineHandler = Handler<CodePipelineEvent, void>;

/**
 * CodePipeline events
 * https://docs.aws.amazon.com/codepipeline/latest/userguide/actions-invoke-lambda-function.html
 */
export interface S3ArtifactLocation {
    bucketName: string;
    objectKey: string;
}
export interface S3ArtifactStore {
    type: "S3";
    s3Location: S3ArtifactLocation;
}

export type ArtifactLocation = S3ArtifactStore;

export interface Artifact {
    name: string;
    revision: string | null;
    location: ArtifactLocation;
}

export interface Credentials {
    accessKeyId: string;
    secretAccessKey: string;
    sessionToken?: string | undefined;
}

export interface EncryptionKey {
    type: string;
    id: string;
}

export interface CodePipelineEvent {
    "CodePipeline.job": {
        id: string;
        accountId: string;
        data: {
            actionConfiguration: {
                configuration: {
                    FunctionName: string;
                    UserParameters: string;
                };
            };
            inputArtifacts: Artifact[];
            outputArtifacts: Artifact[];
            artifactCredentials: Credentials;
            encryptionKey?: (EncryptionKey & { type: "KMS" }) | undefined;
            continuationToken?: string | undefined;
        };
    };
}

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/cognito-user-pool-trigger/_common.d.ts

```typescript
export interface StringMap {
    [name: string]: string;
}

export type ChallengeName =
    | "PASSWORD_VERIFIER"
    | "SMS_MFA"
    | "DEVICE_SRP_AUTH"
    | "DEVICE_PASSWORD_VERIFIER"
    | "ADMIN_NO_SRP_AUTH"
    | "SRP_A";

export interface ChallengeResult {
    challengeName: ChallengeName;
    challengeResult: boolean;
    challengeMetadata?: undefined;
}

export interface CustomChallengeResult {
    challengeName: "CUSTOM_CHALLENGE";
    challengeResult: boolean;
    challengeMetadata?: string | undefined;
}

/**
 * Common attributes shared by all User Pool Lambda Trigger Events
 * @see https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools-working-with-aws-lambda-triggers.html#cognito-user-pools-lambda-trigger-event-parameter-shared
 */
export interface BaseTriggerEvent<T extends string> {
    version: string;
    region: string;
    userPoolId: string;
    triggerSource: T;
    userName: string;
    callerContext: {
        awsSdkVersion: string;
        clientId: string;
    };
    request: {};
    response: {};
}

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/cognito-user-pool-trigger/create-auth-challenge.d.ts

```typescript
import { Handler } from "../../handler";
import { BaseTriggerEvent, ChallengeResult, CustomChallengeResult, StringMap } from "./_common";

/**
 * @see https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-lambda-create-auth-challenge.html
 */
export interface CreateAuthChallengeTriggerEvent extends BaseTriggerEvent<"CreateAuthChallenge_Authentication"> {
    request: {
        userAttributes: StringMap;
        challengeName: string;
        session: Array<ChallengeResult | CustomChallengeResult>;
        userNotFound?: boolean | undefined;
        clientMetadata?: StringMap | undefined;
    };
    response: {
        publicChallengeParameters: StringMap;
        privateChallengeParameters: StringMap;
        challengeMetadata: string;
    };
}

export type CreateAuthChallengeTriggerHandler = Handler<CreateAuthChallengeTriggerEvent>;

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/cognito-user-pool-trigger/custom-email-sender.d.ts

```typescript
import { Handler } from "../../handler";
import { BaseTriggerEvent, StringMap } from "./_common";

export interface BaseCustomEmailSenderTriggerEvent<T extends string> extends BaseTriggerEvent<T> {
    request: {
        type: string;
        code: string | null;
        userAttributes: StringMap;
        clientMetadata?: StringMap | undefined;
    };
}

export type AccountTakeOverActionType = "BLOCK" | "NO_ACTION" | "MFA" | "MFA_IF_CONFIGURED" | "MFA_REQUIRED";

export interface CustomEmailSender_AccountTakeOverNotification_UserAttributes {
    EVENT_ID: string;
    USER_NAME: string;
    IP_ADDRESS: string;
    ACCOUNT_TAKE_OVER_ACTION: AccountTakeOverActionType;
    ONE_CLICK_LINK_VALID: string;
    ONE_CLICK_LINK_INVALID: string;
    LOGIN_TIME: string;
    FEEDBACK_TOKEN: string;
    CITY?: string | undefined;
    COUNTRY?: string | undefined;
    DEVICE_NAME?: string | undefined;
}

export interface CustomEmailSenderSignUpTriggerEvent
    extends BaseCustomEmailSenderTriggerEvent<"CustomEmailSender_SignUp">
{}

export interface CustomEmailSenderResendCodeTriggerEvent
    extends BaseCustomEmailSenderTriggerEvent<"CustomEmailSender_ResendCode">
{}

export interface CustomEmailSenderForgotPasswordTriggerEvent
    extends BaseCustomEmailSenderTriggerEvent<"CustomEmailSender_ForgotPassword">
{}

export interface CustomEmailSenderUpdateUserAttributeTriggerEvent
    extends BaseCustomEmailSenderTriggerEvent<"CustomEmailSender_UpdateUserAttribute">
{}

export interface CustomEmailSenderVerifyUserAttributeTriggerEvent
    extends BaseCustomEmailSenderTriggerEvent<"CustomEmailSender_VerifyUserAttribute">
{}

export interface CustomEmailSenderAdminCreateUserTriggerEvent
    extends BaseCustomEmailSenderTriggerEvent<"CustomEmailSender_AdminCreateUser">
{}

export interface CustomEmailSenderAccountTakeOverNotificationTriggerEvent
    extends BaseTriggerEvent<"CustomEmailSender_AccountTakeOverNotification">
{
    request: {
        type: string;
        code: string | null;
        userAttributes: CustomEmailSender_AccountTakeOverNotification_UserAttributes;
        clientMetadata?: StringMap | undefined;
    };
}

/**
 * @see https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-lambda-custom-email-sender.html
 */
export type CustomEmailSenderTriggerEvent =
    | CustomEmailSenderSignUpTriggerEvent
    | CustomEmailSenderResendCodeTriggerEvent
    | CustomEmailSenderForgotPasswordTriggerEvent
    | CustomEmailSenderUpdateUserAttributeTriggerEvent
    | CustomEmailSenderVerifyUserAttributeTriggerEvent
    | CustomEmailSenderAdminCreateUserTriggerEvent
    | CustomEmailSenderAccountTakeOverNotificationTriggerEvent;

export type CustomEmailSenderTriggerHandler = Handler<CustomEmailSenderTriggerEvent>;

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/cognito-user-pool-trigger/custom-message.d.ts

```typescript
import { Handler } from "../../handler";
import { BaseTriggerEvent, StringMap } from "./_common";

export interface BaseCustomMessageTriggerEvent<T extends string> extends BaseTriggerEvent<T> {
    request: {
        userAttributes: StringMap;
        codeParameter: string;
        linkParameter: string;
        /**
         * This is null for all events other than the AdminCreateUser action.
         */
        usernameParameter: string | null;
        clientMetadata?: StringMap | undefined;
    };
    response: {
        smsMessage: string | null;
        emailMessage: string | null;
        emailSubject: string | null;
    };
}

export type CustomMessageAdminCreateUserTriggerEvent = BaseCustomMessageTriggerEvent<"CustomMessage_AdminCreateUser">;

export type CustomMessageAuthenticationTriggerEvent = BaseCustomMessageTriggerEvent<"CustomMessage_Authentication">;

export type CustomMessageForgotPasswordTriggerEvent = BaseCustomMessageTriggerEvent<"CustomMessage_ForgotPassword">;

export type CustomMessageResendCodeTriggerEvent = BaseCustomMessageTriggerEvent<"CustomMessage_ResendCode">;

export type CustomMessageSignUpTriggerEvent = BaseCustomMessageTriggerEvent<"CustomMessage_SignUp">;

export type CustomMessageUpdateUserAttributeTriggerEvent = BaseCustomMessageTriggerEvent<
    "CustomMessage_UpdateUserAttribute"
>;

export type CustomMessageVerifyUserAttributeTriggerEvent = BaseCustomMessageTriggerEvent<
    "CustomMessage_VerifyUserAttribute"
>;

/**
 * @see https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-lambda-custom-message.html
 */
export type CustomMessageTriggerEvent =
    | CustomMessageSignUpTriggerEvent
    | CustomMessageAdminCreateUserTriggerEvent
    | CustomMessageResendCodeTriggerEvent
    | CustomMessageForgotPasswordTriggerEvent
    | CustomMessageUpdateUserAttributeTriggerEvent
    | CustomMessageVerifyUserAttributeTriggerEvent
    | CustomMessageAuthenticationTriggerEvent;

export type CustomMessageTriggerHandler = Handler<CustomMessageTriggerEvent>;

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/cognito-user-pool-trigger/custom-sms-sender.d.ts

```typescript
import { Handler } from "../../handler";
import { BaseTriggerEvent, StringMap } from "./_common";

export interface BaseCustomSMSSenderTriggerEvent<T extends string> extends BaseTriggerEvent<T> {
    request: {
        type: string;
        code: string | null;
        userAttributes: StringMap;
        clientMetadata?: StringMap | undefined;
    };
}

export interface CustomSMSSenderSignUpTriggerEvent extends BaseCustomSMSSenderTriggerEvent<"CustomSMSSender_SignUp"> {}

export interface CustomSMSSenderResendCodeTriggerEvent
    extends BaseCustomSMSSenderTriggerEvent<"CustomSMSSender_ResendCode">
{}

export interface CustomSMSSenderForgotPasswordTriggerEvent
    extends BaseCustomSMSSenderTriggerEvent<"CustomSMSSender_ForgotPassword">
{}

export interface CustomSMSSenderUpdateUserAttributeTriggerEvent
    extends BaseCustomSMSSenderTriggerEvent<"CustomSMSSender_UpdateUserAttribute">
{}

export interface CustomSMSSenderVerifyUserAttributeTriggerEvent
    extends BaseCustomSMSSenderTriggerEvent<"CustomSMSSender_VerifyUserAttribute">
{}

export interface CustomSMSSenderAdminCreateUserTriggerEvent
    extends BaseCustomSMSSenderTriggerEvent<"CustomSMSSender_AdminCreateUser">
{}

export interface CustomSMSSenderAuthenticationUserTriggerEvent
    extends BaseCustomSMSSenderTriggerEvent<"CustomSMSSender_Authentication">
{}

/**
 * @see https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-lambda-custom-sms-sender.html
 */
export type CustomSMSSenderTriggerEvent =
    | CustomSMSSenderSignUpTriggerEvent
    | CustomSMSSenderResendCodeTriggerEvent
    | CustomSMSSenderForgotPasswordTriggerEvent
    | CustomSMSSenderUpdateUserAttributeTriggerEvent
    | CustomSMSSenderVerifyUserAttributeTriggerEvent
    | CustomSMSSenderAdminCreateUserTriggerEvent
    | CustomSMSSenderAuthenticationUserTriggerEvent;

export type CustomSMSSenderTriggerHandler = Handler<CustomSMSSenderTriggerEvent>;

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/cognito-user-pool-trigger/define-auth-challenge.d.ts

```typescript
import { Handler } from "../../handler";
import { BaseTriggerEvent, ChallengeResult, CustomChallengeResult, StringMap } from "./_common";

/**
 * @see https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-lambda-define-auth-challenge.html
 */
export interface DefineAuthChallengeTriggerEvent extends BaseTriggerEvent<"DefineAuthChallenge_Authentication"> {
    request: {
        userAttributes: StringMap;
        session: Array<ChallengeResult | CustomChallengeResult>;
        userNotFound?: boolean | undefined;
        clientMetadata?: StringMap | undefined;
    };
    response: {
        challengeName?: string | undefined;
        failAuthentication: boolean;
        issueTokens: boolean;
    };
}

export type DefineAuthChallengeTriggerHandler = Handler<DefineAuthChallengeTriggerEvent>;

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/cognito-user-pool-trigger/index.d.ts

```typescript
import { Handler } from "../../handler";

/**
 * Cognito User Pool event
 * @deprecated Please use specific event types instead
 * http://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools-working-with-aws-lambda-triggers.html
 */
export interface CognitoUserPoolTriggerEvent {
    version: number;
    triggerSource:
        | "PreSignUp_SignUp"
        | "PreSignUp_ExternalProvider"
        | "PostConfirmation_ConfirmSignUp"
        | "PreAuthentication_Authentication"
        | "PostAuthentication_Authentication"
        | "CustomMessage_SignUp"
        | "CustomMessage_AdminCreateUser"
        | "CustomMessage_ResendCode"
        | "CustomMessage_ForgotPassword"
        | "CustomMessage_UpdateUserAttribute"
        | "CustomMessage_VerifyUserAttribute"
        | "CustomMessage_Authentication"
        | "DefineAuthChallenge_Authentication"
        | "CreateAuthChallenge_Authentication"
        | "VerifyAuthChallengeResponse_Authentication"
        | "PreSignUp_AdminCreateUser"
        | "PostConfirmation_ConfirmForgotPassword"
        | "TokenGeneration_HostedAuth"
        | "TokenGeneration_Authentication"
        | "TokenGeneration_NewPasswordChallenge"
        | "TokenGeneration_AuthenticateDevice"
        | "TokenGeneration_RefreshTokens"
        | "TokenGeneration_ClientCredentials"
        | "UserMigration_Authentication"
        | "UserMigration_ForgotPassword";
    region: string;
    userPoolId: string;
    userName?: string | undefined;
    callerContext: {
        awsSdkVersion: string;
        clientId: string;
    };
    request: {
        userAttributes: { [key: string]: string };
        validationData?: { [key: string]: string } | undefined;
        codeParameter?: string | undefined;
        linkParameter?: string | undefined;
        usernameParameter?: string | undefined;
        newDeviceUsed?: boolean | undefined;
        session?:
            | Array<{
                challengeName:
                    | "CUSTOM_CHALLENGE"
                    | "PASSWORD_VERIFIER"
                    | "SMS_MFA"
                    | "DEVICE_SRP_AUTH"
                    | "DEVICE_PASSWORD_VERIFIER"
                    | "ADMIN_NO_SRP_AUTH"
                    | "SRP_A";
                challengeResult: boolean;
                challengeMetadata?: string | undefined;
            }>
            | undefined;
        challengeName?: string | undefined;
        privateChallengeParameters?: { [key: string]: string } | undefined;
        challengeAnswer?: string | undefined;
        password?: string | undefined;
        clientMetadata?: { [key: string]: string } | undefined;
        userNotFound?: boolean | undefined;
    };
    response: {
        autoConfirmUser?: boolean | undefined;
        autoVerifyPhone?: boolean | undefined;
        autoVerifyEmail?: boolean | undefined;
        smsMessage?: string | undefined;
        emailMessage?: string | undefined;
        emailSubject?: string | undefined;
        challengeName?: string | undefined;
        issueTokens?: boolean | undefined;
        failAuthentication?: boolean | undefined;
        publicChallengeParameters?: { [key: string]: string } | undefined;
        privateChallengeParameters?: { [key: string]: string } | undefined;
        challengeMetadata?: string | undefined;
        answerCorrect?: boolean | undefined;
        userAttributes?: { [key: string]: string } | undefined;
        finalUserStatus?: "CONFIRMED" | "RESET_REQUIRED" | undefined;
        messageAction?: "SUPPRESS" | undefined;
        desiredDeliveryMediums?: Array<"EMAIL" | "SMS"> | undefined;
        forceAliasCreation?: boolean | undefined;
        claimsOverrideDetails?:
            | {
                claimsToAddOrOverride?: { [key: string]: string } | undefined;
                claimsToSuppress?: string[] | undefined;
                groupOverrideDetails?:
                    | null
                    | {
                        groupsToOverride?: string[] | undefined;
                        iamRolesToOverride?: string[] | undefined;
                        preferredRole?: string | undefined;
                    }
                    | undefined;
            }
            | undefined;
    };
}

/**
 * @deprecated Please use specific event types instead
 */
export type CognitoUserPoolEvent = CognitoUserPoolTriggerEvent;

/**
 * @deprecated Please use specific event handler types instead
 */
export type CognitoUserPoolTriggerHandler = Handler<CognitoUserPoolTriggerEvent>;

export * from "./create-auth-challenge";
export * from "./custom-email-sender";
export * from "./custom-message";
export * from "./custom-sms-sender";
export * from "./define-auth-challenge";
export * from "./post-authentication";
export * from "./post-confirmation";
export * from "./pre-authentication";
export * from "./pre-signup";
export * from "./pre-token-generation";
export * from "./pre-token-generation-v2";
export * from "./pre-token-generation-v3";
export * from "./user-migration";
export * from "./verify-auth-challenge-response";

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/cognito-user-pool-trigger/post-authentication.d.ts

```typescript
import { Handler } from "../../handler";
import { BaseTriggerEvent, StringMap } from "./_common";

/**
 * @see https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-lambda-post-authentication.html
 */
export interface PostAuthenticationTriggerEvent extends BaseTriggerEvent<"PostAuthentication_Authentication"> {
    request: {
        userAttributes: StringMap;
        newDeviceUsed: boolean;
        clientMetadata?: StringMap | undefined;
    };
}

export type PostAuthenticationTriggerHandler = Handler<PostAuthenticationTriggerEvent>;

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/cognito-user-pool-trigger/post-confirmation.d.ts

```typescript
import { Handler } from "../../handler";
import { BaseTriggerEvent, StringMap } from "./_common";

export interface BasePostConfirmationTriggerEvent<T extends string> extends BaseTriggerEvent<T> {
    request: {
        userAttributes: StringMap;
        clientMetadata?: StringMap | undefined;
    };
}

export type PostConfirmationConfirmSignUpTriggerEvent = BasePostConfirmationTriggerEvent<
    "PostConfirmation_ConfirmSignUp"
>;

export type PostConfirmationConfirmForgotPassword = BasePostConfirmationTriggerEvent<
    "PostConfirmation_ConfirmForgotPassword"
>;

/**
 * @see https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-lambda-post-confirmation.html
 */
export type PostConfirmationTriggerEvent =
    | PostConfirmationConfirmSignUpTriggerEvent
    | PostConfirmationConfirmForgotPassword;

export type PostConfirmationTriggerHandler = Handler<PostConfirmationTriggerEvent>;

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/cognito-user-pool-trigger/pre-authentication.d.ts

```typescript
import { Handler } from "../../handler";
import { BaseTriggerEvent, StringMap } from "./_common";

/**
 * @see https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-lambda-pre-authentication.html
 */
export interface PreAuthenticationTriggerEvent extends BaseTriggerEvent<"PreAuthentication_Authentication"> {
    request: {
        userAttributes: StringMap;
        userNotFound?: boolean | undefined;
        validationData?: StringMap | undefined;
        clientMetadata?: StringMap | undefined;
    };
}

export type PreAuthenticationTriggerHandler = Handler<PreAuthenticationTriggerEvent>;

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/cognito-user-pool-trigger/pre-signup.d.ts

```typescript
import { Handler } from "../../handler";
import { BaseTriggerEvent, StringMap } from "./_common";

export interface BasePreSignUpTriggerEvent<T extends string> extends BaseTriggerEvent<T> {
    request: {
        userAttributes: StringMap;
        validationData?: StringMap | undefined;
        clientMetadata?: StringMap | undefined;
    };
    response: {
        autoConfirmUser: boolean;
        autoVerifyEmail: boolean;
        autoVerifyPhone: boolean;
    };
}

export type PreSignUpEmailTriggerEvent = BasePreSignUpTriggerEvent<"PreSignUp_SignUp">;

export type PreSignUpExternalProviderTriggerEvent = BasePreSignUpTriggerEvent<"PreSignUp_ExternalProvider">;

export type PreSignUpAdminCreateUserTriggerEvent = BasePreSignUpTriggerEvent<"PreSignUp_AdminCreateUser">;

/**
 * @see https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-lambda-pre-sign-up.html
 */
export type PreSignUpTriggerEvent =
    | PreSignUpEmailTriggerEvent
    | PreSignUpExternalProviderTriggerEvent
    | PreSignUpAdminCreateUserTriggerEvent;

export type PreSignUpTriggerHandler = Handler<PreSignUpTriggerEvent>;

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/cognito-user-pool-trigger/pre-token-generation-v2.d.ts

```typescript
import { Handler } from "../../handler";
import { BaseTriggerEvent, StringMap } from "./_common";

export interface GroupOverrideDetailsV2 {
    groupsToOverride?: string[] | undefined;
    iamRolesToOverride?: string[] | undefined;
    preferredRole?: string | undefined;
}

/**
 * @see https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-lambda-pre-token-generation.html#cognito-user-pools-lambda-trigger-syntax-pre-token-generation
 */
export interface IdTokenGeneration {
    claimsToAddOrOverride?: StringMap | undefined;
    claimsToSuppress?: string[] | undefined;
}

export interface AccessTokenGeneration {
    claimsToAddOrOverride?: StringMap | undefined;
    claimsToSuppress?: string[] | undefined;
    scopesToAdd?: string[] | undefined;
    scopesToSuppress?: string[] | undefined;
}

export interface ClaimsAndScopeOverrideDetails {
    idTokenGeneration?: IdTokenGeneration | undefined;
    accessTokenGeneration?: AccessTokenGeneration | undefined;
    groupOverrideDetails?: GroupOverrideDetailsV2 | undefined;
}

export interface BasePreTokenGenerationV2TriggerEvent<T extends string> extends BaseTriggerEvent<T> {
    request: {
        userAttributes: StringMap;
        groupConfiguration: GroupOverrideDetailsV2;
        scopes?: string[] | undefined;
        clientMetadata?: StringMap | undefined;
    };
    response: {
        claimsAndScopeOverrideDetails: ClaimsAndScopeOverrideDetails;
    };
}

export type PreTokenGenerationHostedAuthV2TriggerEvent = BasePreTokenGenerationV2TriggerEvent<
    "TokenGeneration_HostedAuth"
>;

export type PreTokenGenerationAuthenticationV2TriggerEvent = BasePreTokenGenerationV2TriggerEvent<
    "TokenGeneration_Authentication"
>;

export type PreTokenGenerationNewPasswordChallengeV2TriggerEvent = BasePreTokenGenerationV2TriggerEvent<
    "TokenGeneration_NewPasswordChallenge"
>;

export type PreTokenGenerationAuthenticateDeviceV2TriggerEvent = BasePreTokenGenerationV2TriggerEvent<
    "TokenGeneration_AuthenticateDevice"
>;

export type PreTokenGenerationRefreshTokensV2TriggerEvent = BasePreTokenGenerationV2TriggerEvent<
    "TokenGeneration_RefreshTokens"
>;

/**
 * @see https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-lambda-pre-token-generation.html
 */
export type PreTokenGenerationV2TriggerEvent =
    | PreTokenGenerationHostedAuthV2TriggerEvent
    | PreTokenGenerationAuthenticationV2TriggerEvent
    | PreTokenGenerationNewPasswordChallengeV2TriggerEvent
    | PreTokenGenerationAuthenticateDeviceV2TriggerEvent
    | PreTokenGenerationRefreshTokensV2TriggerEvent;

export type PreTokenGenerationV2TriggerHandler = Handler<PreTokenGenerationV2TriggerEvent>;

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/cognito-user-pool-trigger/pre-token-generation-v3.d.ts

```typescript
import { Handler } from "../../handler";
import { BaseTriggerEvent, StringMap } from "./_common";

export interface GroupOverrideDetailsV3 {
    groupsToOverride?: string[];
    iamRolesToOverride?: string[];
    preferredRole?: string;
}

export interface IdTokenGenerationV3 {
    claimsToAddOrOverride?: StringMap;
    claimsToSuppress?: string[];
}

export interface AccessTokenGenerationV3 {
    claimsToAddOrOverride?: StringMap;
    claimsToSuppress?: string[];
    scopesToAdd?: string[];
    scopesToSuppress?: string[];
}

export interface ClaimsAndScopeOverrideDetailsV3 {
    idTokenGeneration?: IdTokenGenerationV3;
    accessTokenGeneration?: AccessTokenGenerationV3;
    groupOverrideDetails?: GroupOverrideDetailsV3;
}

/**
 * @see https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-lambda-pre-token-generation.html
 */
export interface BasePreTokenGenerationV3TriggerEvent<T extends string> extends BaseTriggerEvent<T> {
    version: "3";
    request: {
        userAttributes: StringMap;
        groupConfiguration: GroupOverrideDetailsV3;
        scopes?: string[];
        clientMetadata?: StringMap;
    };
    response: {
        claimsAndScopeOverrideDetails: ClaimsAndScopeOverrideDetailsV3;
    };
}

export type PreTokenGenerationClientCredentialsV3TriggerEvent = BasePreTokenGenerationV3TriggerEvent<
    "TokenGeneration_ClientCredentials"
>;

export type PreTokenGenerationV3TriggerEvent = PreTokenGenerationClientCredentialsV3TriggerEvent;

export type PreTokenGenerationV3TriggerHandler = Handler<PreTokenGenerationV3TriggerEvent>;

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/cognito-user-pool-trigger/pre-token-generation.d.ts

```typescript
import { Handler } from "../../handler";
import { BaseTriggerEvent, StringMap } from "./_common";

export interface GroupOverrideDetails {
    groupsToOverride?: string[] | undefined;
    iamRolesToOverride?: string[] | undefined;
    preferredRole?: string | undefined;
}

export interface BasePreTokenGenerationTriggerEvent<T extends string> extends BaseTriggerEvent<T> {
    request: {
        userAttributes: StringMap;
        groupConfiguration: GroupOverrideDetails;
        clientMetadata?: StringMap | undefined;
    };
    response: {
        claimsOverrideDetails: {
            claimsToAddOrOverride?: StringMap | undefined;
            claimsToSuppress?: string[] | undefined;
            groupOverrideDetails?: GroupOverrideDetails | undefined;
        };
    };
}

export type PreTokenGenerationHostedAuthTriggerEvent = BasePreTokenGenerationTriggerEvent<"TokenGeneration_HostedAuth">;

export type PreTokenGenerationAuthenticationTriggerEvent = BasePreTokenGenerationTriggerEvent<
    "TokenGeneration_Authentication"
>;

export type PreTokenGenerationNewPasswordChallengeTriggerEvent = BasePreTokenGenerationTriggerEvent<
    "TokenGeneration_NewPasswordChallenge"
>;

export type PreTokenGenerationAuthenticateDeviceTriggerEvent = BasePreTokenGenerationTriggerEvent<
    "TokenGeneration_AuthenticateDevice"
>;

export type PreTokenGenerationRefreshTokensTriggerEvent = BasePreTokenGenerationTriggerEvent<
    "TokenGeneration_RefreshTokens"
>;

/**
 * @see https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-lambda-pre-token-generation.html
 */
export type PreTokenGenerationTriggerEvent =
    | PreTokenGenerationHostedAuthTriggerEvent
    | PreTokenGenerationAuthenticationTriggerEvent
    | PreTokenGenerationNewPasswordChallengeTriggerEvent
    | PreTokenGenerationAuthenticateDeviceTriggerEvent
    | PreTokenGenerationRefreshTokensTriggerEvent;

export type PreTokenGenerationTriggerHandler = Handler<PreTokenGenerationTriggerEvent>;

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/cognito-user-pool-trigger/user-migration.d.ts

```typescript
import { Handler } from "../../handler";
import { BaseTriggerEvent, StringMap } from "./_common";

export type UserStatus =
    | "UNCONFIRMED"
    | "CONFIRMED"
    | "ARCHIVED"
    | "COMPROMISED"
    | "UNKNOWN"
    | "RESET_REQUIRED"
    | "FORCE_CHANGE_PASSWORD";

export interface BaseUserMigrationTriggerEvent<T extends string> extends BaseTriggerEvent<T> {
    request: {
        password: string;
        validationData?: StringMap | undefined;
        clientMetadata?: StringMap | undefined;
    };
    response: {
        userAttributes: StringMap;
        finalUserStatus?: UserStatus | undefined;
        messageAction?: "RESEND" | "SUPPRESS" | undefined;
        desiredDeliveryMediums: Array<"SMS" | "EMAIL">;
        forceAliasCreation?: boolean | undefined;
        enableSMSMFA?: boolean | undefined;
    };
}

export type UserMigrationAuthenticationTriggerEvent = BaseUserMigrationTriggerEvent<"UserMigration_Authentication">;

export type UserMigrationForgotPasswordTriggerEvent = BaseUserMigrationTriggerEvent<"UserMigration_ForgotPassword">;

/**
 * @see https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-lambda-migrate-user.html
 */
export type UserMigrationTriggerEvent =
    | UserMigrationAuthenticationTriggerEvent
    | UserMigrationForgotPasswordTriggerEvent;

export type UserMigrationTriggerHandler = Handler<UserMigrationTriggerEvent>;

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/cognito-user-pool-trigger/verify-auth-challenge-response.d.ts

```typescript
import { Handler } from "../../handler";
import { BaseTriggerEvent, StringMap } from "./_common";

/**
 * @see https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-lambda-verify-auth-challenge-response.html
 */
export interface VerifyAuthChallengeResponseTriggerEvent
    extends BaseTriggerEvent<"VerifyAuthChallengeResponse_Authentication">
{
    request: {
        userAttributes: StringMap;
        privateChallengeParameters: StringMap;
        challengeAnswer: string;
        userNotFound?: boolean | undefined;
        clientMetadata?: StringMap | undefined;
    };
    response: {
        answerCorrect: boolean;
    };
}

export type VerifyAuthChallengeResponseTriggerHandler = Handler<VerifyAuthChallengeResponseTriggerEvent>;

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/connect-contact-flow.d.ts

```typescript
import { Callback, Handler } from "../handler";

export type ConnectContactFlowHandler = Handler<ConnectContactFlowEvent, ConnectContactFlowResult>;
export type ConnectContactFlowCallback = Callback<ConnectContactFlowResult>;

// Connect
// https://docs.aws.amazon.com/connect/latest/adminguide/connect-lambda-functions.html
export interface ConnectContactFlowEvent {
    Details: {
        ContactData: {
            Attributes: { [key: string]: string };
            Channel: ConnectContactFlowChannel;
            ContactId: string;
            CustomerEndpoint: ConnectContactFlowEndpoint | null;
            InitialContactId: string;
            InitiationMethod: ConnectContactFlowInitiationMethod;
            InstanceARN: string;
            PreviousContactId: string;
            Queue: ConnectContactFlowQueue | null;
            SystemEndpoint: ConnectContactFlowEndpoint | null;
            MediaStreams: {
                Customer: {
                    Audio: CustomerAudio;
                };
            };
        };
        Parameters: { [key: string]: string };
    };
    Name: "ContactFlowEvent";
}

export type ConnectContactFlowChannel = "VOICE" | "CHAT" | "EMAIL";

export type ConnectContactFlowInitiationMethod = "INBOUND" | "OUTBOUND" | "TRANSFER" | "CALLBACK" | "API";

export interface ConnectContactFlowEndpoint {
    Address: string;
    Type: "TELEPHONE_NUMBER";
}

export interface ConnectContactFlowQueue {
    ARN: string;
    Name: string;
}

export interface ConnectContactFlowResult {
    [key: string]: string | null;
}

export type CustomerAudio =
    | null // If Media Streaming has never been started.
    | StartedCustomerAudio // If Media Streaming has been started, but not stopped.
    | (StartedCustomerAudio & StoppedCustomerAudio); // If Media Streaming has been started and stopped.

export interface StartedCustomerAudio {
    StartFragmentNumber: string;
    StartTimestamp: string;
    StreamARN: string;
}

export interface StoppedCustomerAudio {
    StopFragmentNumber: string;
    StopTimestamp: string;
}

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/dynamodb-stream.d.ts

```typescript
import { Handler } from "../handler";

// eslint-disable-next-line @typescript-eslint/no-invalid-void-type
export type DynamoDBStreamHandler = Handler<DynamoDBStreamEvent, DynamoDBBatchResponse | void>;

// eslint-disable-next-line @definitelytyped/strict-export-declare-modifiers, @definitelytyped/no-single-element-tuple-type
type Merge<T> = [{ [K in keyof T]: T[K] }][number];

// eslint-disable-next-line @definitelytyped/strict-export-declare-modifiers
type ExclusivePropertyUnion<T, P = keyof T> = P extends any
    ? Merge<{ [K in Extract<keyof T, P>]: T[K] } & { [K in Exclude<keyof T, P>]?: never }>
    : never;

// http://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_streams_AttributeValue.html
export type AttributeValue = ExclusivePropertyUnion<{
    B: string;
    BOOL: boolean;
    BS: string[];
    L: AttributeValue[];
    M: Record<string, AttributeValue>;
    N: string;
    NS: string[];
    NULL: boolean;
    S: string;
    SS: string[];
}>;

// http://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_streams_StreamRecord.html
export interface StreamRecord {
    ApproximateCreationDateTime?: number | undefined;
    Keys?: { [key: string]: AttributeValue } | undefined;
    NewImage?: { [key: string]: AttributeValue } | undefined;
    OldImage?: { [key: string]: AttributeValue } | undefined;
    SequenceNumber?: string | undefined;
    SizeBytes?: number | undefined;
    StreamViewType?: "KEYS_ONLY" | "NEW_IMAGE" | "OLD_IMAGE" | "NEW_AND_OLD_IMAGES" | undefined;
}

// http://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_streams_Record.html
export interface DynamoDBRecord {
    awsRegion?: string | undefined;
    dynamodb?: StreamRecord | undefined;
    eventID?: string | undefined;
    eventName?: "INSERT" | "MODIFY" | "REMOVE" | undefined;
    eventSource?: string | undefined;
    eventSourceARN?: string | undefined;
    eventVersion?: string | undefined;
    userIdentity?: any;
}

// http://docs.aws.amazon.com/lambda/latest/dg/eventsources.html#eventsources-ddb-update
export interface DynamoDBStreamEvent {
    Records: DynamoDBRecord[];
}

// https://docs.aws.amazon.com/lambda/latest/dg/with-ddb.html#services-ddb-batchfailurereporting
export interface DynamoDBBatchResponse {
    batchItemFailures: DynamoDBBatchItemFailure[];
}

export interface DynamoDBBatchItemFailure {
    itemIdentifier: string;
}

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/eventbridge.d.ts

```typescript
import { Handler } from "../handler";

export type EventBridgeHandler<TDetailType extends string, TDetail, TResult> = Handler<
    EventBridgeEvent<TDetailType, TDetail>,
    TResult
>;

export interface EventBridgeEvent<TDetailType extends string, TDetail> {
    id: string;
    version: string;
    account: string;
    time: string;
    region: string;
    resources: string[];
    source: string;
    "detail-type": TDetailType;
    detail: TDetail;
    "replay-name"?: string;
}

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/guard-duty-event-notification.d.ts

```typescript
import { EventBridgeEvent } from "./eventbridge";

/**
 * Guard Duty events
 * https://docs.aws.amazon.com/guardduty/latest/ug/monitor-with-eventbridge-s3-malware-protection.html
 */

export interface GuardDutyScanResultNotificationEvent
    extends
        EventBridgeEvent<"GuardDuty Malware Protection Object Scan Result", GuardDutyScanResultNotificationEventDetail>
{
    source: "aws.guardduty";
}

export interface GuardDutyScanResultNotificationEventDetail {
    schemaVersion: "1.0";
    scanStatus: "COMPLETED" | "SKIPPED" | "FAILED";
    resourceType: "S3_OBJECT";
    s3ObjectDetails: {
        bucketName: string;
        objectKey: string;
        eTag: string;
        versionId: string;
        s3Throttled: boolean;
    };
    scanResultDetails: {
        scanResultStatus: "NO_THREATS_FOUND" | "THREATS_FOUND" | "UNSUPPORTED" | "ACCESS_DENIED" | "FAILED";
        threats: GuardDutyThreatDetail[] | null;
    };
}

export interface GuardDutyThreatDetail {
    name: string;
}

export type GuardDutyNotificationEvent = GuardDutyScanResultNotificationEvent;

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/iot-authorizer.d.ts

```typescript
import { Handler } from "../handler";
import { PolicyDocument } from "./api-gateway-authorizer";

export type IoTProtocolType = "http" | "mqtt" | "tls";

export type IoTCustomAuthorizerHandler = Handler<IoTCustomAuthorizerEvent, IoTCustomAuthorizerResult>;

export interface IoTProtocolDataTLS {
    serverName: string; // The server name indication (SNI) host_name string.
}

export interface IoTProtocolDataHTTP {
    headers: Record<string, string>;
    queryString: string;
}

export interface IoTProtocolDataMQTT {
    username?: string;
    password?: string; // A base64-encoded string.
    clientId: string; // Included in the event only when the device sends the value.
}

export interface IoTCustomAuthorizerEvent {
    token?: string;
    signatureVerified: boolean; // Indicates whether the device gateway has validated the signature.
    protocols: IoTProtocolType[]; // Indicates which protocols to expect for the request.
    protocolData: {
        tls?: IoTProtocolDataTLS;
        http?: IoTProtocolDataHTTP;
        mqtt?: IoTProtocolDataMQTT;
    };
    connectionMetadata: {
        id: string; // The connection ID. You can use this for logging.
    };
}

/**
 * IoT CustomAuthorizer AuthResponse.PolicyDocument.
 * https://docs.aws.amazon.com/iot/latest/developerguide/config-custom-auth.html#custom-auth-lambda
 * https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements.html#Condition
 */
export interface IoTCustomAuthorizerResult {
    isAuthenticated: boolean; // A Boolean that determines whether client can connect.
    principalId: string; // A string that identifies the connection in logs.
    disconnectAfterInSeconds: number;
    refreshAfterInSeconds: number;
    policyDocuments: PolicyDocument[];
}

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/iot.d.ts

```typescript
import { Handler } from "../handler";

export type IoTHandler = Handler<IoTEvent, void>;

// IoT
// https://docs.aws.amazon.com/lambda/latest/dg/services-iot.html
// IoT payload is not restriced to JSON, but JSON is highly recommended. Types as string, number or array are possible to use.

export type IoTEvent<T = never> = string | number | T;

// PreProvisioningHook
// https://docs.aws.amazon.com/iot/latest/developerguide/pre-provisioning-hook.html
// When using AWS IoT fleet provisioning, you can set up a Lambda function to validate parameters passed from the device before allowing the device to be provisioned.
export type IoTPreProvisioningHookHandler = Handler<IoTPreProvisioningHookEvent, IoTPreProvisioningHookResult>;

export interface IoTPreProvisioningHookEvent {
    claimCertificateId: string;
    certificateId: string;
    certificatePem: string;
    templateArn: string;
    clientId: string;
    parameters: Record<string, string>;
}

export interface IoTPreProvisioningHookResult {
    allowProvisioning: boolean;
    parameterOverrides: Record<string, string>;
}

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/kinesis-firehose-transformation.d.ts

```typescript
import { Callback, Handler } from "../handler";

export type FirehoseTransformationHandler = Handler<FirehoseTransformationEvent, FirehoseTransformationResult>;
export type FirehoseTransformationCallback = Callback<FirehoseTransformationResult>;

// Kinesis Data Firehose Event
// https://docs.aws.amazon.com/lambda/latest/dg/eventsources.html#eventsources-kinesis-firehose
// https://docs.aws.amazon.com/firehose/latest/dev/data-transformation.html
// https://aws.amazon.com/blogs/compute/amazon-kinesis-firehose-data-transformation-with-aws-lambda/
// Examples in the lambda blueprints
export interface FirehoseTransformationEvent {
    invocationId: string;
    deliveryStreamArn: string;
    sourceKinesisStreamArn?: string | undefined;
    region: string;
    records: FirehoseTransformationEventRecord[];
}

export interface FirehoseTransformationEventRecord {
    recordId: string;
    approximateArrivalTimestamp: number;
    /** Base64 encoded */
    data: string;
    kinesisRecordMetadata?: FirehoseRecordMetadata | undefined;
}

export interface FirehoseRecordMetadata {
    shardId: string;
    partitionKey: string;
    approximateArrivalTimestamp: number;
    sequenceNumber: string;
    subsequenceNumber: string;
}

export type FirehoseRecordTransformationStatus = "Ok" | "Dropped" | "ProcessingFailed";

export interface FirehoseTransformationMetadata {
    partitionKeys: { [name: string]: string };
}

export interface FirehoseTransformationResultRecord {
    recordId: string;
    result: FirehoseRecordTransformationStatus;
    /** Encode in Base64 */
    data?: string;
    metadata?: FirehoseTransformationMetadata;
}

export interface FirehoseTransformationResult {
    records: FirehoseTransformationResultRecord[];
}

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/kinesis-stream.d.ts

```typescript
import { Handler } from "../handler";

// eslint-disable-next-line @typescript-eslint/no-invalid-void-type
export type KinesisStreamHandler = Handler<KinesisStreamEvent, KinesisStreamBatchResponse | void>;

export type KinesisStreamTumblingWindowHandler = Handler<
    KinesisStreamTumblingWindowEvent,
    // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
    KinesisStreamStateResponse | void
>;

// Kinesis Streams
// https://docs.aws.amazon.com/lambda/latest/dg/eventsources.html#eventsources-kinesis-streams
export interface KinesisStreamRecordPayload {
    approximateArrivalTimestamp: number;
    data: string;
    kinesisSchemaVersion: string;
    partitionKey: string;
    sequenceNumber: string;
}

export interface KinesisStreamRecord {
    awsRegion: string;
    eventID: string;
    eventName: string;
    eventSource: string;
    eventSourceARN: string;
    eventVersion: string;
    invokeIdentityArn: string;
    kinesis: KinesisStreamRecordPayload;
}

export interface KinesisStreamEvent {
    Records: KinesisStreamRecord[];
}

// https://docs.aws.amazon.com/lambda/latest/dg/with-kinesis.html#services-kinesis-windows
export interface KinesisStreamTumblingWindowEvent extends KinesisStreamEvent {
    window: { start: string; end: string };
    state?: { [key: string]: any };
    isFinalInvokeForWindow: boolean;
    isWindowTerminatedEarly: boolean;
}

export interface KinesisStreamStateResponse extends Partial<KinesisStreamBatchResponse> {
    state: { [key: string]: any };
}

// https://docs.aws.amazon.com/lambda/latest/dg/with-kinesis.html#services-kinesis-batchfailurereporting
export interface KinesisStreamBatchResponse {
    batchItemFailures: KinesisStreamBatchItemFailure[];
}

export interface KinesisStreamBatchItemFailure {
    itemIdentifier: string;
}

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/lambda-function-url.d.ts

```typescript
import { Handler } from "../handler";
import {
    APIGatewayEventRequestContextIAMAuthorizer,
    APIGatewayEventRequestContextV2WithAuthorizer,
    APIGatewayProxyCallbackV2,
    APIGatewayProxyEventV2,
    APIGatewayProxyEventV2WithRequestContext,
    APIGatewayProxyResultV2,
} from "./api-gateway-proxy";

/**
 * Default Lambda Function URL event with no Authorizer
 */
export type LambdaFunctionURLEvent = APIGatewayProxyEventV2;

/**
 * Works with Lambda Function URL format which is currently the same as HTTP API integration Payload Format version 2.0
 * @see - https://docs.aws.amazon.com/lambda/latest/dg/urls-invocation.html#urls-payloads
 */
export type LambdaFunctionURLResult<T = never> = APIGatewayProxyResultV2<T>;

/**
 * Works with Lambda Function URL format which is currently the same as HTTP API integration Payload Format version 2.0
 * @see - https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-develop-integrations-lambda.html
 */
export type LambdaFunctionURLCallback = APIGatewayProxyCallbackV2;

/**
 * Works with Lambda Function URL format which is currently the same as HTTP API integration Payload Format version 2.0
 * @see - https://docs.aws.amazon.com/lambda/latest/dg/urls-invocation.html#urls-payloads
 */
export type LambdaFunctionURLHandler<T = never> = Handler<LambdaFunctionURLEvent, LambdaFunctionURLResult<T>>;

export type LambdaFunctionURLEventWithIAMAuthorizer = APIGatewayProxyEventV2WithRequestContext<
    APIGatewayEventRequestContextV2WithAuthorizer<APIGatewayEventRequestContextIAMAuthorizer>
>;

/**
 * Works with Lambda Function URL format which is currently the same as HTTP API integration Payload Format version 2.0
 * @see - https://docs.aws.amazon.com/lambda/latest/dg/urls-invocation.html#urls-payloads
 */
export type LambdaFunctionURLHandlerWithIAMAuthorizer<T = never> = Handler<
    LambdaFunctionURLEventWithIAMAuthorizer,
    LambdaFunctionURLResult<T>
>;

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/lex-v2.d.ts

```typescript
import { Callback, Handler } from "../handler";

export type LexV2Handler = Handler<LexV2Event, LexV2Result>;
export type LexV2Callback = Callback<LexV2Result>;

// Lex V2
// https://docs.aws.amazon.com/lexv2/latest/dg/lambda.html
export interface LexV2Event {
    messageVersion: string;
    invocationSource: "DialogCodeHook" | "FulfillmentCodeHook";
    inputMode: "DTMF" | "Speech" | "Text";
    responseContentType: string;
    sessionId: string;
    inputTranscript: string;
    bot: LexV2Bot;
    interpretations: LexV2Interpretation[];
    proposedNextState: {
        dialogAction: LexV2DialogAction;
        intent: LexV2Intent;
    };
    requestAttributes?: Record<string, string>;
    sessionState: LexV2SessionState;
    transcriptions: LexV2Transcription[];
}

export interface LexV2Bot {
    id: string;
    name: string;
    aliasId: string;
    aliasName: string;
    localeId: string;
    version: string; // 'DRAFT' | `${number}`
}

export interface LexV2Interpretation {
    intent: LexV2Intent;
    nluConfidence?: number;
    sentimentResponse?: LexV2SentimentResponse;
}

export interface LexV2Intent {
    confirmationState: "Confirmed" | "Denied" | "None";
    name: string;
    slots: LexV2Slots;
    state: LexV2IntentState;
    kendraResponse?: any;
}

export type LexV2IntentState =
    | "Failed"
    | "Fulfilled"
    | "FulfillmentInProgress"
    | "InProgress"
    | "ReadyForFulfillment"
    | "Waiting";

export interface LexV2SentimentResponse {
    sentiment: string;
    sentimentScore: LexV2SentimentScore;
}

export interface LexV2SentimentScore {
    mixed: number;
    negative: number;
    neutral: number;
    positive: number;
}

export interface LexV2SessionState {
    activeContexts?: LexV2ActiveContext[];
    sessionAttributes?: Record<string, string>;
    dialogAction?: LexV2DialogAction;
    intent: LexV2Intent;
    originatingRequestId: string;
}

export interface LexV2ActiveContext {
    name: string;
    contextAttributes: Record<string, string>;
    timeToLive: {
        timeToLiveInSeconds: number;
        turnsToLive: number;
    };
}

export type LevV2DialogActionWithoutSlot =
    | { type: "Close" }
    | { type: "ConfirmIntent" }
    | { type: "Delegate" }
    | { type: "ElicitIntent" };

export type LexV2DialogAction =
    | (LevV2DialogActionWithoutSlot & { slotToElicit?: never })
    | { type: "ElicitSlot"; slotToElicit: string };

export type LexV2ResultDialogAction =
    | (LevV2DialogActionWithoutSlot & { slotToElicit?: never })
    | { type: "ElicitSlot"; slotToElicit: string; slotElicitationStyle?: "Default" | "SpellByLetter" | "SpellByWord" };

export interface LexV2Result {
    sessionState: {
        sessionAttributes?: Record<string, string>;
        dialogAction: LexV2ResultDialogAction;
        intent?: {
            name?: string;
            state: LexV2IntentState;
            slots?: LexV2Slots;
        };
    };
    messages?: LexV2Message[];
}

export type LexV2Message = LexV2ContentMessage | LexV2ImageResponseCardMessage;

export interface LexV2ContentMessage {
    contentType: "CustomPayload" | "PlainText" | "SSML";
    content: string;
}

export interface LexV2ImageResponseCardMessage {
    contentType: "ImageResponseCard";
    imageResponseCard: LexV2ImageResponseCard;
}

export interface LexV2ImageResponseCard {
    title: string;
    subtitle?: string;
    imageUrl?: string;
    buttons?: LexV2ImageResponseCardButton[];
}

export interface LexV2ImageResponseCardButton {
    text: string;
    value: string;
}

export type LexV2Slot = LexV2ScalarSlotValue | LexV2ListSlotValue;
export type LexV2Slots = Record<string, LexV2Slot | null>;

export interface LexV2ScalarSlotValue {
    shape: "Scalar";
    value: LexV2SlotValue;
}

export interface LexV2ListSlotValue {
    shape: "List";
    value: LexV2SlotValue;
    values: LexV2ScalarSlotValue[];
}

export interface LexV2SlotValue {
    interpretedValue?: string;
    originalValue: string;
    resolvedValues: string[];
}

export interface LexV2Transcription {
    transcription: string;
    transcriptionConfidence: number;
    resolvedContext: {
        intent: string;
    };
    resolvedSlots: LexV2Slots;
}

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/lex.d.ts

```typescript
import { Callback, Handler } from "../handler";

export type LexHandler = Handler<LexEvent, LexResult>;
export type LexCallback = Callback<LexResult>;

export interface LexEventSlots {
    [name: string]: string | undefined | null;
}

export interface LexEventSessionAttributes {
    [key: string]: string | undefined;
}

export interface LexEventRequestAttributes {
    [key: string]: string | undefined;
}

// Lex
// https://docs.aws.amazon.com/lambda/latest/dg/invoking-lambda-function.html#supported-event-source-lex
export interface LexEvent {
    currentIntent: {
        name: string;
        slots: LexEventSlots;
        slotDetails: LexSlotDetails;
        confirmationStatus: "None" | "Confirmed" | "Denied";
    };
    bot: {
        name: string;
        alias: string;
        version: string;
    };
    userId: string;
    inputTranscript: string;
    invocationSource: "DialogCodeHook" | "FulfillmentCodeHook";
    outputDialogMode: "Text" | "Voice";
    messageVersion: "1.0";
    sessionAttributes: LexEventSessionAttributes;
    requestAttributes: LexEventRequestAttributes | null;
}

export interface LexSlotResolution {
    value: string;
}

export interface LexSlotDetail {
    // "at least 1 but no more than 5 items"
    resolutions: [LexSlotResolution, LexSlotResolution?, LexSlotResolution?, LexSlotResolution?, LexSlotResolution?];
    originalValue: string;
}

export interface LexSlotDetails {
    [name: string]: LexSlotDetail;
}

export interface LexGenericAttachment {
    title: string;
    subTitle: string;
    imageUrl: string;
    attachmentLinkUrl: string;
    buttons: Array<{
        text: string;
        value: string;
    }>;
}

export interface LexDialogActionBase {
    type: "Close" | "ElicitIntent" | "ElicitSlot" | "ConfirmIntent";
    message?:
        | {
            contentType: "PlainText" | "SSML" | "CustomPayload";
            content: string;
        }
        | undefined;
    responseCard?:
        | {
            version: number;
            contentType: "application/vnd.amazonaws.card.generic";
            genericAttachments: LexGenericAttachment[];
        }
        | undefined;
}

export interface LexDialogActionClose extends LexDialogActionBase {
    type: "Close";
    fulfillmentState: "Fulfilled" | "Failed";
}

export interface LexDialogActionElicitIntent extends LexDialogActionBase {
    type: "ElicitIntent";
}

export interface LexDialogActionElicitSlot extends LexDialogActionBase {
    type: "ElicitSlot";
    intentName: string;
    slots: { [name: string]: string | null };
    slotToElicit: string;
}

export interface LexDialogActionConfirmIntent extends LexDialogActionBase {
    type: "ConfirmIntent";
    intentName: string;
    slots: { [name: string]: string | null };
}

export interface LexDialogActionDelegate {
    type: "Delegate";
    slots: { [name: string]: string | null };
}

export type LexDialogAction =
    | LexDialogActionClose
    | LexDialogActionElicitIntent
    | LexDialogActionElicitSlot
    | LexDialogActionConfirmIntent
    | LexDialogActionDelegate;

export interface LexResult {
    sessionAttributes?: { [key: string]: string } | undefined;
    dialogAction: LexDialogAction;
}

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/msk.d.ts

```typescript
import { Handler } from "../handler";

export type MSKHandler = Handler<MSKEvent, void>;

export interface MSKRecordHeader {
    [headerKey: string]: number[];
}

export interface MSKRecord {
    topic: string;
    partition: number;
    offset: number;
    timestamp: number;
    timestampType: "CREATE_TIME" | "LOG_APPEND_TIME";
    key: string;
    value: string;
    headers: MSKRecordHeader[];
}

// https://docs.aws.amazon.com/lambda/latest/dg/with-msk.html
export interface MSKEvent {
    eventSource: "aws:kafka";
    eventSourceArn: string;
    bootstrapServers: string;
    records: {
        [topic: string]: MSKRecord[];
    };
}

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/s3-batch.d.ts

```typescript
import { Callback, Handler } from "../handler";

/**
 * S3 Batch Operations event
 * https://docs.aws.amazon.com/AmazonS3/latest/dev/batch-ops-invoke-lambda.html
 */
export type S3BatchHandler = Handler<S3BatchEvent, S3BatchResult>;
export type S3BatchCallback = Callback<S3BatchResult>;

export interface S3BatchEvent {
    invocationSchemaVersion: string;
    invocationId: string;
    job: S3BatchEventJob;
    tasks: S3BatchEventTask[];
}

export interface S3BatchEventJob {
    id: string;
}

export interface S3BatchEventTask {
    taskId: string;
    s3Key: string;
    s3VersionId: string | null;
    s3BucketArn: string;
}

export interface S3BatchResult {
    invocationSchemaVersion: string;
    treatMissingKeysAs: S3BatchResultResultCode;
    invocationId: string;
    results: S3BatchResultResult[];
}

export type S3BatchResultResultCode = "Succeeded" | "TemporaryFailure" | "PermanentFailure";

export interface S3BatchResultResult {
    taskId: string;
    resultCode: S3BatchResultResultCode;
    resultString: string;
}

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/s3-event-notification.d.ts

```typescript
import { Handler } from "../handler";
import { EventBridgeEvent } from "./eventbridge";

export interface S3ObjectAccessTierChangedNotificationEventDetail {
    version: "0";
    bucket: {
        name: string;
    };
    object: {
        key: string;
        size: number;
        etag: string;
        "version-id": string;
    };
    "request-id": string;
    requester: string;
    "destination-access-tier": "ARCHIVE_ACCESS" | "DEEP_ARCHIVE_ACCESS"; // https://docs.aws.amazon.com/AmazonS3/latest/API/API_Tiering.html
}

export interface S3ObjectACLUpdatedNotificationEventDetail {
    version: "0";
    bucket: {
        name: string;
    };
    object: {
        key: string;
        etag: string;
        "version-id": string;
    };
    "request-id": string;
    requester: string;
    "source-ip-address": string;
}

export interface S3ObjectCreatedNotificationEventDetail {
    version: "0";
    bucket: {
        name: string;
    };
    object: {
        key: string;
        size: number;
        etag: string;
        "version-id": string;
        sequencer: string;
    };
    "request-id": string;
    requester: string;
    "source-ip-address": string;
    reason: "PutObject" | "POST Object" | "CopyObject" | "CompleteMultipartUpload";
}

export interface S3ObjectDeletedNotificationEventLifecycleExpirationDetail {
    version: "0";
    bucket: {
        name: string;
    };
    object: {
        key: string;
        etag: string;
        "version-id": string;
        sequencer: string;
    };
    "request-id": string;
    requester: string;
    reason: "Lifecycle Expiration";
    "deletion-type": "Permanently Deleted" | "Delete Marker Created";
}

export interface S3ObjectDeletedNotificationEventDeleteObjectDetail {
    version: "0";
    bucket: {
        name: string;
    };
    object: {
        key: string;
        etag: string;
        "version-id": string;
        sequencer: string;
    };
    "request-id": string;
    requester: string;
    "source-ip-address": string;
    reason: "DeleteObject";
    "deletion-type": "Permanently Deleted" | "Delete Marker Created";
}

export type S3ObjectDeletedNotificationEventDetail =
    | S3ObjectDeletedNotificationEventLifecycleExpirationDetail
    | S3ObjectDeletedNotificationEventDeleteObjectDetail;

export interface S3ObjectRestoreCompletedNotificationEventDetail {
    version: "0";
    bucket: {
        name: string;
    };
    object: {
        key: string;
        size: number;
        "version-id": string;
        etag: string;
    };
    "request-id": string;
    requester: "s3.amazonaws.com";
    "restore-expiry-time": string;
    "source-storage-class":
        | "STANDARD"
        | "REDUCED_REDUNDANCY"
        | "STANDARD_IA"
        | "ONEZONE_IA"
        | "INTELLIGENT_TIERING"
        | "GLACIER"
        | "DEEP_ARCHIVE"
        | "OUTPOSTS"
        | "GLACIER_IR"; // https://docs.aws.amazon.com/AmazonS3/latest/API/API_PutObject.html#API_PutObject_RequestSyntax
}

export interface S3ObjectRestoreExpiredNotificationEventDetail {
    version: "0";
    bucket: {
        name: string;
    };
    object: {
        key: string;
        "version-id": string;
        etag: string;
    };
    "request-id": string;
    requester: "s3.amazonaws.com";
}

export interface S3ObjectRestoreInitiatedNotificationEventDetail {
    version: "0";
    bucket: {
        name: string;
    };
    object: {
        key: string;
        size: number;
        "version-id": string;
        etag: string;
    };
    "request-id": string;
    requester: string;
    "source-ip-address": string;
    "source-storage-class":
        | "STANDARD"
        | "REDUCED_REDUNDANCY"
        | "STANDARD_IA"
        | "ONEZONE_IA"
        | "INTELLIGENT_TIERING"
        | "GLACIER"
        | "DEEP_ARCHIVE"
        | "OUTPOSTS"
        | "GLACIER_IR"; // https://docs.aws.amazon.com/AmazonS3/latest/API/API_PutObject.html#API_PutObject_RequestSyntax
}

export interface S3ObjectStorageClassChangedNotificationEventDetail {
    version: "0";
    bucket: {
        name: string;
    };
    object: {
        key: string;
        size: number;
        "version-id": string;
        etag: string;
    };
    "request-id": string;
    requester: string;
    "destination-storage-class":
        | "STANDARD"
        | "REDUCED_REDUNDANCY"
        | "STANDARD_IA"
        | "ONEZONE_IA"
        | "INTELLIGENT_TIERING"
        | "GLACIER"
        | "DEEP_ARCHIVE"
        | "OUTPOSTS"
        | "GLACIER_IR"; // https://docs.aws.amazon.com/AmazonS3/latest/API/API_PutObject.html#API_PutObject_RequestSyntax
}

export interface S3ObjectTagsAddedNotificationEventDetail {
    version: "0";
    bucket: {
        name: string;
    };
    object: {
        key: string;
        "version-id": string;
        etag: string;
    };
    "request-id": string;
    requester: string;
    "source-ip-address": string;
}

export interface S3ObjectTagsDeletedNotificationEventDetail {
    version: "0";
    bucket: {
        name: string;
    };
    object: {
        key: string;
        "version-id": string;
        etag: string;
    };
    "request-id": string;
    requester: string;
    "source-ip-address": string;
}

export interface S3ObjectAccessTierChangedNotificationEvent
    extends EventBridgeEvent<"Object Access Tier Changed", S3ObjectAccessTierChangedNotificationEventDetail>
{
    source: "aws.s3";
}

export interface S3ObjectACLUpdatedNotificationEvent
    extends EventBridgeEvent<"Object ACL Updated", S3ObjectACLUpdatedNotificationEventDetail>
{
    source: "aws.s3";
}

export interface S3ObjectCreatedNotificationEvent
    extends EventBridgeEvent<"Object Created", S3ObjectCreatedNotificationEventDetail>
{
    source: "aws.s3";
}

export interface S3ObjectDeletedNotificationEvent
    extends EventBridgeEvent<"Object Deleted", S3ObjectDeletedNotificationEventDetail>
{
    source: "aws.s3";
}

export interface S3ObjectRestoreCompletedNotificationEvent
    extends EventBridgeEvent<"Object Restore Completed", S3ObjectRestoreCompletedNotificationEventDetail>
{
    source: "aws.s3";
}

export interface S3ObjectRestoreExpiredNotificationEvent
    extends EventBridgeEvent<"Object Restore Expired", S3ObjectRestoreExpiredNotificationEventDetail>
{
    source: "aws.s3";
}

export interface S3ObjectRestoreInitiatedNotificationEvent
    extends EventBridgeEvent<"Object Restore Initiated", S3ObjectRestoreInitiatedNotificationEventDetail>
{
    source: "aws.s3";
}

export interface S3ObjectStorageClassChangedNotificationEvent
    extends EventBridgeEvent<"Object Storage Class Changed", S3ObjectStorageClassChangedNotificationEventDetail>
{
    source: "aws.s3";
}

export interface S3ObjectTagsAddedNotificationEvent
    extends EventBridgeEvent<"Object Tags Added", S3ObjectTagsAddedNotificationEventDetail>
{
    source: "aws.s3";
}

export interface S3ObjectTagsDeletedNotificationEvent
    extends EventBridgeEvent<"Object Tags Deleted", S3ObjectTagsDeletedNotificationEventDetail>
{
    source: "aws.s3";
}

export type S3NotificationEvent =
    | S3ObjectAccessTierChangedNotificationEvent
    | S3ObjectACLUpdatedNotificationEvent
    | S3ObjectCreatedNotificationEvent
    | S3ObjectDeletedNotificationEvent
    | S3ObjectRestoreCompletedNotificationEvent
    | S3ObjectRestoreExpiredNotificationEvent
    | S3ObjectRestoreInitiatedNotificationEvent
    | S3ObjectStorageClassChangedNotificationEvent
    | S3ObjectTagsAddedNotificationEvent
    | S3ObjectTagsDeletedNotificationEvent;

export type S3NotificationEventBridgeHandler<EventType extends S3NotificationEvent = S3NotificationEvent> = Handler<
    EventBridgeEvent<EventType["detail-type"], EventType["detail"]> & {
        source: "aws.s3";
    },
    void
>;

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/s3.d.ts

```typescript
import { Handler } from "../handler";

export type S3Handler = Handler<S3Event, void>;

/**
 * S3Create event
 * https://docs.aws.amazon.com/AmazonS3/latest/dev/notification-content-structure.html
 */

export interface S3EventRecordGlacierRestoreEventData {
    lifecycleRestorationExpiryTime: string;
    lifecycleRestoreStorageClass: string;
}

export interface S3EventRecordGlacierEventData {
    restoreEventData: S3EventRecordGlacierRestoreEventData;
}

export interface S3EventRecord {
    eventVersion: string;
    eventSource: string;
    awsRegion: string;
    eventTime: string;
    eventName: string;
    userIdentity: {
        principalId: string;
    };
    requestParameters: {
        sourceIPAddress: string;
    };
    responseElements: {
        "x-amz-request-id": string;
        "x-amz-id-2": string;
    };
    s3: {
        s3SchemaVersion: string;
        configurationId: string;
        bucket: {
            name: string;
            ownerIdentity: {
                principalId: string;
            };
            arn: string;
        };
        object: {
            key: string;
            size: number;
            eTag: string;
            versionId?: string | undefined;
            sequencer: string;
        };
    };
    glacierEventData?: S3EventRecordGlacierEventData | undefined;
}

export interface S3Event {
    Records: S3EventRecord[];
}

export type S3CreateEvent = S3Event; // old name

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/secretsmanager.d.ts

```typescript
import { Handler } from "../handler";

export type SecretsManagerRotationHandler = Handler<SecretsManagerRotationEvent, void>;

export type SecretsManagerRotationEventStep = "createSecret" | "setSecret" | "testSecret" | "finishSecret";

/**
 * Secrets Manager Rotation event
 * https://docs.aws.amazon.com/secretsmanager/latest/userguide/rotating-secrets-lambda-function-overview.html
 */
export interface SecretsManagerRotationEvent {
    Step: SecretsManagerRotationEventStep;
    SecretId: string;
    ClientRequestToken: string;
}

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/self-managed-kafka.d.ts

```typescript
import { Handler } from "../handler";

export type SelfManagedKafkaHandler = Handler<SelfManagedKafkaEvent, void>;

export interface SelfManagedKafkaRecordHeader {
    [headerKey: string]: number[];
}

export interface SelfManagedKafkaRecord {
    topic: string;
    partition: number;
    offset: number;
    timestamp: number;
    timestampType: "CREATE_TIME" | "LOG_APPEND_TIME";
    key: string;
    value: string;
    headers: SelfManagedKafkaRecordHeader[];
}

// https://docs.aws.amazon.com/lambda/latest/dg/with-kafka.html
export interface SelfManagedKafkaEvent {
    eventSource: "SelfManagedKafka";
    bootstrapServers: string;
    records: {
        [topic: string]: SelfManagedKafkaRecord[];
    };
}

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/ses.d.ts

```typescript
import { Handler } from "../handler";

export type SESHandler = Handler<SESEvent, void>;

// SES event
export interface SESMailHeader {
    name: string;
    value: string;
}

export interface SESMailCommonHeaders {
    returnPath: string;
    from?: string[] | undefined;
    date: string;
    to?: string[] | undefined;
    cc?: string[] | undefined;
    bcc?: string[] | undefined;
    sender?: string[] | undefined;
    replyTo?: string[] | undefined;
    messageId: string;
    subject?: string | undefined;
}

export interface SESMail {
    timestamp: string;
    source: string;
    messageId: string;
    destination: string[];
    headersTruncated: boolean;
    headers: SESMailHeader[];
    commonHeaders: SESMailCommonHeaders;
}

export interface SESReceiptStatus {
    status: "PASS" | "FAIL" | "GRAY" | "PROCESSING_FAILED" | "DISABLED";
}

export interface SESReceiptS3Action {
    type: "S3";
    topicArn?: string | undefined;
    bucketName: string;
    objectKey: string;
}

export interface SESReceiptSnsAction {
    type: "SNS";
    topicArn: string;
}

export interface SESReceiptBounceAction {
    type: "Bounce";
    topicArn?: string | undefined;
    smtpReplyCode: string;
    statusCode: string;
    message: string;
    sender: string;
}

export interface SESReceiptLambdaAction {
    type: "Lambda";
    topicArn?: string | undefined;
    functionArn: string;
    invocationType: string;
}

export interface SESReceiptStopAction {
    type: "Stop";
    topicArn?: string | undefined;
}

export interface SESReceiptWorkMailAction {
    type: "WorkMail";
    topicArn?: string | undefined;
    organizationArn: string;
}

export interface SESReceipt {
    timestamp: string;
    processingTimeMillis: number;
    recipients: string[];
    spamVerdict: SESReceiptStatus;
    virusVerdict: SESReceiptStatus;
    spfVerdict: SESReceiptStatus;
    dkimVerdict: SESReceiptStatus;
    dmarcVerdict: SESReceiptStatus;
    dmarcPolicy?: "none" | "quarantine" | "reject" | undefined;
    action:
        | SESReceiptS3Action
        | SESReceiptSnsAction
        | SESReceiptBounceAction
        | SESReceiptLambdaAction
        | SESReceiptStopAction
        | SESReceiptWorkMailAction;
}

export interface SESMessage {
    mail: SESMail;
    receipt: SESReceipt;
}

export interface SESEventRecord {
    eventSource: string;
    eventVersion: string;
    ses: SESMessage;
}

export interface SESEvent {
    Records: SESEventRecord[];
}

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/sns.d.ts

```typescript
import { Handler } from "../handler";

export type SNSHandler = Handler<SNSEvent, void>;

// SNS "event"
export interface SNSMessageAttribute {
    Type: string;
    Value: string;
}

export interface SNSMessageAttributes {
    [name: string]: SNSMessageAttribute;
}

export interface SNSMessage {
    SignatureVersion: string;
    Timestamp: string;
    Signature: string;
    SigningCertUrl: string; // Not SigningCertURL; see https://github.com/DefinitelyTyped/DefinitelyTyped/pull/73817#issuecomment-3367340170
    MessageId: string;
    Message: string;
    MessageAttributes: SNSMessageAttributes;
    Type: string;
    UnsubscribeUrl: string; // Not UnsubscribeURL; see https://github.com/DefinitelyTyped/DefinitelyTyped/pull/73817#issuecomment-3367340170
    TopicArn: string;
    Subject?: string;
    Token?: string;
}

export interface SNSEventRecord {
    EventVersion: string;
    EventSubscriptionArn: string;
    EventSource: string;
    Sns: SNSMessage;
}

export interface SNSEvent {
    Records: SNSEventRecord[];
}

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/sqs.d.ts

```typescript
import { Handler } from "../handler";

// eslint-disable-next-line @typescript-eslint/no-invalid-void-type
export type SQSHandler = Handler<SQSEvent, SQSBatchResponse | void>;

// SQS
// https://docs.aws.amazon.com/lambda/latest/dg/invoking-lambda-function.html#supported-event-source-sqs
export interface SQSRecord {
    messageId: string;
    receiptHandle: string;
    body: string;
    attributes: SQSRecordAttributes;
    messageAttributes: SQSMessageAttributes;
    md5OfBody: string;
    md5OfMessageAttributes?: string;
    eventSource: string;
    eventSourceARN: string;
    awsRegion: string;
}

export interface SQSEvent {
    Records: SQSRecord[];
}

export interface SQSRecordAttributes {
    AWSTraceHeader?: string | undefined;
    ApproximateReceiveCount: string;
    SentTimestamp: string;
    SenderId: string;
    ApproximateFirstReceiveTimestamp: string;
    SequenceNumber?: string | undefined;
    MessageGroupId?: string | undefined;
    MessageDeduplicationId?: string | undefined;
    DeadLetterQueueSourceArn?: string | undefined; // Undocumented, but used by AWS to support their re-drive functionality in the console
}

export type SQSMessageAttributeDataType = "String" | "Number" | "Binary" | string;

export interface SQSMessageAttribute {
    stringValue?: string | undefined;
    binaryValue?: string | undefined;
    stringListValues?: string[] | undefined; // Not implemented. Reserved for future use.
    binaryListValues?: string[] | undefined; // Not implemented. Reserved for future use.
    dataType: SQSMessageAttributeDataType;
}

export interface SQSMessageAttributes {
    [name: string]: SQSMessageAttribute;
}

// https://docs.aws.amazon.com/lambda/latest/dg/with-sqs.html#services-sqs-batchfailurereporting
export interface SQSBatchResponse {
    batchItemFailures: SQSBatchItemFailure[];
}

export interface SQSBatchItemFailure {
    itemIdentifier: string;
}

```

## ./lib/lambda/node_modules/@types/aws-lambda/trigger/transfer-family-authorizer.d.ts

```typescript
import { Handler } from "../handler";

/**
 * Use this only if you want to use callbacks. AWS [recommends against](https://docs.aws.amazon.com/lambda/latest/dg/nodejs-handler.html) using those,
 * so you might want to use async/await instead, like this:
 *
 * ```typescript
 * const handler = async (event: TransferFamilyAuthorizerEvent): Promise<TransferFamilyAuthorizerResult> => {
 *     ... add your logic here
 * }
 * ```
 */
export type TransferFamilyAuthorizerHandler = Handler<TransferFamilyAuthorizerEvent, TransferFamilyAuthorizerResult>;

/**
 * Transfer Family Authorizer Event. This is the event that will be passed to the Lambda function.
 * Event message structure can be found here: https://docs.aws.amazon.com/transfer/latest/userguide/custom-lambda-idp.html
 * While the documentation is not explicit, for key based auth, password will be undefined
 */
export interface TransferFamilyAuthorizerEvent {
    username: string;
    password?: string;
    protocol: "SFTP" | "FTP" | "FTPS";
    serverId: string;
    sourceIp: string;
}

/**
 * The values that Transfer Family accepts for Lambda functions that are used for custom identity providers.
 * For some examples, see https://docs.aws.amazon.com/transfer/latest/userguide/custom-lambda-idp.html#lambda-auth-examples
 */
export interface TransferFamilyAuthorizerResult {
    /**
     * [**Required if authentication was successful. The user is authenticated if and only if the Role field is not blank**]
     *
     * Specifies the Amazon Resource Name (ARN) of the IAM role that controls your users' access to your Amazon S3 bucket or Amazon EFS file system.
     * The policies attached to this role determine the level of access that you want to provide your users when transferring files into and out of your Amazon S3 or Amazon EFS file system.
     * The IAM role should also contain a trust relationship that allows the server to access your resources when servicing your users' transfer requests.
     *
     * For details on establishing a trust relationship, see [To establish a trust relationship](https://docs.aws.amazon.com/transfer/latest/userguide/requirements-roles.html#establish-trust-transfer).
     */
    Role?: string;

    /**
     * [**Required for Amazon EFS backing storage**]
     *
     * The full POSIX identity, including user ID (`Uid`), group ID (`Gid`), and any secondary group IDs (`SecondaryGids`), that controls your users' access to your Amazon EFS file systems.
     * The POSIX permissions that are set on files and directories in your file system determine the level of access your users get when transferring files into and out of your Amazon EFS file systems.
     */
    PosixProfile?: {
        /**
         * User ID (UID) for the POSIX profile.
         */
        Uid: number;
        /**
         * Group ID (GID) for the POSIX profile.
         */
        Gid: number;
        /**
         * Secondary group IDs for the POSIX profile, if any.
         */
        SecondaryGids?: number[];
    } | undefined;

    /**
     * [**Optional**]
     *
     * A list of SSH public key values that are valid for this user.
     * An empty list implies that this is not a valid login.
     * Must not be returned during password authentication.
     */
    PublicKeys?: string[] | undefined;

    /**
     * [**Optional**]
     *
     * A session policy for your user so that you can use the same IAM role across multiple users.
     * This policy scopes down user access to portions of their Amazon S3 bucket.
     */
    Policy?: string | undefined;

    /**
     * [**Optional**]
     *
     * The type of landing directory (folder) that you want your users' home directory to be when they log in to the server.
     *
     * - If you set it to `PATH`, the user sees the absolute Amazon S3 bucket or Amazon EFS paths as is in their file transfer protocol clients.
     * - If you set it to `LOGICAL`, you must provide mappings in the `HomeDirectoryDetails` parameter to make Amazon S3 or Amazon EFS paths visible to your users.
     */
    HomeDirectoryType?: "PATH" | "LOGICAL" | undefined;

    /**
     * [**Required if `HomeDirectoryType` has a value of `LOGICAL`**]
     *
     * Logical directory mappings that specify which Amazon S3 or Amazon EFS paths and keys should be visible to your user and how you want to make them visible.
     * You must specify the Entry and Target pair, where Entry shows how the path is made visible and Target is the actual Amazon S3 or Amazon EFS path.
     *
     * **Note**: `HomeDirectoryDetails` is a string representation of a JSON map.
     * This is in contrast to `PosixProfile`, which is an actual JSON map object, and `PublicKeys` which is a JSON array of strings.
     * See the [code examples](https://docs.aws.amazon.com/transfer/latest/userguide/custom-lambda-idp.html#lambda-auth-examples).
     */
    HomeDirectoryDetails?: string | undefined;

    /**
     * [**Optional**]
     *
     * The landing directory for a user when they log in to the server using the client.
     */
    HomeDirectory?: string | undefined;
}

```

## ./lib/lambda/node_modules/@types/node/assert.d.ts

```typescript
/**
 * The `node:assert` module provides a set of assertion functions for verifying
 * invariants.
 * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/assert.js)
 */
declare module "assert" {
    /**
     * An alias of {@link ok}.
     * @since v0.5.9
     * @param value The input that is checked for being truthy.
     */
    function assert(value: unknown, message?: string | Error): asserts value;
    namespace assert {
        type AssertMethodNames =
            | "deepEqual"
            | "deepStrictEqual"
            | "doesNotMatch"
            | "doesNotReject"
            | "doesNotThrow"
            | "equal"
            | "fail"
            | "ifError"
            | "match"
            | "notDeepEqual"
            | "notDeepStrictEqual"
            | "notEqual"
            | "notStrictEqual"
            | "ok"
            | "partialDeepStrictEqual"
            | "rejects"
            | "strictEqual"
            | "throws";
        /**
         * Indicates the failure of an assertion. All errors thrown by the `node:assert` module will be instances of the `AssertionError` class.
         */
        class AssertionError extends Error {
            /**
             * Set to the `actual` argument for methods such as {@link assert.strictEqual()}.
             */
            actual: unknown;
            /**
             * Set to the `expected` argument for methods such as {@link assert.strictEqual()}.
             */
            expected: unknown;
            /**
             * Set to the passed in operator value.
             */
            operator: string;
            /**
             * Indicates if the message was auto-generated (`true`) or not.
             */
            generatedMessage: boolean;
            /**
             * Value is always `ERR_ASSERTION` to show that the error is an assertion error.
             */
            code: "ERR_ASSERTION";
            constructor(options?: {
                /** If provided, the error message is set to this value. */
                message?: string | undefined;
                /** The `actual` property on the error instance. */
                actual?: unknown | undefined;
                /** The `expected` property on the error instance. */
                expected?: unknown | undefined;
                /** The `operator` property on the error instance. */
                operator?: string | undefined;
                /** If provided, the generated stack trace omits frames before this function. */
                // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
                stackStartFn?: Function | undefined;
            });
        }
        /**
         * This feature is deprecated and will be removed in a future version.
         * Please consider using alternatives such as the `mock` helper function.
         * @since v14.2.0, v12.19.0
         * @deprecated Deprecated
         */
        class CallTracker {
            /**
             * The wrapper function is expected to be called exactly `exact` times. If the
             * function has not been called exactly `exact` times when `tracker.verify()` is called, then `tracker.verify()` will throw an
             * error.
             *
             * ```js
             * import assert from 'node:assert';
             *
             * // Creates call tracker.
             * const tracker = new assert.CallTracker();
             *
             * function func() {}
             *
             * // Returns a function that wraps func() that must be called exact times
             * // before tracker.verify().
             * const callsfunc = tracker.calls(func);
             * ```
             * @since v14.2.0, v12.19.0
             * @param [fn='A no-op function']
             * @param [exact=1]
             * @return A function that wraps `fn`.
             */
            calls(exact?: number): () => void;
            calls<Func extends (...args: any[]) => any>(fn?: Func, exact?: number): Func;
            /**
             * Example:
             *
             * ```js
             * import assert from 'node:assert';
             *
             * const tracker = new assert.CallTracker();
             *
             * function func() {}
             * const callsfunc = tracker.calls(func);
             * callsfunc(1, 2, 3);
             *
             * assert.deepStrictEqual(tracker.getCalls(callsfunc),
             *                        [{ thisArg: undefined, arguments: [1, 2, 3] }]);
             * ```
             * @since v18.8.0, v16.18.0
             * @return An array with all the calls to a tracked function.
             */
            getCalls(fn: Function): CallTrackerCall[];
            /**
             * The arrays contains information about the expected and actual number of calls of
             * the functions that have not been called the expected number of times.
             *
             * ```js
             * import assert from 'node:assert';
             *
             * // Creates call tracker.
             * const tracker = new assert.CallTracker();
             *
             * function func() {}
             *
             * // Returns a function that wraps func() that must be called exact times
             * // before tracker.verify().
             * const callsfunc = tracker.calls(func, 2);
             *
             * // Returns an array containing information on callsfunc()
             * console.log(tracker.report());
             * // [
             * //  {
             * //    message: 'Expected the func function to be executed 2 time(s) but was
             * //    executed 0 time(s).',
             * //    actual: 0,
             * //    expected: 2,
             * //    operator: 'func',
             * //    stack: stack trace
             * //  }
             * // ]
             * ```
             * @since v14.2.0, v12.19.0
             * @return An array of objects containing information about the wrapper functions returned by {@link tracker.calls()}.
             */
            report(): CallTrackerReportInformation[];
            /**
             * Reset calls of the call tracker. If a tracked function is passed as an argument, the calls will be reset for it.
             * If no arguments are passed, all tracked functions will be reset.
             *
             * ```js
             * import assert from 'node:assert';
             *
             * const tracker = new assert.CallTracker();
             *
             * function func() {}
             * const callsfunc = tracker.calls(func);
             *
             * callsfunc();
             * // Tracker was called once
             * assert.strictEqual(tracker.getCalls(callsfunc).length, 1);
             *
             * tracker.reset(callsfunc);
             * assert.strictEqual(tracker.getCalls(callsfunc).length, 0);
             * ```
             * @since v18.8.0, v16.18.0
             * @param fn a tracked function to reset.
             */
            reset(fn?: Function): void;
            /**
             * Iterates through the list of functions passed to {@link tracker.calls()} and will throw an error for functions that
             * have not been called the expected number of times.
             *
             * ```js
             * import assert from 'node:assert';
             *
             * // Creates call tracker.
             * const tracker = new assert.CallTracker();
             *
             * function func() {}
             *
             * // Returns a function that wraps func() that must be called exact times
             * // before tracker.verify().
             * const callsfunc = tracker.calls(func, 2);
             *
             * callsfunc();
             *
             * // Will throw an error since callsfunc() was only called once.
             * tracker.verify();
             * ```
             * @since v14.2.0, v12.19.0
             */
            verify(): void;
        }
        interface CallTrackerCall {
            thisArg: object;
            arguments: unknown[];
        }
        interface CallTrackerReportInformation {
            message: string;
            /** The actual number of times the function was called. */
            actual: number;
            /** The number of times the function was expected to be called. */
            expected: number;
            /** The name of the function that is wrapped. */
            operator: string;
            /** A stack trace of the function. */
            stack: object;
        }
        type AssertPredicate = RegExp | (new() => object) | ((thrown: unknown) => boolean) | object | Error;
        /**
         * Throws an `AssertionError` with the provided error message or a default
         * error message. If the `message` parameter is an instance of an `Error` then
         * it will be thrown instead of the `AssertionError`.
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * assert.fail();
         * // AssertionError [ERR_ASSERTION]: Failed
         *
         * assert.fail('boom');
         * // AssertionError [ERR_ASSERTION]: boom
         *
         * assert.fail(new TypeError('need array'));
         * // TypeError: need array
         * ```
         *
         * Using `assert.fail()` with more than two arguments is possible but deprecated.
         * See below for further details.
         * @since v0.1.21
         * @param [message='Failed']
         */
        function fail(message?: string | Error): never;
        /** @deprecated since v10.0.0 - use fail([message]) or other assert functions instead. */
        function fail(
            actual: unknown,
            expected: unknown,
            message?: string | Error,
            operator?: string,
            // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
            stackStartFn?: Function,
        ): never;
        /**
         * Tests if `value` is truthy. It is equivalent to `assert.equal(!!value, true, message)`.
         *
         * If `value` is not truthy, an `AssertionError` is thrown with a `message` property set equal to the value of the `message` parameter. If the `message` parameter is `undefined`, a default
         * error message is assigned. If the `message` parameter is an instance of an `Error` then it will be thrown instead of the `AssertionError`.
         * If no arguments are passed in at all `message` will be set to the string:`` 'No value argument passed to `assert.ok()`' ``.
         *
         * Be aware that in the `repl` the error message will be different to the one
         * thrown in a file! See below for further details.
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * assert.ok(true);
         * // OK
         * assert.ok(1);
         * // OK
         *
         * assert.ok();
         * // AssertionError: No value argument passed to `assert.ok()`
         *
         * assert.ok(false, 'it\'s false');
         * // AssertionError: it's false
         *
         * // In the repl:
         * assert.ok(typeof 123 === 'string');
         * // AssertionError: false == true
         *
         * // In a file (e.g. test.js):
         * assert.ok(typeof 123 === 'string');
         * // AssertionError: The expression evaluated to a falsy value:
         * //
         * //   assert.ok(typeof 123 === 'string')
         *
         * assert.ok(false);
         * // AssertionError: The expression evaluated to a falsy value:
         * //
         * //   assert.ok(false)
         *
         * assert.ok(0);
         * // AssertionError: The expression evaluated to a falsy value:
         * //
         * //   assert.ok(0)
         * ```
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * // Using `assert()` works the same:
         * assert(0);
         * // AssertionError: The expression evaluated to a falsy value:
         * //
         * //   assert(0)
         * ```
         * @since v0.1.21
         */
        function ok(value: unknown, message?: string | Error): asserts value;
        /**
         * **Strict assertion mode**
         *
         * An alias of {@link strictEqual}.
         *
         * **Legacy assertion mode**
         *
         * > Stability: 3 - Legacy: Use {@link strictEqual} instead.
         *
         * Tests shallow, coercive equality between the `actual` and `expected` parameters
         * using the [`==` operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Equality). `NaN` is specially handled
         * and treated as being identical if both sides are `NaN`.
         *
         * ```js
         * import assert from 'node:assert';
         *
         * assert.equal(1, 1);
         * // OK, 1 == 1
         * assert.equal(1, '1');
         * // OK, 1 == '1'
         * assert.equal(NaN, NaN);
         * // OK
         *
         * assert.equal(1, 2);
         * // AssertionError: 1 == 2
         * assert.equal({ a: { b: 1 } }, { a: { b: 1 } });
         * // AssertionError: { a: { b: 1 } } == { a: { b: 1 } }
         * ```
         *
         * If the values are not equal, an `AssertionError` is thrown with a `message` property set equal to the value of the `message` parameter. If the `message` parameter is undefined, a default
         * error message is assigned. If the `message` parameter is an instance of an `Error` then it will be thrown instead of the `AssertionError`.
         * @since v0.1.21
         */
        function equal(actual: unknown, expected: unknown, message?: string | Error): void;
        /**
         * **Strict assertion mode**
         *
         * An alias of {@link notStrictEqual}.
         *
         * **Legacy assertion mode**
         *
         * > Stability: 3 - Legacy: Use {@link notStrictEqual} instead.
         *
         * Tests shallow, coercive inequality with the [`!=` operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Inequality). `NaN` is
         * specially handled and treated as being identical if both sides are `NaN`.
         *
         * ```js
         * import assert from 'node:assert';
         *
         * assert.notEqual(1, 2);
         * // OK
         *
         * assert.notEqual(1, 1);
         * // AssertionError: 1 != 1
         *
         * assert.notEqual(1, '1');
         * // AssertionError: 1 != '1'
         * ```
         *
         * If the values are equal, an `AssertionError` is thrown with a `message` property set equal to the value of the `message` parameter. If the `message` parameter is undefined, a default error
         * message is assigned. If the `message` parameter is an instance of an `Error` then it will be thrown instead of the `AssertionError`.
         * @since v0.1.21
         */
        function notEqual(actual: unknown, expected: unknown, message?: string | Error): void;
        /**
         * **Strict assertion mode**
         *
         * An alias of {@link deepStrictEqual}.
         *
         * **Legacy assertion mode**
         *
         * > Stability: 3 - Legacy: Use {@link deepStrictEqual} instead.
         *
         * Tests for deep equality between the `actual` and `expected` parameters. Consider
         * using {@link deepStrictEqual} instead. {@link deepEqual} can have
         * surprising results.
         *
         * _Deep equality_ means that the enumerable "own" properties of child objects
         * are also recursively evaluated by the following rules.
         * @since v0.1.21
         */
        function deepEqual(actual: unknown, expected: unknown, message?: string | Error): void;
        /**
         * **Strict assertion mode**
         *
         * An alias of {@link notDeepStrictEqual}.
         *
         * **Legacy assertion mode**
         *
         * > Stability: 3 - Legacy: Use {@link notDeepStrictEqual} instead.
         *
         * Tests for any deep inequality. Opposite of {@link deepEqual}.
         *
         * ```js
         * import assert from 'node:assert';
         *
         * const obj1 = {
         *   a: {
         *     b: 1,
         *   },
         * };
         * const obj2 = {
         *   a: {
         *     b: 2,
         *   },
         * };
         * const obj3 = {
         *   a: {
         *     b: 1,
         *   },
         * };
         * const obj4 = { __proto__: obj1 };
         *
         * assert.notDeepEqual(obj1, obj1);
         * // AssertionError: { a: { b: 1 } } notDeepEqual { a: { b: 1 } }
         *
         * assert.notDeepEqual(obj1, obj2);
         * // OK
         *
         * assert.notDeepEqual(obj1, obj3);
         * // AssertionError: { a: { b: 1 } } notDeepEqual { a: { b: 1 } }
         *
         * assert.notDeepEqual(obj1, obj4);
         * // OK
         * ```
         *
         * If the values are deeply equal, an `AssertionError` is thrown with a `message` property set equal to the value of the `message` parameter. If the `message` parameter is undefined, a default
         * error message is assigned. If the `message` parameter is an instance of an `Error` then it will be thrown
         * instead of the `AssertionError`.
         * @since v0.1.21
         */
        function notDeepEqual(actual: unknown, expected: unknown, message?: string | Error): void;
        /**
         * Tests strict equality between the `actual` and `expected` parameters as
         * determined by [`Object.is()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * assert.strictEqual(1, 2);
         * // AssertionError [ERR_ASSERTION]: Expected inputs to be strictly equal:
         * //
         * // 1 !== 2
         *
         * assert.strictEqual(1, 1);
         * // OK
         *
         * assert.strictEqual('Hello foobar', 'Hello World!');
         * // AssertionError [ERR_ASSERTION]: Expected inputs to be strictly equal:
         * // + actual - expected
         * //
         * // + 'Hello foobar'
         * // - 'Hello World!'
         * //          ^
         *
         * const apples = 1;
         * const oranges = 2;
         * assert.strictEqual(apples, oranges, `apples ${apples} !== oranges ${oranges}`);
         * // AssertionError [ERR_ASSERTION]: apples 1 !== oranges 2
         *
         * assert.strictEqual(1, '1', new TypeError('Inputs are not identical'));
         * // TypeError: Inputs are not identical
         * ```
         *
         * If the values are not strictly equal, an `AssertionError` is thrown with a `message` property set equal to the value of the `message` parameter. If the `message` parameter is undefined, a
         * default error message is assigned. If the `message` parameter is an instance of an `Error` then it will be thrown
         * instead of the `AssertionError`.
         * @since v0.1.21
         */
        function strictEqual<T>(actual: unknown, expected: T, message?: string | Error): asserts actual is T;
        /**
         * Tests strict inequality between the `actual` and `expected` parameters as
         * determined by [`Object.is()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * assert.notStrictEqual(1, 2);
         * // OK
         *
         * assert.notStrictEqual(1, 1);
         * // AssertionError [ERR_ASSERTION]: Expected "actual" to be strictly unequal to:
         * //
         * // 1
         *
         * assert.notStrictEqual(1, '1');
         * // OK
         * ```
         *
         * If the values are strictly equal, an `AssertionError` is thrown with a `message` property set equal to the value of the `message` parameter. If the `message` parameter is undefined, a
         * default error message is assigned. If the `message` parameter is an instance of an `Error` then it will be thrown
         * instead of the `AssertionError`.
         * @since v0.1.21
         */
        function notStrictEqual(actual: unknown, expected: unknown, message?: string | Error): void;
        /**
         * Tests for deep equality between the `actual` and `expected` parameters.
         * "Deep" equality means that the enumerable "own" properties of child objects
         * are recursively evaluated also by the following rules.
         * @since v1.2.0
         */
        function deepStrictEqual<T>(actual: unknown, expected: T, message?: string | Error): asserts actual is T;
        /**
         * Tests for deep strict inequality. Opposite of {@link deepStrictEqual}.
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * assert.notDeepStrictEqual({ a: 1 }, { a: '1' });
         * // OK
         * ```
         *
         * If the values are deeply and strictly equal, an `AssertionError` is thrown
         * with a `message` property set equal to the value of the `message` parameter. If
         * the `message` parameter is undefined, a default error message is assigned. If
         * the `message` parameter is an instance of an `Error` then it will be thrown
         * instead of the `AssertionError`.
         * @since v1.2.0
         */
        function notDeepStrictEqual(actual: unknown, expected: unknown, message?: string | Error): void;
        /**
         * Expects the function `fn` to throw an error.
         *
         * If specified, `error` can be a [`Class`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes),
         * [`RegExp`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions), a validation function,
         * a validation object where each property will be tested for strict deep equality,
         * or an instance of error where each property will be tested for strict deep
         * equality including the non-enumerable `message` and `name` properties. When
         * using an object, it is also possible to use a regular expression, when
         * validating against a string property. See below for examples.
         *
         * If specified, `message` will be appended to the message provided by the `AssertionError` if the `fn` call fails to throw or in case the error validation
         * fails.
         *
         * Custom validation object/error instance:
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * const err = new TypeError('Wrong value');
         * err.code = 404;
         * err.foo = 'bar';
         * err.info = {
         *   nested: true,
         *   baz: 'text',
         * };
         * err.reg = /abc/i;
         *
         * assert.throws(
         *   () => {
         *     throw err;
         *   },
         *   {
         *     name: 'TypeError',
         *     message: 'Wrong value',
         *     info: {
         *       nested: true,
         *       baz: 'text',
         *     },
         *     // Only properties on the validation object will be tested for.
         *     // Using nested objects requires all properties to be present. Otherwise
         *     // the validation is going to fail.
         *   },
         * );
         *
         * // Using regular expressions to validate error properties:
         * assert.throws(
         *   () => {
         *     throw err;
         *   },
         *   {
         *     // The `name` and `message` properties are strings and using regular
         *     // expressions on those will match against the string. If they fail, an
         *     // error is thrown.
         *     name: /^TypeError$/,
         *     message: /Wrong/,
         *     foo: 'bar',
         *     info: {
         *       nested: true,
         *       // It is not possible to use regular expressions for nested properties!
         *       baz: 'text',
         *     },
         *     // The `reg` property contains a regular expression and only if the
         *     // validation object contains an identical regular expression, it is going
         *     // to pass.
         *     reg: /abc/i,
         *   },
         * );
         *
         * // Fails due to the different `message` and `name` properties:
         * assert.throws(
         *   () => {
         *     const otherErr = new Error('Not found');
         *     // Copy all enumerable properties from `err` to `otherErr`.
         *     for (const [key, value] of Object.entries(err)) {
         *       otherErr[key] = value;
         *     }
         *     throw otherErr;
         *   },
         *   // The error's `message` and `name` properties will also be checked when using
         *   // an error as validation object.
         *   err,
         * );
         * ```
         *
         * Validate instanceof using constructor:
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * assert.throws(
         *   () => {
         *     throw new Error('Wrong value');
         *   },
         *   Error,
         * );
         * ```
         *
         * Validate error message using [`RegExp`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions):
         *
         * Using a regular expression runs `.toString` on the error object, and will
         * therefore also include the error name.
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * assert.throws(
         *   () => {
         *     throw new Error('Wrong value');
         *   },
         *   /^Error: Wrong value$/,
         * );
         * ```
         *
         * Custom error validation:
         *
         * The function must return `true` to indicate all internal validations passed.
         * It will otherwise fail with an `AssertionError`.
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * assert.throws(
         *   () => {
         *     throw new Error('Wrong value');
         *   },
         *   (err) => {
         *     assert(err instanceof Error);
         *     assert(/value/.test(err));
         *     // Avoid returning anything from validation functions besides `true`.
         *     // Otherwise, it's not clear what part of the validation failed. Instead,
         *     // throw an error about the specific validation that failed (as done in this
         *     // example) and add as much helpful debugging information to that error as
         *     // possible.
         *     return true;
         *   },
         *   'unexpected error',
         * );
         * ```
         *
         * `error` cannot be a string. If a string is provided as the second
         * argument, then `error` is assumed to be omitted and the string will be used for `message` instead. This can lead to easy-to-miss mistakes. Using the same
         * message as the thrown error message is going to result in an `ERR_AMBIGUOUS_ARGUMENT` error. Please read the example below carefully if using
         * a string as the second argument gets considered:
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * function throwingFirst() {
         *   throw new Error('First');
         * }
         *
         * function throwingSecond() {
         *   throw new Error('Second');
         * }
         *
         * function notThrowing() {}
         *
         * // The second argument is a string and the input function threw an Error.
         * // The first case will not throw as it does not match for the error message
         * // thrown by the input function!
         * assert.throws(throwingFirst, 'Second');
         * // In the next example the message has no benefit over the message from the
         * // error and since it is not clear if the user intended to actually match
         * // against the error message, Node.js throws an `ERR_AMBIGUOUS_ARGUMENT` error.
         * assert.throws(throwingSecond, 'Second');
         * // TypeError [ERR_AMBIGUOUS_ARGUMENT]
         *
         * // The string is only used (as message) in case the function does not throw:
         * assert.throws(notThrowing, 'Second');
         * // AssertionError [ERR_ASSERTION]: Missing expected exception: Second
         *
         * // If it was intended to match for the error message do this instead:
         * // It does not throw because the error messages match.
         * assert.throws(throwingSecond, /Second$/);
         *
         * // If the error message does not match, an AssertionError is thrown.
         * assert.throws(throwingFirst, /Second$/);
         * // AssertionError [ERR_ASSERTION]
         * ```
         *
         * Due to the confusing error-prone notation, avoid a string as the second
         * argument.
         * @since v0.1.21
         */
        function throws(block: () => unknown, message?: string | Error): void;
        function throws(block: () => unknown, error: AssertPredicate, message?: string | Error): void;
        /**
         * Asserts that the function `fn` does not throw an error.
         *
         * Using `assert.doesNotThrow()` is actually not useful because there
         * is no benefit in catching an error and then rethrowing it. Instead, consider
         * adding a comment next to the specific code path that should not throw and keep
         * error messages as expressive as possible.
         *
         * When `assert.doesNotThrow()` is called, it will immediately call the `fn` function.
         *
         * If an error is thrown and it is the same type as that specified by the `error` parameter, then an `AssertionError` is thrown. If the error is of a
         * different type, or if the `error` parameter is undefined, the error is
         * propagated back to the caller.
         *
         * If specified, `error` can be a [`Class`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes),
         * [`RegExp`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions), or a validation
         * function. See {@link throws} for more details.
         *
         * The following, for instance, will throw the `TypeError` because there is no
         * matching error type in the assertion:
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * assert.doesNotThrow(
         *   () => {
         *     throw new TypeError('Wrong value');
         *   },
         *   SyntaxError,
         * );
         * ```
         *
         * However, the following will result in an `AssertionError` with the message
         * 'Got unwanted exception...':
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * assert.doesNotThrow(
         *   () => {
         *     throw new TypeError('Wrong value');
         *   },
         *   TypeError,
         * );
         * ```
         *
         * If an `AssertionError` is thrown and a value is provided for the `message` parameter, the value of `message` will be appended to the `AssertionError` message:
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * assert.doesNotThrow(
         *   () => {
         *     throw new TypeError('Wrong value');
         *   },
         *   /Wrong value/,
         *   'Whoops',
         * );
         * // Throws: AssertionError: Got unwanted exception: Whoops
         * ```
         * @since v0.1.21
         */
        function doesNotThrow(block: () => unknown, message?: string | Error): void;
        function doesNotThrow(block: () => unknown, error: AssertPredicate, message?: string | Error): void;
        /**
         * Throws `value` if `value` is not `undefined` or `null`. This is useful when
         * testing the `error` argument in callbacks. The stack trace contains all frames
         * from the error passed to `ifError()` including the potential new frames for `ifError()` itself.
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * assert.ifError(null);
         * // OK
         * assert.ifError(0);
         * // AssertionError [ERR_ASSERTION]: ifError got unwanted exception: 0
         * assert.ifError('error');
         * // AssertionError [ERR_ASSERTION]: ifError got unwanted exception: 'error'
         * assert.ifError(new Error());
         * // AssertionError [ERR_ASSERTION]: ifError got unwanted exception: Error
         *
         * // Create some random error frames.
         * let err;
         * (function errorFrame() {
         *   err = new Error('test error');
         * })();
         *
         * (function ifErrorFrame() {
         *   assert.ifError(err);
         * })();
         * // AssertionError [ERR_ASSERTION]: ifError got unwanted exception: test error
         * //     at ifErrorFrame
         * //     at errorFrame
         * ```
         * @since v0.1.97
         */
        function ifError(value: unknown): asserts value is null | undefined;
        /**
         * Awaits the `asyncFn` promise or, if `asyncFn` is a function, immediately
         * calls the function and awaits the returned promise to complete. It will then
         * check that the promise is rejected.
         *
         * If `asyncFn` is a function and it throws an error synchronously, `assert.rejects()` will return a rejected `Promise` with that error. If the
         * function does not return a promise, `assert.rejects()` will return a rejected `Promise` with an [ERR_INVALID_RETURN_VALUE](https://nodejs.org/docs/latest-v22.x/api/errors.html#err_invalid_return_value)
         * error. In both cases the error handler is skipped.
         *
         * Besides the async nature to await the completion behaves identically to {@link throws}.
         *
         * If specified, `error` can be a [`Class`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes),
         * [`RegExp`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions), a validation function,
         * an object where each property will be tested for, or an instance of error where
         * each property will be tested for including the non-enumerable `message` and `name` properties.
         *
         * If specified, `message` will be the message provided by the `{@link AssertionError}` if the `asyncFn` fails to reject.
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * await assert.rejects(
         *   async () => {
         *     throw new TypeError('Wrong value');
         *   },
         *   {
         *     name: 'TypeError',
         *     message: 'Wrong value',
         *   },
         * );
         * ```
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * await assert.rejects(
         *   async () => {
         *     throw new TypeError('Wrong value');
         *   },
         *   (err) => {
         *     assert.strictEqual(err.name, 'TypeError');
         *     assert.strictEqual(err.message, 'Wrong value');
         *     return true;
         *   },
         * );
         * ```
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * assert.rejects(
         *   Promise.reject(new Error('Wrong value')),
         *   Error,
         * ).then(() => {
         *   // ...
         * });
         * ```
         *
         * `error` cannot be a string. If a string is provided as the second argument, then `error` is assumed to
         * be omitted and the string will be used for `message` instead. This can lead to easy-to-miss mistakes. Please read the
         * example in {@link throws} carefully if using a string as the second argument gets considered.
         * @since v10.0.0
         */
        function rejects(block: (() => Promise<unknown>) | Promise<unknown>, message?: string | Error): Promise<void>;
        function rejects(
            block: (() => Promise<unknown>) | Promise<unknown>,
            error: AssertPredicate,
            message?: string | Error,
        ): Promise<void>;
        /**
         * Awaits the `asyncFn` promise or, if `asyncFn` is a function, immediately
         * calls the function and awaits the returned promise to complete. It will then
         * check that the promise is not rejected.
         *
         * If `asyncFn` is a function and it throws an error synchronously, `assert.doesNotReject()` will return a rejected `Promise` with that error. If
         * the function does not return a promise, `assert.doesNotReject()` will return a
         * rejected `Promise` with an [ERR_INVALID_RETURN_VALUE](https://nodejs.org/docs/latest-v22.x/api/errors.html#err_invalid_return_value) error. In both cases
         * the error handler is skipped.
         *
         * Using `assert.doesNotReject()` is actually not useful because there is little
         * benefit in catching a rejection and then rejecting it again. Instead, consider
         * adding a comment next to the specific code path that should not reject and keep
         * error messages as expressive as possible.
         *
         * If specified, `error` can be a [`Class`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes),
         * [`RegExp`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions), or a validation
         * function. See {@link throws} for more details.
         *
         * Besides the async nature to await the completion behaves identically to {@link doesNotThrow}.
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * await assert.doesNotReject(
         *   async () => {
         *     throw new TypeError('Wrong value');
         *   },
         *   SyntaxError,
         * );
         * ```
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * assert.doesNotReject(Promise.reject(new TypeError('Wrong value')))
         *   .then(() => {
         *     // ...
         *   });
         * ```
         * @since v10.0.0
         */
        function doesNotReject(
            block: (() => Promise<unknown>) | Promise<unknown>,
            message?: string | Error,
        ): Promise<void>;
        function doesNotReject(
            block: (() => Promise<unknown>) | Promise<unknown>,
            error: AssertPredicate,
            message?: string | Error,
        ): Promise<void>;
        /**
         * Expects the `string` input to match the regular expression.
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * assert.match('I will fail', /pass/);
         * // AssertionError [ERR_ASSERTION]: The input did not match the regular ...
         *
         * assert.match(123, /pass/);
         * // AssertionError [ERR_ASSERTION]: The "string" argument must be of type string.
         *
         * assert.match('I will pass', /pass/);
         * // OK
         * ```
         *
         * If the values do not match, or if the `string` argument is of another type than `string`, an `{@link AssertionError}` is thrown with a `message` property set equal
         * to the value of the `message` parameter. If the `message` parameter is
         * undefined, a default error message is assigned. If the `message` parameter is an
         * instance of an [Error](https://nodejs.org/docs/latest-v22.x/api/errors.html#class-error) then it will be thrown instead of the `{@link AssertionError}`.
         * @since v13.6.0, v12.16.0
         */
        function match(value: string, regExp: RegExp, message?: string | Error): void;
        /**
         * Expects the `string` input not to match the regular expression.
         *
         * ```js
         * import assert from 'node:assert/strict';
         *
         * assert.doesNotMatch('I will fail', /fail/);
         * // AssertionError [ERR_ASSERTION]: The input was expected to not match the ...
         *
         * assert.doesNotMatch(123, /pass/);
         * // AssertionError [ERR_ASSERTION]: The "string" argument must be of type string.
         *
         * assert.doesNotMatch('I will pass', /different/);
         * // OK
         * ```
         *
         * If the values do match, or if the `string` argument is of another type than `string`, an `{@link AssertionError}` is thrown with a `message` property set equal
         * to the value of the `message` parameter. If the `message` parameter is
         * undefined, a default error message is assigned. If the `message` parameter is an
         * instance of an [Error](https://nodejs.org/docs/latest-v22.x/api/errors.html#class-error) then it will be thrown instead of the `{@link AssertionError}`.
         * @since v13.6.0, v12.16.0
         */
        function doesNotMatch(value: string, regExp: RegExp, message?: string | Error): void;
        /**
         * Tests for partial deep equality between the `actual` and `expected` parameters.
         * "Deep" equality means that the enumerable "own" properties of child objects
         * are recursively evaluated also by the following rules. "Partial" equality means
         * that only properties that exist on the `expected` parameter are going to be
         * compared.
         *
         * This method always passes the same test cases as `assert.deepStrictEqual()`,
         * behaving as a super set of it.
         * @since v22.13.0
         */
        function partialDeepStrictEqual(actual: unknown, expected: unknown, message?: string | Error): void;
        /**
         * In strict assertion mode, non-strict methods behave like their corresponding strict methods. For example,
         * {@link deepEqual} will behave like {@link deepStrictEqual}.
         *
         * In strict assertion mode, error messages for objects display a diff. In legacy assertion mode, error
         * messages for objects display the objects, often truncated.
         *
         * To use strict assertion mode:
         *
         * ```js
         * import { strict as assert } from 'node:assert';
         * import assert from 'node:assert/strict';
         * ```
         *
         * Example error diff:
         *
         * ```js
         * import { strict as assert } from 'node:assert';
         *
         * assert.deepEqual([[[1, 2, 3]], 4, 5], [[[1, 2, '3']], 4, 5]);
         * // AssertionError: Expected inputs to be strictly deep-equal:
         * // + actual - expected ... Lines skipped
         * //
         * //   [
         * //     [
         * // ...
         * //       2,
         * // +     3
         * // -     '3'
         * //     ],
         * // ...
         * //     5
         * //   ]
         * ```
         *
         * To deactivate the colors, use the `NO_COLOR` or `NODE_DISABLE_COLORS` environment variables. This will also
         * deactivate the colors in the REPL. For more on color support in terminal environments, read the tty
         * `getColorDepth()` documentation.
         *
         * @since v15.0.0, v13.9.0, v12.16.2, v9.9.0
         */
        namespace strict {
            type AssertionError = assert.AssertionError;
            type AssertPredicate = assert.AssertPredicate;
            type CallTrackerCall = assert.CallTrackerCall;
            type CallTrackerReportInformation = assert.CallTrackerReportInformation;
        }
        const strict:
            & Omit<
                typeof assert,
                | "equal"
                | "notEqual"
                | "deepEqual"
                | "notDeepEqual"
                | "ok"
                | "strictEqual"
                | "deepStrictEqual"
                | "ifError"
                | "strict"
                | "AssertionError"
            >
            & {
                (value: unknown, message?: string | Error): asserts value;
                equal: typeof strictEqual;
                notEqual: typeof notStrictEqual;
                deepEqual: typeof deepStrictEqual;
                notDeepEqual: typeof notDeepStrictEqual;
                // Mapped types and assertion functions are incompatible?
                // TS2775: Assertions require every name in the call target
                // to be declared with an explicit type annotation.
                ok: typeof ok;
                strictEqual: typeof strictEqual;
                deepStrictEqual: typeof deepStrictEqual;
                ifError: typeof ifError;
                strict: typeof strict;
                AssertionError: typeof AssertionError;
            };
    }
    export = assert;
}
declare module "node:assert" {
    import assert = require("assert");
    export = assert;
}

```

## ./lib/lambda/node_modules/@types/node/async_hooks.d.ts

```typescript
/**
 * We strongly discourage the use of the `async_hooks` API.
 * Other APIs that can cover most of its use cases include:
 *
 * * [`AsyncLocalStorage`](https://nodejs.org/docs/latest-v22.x/api/async_context.html#class-asynclocalstorage) tracks async context
 * * [`process.getActiveResourcesInfo()`](https://nodejs.org/docs/latest-v22.x/api/process.html#processgetactiveresourcesinfo) tracks active resources
 *
 * The `node:async_hooks` module provides an API to track asynchronous resources.
 * It can be accessed using:
 *
 * ```js
 * import async_hooks from 'node:async_hooks';
 * ```
 * @experimental
 * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/async_hooks.js)
 */
declare module "async_hooks" {
    /**
     * ```js
     * import { executionAsyncId } from 'node:async_hooks';
     * import fs from 'node:fs';
     *
     * console.log(executionAsyncId());  // 1 - bootstrap
     * const path = '.';
     * fs.open(path, 'r', (err, fd) => {
     *   console.log(executionAsyncId());  // 6 - open()
     * });
     * ```
     *
     * The ID returned from `executionAsyncId()` is related to execution timing, not
     * causality (which is covered by `triggerAsyncId()`):
     *
     * ```js
     * const server = net.createServer((conn) => {
     *   // Returns the ID of the server, not of the new connection, because the
     *   // callback runs in the execution scope of the server's MakeCallback().
     *   async_hooks.executionAsyncId();
     *
     * }).listen(port, () => {
     *   // Returns the ID of a TickObject (process.nextTick()) because all
     *   // callbacks passed to .listen() are wrapped in a nextTick().
     *   async_hooks.executionAsyncId();
     * });
     * ```
     *
     * Promise contexts may not get precise `executionAsyncIds` by default.
     * See the section on [promise execution tracking](https://nodejs.org/docs/latest-v22.x/api/async_hooks.html#promise-execution-tracking).
     * @since v8.1.0
     * @return The `asyncId` of the current execution context. Useful to track when something calls.
     */
    function executionAsyncId(): number;
    /**
     * Resource objects returned by `executionAsyncResource()` are most often internal
     * Node.js handle objects with undocumented APIs. Using any functions or properties
     * on the object is likely to crash your application and should be avoided.
     *
     * Using `executionAsyncResource()` in the top-level execution context will
     * return an empty object as there is no handle or request object to use,
     * but having an object representing the top-level can be helpful.
     *
     * ```js
     * import { open } from 'node:fs';
     * import { executionAsyncId, executionAsyncResource } from 'node:async_hooks';
     *
     * console.log(executionAsyncId(), executionAsyncResource());  // 1 {}
     * open(new URL(import.meta.url), 'r', (err, fd) => {
     *   console.log(executionAsyncId(), executionAsyncResource());  // 7 FSReqWrap
     * });
     * ```
     *
     * This can be used to implement continuation local storage without the
     * use of a tracking `Map` to store the metadata:
     *
     * ```js
     * import { createServer } from 'node:http';
     * import {
     *   executionAsyncId,
     *   executionAsyncResource,
     *   createHook,
     * } from 'node:async_hooks';
     * const sym = Symbol('state'); // Private symbol to avoid pollution
     *
     * createHook({
     *   init(asyncId, type, triggerAsyncId, resource) {
     *     const cr = executionAsyncResource();
     *     if (cr) {
     *       resource[sym] = cr[sym];
     *     }
     *   },
     * }).enable();
     *
     * const server = createServer((req, res) => {
     *   executionAsyncResource()[sym] = { state: req.url };
     *   setTimeout(function() {
     *     res.end(JSON.stringify(executionAsyncResource()[sym]));
     *   }, 100);
     * }).listen(3000);
     * ```
     * @since v13.9.0, v12.17.0
     * @return The resource representing the current execution. Useful to store data within the resource.
     */
    function executionAsyncResource(): object;
    /**
     * ```js
     * const server = net.createServer((conn) => {
     *   // The resource that caused (or triggered) this callback to be called
     *   // was that of the new connection. Thus the return value of triggerAsyncId()
     *   // is the asyncId of "conn".
     *   async_hooks.triggerAsyncId();
     *
     * }).listen(port, () => {
     *   // Even though all callbacks passed to .listen() are wrapped in a nextTick()
     *   // the callback itself exists because the call to the server's .listen()
     *   // was made. So the return value would be the ID of the server.
     *   async_hooks.triggerAsyncId();
     * });
     * ```
     *
     * Promise contexts may not get valid `triggerAsyncId`s by default. See
     * the section on [promise execution tracking](https://nodejs.org/docs/latest-v22.x/api/async_hooks.html#promise-execution-tracking).
     * @return The ID of the resource responsible for calling the callback that is currently being executed.
     */
    function triggerAsyncId(): number;
    interface HookCallbacks {
        /**
         * Called when a class is constructed that has the possibility to emit an asynchronous event.
         * @param asyncId A unique ID for the async resource
         * @param type The type of the async resource
         * @param triggerAsyncId The unique ID of the async resource in whose execution context this async resource was created
         * @param resource Reference to the resource representing the async operation, needs to be released during destroy
         */
        init?(asyncId: number, type: string, triggerAsyncId: number, resource: object): void;
        /**
         * When an asynchronous operation is initiated or completes a callback is called to notify the user.
         * The before callback is called just before said callback is executed.
         * @param asyncId the unique identifier assigned to the resource about to execute the callback.
         */
        before?(asyncId: number): void;
        /**
         * Called immediately after the callback specified in `before` is completed.
         *
         * If an uncaught exception occurs during execution of the callback, then `after` will run after the `'uncaughtException'` event is emitted or a `domain`'s handler runs.
         * @param asyncId the unique identifier assigned to the resource which has executed the callback.
         */
        after?(asyncId: number): void;
        /**
         * Called when a promise has resolve() called. This may not be in the same execution id
         * as the promise itself.
         * @param asyncId the unique id for the promise that was resolve()d.
         */
        promiseResolve?(asyncId: number): void;
        /**
         * Called after the resource corresponding to asyncId is destroyed
         * @param asyncId a unique ID for the async resource
         */
        destroy?(asyncId: number): void;
    }
    interface AsyncHook {
        /**
         * Enable the callbacks for a given AsyncHook instance. If no callbacks are provided enabling is a noop.
         */
        enable(): this;
        /**
         * Disable the callbacks for a given AsyncHook instance from the global pool of AsyncHook callbacks to be executed. Once a hook has been disabled it will not be called again until enabled.
         */
        disable(): this;
    }
    /**
     * Registers functions to be called for different lifetime events of each async
     * operation.
     *
     * The callbacks `init()`/`before()`/`after()`/`destroy()` are called for the
     * respective asynchronous event during a resource's lifetime.
     *
     * All callbacks are optional. For example, if only resource cleanup needs to
     * be tracked, then only the `destroy` callback needs to be passed. The
     * specifics of all functions that can be passed to `callbacks` is in the `Hook Callbacks` section.
     *
     * ```js
     * import { createHook } from 'node:async_hooks';
     *
     * const asyncHook = createHook({
     *   init(asyncId, type, triggerAsyncId, resource) { },
     *   destroy(asyncId) { },
     * });
     * ```
     *
     * The callbacks will be inherited via the prototype chain:
     *
     * ```js
     * class MyAsyncCallbacks {
     *   init(asyncId, type, triggerAsyncId, resource) { }
     *   destroy(asyncId) {}
     * }
     *
     * class MyAddedCallbacks extends MyAsyncCallbacks {
     *   before(asyncId) { }
     *   after(asyncId) { }
     * }
     *
     * const asyncHook = async_hooks.createHook(new MyAddedCallbacks());
     * ```
     *
     * Because promises are asynchronous resources whose lifecycle is tracked
     * via the async hooks mechanism, the `init()`, `before()`, `after()`, and`destroy()` callbacks _must not_ be async functions that return promises.
     * @since v8.1.0
     * @param callbacks The `Hook Callbacks` to register
     * @return Instance used for disabling and enabling hooks
     */
    function createHook(callbacks: HookCallbacks): AsyncHook;
    interface AsyncResourceOptions {
        /**
         * The ID of the execution context that created this async event.
         * @default executionAsyncId()
         */
        triggerAsyncId?: number | undefined;
        /**
         * Disables automatic `emitDestroy` when the object is garbage collected.
         * This usually does not need to be set (even if `emitDestroy` is called
         * manually), unless the resource's `asyncId` is retrieved and the
         * sensitive API's `emitDestroy` is called with it.
         * @default false
         */
        requireManualDestroy?: boolean | undefined;
    }
    /**
     * The class `AsyncResource` is designed to be extended by the embedder's async
     * resources. Using this, users can easily trigger the lifetime events of their
     * own resources.
     *
     * The `init` hook will trigger when an `AsyncResource` is instantiated.
     *
     * The following is an overview of the `AsyncResource` API.
     *
     * ```js
     * import { AsyncResource, executionAsyncId } from 'node:async_hooks';
     *
     * // AsyncResource() is meant to be extended. Instantiating a
     * // new AsyncResource() also triggers init. If triggerAsyncId is omitted then
     * // async_hook.executionAsyncId() is used.
     * const asyncResource = new AsyncResource(
     *   type, { triggerAsyncId: executionAsyncId(), requireManualDestroy: false },
     * );
     *
     * // Run a function in the execution context of the resource. This will
     * // * establish the context of the resource
     * // * trigger the AsyncHooks before callbacks
     * // * call the provided function `fn` with the supplied arguments
     * // * trigger the AsyncHooks after callbacks
     * // * restore the original execution context
     * asyncResource.runInAsyncScope(fn, thisArg, ...args);
     *
     * // Call AsyncHooks destroy callbacks.
     * asyncResource.emitDestroy();
     *
     * // Return the unique ID assigned to the AsyncResource instance.
     * asyncResource.asyncId();
     *
     * // Return the trigger ID for the AsyncResource instance.
     * asyncResource.triggerAsyncId();
     * ```
     */
    class AsyncResource {
        /**
         * AsyncResource() is meant to be extended. Instantiating a
         * new AsyncResource() also triggers init. If triggerAsyncId is omitted then
         * async_hook.executionAsyncId() is used.
         * @param type The type of async event.
         * @param triggerAsyncId The ID of the execution context that created
         *   this async event (default: `executionAsyncId()`), or an
         *   AsyncResourceOptions object (since v9.3.0)
         */
        constructor(type: string, triggerAsyncId?: number | AsyncResourceOptions);
        /**
         * Binds the given function to the current execution context.
         * @since v14.8.0, v12.19.0
         * @param fn The function to bind to the current execution context.
         * @param type An optional name to associate with the underlying `AsyncResource`.
         */
        static bind<Func extends (this: ThisArg, ...args: any[]) => any, ThisArg>(
            fn: Func,
            type?: string,
            thisArg?: ThisArg,
        ): Func;
        /**
         * Binds the given function to execute to this `AsyncResource`'s scope.
         * @since v14.8.0, v12.19.0
         * @param fn The function to bind to the current `AsyncResource`.
         */
        bind<Func extends (...args: any[]) => any>(fn: Func): Func;
        /**
         * Call the provided function with the provided arguments in the execution context
         * of the async resource. This will establish the context, trigger the AsyncHooks
         * before callbacks, call the function, trigger the AsyncHooks after callbacks, and
         * then restore the original execution context.
         * @since v9.6.0
         * @param fn The function to call in the execution context of this async resource.
         * @param thisArg The receiver to be used for the function call.
         * @param args Optional arguments to pass to the function.
         */
        runInAsyncScope<This, Result>(
            fn: (this: This, ...args: any[]) => Result,
            thisArg?: This,
            ...args: any[]
        ): Result;
        /**
         * Call all `destroy` hooks. This should only ever be called once. An error will
         * be thrown if it is called more than once. This **must** be manually called. If
         * the resource is left to be collected by the GC then the `destroy` hooks will
         * never be called.
         * @return A reference to `asyncResource`.
         */
        emitDestroy(): this;
        /**
         * @return The unique `asyncId` assigned to the resource.
         */
        asyncId(): number;
        /**
         * @return The same `triggerAsyncId` that is passed to the `AsyncResource` constructor.
         */
        triggerAsyncId(): number;
    }
    /**
     * This class creates stores that stay coherent through asynchronous operations.
     *
     * While you can create your own implementation on top of the `node:async_hooks` module, `AsyncLocalStorage` should be preferred as it is a performant and memory
     * safe implementation that involves significant optimizations that are non-obvious
     * to implement.
     *
     * The following example uses `AsyncLocalStorage` to build a simple logger
     * that assigns IDs to incoming HTTP requests and includes them in messages
     * logged within each request.
     *
     * ```js
     * import http from 'node:http';
     * import { AsyncLocalStorage } from 'node:async_hooks';
     *
     * const asyncLocalStorage = new AsyncLocalStorage();
     *
     * function logWithId(msg) {
     *   const id = asyncLocalStorage.getStore();
     *   console.log(`${id !== undefined ? id : '-'}:`, msg);
     * }
     *
     * let idSeq = 0;
     * http.createServer((req, res) => {
     *   asyncLocalStorage.run(idSeq++, () => {
     *     logWithId('start');
     *     // Imagine any chain of async operations here
     *     setImmediate(() => {
     *       logWithId('finish');
     *       res.end();
     *     });
     *   });
     * }).listen(8080);
     *
     * http.get('http://localhost:8080');
     * http.get('http://localhost:8080');
     * // Prints:
     * //   0: start
     * //   0: finish
     * //   1: start
     * //   1: finish
     * ```
     *
     * Each instance of `AsyncLocalStorage` maintains an independent storage context.
     * Multiple instances can safely exist simultaneously without risk of interfering
     * with each other's data.
     * @since v13.10.0, v12.17.0
     */
    class AsyncLocalStorage<T> {
        /**
         * Binds the given function to the current execution context.
         * @since v19.8.0
         * @param fn The function to bind to the current execution context.
         * @return A new function that calls `fn` within the captured execution context.
         */
        static bind<Func extends (...args: any[]) => any>(fn: Func): Func;
        /**
         * Captures the current execution context and returns a function that accepts a
         * function as an argument. Whenever the returned function is called, it
         * calls the function passed to it within the captured context.
         *
         * ```js
         * const asyncLocalStorage = new AsyncLocalStorage();
         * const runInAsyncScope = asyncLocalStorage.run(123, () => AsyncLocalStorage.snapshot());
         * const result = asyncLocalStorage.run(321, () => runInAsyncScope(() => asyncLocalStorage.getStore()));
         * console.log(result);  // returns 123
         * ```
         *
         * AsyncLocalStorage.snapshot() can replace the use of AsyncResource for simple
         * async context tracking purposes, for example:
         *
         * ```js
         * class Foo {
         *   #runInAsyncScope = AsyncLocalStorage.snapshot();
         *
         *   get() { return this.#runInAsyncScope(() => asyncLocalStorage.getStore()); }
         * }
         *
         * const foo = asyncLocalStorage.run(123, () => new Foo());
         * console.log(asyncLocalStorage.run(321, () => foo.get())); // returns 123
         * ```
         * @since v19.8.0
         * @return A new function with the signature `(fn: (...args) : R, ...args) : R`.
         */
        static snapshot(): <R, TArgs extends any[]>(fn: (...args: TArgs) => R, ...args: TArgs) => R;
        /**
         * Disables the instance of `AsyncLocalStorage`. All subsequent calls
         * to `asyncLocalStorage.getStore()` will return `undefined` until `asyncLocalStorage.run()` or `asyncLocalStorage.enterWith()` is called again.
         *
         * When calling `asyncLocalStorage.disable()`, all current contexts linked to the
         * instance will be exited.
         *
         * Calling `asyncLocalStorage.disable()` is required before the `asyncLocalStorage` can be garbage collected. This does not apply to stores
         * provided by the `asyncLocalStorage`, as those objects are garbage collected
         * along with the corresponding async resources.
         *
         * Use this method when the `asyncLocalStorage` is not in use anymore
         * in the current process.
         * @since v13.10.0, v12.17.0
         * @experimental
         */
        disable(): void;
        /**
         * Returns the current store.
         * If called outside of an asynchronous context initialized by
         * calling `asyncLocalStorage.run()` or `asyncLocalStorage.enterWith()`, it
         * returns `undefined`.
         * @since v13.10.0, v12.17.0
         */
        getStore(): T | undefined;
        /**
         * Runs a function synchronously within a context and returns its
         * return value. The store is not accessible outside of the callback function.
         * The store is accessible to any asynchronous operations created within the
         * callback.
         *
         * The optional `args` are passed to the callback function.
         *
         * If the callback function throws an error, the error is thrown by `run()` too.
         * The stacktrace is not impacted by this call and the context is exited.
         *
         * Example:
         *
         * ```js
         * const store = { id: 2 };
         * try {
         *   asyncLocalStorage.run(store, () => {
         *     asyncLocalStorage.getStore(); // Returns the store object
         *     setTimeout(() => {
         *       asyncLocalStorage.getStore(); // Returns the store object
         *     }, 200);
         *     throw new Error();
         *   });
         * } catch (e) {
         *   asyncLocalStorage.getStore(); // Returns undefined
         *   // The error will be caught here
         * }
         * ```
         * @since v13.10.0, v12.17.0
         */
        run<R>(store: T, callback: () => R): R;
        run<R, TArgs extends any[]>(store: T, callback: (...args: TArgs) => R, ...args: TArgs): R;
        /**
         * Runs a function synchronously outside of a context and returns its
         * return value. The store is not accessible within the callback function or
         * the asynchronous operations created within the callback. Any `getStore()` call done within the callback function will always return `undefined`.
         *
         * The optional `args` are passed to the callback function.
         *
         * If the callback function throws an error, the error is thrown by `exit()` too.
         * The stacktrace is not impacted by this call and the context is re-entered.
         *
         * Example:
         *
         * ```js
         * // Within a call to run
         * try {
         *   asyncLocalStorage.getStore(); // Returns the store object or value
         *   asyncLocalStorage.exit(() => {
         *     asyncLocalStorage.getStore(); // Returns undefined
         *     throw new Error();
         *   });
         * } catch (e) {
         *   asyncLocalStorage.getStore(); // Returns the same object or value
         *   // The error will be caught here
         * }
         * ```
         * @since v13.10.0, v12.17.0
         * @experimental
         */
        exit<R, TArgs extends any[]>(callback: (...args: TArgs) => R, ...args: TArgs): R;
        /**
         * Transitions into the context for the remainder of the current
         * synchronous execution and then persists the store through any following
         * asynchronous calls.
         *
         * Example:
         *
         * ```js
         * const store = { id: 1 };
         * // Replaces previous store with the given store object
         * asyncLocalStorage.enterWith(store);
         * asyncLocalStorage.getStore(); // Returns the store object
         * someAsyncOperation(() => {
         *   asyncLocalStorage.getStore(); // Returns the same object
         * });
         * ```
         *
         * This transition will continue for the _entire_ synchronous execution.
         * This means that if, for example, the context is entered within an event
         * handler subsequent event handlers will also run within that context unless
         * specifically bound to another context with an `AsyncResource`. That is why `run()` should be preferred over `enterWith()` unless there are strong reasons
         * to use the latter method.
         *
         * ```js
         * const store = { id: 1 };
         *
         * emitter.on('my-event', () => {
         *   asyncLocalStorage.enterWith(store);
         * });
         * emitter.on('my-event', () => {
         *   asyncLocalStorage.getStore(); // Returns the same object
         * });
         *
         * asyncLocalStorage.getStore(); // Returns undefined
         * emitter.emit('my-event');
         * asyncLocalStorage.getStore(); // Returns the same object
         * ```
         * @since v13.11.0, v12.17.0
         * @experimental
         */
        enterWith(store: T): void;
    }
    /**
     * @since v17.2.0, v16.14.0
     * @return A map of provider types to the corresponding numeric id.
     * This map contains all the event types that might be emitted by the `async_hooks.init()` event.
     */
    namespace asyncWrapProviders {
        const NONE: number;
        const DIRHANDLE: number;
        const DNSCHANNEL: number;
        const ELDHISTOGRAM: number;
        const FILEHANDLE: number;
        const FILEHANDLECLOSEREQ: number;
        const FIXEDSIZEBLOBCOPY: number;
        const FSEVENTWRAP: number;
        const FSREQCALLBACK: number;
        const FSREQPROMISE: number;
        const GETADDRINFOREQWRAP: number;
        const GETNAMEINFOREQWRAP: number;
        const HEAPSNAPSHOT: number;
        const HTTP2SESSION: number;
        const HTTP2STREAM: number;
        const HTTP2PING: number;
        const HTTP2SETTINGS: number;
        const HTTPINCOMINGMESSAGE: number;
        const HTTPCLIENTREQUEST: number;
        const JSSTREAM: number;
        const JSUDPWRAP: number;
        const MESSAGEPORT: number;
        const PIPECONNECTWRAP: number;
        const PIPESERVERWRAP: number;
        const PIPEWRAP: number;
        const PROCESSWRAP: number;
        const PROMISE: number;
        const QUERYWRAP: number;
        const SHUTDOWNWRAP: number;
        const SIGNALWRAP: number;
        const STATWATCHER: number;
        const STREAMPIPE: number;
        const TCPCONNECTWRAP: number;
        const TCPSERVERWRAP: number;
        const TCPWRAP: number;
        const TTYWRAP: number;
        const UDPSENDWRAP: number;
        const UDPWRAP: number;
        const SIGINTWATCHDOG: number;
        const WORKER: number;
        const WORKERHEAPSNAPSHOT: number;
        const WRITEWRAP: number;
        const ZLIB: number;
        const CHECKPRIMEREQUEST: number;
        const PBKDF2REQUEST: number;
        const KEYPAIRGENREQUEST: number;
        const KEYGENREQUEST: number;
        const KEYEXPORTREQUEST: number;
        const CIPHERREQUEST: number;
        const DERIVEBITSREQUEST: number;
        const HASHREQUEST: number;
        const RANDOMBYTESREQUEST: number;
        const RANDOMPRIMEREQUEST: number;
        const SCRYPTREQUEST: number;
        const SIGNREQUEST: number;
        const TLSWRAP: number;
        const VERIFYREQUEST: number;
    }
}
declare module "node:async_hooks" {
    export * from "async_hooks";
}

```

## ./lib/lambda/node_modules/@types/node/buffer.buffer.d.ts

```typescript
declare module "buffer" {
    type ImplicitArrayBuffer<T extends WithImplicitCoercion<ArrayBufferLike>> = T extends
        { valueOf(): infer V extends ArrayBufferLike } ? V : T;
    global {
        interface BufferConstructor {
            // see buffer.d.ts for implementation shared with all TypeScript versions

            /**
             * Allocates a new buffer containing the given {str}.
             *
             * @param str String to store in buffer.
             * @param encoding encoding to use, optional.  Default is 'utf8'
             * @deprecated since v10.0.0 - Use `Buffer.from(string[, encoding])` instead.
             */
            new(str: string, encoding?: BufferEncoding): Buffer<ArrayBuffer>;
            /**
             * Allocates a new buffer of {size} octets.
             *
             * @param size count of octets to allocate.
             * @deprecated since v10.0.0 - Use `Buffer.alloc()` instead (also see `Buffer.allocUnsafe()`).
             */
            new(size: number): Buffer<ArrayBuffer>;
            /**
             * Allocates a new buffer containing the given {array} of octets.
             *
             * @param array The octets to store.
             * @deprecated since v10.0.0 - Use `Buffer.from(array)` instead.
             */
            new(array: ArrayLike<number>): Buffer<ArrayBuffer>;
            /**
             * Produces a Buffer backed by the same allocated memory as
             * the given {ArrayBuffer}/{SharedArrayBuffer}.
             *
             * @param arrayBuffer The ArrayBuffer with which to share memory.
             * @deprecated since v10.0.0 - Use `Buffer.from(arrayBuffer[, byteOffset[, length]])` instead.
             */
            new<TArrayBuffer extends ArrayBufferLike = ArrayBuffer>(arrayBuffer: TArrayBuffer): Buffer<TArrayBuffer>;
            /**
             * Allocates a new `Buffer` using an `array` of bytes in the range `0`  `255`.
             * Array entries outside that range will be truncated to fit into it.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * // Creates a new Buffer containing the UTF-8 bytes of the string 'buffer'.
             * const buf = Buffer.from([0x62, 0x75, 0x66, 0x66, 0x65, 0x72]);
             * ```
             *
             * If `array` is an `Array`-like object (that is, one with a `length` property of
             * type `number`), it is treated as if it is an array, unless it is a `Buffer` or
             * a `Uint8Array`. This means all other `TypedArray` variants get treated as an
             * `Array`. To create a `Buffer` from the bytes backing a `TypedArray`, use
             * `Buffer.copyBytesFrom()`.
             *
             * A `TypeError` will be thrown if `array` is not an `Array` or another type
             * appropriate for `Buffer.from()` variants.
             *
             * `Buffer.from(array)` and `Buffer.from(string)` may also use the internal
             * `Buffer` pool like `Buffer.allocUnsafe()` does.
             * @since v5.10.0
             */
            from(array: WithImplicitCoercion<ArrayLike<number>>): Buffer<ArrayBuffer>;
            /**
             * This creates a view of the `ArrayBuffer` without copying the underlying
             * memory. For example, when passed a reference to the `.buffer` property of a
             * `TypedArray` instance, the newly created `Buffer` will share the same
             * allocated memory as the `TypedArray`'s underlying `ArrayBuffer`.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const arr = new Uint16Array(2);
             *
             * arr[0] = 5000;
             * arr[1] = 4000;
             *
             * // Shares memory with `arr`.
             * const buf = Buffer.from(arr.buffer);
             *
             * console.log(buf);
             * // Prints: <Buffer 88 13 a0 0f>
             *
             * // Changing the original Uint16Array changes the Buffer also.
             * arr[1] = 6000;
             *
             * console.log(buf);
             * // Prints: <Buffer 88 13 70 17>
             * ```
             *
             * The optional `byteOffset` and `length` arguments specify a memory range within
             * the `arrayBuffer` that will be shared by the `Buffer`.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const ab = new ArrayBuffer(10);
             * const buf = Buffer.from(ab, 0, 2);
             *
             * console.log(buf.length);
             * // Prints: 2
             * ```
             *
             * A `TypeError` will be thrown if `arrayBuffer` is not an `ArrayBuffer` or a
             * `SharedArrayBuffer` or another type appropriate for `Buffer.from()`
             * variants.
             *
             * It is important to remember that a backing `ArrayBuffer` can cover a range
             * of memory that extends beyond the bounds of a `TypedArray` view. A new
             * `Buffer` created using the `buffer` property of a `TypedArray` may extend
             * beyond the range of the `TypedArray`:
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const arrA = Uint8Array.from([0x63, 0x64, 0x65, 0x66]); // 4 elements
             * const arrB = new Uint8Array(arrA.buffer, 1, 2); // 2 elements
             * console.log(arrA.buffer === arrB.buffer); // true
             *
             * const buf = Buffer.from(arrB.buffer);
             * console.log(buf);
             * // Prints: <Buffer 63 64 65 66>
             * ```
             * @since v5.10.0
             * @param arrayBuffer An `ArrayBuffer`, `SharedArrayBuffer`, for example the
             * `.buffer` property of a `TypedArray`.
             * @param byteOffset Index of first byte to expose. **Default:** `0`.
             * @param length Number of bytes to expose. **Default:**
             * `arrayBuffer.byteLength - byteOffset`.
             */
            from<TArrayBuffer extends WithImplicitCoercion<ArrayBufferLike>>(
                arrayBuffer: TArrayBuffer,
                byteOffset?: number,
                length?: number,
            ): Buffer<ImplicitArrayBuffer<TArrayBuffer>>;
            /**
             * Creates a new `Buffer` containing `string`. The `encoding` parameter identifies
             * the character encoding to be used when converting `string` into bytes.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf1 = Buffer.from('this is a tst');
             * const buf2 = Buffer.from('7468697320697320612074c3a97374', 'hex');
             *
             * console.log(buf1.toString());
             * // Prints: this is a tst
             * console.log(buf2.toString());
             * // Prints: this is a tst
             * console.log(buf1.toString('latin1'));
             * // Prints: this is a tst
             * ```
             *
             * A `TypeError` will be thrown if `string` is not a string or another type
             * appropriate for `Buffer.from()` variants.
             *
             * `Buffer.from(string)` may also use the internal `Buffer` pool like
             * `Buffer.allocUnsafe()` does.
             * @since v5.10.0
             * @param string A string to encode.
             * @param encoding The encoding of `string`. **Default:** `'utf8'`.
             */
            from(string: WithImplicitCoercion<string>, encoding?: BufferEncoding): Buffer<ArrayBuffer>;
            from(arrayOrString: WithImplicitCoercion<ArrayLike<number> | string>): Buffer<ArrayBuffer>;
            /**
             * Creates a new Buffer using the passed {data}
             * @param values to create a new Buffer
             */
            of(...items: number[]): Buffer<ArrayBuffer>;
            /**
             * Returns a new `Buffer` which is the result of concatenating all the `Buffer` instances in the `list` together.
             *
             * If the list has no items, or if the `totalLength` is 0, then a new zero-length `Buffer` is returned.
             *
             * If `totalLength` is not provided, it is calculated from the `Buffer` instances
             * in `list` by adding their lengths.
             *
             * If `totalLength` is provided, it is coerced to an unsigned integer. If the
             * combined length of the `Buffer`s in `list` exceeds `totalLength`, the result is
             * truncated to `totalLength`. If the combined length of the `Buffer`s in `list` is
             * less than `totalLength`, the remaining space is filled with zeros.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * // Create a single `Buffer` from a list of three `Buffer` instances.
             *
             * const buf1 = Buffer.alloc(10);
             * const buf2 = Buffer.alloc(14);
             * const buf3 = Buffer.alloc(18);
             * const totalLength = buf1.length + buf2.length + buf3.length;
             *
             * console.log(totalLength);
             * // Prints: 42
             *
             * const bufA = Buffer.concat([buf1, buf2, buf3], totalLength);
             *
             * console.log(bufA);
             * // Prints: <Buffer 00 00 00 00 ...>
             * console.log(bufA.length);
             * // Prints: 42
             * ```
             *
             * `Buffer.concat()` may also use the internal `Buffer` pool like `Buffer.allocUnsafe()` does.
             * @since v0.7.11
             * @param list List of `Buffer` or {@link Uint8Array} instances to concatenate.
             * @param totalLength Total length of the `Buffer` instances in `list` when concatenated.
             */
            concat(list: readonly Uint8Array[], totalLength?: number): Buffer<ArrayBuffer>;
            /**
             * Copies the underlying memory of `view` into a new `Buffer`.
             *
             * ```js
             * const u16 = new Uint16Array([0, 0xffff]);
             * const buf = Buffer.copyBytesFrom(u16, 1, 1);
             * u16[1] = 0;
             * console.log(buf.length); // 2
             * console.log(buf[0]); // 255
             * console.log(buf[1]); // 255
             * ```
             * @since v19.8.0
             * @param view The {TypedArray} to copy.
             * @param [offset=0] The starting offset within `view`.
             * @param [length=view.length - offset] The number of elements from `view` to copy.
             */
            copyBytesFrom(view: NodeJS.TypedArray, offset?: number, length?: number): Buffer<ArrayBuffer>;
            /**
             * Allocates a new `Buffer` of `size` bytes. If `fill` is `undefined`, the`Buffer` will be zero-filled.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.alloc(5);
             *
             * console.log(buf);
             * // Prints: <Buffer 00 00 00 00 00>
             * ```
             *
             * If `size` is larger than {@link constants.MAX_LENGTH} or smaller than 0, `ERR_OUT_OF_RANGE` is thrown.
             *
             * If `fill` is specified, the allocated `Buffer` will be initialized by calling `buf.fill(fill)`.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.alloc(5, 'a');
             *
             * console.log(buf);
             * // Prints: <Buffer 61 61 61 61 61>
             * ```
             *
             * If both `fill` and `encoding` are specified, the allocated `Buffer` will be
             * initialized by calling `buf.fill(fill, encoding)`.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.alloc(11, 'aGVsbG8gd29ybGQ=', 'base64');
             *
             * console.log(buf);
             * // Prints: <Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64>
             * ```
             *
             * Calling `Buffer.alloc()` can be measurably slower than the alternative `Buffer.allocUnsafe()` but ensures that the newly created `Buffer` instance
             * contents will never contain sensitive data from previous allocations, including
             * data that might not have been allocated for `Buffer`s.
             *
             * A `TypeError` will be thrown if `size` is not a number.
             * @since v5.10.0
             * @param size The desired length of the new `Buffer`.
             * @param [fill=0] A value to pre-fill the new `Buffer` with.
             * @param [encoding='utf8'] If `fill` is a string, this is its encoding.
             */
            alloc(size: number, fill?: string | Uint8Array | number, encoding?: BufferEncoding): Buffer<ArrayBuffer>;
            /**
             * Allocates a new `Buffer` of `size` bytes. If `size` is larger than {@link constants.MAX_LENGTH} or smaller than 0, `ERR_OUT_OF_RANGE` is thrown.
             *
             * The underlying memory for `Buffer` instances created in this way is _not_
             * _initialized_. The contents of the newly created `Buffer` are unknown and _may contain sensitive data_. Use `Buffer.alloc()` instead to initialize`Buffer` instances with zeroes.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(10);
             *
             * console.log(buf);
             * // Prints (contents may vary): <Buffer a0 8b 28 3f 01 00 00 00 50 32>
             *
             * buf.fill(0);
             *
             * console.log(buf);
             * // Prints: <Buffer 00 00 00 00 00 00 00 00 00 00>
             * ```
             *
             * A `TypeError` will be thrown if `size` is not a number.
             *
             * The `Buffer` module pre-allocates an internal `Buffer` instance of
             * size `Buffer.poolSize` that is used as a pool for the fast allocation of new `Buffer` instances created using `Buffer.allocUnsafe()`, `Buffer.from(array)`,
             * and `Buffer.concat()` only when `size` is less than `Buffer.poolSize >>> 1` (floor of `Buffer.poolSize` divided by two).
             *
             * Use of this pre-allocated internal memory pool is a key difference between
             * calling `Buffer.alloc(size, fill)` vs. `Buffer.allocUnsafe(size).fill(fill)`.
             * Specifically, `Buffer.alloc(size, fill)` will _never_ use the internal `Buffer`pool, while `Buffer.allocUnsafe(size).fill(fill)`_will_ use the internal`Buffer` pool if `size` is less
             * than or equal to half `Buffer.poolSize`. The
             * difference is subtle but can be important when an application requires the
             * additional performance that `Buffer.allocUnsafe()` provides.
             * @since v5.10.0
             * @param size The desired length of the new `Buffer`.
             */
            allocUnsafe(size: number): Buffer<ArrayBuffer>;
            /**
             * Allocates a new `Buffer` of `size` bytes. If `size` is larger than {@link constants.MAX_LENGTH} or smaller than 0, `ERR_OUT_OF_RANGE` is thrown. A zero-length `Buffer` is created if
             * `size` is 0.
             *
             * The underlying memory for `Buffer` instances created in this way is _not_
             * _initialized_. The contents of the newly created `Buffer` are unknown and _may contain sensitive data_. Use `buf.fill(0)` to initialize
             * such `Buffer` instances with zeroes.
             *
             * When using `Buffer.allocUnsafe()` to allocate new `Buffer` instances,
             * allocations under 4 KiB are sliced from a single pre-allocated `Buffer`. This
             * allows applications to avoid the garbage collection overhead of creating many
             * individually allocated `Buffer` instances. This approach improves both
             * performance and memory usage by eliminating the need to track and clean up as
             * many individual `ArrayBuffer` objects.
             *
             * However, in the case where a developer may need to retain a small chunk of
             * memory from a pool for an indeterminate amount of time, it may be appropriate
             * to create an un-pooled `Buffer` instance using `Buffer.allocUnsafeSlow()` and
             * then copying out the relevant bits.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * // Need to keep around a few small chunks of memory.
             * const store = [];
             *
             * socket.on('readable', () => {
             *   let data;
             *   while (null !== (data = readable.read())) {
             *     // Allocate for retained data.
             *     const sb = Buffer.allocUnsafeSlow(10);
             *
             *     // Copy the data into the new allocation.
             *     data.copy(sb, 0, 0, 10);
             *
             *     store.push(sb);
             *   }
             * });
             * ```
             *
             * A `TypeError` will be thrown if `size` is not a number.
             * @since v5.12.0
             * @param size The desired length of the new `Buffer`.
             */
            allocUnsafeSlow(size: number): Buffer<ArrayBuffer>;
        }
        interface Buffer<TArrayBuffer extends ArrayBufferLike = ArrayBufferLike> extends Uint8Array<TArrayBuffer> {
            // see buffer.d.ts for implementation shared with all TypeScript versions

            /**
             * Returns a new `Buffer` that references the same memory as the original, but
             * offset and cropped by the `start` and `end` indices.
             *
             * This method is not compatible with the `Uint8Array.prototype.slice()`,
             * which is a superclass of `Buffer`. To copy the slice, use`Uint8Array.prototype.slice()`.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from('buffer');
             *
             * const copiedBuf = Uint8Array.prototype.slice.call(buf);
             * copiedBuf[0]++;
             * console.log(copiedBuf.toString());
             * // Prints: cuffer
             *
             * console.log(buf.toString());
             * // Prints: buffer
             *
             * // With buf.slice(), the original buffer is modified.
             * const notReallyCopiedBuf = buf.slice();
             * notReallyCopiedBuf[0]++;
             * console.log(notReallyCopiedBuf.toString());
             * // Prints: cuffer
             * console.log(buf.toString());
             * // Also prints: cuffer (!)
             * ```
             * @since v0.3.0
             * @deprecated Use `subarray` instead.
             * @param [start=0] Where the new `Buffer` will start.
             * @param [end=buf.length] Where the new `Buffer` will end (not inclusive).
             */
            slice(start?: number, end?: number): Buffer<ArrayBuffer>;
            /**
             * Returns a new `Buffer` that references the same memory as the original, but
             * offset and cropped by the `start` and `end` indices.
             *
             * Specifying `end` greater than `buf.length` will return the same result as
             * that of `end` equal to `buf.length`.
             *
             * This method is inherited from [`TypedArray.prototype.subarray()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/subarray).
             *
             * Modifying the new `Buffer` slice will modify the memory in the original `Buffer`because the allocated memory of the two objects overlap.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * // Create a `Buffer` with the ASCII alphabet, take a slice, and modify one byte
             * // from the original `Buffer`.
             *
             * const buf1 = Buffer.allocUnsafe(26);
             *
             * for (let i = 0; i < 26; i++) {
             *   // 97 is the decimal ASCII value for 'a'.
             *   buf1[i] = i + 97;
             * }
             *
             * const buf2 = buf1.subarray(0, 3);
             *
             * console.log(buf2.toString('ascii', 0, buf2.length));
             * // Prints: abc
             *
             * buf1[0] = 33;
             *
             * console.log(buf2.toString('ascii', 0, buf2.length));
             * // Prints: !bc
             * ```
             *
             * Specifying negative indexes causes the slice to be generated relative to the
             * end of `buf` rather than the beginning.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from('buffer');
             *
             * console.log(buf.subarray(-6, -1).toString());
             * // Prints: buffe
             * // (Equivalent to buf.subarray(0, 5).)
             *
             * console.log(buf.subarray(-6, -2).toString());
             * // Prints: buff
             * // (Equivalent to buf.subarray(0, 4).)
             *
             * console.log(buf.subarray(-5, -2).toString());
             * // Prints: uff
             * // (Equivalent to buf.subarray(1, 4).)
             * ```
             * @since v3.0.0
             * @param [start=0] Where the new `Buffer` will start.
             * @param [end=buf.length] Where the new `Buffer` will end (not inclusive).
             */
            subarray(start?: number, end?: number): Buffer<TArrayBuffer>;
        }
        type NonSharedBuffer = Buffer<ArrayBuffer>;
        type AllowSharedBuffer = Buffer<ArrayBufferLike>;
    }
    /** @deprecated Use `Buffer.allocUnsafeSlow()` instead. */
    var SlowBuffer: {
        /** @deprecated Use `Buffer.allocUnsafeSlow()` instead. */
        new(size: number): Buffer<ArrayBuffer>;
        prototype: Buffer;
    };
}

```

## ./lib/lambda/node_modules/@types/node/buffer.d.ts

```typescript
// If lib.dom.d.ts or lib.webworker.d.ts is loaded, then use the global types.
// Otherwise, use the types from node.
type _Blob = typeof globalThis extends { onmessage: any; Blob: any } ? {} : import("buffer").Blob;
type _File = typeof globalThis extends { onmessage: any; File: any } ? {} : import("buffer").File;

/**
 * `Buffer` objects are used to represent a fixed-length sequence of bytes. Many
 * Node.js APIs support `Buffer`s.
 *
 * The `Buffer` class is a subclass of JavaScript's [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array) class and
 * extends it with methods that cover additional use cases. Node.js APIs accept
 * plain [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array) s wherever `Buffer`s are supported as well.
 *
 * While the `Buffer` class is available within the global scope, it is still
 * recommended to explicitly reference it via an import or require statement.
 *
 * ```js
 * import { Buffer } from 'node:buffer';
 *
 * // Creates a zero-filled Buffer of length 10.
 * const buf1 = Buffer.alloc(10);
 *
 * // Creates a Buffer of length 10,
 * // filled with bytes which all have the value `1`.
 * const buf2 = Buffer.alloc(10, 1);
 *
 * // Creates an uninitialized buffer of length 10.
 * // This is faster than calling Buffer.alloc() but the returned
 * // Buffer instance might contain old data that needs to be
 * // overwritten using fill(), write(), or other functions that fill the Buffer's
 * // contents.
 * const buf3 = Buffer.allocUnsafe(10);
 *
 * // Creates a Buffer containing the bytes [1, 2, 3].
 * const buf4 = Buffer.from([1, 2, 3]);
 *
 * // Creates a Buffer containing the bytes [1, 1, 1, 1]  the entries
 * // are all truncated using `(value &#x26; 255)` to fit into the range 0255.
 * const buf5 = Buffer.from([257, 257.5, -255, '1']);
 *
 * // Creates a Buffer containing the UTF-8-encoded bytes for the string 'tst':
 * // [0x74, 0xc3, 0xa9, 0x73, 0x74] (in hexadecimal notation)
 * // [116, 195, 169, 115, 116] (in decimal notation)
 * const buf6 = Buffer.from('tst');
 *
 * // Creates a Buffer containing the Latin-1 bytes [0x74, 0xe9, 0x73, 0x74].
 * const buf7 = Buffer.from('tst', 'latin1');
 * ```
 * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/buffer.js)
 */
declare module "buffer" {
    import { BinaryLike } from "node:crypto";
    import { ReadableStream as WebReadableStream } from "node:stream/web";
    /**
     * This function returns `true` if `input` contains only valid UTF-8-encoded data,
     * including the case in which `input` is empty.
     *
     * Throws if the `input` is a detached array buffer.
     * @since v19.4.0, v18.14.0
     * @param input The input to validate.
     */
    export function isUtf8(input: Buffer | ArrayBuffer | NodeJS.TypedArray): boolean;
    /**
     * This function returns `true` if `input` contains only valid ASCII-encoded data,
     * including the case in which `input` is empty.
     *
     * Throws if the `input` is a detached array buffer.
     * @since v19.6.0, v18.15.0
     * @param input The input to validate.
     */
    export function isAscii(input: Buffer | ArrayBuffer | NodeJS.TypedArray): boolean;
    export let INSPECT_MAX_BYTES: number;
    export const kMaxLength: number;
    export const kStringMaxLength: number;
    export const constants: {
        MAX_LENGTH: number;
        MAX_STRING_LENGTH: number;
    };
    export type TranscodeEncoding =
        | "ascii"
        | "utf8"
        | "utf-8"
        | "utf16le"
        | "utf-16le"
        | "ucs2"
        | "ucs-2"
        | "latin1"
        | "binary";
    /**
     * Re-encodes the given `Buffer` or `Uint8Array` instance from one character
     * encoding to another. Returns a new `Buffer` instance.
     *
     * Throws if the `fromEnc` or `toEnc` specify invalid character encodings or if
     * conversion from `fromEnc` to `toEnc` is not permitted.
     *
     * Encodings supported by `buffer.transcode()` are: `'ascii'`, `'utf8'`, `'utf16le'`, `'ucs2'`, `'latin1'`, and `'binary'`.
     *
     * The transcoding process will use substitution characters if a given byte
     * sequence cannot be adequately represented in the target encoding. For instance:
     *
     * ```js
     * import { Buffer, transcode } from 'node:buffer';
     *
     * const newBuf = transcode(Buffer.from(''), 'utf8', 'ascii');
     * console.log(newBuf.toString('ascii'));
     * // Prints: '?'
     * ```
     *
     * Because the Euro (``) sign is not representable in US-ASCII, it is replaced
     * with `?` in the transcoded `Buffer`.
     * @since v7.1.0
     * @param source A `Buffer` or `Uint8Array` instance.
     * @param fromEnc The current encoding.
     * @param toEnc To target encoding.
     */
    export function transcode(source: Uint8Array, fromEnc: TranscodeEncoding, toEnc: TranscodeEncoding): Buffer;
    /**
     * Resolves a `'blob:nodedata:...'` an associated `Blob` object registered using
     * a prior call to `URL.createObjectURL()`.
     * @since v16.7.0
     * @param id A `'blob:nodedata:...` URL string returned by a prior call to `URL.createObjectURL()`.
     */
    export function resolveObjectURL(id: string): Blob | undefined;
    export { type AllowSharedBuffer, Buffer, type NonSharedBuffer };
    /**
     * @experimental
     */
    export interface BlobOptions {
        /**
         * One of either `'transparent'` or `'native'`. When set to `'native'`, line endings in string source parts
         * will be converted to the platform native line-ending as specified by `import { EOL } from 'node:os'`.
         */
        endings?: "transparent" | "native";
        /**
         * The Blob content-type. The intent is for `type` to convey
         * the MIME media type of the data, however no validation of the type format
         * is performed.
         */
        type?: string | undefined;
    }
    /**
     * A `Blob` encapsulates immutable, raw data that can be safely shared across
     * multiple worker threads.
     * @since v15.7.0, v14.18.0
     */
    export class Blob {
        /**
         * The total size of the `Blob` in bytes.
         * @since v15.7.0, v14.18.0
         */
        readonly size: number;
        /**
         * The content-type of the `Blob`.
         * @since v15.7.0, v14.18.0
         */
        readonly type: string;
        /**
         * Creates a new `Blob` object containing a concatenation of the given sources.
         *
         * {ArrayBuffer}, {TypedArray}, {DataView}, and {Buffer} sources are copied into
         * the 'Blob' and can therefore be safely modified after the 'Blob' is created.
         *
         * String sources are also copied into the `Blob`.
         */
        constructor(sources: Array<ArrayBuffer | BinaryLike | Blob>, options?: BlobOptions);
        /**
         * Returns a promise that fulfills with an [ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) containing a copy of
         * the `Blob` data.
         * @since v15.7.0, v14.18.0
         */
        arrayBuffer(): Promise<ArrayBuffer>;
        /**
         * The `blob.bytes()` method returns the byte of the `Blob` object as a `Promise<Uint8Array>`.
         *
         * ```js
         * const blob = new Blob(['hello']);
         * blob.bytes().then((bytes) => {
         *   console.log(bytes); // Outputs: Uint8Array(5) [ 104, 101, 108, 108, 111 ]
         * });
         * ```
         */
        bytes(): Promise<Uint8Array>;
        /**
         * Creates and returns a new `Blob` containing a subset of this `Blob` objects
         * data. The original `Blob` is not altered.
         * @since v15.7.0, v14.18.0
         * @param start The starting index.
         * @param end The ending index.
         * @param type The content-type for the new `Blob`
         */
        slice(start?: number, end?: number, type?: string): Blob;
        /**
         * Returns a promise that fulfills with the contents of the `Blob` decoded as a
         * UTF-8 string.
         * @since v15.7.0, v14.18.0
         */
        text(): Promise<string>;
        /**
         * Returns a new `ReadableStream` that allows the content of the `Blob` to be read.
         * @since v16.7.0
         */
        stream(): WebReadableStream;
    }
    export interface FileOptions {
        /**
         * One of either `'transparent'` or `'native'`. When set to `'native'`, line endings in string source parts will be
         * converted to the platform native line-ending as specified by `import { EOL } from 'node:os'`.
         */
        endings?: "native" | "transparent";
        /** The File content-type. */
        type?: string;
        /** The last modified date of the file. `Default`: Date.now(). */
        lastModified?: number;
    }
    /**
     * A [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File) provides information about files.
     * @since v19.2.0, v18.13.0
     */
    export class File extends Blob {
        constructor(sources: Array<BinaryLike | Blob>, fileName: string, options?: FileOptions);
        /**
         * The name of the `File`.
         * @since v19.2.0, v18.13.0
         */
        readonly name: string;
        /**
         * The last modified date of the `File`.
         * @since v19.2.0, v18.13.0
         */
        readonly lastModified: number;
    }
    export import atob = globalThis.atob;
    export import btoa = globalThis.btoa;
    export type WithImplicitCoercion<T> =
        | T
        | { valueOf(): T }
        | (T extends string ? { [Symbol.toPrimitive](hint: "string"): T } : never);
    global {
        namespace NodeJS {
            export { BufferEncoding };
        }
        // Buffer class
        type BufferEncoding =
            | "ascii"
            | "utf8"
            | "utf-8"
            | "utf16le"
            | "utf-16le"
            | "ucs2"
            | "ucs-2"
            | "base64"
            | "base64url"
            | "latin1"
            | "binary"
            | "hex";
        /**
         * Raw data is stored in instances of the Buffer class.
         * A Buffer is similar to an array of integers but corresponds to a raw memory allocation outside the V8 heap.  A Buffer cannot be resized.
         * Valid string encodings: 'ascii'|'utf8'|'utf16le'|'ucs2'(alias of 'utf16le')|'base64'|'base64url'|'binary'(deprecated)|'hex'
         */
        interface BufferConstructor {
            // see buffer.buffer.d.ts for implementation specific to TypeScript 5.7 and later
            // see ts5.6/buffer.buffer.d.ts for implementation specific to TypeScript 5.6 and earlier

            /**
             * Returns `true` if `obj` is a `Buffer`, `false` otherwise.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * Buffer.isBuffer(Buffer.alloc(10)); // true
             * Buffer.isBuffer(Buffer.from('foo')); // true
             * Buffer.isBuffer('a string'); // false
             * Buffer.isBuffer([]); // false
             * Buffer.isBuffer(new Uint8Array(1024)); // false
             * ```
             * @since v0.1.101
             */
            isBuffer(obj: any): obj is Buffer;
            /**
             * Returns `true` if `encoding` is the name of a supported character encoding,
             * or `false` otherwise.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * console.log(Buffer.isEncoding('utf8'));
             * // Prints: true
             *
             * console.log(Buffer.isEncoding('hex'));
             * // Prints: true
             *
             * console.log(Buffer.isEncoding('utf/8'));
             * // Prints: false
             *
             * console.log(Buffer.isEncoding(''));
             * // Prints: false
             * ```
             * @since v0.9.1
             * @param encoding A character encoding name to check.
             */
            isEncoding(encoding: string): encoding is BufferEncoding;
            /**
             * Returns the byte length of a string when encoded using `encoding`.
             * This is not the same as [`String.prototype.length`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length), which does not account
             * for the encoding that is used to convert the string into bytes.
             *
             * For `'base64'`, `'base64url'`, and `'hex'`, this function assumes valid input.
             * For strings that contain non-base64/hex-encoded data (e.g. whitespace), the
             * return value might be greater than the length of a `Buffer` created from the
             * string.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const str = '\u00bd + \u00bc = \u00be';
             *
             * console.log(`${str}: ${str.length} characters, ` +
             *             `${Buffer.byteLength(str, 'utf8')} bytes`);
             * // Prints:  +  = : 9 characters, 12 bytes
             * ```
             *
             * When `string` is a
             * `Buffer`/[`DataView`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)/[`TypedArray`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/-
             * Reference/Global_Objects/TypedArray)/[`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)/[`SharedArrayBuffer`](https://develop-
             * er.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer), the byte length as reported by `.byteLength`is returned.
             * @since v0.1.90
             * @param string A value to calculate the length of.
             * @param [encoding='utf8'] If `string` is a string, this is its encoding.
             * @return The number of bytes contained within `string`.
             */
            byteLength(
                string: string | Buffer | NodeJS.ArrayBufferView | ArrayBuffer | SharedArrayBuffer,
                encoding?: BufferEncoding,
            ): number;
            /**
             * Compares `buf1` to `buf2`, typically for the purpose of sorting arrays of `Buffer` instances. This is equivalent to calling `buf1.compare(buf2)`.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf1 = Buffer.from('1234');
             * const buf2 = Buffer.from('0123');
             * const arr = [buf1, buf2];
             *
             * console.log(arr.sort(Buffer.compare));
             * // Prints: [ <Buffer 30 31 32 33>, <Buffer 31 32 33 34> ]
             * // (This result is equal to: [buf2, buf1].)
             * ```
             * @since v0.11.13
             * @return Either `-1`, `0`, or `1`, depending on the result of the comparison. See `compare` for details.
             */
            compare(buf1: Uint8Array, buf2: Uint8Array): -1 | 0 | 1;
            /**
             * This is the size (in bytes) of pre-allocated internal `Buffer` instances used
             * for pooling. This value may be modified.
             * @since v0.11.3
             */
            poolSize: number;
        }
        interface Buffer {
            // see buffer.buffer.d.ts for implementation specific to TypeScript 5.7 and later
            // see ts5.6/buffer.buffer.d.ts for implementation specific to TypeScript 5.6 and earlier

            /**
             * Writes `string` to `buf` at `offset` according to the character encoding in`encoding`. The `length` parameter is the number of bytes to write. If `buf` did
             * not contain enough space to fit the entire string, only part of `string` will be
             * written. However, partially encoded characters will not be written.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.alloc(256);
             *
             * const len = buf.write('\u00bd + \u00bc = \u00be', 0);
             *
             * console.log(`${len} bytes: ${buf.toString('utf8', 0, len)}`);
             * // Prints: 12 bytes:  +  = 
             *
             * const buffer = Buffer.alloc(10);
             *
             * const length = buffer.write('abcd', 8);
             *
             * console.log(`${length} bytes: ${buffer.toString('utf8', 8, 10)}`);
             * // Prints: 2 bytes : ab
             * ```
             * @since v0.1.90
             * @param string String to write to `buf`.
             * @param [offset=0] Number of bytes to skip before starting to write `string`.
             * @param [length=buf.length - offset] Maximum number of bytes to write (written bytes will not exceed `buf.length - offset`).
             * @param [encoding='utf8'] The character encoding of `string`.
             * @return Number of bytes written.
             */
            write(string: string, encoding?: BufferEncoding): number;
            write(string: string, offset: number, encoding?: BufferEncoding): number;
            write(string: string, offset: number, length: number, encoding?: BufferEncoding): number;
            /**
             * Decodes `buf` to a string according to the specified character encoding in`encoding`. `start` and `end` may be passed to decode only a subset of `buf`.
             *
             * If `encoding` is `'utf8'` and a byte sequence in the input is not valid UTF-8,
             * then each invalid byte is replaced with the replacement character `U+FFFD`.
             *
             * The maximum length of a string instance (in UTF-16 code units) is available
             * as {@link constants.MAX_STRING_LENGTH}.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf1 = Buffer.allocUnsafe(26);
             *
             * for (let i = 0; i < 26; i++) {
             *   // 97 is the decimal ASCII value for 'a'.
             *   buf1[i] = i + 97;
             * }
             *
             * console.log(buf1.toString('utf8'));
             * // Prints: abcdefghijklmnopqrstuvwxyz
             * console.log(buf1.toString('utf8', 0, 5));
             * // Prints: abcde
             *
             * const buf2 = Buffer.from('tst');
             *
             * console.log(buf2.toString('hex'));
             * // Prints: 74c3a97374
             * console.log(buf2.toString('utf8', 0, 3));
             * // Prints: t
             * console.log(buf2.toString(undefined, 0, 3));
             * // Prints: t
             * ```
             * @since v0.1.90
             * @param [encoding='utf8'] The character encoding to use.
             * @param [start=0] The byte offset to start decoding at.
             * @param [end=buf.length] The byte offset to stop decoding at (not inclusive).
             */
            toString(encoding?: BufferEncoding, start?: number, end?: number): string;
            /**
             * Returns a JSON representation of `buf`. [`JSON.stringify()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify) implicitly calls
             * this function when stringifying a `Buffer` instance.
             *
             * `Buffer.from()` accepts objects in the format returned from this method.
             * In particular, `Buffer.from(buf.toJSON())` works like `Buffer.from(buf)`.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]);
             * const json = JSON.stringify(buf);
             *
             * console.log(json);
             * // Prints: {"type":"Buffer","data":[1,2,3,4,5]}
             *
             * const copy = JSON.parse(json, (key, value) => {
             *   return value &#x26;&#x26; value.type === 'Buffer' ?
             *     Buffer.from(value) :
             *     value;
             * });
             *
             * console.log(copy);
             * // Prints: <Buffer 01 02 03 04 05>
             * ```
             * @since v0.9.2
             */
            toJSON(): {
                type: "Buffer";
                data: number[];
            };
            /**
             * Returns `true` if both `buf` and `otherBuffer` have exactly the same bytes,`false` otherwise. Equivalent to `buf.compare(otherBuffer) === 0`.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf1 = Buffer.from('ABC');
             * const buf2 = Buffer.from('414243', 'hex');
             * const buf3 = Buffer.from('ABCD');
             *
             * console.log(buf1.equals(buf2));
             * // Prints: true
             * console.log(buf1.equals(buf3));
             * // Prints: false
             * ```
             * @since v0.11.13
             * @param otherBuffer A `Buffer` or {@link Uint8Array} with which to compare `buf`.
             */
            equals(otherBuffer: Uint8Array): boolean;
            /**
             * Compares `buf` with `target` and returns a number indicating whether `buf`comes before, after, or is the same as `target` in sort order.
             * Comparison is based on the actual sequence of bytes in each `Buffer`.
             *
             * * `0` is returned if `target` is the same as `buf`
             * * `1` is returned if `target` should come _before_`buf` when sorted.
             * * `-1` is returned if `target` should come _after_`buf` when sorted.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf1 = Buffer.from('ABC');
             * const buf2 = Buffer.from('BCD');
             * const buf3 = Buffer.from('ABCD');
             *
             * console.log(buf1.compare(buf1));
             * // Prints: 0
             * console.log(buf1.compare(buf2));
             * // Prints: -1
             * console.log(buf1.compare(buf3));
             * // Prints: -1
             * console.log(buf2.compare(buf1));
             * // Prints: 1
             * console.log(buf2.compare(buf3));
             * // Prints: 1
             * console.log([buf1, buf2, buf3].sort(Buffer.compare));
             * // Prints: [ <Buffer 41 42 43>, <Buffer 41 42 43 44>, <Buffer 42 43 44> ]
             * // (This result is equal to: [buf1, buf3, buf2].)
             * ```
             *
             * The optional `targetStart`, `targetEnd`, `sourceStart`, and `sourceEnd` arguments can be used to limit the comparison to specific ranges within `target` and `buf` respectively.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf1 = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8, 9]);
             * const buf2 = Buffer.from([5, 6, 7, 8, 9, 1, 2, 3, 4]);
             *
             * console.log(buf1.compare(buf2, 5, 9, 0, 4));
             * // Prints: 0
             * console.log(buf1.compare(buf2, 0, 6, 4));
             * // Prints: -1
             * console.log(buf1.compare(buf2, 5, 6, 5));
             * // Prints: 1
             * ```
             *
             * `ERR_OUT_OF_RANGE` is thrown if `targetStart < 0`, `sourceStart < 0`, `targetEnd > target.byteLength`, or `sourceEnd > source.byteLength`.
             * @since v0.11.13
             * @param target A `Buffer` or {@link Uint8Array} with which to compare `buf`.
             * @param [targetStart=0] The offset within `target` at which to begin comparison.
             * @param [targetEnd=target.length] The offset within `target` at which to end comparison (not inclusive).
             * @param [sourceStart=0] The offset within `buf` at which to begin comparison.
             * @param [sourceEnd=buf.length] The offset within `buf` at which to end comparison (not inclusive).
             */
            compare(
                target: Uint8Array,
                targetStart?: number,
                targetEnd?: number,
                sourceStart?: number,
                sourceEnd?: number,
            ): -1 | 0 | 1;
            /**
             * Copies data from a region of `buf` to a region in `target`, even if the `target`memory region overlaps with `buf`.
             *
             * [`TypedArray.prototype.set()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set) performs the same operation, and is available
             * for all TypedArrays, including Node.js `Buffer`s, although it takes
             * different function arguments.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * // Create two `Buffer` instances.
             * const buf1 = Buffer.allocUnsafe(26);
             * const buf2 = Buffer.allocUnsafe(26).fill('!');
             *
             * for (let i = 0; i < 26; i++) {
             *   // 97 is the decimal ASCII value for 'a'.
             *   buf1[i] = i + 97;
             * }
             *
             * // Copy `buf1` bytes 16 through 19 into `buf2` starting at byte 8 of `buf2`.
             * buf1.copy(buf2, 8, 16, 20);
             * // This is equivalent to:
             * // buf2.set(buf1.subarray(16, 20), 8);
             *
             * console.log(buf2.toString('ascii', 0, 25));
             * // Prints: !!!!!!!!qrst!!!!!!!!!!!!!
             * ```
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * // Create a `Buffer` and copy data from one region to an overlapping region
             * // within the same `Buffer`.
             *
             * const buf = Buffer.allocUnsafe(26);
             *
             * for (let i = 0; i < 26; i++) {
             *   // 97 is the decimal ASCII value for 'a'.
             *   buf[i] = i + 97;
             * }
             *
             * buf.copy(buf, 0, 4, 10);
             *
             * console.log(buf.toString());
             * // Prints: efghijghijklmnopqrstuvwxyz
             * ```
             * @since v0.1.90
             * @param target A `Buffer` or {@link Uint8Array} to copy into.
             * @param [targetStart=0] The offset within `target` at which to begin writing.
             * @param [sourceStart=0] The offset within `buf` from which to begin copying.
             * @param [sourceEnd=buf.length] The offset within `buf` at which to stop copying (not inclusive).
             * @return The number of bytes copied.
             */
            copy(target: Uint8Array, targetStart?: number, sourceStart?: number, sourceEnd?: number): number;
            /**
             * Writes `value` to `buf` at the specified `offset` as big-endian.
             *
             * `value` is interpreted and written as a two's complement signed integer.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(8);
             *
             * buf.writeBigInt64BE(0x0102030405060708n, 0);
             *
             * console.log(buf);
             * // Prints: <Buffer 01 02 03 04 05 06 07 08>
             * ```
             * @since v12.0.0, v10.20.0
             * @param value Number to be written to `buf`.
             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy: `0 <= offset <= buf.length - 8`.
             * @return `offset` plus the number of bytes written.
             */
            writeBigInt64BE(value: bigint, offset?: number): number;
            /**
             * Writes `value` to `buf` at the specified `offset` as little-endian.
             *
             * `value` is interpreted and written as a two's complement signed integer.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(8);
             *
             * buf.writeBigInt64LE(0x0102030405060708n, 0);
             *
             * console.log(buf);
             * // Prints: <Buffer 08 07 06 05 04 03 02 01>
             * ```
             * @since v12.0.0, v10.20.0
             * @param value Number to be written to `buf`.
             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy: `0 <= offset <= buf.length - 8`.
             * @return `offset` plus the number of bytes written.
             */
            writeBigInt64LE(value: bigint, offset?: number): number;
            /**
             * Writes `value` to `buf` at the specified `offset` as big-endian.
             *
             * This function is also available under the `writeBigUint64BE` alias.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(8);
             *
             * buf.writeBigUInt64BE(0xdecafafecacefaden, 0);
             *
             * console.log(buf);
             * // Prints: <Buffer de ca fa fe ca ce fa de>
             * ```
             * @since v12.0.0, v10.20.0
             * @param value Number to be written to `buf`.
             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy: `0 <= offset <= buf.length - 8`.
             * @return `offset` plus the number of bytes written.
             */
            writeBigUInt64BE(value: bigint, offset?: number): number;
            /**
             * @alias Buffer.writeBigUInt64BE
             * @since v14.10.0, v12.19.0
             */
            writeBigUint64BE(value: bigint, offset?: number): number;
            /**
             * Writes `value` to `buf` at the specified `offset` as little-endian
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(8);
             *
             * buf.writeBigUInt64LE(0xdecafafecacefaden, 0);
             *
             * console.log(buf);
             * // Prints: <Buffer de fa ce ca fe fa ca de>
             * ```
             *
             * This function is also available under the `writeBigUint64LE` alias.
             * @since v12.0.0, v10.20.0
             * @param value Number to be written to `buf`.
             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy: `0 <= offset <= buf.length - 8`.
             * @return `offset` plus the number of bytes written.
             */
            writeBigUInt64LE(value: bigint, offset?: number): number;
            /**
             * @alias Buffer.writeBigUInt64LE
             * @since v14.10.0, v12.19.0
             */
            writeBigUint64LE(value: bigint, offset?: number): number;
            /**
             * Writes `byteLength` bytes of `value` to `buf` at the specified `offset`as little-endian. Supports up to 48 bits of accuracy. Behavior is undefined
             * when `value` is anything other than an unsigned integer.
             *
             * This function is also available under the `writeUintLE` alias.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(6);
             *
             * buf.writeUIntLE(0x1234567890ab, 0, 6);
             *
             * console.log(buf);
             * // Prints: <Buffer ab 90 78 56 34 12>
             * ```
             * @since v0.5.5
             * @param value Number to be written to `buf`.
             * @param offset Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`.
             * @param byteLength Number of bytes to write. Must satisfy `0 < byteLength <= 6`.
             * @return `offset` plus the number of bytes written.
             */
            writeUIntLE(value: number, offset: number, byteLength: number): number;
            /**
             * @alias Buffer.writeUIntLE
             * @since v14.9.0, v12.19.0
             */
            writeUintLE(value: number, offset: number, byteLength: number): number;
            /**
             * Writes `byteLength` bytes of `value` to `buf` at the specified `offset`as big-endian. Supports up to 48 bits of accuracy. Behavior is undefined
             * when `value` is anything other than an unsigned integer.
             *
             * This function is also available under the `writeUintBE` alias.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(6);
             *
             * buf.writeUIntBE(0x1234567890ab, 0, 6);
             *
             * console.log(buf);
             * // Prints: <Buffer 12 34 56 78 90 ab>
             * ```
             * @since v0.5.5
             * @param value Number to be written to `buf`.
             * @param offset Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`.
             * @param byteLength Number of bytes to write. Must satisfy `0 < byteLength <= 6`.
             * @return `offset` plus the number of bytes written.
             */
            writeUIntBE(value: number, offset: number, byteLength: number): number;
            /**
             * @alias Buffer.writeUIntBE
             * @since v14.9.0, v12.19.0
             */
            writeUintBE(value: number, offset: number, byteLength: number): number;
            /**
             * Writes `byteLength` bytes of `value` to `buf` at the specified `offset`as little-endian. Supports up to 48 bits of accuracy. Behavior is undefined
             * when `value` is anything other than a signed integer.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(6);
             *
             * buf.writeIntLE(0x1234567890ab, 0, 6);
             *
             * console.log(buf);
             * // Prints: <Buffer ab 90 78 56 34 12>
             * ```
             * @since v0.11.15
             * @param value Number to be written to `buf`.
             * @param offset Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`.
             * @param byteLength Number of bytes to write. Must satisfy `0 < byteLength <= 6`.
             * @return `offset` plus the number of bytes written.
             */
            writeIntLE(value: number, offset: number, byteLength: number): number;
            /**
             * Writes `byteLength` bytes of `value` to `buf` at the specified `offset`as big-endian. Supports up to 48 bits of accuracy. Behavior is undefined when`value` is anything other than a
             * signed integer.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(6);
             *
             * buf.writeIntBE(0x1234567890ab, 0, 6);
             *
             * console.log(buf);
             * // Prints: <Buffer 12 34 56 78 90 ab>
             * ```
             * @since v0.11.15
             * @param value Number to be written to `buf`.
             * @param offset Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - byteLength`.
             * @param byteLength Number of bytes to write. Must satisfy `0 < byteLength <= 6`.
             * @return `offset` plus the number of bytes written.
             */
            writeIntBE(value: number, offset: number, byteLength: number): number;
            /**
             * Reads an unsigned, big-endian 64-bit integer from `buf` at the specified`offset`.
             *
             * This function is also available under the `readBigUint64BE` alias.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from([0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff]);
             *
             * console.log(buf.readBigUInt64BE(0));
             * // Prints: 4294967295n
             * ```
             * @since v12.0.0, v10.20.0
             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy: `0 <= offset <= buf.length - 8`.
             */
            readBigUInt64BE(offset?: number): bigint;
            /**
             * @alias Buffer.readBigUInt64BE
             * @since v14.10.0, v12.19.0
             */
            readBigUint64BE(offset?: number): bigint;
            /**
             * Reads an unsigned, little-endian 64-bit integer from `buf` at the specified`offset`.
             *
             * This function is also available under the `readBigUint64LE` alias.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from([0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff]);
             *
             * console.log(buf.readBigUInt64LE(0));
             * // Prints: 18446744069414584320n
             * ```
             * @since v12.0.0, v10.20.0
             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy: `0 <= offset <= buf.length - 8`.
             */
            readBigUInt64LE(offset?: number): bigint;
            /**
             * @alias Buffer.readBigUInt64LE
             * @since v14.10.0, v12.19.0
             */
            readBigUint64LE(offset?: number): bigint;
            /**
             * Reads a signed, big-endian 64-bit integer from `buf` at the specified `offset`.
             *
             * Integers read from a `Buffer` are interpreted as two's complement signed
             * values.
             * @since v12.0.0, v10.20.0
             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy: `0 <= offset <= buf.length - 8`.
             */
            readBigInt64BE(offset?: number): bigint;
            /**
             * Reads a signed, little-endian 64-bit integer from `buf` at the specified`offset`.
             *
             * Integers read from a `Buffer` are interpreted as two's complement signed
             * values.
             * @since v12.0.0, v10.20.0
             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy: `0 <= offset <= buf.length - 8`.
             */
            readBigInt64LE(offset?: number): bigint;
            /**
             * Reads `byteLength` number of bytes from `buf` at the specified `offset` and interprets the result as an unsigned, little-endian integer supporting
             * up to 48 bits of accuracy.
             *
             * This function is also available under the `readUintLE` alias.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);
             *
             * console.log(buf.readUIntLE(0, 6).toString(16));
             * // Prints: ab9078563412
             * ```
             * @since v0.11.15
             * @param offset Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`.
             * @param byteLength Number of bytes to read. Must satisfy `0 < byteLength <= 6`.
             */
            readUIntLE(offset: number, byteLength: number): number;
            /**
             * @alias Buffer.readUIntLE
             * @since v14.9.0, v12.19.0
             */
            readUintLE(offset: number, byteLength: number): number;
            /**
             * Reads `byteLength` number of bytes from `buf` at the specified `offset` and interprets the result as an unsigned big-endian integer supporting
             * up to 48 bits of accuracy.
             *
             * This function is also available under the `readUintBE` alias.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);
             *
             * console.log(buf.readUIntBE(0, 6).toString(16));
             * // Prints: 1234567890ab
             * console.log(buf.readUIntBE(1, 6).toString(16));
             * // Throws ERR_OUT_OF_RANGE.
             * ```
             * @since v0.11.15
             * @param offset Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`.
             * @param byteLength Number of bytes to read. Must satisfy `0 < byteLength <= 6`.
             */
            readUIntBE(offset: number, byteLength: number): number;
            /**
             * @alias Buffer.readUIntBE
             * @since v14.9.0, v12.19.0
             */
            readUintBE(offset: number, byteLength: number): number;
            /**
             * Reads `byteLength` number of bytes from `buf` at the specified `offset` and interprets the result as a little-endian, two's complement signed value
             * supporting up to 48 bits of accuracy.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);
             *
             * console.log(buf.readIntLE(0, 6).toString(16));
             * // Prints: -546f87a9cbee
             * ```
             * @since v0.11.15
             * @param offset Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`.
             * @param byteLength Number of bytes to read. Must satisfy `0 < byteLength <= 6`.
             */
            readIntLE(offset: number, byteLength: number): number;
            /**
             * Reads `byteLength` number of bytes from `buf` at the specified `offset` and interprets the result as a big-endian, two's complement signed value
             * supporting up to 48 bits of accuracy.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);
             *
             * console.log(buf.readIntBE(0, 6).toString(16));
             * // Prints: 1234567890ab
             * console.log(buf.readIntBE(1, 6).toString(16));
             * // Throws ERR_OUT_OF_RANGE.
             * console.log(buf.readIntBE(1, 0).toString(16));
             * // Throws ERR_OUT_OF_RANGE.
             * ```
             * @since v0.11.15
             * @param offset Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - byteLength`.
             * @param byteLength Number of bytes to read. Must satisfy `0 < byteLength <= 6`.
             */
            readIntBE(offset: number, byteLength: number): number;
            /**
             * Reads an unsigned 8-bit integer from `buf` at the specified `offset`.
             *
             * This function is also available under the `readUint8` alias.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from([1, -2]);
             *
             * console.log(buf.readUInt8(0));
             * // Prints: 1
             * console.log(buf.readUInt8(1));
             * // Prints: 254
             * console.log(buf.readUInt8(2));
             * // Throws ERR_OUT_OF_RANGE.
             * ```
             * @since v0.5.0
             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 1`.
             */
            readUInt8(offset?: number): number;
            /**
             * @alias Buffer.readUInt8
             * @since v14.9.0, v12.19.0
             */
            readUint8(offset?: number): number;
            /**
             * Reads an unsigned, little-endian 16-bit integer from `buf` at the specified `offset`.
             *
             * This function is also available under the `readUint16LE` alias.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from([0x12, 0x34, 0x56]);
             *
             * console.log(buf.readUInt16LE(0).toString(16));
             * // Prints: 3412
             * console.log(buf.readUInt16LE(1).toString(16));
             * // Prints: 5634
             * console.log(buf.readUInt16LE(2).toString(16));
             * // Throws ERR_OUT_OF_RANGE.
             * ```
             * @since v0.5.5
             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`.
             */
            readUInt16LE(offset?: number): number;
            /**
             * @alias Buffer.readUInt16LE
             * @since v14.9.0, v12.19.0
             */
            readUint16LE(offset?: number): number;
            /**
             * Reads an unsigned, big-endian 16-bit integer from `buf` at the specified`offset`.
             *
             * This function is also available under the `readUint16BE` alias.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from([0x12, 0x34, 0x56]);
             *
             * console.log(buf.readUInt16BE(0).toString(16));
             * // Prints: 1234
             * console.log(buf.readUInt16BE(1).toString(16));
             * // Prints: 3456
             * ```
             * @since v0.5.5
             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`.
             */
            readUInt16BE(offset?: number): number;
            /**
             * @alias Buffer.readUInt16BE
             * @since v14.9.0, v12.19.0
             */
            readUint16BE(offset?: number): number;
            /**
             * Reads an unsigned, little-endian 32-bit integer from `buf` at the specified`offset`.
             *
             * This function is also available under the `readUint32LE` alias.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from([0x12, 0x34, 0x56, 0x78]);
             *
             * console.log(buf.readUInt32LE(0).toString(16));
             * // Prints: 78563412
             * console.log(buf.readUInt32LE(1).toString(16));
             * // Throws ERR_OUT_OF_RANGE.
             * ```
             * @since v0.5.5
             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`.
             */
            readUInt32LE(offset?: number): number;
            /**
             * @alias Buffer.readUInt32LE
             * @since v14.9.0, v12.19.0
             */
            readUint32LE(offset?: number): number;
            /**
             * Reads an unsigned, big-endian 32-bit integer from `buf` at the specified`offset`.
             *
             * This function is also available under the `readUint32BE` alias.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from([0x12, 0x34, 0x56, 0x78]);
             *
             * console.log(buf.readUInt32BE(0).toString(16));
             * // Prints: 12345678
             * ```
             * @since v0.5.5
             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`.
             */
            readUInt32BE(offset?: number): number;
            /**
             * @alias Buffer.readUInt32BE
             * @since v14.9.0, v12.19.0
             */
            readUint32BE(offset?: number): number;
            /**
             * Reads a signed 8-bit integer from `buf` at the specified `offset`.
             *
             * Integers read from a `Buffer` are interpreted as two's complement signed values.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from([-1, 5]);
             *
             * console.log(buf.readInt8(0));
             * // Prints: -1
             * console.log(buf.readInt8(1));
             * // Prints: 5
             * console.log(buf.readInt8(2));
             * // Throws ERR_OUT_OF_RANGE.
             * ```
             * @since v0.5.0
             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 1`.
             */
            readInt8(offset?: number): number;
            /**
             * Reads a signed, little-endian 16-bit integer from `buf` at the specified`offset`.
             *
             * Integers read from a `Buffer` are interpreted as two's complement signed values.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from([0, 5]);
             *
             * console.log(buf.readInt16LE(0));
             * // Prints: 1280
             * console.log(buf.readInt16LE(1));
             * // Throws ERR_OUT_OF_RANGE.
             * ```
             * @since v0.5.5
             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`.
             */
            readInt16LE(offset?: number): number;
            /**
             * Reads a signed, big-endian 16-bit integer from `buf` at the specified `offset`.
             *
             * Integers read from a `Buffer` are interpreted as two's complement signed values.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from([0, 5]);
             *
             * console.log(buf.readInt16BE(0));
             * // Prints: 5
             * ```
             * @since v0.5.5
             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 2`.
             */
            readInt16BE(offset?: number): number;
            /**
             * Reads a signed, little-endian 32-bit integer from `buf` at the specified`offset`.
             *
             * Integers read from a `Buffer` are interpreted as two's complement signed values.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from([0, 0, 0, 5]);
             *
             * console.log(buf.readInt32LE(0));
             * // Prints: 83886080
             * console.log(buf.readInt32LE(1));
             * // Throws ERR_OUT_OF_RANGE.
             * ```
             * @since v0.5.5
             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`.
             */
            readInt32LE(offset?: number): number;
            /**
             * Reads a signed, big-endian 32-bit integer from `buf` at the specified `offset`.
             *
             * Integers read from a `Buffer` are interpreted as two's complement signed values.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from([0, 0, 0, 5]);
             *
             * console.log(buf.readInt32BE(0));
             * // Prints: 5
             * ```
             * @since v0.5.5
             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`.
             */
            readInt32BE(offset?: number): number;
            /**
             * Reads a 32-bit, little-endian float from `buf` at the specified `offset`.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from([1, 2, 3, 4]);
             *
             * console.log(buf.readFloatLE(0));
             * // Prints: 1.539989614439558e-36
             * console.log(buf.readFloatLE(1));
             * // Throws ERR_OUT_OF_RANGE.
             * ```
             * @since v0.11.15
             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`.
             */
            readFloatLE(offset?: number): number;
            /**
             * Reads a 32-bit, big-endian float from `buf` at the specified `offset`.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from([1, 2, 3, 4]);
             *
             * console.log(buf.readFloatBE(0));
             * // Prints: 2.387939260590663e-38
             * ```
             * @since v0.11.15
             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 4`.
             */
            readFloatBE(offset?: number): number;
            /**
             * Reads a 64-bit, little-endian double from `buf` at the specified `offset`.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);
             *
             * console.log(buf.readDoubleLE(0));
             * // Prints: 5.447603722011605e-270
             * console.log(buf.readDoubleLE(1));
             * // Throws ERR_OUT_OF_RANGE.
             * ```
             * @since v0.11.15
             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 8`.
             */
            readDoubleLE(offset?: number): number;
            /**
             * Reads a 64-bit, big-endian double from `buf` at the specified `offset`.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);
             *
             * console.log(buf.readDoubleBE(0));
             * // Prints: 8.20788039913184e-304
             * ```
             * @since v0.11.15
             * @param [offset=0] Number of bytes to skip before starting to read. Must satisfy `0 <= offset <= buf.length - 8`.
             */
            readDoubleBE(offset?: number): number;
            reverse(): this;
            /**
             * Interprets `buf` as an array of unsigned 16-bit integers and swaps the
             * byte order _in-place_. Throws `ERR_INVALID_BUFFER_SIZE` if `buf.length` is not a multiple of 2.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);
             *
             * console.log(buf1);
             * // Prints: <Buffer 01 02 03 04 05 06 07 08>
             *
             * buf1.swap16();
             *
             * console.log(buf1);
             * // Prints: <Buffer 02 01 04 03 06 05 08 07>
             *
             * const buf2 = Buffer.from([0x1, 0x2, 0x3]);
             *
             * buf2.swap16();
             * // Throws ERR_INVALID_BUFFER_SIZE.
             * ```
             *
             * One convenient use of `buf.swap16()` is to perform a fast in-place conversion
             * between UTF-16 little-endian and UTF-16 big-endian:
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from('This is little-endian UTF-16', 'utf16le');
             * buf.swap16(); // Convert to big-endian UTF-16 text.
             * ```
             * @since v5.10.0
             * @return A reference to `buf`.
             */
            swap16(): this;
            /**
             * Interprets `buf` as an array of unsigned 32-bit integers and swaps the
             * byte order _in-place_. Throws `ERR_INVALID_BUFFER_SIZE` if `buf.length` is not a multiple of 4.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);
             *
             * console.log(buf1);
             * // Prints: <Buffer 01 02 03 04 05 06 07 08>
             *
             * buf1.swap32();
             *
             * console.log(buf1);
             * // Prints: <Buffer 04 03 02 01 08 07 06 05>
             *
             * const buf2 = Buffer.from([0x1, 0x2, 0x3]);
             *
             * buf2.swap32();
             * // Throws ERR_INVALID_BUFFER_SIZE.
             * ```
             * @since v5.10.0
             * @return A reference to `buf`.
             */
            swap32(): this;
            /**
             * Interprets `buf` as an array of 64-bit numbers and swaps byte order _in-place_.
             * Throws `ERR_INVALID_BUFFER_SIZE` if `buf.length` is not a multiple of 8.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);
             *
             * console.log(buf1);
             * // Prints: <Buffer 01 02 03 04 05 06 07 08>
             *
             * buf1.swap64();
             *
             * console.log(buf1);
             * // Prints: <Buffer 08 07 06 05 04 03 02 01>
             *
             * const buf2 = Buffer.from([0x1, 0x2, 0x3]);
             *
             * buf2.swap64();
             * // Throws ERR_INVALID_BUFFER_SIZE.
             * ```
             * @since v6.3.0
             * @return A reference to `buf`.
             */
            swap64(): this;
            /**
             * Writes `value` to `buf` at the specified `offset`. `value` must be a
             * valid unsigned 8-bit integer. Behavior is undefined when `value` is anything
             * other than an unsigned 8-bit integer.
             *
             * This function is also available under the `writeUint8` alias.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(4);
             *
             * buf.writeUInt8(0x3, 0);
             * buf.writeUInt8(0x4, 1);
             * buf.writeUInt8(0x23, 2);
             * buf.writeUInt8(0x42, 3);
             *
             * console.log(buf);
             * // Prints: <Buffer 03 04 23 42>
             * ```
             * @since v0.5.0
             * @param value Number to be written to `buf`.
             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 1`.
             * @return `offset` plus the number of bytes written.
             */
            writeUInt8(value: number, offset?: number): number;
            /**
             * @alias Buffer.writeUInt8
             * @since v14.9.0, v12.19.0
             */
            writeUint8(value: number, offset?: number): number;
            /**
             * Writes `value` to `buf` at the specified `offset` as little-endian. The `value` must be a valid unsigned 16-bit integer. Behavior is undefined when `value` is
             * anything other than an unsigned 16-bit integer.
             *
             * This function is also available under the `writeUint16LE` alias.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(4);
             *
             * buf.writeUInt16LE(0xdead, 0);
             * buf.writeUInt16LE(0xbeef, 2);
             *
             * console.log(buf);
             * // Prints: <Buffer ad de ef be>
             * ```
             * @since v0.5.5
             * @param value Number to be written to `buf`.
             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`.
             * @return `offset` plus the number of bytes written.
             */
            writeUInt16LE(value: number, offset?: number): number;
            /**
             * @alias Buffer.writeUInt16LE
             * @since v14.9.0, v12.19.0
             */
            writeUint16LE(value: number, offset?: number): number;
            /**
             * Writes `value` to `buf` at the specified `offset` as big-endian. The `value` must be a valid unsigned 16-bit integer. Behavior is undefined when `value`is anything other than an
             * unsigned 16-bit integer.
             *
             * This function is also available under the `writeUint16BE` alias.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(4);
             *
             * buf.writeUInt16BE(0xdead, 0);
             * buf.writeUInt16BE(0xbeef, 2);
             *
             * console.log(buf);
             * // Prints: <Buffer de ad be ef>
             * ```
             * @since v0.5.5
             * @param value Number to be written to `buf`.
             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`.
             * @return `offset` plus the number of bytes written.
             */
            writeUInt16BE(value: number, offset?: number): number;
            /**
             * @alias Buffer.writeUInt16BE
             * @since v14.9.0, v12.19.0
             */
            writeUint16BE(value: number, offset?: number): number;
            /**
             * Writes `value` to `buf` at the specified `offset` as little-endian. The `value` must be a valid unsigned 32-bit integer. Behavior is undefined when `value` is
             * anything other than an unsigned 32-bit integer.
             *
             * This function is also available under the `writeUint32LE` alias.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(4);
             *
             * buf.writeUInt32LE(0xfeedface, 0);
             *
             * console.log(buf);
             * // Prints: <Buffer ce fa ed fe>
             * ```
             * @since v0.5.5
             * @param value Number to be written to `buf`.
             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`.
             * @return `offset` plus the number of bytes written.
             */
            writeUInt32LE(value: number, offset?: number): number;
            /**
             * @alias Buffer.writeUInt32LE
             * @since v14.9.0, v12.19.0
             */
            writeUint32LE(value: number, offset?: number): number;
            /**
             * Writes `value` to `buf` at the specified `offset` as big-endian. The `value` must be a valid unsigned 32-bit integer. Behavior is undefined when `value`is anything other than an
             * unsigned 32-bit integer.
             *
             * This function is also available under the `writeUint32BE` alias.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(4);
             *
             * buf.writeUInt32BE(0xfeedface, 0);
             *
             * console.log(buf);
             * // Prints: <Buffer fe ed fa ce>
             * ```
             * @since v0.5.5
             * @param value Number to be written to `buf`.
             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`.
             * @return `offset` plus the number of bytes written.
             */
            writeUInt32BE(value: number, offset?: number): number;
            /**
             * @alias Buffer.writeUInt32BE
             * @since v14.9.0, v12.19.0
             */
            writeUint32BE(value: number, offset?: number): number;
            /**
             * Writes `value` to `buf` at the specified `offset`. `value` must be a valid
             * signed 8-bit integer. Behavior is undefined when `value` is anything other than
             * a signed 8-bit integer.
             *
             * `value` is interpreted and written as a two's complement signed integer.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(2);
             *
             * buf.writeInt8(2, 0);
             * buf.writeInt8(-2, 1);
             *
             * console.log(buf);
             * // Prints: <Buffer 02 fe>
             * ```
             * @since v0.5.0
             * @param value Number to be written to `buf`.
             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 1`.
             * @return `offset` plus the number of bytes written.
             */
            writeInt8(value: number, offset?: number): number;
            /**
             * Writes `value` to `buf` at the specified `offset` as little-endian.  The `value` must be a valid signed 16-bit integer. Behavior is undefined when `value` is
             * anything other than a signed 16-bit integer.
             *
             * The `value` is interpreted and written as a two's complement signed integer.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(2);
             *
             * buf.writeInt16LE(0x0304, 0);
             *
             * console.log(buf);
             * // Prints: <Buffer 04 03>
             * ```
             * @since v0.5.5
             * @param value Number to be written to `buf`.
             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`.
             * @return `offset` plus the number of bytes written.
             */
            writeInt16LE(value: number, offset?: number): number;
            /**
             * Writes `value` to `buf` at the specified `offset` as big-endian.  The `value` must be a valid signed 16-bit integer. Behavior is undefined when `value` is
             * anything other than a signed 16-bit integer.
             *
             * The `value` is interpreted and written as a two's complement signed integer.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(2);
             *
             * buf.writeInt16BE(0x0102, 0);
             *
             * console.log(buf);
             * // Prints: <Buffer 01 02>
             * ```
             * @since v0.5.5
             * @param value Number to be written to `buf`.
             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 2`.
             * @return `offset` plus the number of bytes written.
             */
            writeInt16BE(value: number, offset?: number): number;
            /**
             * Writes `value` to `buf` at the specified `offset` as little-endian. The `value` must be a valid signed 32-bit integer. Behavior is undefined when `value` is
             * anything other than a signed 32-bit integer.
             *
             * The `value` is interpreted and written as a two's complement signed integer.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(4);
             *
             * buf.writeInt32LE(0x05060708, 0);
             *
             * console.log(buf);
             * // Prints: <Buffer 08 07 06 05>
             * ```
             * @since v0.5.5
             * @param value Number to be written to `buf`.
             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`.
             * @return `offset` plus the number of bytes written.
             */
            writeInt32LE(value: number, offset?: number): number;
            /**
             * Writes `value` to `buf` at the specified `offset` as big-endian. The `value` must be a valid signed 32-bit integer. Behavior is undefined when `value` is
             * anything other than a signed 32-bit integer.
             *
             * The `value` is interpreted and written as a two's complement signed integer.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(4);
             *
             * buf.writeInt32BE(0x01020304, 0);
             *
             * console.log(buf);
             * // Prints: <Buffer 01 02 03 04>
             * ```
             * @since v0.5.5
             * @param value Number to be written to `buf`.
             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`.
             * @return `offset` plus the number of bytes written.
             */
            writeInt32BE(value: number, offset?: number): number;
            /**
             * Writes `value` to `buf` at the specified `offset` as little-endian. Behavior is
             * undefined when `value` is anything other than a JavaScript number.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(4);
             *
             * buf.writeFloatLE(0xcafebabe, 0);
             *
             * console.log(buf);
             * // Prints: <Buffer bb fe 4a 4f>
             * ```
             * @since v0.11.15
             * @param value Number to be written to `buf`.
             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`.
             * @return `offset` plus the number of bytes written.
             */
            writeFloatLE(value: number, offset?: number): number;
            /**
             * Writes `value` to `buf` at the specified `offset` as big-endian. Behavior is
             * undefined when `value` is anything other than a JavaScript number.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(4);
             *
             * buf.writeFloatBE(0xcafebabe, 0);
             *
             * console.log(buf);
             * // Prints: <Buffer 4f 4a fe bb>
             * ```
             * @since v0.11.15
             * @param value Number to be written to `buf`.
             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 4`.
             * @return `offset` plus the number of bytes written.
             */
            writeFloatBE(value: number, offset?: number): number;
            /**
             * Writes `value` to `buf` at the specified `offset` as little-endian. The `value` must be a JavaScript number. Behavior is undefined when `value` is anything
             * other than a JavaScript number.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(8);
             *
             * buf.writeDoubleLE(123.456, 0);
             *
             * console.log(buf);
             * // Prints: <Buffer 77 be 9f 1a 2f dd 5e 40>
             * ```
             * @since v0.11.15
             * @param value Number to be written to `buf`.
             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 8`.
             * @return `offset` plus the number of bytes written.
             */
            writeDoubleLE(value: number, offset?: number): number;
            /**
             * Writes `value` to `buf` at the specified `offset` as big-endian. The `value` must be a JavaScript number. Behavior is undefined when `value` is anything
             * other than a JavaScript number.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(8);
             *
             * buf.writeDoubleBE(123.456, 0);
             *
             * console.log(buf);
             * // Prints: <Buffer 40 5e dd 2f 1a 9f be 77>
             * ```
             * @since v0.11.15
             * @param value Number to be written to `buf`.
             * @param [offset=0] Number of bytes to skip before starting to write. Must satisfy `0 <= offset <= buf.length - 8`.
             * @return `offset` plus the number of bytes written.
             */
            writeDoubleBE(value: number, offset?: number): number;
            /**
             * Fills `buf` with the specified `value`. If the `offset` and `end` are not given,
             * the entire `buf` will be filled:
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * // Fill a `Buffer` with the ASCII character 'h'.
             *
             * const b = Buffer.allocUnsafe(50).fill('h');
             *
             * console.log(b.toString());
             * // Prints: hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh
             *
             * // Fill a buffer with empty string
             * const c = Buffer.allocUnsafe(5).fill('');
             *
             * console.log(c.fill(''));
             * // Prints: <Buffer 00 00 00 00 00>
             * ```
             *
             * `value` is coerced to a `uint32` value if it is not a string, `Buffer`, or
             * integer. If the resulting integer is greater than `255` (decimal), `buf` will be
             * filled with `value &#x26; 255`.
             *
             * If the final write of a `fill()` operation falls on a multi-byte character,
             * then only the bytes of that character that fit into `buf` are written:
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * // Fill a `Buffer` with character that takes up two bytes in UTF-8.
             *
             * console.log(Buffer.allocUnsafe(5).fill('\u0222'));
             * // Prints: <Buffer c8 a2 c8 a2 c8>
             * ```
             *
             * If `value` contains invalid characters, it is truncated; if no valid
             * fill data remains, an exception is thrown:
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.allocUnsafe(5);
             *
             * console.log(buf.fill('a'));
             * // Prints: <Buffer 61 61 61 61 61>
             * console.log(buf.fill('aazz', 'hex'));
             * // Prints: <Buffer aa aa aa aa aa>
             * console.log(buf.fill('zz', 'hex'));
             * // Throws an exception.
             * ```
             * @since v0.5.0
             * @param value The value with which to fill `buf`. Empty value (string, Uint8Array, Buffer) is coerced to `0`.
             * @param [offset=0] Number of bytes to skip before starting to fill `buf`.
             * @param [end=buf.length] Where to stop filling `buf` (not inclusive).
             * @param [encoding='utf8'] The encoding for `value` if `value` is a string.
             * @return A reference to `buf`.
             */
            fill(value: string | Uint8Array | number, offset?: number, end?: number, encoding?: BufferEncoding): this;
            fill(value: string | Uint8Array | number, offset: number, encoding: BufferEncoding): this;
            fill(value: string | Uint8Array | number, encoding: BufferEncoding): this;
            /**
             * If `value` is:
             *
             * * a string, `value` is interpreted according to the character encoding in `encoding`.
             * * a `Buffer` or [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array), `value` will be used in its entirety.
             * To compare a partial `Buffer`, use `buf.subarray`.
             * * a number, `value` will be interpreted as an unsigned 8-bit integer
             * value between `0` and `255`.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from('this is a buffer');
             *
             * console.log(buf.indexOf('this'));
             * // Prints: 0
             * console.log(buf.indexOf('is'));
             * // Prints: 2
             * console.log(buf.indexOf(Buffer.from('a buffer')));
             * // Prints: 8
             * console.log(buf.indexOf(97));
             * // Prints: 8 (97 is the decimal ASCII value for 'a')
             * console.log(buf.indexOf(Buffer.from('a buffer example')));
             * // Prints: -1
             * console.log(buf.indexOf(Buffer.from('a buffer example').slice(0, 8)));
             * // Prints: 8
             *
             * const utf16Buffer = Buffer.from('\u039a\u0391\u03a3\u03a3\u0395', 'utf16le');
             *
             * console.log(utf16Buffer.indexOf('\u03a3', 0, 'utf16le'));
             * // Prints: 4
             * console.log(utf16Buffer.indexOf('\u03a3', -4, 'utf16le'));
             * // Prints: 6
             * ```
             *
             * If `value` is not a string, number, or `Buffer`, this method will throw a `TypeError`. If `value` is a number, it will be coerced to a valid byte value,
             * an integer between 0 and 255.
             *
             * If `byteOffset` is not a number, it will be coerced to a number. If the result
             * of coercion is `NaN` or `0`, then the entire buffer will be searched. This
             * behavior matches [`String.prototype.indexOf()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf).
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const b = Buffer.from('abcdef');
             *
             * // Passing a value that's a number, but not a valid byte.
             * // Prints: 2, equivalent to searching for 99 or 'c'.
             * console.log(b.indexOf(99.9));
             * console.log(b.indexOf(256 + 99));
             *
             * // Passing a byteOffset that coerces to NaN or 0.
             * // Prints: 1, searching the whole buffer.
             * console.log(b.indexOf('b', undefined));
             * console.log(b.indexOf('b', {}));
             * console.log(b.indexOf('b', null));
             * console.log(b.indexOf('b', []));
             * ```
             *
             * If `value` is an empty string or empty `Buffer` and `byteOffset` is less
             * than `buf.length`, `byteOffset` will be returned. If `value` is empty and`byteOffset` is at least `buf.length`, `buf.length` will be returned.
             * @since v1.5.0
             * @param value What to search for.
             * @param [byteOffset=0] Where to begin searching in `buf`. If negative, then offset is calculated from the end of `buf`.
             * @param [encoding='utf8'] If `value` is a string, this is the encoding used to determine the binary representation of the string that will be searched for in `buf`.
             * @return The index of the first occurrence of `value` in `buf`, or `-1` if `buf` does not contain `value`.
             */
            indexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: BufferEncoding): number;
            indexOf(value: string | number | Uint8Array, encoding: BufferEncoding): number;
            /**
             * Identical to `buf.indexOf()`, except the last occurrence of `value` is found
             * rather than the first occurrence.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from('this buffer is a buffer');
             *
             * console.log(buf.lastIndexOf('this'));
             * // Prints: 0
             * console.log(buf.lastIndexOf('buffer'));
             * // Prints: 17
             * console.log(buf.lastIndexOf(Buffer.from('buffer')));
             * // Prints: 17
             * console.log(buf.lastIndexOf(97));
             * // Prints: 15 (97 is the decimal ASCII value for 'a')
             * console.log(buf.lastIndexOf(Buffer.from('yolo')));
             * // Prints: -1
             * console.log(buf.lastIndexOf('buffer', 5));
             * // Prints: 5
             * console.log(buf.lastIndexOf('buffer', 4));
             * // Prints: -1
             *
             * const utf16Buffer = Buffer.from('\u039a\u0391\u03a3\u03a3\u0395', 'utf16le');
             *
             * console.log(utf16Buffer.lastIndexOf('\u03a3', undefined, 'utf16le'));
             * // Prints: 6
             * console.log(utf16Buffer.lastIndexOf('\u03a3', -5, 'utf16le'));
             * // Prints: 4
             * ```
             *
             * If `value` is not a string, number, or `Buffer`, this method will throw a `TypeError`. If `value` is a number, it will be coerced to a valid byte value,
             * an integer between 0 and 255.
             *
             * If `byteOffset` is not a number, it will be coerced to a number. Any arguments
             * that coerce to `NaN`, like `{}` or `undefined`, will search the whole buffer.
             * This behavior matches [`String.prototype.lastIndexOf()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf).
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const b = Buffer.from('abcdef');
             *
             * // Passing a value that's a number, but not a valid byte.
             * // Prints: 2, equivalent to searching for 99 or 'c'.
             * console.log(b.lastIndexOf(99.9));
             * console.log(b.lastIndexOf(256 + 99));
             *
             * // Passing a byteOffset that coerces to NaN.
             * // Prints: 1, searching the whole buffer.
             * console.log(b.lastIndexOf('b', undefined));
             * console.log(b.lastIndexOf('b', {}));
             *
             * // Passing a byteOffset that coerces to 0.
             * // Prints: -1, equivalent to passing 0.
             * console.log(b.lastIndexOf('b', null));
             * console.log(b.lastIndexOf('b', []));
             * ```
             *
             * If `value` is an empty string or empty `Buffer`, `byteOffset` will be returned.
             * @since v6.0.0
             * @param value What to search for.
             * @param [byteOffset=buf.length - 1] Where to begin searching in `buf`. If negative, then offset is calculated from the end of `buf`.
             * @param [encoding='utf8'] If `value` is a string, this is the encoding used to determine the binary representation of the string that will be searched for in `buf`.
             * @return The index of the last occurrence of `value` in `buf`, or `-1` if `buf` does not contain `value`.
             */
            lastIndexOf(value: string | number | Uint8Array, byteOffset?: number, encoding?: BufferEncoding): number;
            lastIndexOf(value: string | number | Uint8Array, encoding: BufferEncoding): number;
            /**
             * Equivalent to `buf.indexOf() !== -1`.
             *
             * ```js
             * import { Buffer } from 'node:buffer';
             *
             * const buf = Buffer.from('this is a buffer');
             *
             * console.log(buf.includes('this'));
             * // Prints: true
             * console.log(buf.includes('is'));
             * // Prints: true
             * console.log(buf.includes(Buffer.from('a buffer')));
             * // Prints: true
             * console.log(buf.includes(97));
             * // Prints: true (97 is the decimal ASCII value for 'a')
             * console.log(buf.includes(Buffer.from('a buffer example')));
             * // Prints: false
             * console.log(buf.includes(Buffer.from('a buffer example').slice(0, 8)));
             * // Prints: true
             * console.log(buf.includes('this', 4));
             * // Prints: false
             * ```
             * @since v5.3.0
             * @param value What to search for.
             * @param [byteOffset=0] Where to begin searching in `buf`. If negative, then offset is calculated from the end of `buf`.
             * @param [encoding='utf8'] If `value` is a string, this is its encoding.
             * @return `true` if `value` was found in `buf`, `false` otherwise.
             */
            includes(value: string | number | Buffer, byteOffset?: number, encoding?: BufferEncoding): boolean;
            includes(value: string | number | Buffer, encoding: BufferEncoding): boolean;
        }
        var Buffer: BufferConstructor;
        /**
         * Decodes a string of Base64-encoded data into bytes, and encodes those bytes
         * into a string using Latin-1 (ISO-8859-1).
         *
         * The `data` may be any JavaScript-value that can be coerced into a string.
         *
         * **This function is only provided for compatibility with legacy web platform APIs**
         * **and should never be used in new code, because they use strings to represent**
         * **binary data and predate the introduction of typed arrays in JavaScript.**
         * **For code running using Node.js APIs, converting between base64-encoded strings**
         * **and binary data should be performed using `Buffer.from(str, 'base64')` and `buf.toString('base64')`.**
         * @since v15.13.0, v14.17.0
         * @legacy Use `Buffer.from(data, 'base64')` instead.
         * @param data The Base64-encoded input string.
         */
        function atob(data: string): string;
        /**
         * Decodes a string into bytes using Latin-1 (ISO-8859), and encodes those bytes
         * into a string using Base64.
         *
         * The `data` may be any JavaScript-value that can be coerced into a string.
         *
         * **This function is only provided for compatibility with legacy web platform APIs**
         * **and should never be used in new code, because they use strings to represent**
         * **binary data and predate the introduction of typed arrays in JavaScript.**
         * **For code running using Node.js APIs, converting between base64-encoded strings**
         * **and binary data should be performed using `Buffer.from(str, 'base64')` and `buf.toString('base64')`.**
         * @since v15.13.0, v14.17.0
         * @legacy Use `buf.toString('base64')` instead.
         * @param data An ASCII (Latin1) string.
         */
        function btoa(data: string): string;
        interface Blob extends _Blob {}
        /**
         * `Blob` class is a global reference for `import { Blob } from 'node:buffer'`
         * https://nodejs.org/api/buffer.html#class-blob
         * @since v18.0.0
         */
        var Blob: typeof globalThis extends { onmessage: any; Blob: infer T } ? T
            : typeof import("buffer").Blob;
        interface File extends _File {}
        /**
         * `File` class is a global reference for `import { File } from 'node:buffer'`
         * https://nodejs.org/api/buffer.html#class-file
         * @since v20.0.0
         */
        var File: typeof globalThis extends { onmessage: any; File: infer T } ? T
            : typeof import("buffer").File;
    }
}
declare module "node:buffer" {
    export * from "buffer";
}

```

## ./lib/lambda/node_modules/@types/node/child_process.d.ts

```typescript
/**
 * The `node:child_process` module provides the ability to spawn subprocesses in
 * a manner that is similar, but not identical, to [`popen(3)`](http://man7.org/linux/man-pages/man3/popen.3.html). This capability
 * is primarily provided by the {@link spawn} function:
 *
 * ```js
 * import { spawn } from 'node:child_process';
 * const ls = spawn('ls', ['-lh', '/usr']);
 *
 * ls.stdout.on('data', (data) => {
 *   console.log(`stdout: ${data}`);
 * });
 *
 * ls.stderr.on('data', (data) => {
 *   console.error(`stderr: ${data}`);
 * });
 *
 * ls.on('close', (code) => {
 *   console.log(`child process exited with code ${code}`);
 * });
 * ```
 *
 * By default, pipes for `stdin`, `stdout`, and `stderr` are established between
 * the parent Node.js process and the spawned subprocess. These pipes have
 * limited (and platform-specific) capacity. If the subprocess writes to
 * stdout in excess of that limit without the output being captured, the
 * subprocess blocks, waiting for the pipe buffer to accept more data. This is
 * identical to the behavior of pipes in the shell. Use the `{ stdio: 'ignore' }` option if the output will not be consumed.
 *
 * The command lookup is performed using the `options.env.PATH` environment
 * variable if `env` is in the `options` object. Otherwise, `process.env.PATH` is
 * used. If `options.env` is set without `PATH`, lookup on Unix is performed
 * on a default search path search of `/usr/bin:/bin` (see your operating system's
 * manual for execvpe/execvp), on Windows the current processes environment
 * variable `PATH` is used.
 *
 * On Windows, environment variables are case-insensitive. Node.js
 * lexicographically sorts the `env` keys and uses the first one that
 * case-insensitively matches. Only first (in lexicographic order) entry will be
 * passed to the subprocess. This might lead to issues on Windows when passing
 * objects to the `env` option that have multiple variants of the same key, such as `PATH` and `Path`.
 *
 * The {@link spawn} method spawns the child process asynchronously,
 * without blocking the Node.js event loop. The {@link spawnSync} function provides equivalent functionality in a synchronous manner that blocks
 * the event loop until the spawned process either exits or is terminated.
 *
 * For convenience, the `node:child_process` module provides a handful of
 * synchronous and asynchronous alternatives to {@link spawn} and {@link spawnSync}. Each of these alternatives are implemented on
 * top of {@link spawn} or {@link spawnSync}.
 *
 * * {@link exec}: spawns a shell and runs a command within that
 * shell, passing the `stdout` and `stderr` to a callback function when
 * complete.
 * * {@link execFile}: similar to {@link exec} except
 * that it spawns the command directly without first spawning a shell by
 * default.
 * * {@link fork}: spawns a new Node.js process and invokes a
 * specified module with an IPC communication channel established that allows
 * sending messages between parent and child.
 * * {@link execSync}: a synchronous version of {@link exec} that will block the Node.js event loop.
 * * {@link execFileSync}: a synchronous version of {@link execFile} that will block the Node.js event loop.
 *
 * For certain use cases, such as automating shell scripts, the `synchronous counterparts` may be more convenient. In many cases, however,
 * the synchronous methods can have significant impact on performance due to
 * stalling the event loop while spawned processes complete.
 * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/child_process.js)
 */
declare module "child_process" {
    import { Abortable, EventEmitter } from "node:events";
    import * as dgram from "node:dgram";
    import * as net from "node:net";
    import { Readable, Stream, Writable } from "node:stream";
    import { URL } from "node:url";
    type Serializable = string | object | number | boolean | bigint;
    type SendHandle = net.Socket | net.Server | dgram.Socket | undefined;
    /**
     * Instances of the `ChildProcess` represent spawned child processes.
     *
     * Instances of `ChildProcess` are not intended to be created directly. Rather,
     * use the {@link spawn}, {@link exec},{@link execFile}, or {@link fork} methods to create
     * instances of `ChildProcess`.
     * @since v2.2.0
     */
    class ChildProcess extends EventEmitter {
        /**
         * A `Writable Stream` that represents the child process's `stdin`.
         *
         * If a child process waits to read all of its input, the child will not continue
         * until this stream has been closed via `end()`.
         *
         * If the child was spawned with `stdio[0]` set to anything other than `'pipe'`,
         * then this will be `null`.
         *
         * `subprocess.stdin` is an alias for `subprocess.stdio[0]`. Both properties will
         * refer to the same value.
         *
         * The `subprocess.stdin` property can be `null` or `undefined` if the child process could not be successfully spawned.
         * @since v0.1.90
         */
        stdin: Writable | null;
        /**
         * A `Readable Stream` that represents the child process's `stdout`.
         *
         * If the child was spawned with `stdio[1]` set to anything other than `'pipe'`,
         * then this will be `null`.
         *
         * `subprocess.stdout` is an alias for `subprocess.stdio[1]`. Both properties will
         * refer to the same value.
         *
         * ```js
         * import { spawn } from 'node:child_process';
         *
         * const subprocess = spawn('ls');
         *
         * subprocess.stdout.on('data', (data) => {
         *   console.log(`Received chunk ${data}`);
         * });
         * ```
         *
         * The `subprocess.stdout` property can be `null` or `undefined` if the child process could not be successfully spawned.
         * @since v0.1.90
         */
        stdout: Readable | null;
        /**
         * A `Readable Stream` that represents the child process's `stderr`.
         *
         * If the child was spawned with `stdio[2]` set to anything other than `'pipe'`,
         * then this will be `null`.
         *
         * `subprocess.stderr` is an alias for `subprocess.stdio[2]`. Both properties will
         * refer to the same value.
         *
         * The `subprocess.stderr` property can be `null` or `undefined` if the child process could not be successfully spawned.
         * @since v0.1.90
         */
        stderr: Readable | null;
        /**
         * The `subprocess.channel` property is a reference to the child's IPC channel. If
         * no IPC channel exists, this property is `undefined`.
         * @since v7.1.0
         */
        readonly channel?: Control | null;
        /**
         * A sparse array of pipes to the child process, corresponding with positions in
         * the `stdio` option passed to {@link spawn} that have been set
         * to the value `'pipe'`. `subprocess.stdio[0]`, `subprocess.stdio[1]`, and `subprocess.stdio[2]` are also available as `subprocess.stdin`, `subprocess.stdout`, and `subprocess.stderr`,
         * respectively.
         *
         * In the following example, only the child's fd `1` (stdout) is configured as a
         * pipe, so only the parent's `subprocess.stdio[1]` is a stream, all other values
         * in the array are `null`.
         *
         * ```js
         * import assert from 'node:assert';
         * import fs from 'node:fs';
         * import child_process from 'node:child_process';
         *
         * const subprocess = child_process.spawn('ls', {
         *   stdio: [
         *     0, // Use parent's stdin for child.
         *     'pipe', // Pipe child's stdout to parent.
         *     fs.openSync('err.out', 'w'), // Direct child's stderr to a file.
         *   ],
         * });
         *
         * assert.strictEqual(subprocess.stdio[0], null);
         * assert.strictEqual(subprocess.stdio[0], subprocess.stdin);
         *
         * assert(subprocess.stdout);
         * assert.strictEqual(subprocess.stdio[1], subprocess.stdout);
         *
         * assert.strictEqual(subprocess.stdio[2], null);
         * assert.strictEqual(subprocess.stdio[2], subprocess.stderr);
         * ```
         *
         * The `subprocess.stdio` property can be `undefined` if the child process could
         * not be successfully spawned.
         * @since v0.7.10
         */
        readonly stdio: [
            Writable | null,
            // stdin
            Readable | null,
            // stdout
            Readable | null,
            // stderr
            Readable | Writable | null | undefined,
            // extra
            Readable | Writable | null | undefined, // extra
        ];
        /**
         * The `subprocess.killed` property indicates whether the child process
         * successfully received a signal from `subprocess.kill()`. The `killed` property
         * does not indicate that the child process has been terminated.
         * @since v0.5.10
         */
        readonly killed: boolean;
        /**
         * Returns the process identifier (PID) of the child process. If the child process
         * fails to spawn due to errors, then the value is `undefined` and `error` is
         * emitted.
         *
         * ```js
         * import { spawn } from 'node:child_process';
         * const grep = spawn('grep', ['ssh']);
         *
         * console.log(`Spawned child pid: ${grep.pid}`);
         * grep.stdin.end();
         * ```
         * @since v0.1.90
         */
        readonly pid?: number | undefined;
        /**
         * The `subprocess.connected` property indicates whether it is still possible to
         * send and receive messages from a child process. When `subprocess.connected` is `false`, it is no longer possible to send or receive messages.
         * @since v0.7.2
         */
        readonly connected: boolean;
        /**
         * The `subprocess.exitCode` property indicates the exit code of the child process.
         * If the child process is still running, the field will be `null`.
         */
        readonly exitCode: number | null;
        /**
         * The `subprocess.signalCode` property indicates the signal received by
         * the child process if any, else `null`.
         */
        readonly signalCode: NodeJS.Signals | null;
        /**
         * The `subprocess.spawnargs` property represents the full list of command-line
         * arguments the child process was launched with.
         */
        readonly spawnargs: string[];
        /**
         * The `subprocess.spawnfile` property indicates the executable file name of
         * the child process that is launched.
         *
         * For {@link fork}, its value will be equal to `process.execPath`.
         * For {@link spawn}, its value will be the name of
         * the executable file.
         * For {@link exec},  its value will be the name of the shell
         * in which the child process is launched.
         */
        readonly spawnfile: string;
        /**
         * The `subprocess.kill()` method sends a signal to the child process. If no
         * argument is given, the process will be sent the `'SIGTERM'` signal. See [`signal(7)`](http://man7.org/linux/man-pages/man7/signal.7.html) for a list of available signals. This function
         * returns `true` if [`kill(2)`](http://man7.org/linux/man-pages/man2/kill.2.html) succeeds, and `false` otherwise.
         *
         * ```js
         * import { spawn } from 'node:child_process';
         * const grep = spawn('grep', ['ssh']);
         *
         * grep.on('close', (code, signal) => {
         *   console.log(
         *     `child process terminated due to receipt of signal ${signal}`);
         * });
         *
         * // Send SIGHUP to process.
         * grep.kill('SIGHUP');
         * ```
         *
         * The `ChildProcess` object may emit an `'error'` event if the signal
         * cannot be delivered. Sending a signal to a child process that has already exited
         * is not an error but may have unforeseen consequences. Specifically, if the
         * process identifier (PID) has been reassigned to another process, the signal will
         * be delivered to that process instead which can have unexpected results.
         *
         * While the function is called `kill`, the signal delivered to the child process
         * may not actually terminate the process.
         *
         * See [`kill(2)`](http://man7.org/linux/man-pages/man2/kill.2.html) for reference.
         *
         * On Windows, where POSIX signals do not exist, the `signal` argument will be
         * ignored, and the process will be killed forcefully and abruptly (similar to `'SIGKILL'`).
         * See `Signal Events` for more details.
         *
         * On Linux, child processes of child processes will not be terminated
         * when attempting to kill their parent. This is likely to happen when running a
         * new process in a shell or with the use of the `shell` option of `ChildProcess`:
         *
         * ```js
         * 'use strict';
         * import { spawn } from 'node:child_process';
         *
         * const subprocess = spawn(
         *   'sh',
         *   [
         *     '-c',
         *     `node -e "setInterval(() => {
         *       console.log(process.pid, 'is alive')
         *     }, 500);"`,
         *   ], {
         *     stdio: ['inherit', 'inherit', 'inherit'],
         *   },
         * );
         *
         * setTimeout(() => {
         *   subprocess.kill(); // Does not terminate the Node.js process in the shell.
         * }, 2000);
         * ```
         * @since v0.1.90
         */
        kill(signal?: NodeJS.Signals | number): boolean;
        /**
         * Calls {@link ChildProcess.kill} with `'SIGTERM'`.
         * @since v20.5.0
         */
        [Symbol.dispose](): void;
        /**
         * When an IPC channel has been established between the parent and child (
         * i.e. when using {@link fork}), the `subprocess.send()` method can
         * be used to send messages to the child process. When the child process is a
         * Node.js instance, these messages can be received via the `'message'` event.
         *
         * The message goes through serialization and parsing. The resulting
         * message might not be the same as what is originally sent.
         *
         * For example, in the parent script:
         *
         * ```js
         * import cp from 'node:child_process';
         * const n = cp.fork(`${__dirname}/sub.js`);
         *
         * n.on('message', (m) => {
         *   console.log('PARENT got message:', m);
         * });
         *
         * // Causes the child to print: CHILD got message: { hello: 'world' }
         * n.send({ hello: 'world' });
         * ```
         *
         * And then the child script, `'sub.js'` might look like this:
         *
         * ```js
         * process.on('message', (m) => {
         *   console.log('CHILD got message:', m);
         * });
         *
         * // Causes the parent to print: PARENT got message: { foo: 'bar', baz: null }
         * process.send({ foo: 'bar', baz: NaN });
         * ```
         *
         * Child Node.js processes will have a `process.send()` method of their own
         * that allows the child to send messages back to the parent.
         *
         * There is a special case when sending a `{cmd: 'NODE_foo'}` message. Messages
         * containing a `NODE_` prefix in the `cmd` property are reserved for use within
         * Node.js core and will not be emitted in the child's `'message'` event. Rather, such messages are emitted using the `'internalMessage'` event and are consumed internally by Node.js.
         * Applications should avoid using such messages or listening for `'internalMessage'` events as it is subject to change without notice.
         *
         * The optional `sendHandle` argument that may be passed to `subprocess.send()` is
         * for passing a TCP server or socket object to the child process. The child will
         * receive the object as the second argument passed to the callback function
         * registered on the `'message'` event. Any data that is received and buffered in
         * the socket will not be sent to the child. Sending IPC sockets is not supported on Windows.
         *
         * The optional `callback` is a function that is invoked after the message is
         * sent but before the child may have received it. The function is called with a
         * single argument: `null` on success, or an `Error` object on failure.
         *
         * If no `callback` function is provided and the message cannot be sent, an `'error'` event will be emitted by the `ChildProcess` object. This can
         * happen, for instance, when the child process has already exited.
         *
         * `subprocess.send()` will return `false` if the channel has closed or when the
         * backlog of unsent messages exceeds a threshold that makes it unwise to send
         * more. Otherwise, the method returns `true`. The `callback` function can be
         * used to implement flow control.
         *
         * #### Example: sending a server object
         *
         * The `sendHandle` argument can be used, for instance, to pass the handle of
         * a TCP server object to the child process as illustrated in the example below:
         *
         * ```js
         * import { createServer } from 'node:net';
         * import { fork } from 'node:child_process';
         * const subprocess = fork('subprocess.js');
         *
         * // Open up the server object and send the handle.
         * const server = createServer();
         * server.on('connection', (socket) => {
         *   socket.end('handled by parent');
         * });
         * server.listen(1337, () => {
         *   subprocess.send('server', server);
         * });
         * ```
         *
         * The child would then receive the server object as:
         *
         * ```js
         * process.on('message', (m, server) => {
         *   if (m === 'server') {
         *     server.on('connection', (socket) => {
         *       socket.end('handled by child');
         *     });
         *   }
         * });
         * ```
         *
         * Once the server is now shared between the parent and child, some connections
         * can be handled by the parent and some by the child.
         *
         * While the example above uses a server created using the `node:net` module, `node:dgram` module servers use exactly the same workflow with the exceptions of
         * listening on a `'message'` event instead of `'connection'` and using `server.bind()` instead of `server.listen()`. This is, however, only
         * supported on Unix platforms.
         *
         * #### Example: sending a socket object
         *
         * Similarly, the `sendHandler` argument can be used to pass the handle of a
         * socket to the child process. The example below spawns two children that each
         * handle connections with "normal" or "special" priority:
         *
         * ```js
         * import { createServer } from 'node:net';
         * import { fork } from 'node:child_process';
         * const normal = fork('subprocess.js', ['normal']);
         * const special = fork('subprocess.js', ['special']);
         *
         * // Open up the server and send sockets to child. Use pauseOnConnect to prevent
         * // the sockets from being read before they are sent to the child process.
         * const server = createServer({ pauseOnConnect: true });
         * server.on('connection', (socket) => {
         *
         *   // If this is special priority...
         *   if (socket.remoteAddress === '74.125.127.100') {
         *     special.send('socket', socket);
         *     return;
         *   }
         *   // This is normal priority.
         *   normal.send('socket', socket);
         * });
         * server.listen(1337);
         * ```
         *
         * The `subprocess.js` would receive the socket handle as the second argument
         * passed to the event callback function:
         *
         * ```js
         * process.on('message', (m, socket) => {
         *   if (m === 'socket') {
         *     if (socket) {
         *       // Check that the client socket exists.
         *       // It is possible for the socket to be closed between the time it is
         *       // sent and the time it is received in the child process.
         *       socket.end(`Request handled with ${process.argv[2]} priority`);
         *     }
         *   }
         * });
         * ```
         *
         * Do not use `.maxConnections` on a socket that has been passed to a subprocess.
         * The parent cannot track when the socket is destroyed.
         *
         * Any `'message'` handlers in the subprocess should verify that `socket` exists,
         * as the connection may have been closed during the time it takes to send the
         * connection to the child.
         * @since v0.5.9
         * @param sendHandle `undefined`, or a [`net.Socket`](https://nodejs.org/docs/latest-v22.x/api/net.html#class-netsocket), [`net.Server`](https://nodejs.org/docs/latest-v22.x/api/net.html#class-netserver), or [`dgram.Socket`](https://nodejs.org/docs/latest-v22.x/api/dgram.html#class-dgramsocket) object.
         * @param options The `options` argument, if present, is an object used to parameterize the sending of certain types of handles. `options` supports the following properties:
         */
        send(message: Serializable, callback?: (error: Error | null) => void): boolean;
        send(message: Serializable, sendHandle?: SendHandle, callback?: (error: Error | null) => void): boolean;
        send(
            message: Serializable,
            sendHandle?: SendHandle,
            options?: MessageOptions,
            callback?: (error: Error | null) => void,
        ): boolean;
        /**
         * Closes the IPC channel between parent and child, allowing the child to exit
         * gracefully once there are no other connections keeping it alive. After calling
         * this method the `subprocess.connected` and `process.connected` properties in
         * both the parent and child (respectively) will be set to `false`, and it will be
         * no longer possible to pass messages between the processes.
         *
         * The `'disconnect'` event will be emitted when there are no messages in the
         * process of being received. This will most often be triggered immediately after
         * calling `subprocess.disconnect()`.
         *
         * When the child process is a Node.js instance (e.g. spawned using {@link fork}), the `process.disconnect()` method can be invoked
         * within the child process to close the IPC channel as well.
         * @since v0.7.2
         */
        disconnect(): void;
        /**
         * By default, the parent will wait for the detached child to exit. To prevent the
         * parent from waiting for a given `subprocess` to exit, use the `subprocess.unref()` method. Doing so will cause the parent's event loop to not
         * include the child in its reference count, allowing the parent to exit
         * independently of the child, unless there is an established IPC channel between
         * the child and the parent.
         *
         * ```js
         * import { spawn } from 'node:child_process';
         *
         * const subprocess = spawn(process.argv[0], ['child_program.js'], {
         *   detached: true,
         *   stdio: 'ignore',
         * });
         *
         * subprocess.unref();
         * ```
         * @since v0.7.10
         */
        unref(): void;
        /**
         * Calling `subprocess.ref()` after making a call to `subprocess.unref()` will
         * restore the removed reference count for the child process, forcing the parent
         * to wait for the child to exit before exiting itself.
         *
         * ```js
         * import { spawn } from 'node:child_process';
         *
         * const subprocess = spawn(process.argv[0], ['child_program.js'], {
         *   detached: true,
         *   stdio: 'ignore',
         * });
         *
         * subprocess.unref();
         * subprocess.ref();
         * ```
         * @since v0.7.10
         */
        ref(): void;
        /**
         * events.EventEmitter
         * 1. close
         * 2. disconnect
         * 3. error
         * 4. exit
         * 5. message
         * 6. spawn
         */
        addListener(event: string, listener: (...args: any[]) => void): this;
        addListener(event: "close", listener: (code: number | null, signal: NodeJS.Signals | null) => void): this;
        addListener(event: "disconnect", listener: () => void): this;
        addListener(event: "error", listener: (err: Error) => void): this;
        addListener(event: "exit", listener: (code: number | null, signal: NodeJS.Signals | null) => void): this;
        addListener(event: "message", listener: (message: Serializable, sendHandle: SendHandle) => void): this;
        addListener(event: "spawn", listener: () => void): this;
        emit(event: string | symbol, ...args: any[]): boolean;
        emit(event: "close", code: number | null, signal: NodeJS.Signals | null): boolean;
        emit(event: "disconnect"): boolean;
        emit(event: "error", err: Error): boolean;
        emit(event: "exit", code: number | null, signal: NodeJS.Signals | null): boolean;
        emit(event: "message", message: Serializable, sendHandle: SendHandle): boolean;
        emit(event: "spawn", listener: () => void): boolean;
        on(event: string, listener: (...args: any[]) => void): this;
        on(event: "close", listener: (code: number | null, signal: NodeJS.Signals | null) => void): this;
        on(event: "disconnect", listener: () => void): this;
        on(event: "error", listener: (err: Error) => void): this;
        on(event: "exit", listener: (code: number | null, signal: NodeJS.Signals | null) => void): this;
        on(event: "message", listener: (message: Serializable, sendHandle: SendHandle) => void): this;
        on(event: "spawn", listener: () => void): this;
        once(event: string, listener: (...args: any[]) => void): this;
        once(event: "close", listener: (code: number | null, signal: NodeJS.Signals | null) => void): this;
        once(event: "disconnect", listener: () => void): this;
        once(event: "error", listener: (err: Error) => void): this;
        once(event: "exit", listener: (code: number | null, signal: NodeJS.Signals | null) => void): this;
        once(event: "message", listener: (message: Serializable, sendHandle: SendHandle) => void): this;
        once(event: "spawn", listener: () => void): this;
        prependListener(event: string, listener: (...args: any[]) => void): this;
        prependListener(event: "close", listener: (code: number | null, signal: NodeJS.Signals | null) => void): this;
        prependListener(event: "disconnect", listener: () => void): this;
        prependListener(event: "error", listener: (err: Error) => void): this;
        prependListener(event: "exit", listener: (code: number | null, signal: NodeJS.Signals | null) => void): this;
        prependListener(event: "message", listener: (message: Serializable, sendHandle: SendHandle) => void): this;
        prependListener(event: "spawn", listener: () => void): this;
        prependOnceListener(event: string, listener: (...args: any[]) => void): this;
        prependOnceListener(
            event: "close",
            listener: (code: number | null, signal: NodeJS.Signals | null) => void,
        ): this;
        prependOnceListener(event: "disconnect", listener: () => void): this;
        prependOnceListener(event: "error", listener: (err: Error) => void): this;
        prependOnceListener(
            event: "exit",
            listener: (code: number | null, signal: NodeJS.Signals | null) => void,
        ): this;
        prependOnceListener(event: "message", listener: (message: Serializable, sendHandle: SendHandle) => void): this;
        prependOnceListener(event: "spawn", listener: () => void): this;
    }
    // return this object when stdio option is undefined or not specified
    interface ChildProcessWithoutNullStreams extends ChildProcess {
        stdin: Writable;
        stdout: Readable;
        stderr: Readable;
        readonly stdio: [
            Writable,
            Readable,
            Readable,
            // stderr
            Readable | Writable | null | undefined,
            // extra, no modification
            Readable | Writable | null | undefined, // extra, no modification
        ];
    }
    // return this object when stdio option is a tuple of 3
    interface ChildProcessByStdio<I extends null | Writable, O extends null | Readable, E extends null | Readable>
        extends ChildProcess
    {
        stdin: I;
        stdout: O;
        stderr: E;
        readonly stdio: [
            I,
            O,
            E,
            Readable | Writable | null | undefined,
            // extra, no modification
            Readable | Writable | null | undefined, // extra, no modification
        ];
    }
    interface Control extends EventEmitter {
        ref(): void;
        unref(): void;
    }
    interface MessageOptions {
        keepOpen?: boolean | undefined;
    }
    type IOType = "overlapped" | "pipe" | "ignore" | "inherit";
    type StdioOptions = IOType | Array<IOType | "ipc" | Stream | number | null | undefined>;
    type SerializationType = "json" | "advanced";
    interface MessagingOptions extends Abortable {
        /**
         * Specify the kind of serialization used for sending messages between processes.
         * @default 'json'
         */
        serialization?: SerializationType | undefined;
        /**
         * The signal value to be used when the spawned process will be killed by the abort signal.
         * @default 'SIGTERM'
         */
        killSignal?: NodeJS.Signals | number | undefined;
        /**
         * In milliseconds the maximum amount of time the process is allowed to run.
         */
        timeout?: number | undefined;
    }
    interface ProcessEnvOptions {
        uid?: number | undefined;
        gid?: number | undefined;
        cwd?: string | URL | undefined;
        env?: NodeJS.ProcessEnv | undefined;
    }
    interface CommonOptions extends ProcessEnvOptions {
        /**
         * @default false
         */
        windowsHide?: boolean | undefined;
        /**
         * @default 0
         */
        timeout?: number | undefined;
    }
    interface CommonSpawnOptions extends CommonOptions, MessagingOptions, Abortable {
        argv0?: string | undefined;
        /**
         * Can be set to 'pipe', 'inherit', 'overlapped', or 'ignore', or an array of these strings.
         * If passed as an array, the first element is used for `stdin`, the second for
         * `stdout`, and the third for `stderr`. A fourth element can be used to
         * specify the `stdio` behavior beyond the standard streams. See
         * {@link ChildProcess.stdio} for more information.
         *
         * @default 'pipe'
         */
        stdio?: StdioOptions | undefined;
        shell?: boolean | string | undefined;
        windowsVerbatimArguments?: boolean | undefined;
    }
    interface SpawnOptions extends CommonSpawnOptions {
        detached?: boolean | undefined;
    }
    interface SpawnOptionsWithoutStdio extends SpawnOptions {
        stdio?: StdioPipeNamed | StdioPipe[] | undefined;
    }
    type StdioNull = "inherit" | "ignore" | Stream;
    type StdioPipeNamed = "pipe" | "overlapped";
    type StdioPipe = undefined | null | StdioPipeNamed;
    interface SpawnOptionsWithStdioTuple<
        Stdin extends StdioNull | StdioPipe,
        Stdout extends StdioNull | StdioPipe,
        Stderr extends StdioNull | StdioPipe,
    > extends SpawnOptions {
        stdio: [Stdin, Stdout, Stderr];
    }
    /**
     * The `child_process.spawn()` method spawns a new process using the given `command`, with command-line arguments in `args`. If omitted, `args` defaults
     * to an empty array.
     *
     * **If the `shell` option is enabled, do not pass unsanitized user input to this**
     * **function. Any input containing shell metacharacters may be used to trigger**
     * **arbitrary command execution.**
     *
     * A third argument may be used to specify additional options, with these defaults:
     *
     * ```js
     * const defaults = {
     *   cwd: undefined,
     *   env: process.env,
     * };
     * ```
     *
     * Use `cwd` to specify the working directory from which the process is spawned.
     * If not given, the default is to inherit the current working directory. If given,
     * but the path does not exist, the child process emits an `ENOENT` error
     * and exits immediately. `ENOENT` is also emitted when the command
     * does not exist.
     *
     * Use `env` to specify environment variables that will be visible to the new
     * process, the default is `process.env`.
     *
     * `undefined` values in `env` will be ignored.
     *
     * Example of running `ls -lh /usr`, capturing `stdout`, `stderr`, and the
     * exit code:
     *
     * ```js
     * import { spawn } from 'node:child_process';
     * const ls = spawn('ls', ['-lh', '/usr']);
     *
     * ls.stdout.on('data', (data) => {
     *   console.log(`stdout: ${data}`);
     * });
     *
     * ls.stderr.on('data', (data) => {
     *   console.error(`stderr: ${data}`);
     * });
     *
     * ls.on('close', (code) => {
     *   console.log(`child process exited with code ${code}`);
     * });
     * ```
     *
     * Example: A very elaborate way to run `ps ax | grep ssh`
     *
     * ```js
     * import { spawn } from 'node:child_process';
     * const ps = spawn('ps', ['ax']);
     * const grep = spawn('grep', ['ssh']);
     *
     * ps.stdout.on('data', (data) => {
     *   grep.stdin.write(data);
     * });
     *
     * ps.stderr.on('data', (data) => {
     *   console.error(`ps stderr: ${data}`);
     * });
     *
     * ps.on('close', (code) => {
     *   if (code !== 0) {
     *     console.log(`ps process exited with code ${code}`);
     *   }
     *   grep.stdin.end();
     * });
     *
     * grep.stdout.on('data', (data) => {
     *   console.log(data.toString());
     * });
     *
     * grep.stderr.on('data', (data) => {
     *   console.error(`grep stderr: ${data}`);
     * });
     *
     * grep.on('close', (code) => {
     *   if (code !== 0) {
     *     console.log(`grep process exited with code ${code}`);
     *   }
     * });
     * ```
     *
     * Example of checking for failed `spawn`:
     *
     * ```js
     * import { spawn } from 'node:child_process';
     * const subprocess = spawn('bad_command');
     *
     * subprocess.on('error', (err) => {
     *   console.error('Failed to start subprocess.');
     * });
     * ```
     *
     * Certain platforms (macOS, Linux) will use the value of `argv[0]` for the process
     * title while others (Windows, SunOS) will use `command`.
     *
     * Node.js overwrites `argv[0]` with `process.execPath` on startup, so `process.argv[0]` in a Node.js child process will not match the `argv0` parameter passed to `spawn` from the parent. Retrieve
     * it with the `process.argv0` property instead.
     *
     * If the `signal` option is enabled, calling `.abort()` on the corresponding `AbortController` is similar to calling `.kill()` on the child process except
     * the error passed to the callback will be an `AbortError`:
     *
     * ```js
     * import { spawn } from 'node:child_process';
     * const controller = new AbortController();
     * const { signal } = controller;
     * const grep = spawn('grep', ['ssh'], { signal });
     * grep.on('error', (err) => {
     *   // This will be called with err being an AbortError if the controller aborts
     * });
     * controller.abort(); // Stops the child process
     * ```
     * @since v0.1.90
     * @param command The command to run.
     * @param args List of string arguments.
     */
    function spawn(command: string, options?: SpawnOptionsWithoutStdio): ChildProcessWithoutNullStreams;
    function spawn(
        command: string,
        options: SpawnOptionsWithStdioTuple<StdioPipe, StdioPipe, StdioPipe>,
    ): ChildProcessByStdio<Writable, Readable, Readable>;
    function spawn(
        command: string,
        options: SpawnOptionsWithStdioTuple<StdioPipe, StdioPipe, StdioNull>,
    ): ChildProcessByStdio<Writable, Readable, null>;
    function spawn(
        command: string,
        options: SpawnOptionsWithStdioTuple<StdioPipe, StdioNull, StdioPipe>,
    ): ChildProcessByStdio<Writable, null, Readable>;
    function spawn(
        command: string,
        options: SpawnOptionsWithStdioTuple<StdioNull, StdioPipe, StdioPipe>,
    ): ChildProcessByStdio<null, Readable, Readable>;
    function spawn(
        command: string,
        options: SpawnOptionsWithStdioTuple<StdioPipe, StdioNull, StdioNull>,
    ): ChildProcessByStdio<Writable, null, null>;
    function spawn(
        command: string,
        options: SpawnOptionsWithStdioTuple<StdioNull, StdioPipe, StdioNull>,
    ): ChildProcessByStdio<null, Readable, null>;
    function spawn(
        command: string,
        options: SpawnOptionsWithStdioTuple<StdioNull, StdioNull, StdioPipe>,
    ): ChildProcessByStdio<null, null, Readable>;
    function spawn(
        command: string,
        options: SpawnOptionsWithStdioTuple<StdioNull, StdioNull, StdioNull>,
    ): ChildProcessByStdio<null, null, null>;
    function spawn(command: string, options: SpawnOptions): ChildProcess;
    // overloads of spawn with 'args'
    function spawn(
        command: string,
        args?: readonly string[],
        options?: SpawnOptionsWithoutStdio,
    ): ChildProcessWithoutNullStreams;
    function spawn(
        command: string,
        args: readonly string[],
        options: SpawnOptionsWithStdioTuple<StdioPipe, StdioPipe, StdioPipe>,
    ): ChildProcessByStdio<Writable, Readable, Readable>;
    function spawn(
        command: string,
        args: readonly string[],
        options: SpawnOptionsWithStdioTuple<StdioPipe, StdioPipe, StdioNull>,
    ): ChildProcessByStdio<Writable, Readable, null>;
    function spawn(
        command: string,
        args: readonly string[],
        options: SpawnOptionsWithStdioTuple<StdioPipe, StdioNull, StdioPipe>,
    ): ChildProcessByStdio<Writable, null, Readable>;
    function spawn(
        command: string,
        args: readonly string[],
        options: SpawnOptionsWithStdioTuple<StdioNull, StdioPipe, StdioPipe>,
    ): ChildProcessByStdio<null, Readable, Readable>;
    function spawn(
        command: string,
        args: readonly string[],
        options: SpawnOptionsWithStdioTuple<StdioPipe, StdioNull, StdioNull>,
    ): ChildProcessByStdio<Writable, null, null>;
    function spawn(
        command: string,
        args: readonly string[],
        options: SpawnOptionsWithStdioTuple<StdioNull, StdioPipe, StdioNull>,
    ): ChildProcessByStdio<null, Readable, null>;
    function spawn(
        command: string,
        args: readonly string[],
        options: SpawnOptionsWithStdioTuple<StdioNull, StdioNull, StdioPipe>,
    ): ChildProcessByStdio<null, null, Readable>;
    function spawn(
        command: string,
        args: readonly string[],
        options: SpawnOptionsWithStdioTuple<StdioNull, StdioNull, StdioNull>,
    ): ChildProcessByStdio<null, null, null>;
    function spawn(command: string, args: readonly string[], options: SpawnOptions): ChildProcess;
    interface ExecOptions extends CommonOptions {
        shell?: string | undefined;
        signal?: AbortSignal | undefined;
        maxBuffer?: number | undefined;
        killSignal?: NodeJS.Signals | number | undefined;
        encoding?: string | null | undefined;
    }
    interface ExecOptionsWithStringEncoding extends ExecOptions {
        encoding?: BufferEncoding | undefined;
    }
    interface ExecOptionsWithBufferEncoding extends ExecOptions {
        encoding: "buffer" | null; // specify `null`.
    }
    // TODO: Just Plain Wrong (see also nodejs/node#57392)
    interface ExecException extends Error {
        cmd?: string;
        killed?: boolean;
        code?: number;
        signal?: NodeJS.Signals;
        stdout?: string;
        stderr?: string;
    }
    /**
     * Spawns a shell then executes the `command` within that shell, buffering any
     * generated output. The `command` string passed to the exec function is processed
     * directly by the shell and special characters (vary based on [shell](https://en.wikipedia.org/wiki/List_of_command-line_interpreters))
     * need to be dealt with accordingly:
     *
     * ```js
     * import { exec } from 'node:child_process';
     *
     * exec('"/path/to/test file/test.sh" arg1 arg2');
     * // Double quotes are used so that the space in the path is not interpreted as
     * // a delimiter of multiple arguments.
     *
     * exec('echo "The \\$HOME variable is $HOME"');
     * // The $HOME variable is escaped in the first instance, but not in the second.
     * ```
     *
     * **Never pass unsanitized user input to this function. Any input containing shell**
     * **metacharacters may be used to trigger arbitrary command execution.**
     *
     * If a `callback` function is provided, it is called with the arguments `(error, stdout, stderr)`. On success, `error` will be `null`. On error, `error` will be an instance of `Error`. The
     * `error.code` property will be
     * the exit code of the process. By convention, any exit code other than `0` indicates an error. `error.signal` will be the signal that terminated the
     * process.
     *
     * The `stdout` and `stderr` arguments passed to the callback will contain the
     * stdout and stderr output of the child process. By default, Node.js will decode
     * the output as UTF-8 and pass strings to the callback. The `encoding` option
     * can be used to specify the character encoding used to decode the stdout and
     * stderr output. If `encoding` is `'buffer'`, or an unrecognized character
     * encoding, `Buffer` objects will be passed to the callback instead.
     *
     * ```js
     * import { exec } from 'node:child_process';
     * exec('cat *.js missing_file | wc -l', (error, stdout, stderr) => {
     *   if (error) {
     *     console.error(`exec error: ${error}`);
     *     return;
     *   }
     *   console.log(`stdout: ${stdout}`);
     *   console.error(`stderr: ${stderr}`);
     * });
     * ```
     *
     * If `timeout` is greater than `0`, the parent will send the signal
     * identified by the `killSignal` property (the default is `'SIGTERM'`) if the
     * child runs longer than `timeout` milliseconds.
     *
     * Unlike the [`exec(3)`](http://man7.org/linux/man-pages/man3/exec.3.html) POSIX system call, `child_process.exec()` does not replace
     * the existing process and uses a shell to execute the command.
     *
     * If this method is invoked as its `util.promisify()` ed version, it returns
     * a `Promise` for an `Object` with `stdout` and `stderr` properties. The returned `ChildProcess` instance is attached to the `Promise` as a `child` property. In
     * case of an error (including any error resulting in an exit code other than 0), a
     * rejected promise is returned, with the same `error` object given in the
     * callback, but with two additional properties `stdout` and `stderr`.
     *
     * ```js
     * import util from 'node:util';
     * import child_process from 'node:child_process';
     * const exec = util.promisify(child_process.exec);
     *
     * async function lsExample() {
     *   const { stdout, stderr } = await exec('ls');
     *   console.log('stdout:', stdout);
     *   console.error('stderr:', stderr);
     * }
     * lsExample();
     * ```
     *
     * If the `signal` option is enabled, calling `.abort()` on the corresponding `AbortController` is similar to calling `.kill()` on the child process except
     * the error passed to the callback will be an `AbortError`:
     *
     * ```js
     * import { exec } from 'node:child_process';
     * const controller = new AbortController();
     * const { signal } = controller;
     * const child = exec('grep ssh', { signal }, (error) => {
     *   console.error(error); // an AbortError
     * });
     * controller.abort();
     * ```
     * @since v0.1.90
     * @param command The command to run, with space-separated arguments.
     * @param callback called with the output when process terminates.
     */
    function exec(
        command: string,
        callback?: (error: ExecException | null, stdout: string, stderr: string) => void,
    ): ChildProcess;
    // `options` with `"buffer"` or `null` for `encoding` means stdout/stderr are definitely `Buffer`.
    function exec(
        command: string,
        options: ExecOptionsWithBufferEncoding,
        callback?: (error: ExecException | null, stdout: Buffer, stderr: Buffer) => void,
    ): ChildProcess;
    // `options` with well-known or absent `encoding` means stdout/stderr are definitely `string`.
    function exec(
        command: string,
        options: ExecOptionsWithStringEncoding,
        callback?: (error: ExecException | null, stdout: string, stderr: string) => void,
    ): ChildProcess;
    // fallback if nothing else matches. Worst case is always `string | Buffer`.
    function exec(
        command: string,
        options: ExecOptions | undefined | null,
        callback?: (error: ExecException | null, stdout: string | Buffer, stderr: string | Buffer) => void,
    ): ChildProcess;
    interface PromiseWithChild<T> extends Promise<T> {
        child: ChildProcess;
    }
    namespace exec {
        function __promisify__(command: string): PromiseWithChild<{
            stdout: string;
            stderr: string;
        }>;
        function __promisify__(
            command: string,
            options: ExecOptionsWithBufferEncoding,
        ): PromiseWithChild<{
            stdout: Buffer;
            stderr: Buffer;
        }>;
        function __promisify__(
            command: string,
            options: ExecOptionsWithStringEncoding,
        ): PromiseWithChild<{
            stdout: string;
            stderr: string;
        }>;
        function __promisify__(
            command: string,
            options: ExecOptions | undefined | null,
        ): PromiseWithChild<{
            stdout: string | Buffer;
            stderr: string | Buffer;
        }>;
    }
    interface ExecFileOptions extends CommonOptions, Abortable {
        maxBuffer?: number | undefined;
        killSignal?: NodeJS.Signals | number | undefined;
        windowsVerbatimArguments?: boolean | undefined;
        shell?: boolean | string | undefined;
        signal?: AbortSignal | undefined;
        encoding?: string | null | undefined;
    }
    interface ExecFileOptionsWithStringEncoding extends ExecFileOptions {
        encoding?: BufferEncoding | undefined;
    }
    interface ExecFileOptionsWithBufferEncoding extends ExecFileOptions {
        encoding: "buffer" | null;
    }
    /** @deprecated Use `ExecFileOptions` instead. */
    interface ExecFileOptionsWithOtherEncoding extends ExecFileOptions {}
    // TODO: execFile exceptions can take many forms... this accurately describes none of them
    type ExecFileException =
        & Omit<ExecException, "code">
        & Omit<NodeJS.ErrnoException, "code">
        & { code?: string | number | null };
    /**
     * The `child_process.execFile()` function is similar to {@link exec} except that it does not spawn a shell by default. Rather, the specified
     * executable `file` is spawned directly as a new process making it slightly more
     * efficient than {@link exec}.
     *
     * The same options as {@link exec} are supported. Since a shell is
     * not spawned, behaviors such as I/O redirection and file globbing are not
     * supported.
     *
     * ```js
     * import { execFile } from 'node:child_process';
     * const child = execFile('node', ['--version'], (error, stdout, stderr) => {
     *   if (error) {
     *     throw error;
     *   }
     *   console.log(stdout);
     * });
     * ```
     *
     * The `stdout` and `stderr` arguments passed to the callback will contain the
     * stdout and stderr output of the child process. By default, Node.js will decode
     * the output as UTF-8 and pass strings to the callback. The `encoding` option
     * can be used to specify the character encoding used to decode the stdout and
     * stderr output. If `encoding` is `'buffer'`, or an unrecognized character
     * encoding, `Buffer` objects will be passed to the callback instead.
     *
     * If this method is invoked as its `util.promisify()` ed version, it returns
     * a `Promise` for an `Object` with `stdout` and `stderr` properties. The returned `ChildProcess` instance is attached to the `Promise` as a `child` property. In
     * case of an error (including any error resulting in an exit code other than 0), a
     * rejected promise is returned, with the same `error` object given in the
     * callback, but with two additional properties `stdout` and `stderr`.
     *
     * ```js
     * import util from 'node:util';
     * import child_process from 'node:child_process';
     * const execFile = util.promisify(child_process.execFile);
     * async function getVersion() {
     *   const { stdout } = await execFile('node', ['--version']);
     *   console.log(stdout);
     * }
     * getVersion();
     * ```
     *
     * **If the `shell` option is enabled, do not pass unsanitized user input to this**
     * **function. Any input containing shell metacharacters may be used to trigger**
     * **arbitrary command execution.**
     *
     * If the `signal` option is enabled, calling `.abort()` on the corresponding `AbortController` is similar to calling `.kill()` on the child process except
     * the error passed to the callback will be an `AbortError`:
     *
     * ```js
     * import { execFile } from 'node:child_process';
     * const controller = new AbortController();
     * const { signal } = controller;
     * const child = execFile('node', ['--version'], { signal }, (error) => {
     *   console.error(error); // an AbortError
     * });
     * controller.abort();
     * ```
     * @since v0.1.91
     * @param file The name or path of the executable file to run.
     * @param args List of string arguments.
     * @param callback Called with the output when process terminates.
     */
    // no `options` definitely means stdout/stderr are `string`.
    function execFile(
        file: string,
        callback?: (error: ExecFileException | null, stdout: string, stderr: string) => void,
    ): ChildProcess;
    function execFile(
        file: string,
        args: readonly string[] | undefined | null,
        callback?: (error: ExecFileException | null, stdout: string, stderr: string) => void,
    ): ChildProcess;
    // `options` with `"buffer"` or `null` for `encoding` means stdout/stderr are definitely `Buffer`.
    function execFile(
        file: string,
        options: ExecFileOptionsWithBufferEncoding,
        callback?: (error: ExecFileException | null, stdout: Buffer, stderr: Buffer) => void,
    ): ChildProcess;
    function execFile(
        file: string,
        args: readonly string[] | undefined | null,
        options: ExecFileOptionsWithBufferEncoding,
        callback?: (error: ExecFileException | null, stdout: Buffer, stderr: Buffer) => void,
    ): ChildProcess;
    // `options` with well-known or absent `encoding` means stdout/stderr are definitely `string`.
    function execFile(
        file: string,
        options: ExecFileOptionsWithStringEncoding,
        callback?: (error: ExecFileException | null, stdout: string, stderr: string) => void,
    ): ChildProcess;
    function execFile(
        file: string,
        args: readonly string[] | undefined | null,
        options: ExecFileOptionsWithStringEncoding,
        callback?: (error: ExecFileException | null, stdout: string, stderr: string) => void,
    ): ChildProcess;
    // fallback if nothing else matches. Worst case is always `string | Buffer`.
    function execFile(
        file: string,
        options: ExecFileOptions | undefined | null,
        callback:
            | ((error: ExecFileException | null, stdout: string | Buffer, stderr: string | Buffer) => void)
            | undefined
            | null,
    ): ChildProcess;
    function execFile(
        file: string,
        args: readonly string[] | undefined | null,
        options: ExecFileOptions | undefined | null,
        callback:
            | ((error: ExecFileException | null, stdout: string | Buffer, stderr: string | Buffer) => void)
            | undefined
            | null,
    ): ChildProcess;
    namespace execFile {
        function __promisify__(file: string): PromiseWithChild<{
            stdout: string;
            stderr: string;
        }>;
        function __promisify__(
            file: string,
            args: readonly string[] | undefined | null,
        ): PromiseWithChild<{
            stdout: string;
            stderr: string;
        }>;
        function __promisify__(
            file: string,
            options: ExecFileOptionsWithBufferEncoding,
        ): PromiseWithChild<{
            stdout: Buffer;
            stderr: Buffer;
        }>;
        function __promisify__(
            file: string,
            args: readonly string[] | undefined | null,
            options: ExecFileOptionsWithBufferEncoding,
        ): PromiseWithChild<{
            stdout: Buffer;
            stderr: Buffer;
        }>;
        function __promisify__(
            file: string,
            options: ExecFileOptionsWithStringEncoding,
        ): PromiseWithChild<{
            stdout: string;
            stderr: string;
        }>;
        function __promisify__(
            file: string,
            args: readonly string[] | undefined | null,
            options: ExecFileOptionsWithStringEncoding,
        ): PromiseWithChild<{
            stdout: string;
            stderr: string;
        }>;
        function __promisify__(
            file: string,
            options: ExecFileOptions | undefined | null,
        ): PromiseWithChild<{
            stdout: string | Buffer;
            stderr: string | Buffer;
        }>;
        function __promisify__(
            file: string,
            args: readonly string[] | undefined | null,
            options: ExecFileOptions | undefined | null,
        ): PromiseWithChild<{
            stdout: string | Buffer;
            stderr: string | Buffer;
        }>;
    }
    interface ForkOptions extends ProcessEnvOptions, MessagingOptions, Abortable {
        execPath?: string | undefined;
        execArgv?: string[] | undefined;
        silent?: boolean | undefined;
        /**
         * Can be set to 'pipe', 'inherit', 'overlapped', or 'ignore', or an array of these strings.
         * If passed as an array, the first element is used for `stdin`, the second for
         * `stdout`, and the third for `stderr`. A fourth element can be used to
         * specify the `stdio` behavior beyond the standard streams. See
         * {@link ChildProcess.stdio} for more information.
         *
         * @default 'pipe'
         */
        stdio?: StdioOptions | undefined;
        detached?: boolean | undefined;
        windowsVerbatimArguments?: boolean | undefined;
    }
    /**
     * The `child_process.fork()` method is a special case of {@link spawn} used specifically to spawn new Node.js processes.
     * Like {@link spawn}, a `ChildProcess` object is returned. The
     * returned `ChildProcess` will have an additional communication channel
     * built-in that allows messages to be passed back and forth between the parent and
     * child. See `subprocess.send()` for details.
     *
     * Keep in mind that spawned Node.js child processes are
     * independent of the parent with exception of the IPC communication channel
     * that is established between the two. Each process has its own memory, with
     * their own V8 instances. Because of the additional resource allocations
     * required, spawning a large number of child Node.js processes is not
     * recommended.
     *
     * By default, `child_process.fork()` will spawn new Node.js instances using the `process.execPath` of the parent process. The `execPath` property in the `options` object allows for an alternative
     * execution path to be used.
     *
     * Node.js processes launched with a custom `execPath` will communicate with the
     * parent process using the file descriptor (fd) identified using the
     * environment variable `NODE_CHANNEL_FD` on the child process.
     *
     * Unlike the [`fork(2)`](http://man7.org/linux/man-pages/man2/fork.2.html) POSIX system call, `child_process.fork()` does not clone the
     * current process.
     *
     * The `shell` option available in {@link spawn} is not supported by `child_process.fork()` and will be ignored if set.
     *
     * If the `signal` option is enabled, calling `.abort()` on the corresponding `AbortController` is similar to calling `.kill()` on the child process except
     * the error passed to the callback will be an `AbortError`:
     *
     * ```js
     * if (process.argv[2] === 'child') {
     *   setTimeout(() => {
     *     console.log(`Hello from ${process.argv[2]}!`);
     *   }, 1_000);
     * } else {
     *   import { fork } from 'node:child_process';
     *   const controller = new AbortController();
     *   const { signal } = controller;
     *   const child = fork(__filename, ['child'], { signal });
     *   child.on('error', (err) => {
     *     // This will be called with err being an AbortError if the controller aborts
     *   });
     *   controller.abort(); // Stops the child process
     * }
     * ```
     * @since v0.5.0
     * @param modulePath The module to run in the child.
     * @param args List of string arguments.
     */
    function fork(modulePath: string | URL, options?: ForkOptions): ChildProcess;
    function fork(modulePath: string | URL, args?: readonly string[], options?: ForkOptions): ChildProcess;
    interface SpawnSyncOptions extends CommonSpawnOptions {
        input?: string | NodeJS.ArrayBufferView | undefined;
        maxBuffer?: number | undefined;
        encoding?: BufferEncoding | "buffer" | null | undefined;
    }
    interface SpawnSyncOptionsWithStringEncoding extends SpawnSyncOptions {
        encoding: BufferEncoding;
    }
    interface SpawnSyncOptionsWithBufferEncoding extends SpawnSyncOptions {
        encoding?: "buffer" | null | undefined;
    }
    interface SpawnSyncReturns<T> {
        pid: number;
        output: Array<T | null>;
        stdout: T;
        stderr: T;
        status: number | null;
        signal: NodeJS.Signals | null;
        error?: Error;
    }
    /**
     * The `child_process.spawnSync()` method is generally identical to {@link spawn} with the exception that the function will not return
     * until the child process has fully closed. When a timeout has been encountered
     * and `killSignal` is sent, the method won't return until the process has
     * completely exited. If the process intercepts and handles the `SIGTERM` signal
     * and doesn't exit, the parent process will wait until the child process has
     * exited.
     *
     * **If the `shell` option is enabled, do not pass unsanitized user input to this**
     * **function. Any input containing shell metacharacters may be used to trigger**
     * **arbitrary command execution.**
     * @since v0.11.12
     * @param command The command to run.
     * @param args List of string arguments.
     */
    function spawnSync(command: string): SpawnSyncReturns<Buffer>;
    function spawnSync(command: string, options: SpawnSyncOptionsWithStringEncoding): SpawnSyncReturns<string>;
    function spawnSync(command: string, options: SpawnSyncOptionsWithBufferEncoding): SpawnSyncReturns<Buffer>;
    function spawnSync(command: string, options?: SpawnSyncOptions): SpawnSyncReturns<string | Buffer>;
    function spawnSync(command: string, args: readonly string[]): SpawnSyncReturns<Buffer>;
    function spawnSync(
        command: string,
        args: readonly string[],
        options: SpawnSyncOptionsWithStringEncoding,
    ): SpawnSyncReturns<string>;
    function spawnSync(
        command: string,
        args: readonly string[],
        options: SpawnSyncOptionsWithBufferEncoding,
    ): SpawnSyncReturns<Buffer>;
    function spawnSync(
        command: string,
        args?: readonly string[],
        options?: SpawnSyncOptions,
    ): SpawnSyncReturns<string | Buffer>;
    interface CommonExecOptions extends CommonOptions {
        input?: string | NodeJS.ArrayBufferView | undefined;
        /**
         * Can be set to 'pipe', 'inherit, or 'ignore', or an array of these strings.
         * If passed as an array, the first element is used for `stdin`, the second for
         * `stdout`, and the third for `stderr`. A fourth element can be used to
         * specify the `stdio` behavior beyond the standard streams. See
         * {@link ChildProcess.stdio} for more information.
         *
         * @default 'pipe'
         */
        stdio?: StdioOptions | undefined;
        killSignal?: NodeJS.Signals | number | undefined;
        maxBuffer?: number | undefined;
        encoding?: BufferEncoding | "buffer" | null | undefined;
    }
    interface ExecSyncOptions extends CommonExecOptions {
        shell?: string | undefined;
    }
    interface ExecSyncOptionsWithStringEncoding extends ExecSyncOptions {
        encoding: BufferEncoding;
    }
    interface ExecSyncOptionsWithBufferEncoding extends ExecSyncOptions {
        encoding?: "buffer" | null | undefined;
    }
    /**
     * The `child_process.execSync()` method is generally identical to {@link exec} with the exception that the method will not return
     * until the child process has fully closed. When a timeout has been encountered
     * and `killSignal` is sent, the method won't return until the process has
     * completely exited. If the child process intercepts and handles the `SIGTERM` signal and doesn't exit, the parent process will wait until the child process
     * has exited.
     *
     * If the process times out or has a non-zero exit code, this method will throw.
     * The `Error` object will contain the entire result from {@link spawnSync}.
     *
     * **Never pass unsanitized user input to this function. Any input containing shell**
     * **metacharacters may be used to trigger arbitrary command execution.**
     * @since v0.11.12
     * @param command The command to run.
     * @return The stdout from the command.
     */
    function execSync(command: string): Buffer;
    function execSync(command: string, options: ExecSyncOptionsWithStringEncoding): string;
    function execSync(command: string, options: ExecSyncOptionsWithBufferEncoding): Buffer;
    function execSync(command: string, options?: ExecSyncOptions): string | Buffer;
    interface ExecFileSyncOptions extends CommonExecOptions {
        shell?: boolean | string | undefined;
    }
    interface ExecFileSyncOptionsWithStringEncoding extends ExecFileSyncOptions {
        encoding: BufferEncoding;
    }
    interface ExecFileSyncOptionsWithBufferEncoding extends ExecFileSyncOptions {
        encoding?: "buffer" | null | undefined; // specify `null`.
    }
    /**
     * The `child_process.execFileSync()` method is generally identical to {@link execFile} with the exception that the method will not
     * return until the child process has fully closed. When a timeout has been
     * encountered and `killSignal` is sent, the method won't return until the process
     * has completely exited.
     *
     * If the child process intercepts and handles the `SIGTERM` signal and
     * does not exit, the parent process will still wait until the child process has
     * exited.
     *
     * If the process times out or has a non-zero exit code, this method will throw an `Error` that will include the full result of the underlying {@link spawnSync}.
     *
     * **If the `shell` option is enabled, do not pass unsanitized user input to this**
     * **function. Any input containing shell metacharacters may be used to trigger**
     * **arbitrary command execution.**
     * @since v0.11.12
     * @param file The name or path of the executable file to run.
     * @param args List of string arguments.
     * @return The stdout from the command.
     */
    function execFileSync(file: string): Buffer;
    function execFileSync(file: string, options: ExecFileSyncOptionsWithStringEncoding): string;
    function execFileSync(file: string, options: ExecFileSyncOptionsWithBufferEncoding): Buffer;
    function execFileSync(file: string, options?: ExecFileSyncOptions): string | Buffer;
    function execFileSync(file: string, args: readonly string[]): Buffer;
    function execFileSync(
        file: string,
        args: readonly string[],
        options: ExecFileSyncOptionsWithStringEncoding,
    ): string;
    function execFileSync(
        file: string,
        args: readonly string[],
        options: ExecFileSyncOptionsWithBufferEncoding,
    ): Buffer;
    function execFileSync(file: string, args?: readonly string[], options?: ExecFileSyncOptions): string | Buffer;
}
declare module "node:child_process" {
    export * from "child_process";
}

```

## ./lib/lambda/node_modules/@types/node/cluster.d.ts

```typescript
/**
 * Clusters of Node.js processes can be used to run multiple instances of Node.js
 * that can distribute workloads among their application threads. When process isolation
 * is not needed, use the [`worker_threads`](https://nodejs.org/docs/latest-v22.x/api/worker_threads.html)
 * module instead, which allows running multiple application threads within a single Node.js instance.
 *
 * The cluster module allows easy creation of child processes that all share
 * server ports.
 *
 * ```js
 * import cluster from 'node:cluster';
 * import http from 'node:http';
 * import { availableParallelism } from 'node:os';
 * import process from 'node:process';
 *
 * const numCPUs = availableParallelism();
 *
 * if (cluster.isPrimary) {
 *   console.log(`Primary ${process.pid} is running`);
 *
 *   // Fork workers.
 *   for (let i = 0; i < numCPUs; i++) {
 *     cluster.fork();
 *   }
 *
 *   cluster.on('exit', (worker, code, signal) => {
 *     console.log(`worker ${worker.process.pid} died`);
 *   });
 * } else {
 *   // Workers can share any TCP connection
 *   // In this case it is an HTTP server
 *   http.createServer((req, res) => {
 *     res.writeHead(200);
 *     res.end('hello world\n');
 *   }).listen(8000);
 *
 *   console.log(`Worker ${process.pid} started`);
 * }
 * ```
 *
 * Running Node.js will now share port 8000 between the workers:
 *
 * ```console
 * $ node server.js
 * Primary 3596 is running
 * Worker 4324 started
 * Worker 4520 started
 * Worker 6056 started
 * Worker 5644 started
 * ```
 *
 * On Windows, it is not yet possible to set up a named pipe server in a worker.
 * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/cluster.js)
 */
declare module "cluster" {
    import * as child from "node:child_process";
    import EventEmitter = require("node:events");
    import * as net from "node:net";
    type SerializationType = "json" | "advanced";
    export interface ClusterSettings {
        /**
         * List of string arguments passed to the Node.js executable.
         * @default process.execArgv
         */
        execArgv?: string[] | undefined;
        /**
         * File path to worker file.
         * @default process.argv[1]
         */
        exec?: string | undefined;
        /**
         * String arguments passed to worker.
         * @default process.argv.slice(2)
         */
        args?: string[] | undefined;
        /**
         * Whether or not to send output to parent's stdio.
         * @default false
         */
        silent?: boolean | undefined;
        /**
         * Configures the stdio of forked processes. Because the cluster module relies on IPC to function, this configuration must
         * contain an `'ipc'` entry. When this option is provided, it overrides `silent`. See [`child_prcess.spawn()`](https://nodejs.org/docs/latest-v22.x/api/child_process.html#child_processspawncommand-args-options)'s
         * [`stdio`](https://nodejs.org/docs/latest-v22.x/api/child_process.html#optionsstdio).
         */
        stdio?: any[] | undefined;
        /**
         * Sets the user identity of the process. (See [`setuid(2)`](https://man7.org/linux/man-pages/man2/setuid.2.html).)
         */
        uid?: number | undefined;
        /**
         * Sets the group identity of the process. (See [`setgid(2)`](https://man7.org/linux/man-pages/man2/setgid.2.html).)
         */
        gid?: number | undefined;
        /**
         * Sets inspector port of worker. This can be a number, or a function that takes no arguments and returns a number.
         * By default each worker gets its own port, incremented from the primary's `process.debugPort`.
         */
        inspectPort?: number | (() => number) | undefined;
        /**
         * Specify the kind of serialization used for sending messages between processes. Possible values are `'json'` and `'advanced'`.
         * See [Advanced serialization for `child_process`](https://nodejs.org/docs/latest-v22.x/api/child_process.html#advanced-serialization) for more details.
         * @default false
         */
        serialization?: SerializationType | undefined;
        /**
         * Current working directory of the worker process.
         * @default undefined (inherits from parent process)
         */
        cwd?: string | undefined;
        /**
         * Hide the forked processes console window that would normally be created on Windows systems.
         * @default false
         */
        windowsHide?: boolean | undefined;
    }
    export interface Address {
        address: string;
        port: number;
        /**
         * The `addressType` is one of:
         *
         * * `4` (TCPv4)
         * * `6` (TCPv6)
         * * `-1` (Unix domain socket)
         * * `'udp4'` or `'udp6'` (UDPv4 or UDPv6)
         */
        addressType: 4 | 6 | -1 | "udp4" | "udp6";
    }
    /**
     * A `Worker` object contains all public information and method about a worker.
     * In the primary it can be obtained using `cluster.workers`. In a worker
     * it can be obtained using `cluster.worker`.
     * @since v0.7.0
     */
    export class Worker extends EventEmitter {
        /**
         * Each new worker is given its own unique id, this id is stored in the `id`.
         *
         * While a worker is alive, this is the key that indexes it in `cluster.workers`.
         * @since v0.8.0
         */
        id: number;
        /**
         * All workers are created using [`child_process.fork()`](https://nodejs.org/docs/latest-v22.x/api/child_process.html#child_processforkmodulepath-args-options), the returned object
         * from this function is stored as `.process`. In a worker, the global `process` is stored.
         *
         * See: [Child Process module](https://nodejs.org/docs/latest-v22.x/api/child_process.html#child_processforkmodulepath-args-options).
         *
         * Workers will call `process.exit(0)` if the `'disconnect'` event occurs
         * on `process` and `.exitedAfterDisconnect` is not `true`. This protects against
         * accidental disconnection.
         * @since v0.7.0
         */
        process: child.ChildProcess;
        /**
         * Send a message to a worker or primary, optionally with a handle.
         *
         * In the primary, this sends a message to a specific worker. It is identical to [`ChildProcess.send()`](https://nodejs.org/docs/latest-v22.x/api/child_process.html#subprocesssendmessage-sendhandle-options-callback).
         *
         * In a worker, this sends a message to the primary. It is identical to `process.send()`.
         *
         * This example will echo back all messages from the primary:
         *
         * ```js
         * if (cluster.isPrimary) {
         *   const worker = cluster.fork();
         *   worker.send('hi there');
         *
         * } else if (cluster.isWorker) {
         *   process.on('message', (msg) => {
         *     process.send(msg);
         *   });
         * }
         * ```
         * @since v0.7.0
         * @param options The `options` argument, if present, is an object used to parameterize the sending of certain types of handles.
         */
        send(message: child.Serializable, callback?: (error: Error | null) => void): boolean;
        send(
            message: child.Serializable,
            sendHandle: child.SendHandle,
            callback?: (error: Error | null) => void,
        ): boolean;
        send(
            message: child.Serializable,
            sendHandle: child.SendHandle,
            options?: child.MessageOptions,
            callback?: (error: Error | null) => void,
        ): boolean;
        /**
         * This function will kill the worker. In the primary worker, it does this by
         * disconnecting the `worker.process`, and once disconnected, killing with `signal`. In the worker, it does it by killing the process with `signal`.
         *
         * The `kill()` function kills the worker process without waiting for a graceful
         * disconnect, it has the same behavior as `worker.process.kill()`.
         *
         * This method is aliased as `worker.destroy()` for backwards compatibility.
         *
         * In a worker, `process.kill()` exists, but it is not this function;
         * it is [`kill()`](https://nodejs.org/docs/latest-v22.x/api/process.html#processkillpid-signal).
         * @since v0.9.12
         * @param [signal='SIGTERM'] Name of the kill signal to send to the worker process.
         */
        kill(signal?: string): void;
        destroy(signal?: string): void;
        /**
         * In a worker, this function will close all servers, wait for the `'close'` event
         * on those servers, and then disconnect the IPC channel.
         *
         * In the primary, an internal message is sent to the worker causing it to call `.disconnect()` on itself.
         *
         * Causes `.exitedAfterDisconnect` to be set.
         *
         * After a server is closed, it will no longer accept new connections,
         * but connections may be accepted by any other listening worker. Existing
         * connections will be allowed to close as usual. When no more connections exist,
         * see `server.close()`, the IPC channel to the worker will close allowing it
         * to die gracefully.
         *
         * The above applies _only_ to server connections, client connections are not
         * automatically closed by workers, and disconnect does not wait for them to close
         * before exiting.
         *
         * In a worker, `process.disconnect` exists, but it is not this function;
         * it is `disconnect()`.
         *
         * Because long living server connections may block workers from disconnecting, it
         * may be useful to send a message, so application specific actions may be taken to
         * close them. It also may be useful to implement a timeout, killing a worker if
         * the `'disconnect'` event has not been emitted after some time.
         *
         * ```js
         * import net from 'node:net';
         *
         * if (cluster.isPrimary) {
         *   const worker = cluster.fork();
         *   let timeout;
         *
         *   worker.on('listening', (address) => {
         *     worker.send('shutdown');
         *     worker.disconnect();
         *     timeout = setTimeout(() => {
         *       worker.kill();
         *     }, 2000);
         *   });
         *
         *   worker.on('disconnect', () => {
         *     clearTimeout(timeout);
         *   });
         *
         * } else if (cluster.isWorker) {
         *   const server = net.createServer((socket) => {
         *     // Connections never end
         *   });
         *
         *   server.listen(8000);
         *
         *   process.on('message', (msg) => {
         *     if (msg === 'shutdown') {
         *       // Initiate graceful close of any connections to server
         *     }
         *   });
         * }
         * ```
         * @since v0.7.7
         * @return A reference to `worker`.
         */
        disconnect(): this;
        /**
         * This function returns `true` if the worker is connected to its primary via its
         * IPC channel, `false` otherwise. A worker is connected to its primary after it
         * has been created. It is disconnected after the `'disconnect'` event is emitted.
         * @since v0.11.14
         */
        isConnected(): boolean;
        /**
         * This function returns `true` if the worker's process has terminated (either
         * because of exiting or being signaled). Otherwise, it returns `false`.
         *
         * ```js
         * import cluster from 'node:cluster';
         * import http from 'node:http';
         * import { availableParallelism } from 'node:os';
         * import process from 'node:process';
         *
         * const numCPUs = availableParallelism();
         *
         * if (cluster.isPrimary) {
         *   console.log(`Primary ${process.pid} is running`);
         *
         *   // Fork workers.
         *   for (let i = 0; i < numCPUs; i++) {
         *     cluster.fork();
         *   }
         *
         *   cluster.on('fork', (worker) => {
         *     console.log('worker is dead:', worker.isDead());
         *   });
         *
         *   cluster.on('exit', (worker, code, signal) => {
         *     console.log('worker is dead:', worker.isDead());
         *   });
         * } else {
         *   // Workers can share any TCP connection. In this case, it is an HTTP server.
         *   http.createServer((req, res) => {
         *     res.writeHead(200);
         *     res.end(`Current process\n ${process.pid}`);
         *     process.kill(process.pid);
         *   }).listen(8000);
         * }
         * ```
         * @since v0.11.14
         */
        isDead(): boolean;
        /**
         * This property is `true` if the worker exited due to `.disconnect()`.
         * If the worker exited any other way, it is `false`. If the
         * worker has not exited, it is `undefined`.
         *
         * The boolean `worker.exitedAfterDisconnect` allows distinguishing between
         * voluntary and accidental exit, the primary may choose not to respawn a worker
         * based on this value.
         *
         * ```js
         * cluster.on('exit', (worker, code, signal) => {
         *   if (worker.exitedAfterDisconnect === true) {
         *     console.log('Oh, it was just voluntary  no need to worry');
         *   }
         * });
         *
         * // kill worker
         * worker.kill();
         * ```
         * @since v6.0.0
         */
        exitedAfterDisconnect: boolean;
        /**
         * events.EventEmitter
         *   1. disconnect
         *   2. error
         *   3. exit
         *   4. listening
         *   5. message
         *   6. online
         */
        addListener(event: string, listener: (...args: any[]) => void): this;
        addListener(event: "disconnect", listener: () => void): this;
        addListener(event: "error", listener: (error: Error) => void): this;
        addListener(event: "exit", listener: (code: number, signal: string) => void): this;
        addListener(event: "listening", listener: (address: Address) => void): this;
        addListener(event: "message", listener: (message: any, handle: net.Socket | net.Server) => void): this; // the handle is a net.Socket or net.Server object, or undefined.
        addListener(event: "online", listener: () => void): this;
        emit(event: string | symbol, ...args: any[]): boolean;
        emit(event: "disconnect"): boolean;
        emit(event: "error", error: Error): boolean;
        emit(event: "exit", code: number, signal: string): boolean;
        emit(event: "listening", address: Address): boolean;
        emit(event: "message", message: any, handle: net.Socket | net.Server): boolean;
        emit(event: "online"): boolean;
        on(event: string, listener: (...args: any[]) => void): this;
        on(event: "disconnect", listener: () => void): this;
        on(event: "error", listener: (error: Error) => void): this;
        on(event: "exit", listener: (code: number, signal: string) => void): this;
        on(event: "listening", listener: (address: Address) => void): this;
        on(event: "message", listener: (message: any, handle: net.Socket | net.Server) => void): this; // the handle is a net.Socket or net.Server object, or undefined.
        on(event: "online", listener: () => void): this;
        once(event: string, listener: (...args: any[]) => void): this;
        once(event: "disconnect", listener: () => void): this;
        once(event: "error", listener: (error: Error) => void): this;
        once(event: "exit", listener: (code: number, signal: string) => void): this;
        once(event: "listening", listener: (address: Address) => void): this;
        once(event: "message", listener: (message: any, handle: net.Socket | net.Server) => void): this; // the handle is a net.Socket or net.Server object, or undefined.
        once(event: "online", listener: () => void): this;
        prependListener(event: string, listener: (...args: any[]) => void): this;
        prependListener(event: "disconnect", listener: () => void): this;
        prependListener(event: "error", listener: (error: Error) => void): this;
        prependListener(event: "exit", listener: (code: number, signal: string) => void): this;
        prependListener(event: "listening", listener: (address: Address) => void): this;
        prependListener(event: "message", listener: (message: any, handle: net.Socket | net.Server) => void): this; // the handle is a net.Socket or net.Server object, or undefined.
        prependListener(event: "online", listener: () => void): this;
        prependOnceListener(event: string, listener: (...args: any[]) => void): this;
        prependOnceListener(event: "disconnect", listener: () => void): this;
        prependOnceListener(event: "error", listener: (error: Error) => void): this;
        prependOnceListener(event: "exit", listener: (code: number, signal: string) => void): this;
        prependOnceListener(event: "listening", listener: (address: Address) => void): this;
        prependOnceListener(event: "message", listener: (message: any, handle: net.Socket | net.Server) => void): this; // the handle is a net.Socket or net.Server object, or undefined.
        prependOnceListener(event: "online", listener: () => void): this;
    }
    export interface Cluster extends EventEmitter {
        disconnect(callback?: () => void): void;
        /**
         * Spawn a new worker process.
         *
         * This can only be called from the primary process.
         * @param env Key/value pairs to add to worker process environment.
         * @since v0.6.0
         */
        fork(env?: any): Worker;
        /** @deprecated since v16.0.0 - use isPrimary. */
        readonly isMaster: boolean;
        /**
         * True if the process is a primary. This is determined by the `process.env.NODE_UNIQUE_ID`. If `process.env.NODE_UNIQUE_ID`
         * is undefined, then `isPrimary` is `true`.
         * @since v16.0.0
         */
        readonly isPrimary: boolean;
        /**
         * True if the process is not a primary (it is the negation of `cluster.isPrimary`).
         * @since v0.6.0
         */
        readonly isWorker: boolean;
        /**
         * The scheduling policy, either `cluster.SCHED_RR` for round-robin or `cluster.SCHED_NONE` to leave it to the operating system. This is a
         * global setting and effectively frozen once either the first worker is spawned, or [`.setupPrimary()`](https://nodejs.org/docs/latest-v22.x/api/cluster.html#clustersetupprimarysettings)
         * is called, whichever comes first.
         *
         * `SCHED_RR` is the default on all operating systems except Windows. Windows will change to `SCHED_RR` once libuv is able to effectively distribute
         * IOCP handles without incurring a large performance hit.
         *
         * `cluster.schedulingPolicy` can also be set through the `NODE_CLUSTER_SCHED_POLICY` environment variable. Valid values are `'rr'` and `'none'`.
         * @since v0.11.2
         */
        schedulingPolicy: number;
        /**
         * After calling [`.setupPrimary()`](https://nodejs.org/docs/latest-v22.x/api/cluster.html#clustersetupprimarysettings)
         * (or [`.fork()`](https://nodejs.org/docs/latest-v22.x/api/cluster.html#clusterforkenv)) this settings object will contain
         * the settings, including the default values.
         *
         * This object is not intended to be changed or set manually.
         * @since v0.7.1
         */
        readonly settings: ClusterSettings;
        /** @deprecated since v16.0.0 - use [`.setupPrimary()`](https://nodejs.org/docs/latest-v22.x/api/cluster.html#clustersetupprimarysettings) instead. */
        setupMaster(settings?: ClusterSettings): void;
        /**
         * `setupPrimary` is used to change the default 'fork' behavior. Once called, the settings will be present in `cluster.settings`.
         *
         * Any settings changes only affect future calls to [`.fork()`](https://nodejs.org/docs/latest-v22.x/api/cluster.html#clusterforkenv)
         * and have no effect on workers that are already running.
         *
         * The only attribute of a worker that cannot be set via `.setupPrimary()` is the `env` passed to
         * [`.fork()`](https://nodejs.org/docs/latest-v22.x/api/cluster.html#clusterforkenv).
         *
         * The defaults above apply to the first call only; the defaults for later calls are the current values at the time of
         * `cluster.setupPrimary()` is called.
         *
         * ```js
         * import cluster from 'node:cluster';
         *
         * cluster.setupPrimary({
         *   exec: 'worker.js',
         *   args: ['--use', 'https'],
         *   silent: true,
         * });
         * cluster.fork(); // https worker
         * cluster.setupPrimary({
         *   exec: 'worker.js',
         *   args: ['--use', 'http'],
         * });
         * cluster.fork(); // http worker
         * ```
         *
         * This can only be called from the primary process.
         * @since v16.0.0
         */
        setupPrimary(settings?: ClusterSettings): void;
        /**
         * A reference to the current worker object. Not available in the primary process.
         *
         * ```js
         * import cluster from 'node:cluster';
         *
         * if (cluster.isPrimary) {
         *   console.log('I am primary');
         *   cluster.fork();
         *   cluster.fork();
         * } else if (cluster.isWorker) {
         *   console.log(`I am worker #${cluster.worker.id}`);
         * }
         * ```
         * @since v0.7.0
         */
        readonly worker?: Worker;
        /**
         * A hash that stores the active worker objects, keyed by `id` field. This makes it easy to loop through all the workers. It is only available in the primary process.
         *
         * A worker is removed from `cluster.workers` after the worker has disconnected _and_ exited. The order between these two events cannot be determined in advance. However, it
         * is guaranteed that the removal from the `cluster.workers` list happens before the last `'disconnect'` or `'exit'` event is emitted.
         *
         * ```js
         * import cluster from 'node:cluster';
         *
         * for (const worker of Object.values(cluster.workers)) {
         *   worker.send('big announcement to all workers');
         * }
         * ```
         * @since v0.7.0
         */
        readonly workers?: NodeJS.Dict<Worker>;
        readonly SCHED_NONE: number;
        readonly SCHED_RR: number;
        /**
         * events.EventEmitter
         *   1. disconnect
         *   2. exit
         *   3. fork
         *   4. listening
         *   5. message
         *   6. online
         *   7. setup
         */
        addListener(event: string, listener: (...args: any[]) => void): this;
        addListener(event: "disconnect", listener: (worker: Worker) => void): this;
        addListener(event: "exit", listener: (worker: Worker, code: number, signal: string) => void): this;
        addListener(event: "fork", listener: (worker: Worker) => void): this;
        addListener(event: "listening", listener: (worker: Worker, address: Address) => void): this;
        addListener(
            event: "message",
            listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void,
        ): this; // the handle is a net.Socket or net.Server object, or undefined.
        addListener(event: "online", listener: (worker: Worker) => void): this;
        addListener(event: "setup", listener: (settings: ClusterSettings) => void): this;
        emit(event: string | symbol, ...args: any[]): boolean;
        emit(event: "disconnect", worker: Worker): boolean;
        emit(event: "exit", worker: Worker, code: number, signal: string): boolean;
        emit(event: "fork", worker: Worker): boolean;
        emit(event: "listening", worker: Worker, address: Address): boolean;
        emit(event: "message", worker: Worker, message: any, handle: net.Socket | net.Server): boolean;
        emit(event: "online", worker: Worker): boolean;
        emit(event: "setup", settings: ClusterSettings): boolean;
        on(event: string, listener: (...args: any[]) => void): this;
        on(event: "disconnect", listener: (worker: Worker) => void): this;
        on(event: "exit", listener: (worker: Worker, code: number, signal: string) => void): this;
        on(event: "fork", listener: (worker: Worker) => void): this;
        on(event: "listening", listener: (worker: Worker, address: Address) => void): this;
        on(event: "message", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): this; // the handle is a net.Socket or net.Server object, or undefined.
        on(event: "online", listener: (worker: Worker) => void): this;
        on(event: "setup", listener: (settings: ClusterSettings) => void): this;
        once(event: string, listener: (...args: any[]) => void): this;
        once(event: "disconnect", listener: (worker: Worker) => void): this;
        once(event: "exit", listener: (worker: Worker, code: number, signal: string) => void): this;
        once(event: "fork", listener: (worker: Worker) => void): this;
        once(event: "listening", listener: (worker: Worker, address: Address) => void): this;
        once(event: "message", listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void): this; // the handle is a net.Socket or net.Server object, or undefined.
        once(event: "online", listener: (worker: Worker) => void): this;
        once(event: "setup", listener: (settings: ClusterSettings) => void): this;
        prependListener(event: string, listener: (...args: any[]) => void): this;
        prependListener(event: "disconnect", listener: (worker: Worker) => void): this;
        prependListener(event: "exit", listener: (worker: Worker, code: number, signal: string) => void): this;
        prependListener(event: "fork", listener: (worker: Worker) => void): this;
        prependListener(event: "listening", listener: (worker: Worker, address: Address) => void): this;
        prependListener(
            event: "message",
            listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void,
        ): this;
        prependListener(event: "online", listener: (worker: Worker) => void): this;
        prependListener(event: "setup", listener: (settings: ClusterSettings) => void): this;
        prependOnceListener(event: string, listener: (...args: any[]) => void): this;
        prependOnceListener(event: "disconnect", listener: (worker: Worker) => void): this;
        prependOnceListener(event: "exit", listener: (worker: Worker, code: number, signal: string) => void): this;
        prependOnceListener(event: "fork", listener: (worker: Worker) => void): this;
        prependOnceListener(event: "listening", listener: (worker: Worker, address: Address) => void): this;
        // the handle is a net.Socket or net.Server object, or undefined.
        prependOnceListener(
            event: "message",
            listener: (worker: Worker, message: any, handle: net.Socket | net.Server) => void,
        ): this;
        prependOnceListener(event: "online", listener: (worker: Worker) => void): this;
        prependOnceListener(event: "setup", listener: (settings: ClusterSettings) => void): this;
    }
    const cluster: Cluster;
    export default cluster;
}
declare module "node:cluster" {
    export * from "cluster";
    export { default as default } from "cluster";
}

```

## ./lib/lambda/node_modules/@types/node/console.d.ts

```typescript
/**
 * The `node:console` module provides a simple debugging console that is similar to
 * the JavaScript console mechanism provided by web browsers.
 *
 * The module exports two specific components:
 *
 * * A `Console` class with methods such as `console.log()`, `console.error()`, and `console.warn()` that can be used to write to any Node.js stream.
 * * A global `console` instance configured to write to [`process.stdout`](https://nodejs.org/docs/latest-v22.x/api/process.html#processstdout) and
 * [`process.stderr`](https://nodejs.org/docs/latest-v22.x/api/process.html#processstderr). The global `console` can be used without importing the `node:console` module.
 *
 * _**Warning**_: The global console object's methods are neither consistently
 * synchronous like the browser APIs they resemble, nor are they consistently
 * asynchronous like all other Node.js streams. See the [`note on process I/O`](https://nodejs.org/docs/latest-v22.x/api/process.html#a-note-on-process-io) for
 * more information.
 *
 * Example using the global `console`:
 *
 * ```js
 * console.log('hello world');
 * // Prints: hello world, to stdout
 * console.log('hello %s', 'world');
 * // Prints: hello world, to stdout
 * console.error(new Error('Whoops, something bad happened'));
 * // Prints error message and stack trace to stderr:
 * //   Error: Whoops, something bad happened
 * //     at [eval]:5:15
 * //     at Script.runInThisContext (node:vm:132:18)
 * //     at Object.runInThisContext (node:vm:309:38)
 * //     at node:internal/process/execution:77:19
 * //     at [eval]-wrapper:6:22
 * //     at evalScript (node:internal/process/execution:76:60)
 * //     at node:internal/main/eval_string:23:3
 *
 * const name = 'Will Robinson';
 * console.warn(`Danger ${name}! Danger!`);
 * // Prints: Danger Will Robinson! Danger!, to stderr
 * ```
 *
 * Example using the `Console` class:
 *
 * ```js
 * const out = getStreamSomehow();
 * const err = getStreamSomehow();
 * const myConsole = new console.Console(out, err);
 *
 * myConsole.log('hello world');
 * // Prints: hello world, to out
 * myConsole.log('hello %s', 'world');
 * // Prints: hello world, to out
 * myConsole.error(new Error('Whoops, something bad happened'));
 * // Prints: [Error: Whoops, something bad happened], to err
 *
 * const name = 'Will Robinson';
 * myConsole.warn(`Danger ${name}! Danger!`);
 * // Prints: Danger Will Robinson! Danger!, to err
 * ```
 * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/console.js)
 */
declare module "console" {
    import console = require("node:console");
    export = console;
}
declare module "node:console" {
    import { InspectOptions } from "node:util";
    global {
        // This needs to be global to avoid TS2403 in case lib.dom.d.ts is present in the same build
        interface Console {
            Console: console.ConsoleConstructor;
            /**
             * `console.assert()` writes a message if `value` is [falsy](https://developer.mozilla.org/en-US/docs/Glossary/Falsy) or omitted. It only
             * writes a message and does not otherwise affect execution. The output always
             * starts with `"Assertion failed"`. If provided, `message` is formatted using
             * [`util.format()`](https://nodejs.org/docs/latest-v22.x/api/util.html#utilformatformat-args).
             *
             * If `value` is [truthy](https://developer.mozilla.org/en-US/docs/Glossary/Truthy), nothing happens.
             *
             * ```js
             * console.assert(true, 'does nothing');
             *
             * console.assert(false, 'Whoops %s work', 'didn\'t');
             * // Assertion failed: Whoops didn't work
             *
             * console.assert();
             * // Assertion failed
             * ```
             * @since v0.1.101
             * @param value The value tested for being truthy.
             * @param message All arguments besides `value` are used as error message.
             */
            assert(value: any, message?: string, ...optionalParams: any[]): void;
            /**
             * When `stdout` is a TTY, calling `console.clear()` will attempt to clear the
             * TTY. When `stdout` is not a TTY, this method does nothing.
             *
             * The specific operation of `console.clear()` can vary across operating systems
             * and terminal types. For most Linux operating systems, `console.clear()` operates similarly to the `clear` shell command. On Windows, `console.clear()` will clear only the output in the
             * current terminal viewport for the Node.js
             * binary.
             * @since v8.3.0
             */
            clear(): void;
            /**
             * Maintains an internal counter specific to `label` and outputs to `stdout` the
             * number of times `console.count()` has been called with the given `label`.
             *
             * ```js
             * > console.count()
             * default: 1
             * undefined
             * > console.count('default')
             * default: 2
             * undefined
             * > console.count('abc')
             * abc: 1
             * undefined
             * > console.count('xyz')
             * xyz: 1
             * undefined
             * > console.count('abc')
             * abc: 2
             * undefined
             * > console.count()
             * default: 3
             * undefined
             * >
             * ```
             * @since v8.3.0
             * @param [label='default'] The display label for the counter.
             */
            count(label?: string): void;
            /**
             * Resets the internal counter specific to `label`.
             *
             * ```js
             * > console.count('abc');
             * abc: 1
             * undefined
             * > console.countReset('abc');
             * undefined
             * > console.count('abc');
             * abc: 1
             * undefined
             * >
             * ```
             * @since v8.3.0
             * @param [label='default'] The display label for the counter.
             */
            countReset(label?: string): void;
            /**
             * The `console.debug()` function is an alias for {@link log}.
             * @since v8.0.0
             */
            debug(message?: any, ...optionalParams: any[]): void;
            /**
             * Uses [`util.inspect()`](https://nodejs.org/docs/latest-v22.x/api/util.html#utilinspectobject-options) on `obj` and prints the resulting string to `stdout`.
             * This function bypasses any custom `inspect()` function defined on `obj`.
             * @since v0.1.101
             */
            dir(obj: any, options?: InspectOptions): void;
            /**
             * This method calls `console.log()` passing it the arguments received.
             * This method does not produce any XML formatting.
             * @since v8.0.0
             */
            dirxml(...data: any[]): void;
            /**
             * Prints to `stderr` with newline. Multiple arguments can be passed, with the
             * first used as the primary message and all additional used as substitution
             * values similar to [`printf(3)`](http://man7.org/linux/man-pages/man3/printf.3.html)
             * (the arguments are all passed to [`util.format()`](https://nodejs.org/docs/latest-v22.x/api/util.html#utilformatformat-args)).
             *
             * ```js
             * const code = 5;
             * console.error('error #%d', code);
             * // Prints: error #5, to stderr
             * console.error('error', code);
             * // Prints: error 5, to stderr
             * ```
             *
             * If formatting elements (e.g. `%d`) are not found in the first string then
             * [`util.inspect()`](https://nodejs.org/docs/latest-v22.x/api/util.html#utilinspectobject-options) is called on each argument and the
             * resulting string values are concatenated. See [`util.format()`](https://nodejs.org/docs/latest-v22.x/api/util.html#utilformatformat-args)
             * for more information.
             * @since v0.1.100
             */
            error(message?: any, ...optionalParams: any[]): void;
            /**
             * Increases indentation of subsequent lines by spaces for `groupIndentation` length.
             *
             * If one or more `label`s are provided, those are printed first without the
             * additional indentation.
             * @since v8.5.0
             */
            group(...label: any[]): void;
            /**
             * An alias for {@link group}.
             * @since v8.5.0
             */
            groupCollapsed(...label: any[]): void;
            /**
             * Decreases indentation of subsequent lines by spaces for `groupIndentation` length.
             * @since v8.5.0
             */
            groupEnd(): void;
            /**
             * The `console.info()` function is an alias for {@link log}.
             * @since v0.1.100
             */
            info(message?: any, ...optionalParams: any[]): void;
            /**
             * Prints to `stdout` with newline. Multiple arguments can be passed, with the
             * first used as the primary message and all additional used as substitution
             * values similar to [`printf(3)`](http://man7.org/linux/man-pages/man3/printf.3.html)
             * (the arguments are all passed to [`util.format()`](https://nodejs.org/docs/latest-v22.x/api/util.html#utilformatformat-args)).
             *
             * ```js
             * const count = 5;
             * console.log('count: %d', count);
             * // Prints: count: 5, to stdout
             * console.log('count:', count);
             * // Prints: count: 5, to stdout
             * ```
             *
             * See [`util.format()`](https://nodejs.org/docs/latest-v22.x/api/util.html#utilformatformat-args) for more information.
             * @since v0.1.100
             */
            log(message?: any, ...optionalParams: any[]): void;
            /**
             * Try to construct a table with the columns of the properties of `tabularData` (or use `properties`) and rows of `tabularData` and log it. Falls back to just
             * logging the argument if it can't be parsed as tabular.
             *
             * ```js
             * // These can't be parsed as tabular data
             * console.table(Symbol());
             * // Symbol()
             *
             * console.table(undefined);
             * // undefined
             *
             * console.table([{ a: 1, b: 'Y' }, { a: 'Z', b: 2 }]);
             * // 
             * //  (index)   a    b  
             * // 
             * //     0      1   'Y' 
             * //     1     'Z'   2  
             * // 
             *
             * console.table([{ a: 1, b: 'Y' }, { a: 'Z', b: 2 }], ['a']);
             * // 
             * //  (index)   a  
             * // 
             * //     0      1  
             * //     1     'Z' 
             * // 
             * ```
             * @since v10.0.0
             * @param properties Alternate properties for constructing the table.
             */
            table(tabularData: any, properties?: readonly string[]): void;
            /**
             * Starts a timer that can be used to compute the duration of an operation. Timers
             * are identified by a unique `label`. Use the same `label` when calling {@link timeEnd} to stop the timer and output the elapsed time in
             * suitable time units to `stdout`. For example, if the elapsed
             * time is 3869ms, `console.timeEnd()` displays "3.869s".
             * @since v0.1.104
             * @param [label='default']
             */
            time(label?: string): void;
            /**
             * Stops a timer that was previously started by calling {@link time} and
             * prints the result to `stdout`:
             *
             * ```js
             * console.time('bunch-of-stuff');
             * // Do a bunch of stuff.
             * console.timeEnd('bunch-of-stuff');
             * // Prints: bunch-of-stuff: 225.438ms
             * ```
             * @since v0.1.104
             * @param [label='default']
             */
            timeEnd(label?: string): void;
            /**
             * For a timer that was previously started by calling {@link time}, prints
             * the elapsed time and other `data` arguments to `stdout`:
             *
             * ```js
             * console.time('process');
             * const value = expensiveProcess1(); // Returns 42
             * console.timeLog('process', value);
             * // Prints "process: 365.227ms 42".
             * doExpensiveProcess2(value);
             * console.timeEnd('process');
             * ```
             * @since v10.7.0
             * @param [label='default']
             */
            timeLog(label?: string, ...data: any[]): void;
            /**
             * Prints to `stderr` the string `'Trace: '`, followed by the [`util.format()`](https://nodejs.org/docs/latest-v22.x/api/util.html#utilformatformat-args)
             * formatted message and stack trace to the current position in the code.
             *
             * ```js
             * console.trace('Show me');
             * // Prints: (stack trace will vary based on where trace is called)
             * //  Trace: Show me
             * //    at repl:2:9
             * //    at REPLServer.defaultEval (repl.js:248:27)
             * //    at bound (domain.js:287:14)
             * //    at REPLServer.runBound [as eval] (domain.js:300:12)
             * //    at REPLServer.<anonymous> (repl.js:412:12)
             * //    at emitOne (events.js:82:20)
             * //    at REPLServer.emit (events.js:169:7)
             * //    at REPLServer.Interface._onLine (readline.js:210:10)
             * //    at REPLServer.Interface._line (readline.js:549:8)
             * //    at REPLServer.Interface._ttyWrite (readline.js:826:14)
             * ```
             * @since v0.1.104
             */
            trace(message?: any, ...optionalParams: any[]): void;
            /**
             * The `console.warn()` function is an alias for {@link error}.
             * @since v0.1.100
             */
            warn(message?: any, ...optionalParams: any[]): void;
            // --- Inspector mode only ---
            /**
             * This method does not display anything unless used in the inspector. The `console.profile()`
             * method starts a JavaScript CPU profile with an optional label until {@link profileEnd}
             * is called. The profile is then added to the Profile panel of the inspector.
             *
             * ```js
             * console.profile('MyLabel');
             * // Some code
             * console.profileEnd('MyLabel');
             * // Adds the profile 'MyLabel' to the Profiles panel of the inspector.
             * ```
             * @since v8.0.0
             */
            profile(label?: string): void;
            /**
             * This method does not display anything unless used in the inspector. Stops the current
             * JavaScript CPU profiling session if one has been started and prints the report to the
             * Profiles panel of the inspector. See {@link profile} for an example.
             *
             * If this method is called without a label, the most recently started profile is stopped.
             * @since v8.0.0
             */
            profileEnd(label?: string): void;
            /**
             * This method does not display anything unless used in the inspector. The `console.timeStamp()`
             * method adds an event with the label `'label'` to the Timeline panel of the inspector.
             * @since v8.0.0
             */
            timeStamp(label?: string): void;
        }
        /**
         * The `console` module provides a simple debugging console that is similar to the
         * JavaScript console mechanism provided by web browsers.
         *
         * The module exports two specific components:
         *
         * * A `Console` class with methods such as `console.log()`, `console.error()` and `console.warn()` that can be used to write to any Node.js stream.
         * * A global `console` instance configured to write to [`process.stdout`](https://nodejs.org/docs/latest-v22.x/api/process.html#processstdout) and
         * [`process.stderr`](https://nodejs.org/docs/latest-v22.x/api/process.html#processstderr). The global `console` can be used without importing the `node:console` module.
         *
         * _**Warning**_: The global console object's methods are neither consistently
         * synchronous like the browser APIs they resemble, nor are they consistently
         * asynchronous like all other Node.js streams. See the [`note on process I/O`](https://nodejs.org/docs/latest-v22.x/api/process.html#a-note-on-process-io) for
         * more information.
         *
         * Example using the global `console`:
         *
         * ```js
         * console.log('hello world');
         * // Prints: hello world, to stdout
         * console.log('hello %s', 'world');
         * // Prints: hello world, to stdout
         * console.error(new Error('Whoops, something bad happened'));
         * // Prints error message and stack trace to stderr:
         * //   Error: Whoops, something bad happened
         * //     at [eval]:5:15
         * //     at Script.runInThisContext (node:vm:132:18)
         * //     at Object.runInThisContext (node:vm:309:38)
         * //     at node:internal/process/execution:77:19
         * //     at [eval]-wrapper:6:22
         * //     at evalScript (node:internal/process/execution:76:60)
         * //     at node:internal/main/eval_string:23:3
         *
         * const name = 'Will Robinson';
         * console.warn(`Danger ${name}! Danger!`);
         * // Prints: Danger Will Robinson! Danger!, to stderr
         * ```
         *
         * Example using the `Console` class:
         *
         * ```js
         * const out = getStreamSomehow();
         * const err = getStreamSomehow();
         * const myConsole = new console.Console(out, err);
         *
         * myConsole.log('hello world');
         * // Prints: hello world, to out
         * myConsole.log('hello %s', 'world');
         * // Prints: hello world, to out
         * myConsole.error(new Error('Whoops, something bad happened'));
         * // Prints: [Error: Whoops, something bad happened], to err
         *
         * const name = 'Will Robinson';
         * myConsole.warn(`Danger ${name}! Danger!`);
         * // Prints: Danger Will Robinson! Danger!, to err
         * ```
         * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/console.js)
         */
        namespace console {
            interface ConsoleConstructorOptions {
                stdout: NodeJS.WritableStream;
                stderr?: NodeJS.WritableStream | undefined;
                /**
                 * Ignore errors when writing to the underlying streams.
                 * @default true
                 */
                ignoreErrors?: boolean | undefined;
                /**
                 * Set color support for this `Console` instance. Setting to true enables coloring while inspecting
                 * values. Setting to `false` disables coloring while inspecting values. Setting to `'auto'` makes color
                 * support depend on the value of the `isTTY` property and the value returned by `getColorDepth()` on the
                 * respective stream. This option can not be used, if `inspectOptions.colors` is set as well.
                 * @default auto
                 */
                colorMode?: boolean | "auto" | undefined;
                /**
                 * Specifies options that are passed along to
                 * [`util.inspect()`](https://nodejs.org/docs/latest-v22.x/api/util.html#utilinspectobject-options).
                 */
                inspectOptions?: InspectOptions | undefined;
                /**
                 * Set group indentation.
                 * @default 2
                 */
                groupIndentation?: number | undefined;
            }
            interface ConsoleConstructor {
                prototype: Console;
                new(stdout: NodeJS.WritableStream, stderr?: NodeJS.WritableStream, ignoreErrors?: boolean): Console;
                new(options: ConsoleConstructorOptions): Console;
            }
        }
        var console: Console;
    }
    export = globalThis.console;
}

```

## ./lib/lambda/node_modules/@types/node/constants.d.ts

```typescript
/**
 * @deprecated The `node:constants` module is deprecated. When requiring access to constants
 * relevant to specific Node.js builtin modules, developers should instead refer
 * to the `constants` property exposed by the relevant module. For instance,
 * `require('node:fs').constants` and `require('node:os').constants`.
 */
declare module "constants" {
    const constants:
        & typeof import("node:os").constants.dlopen
        & typeof import("node:os").constants.errno
        & typeof import("node:os").constants.priority
        & typeof import("node:os").constants.signals
        & typeof import("node:fs").constants
        & typeof import("node:crypto").constants;
    export = constants;
}

declare module "node:constants" {
    import constants = require("constants");
    export = constants;
}

```

## ./lib/lambda/node_modules/@types/node/crypto.d.ts

```typescript
/**
 * The `node:crypto` module provides cryptographic functionality that includes a
 * set of wrappers for OpenSSL's hash, HMAC, cipher, decipher, sign, and verify
 * functions.
 *
 * ```js
 * const { createHmac } = await import('node:crypto');
 *
 * const secret = 'abcdefg';
 * const hash = createHmac('sha256', secret)
 *                .update('I love cupcakes')
 *                .digest('hex');
 * console.log(hash);
 * // Prints:
 * //   c0fa1bc00531bd78ef38c628449c5102aeabd49b5dc3a2a516ea6ea959d6658e
 * ```
 * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/crypto.js)
 */
declare module "crypto" {
    import * as stream from "node:stream";
    import { PeerCertificate } from "node:tls";
    /**
     * SPKAC is a Certificate Signing Request mechanism originally implemented by
     * Netscape and was specified formally as part of HTML5's `keygen` element.
     *
     * `<keygen>` is deprecated since [HTML 5.2](https://www.w3.org/TR/html52/changes.html#features-removed) and new projects
     * should not use this element anymore.
     *
     * The `node:crypto` module provides the `Certificate` class for working with SPKAC
     * data. The most common usage is handling output generated by the HTML5 `<keygen>` element. Node.js uses [OpenSSL's SPKAC
     * implementation](https://www.openssl.org/docs/man3.0/man1/openssl-spkac.html) internally.
     * @since v0.11.8
     */
    class Certificate {
        /**
         * ```js
         * const { Certificate } = await import('node:crypto');
         * const spkac = getSpkacSomehow();
         * const challenge = Certificate.exportChallenge(spkac);
         * console.log(challenge.toString('utf8'));
         * // Prints: the challenge as a UTF8 string
         * ```
         * @since v9.0.0
         * @param encoding The `encoding` of the `spkac` string.
         * @return The challenge component of the `spkac` data structure, which includes a public key and a challenge.
         */
        static exportChallenge(spkac: BinaryLike): Buffer;
        /**
         * ```js
         * const { Certificate } = await import('node:crypto');
         * const spkac = getSpkacSomehow();
         * const publicKey = Certificate.exportPublicKey(spkac);
         * console.log(publicKey);
         * // Prints: the public key as <Buffer ...>
         * ```
         * @since v9.0.0
         * @param encoding The `encoding` of the `spkac` string.
         * @return The public key component of the `spkac` data structure, which includes a public key and a challenge.
         */
        static exportPublicKey(spkac: BinaryLike, encoding?: string): Buffer;
        /**
         * ```js
         * import { Buffer } from 'node:buffer';
         * const { Certificate } = await import('node:crypto');
         *
         * const spkac = getSpkacSomehow();
         * console.log(Certificate.verifySpkac(Buffer.from(spkac)));
         * // Prints: true or false
         * ```
         * @since v9.0.0
         * @param encoding The `encoding` of the `spkac` string.
         * @return `true` if the given `spkac` data structure is valid, `false` otherwise.
         */
        static verifySpkac(spkac: NodeJS.ArrayBufferView): boolean;
        /**
         * @deprecated
         * @param spkac
         * @returns The challenge component of the `spkac` data structure,
         * which includes a public key and a challenge.
         */
        exportChallenge(spkac: BinaryLike): Buffer;
        /**
         * @deprecated
         * @param spkac
         * @param encoding The encoding of the spkac string.
         * @returns The public key component of the `spkac` data structure,
         * which includes a public key and a challenge.
         */
        exportPublicKey(spkac: BinaryLike, encoding?: string): Buffer;
        /**
         * @deprecated
         * @param spkac
         * @returns `true` if the given `spkac` data structure is valid,
         * `false` otherwise.
         */
        verifySpkac(spkac: NodeJS.ArrayBufferView): boolean;
    }
    namespace constants {
        // https://nodejs.org/dist/latest-v22.x/docs/api/crypto.html#crypto-constants
        const OPENSSL_VERSION_NUMBER: number;
        /** Applies multiple bug workarounds within OpenSSL. See https://www.openssl.org/docs/man1.0.2/ssl/SSL_CTX_set_options.html for detail. */
        const SSL_OP_ALL: number;
        /** Instructs OpenSSL to allow a non-[EC]DHE-based key exchange mode for TLS v1.3 */
        const SSL_OP_ALLOW_NO_DHE_KEX: number;
        /** Allows legacy insecure renegotiation between OpenSSL and unpatched clients or servers. See https://www.openssl.org/docs/man1.0.2/ssl/SSL_CTX_set_options.html. */
        const SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION: number;
        /** Attempts to use the server's preferences instead of the client's when selecting a cipher. See https://www.openssl.org/docs/man1.0.2/ssl/SSL_CTX_set_options.html. */
        const SSL_OP_CIPHER_SERVER_PREFERENCE: number;
        /** Instructs OpenSSL to use Cisco's version identifier of DTLS_BAD_VER. */
        const SSL_OP_CISCO_ANYCONNECT: number;
        /** Instructs OpenSSL to turn on cookie exchange. */
        const SSL_OP_COOKIE_EXCHANGE: number;
        /** Instructs OpenSSL to add server-hello extension from an early version of the cryptopro draft. */
        const SSL_OP_CRYPTOPRO_TLSEXT_BUG: number;
        /** Instructs OpenSSL to disable a SSL 3.0/TLS 1.0 vulnerability workaround added in OpenSSL 0.9.6d. */
        const SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS: number;
        /** Allows initial connection to servers that do not support RI. */
        const SSL_OP_LEGACY_SERVER_CONNECT: number;
        /** Instructs OpenSSL to disable support for SSL/TLS compression. */
        const SSL_OP_NO_COMPRESSION: number;
        /** Instructs OpenSSL to disable encrypt-then-MAC. */
        const SSL_OP_NO_ENCRYPT_THEN_MAC: number;
        const SSL_OP_NO_QUERY_MTU: number;
        /** Instructs OpenSSL to disable renegotiation. */
        const SSL_OP_NO_RENEGOTIATION: number;
        /** Instructs OpenSSL to always start a new session when performing renegotiation. */
        const SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION: number;
        /** Instructs OpenSSL to turn off SSL v2 */
        const SSL_OP_NO_SSLv2: number;
        /** Instructs OpenSSL to turn off SSL v3 */
        const SSL_OP_NO_SSLv3: number;
        /** Instructs OpenSSL to disable use of RFC4507bis tickets. */
        const SSL_OP_NO_TICKET: number;
        /** Instructs OpenSSL to turn off TLS v1 */
        const SSL_OP_NO_TLSv1: number;
        /** Instructs OpenSSL to turn off TLS v1.1 */
        const SSL_OP_NO_TLSv1_1: number;
        /** Instructs OpenSSL to turn off TLS v1.2 */
        const SSL_OP_NO_TLSv1_2: number;
        /** Instructs OpenSSL to turn off TLS v1.3 */
        const SSL_OP_NO_TLSv1_3: number;
        /** Instructs OpenSSL server to prioritize ChaCha20-Poly1305 when the client does. This option has no effect if `SSL_OP_CIPHER_SERVER_PREFERENCE` is not enabled. */
        const SSL_OP_PRIORITIZE_CHACHA: number;
        /** Instructs OpenSSL to disable version rollback attack detection. */
        const SSL_OP_TLS_ROLLBACK_BUG: number;
        const ENGINE_METHOD_RSA: number;
        const ENGINE_METHOD_DSA: number;
        const ENGINE_METHOD_DH: number;
        const ENGINE_METHOD_RAND: number;
        const ENGINE_METHOD_EC: number;
        const ENGINE_METHOD_CIPHERS: number;
        const ENGINE_METHOD_DIGESTS: number;
        const ENGINE_METHOD_PKEY_METHS: number;
        const ENGINE_METHOD_PKEY_ASN1_METHS: number;
        const ENGINE_METHOD_ALL: number;
        const ENGINE_METHOD_NONE: number;
        const DH_CHECK_P_NOT_SAFE_PRIME: number;
        const DH_CHECK_P_NOT_PRIME: number;
        const DH_UNABLE_TO_CHECK_GENERATOR: number;
        const DH_NOT_SUITABLE_GENERATOR: number;
        const RSA_PKCS1_PADDING: number;
        const RSA_SSLV23_PADDING: number;
        const RSA_NO_PADDING: number;
        const RSA_PKCS1_OAEP_PADDING: number;
        const RSA_X931_PADDING: number;
        const RSA_PKCS1_PSS_PADDING: number;
        /** Sets the salt length for RSA_PKCS1_PSS_PADDING to the digest size when signing or verifying. */
        const RSA_PSS_SALTLEN_DIGEST: number;
        /** Sets the salt length for RSA_PKCS1_PSS_PADDING to the maximum permissible value when signing data. */
        const RSA_PSS_SALTLEN_MAX_SIGN: number;
        /** Causes the salt length for RSA_PKCS1_PSS_PADDING to be determined automatically when verifying a signature. */
        const RSA_PSS_SALTLEN_AUTO: number;
        const POINT_CONVERSION_COMPRESSED: number;
        const POINT_CONVERSION_UNCOMPRESSED: number;
        const POINT_CONVERSION_HYBRID: number;
        /** Specifies the built-in default cipher list used by Node.js (colon-separated values). */
        const defaultCoreCipherList: string;
        /** Specifies the active default cipher list used by the current Node.js process  (colon-separated values). */
        const defaultCipherList: string;
    }
    interface HashOptions extends stream.TransformOptions {
        /**
         * For XOF hash functions such as `shake256`, the
         * outputLength option can be used to specify the desired output length in bytes.
         */
        outputLength?: number | undefined;
    }
    /** @deprecated since v10.0.0 */
    const fips: boolean;
    /**
     * Creates and returns a `Hash` object that can be used to generate hash digests
     * using the given `algorithm`. Optional `options` argument controls stream
     * behavior. For XOF hash functions such as `'shake256'`, the `outputLength` option
     * can be used to specify the desired output length in bytes.
     *
     * The `algorithm` is dependent on the available algorithms supported by the
     * version of OpenSSL on the platform. Examples are `'sha256'`, `'sha512'`, etc.
     * On recent releases of OpenSSL, `openssl list -digest-algorithms` will
     * display the available digest algorithms.
     *
     * Example: generating the sha256 sum of a file
     *
     * ```js
     * import {
     *   createReadStream,
     * } from 'node:fs';
     * import { argv } from 'node:process';
     * const {
     *   createHash,
     * } = await import('node:crypto');
     *
     * const filename = argv[2];
     *
     * const hash = createHash('sha256');
     *
     * const input = createReadStream(filename);
     * input.on('readable', () => {
     *   // Only one element is going to be produced by the
     *   // hash stream.
     *   const data = input.read();
     *   if (data)
     *     hash.update(data);
     *   else {
     *     console.log(`${hash.digest('hex')} ${filename}`);
     *   }
     * });
     * ```
     * @since v0.1.92
     * @param options `stream.transform` options
     */
    function createHash(algorithm: string, options?: HashOptions): Hash;
    /**
     * Creates and returns an `Hmac` object that uses the given `algorithm` and `key`.
     * Optional `options` argument controls stream behavior.
     *
     * The `algorithm` is dependent on the available algorithms supported by the
     * version of OpenSSL on the platform. Examples are `'sha256'`, `'sha512'`, etc.
     * On recent releases of OpenSSL, `openssl list -digest-algorithms` will
     * display the available digest algorithms.
     *
     * The `key` is the HMAC key used to generate the cryptographic HMAC hash. If it is
     * a `KeyObject`, its type must be `secret`. If it is a string, please consider `caveats when using strings as inputs to cryptographic APIs`. If it was
     * obtained from a cryptographically secure source of entropy, such as {@link randomBytes} or {@link generateKey}, its length should not
     * exceed the block size of `algorithm` (e.g., 512 bits for SHA-256).
     *
     * Example: generating the sha256 HMAC of a file
     *
     * ```js
     * import {
     *   createReadStream,
     * } from 'node:fs';
     * import { argv } from 'node:process';
     * const {
     *   createHmac,
     * } = await import('node:crypto');
     *
     * const filename = argv[2];
     *
     * const hmac = createHmac('sha256', 'a secret');
     *
     * const input = createReadStream(filename);
     * input.on('readable', () => {
     *   // Only one element is going to be produced by the
     *   // hash stream.
     *   const data = input.read();
     *   if (data)
     *     hmac.update(data);
     *   else {
     *     console.log(`${hmac.digest('hex')} ${filename}`);
     *   }
     * });
     * ```
     * @since v0.1.94
     * @param options `stream.transform` options
     */
    function createHmac(algorithm: string, key: BinaryLike | KeyObject, options?: stream.TransformOptions): Hmac;
    // https://nodejs.org/api/buffer.html#buffer_buffers_and_character_encodings
    type BinaryToTextEncoding = "base64" | "base64url" | "hex" | "binary";
    type CharacterEncoding = "utf8" | "utf-8" | "utf16le" | "utf-16le" | "latin1";
    type LegacyCharacterEncoding = "ascii" | "binary" | "ucs2" | "ucs-2";
    type Encoding = BinaryToTextEncoding | CharacterEncoding | LegacyCharacterEncoding;
    type ECDHKeyFormat = "compressed" | "uncompressed" | "hybrid";
    /**
     * The `Hash` class is a utility for creating hash digests of data. It can be
     * used in one of two ways:
     *
     * * As a `stream` that is both readable and writable, where data is written
     * to produce a computed hash digest on the readable side, or
     * * Using the `hash.update()` and `hash.digest()` methods to produce the
     * computed hash.
     *
     * The {@link createHash} method is used to create `Hash` instances. `Hash`objects are not to be created directly using the `new` keyword.
     *
     * Example: Using `Hash` objects as streams:
     *
     * ```js
     * const {
     *   createHash,
     * } = await import('node:crypto');
     *
     * const hash = createHash('sha256');
     *
     * hash.on('readable', () => {
     *   // Only one element is going to be produced by the
     *   // hash stream.
     *   const data = hash.read();
     *   if (data) {
     *     console.log(data.toString('hex'));
     *     // Prints:
     *     //   6a2da20943931e9834fc12cfe5bb47bbd9ae43489a30726962b576f4e3993e50
     *   }
     * });
     *
     * hash.write('some data to hash');
     * hash.end();
     * ```
     *
     * Example: Using `Hash` and piped streams:
     *
     * ```js
     * import { createReadStream } from 'node:fs';
     * import { stdout } from 'node:process';
     * const { createHash } = await import('node:crypto');
     *
     * const hash = createHash('sha256');
     *
     * const input = createReadStream('test.js');
     * input.pipe(hash).setEncoding('hex').pipe(stdout);
     * ```
     *
     * Example: Using the `hash.update()` and `hash.digest()` methods:
     *
     * ```js
     * const {
     *   createHash,
     * } = await import('node:crypto');
     *
     * const hash = createHash('sha256');
     *
     * hash.update('some data to hash');
     * console.log(hash.digest('hex'));
     * // Prints:
     * //   6a2da20943931e9834fc12cfe5bb47bbd9ae43489a30726962b576f4e3993e50
     * ```
     * @since v0.1.92
     */
    class Hash extends stream.Transform {
        private constructor();
        /**
         * Creates a new `Hash` object that contains a deep copy of the internal state
         * of the current `Hash` object.
         *
         * The optional `options` argument controls stream behavior. For XOF hash
         * functions such as `'shake256'`, the `outputLength` option can be used to
         * specify the desired output length in bytes.
         *
         * An error is thrown when an attempt is made to copy the `Hash` object after
         * its `hash.digest()` method has been called.
         *
         * ```js
         * // Calculate a rolling hash.
         * const {
         *   createHash,
         * } = await import('node:crypto');
         *
         * const hash = createHash('sha256');
         *
         * hash.update('one');
         * console.log(hash.copy().digest('hex'));
         *
         * hash.update('two');
         * console.log(hash.copy().digest('hex'));
         *
         * hash.update('three');
         * console.log(hash.copy().digest('hex'));
         *
         * // Etc.
         * ```
         * @since v13.1.0
         * @param options `stream.transform` options
         */
        copy(options?: HashOptions): Hash;
        /**
         * Updates the hash content with the given `data`, the encoding of which
         * is given in `inputEncoding`.
         * If `encoding` is not provided, and the `data` is a string, an
         * encoding of `'utf8'` is enforced. If `data` is a `Buffer`, `TypedArray`, or`DataView`, then `inputEncoding` is ignored.
         *
         * This can be called many times with new data as it is streamed.
         * @since v0.1.92
         * @param inputEncoding The `encoding` of the `data` string.
         */
        update(data: BinaryLike): Hash;
        update(data: string, inputEncoding: Encoding): Hash;
        /**
         * Calculates the digest of all of the data passed to be hashed (using the `hash.update()` method).
         * If `encoding` is provided a string will be returned; otherwise
         * a `Buffer` is returned.
         *
         * The `Hash` object can not be used again after `hash.digest()` method has been
         * called. Multiple calls will cause an error to be thrown.
         * @since v0.1.92
         * @param encoding The `encoding` of the return value.
         */
        digest(): Buffer;
        digest(encoding: BinaryToTextEncoding): string;
    }
    /**
     * The `Hmac` class is a utility for creating cryptographic HMAC digests. It can
     * be used in one of two ways:
     *
     * * As a `stream` that is both readable and writable, where data is written
     * to produce a computed HMAC digest on the readable side, or
     * * Using the `hmac.update()` and `hmac.digest()` methods to produce the
     * computed HMAC digest.
     *
     * The {@link createHmac} method is used to create `Hmac` instances. `Hmac`objects are not to be created directly using the `new` keyword.
     *
     * Example: Using `Hmac` objects as streams:
     *
     * ```js
     * const {
     *   createHmac,
     * } = await import('node:crypto');
     *
     * const hmac = createHmac('sha256', 'a secret');
     *
     * hmac.on('readable', () => {
     *   // Only one element is going to be produced by the
     *   // hash stream.
     *   const data = hmac.read();
     *   if (data) {
     *     console.log(data.toString('hex'));
     *     // Prints:
     *     //   7fd04df92f636fd450bc841c9418e5825c17f33ad9c87c518115a45971f7f77e
     *   }
     * });
     *
     * hmac.write('some data to hash');
     * hmac.end();
     * ```
     *
     * Example: Using `Hmac` and piped streams:
     *
     * ```js
     * import { createReadStream } from 'node:fs';
     * import { stdout } from 'node:process';
     * const {
     *   createHmac,
     * } = await import('node:crypto');
     *
     * const hmac = createHmac('sha256', 'a secret');
     *
     * const input = createReadStream('test.js');
     * input.pipe(hmac).pipe(stdout);
     * ```
     *
     * Example: Using the `hmac.update()` and `hmac.digest()` methods:
     *
     * ```js
     * const {
     *   createHmac,
     * } = await import('node:crypto');
     *
     * const hmac = createHmac('sha256', 'a secret');
     *
     * hmac.update('some data to hash');
     * console.log(hmac.digest('hex'));
     * // Prints:
     * //   7fd04df92f636fd450bc841c9418e5825c17f33ad9c87c518115a45971f7f77e
     * ```
     * @since v0.1.94
     * @deprecated Since v20.13.0 Calling `Hmac` class directly with `Hmac()` or `new Hmac()` is deprecated due to being internals, not intended for public use. Please use the {@link createHmac} method to create Hmac instances.
     */
    class Hmac extends stream.Transform {
        private constructor();
        /**
         * Updates the `Hmac` content with the given `data`, the encoding of which
         * is given in `inputEncoding`.
         * If `encoding` is not provided, and the `data` is a string, an
         * encoding of `'utf8'` is enforced. If `data` is a `Buffer`, `TypedArray`, or`DataView`, then `inputEncoding` is ignored.
         *
         * This can be called many times with new data as it is streamed.
         * @since v0.1.94
         * @param inputEncoding The `encoding` of the `data` string.
         */
        update(data: BinaryLike): Hmac;
        update(data: string, inputEncoding: Encoding): Hmac;
        /**
         * Calculates the HMAC digest of all of the data passed using `hmac.update()`.
         * If `encoding` is
         * provided a string is returned; otherwise a `Buffer` is returned;
         *
         * The `Hmac` object can not be used again after `hmac.digest()` has been
         * called. Multiple calls to `hmac.digest()` will result in an error being thrown.
         * @since v0.1.94
         * @param encoding The `encoding` of the return value.
         */
        digest(): Buffer;
        digest(encoding: BinaryToTextEncoding): string;
    }
    type KeyObjectType = "secret" | "public" | "private";
    interface KeyExportOptions<T extends KeyFormat> {
        type: "pkcs1" | "spki" | "pkcs8" | "sec1";
        format: T;
        cipher?: string | undefined;
        passphrase?: string | Buffer | undefined;
    }
    interface JwkKeyExportOptions {
        format: "jwk";
    }
    interface JsonWebKey {
        crv?: string;
        d?: string;
        dp?: string;
        dq?: string;
        e?: string;
        k?: string;
        kty?: string;
        n?: string;
        p?: string;
        q?: string;
        qi?: string;
        x?: string;
        y?: string;
        [key: string]: unknown;
    }
    interface AsymmetricKeyDetails {
        /**
         * Key size in bits (RSA, DSA).
         */
        modulusLength?: number;
        /**
         * Public exponent (RSA).
         */
        publicExponent?: bigint;
        /**
         * Name of the message digest (RSA-PSS).
         */
        hashAlgorithm?: string;
        /**
         * Name of the message digest used by MGF1 (RSA-PSS).
         */
        mgf1HashAlgorithm?: string;
        /**
         * Minimal salt length in bytes (RSA-PSS).
         */
        saltLength?: number;
        /**
         * Size of q in bits (DSA).
         */
        divisorLength?: number;
        /**
         * Name of the curve (EC).
         */
        namedCurve?: string;
    }
    /**
     * Node.js uses a `KeyObject` class to represent a symmetric or asymmetric key,
     * and each kind of key exposes different functions. The {@link createSecretKey}, {@link createPublicKey} and {@link createPrivateKey} methods are used to create `KeyObject`instances. `KeyObject`
     * objects are not to be created directly using the `new`keyword.
     *
     * Most applications should consider using the new `KeyObject` API instead of
     * passing keys as strings or `Buffer`s due to improved security features.
     *
     * `KeyObject` instances can be passed to other threads via `postMessage()`.
     * The receiver obtains a cloned `KeyObject`, and the `KeyObject` does not need to
     * be listed in the `transferList` argument.
     * @since v11.6.0
     */
    class KeyObject {
        private constructor();
        /**
         * Example: Converting a `CryptoKey` instance to a `KeyObject`:
         *
         * ```js
         * const { KeyObject } = await import('node:crypto');
         * const { subtle } = globalThis.crypto;
         *
         * const key = await subtle.generateKey({
         *   name: 'HMAC',
         *   hash: 'SHA-256',
         *   length: 256,
         * }, true, ['sign', 'verify']);
         *
         * const keyObject = KeyObject.from(key);
         * console.log(keyObject.symmetricKeySize);
         * // Prints: 32 (symmetric key size in bytes)
         * ```
         * @since v15.0.0
         */
        static from(key: webcrypto.CryptoKey): KeyObject;
        /**
         * For asymmetric keys, this property represents the type of the key. Supported key
         * types are:
         *
         * * `'rsa'` (OID 1.2.840.113549.1.1.1)
         * * `'rsa-pss'` (OID 1.2.840.113549.1.1.10)
         * * `'dsa'` (OID 1.2.840.10040.4.1)
         * * `'ec'` (OID 1.2.840.10045.2.1)
         * * `'x25519'` (OID 1.3.101.110)
         * * `'x448'` (OID 1.3.101.111)
         * * `'ed25519'` (OID 1.3.101.112)
         * * `'ed448'` (OID 1.3.101.113)
         * * `'dh'` (OID 1.2.840.113549.1.3.1)
         *
         * This property is `undefined` for unrecognized `KeyObject` types and symmetric
         * keys.
         * @since v11.6.0
         */
        asymmetricKeyType?: KeyType;
        /**
         * This property exists only on asymmetric keys. Depending on the type of the key,
         * this object contains information about the key. None of the information obtained
         * through this property can be used to uniquely identify a key or to compromise
         * the security of the key.
         *
         * For RSA-PSS keys, if the key material contains a `RSASSA-PSS-params` sequence,
         * the `hashAlgorithm`, `mgf1HashAlgorithm`, and `saltLength` properties will be
         * set.
         *
         * Other key details might be exposed via this API using additional attributes.
         * @since v15.7.0
         */
        asymmetricKeyDetails?: AsymmetricKeyDetails;
        /**
         * For symmetric keys, the following encoding options can be used:
         *
         * For public keys, the following encoding options can be used:
         *
         * For private keys, the following encoding options can be used:
         *
         * The result type depends on the selected encoding format, when PEM the
         * result is a string, when DER it will be a buffer containing the data
         * encoded as DER, when [JWK](https://tools.ietf.org/html/rfc7517) it will be an object.
         *
         * When [JWK](https://tools.ietf.org/html/rfc7517) encoding format was selected, all other encoding options are
         * ignored.
         *
         * PKCS#1, SEC1, and PKCS#8 type keys can be encrypted by using a combination of
         * the `cipher` and `format` options. The PKCS#8 `type` can be used with any`format` to encrypt any key algorithm (RSA, EC, or DH) by specifying a`cipher`. PKCS#1 and SEC1 can only be
         * encrypted by specifying a `cipher`when the PEM `format` is used. For maximum compatibility, use PKCS#8 for
         * encrypted private keys. Since PKCS#8 defines its own
         * encryption mechanism, PEM-level encryption is not supported when encrypting
         * a PKCS#8 key. See [RFC 5208](https://www.rfc-editor.org/rfc/rfc5208.txt) for PKCS#8 encryption and [RFC 1421](https://www.rfc-editor.org/rfc/rfc1421.txt) for
         * PKCS#1 and SEC1 encryption.
         * @since v11.6.0
         */
        export(options: KeyExportOptions<"pem">): string | Buffer;
        export(options?: KeyExportOptions<"der">): Buffer;
        export(options?: JwkKeyExportOptions): JsonWebKey;
        /**
         * Returns `true` or `false` depending on whether the keys have exactly the same
         * type, value, and parameters. This method is not [constant time](https://en.wikipedia.org/wiki/Timing_attack).
         * @since v17.7.0, v16.15.0
         * @param otherKeyObject A `KeyObject` with which to compare `keyObject`.
         */
        equals(otherKeyObject: KeyObject): boolean;
        /**
         * For secret keys, this property represents the size of the key in bytes. This
         * property is `undefined` for asymmetric keys.
         * @since v11.6.0
         */
        symmetricKeySize?: number;
        /**
         * Converts a `KeyObject` instance to a `CryptoKey`.
         * @since 22.10.0
         */
        toCryptoKey(
            algorithm:
                | webcrypto.AlgorithmIdentifier
                | webcrypto.RsaHashedImportParams
                | webcrypto.EcKeyImportParams
                | webcrypto.HmacImportParams,
            extractable: boolean,
            keyUsages: readonly webcrypto.KeyUsage[],
        ): webcrypto.CryptoKey;
        /**
         * Depending on the type of this `KeyObject`, this property is either`'secret'` for secret (symmetric) keys, `'public'` for public (asymmetric) keys
         * or `'private'` for private (asymmetric) keys.
         * @since v11.6.0
         */
        type: KeyObjectType;
    }
    type CipherCCMTypes = "aes-128-ccm" | "aes-192-ccm" | "aes-256-ccm";
    type CipherGCMTypes = "aes-128-gcm" | "aes-192-gcm" | "aes-256-gcm";
    type CipherOCBTypes = "aes-128-ocb" | "aes-192-ocb" | "aes-256-ocb";
    type CipherChaCha20Poly1305Types = "chacha20-poly1305";
    type BinaryLike = string | NodeJS.ArrayBufferView;
    type CipherKey = BinaryLike | KeyObject;
    interface CipherCCMOptions extends stream.TransformOptions {
        authTagLength: number;
    }
    interface CipherGCMOptions extends stream.TransformOptions {
        authTagLength?: number | undefined;
    }
    interface CipherOCBOptions extends stream.TransformOptions {
        authTagLength: number;
    }
    interface CipherChaCha20Poly1305Options extends stream.TransformOptions {
        /** @default 16 */
        authTagLength?: number | undefined;
    }
    /**
     * Creates and returns a `Cipher` object, with the given `algorithm`, `key` and
     * initialization vector (`iv`).
     *
     * The `options` argument controls stream behavior and is optional except when a
     * cipher in CCM or OCB mode (e.g. `'aes-128-ccm'`) is used. In that case, the`authTagLength` option is required and specifies the length of the
     * authentication tag in bytes, see `CCM mode`. In GCM mode, the `authTagLength`option is not required but can be used to set the length of the authentication
     * tag that will be returned by `getAuthTag()` and defaults to 16 bytes.
     * For `chacha20-poly1305`, the `authTagLength` option defaults to 16 bytes.
     *
     * The `algorithm` is dependent on OpenSSL, examples are `'aes192'`, etc. On
     * recent OpenSSL releases, `openssl list -cipher-algorithms` will
     * display the available cipher algorithms.
     *
     * The `key` is the raw key used by the `algorithm` and `iv` is an [initialization vector](https://en.wikipedia.org/wiki/Initialization_vector). Both arguments must be `'utf8'` encoded
     * strings,`Buffers`, `TypedArray`, or `DataView`s. The `key` may optionally be
     * a `KeyObject` of type `secret`. If the cipher does not need
     * an initialization vector, `iv` may be `null`.
     *
     * When passing strings for `key` or `iv`, please consider `caveats when using strings as inputs to cryptographic APIs`.
     *
     * Initialization vectors should be unpredictable and unique; ideally, they will be
     * cryptographically random. They do not have to be secret: IVs are typically just
     * added to ciphertext messages unencrypted. It may sound contradictory that
     * something has to be unpredictable and unique, but does not have to be secret;
     * remember that an attacker must not be able to predict ahead of time what a
     * given IV will be.
     * @since v0.1.94
     * @param options `stream.transform` options
     */
    function createCipheriv(
        algorithm: CipherCCMTypes,
        key: CipherKey,
        iv: BinaryLike,
        options: CipherCCMOptions,
    ): CipherCCM;
    function createCipheriv(
        algorithm: CipherOCBTypes,
        key: CipherKey,
        iv: BinaryLike,
        options: CipherOCBOptions,
    ): CipherOCB;
    function createCipheriv(
        algorithm: CipherGCMTypes,
        key: CipherKey,
        iv: BinaryLike,
        options?: CipherGCMOptions,
    ): CipherGCM;
    function createCipheriv(
        algorithm: CipherChaCha20Poly1305Types,
        key: CipherKey,
        iv: BinaryLike,
        options?: CipherChaCha20Poly1305Options,
    ): CipherChaCha20Poly1305;
    function createCipheriv(
        algorithm: string,
        key: CipherKey,
        iv: BinaryLike | null,
        options?: stream.TransformOptions,
    ): Cipher;
    /**
     * Instances of the `Cipher` class are used to encrypt data. The class can be
     * used in one of two ways:
     *
     * * As a `stream` that is both readable and writable, where plain unencrypted
     * data is written to produce encrypted data on the readable side, or
     * * Using the `cipher.update()` and `cipher.final()` methods to produce
     * the encrypted data.
     *
     * The {@link createCipheriv} method is
     * used to create `Cipher` instances. `Cipher` objects are not to be created
     * directly using the `new` keyword.
     *
     * Example: Using `Cipher` objects as streams:
     *
     * ```js
     * const {
     *   scrypt,
     *   randomFill,
     *   createCipheriv,
     * } = await import('node:crypto');
     *
     * const algorithm = 'aes-192-cbc';
     * const password = 'Password used to generate key';
     *
     * // First, we'll generate the key. The key length is dependent on the algorithm.
     * // In this case for aes192, it is 24 bytes (192 bits).
     * scrypt(password, 'salt', 24, (err, key) => {
     *   if (err) throw err;
     *   // Then, we'll generate a random initialization vector
     *   randomFill(new Uint8Array(16), (err, iv) => {
     *     if (err) throw err;
     *
     *     // Once we have the key and iv, we can create and use the cipher...
     *     const cipher = createCipheriv(algorithm, key, iv);
     *
     *     let encrypted = '';
     *     cipher.setEncoding('hex');
     *
     *     cipher.on('data', (chunk) => encrypted += chunk);
     *     cipher.on('end', () => console.log(encrypted));
     *
     *     cipher.write('some clear text data');
     *     cipher.end();
     *   });
     * });
     * ```
     *
     * Example: Using `Cipher` and piped streams:
     *
     * ```js
     * import {
     *   createReadStream,
     *   createWriteStream,
     * } from 'node:fs';
     *
     * import {
     *   pipeline,
     * } from 'node:stream';
     *
     * const {
     *   scrypt,
     *   randomFill,
     *   createCipheriv,
     * } = await import('node:crypto');
     *
     * const algorithm = 'aes-192-cbc';
     * const password = 'Password used to generate key';
     *
     * // First, we'll generate the key. The key length is dependent on the algorithm.
     * // In this case for aes192, it is 24 bytes (192 bits).
     * scrypt(password, 'salt', 24, (err, key) => {
     *   if (err) throw err;
     *   // Then, we'll generate a random initialization vector
     *   randomFill(new Uint8Array(16), (err, iv) => {
     *     if (err) throw err;
     *
     *     const cipher = createCipheriv(algorithm, key, iv);
     *
     *     const input = createReadStream('test.js');
     *     const output = createWriteStream('test.enc');
     *
     *     pipeline(input, cipher, output, (err) => {
     *       if (err) throw err;
     *     });
     *   });
     * });
     * ```
     *
     * Example: Using the `cipher.update()` and `cipher.final()` methods:
     *
     * ```js
     * const {
     *   scrypt,
     *   randomFill,
     *   createCipheriv,
     * } = await import('node:crypto');
     *
     * const algorithm = 'aes-192-cbc';
     * const password = 'Password used to generate key';
     *
     * // First, we'll generate the key. The key length is dependent on the algorithm.
     * // In this case for aes192, it is 24 bytes (192 bits).
     * scrypt(password, 'salt', 24, (err, key) => {
     *   if (err) throw err;
     *   // Then, we'll generate a random initialization vector
     *   randomFill(new Uint8Array(16), (err, iv) => {
     *     if (err) throw err;
     *
     *     const cipher = createCipheriv(algorithm, key, iv);
     *
     *     let encrypted = cipher.update('some clear text data', 'utf8', 'hex');
     *     encrypted += cipher.final('hex');
     *     console.log(encrypted);
     *   });
     * });
     * ```
     * @since v0.1.94
     */
    class Cipher extends stream.Transform {
        private constructor();
        /**
         * Updates the cipher with `data`. If the `inputEncoding` argument is given,
         * the `data`argument is a string using the specified encoding. If the `inputEncoding`argument is not given, `data` must be a `Buffer`, `TypedArray`, or `DataView`. If `data` is a `Buffer`,
         * `TypedArray`, or `DataView`, then `inputEncoding` is ignored.
         *
         * The `outputEncoding` specifies the output format of the enciphered
         * data. If the `outputEncoding`is specified, a string using the specified encoding is returned. If no`outputEncoding` is provided, a `Buffer` is returned.
         *
         * The `cipher.update()` method can be called multiple times with new data until `cipher.final()` is called. Calling `cipher.update()` after `cipher.final()` will result in an error being
         * thrown.
         * @since v0.1.94
         * @param inputEncoding The `encoding` of the data.
         * @param outputEncoding The `encoding` of the return value.
         */
        update(data: BinaryLike): Buffer;
        update(data: string, inputEncoding: Encoding): Buffer;
        update(data: NodeJS.ArrayBufferView, inputEncoding: undefined, outputEncoding: Encoding): string;
        update(data: string, inputEncoding: Encoding | undefined, outputEncoding: Encoding): string;
        /**
         * Once the `cipher.final()` method has been called, the `Cipher` object can no
         * longer be used to encrypt data. Attempts to call `cipher.final()` more than
         * once will result in an error being thrown.
         * @since v0.1.94
         * @param outputEncoding The `encoding` of the return value.
         * @return Any remaining enciphered contents. If `outputEncoding` is specified, a string is returned. If an `outputEncoding` is not provided, a {@link Buffer} is returned.
         */
        final(): Buffer;
        final(outputEncoding: BufferEncoding): string;
        /**
         * When using block encryption algorithms, the `Cipher` class will automatically
         * add padding to the input data to the appropriate block size. To disable the
         * default padding call `cipher.setAutoPadding(false)`.
         *
         * When `autoPadding` is `false`, the length of the entire input data must be a
         * multiple of the cipher's block size or `cipher.final()` will throw an error.
         * Disabling automatic padding is useful for non-standard padding, for instance
         * using `0x0` instead of PKCS padding.
         *
         * The `cipher.setAutoPadding()` method must be called before `cipher.final()`.
         * @since v0.7.1
         * @param [autoPadding=true]
         * @return for method chaining.
         */
        setAutoPadding(autoPadding?: boolean): this;
    }
    interface CipherCCM extends Cipher {
        setAAD(
            buffer: NodeJS.ArrayBufferView,
            options: {
                plaintextLength: number;
            },
        ): this;
        getAuthTag(): Buffer;
    }
    interface CipherGCM extends Cipher {
        setAAD(
            buffer: NodeJS.ArrayBufferView,
            options?: {
                plaintextLength: number;
            },
        ): this;
        getAuthTag(): Buffer;
    }
    interface CipherOCB extends Cipher {
        setAAD(
            buffer: NodeJS.ArrayBufferView,
            options?: {
                plaintextLength: number;
            },
        ): this;
        getAuthTag(): Buffer;
    }
    interface CipherChaCha20Poly1305 extends Cipher {
        setAAD(
            buffer: NodeJS.ArrayBufferView,
            options: {
                plaintextLength: number;
            },
        ): this;
        getAuthTag(): Buffer;
    }
    /**
     * Creates and returns a `Decipher` object that uses the given `algorithm`, `key` and initialization vector (`iv`).
     *
     * The `options` argument controls stream behavior and is optional except when a
     * cipher in CCM or OCB mode (e.g. `'aes-128-ccm'`) is used. In that case, the `authTagLength` option is required and specifies the length of the
     * authentication tag in bytes, see `CCM mode`. In GCM mode, the `authTagLength` option is not required but can be used to restrict accepted authentication tags
     * to those with the specified length.
     * For `chacha20-poly1305`, the `authTagLength` option defaults to 16 bytes.
     *
     * The `algorithm` is dependent on OpenSSL, examples are `'aes192'`, etc. On
     * recent OpenSSL releases, `openssl list -cipher-algorithms` will
     * display the available cipher algorithms.
     *
     * The `key` is the raw key used by the `algorithm` and `iv` is an [initialization vector](https://en.wikipedia.org/wiki/Initialization_vector). Both arguments must be `'utf8'` encoded
     * strings,`Buffers`, `TypedArray`, or `DataView`s. The `key` may optionally be
     * a `KeyObject` of type `secret`. If the cipher does not need
     * an initialization vector, `iv` may be `null`.
     *
     * When passing strings for `key` or `iv`, please consider `caveats when using strings as inputs to cryptographic APIs`.
     *
     * Initialization vectors should be unpredictable and unique; ideally, they will be
     * cryptographically random. They do not have to be secret: IVs are typically just
     * added to ciphertext messages unencrypted. It may sound contradictory that
     * something has to be unpredictable and unique, but does not have to be secret;
     * remember that an attacker must not be able to predict ahead of time what a given
     * IV will be.
     * @since v0.1.94
     * @param options `stream.transform` options
     */
    function createDecipheriv(
        algorithm: CipherCCMTypes,
        key: CipherKey,
        iv: BinaryLike,
        options: CipherCCMOptions,
    ): DecipherCCM;
    function createDecipheriv(
        algorithm: CipherOCBTypes,
        key: CipherKey,
        iv: BinaryLike,
        options: CipherOCBOptions,
    ): DecipherOCB;
    function createDecipheriv(
        algorithm: CipherGCMTypes,
        key: CipherKey,
        iv: BinaryLike,
        options?: CipherGCMOptions,
    ): DecipherGCM;
    function createDecipheriv(
        algorithm: CipherChaCha20Poly1305Types,
        key: CipherKey,
        iv: BinaryLike,
        options?: CipherChaCha20Poly1305Options,
    ): DecipherChaCha20Poly1305;
    function createDecipheriv(
        algorithm: string,
        key: CipherKey,
        iv: BinaryLike | null,
        options?: stream.TransformOptions,
    ): Decipher;
    /**
     * Instances of the `Decipher` class are used to decrypt data. The class can be
     * used in one of two ways:
     *
     * * As a `stream` that is both readable and writable, where plain encrypted
     * data is written to produce unencrypted data on the readable side, or
     * * Using the `decipher.update()` and `decipher.final()` methods to
     * produce the unencrypted data.
     *
     * The {@link createDecipheriv} method is
     * used to create `Decipher` instances. `Decipher` objects are not to be created
     * directly using the `new` keyword.
     *
     * Example: Using `Decipher` objects as streams:
     *
     * ```js
     * import { Buffer } from 'node:buffer';
     * const {
     *   scryptSync,
     *   createDecipheriv,
     * } = await import('node:crypto');
     *
     * const algorithm = 'aes-192-cbc';
     * const password = 'Password used to generate key';
     * // Key length is dependent on the algorithm. In this case for aes192, it is
     * // 24 bytes (192 bits).
     * // Use the async `crypto.scrypt()` instead.
     * const key = scryptSync(password, 'salt', 24);
     * // The IV is usually passed along with the ciphertext.
     * const iv = Buffer.alloc(16, 0); // Initialization vector.
     *
     * const decipher = createDecipheriv(algorithm, key, iv);
     *
     * let decrypted = '';
     * decipher.on('readable', () => {
     *   let chunk;
     *   while (null !== (chunk = decipher.read())) {
     *     decrypted += chunk.toString('utf8');
     *   }
     * });
     * decipher.on('end', () => {
     *   console.log(decrypted);
     *   // Prints: some clear text data
     * });
     *
     * // Encrypted with same algorithm, key and iv.
     * const encrypted =
     *   'e5f79c5915c02171eec6b212d5520d44480993d7d622a7c4c2da32f6efda0ffa';
     * decipher.write(encrypted, 'hex');
     * decipher.end();
     * ```
     *
     * Example: Using `Decipher` and piped streams:
     *
     * ```js
     * import {
     *   createReadStream,
     *   createWriteStream,
     * } from 'node:fs';
     * import { Buffer } from 'node:buffer';
     * const {
     *   scryptSync,
     *   createDecipheriv,
     * } = await import('node:crypto');
     *
     * const algorithm = 'aes-192-cbc';
     * const password = 'Password used to generate key';
     * // Use the async `crypto.scrypt()` instead.
     * const key = scryptSync(password, 'salt', 24);
     * // The IV is usually passed along with the ciphertext.
     * const iv = Buffer.alloc(16, 0); // Initialization vector.
     *
     * const decipher = createDecipheriv(algorithm, key, iv);
     *
     * const input = createReadStream('test.enc');
     * const output = createWriteStream('test.js');
     *
     * input.pipe(decipher).pipe(output);
     * ```
     *
     * Example: Using the `decipher.update()` and `decipher.final()` methods:
     *
     * ```js
     * import { Buffer } from 'node:buffer';
     * const {
     *   scryptSync,
     *   createDecipheriv,
     * } = await import('node:crypto');
     *
     * const algorithm = 'aes-192-cbc';
     * const password = 'Password used to generate key';
     * // Use the async `crypto.scrypt()` instead.
     * const key = scryptSync(password, 'salt', 24);
     * // The IV is usually passed along with the ciphertext.
     * const iv = Buffer.alloc(16, 0); // Initialization vector.
     *
     * const decipher = createDecipheriv(algorithm, key, iv);
     *
     * // Encrypted using same algorithm, key and iv.
     * const encrypted =
     *   'e5f79c5915c02171eec6b212d5520d44480993d7d622a7c4c2da32f6efda0ffa';
     * let decrypted = decipher.update(encrypted, 'hex', 'utf8');
     * decrypted += decipher.final('utf8');
     * console.log(decrypted);
     * // Prints: some clear text data
     * ```
     * @since v0.1.94
     */
    class Decipher extends stream.Transform {
        private constructor();
        /**
         * Updates the decipher with `data`. If the `inputEncoding` argument is given,
         * the `data` argument is a string using the specified encoding. If the `inputEncoding` argument is not given, `data` must be a `Buffer`. If `data` is a `Buffer` then `inputEncoding` is
         * ignored.
         *
         * The `outputEncoding` specifies the output format of the enciphered
         * data. If the `outputEncoding` is specified, a string using the specified encoding is returned. If no `outputEncoding` is provided, a `Buffer` is returned.
         *
         * The `decipher.update()` method can be called multiple times with new data until `decipher.final()` is called. Calling `decipher.update()` after `decipher.final()` will result in an error
         * being thrown.
         * @since v0.1.94
         * @param inputEncoding The `encoding` of the `data` string.
         * @param outputEncoding The `encoding` of the return value.
         */
        update(data: NodeJS.ArrayBufferView): Buffer;
        update(data: string, inputEncoding: Encoding): Buffer;
        update(data: NodeJS.ArrayBufferView, inputEncoding: undefined, outputEncoding: Encoding): string;
        update(data: string, inputEncoding: Encoding | undefined, outputEncoding: Encoding): string;
        /**
         * Once the `decipher.final()` method has been called, the `Decipher` object can
         * no longer be used to decrypt data. Attempts to call `decipher.final()` more
         * than once will result in an error being thrown.
         * @since v0.1.94
         * @param outputEncoding The `encoding` of the return value.
         * @return Any remaining deciphered contents. If `outputEncoding` is specified, a string is returned. If an `outputEncoding` is not provided, a {@link Buffer} is returned.
         */
        final(): Buffer;
        final(outputEncoding: BufferEncoding): string;
        /**
         * When data has been encrypted without standard block padding, calling `decipher.setAutoPadding(false)` will disable automatic padding to prevent `decipher.final()` from checking for and
         * removing padding.
         *
         * Turning auto padding off will only work if the input data's length is a
         * multiple of the ciphers block size.
         *
         * The `decipher.setAutoPadding()` method must be called before `decipher.final()`.
         * @since v0.7.1
         * @param [autoPadding=true]
         * @return for method chaining.
         */
        setAutoPadding(auto_padding?: boolean): this;
    }
    interface DecipherCCM extends Decipher {
        setAuthTag(buffer: NodeJS.ArrayBufferView): this;
        setAAD(
            buffer: NodeJS.ArrayBufferView,
            options: {
                plaintextLength: number;
            },
        ): this;
    }
    interface DecipherGCM extends Decipher {
        setAuthTag(buffer: NodeJS.ArrayBufferView): this;
        setAAD(
            buffer: NodeJS.ArrayBufferView,
            options?: {
                plaintextLength: number;
            },
        ): this;
    }
    interface DecipherOCB extends Decipher {
        setAuthTag(buffer: NodeJS.ArrayBufferView): this;
        setAAD(
            buffer: NodeJS.ArrayBufferView,
            options?: {
                plaintextLength: number;
            },
        ): this;
    }
    interface DecipherChaCha20Poly1305 extends Decipher {
        setAuthTag(buffer: NodeJS.ArrayBufferView): this;
        setAAD(
            buffer: NodeJS.ArrayBufferView,
            options: {
                plaintextLength: number;
            },
        ): this;
    }
    interface PrivateKeyInput {
        key: string | Buffer;
        format?: KeyFormat | undefined;
        type?: "pkcs1" | "pkcs8" | "sec1" | undefined;
        passphrase?: string | Buffer | undefined;
        encoding?: string | undefined;
    }
    interface PublicKeyInput {
        key: string | Buffer;
        format?: KeyFormat | undefined;
        type?: "pkcs1" | "spki" | undefined;
        encoding?: string | undefined;
    }
    /**
     * Asynchronously generates a new random secret key of the given `length`. The `type` will determine which validations will be performed on the `length`.
     *
     * ```js
     * const {
     *   generateKey,
     * } = await import('node:crypto');
     *
     * generateKey('hmac', { length: 512 }, (err, key) => {
     *   if (err) throw err;
     *   console.log(key.export().toString('hex'));  // 46e..........620
     * });
     * ```
     *
     * The size of a generated HMAC key should not exceed the block size of the
     * underlying hash function. See {@link createHmac} for more information.
     * @since v15.0.0
     * @param type The intended use of the generated secret key. Currently accepted values are `'hmac'` and `'aes'`.
     */
    function generateKey(
        type: "hmac" | "aes",
        options: {
            length: number;
        },
        callback: (err: Error | null, key: KeyObject) => void,
    ): void;
    /**
     * Synchronously generates a new random secret key of the given `length`. The `type` will determine which validations will be performed on the `length`.
     *
     * ```js
     * const {
     *   generateKeySync,
     * } = await import('node:crypto');
     *
     * const key = generateKeySync('hmac', { length: 512 });
     * console.log(key.export().toString('hex'));  // e89..........41e
     * ```
     *
     * The size of a generated HMAC key should not exceed the block size of the
     * underlying hash function. See {@link createHmac} for more information.
     * @since v15.0.0
     * @param type The intended use of the generated secret key. Currently accepted values are `'hmac'` and `'aes'`.
     */
    function generateKeySync(
        type: "hmac" | "aes",
        options: {
            length: number;
        },
    ): KeyObject;
    interface JsonWebKeyInput {
        key: JsonWebKey;
        format: "jwk";
    }
    /**
     * Creates and returns a new key object containing a private key. If `key` is a
     * string or `Buffer`, `format` is assumed to be `'pem'`; otherwise, `key` must be an object with the properties described above.
     *
     * If the private key is encrypted, a `passphrase` must be specified. The length
     * of the passphrase is limited to 1024 bytes.
     * @since v11.6.0
     */
    function createPrivateKey(key: PrivateKeyInput | string | Buffer | JsonWebKeyInput): KeyObject;
    /**
     * Creates and returns a new key object containing a public key. If `key` is a
     * string or `Buffer`, `format` is assumed to be `'pem'`; if `key` is a `KeyObject` with type `'private'`, the public key is derived from the given private key;
     * otherwise, `key` must be an object with the properties described above.
     *
     * If the format is `'pem'`, the `'key'` may also be an X.509 certificate.
     *
     * Because public keys can be derived from private keys, a private key may be
     * passed instead of a public key. In that case, this function behaves as if {@link createPrivateKey} had been called, except that the type of the
     * returned `KeyObject` will be `'public'` and that the private key cannot be
     * extracted from the returned `KeyObject`. Similarly, if a `KeyObject` with type `'private'` is given, a new `KeyObject` with type `'public'` will be returned
     * and it will be impossible to extract the private key from the returned object.
     * @since v11.6.0
     */
    function createPublicKey(key: PublicKeyInput | string | Buffer | KeyObject | JsonWebKeyInput): KeyObject;
    /**
     * Creates and returns a new key object containing a secret key for symmetric
     * encryption or `Hmac`.
     * @since v11.6.0
     * @param encoding The string encoding when `key` is a string.
     */
    function createSecretKey(key: NodeJS.ArrayBufferView): KeyObject;
    function createSecretKey(key: string, encoding: BufferEncoding): KeyObject;
    /**
     * Creates and returns a `Sign` object that uses the given `algorithm`. Use {@link getHashes} to obtain the names of the available digest algorithms.
     * Optional `options` argument controls the `stream.Writable` behavior.
     *
     * In some cases, a `Sign` instance can be created using the name of a signature
     * algorithm, such as `'RSA-SHA256'`, instead of a digest algorithm. This will use
     * the corresponding digest algorithm. This does not work for all signature
     * algorithms, such as `'ecdsa-with-SHA256'`, so it is best to always use digest
     * algorithm names.
     * @since v0.1.92
     * @param options `stream.Writable` options
     */
    function createSign(algorithm: string, options?: stream.WritableOptions): Sign;
    type DSAEncoding = "der" | "ieee-p1363";
    interface SigningOptions {
        /**
         * @see crypto.constants.RSA_PKCS1_PADDING
         */
        padding?: number | undefined;
        saltLength?: number | undefined;
        dsaEncoding?: DSAEncoding | undefined;
    }
    interface SignPrivateKeyInput extends PrivateKeyInput, SigningOptions {}
    interface SignKeyObjectInput extends SigningOptions {
        key: KeyObject;
    }
    interface SignJsonWebKeyInput extends JsonWebKeyInput, SigningOptions {}
    interface VerifyPublicKeyInput extends PublicKeyInput, SigningOptions {}
    interface VerifyKeyObjectInput extends SigningOptions {
        key: KeyObject;
    }
    interface VerifyJsonWebKeyInput extends JsonWebKeyInput, SigningOptions {}
    type KeyLike = string | Buffer | KeyObject;
    /**
     * The `Sign` class is a utility for generating signatures. It can be used in one
     * of two ways:
     *
     * * As a writable `stream`, where data to be signed is written and the `sign.sign()` method is used to generate and return the signature, or
     * * Using the `sign.update()` and `sign.sign()` methods to produce the
     * signature.
     *
     * The {@link createSign} method is used to create `Sign` instances. The
     * argument is the string name of the hash function to use. `Sign` objects are not
     * to be created directly using the `new` keyword.
     *
     * Example: Using `Sign` and `Verify` objects as streams:
     *
     * ```js
     * const {
     *   generateKeyPairSync,
     *   createSign,
     *   createVerify,
     * } = await import('node:crypto');
     *
     * const { privateKey, publicKey } = generateKeyPairSync('ec', {
     *   namedCurve: 'sect239k1',
     * });
     *
     * const sign = createSign('SHA256');
     * sign.write('some data to sign');
     * sign.end();
     * const signature = sign.sign(privateKey, 'hex');
     *
     * const verify = createVerify('SHA256');
     * verify.write('some data to sign');
     * verify.end();
     * console.log(verify.verify(publicKey, signature, 'hex'));
     * // Prints: true
     * ```
     *
     * Example: Using the `sign.update()` and `verify.update()` methods:
     *
     * ```js
     * const {
     *   generateKeyPairSync,
     *   createSign,
     *   createVerify,
     * } = await import('node:crypto');
     *
     * const { privateKey, publicKey } = generateKeyPairSync('rsa', {
     *   modulusLength: 2048,
     * });
     *
     * const sign = createSign('SHA256');
     * sign.update('some data to sign');
     * sign.end();
     * const signature = sign.sign(privateKey);
     *
     * const verify = createVerify('SHA256');
     * verify.update('some data to sign');
     * verify.end();
     * console.log(verify.verify(publicKey, signature));
     * // Prints: true
     * ```
     * @since v0.1.92
     */
    class Sign extends stream.Writable {
        private constructor();
        /**
         * Updates the `Sign` content with the given `data`, the encoding of which
         * is given in `inputEncoding`.
         * If `encoding` is not provided, and the `data` is a string, an
         * encoding of `'utf8'` is enforced. If `data` is a `Buffer`, `TypedArray`, or`DataView`, then `inputEncoding` is ignored.
         *
         * This can be called many times with new data as it is streamed.
         * @since v0.1.92
         * @param inputEncoding The `encoding` of the `data` string.
         */
        update(data: BinaryLike): this;
        update(data: string, inputEncoding: Encoding): this;
        /**
         * Calculates the signature on all the data passed through using either `sign.update()` or `sign.write()`.
         *
         * If `privateKey` is not a `KeyObject`, this function behaves as if `privateKey` had been passed to {@link createPrivateKey}. If it is an
         * object, the following additional properties can be passed:
         *
         * If `outputEncoding` is provided a string is returned; otherwise a `Buffer` is returned.
         *
         * The `Sign` object can not be again used after `sign.sign()` method has been
         * called. Multiple calls to `sign.sign()` will result in an error being thrown.
         * @since v0.1.92
         */
        sign(privateKey: KeyLike | SignKeyObjectInput | SignPrivateKeyInput | SignJsonWebKeyInput): Buffer;
        sign(
            privateKey: KeyLike | SignKeyObjectInput | SignPrivateKeyInput | SignJsonWebKeyInput,
            outputFormat: BinaryToTextEncoding,
        ): string;
    }
    /**
     * Creates and returns a `Verify` object that uses the given algorithm.
     * Use {@link getHashes} to obtain an array of names of the available
     * signing algorithms. Optional `options` argument controls the `stream.Writable` behavior.
     *
     * In some cases, a `Verify` instance can be created using the name of a signature
     * algorithm, such as `'RSA-SHA256'`, instead of a digest algorithm. This will use
     * the corresponding digest algorithm. This does not work for all signature
     * algorithms, such as `'ecdsa-with-SHA256'`, so it is best to always use digest
     * algorithm names.
     * @since v0.1.92
     * @param options `stream.Writable` options
     */
    function createVerify(algorithm: string, options?: stream.WritableOptions): Verify;
    /**
     * The `Verify` class is a utility for verifying signatures. It can be used in one
     * of two ways:
     *
     * * As a writable `stream` where written data is used to validate against the
     * supplied signature, or
     * * Using the `verify.update()` and `verify.verify()` methods to verify
     * the signature.
     *
     * The {@link createVerify} method is used to create `Verify` instances. `Verify` objects are not to be created directly using the `new` keyword.
     *
     * See `Sign` for examples.
     * @since v0.1.92
     */
    class Verify extends stream.Writable {
        private constructor();
        /**
         * Updates the `Verify` content with the given `data`, the encoding of which
         * is given in `inputEncoding`.
         * If `inputEncoding` is not provided, and the `data` is a string, an
         * encoding of `'utf8'` is enforced. If `data` is a `Buffer`, `TypedArray`, or `DataView`, then `inputEncoding` is ignored.
         *
         * This can be called many times with new data as it is streamed.
         * @since v0.1.92
         * @param inputEncoding The `encoding` of the `data` string.
         */
        update(data: BinaryLike): Verify;
        update(data: string, inputEncoding: Encoding): Verify;
        /**
         * Verifies the provided data using the given `object` and `signature`.
         *
         * If `object` is not a `KeyObject`, this function behaves as if `object` had been passed to {@link createPublicKey}. If it is an
         * object, the following additional properties can be passed:
         *
         * The `signature` argument is the previously calculated signature for the data, in
         * the `signatureEncoding`.
         * If a `signatureEncoding` is specified, the `signature` is expected to be a
         * string; otherwise `signature` is expected to be a `Buffer`, `TypedArray`, or `DataView`.
         *
         * The `verify` object can not be used again after `verify.verify()` has been
         * called. Multiple calls to `verify.verify()` will result in an error being
         * thrown.
         *
         * Because public keys can be derived from private keys, a private key may
         * be passed instead of a public key.
         * @since v0.1.92
         */
        verify(
            object: KeyLike | VerifyKeyObjectInput | VerifyPublicKeyInput | VerifyJsonWebKeyInput,
            signature: NodeJS.ArrayBufferView,
        ): boolean;
        verify(
            object: KeyLike | VerifyKeyObjectInput | VerifyPublicKeyInput | VerifyJsonWebKeyInput,
            signature: string,
            signature_format?: BinaryToTextEncoding,
        ): boolean;
    }
    /**
     * Creates a `DiffieHellman` key exchange object using the supplied `prime` and an
     * optional specific `generator`.
     *
     * The `generator` argument can be a number, string, or `Buffer`. If `generator` is not specified, the value `2` is used.
     *
     * If `primeEncoding` is specified, `prime` is expected to be a string; otherwise
     * a `Buffer`, `TypedArray`, or `DataView` is expected.
     *
     * If `generatorEncoding` is specified, `generator` is expected to be a string;
     * otherwise a number, `Buffer`, `TypedArray`, or `DataView` is expected.
     * @since v0.11.12
     * @param primeEncoding The `encoding` of the `prime` string.
     * @param [generator=2]
     * @param generatorEncoding The `encoding` of the `generator` string.
     */
    function createDiffieHellman(primeLength: number, generator?: number): DiffieHellman;
    function createDiffieHellman(
        prime: ArrayBuffer | NodeJS.ArrayBufferView,
        generator?: number | ArrayBuffer | NodeJS.ArrayBufferView,
    ): DiffieHellman;
    function createDiffieHellman(
        prime: ArrayBuffer | NodeJS.ArrayBufferView,
        generator: string,
        generatorEncoding: BinaryToTextEncoding,
    ): DiffieHellman;
    function createDiffieHellman(
        prime: string,
        primeEncoding: BinaryToTextEncoding,
        generator?: number | ArrayBuffer | NodeJS.ArrayBufferView,
    ): DiffieHellman;
    function createDiffieHellman(
        prime: string,
        primeEncoding: BinaryToTextEncoding,
        generator: string,
        generatorEncoding: BinaryToTextEncoding,
    ): DiffieHellman;
    /**
     * The `DiffieHellman` class is a utility for creating Diffie-Hellman key
     * exchanges.
     *
     * Instances of the `DiffieHellman` class can be created using the {@link createDiffieHellman} function.
     *
     * ```js
     * import assert from 'node:assert';
     *
     * const {
     *   createDiffieHellman,
     * } = await import('node:crypto');
     *
     * // Generate Alice's keys...
     * const alice = createDiffieHellman(2048);
     * const aliceKey = alice.generateKeys();
     *
     * // Generate Bob's keys...
     * const bob = createDiffieHellman(alice.getPrime(), alice.getGenerator());
     * const bobKey = bob.generateKeys();
     *
     * // Exchange and generate the secret...
     * const aliceSecret = alice.computeSecret(bobKey);
     * const bobSecret = bob.computeSecret(aliceKey);
     *
     * // OK
     * assert.strictEqual(aliceSecret.toString('hex'), bobSecret.toString('hex'));
     * ```
     * @since v0.5.0
     */
    class DiffieHellman {
        private constructor();
        /**
         * Generates private and public Diffie-Hellman key values unless they have been
         * generated or computed already, and returns
         * the public key in the specified `encoding`. This key should be
         * transferred to the other party.
         * If `encoding` is provided a string is returned; otherwise a `Buffer` is returned.
         *
         * This function is a thin wrapper around [`DH_generate_key()`](https://www.openssl.org/docs/man3.0/man3/DH_generate_key.html). In particular,
         * once a private key has been generated or set, calling this function only updates
         * the public key but does not generate a new private key.
         * @since v0.5.0
         * @param encoding The `encoding` of the return value.
         */
        generateKeys(): Buffer;
        generateKeys(encoding: BinaryToTextEncoding): string;
        /**
         * Computes the shared secret using `otherPublicKey` as the other
         * party's public key and returns the computed shared secret. The supplied
         * key is interpreted using the specified `inputEncoding`, and secret is
         * encoded using specified `outputEncoding`.
         * If the `inputEncoding` is not
         * provided, `otherPublicKey` is expected to be a `Buffer`, `TypedArray`, or `DataView`.
         *
         * If `outputEncoding` is given a string is returned; otherwise, a `Buffer` is returned.
         * @since v0.5.0
         * @param inputEncoding The `encoding` of an `otherPublicKey` string.
         * @param outputEncoding The `encoding` of the return value.
         */
        computeSecret(otherPublicKey: NodeJS.ArrayBufferView, inputEncoding?: null, outputEncoding?: null): Buffer;
        computeSecret(otherPublicKey: string, inputEncoding: BinaryToTextEncoding, outputEncoding?: null): Buffer;
        computeSecret(
            otherPublicKey: NodeJS.ArrayBufferView,
            inputEncoding: null,
            outputEncoding: BinaryToTextEncoding,
        ): string;
        computeSecret(
            otherPublicKey: string,
            inputEncoding: BinaryToTextEncoding,
            outputEncoding: BinaryToTextEncoding,
        ): string;
        /**
         * Returns the Diffie-Hellman prime in the specified `encoding`.
         * If `encoding` is provided a string is
         * returned; otherwise a `Buffer` is returned.
         * @since v0.5.0
         * @param encoding The `encoding` of the return value.
         */
        getPrime(): Buffer;
        getPrime(encoding: BinaryToTextEncoding): string;
        /**
         * Returns the Diffie-Hellman generator in the specified `encoding`.
         * If `encoding` is provided a string is
         * returned; otherwise a `Buffer` is returned.
         * @since v0.5.0
         * @param encoding The `encoding` of the return value.
         */
        getGenerator(): Buffer;
        getGenerator(encoding: BinaryToTextEncoding): string;
        /**
         * Returns the Diffie-Hellman public key in the specified `encoding`.
         * If `encoding` is provided a
         * string is returned; otherwise a `Buffer` is returned.
         * @since v0.5.0
         * @param encoding The `encoding` of the return value.
         */
        getPublicKey(): Buffer;
        getPublicKey(encoding: BinaryToTextEncoding): string;
        /**
         * Returns the Diffie-Hellman private key in the specified `encoding`.
         * If `encoding` is provided a
         * string is returned; otherwise a `Buffer` is returned.
         * @since v0.5.0
         * @param encoding The `encoding` of the return value.
         */
        getPrivateKey(): Buffer;
        getPrivateKey(encoding: BinaryToTextEncoding): string;
        /**
         * Sets the Diffie-Hellman public key. If the `encoding` argument is provided, `publicKey` is expected
         * to be a string. If no `encoding` is provided, `publicKey` is expected
         * to be a `Buffer`, `TypedArray`, or `DataView`.
         * @since v0.5.0
         * @param encoding The `encoding` of the `publicKey` string.
         */
        setPublicKey(publicKey: NodeJS.ArrayBufferView): void;
        setPublicKey(publicKey: string, encoding: BufferEncoding): void;
        /**
         * Sets the Diffie-Hellman private key. If the `encoding` argument is provided,`privateKey` is expected
         * to be a string. If no `encoding` is provided, `privateKey` is expected
         * to be a `Buffer`, `TypedArray`, or `DataView`.
         *
         * This function does not automatically compute the associated public key. Either `diffieHellman.setPublicKey()` or `diffieHellman.generateKeys()` can be
         * used to manually provide the public key or to automatically derive it.
         * @since v0.5.0
         * @param encoding The `encoding` of the `privateKey` string.
         */
        setPrivateKey(privateKey: NodeJS.ArrayBufferView): void;
        setPrivateKey(privateKey: string, encoding: BufferEncoding): void;
        /**
         * A bit field containing any warnings and/or errors resulting from a check
         * performed during initialization of the `DiffieHellman` object.
         *
         * The following values are valid for this property (as defined in `node:constants` module):
         *
         * * `DH_CHECK_P_NOT_SAFE_PRIME`
         * * `DH_CHECK_P_NOT_PRIME`
         * * `DH_UNABLE_TO_CHECK_GENERATOR`
         * * `DH_NOT_SUITABLE_GENERATOR`
         * @since v0.11.12
         */
        verifyError: number;
    }
    /**
     * The `DiffieHellmanGroup` class takes a well-known modp group as its argument.
     * It works the same as `DiffieHellman`, except that it does not allow changing its keys after creation.
     * In other words, it does not implement `setPublicKey()` or `setPrivateKey()` methods.
     *
     * ```js
     * const { createDiffieHellmanGroup } = await import('node:crypto');
     * const dh = createDiffieHellmanGroup('modp1');
     * ```
     * The name (e.g. `'modp1'`) is taken from [RFC 2412](https://www.rfc-editor.org/rfc/rfc2412.txt) (modp1 and 2) and [RFC 3526](https://www.rfc-editor.org/rfc/rfc3526.txt):
     * ```bash
     * $ perl -ne 'print "$1\n" if /"(modp\d+)"/' src/node_crypto_groups.h
     * modp1  #  768 bits
     * modp2  # 1024 bits
     * modp5  # 1536 bits
     * modp14 # 2048 bits
     * modp15 # etc.
     * modp16
     * modp17
     * modp18
     * ```
     * @since v0.7.5
     */
    const DiffieHellmanGroup: DiffieHellmanGroupConstructor;
    interface DiffieHellmanGroupConstructor {
        new(name: string): DiffieHellmanGroup;
        (name: string): DiffieHellmanGroup;
        readonly prototype: DiffieHellmanGroup;
    }
    type DiffieHellmanGroup = Omit<DiffieHellman, "setPublicKey" | "setPrivateKey">;
    /**
     * Creates a predefined `DiffieHellmanGroup` key exchange object. The
     * supported groups are listed in the documentation for `DiffieHellmanGroup`.
     *
     * The returned object mimics the interface of objects created by {@link createDiffieHellman}, but will not allow changing
     * the keys (with `diffieHellman.setPublicKey()`, for example). The
     * advantage of using this method is that the parties do not have to
     * generate nor exchange a group modulus beforehand, saving both processor
     * and communication time.
     *
     * Example (obtaining a shared secret):
     *
     * ```js
     * const {
     *   getDiffieHellman,
     * } = await import('node:crypto');
     * const alice = getDiffieHellman('modp14');
     * const bob = getDiffieHellman('modp14');
     *
     * alice.generateKeys();
     * bob.generateKeys();
     *
     * const aliceSecret = alice.computeSecret(bob.getPublicKey(), null, 'hex');
     * const bobSecret = bob.computeSecret(alice.getPublicKey(), null, 'hex');
     *
     * // aliceSecret and bobSecret should be the same
     * console.log(aliceSecret === bobSecret);
     * ```
     * @since v0.7.5
     */
    function getDiffieHellman(groupName: string): DiffieHellmanGroup;
    /**
     * An alias for {@link getDiffieHellman}
     * @since v0.9.3
     */
    function createDiffieHellmanGroup(name: string): DiffieHellmanGroup;
    /**
     * Provides an asynchronous Password-Based Key Derivation Function 2 (PBKDF2)
     * implementation. A selected HMAC digest algorithm specified by `digest` is
     * applied to derive a key of the requested byte length (`keylen`) from the `password`, `salt` and `iterations`.
     *
     * The supplied `callback` function is called with two arguments: `err` and `derivedKey`. If an error occurs while deriving the key, `err` will be set;
     * otherwise `err` will be `null`. By default, the successfully generated `derivedKey` will be passed to the callback as a `Buffer`. An error will be
     * thrown if any of the input arguments specify invalid values or types.
     *
     * The `iterations` argument must be a number set as high as possible. The
     * higher the number of iterations, the more secure the derived key will be,
     * but will take a longer amount of time to complete.
     *
     * The `salt` should be as unique as possible. It is recommended that a salt is
     * random and at least 16 bytes long. See [NIST SP 800-132](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf) for details.
     *
     * When passing strings for `password` or `salt`, please consider `caveats when using strings as inputs to cryptographic APIs`.
     *
     * ```js
     * const {
     *   pbkdf2,
     * } = await import('node:crypto');
     *
     * pbkdf2('secret', 'salt', 100000, 64, 'sha512', (err, derivedKey) => {
     *   if (err) throw err;
     *   console.log(derivedKey.toString('hex'));  // '3745e48...08d59ae'
     * });
     * ```
     *
     * An array of supported digest functions can be retrieved using {@link getHashes}.
     *
     * This API uses libuv's threadpool, which can have surprising and
     * negative performance implications for some applications; see the `UV_THREADPOOL_SIZE` documentation for more information.
     * @since v0.5.5
     */
    function pbkdf2(
        password: BinaryLike,
        salt: BinaryLike,
        iterations: number,
        keylen: number,
        digest: string,
        callback: (err: Error | null, derivedKey: Buffer) => void,
    ): void;
    /**
     * Provides a synchronous Password-Based Key Derivation Function 2 (PBKDF2)
     * implementation. A selected HMAC digest algorithm specified by `digest` is
     * applied to derive a key of the requested byte length (`keylen`) from the `password`, `salt` and `iterations`.
     *
     * If an error occurs an `Error` will be thrown, otherwise the derived key will be
     * returned as a `Buffer`.
     *
     * The `iterations` argument must be a number set as high as possible. The
     * higher the number of iterations, the more secure the derived key will be,
     * but will take a longer amount of time to complete.
     *
     * The `salt` should be as unique as possible. It is recommended that a salt is
     * random and at least 16 bytes long. See [NIST SP 800-132](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf) for details.
     *
     * When passing strings for `password` or `salt`, please consider `caveats when using strings as inputs to cryptographic APIs`.
     *
     * ```js
     * const {
     *   pbkdf2Sync,
     * } = await import('node:crypto');
     *
     * const key = pbkdf2Sync('secret', 'salt', 100000, 64, 'sha512');
     * console.log(key.toString('hex'));  // '3745e48...08d59ae'
     * ```
     *
     * An array of supported digest functions can be retrieved using {@link getHashes}.
     * @since v0.9.3
     */
    function pbkdf2Sync(
        password: BinaryLike,
        salt: BinaryLike,
        iterations: number,
        keylen: number,
        digest: string,
    ): Buffer;
    /**
     * Generates cryptographically strong pseudorandom data. The `size` argument
     * is a number indicating the number of bytes to generate.
     *
     * If a `callback` function is provided, the bytes are generated asynchronously
     * and the `callback` function is invoked with two arguments: `err` and `buf`.
     * If an error occurs, `err` will be an `Error` object; otherwise it is `null`. The `buf` argument is a `Buffer` containing the generated bytes.
     *
     * ```js
     * // Asynchronous
     * const {
     *   randomBytes,
     * } = await import('node:crypto');
     *
     * randomBytes(256, (err, buf) => {
     *   if (err) throw err;
     *   console.log(`${buf.length} bytes of random data: ${buf.toString('hex')}`);
     * });
     * ```
     *
     * If the `callback` function is not provided, the random bytes are generated
     * synchronously and returned as a `Buffer`. An error will be thrown if
     * there is a problem generating the bytes.
     *
     * ```js
     * // Synchronous
     * const {
     *   randomBytes,
     * } = await import('node:crypto');
     *
     * const buf = randomBytes(256);
     * console.log(
     *   `${buf.length} bytes of random data: ${buf.toString('hex')}`);
     * ```
     *
     * The `crypto.randomBytes()` method will not complete until there is
     * sufficient entropy available.
     * This should normally never take longer than a few milliseconds. The only time
     * when generating the random bytes may conceivably block for a longer period of
     * time is right after boot, when the whole system is still low on entropy.
     *
     * This API uses libuv's threadpool, which can have surprising and
     * negative performance implications for some applications; see the `UV_THREADPOOL_SIZE` documentation for more information.
     *
     * The asynchronous version of `crypto.randomBytes()` is carried out in a single
     * threadpool request. To minimize threadpool task length variation, partition
     * large `randomBytes` requests when doing so as part of fulfilling a client
     * request.
     * @since v0.5.8
     * @param size The number of bytes to generate. The `size` must not be larger than `2**31 - 1`.
     * @return if the `callback` function is not provided.
     */
    function randomBytes(size: number): Buffer;
    function randomBytes(size: number, callback: (err: Error | null, buf: Buffer) => void): void;
    function pseudoRandomBytes(size: number): Buffer;
    function pseudoRandomBytes(size: number, callback: (err: Error | null, buf: Buffer) => void): void;
    /**
     * Return a random integer `n` such that `min <= n < max`.  This
     * implementation avoids [modulo bias](https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#Modulo_bias).
     *
     * The range (`max - min`) must be less than 2**48. `min` and `max` must
     * be [safe integers](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isSafeInteger).
     *
     * If the `callback` function is not provided, the random integer is
     * generated synchronously.
     *
     * ```js
     * // Asynchronous
     * const {
     *   randomInt,
     * } = await import('node:crypto');
     *
     * randomInt(3, (err, n) => {
     *   if (err) throw err;
     *   console.log(`Random number chosen from (0, 1, 2): ${n}`);
     * });
     * ```
     *
     * ```js
     * // Synchronous
     * const {
     *   randomInt,
     * } = await import('node:crypto');
     *
     * const n = randomInt(3);
     * console.log(`Random number chosen from (0, 1, 2): ${n}`);
     * ```
     *
     * ```js
     * // With `min` argument
     * const {
     *   randomInt,
     * } = await import('node:crypto');
     *
     * const n = randomInt(1, 7);
     * console.log(`The dice rolled: ${n}`);
     * ```
     * @since v14.10.0, v12.19.0
     * @param [min=0] Start of random range (inclusive).
     * @param max End of random range (exclusive).
     * @param callback `function(err, n) {}`.
     */
    function randomInt(max: number): number;
    function randomInt(min: number, max: number): number;
    function randomInt(max: number, callback: (err: Error | null, value: number) => void): void;
    function randomInt(min: number, max: number, callback: (err: Error | null, value: number) => void): void;
    /**
     * Synchronous version of {@link randomFill}.
     *
     * ```js
     * import { Buffer } from 'node:buffer';
     * const { randomFillSync } = await import('node:crypto');
     *
     * const buf = Buffer.alloc(10);
     * console.log(randomFillSync(buf).toString('hex'));
     *
     * randomFillSync(buf, 5);
     * console.log(buf.toString('hex'));
     *
     * // The above is equivalent to the following:
     * randomFillSync(buf, 5, 5);
     * console.log(buf.toString('hex'));
     * ```
     *
     * Any `ArrayBuffer`, `TypedArray` or `DataView` instance may be passed as`buffer`.
     *
     * ```js
     * import { Buffer } from 'node:buffer';
     * const { randomFillSync } = await import('node:crypto');
     *
     * const a = new Uint32Array(10);
     * console.log(Buffer.from(randomFillSync(a).buffer,
     *                         a.byteOffset, a.byteLength).toString('hex'));
     *
     * const b = new DataView(new ArrayBuffer(10));
     * console.log(Buffer.from(randomFillSync(b).buffer,
     *                         b.byteOffset, b.byteLength).toString('hex'));
     *
     * const c = new ArrayBuffer(10);
     * console.log(Buffer.from(randomFillSync(c)).toString('hex'));
     * ```
     * @since v7.10.0, v6.13.0
     * @param buffer Must be supplied. The size of the provided `buffer` must not be larger than `2**31 - 1`.
     * @param [offset=0]
     * @param [size=buffer.length - offset]
     * @return The object passed as `buffer` argument.
     */
    function randomFillSync<T extends NodeJS.ArrayBufferView>(buffer: T, offset?: number, size?: number): T;
    /**
     * This function is similar to {@link randomBytes} but requires the first
     * argument to be a `Buffer` that will be filled. It also
     * requires that a callback is passed in.
     *
     * If the `callback` function is not provided, an error will be thrown.
     *
     * ```js
     * import { Buffer } from 'node:buffer';
     * const { randomFill } = await import('node:crypto');
     *
     * const buf = Buffer.alloc(10);
     * randomFill(buf, (err, buf) => {
     *   if (err) throw err;
     *   console.log(buf.toString('hex'));
     * });
     *
     * randomFill(buf, 5, (err, buf) => {
     *   if (err) throw err;
     *   console.log(buf.toString('hex'));
     * });
     *
     * // The above is equivalent to the following:
     * randomFill(buf, 5, 5, (err, buf) => {
     *   if (err) throw err;
     *   console.log(buf.toString('hex'));
     * });
     * ```
     *
     * Any `ArrayBuffer`, `TypedArray`, or `DataView` instance may be passed as `buffer`.
     *
     * While this includes instances of `Float32Array` and `Float64Array`, this
     * function should not be used to generate random floating-point numbers. The
     * result may contain `+Infinity`, `-Infinity`, and `NaN`, and even if the array
     * contains finite numbers only, they are not drawn from a uniform random
     * distribution and have no meaningful lower or upper bounds.
     *
     * ```js
     * import { Buffer } from 'node:buffer';
     * const { randomFill } = await import('node:crypto');
     *
     * const a = new Uint32Array(10);
     * randomFill(a, (err, buf) => {
     *   if (err) throw err;
     *   console.log(Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength)
     *     .toString('hex'));
     * });
     *
     * const b = new DataView(new ArrayBuffer(10));
     * randomFill(b, (err, buf) => {
     *   if (err) throw err;
     *   console.log(Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength)
     *     .toString('hex'));
     * });
     *
     * const c = new ArrayBuffer(10);
     * randomFill(c, (err, buf) => {
     *   if (err) throw err;
     *   console.log(Buffer.from(buf).toString('hex'));
     * });
     * ```
     *
     * This API uses libuv's threadpool, which can have surprising and
     * negative performance implications for some applications; see the `UV_THREADPOOL_SIZE` documentation for more information.
     *
     * The asynchronous version of `crypto.randomFill()` is carried out in a single
     * threadpool request. To minimize threadpool task length variation, partition
     * large `randomFill` requests when doing so as part of fulfilling a client
     * request.
     * @since v7.10.0, v6.13.0
     * @param buffer Must be supplied. The size of the provided `buffer` must not be larger than `2**31 - 1`.
     * @param [offset=0]
     * @param [size=buffer.length - offset]
     * @param callback `function(err, buf) {}`.
     */
    function randomFill<T extends NodeJS.ArrayBufferView>(
        buffer: T,
        callback: (err: Error | null, buf: T) => void,
    ): void;
    function randomFill<T extends NodeJS.ArrayBufferView>(
        buffer: T,
        offset: number,
        callback: (err: Error | null, buf: T) => void,
    ): void;
    function randomFill<T extends NodeJS.ArrayBufferView>(
        buffer: T,
        offset: number,
        size: number,
        callback: (err: Error | null, buf: T) => void,
    ): void;
    interface ScryptOptions {
        cost?: number | undefined;
        blockSize?: number | undefined;
        parallelization?: number | undefined;
        N?: number | undefined;
        r?: number | undefined;
        p?: number | undefined;
        maxmem?: number | undefined;
    }
    /**
     * Provides an asynchronous [scrypt](https://en.wikipedia.org/wiki/Scrypt) implementation. Scrypt is a password-based
     * key derivation function that is designed to be expensive computationally and
     * memory-wise in order to make brute-force attacks unrewarding.
     *
     * The `salt` should be as unique as possible. It is recommended that a salt is
     * random and at least 16 bytes long. See [NIST SP 800-132](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf) for details.
     *
     * When passing strings for `password` or `salt`, please consider `caveats when using strings as inputs to cryptographic APIs`.
     *
     * The `callback` function is called with two arguments: `err` and `derivedKey`. `err` is an exception object when key derivation fails, otherwise `err` is `null`. `derivedKey` is passed to the
     * callback as a `Buffer`.
     *
     * An exception is thrown when any of the input arguments specify invalid values
     * or types.
     *
     * ```js
     * const {
     *   scrypt,
     * } = await import('node:crypto');
     *
     * // Using the factory defaults.
     * scrypt('password', 'salt', 64, (err, derivedKey) => {
     *   if (err) throw err;
     *   console.log(derivedKey.toString('hex'));  // '3745e48...08d59ae'
     * });
     * // Using a custom N parameter. Must be a power of two.
     * scrypt('password', 'salt', 64, { N: 1024 }, (err, derivedKey) => {
     *   if (err) throw err;
     *   console.log(derivedKey.toString('hex'));  // '3745e48...aa39b34'
     * });
     * ```
     * @since v10.5.0
     */
    function scrypt(
        password: BinaryLike,
        salt: BinaryLike,
        keylen: number,
        callback: (err: Error | null, derivedKey: Buffer) => void,
    ): void;
    function scrypt(
        password: BinaryLike,
        salt: BinaryLike,
        keylen: number,
        options: ScryptOptions,
        callback: (err: Error | null, derivedKey: Buffer) => void,
    ): void;
    /**
     * Provides a synchronous [scrypt](https://en.wikipedia.org/wiki/Scrypt) implementation. Scrypt is a password-based
     * key derivation function that is designed to be expensive computationally and
     * memory-wise in order to make brute-force attacks unrewarding.
     *
     * The `salt` should be as unique as possible. It is recommended that a salt is
     * random and at least 16 bytes long. See [NIST SP 800-132](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf) for details.
     *
     * When passing strings for `password` or `salt`, please consider `caveats when using strings as inputs to cryptographic APIs`.
     *
     * An exception is thrown when key derivation fails, otherwise the derived key is
     * returned as a `Buffer`.
     *
     * An exception is thrown when any of the input arguments specify invalid values
     * or types.
     *
     * ```js
     * const {
     *   scryptSync,
     * } = await import('node:crypto');
     * // Using the factory defaults.
     *
     * const key1 = scryptSync('password', 'salt', 64);
     * console.log(key1.toString('hex'));  // '3745e48...08d59ae'
     * // Using a custom N parameter. Must be a power of two.
     * const key2 = scryptSync('password', 'salt', 64, { N: 1024 });
     * console.log(key2.toString('hex'));  // '3745e48...aa39b34'
     * ```
     * @since v10.5.0
     */
    function scryptSync(password: BinaryLike, salt: BinaryLike, keylen: number, options?: ScryptOptions): Buffer;
    interface RsaPublicKey {
        key: KeyLike;
        padding?: number | undefined;
    }
    interface RsaPrivateKey {
        key: KeyLike;
        passphrase?: string | undefined;
        /**
         * @default 'sha1'
         */
        oaepHash?: string | undefined;
        oaepLabel?: NodeJS.TypedArray | undefined;
        padding?: number | undefined;
    }
    /**
     * Encrypts the content of `buffer` with `key` and returns a new `Buffer` with encrypted content. The returned data can be decrypted using
     * the corresponding private key, for example using {@link privateDecrypt}.
     *
     * If `key` is not a `KeyObject`, this function behaves as if `key` had been passed to {@link createPublicKey}. If it is an
     * object, the `padding` property can be passed. Otherwise, this function uses `RSA_PKCS1_OAEP_PADDING`.
     *
     * Because RSA public keys can be derived from private keys, a private key may
     * be passed instead of a public key.
     * @since v0.11.14
     */
    function publicEncrypt(
        key: RsaPublicKey | RsaPrivateKey | KeyLike,
        buffer: NodeJS.ArrayBufferView | string,
    ): Buffer;
    /**
     * Decrypts `buffer` with `key`.`buffer` was previously encrypted using
     * the corresponding private key, for example using {@link privateEncrypt}.
     *
     * If `key` is not a `KeyObject`, this function behaves as if `key` had been passed to {@link createPublicKey}. If it is an
     * object, the `padding` property can be passed. Otherwise, this function uses `RSA_PKCS1_PADDING`.
     *
     * Because RSA public keys can be derived from private keys, a private key may
     * be passed instead of a public key.
     * @since v1.1.0
     */
    function publicDecrypt(
        key: RsaPublicKey | RsaPrivateKey | KeyLike,
        buffer: NodeJS.ArrayBufferView | string,
    ): Buffer;
    /**
     * Decrypts `buffer` with `privateKey`. `buffer` was previously encrypted using
     * the corresponding public key, for example using {@link publicEncrypt}.
     *
     * If `privateKey` is not a `KeyObject`, this function behaves as if `privateKey` had been passed to {@link createPrivateKey}. If it is an
     * object, the `padding` property can be passed. Otherwise, this function uses `RSA_PKCS1_OAEP_PADDING`.
     * @since v0.11.14
     */
    function privateDecrypt(privateKey: RsaPrivateKey | KeyLike, buffer: NodeJS.ArrayBufferView | string): Buffer;
    /**
     * Encrypts `buffer` with `privateKey`. The returned data can be decrypted using
     * the corresponding public key, for example using {@link publicDecrypt}.
     *
     * If `privateKey` is not a `KeyObject`, this function behaves as if `privateKey` had been passed to {@link createPrivateKey}. If it is an
     * object, the `padding` property can be passed. Otherwise, this function uses `RSA_PKCS1_PADDING`.
     * @since v1.1.0
     */
    function privateEncrypt(privateKey: RsaPrivateKey | KeyLike, buffer: NodeJS.ArrayBufferView | string): Buffer;
    /**
     * ```js
     * const {
     *   getCiphers,
     * } = await import('node:crypto');
     *
     * console.log(getCiphers()); // ['aes-128-cbc', 'aes-128-ccm', ...]
     * ```
     * @since v0.9.3
     * @return An array with the names of the supported cipher algorithms.
     */
    function getCiphers(): string[];
    /**
     * ```js
     * const {
     *   getCurves,
     * } = await import('node:crypto');
     *
     * console.log(getCurves()); // ['Oakley-EC2N-3', 'Oakley-EC2N-4', ...]
     * ```
     * @since v2.3.0
     * @return An array with the names of the supported elliptic curves.
     */
    function getCurves(): string[];
    /**
     * @since v10.0.0
     * @return `1` if and only if a FIPS compliant crypto provider is currently in use, `0` otherwise. A future semver-major release may change the return type of this API to a {boolean}.
     */
    function getFips(): 1 | 0;
    /**
     * Enables the FIPS compliant crypto provider in a FIPS-enabled Node.js build.
     * Throws an error if FIPS mode is not available.
     * @since v10.0.0
     * @param bool `true` to enable FIPS mode.
     */
    function setFips(bool: boolean): void;
    /**
     * ```js
     * const {
     *   getHashes,
     * } = await import('node:crypto');
     *
     * console.log(getHashes()); // ['DSA', 'DSA-SHA', 'DSA-SHA1', ...]
     * ```
     * @since v0.9.3
     * @return An array of the names of the supported hash algorithms, such as `'RSA-SHA256'`. Hash algorithms are also called "digest" algorithms.
     */
    function getHashes(): string[];
    /**
     * The `ECDH` class is a utility for creating Elliptic Curve Diffie-Hellman (ECDH)
     * key exchanges.
     *
     * Instances of the `ECDH` class can be created using the {@link createECDH} function.
     *
     * ```js
     * import assert from 'node:assert';
     *
     * const {
     *   createECDH,
     * } = await import('node:crypto');
     *
     * // Generate Alice's keys...
     * const alice = createECDH('secp521r1');
     * const aliceKey = alice.generateKeys();
     *
     * // Generate Bob's keys...
     * const bob = createECDH('secp521r1');
     * const bobKey = bob.generateKeys();
     *
     * // Exchange and generate the secret...
     * const aliceSecret = alice.computeSecret(bobKey);
     * const bobSecret = bob.computeSecret(aliceKey);
     *
     * assert.strictEqual(aliceSecret.toString('hex'), bobSecret.toString('hex'));
     * // OK
     * ```
     * @since v0.11.14
     */
    class ECDH {
        private constructor();
        /**
         * Converts the EC Diffie-Hellman public key specified by `key` and `curve` to the
         * format specified by `format`. The `format` argument specifies point encoding
         * and can be `'compressed'`, `'uncompressed'` or `'hybrid'`. The supplied key is
         * interpreted using the specified `inputEncoding`, and the returned key is encoded
         * using the specified `outputEncoding`.
         *
         * Use {@link getCurves} to obtain a list of available curve names.
         * On recent OpenSSL releases, `openssl ecparam -list_curves` will also display
         * the name and description of each available elliptic curve.
         *
         * If `format` is not specified the point will be returned in `'uncompressed'` format.
         *
         * If the `inputEncoding` is not provided, `key` is expected to be a `Buffer`, `TypedArray`, or `DataView`.
         *
         * Example (uncompressing a key):
         *
         * ```js
         * const {
         *   createECDH,
         *   ECDH,
         * } = await import('node:crypto');
         *
         * const ecdh = createECDH('secp256k1');
         * ecdh.generateKeys();
         *
         * const compressedKey = ecdh.getPublicKey('hex', 'compressed');
         *
         * const uncompressedKey = ECDH.convertKey(compressedKey,
         *                                         'secp256k1',
         *                                         'hex',
         *                                         'hex',
         *                                         'uncompressed');
         *
         * // The converted key and the uncompressed public key should be the same
         * console.log(uncompressedKey === ecdh.getPublicKey('hex'));
         * ```
         * @since v10.0.0
         * @param inputEncoding The `encoding` of the `key` string.
         * @param outputEncoding The `encoding` of the return value.
         * @param [format='uncompressed']
         */
        static convertKey(
            key: BinaryLike,
            curve: string,
            inputEncoding?: BinaryToTextEncoding,
            outputEncoding?: "latin1" | "hex" | "base64" | "base64url",
            format?: "uncompressed" | "compressed" | "hybrid",
        ): Buffer | string;
        /**
         * Generates private and public EC Diffie-Hellman key values, and returns
         * the public key in the specified `format` and `encoding`. This key should be
         * transferred to the other party.
         *
         * The `format` argument specifies point encoding and can be `'compressed'` or `'uncompressed'`. If `format` is not specified, the point will be returned in`'uncompressed'` format.
         *
         * If `encoding` is provided a string is returned; otherwise a `Buffer` is returned.
         * @since v0.11.14
         * @param encoding The `encoding` of the return value.
         * @param [format='uncompressed']
         */
        generateKeys(): Buffer;
        generateKeys(encoding: BinaryToTextEncoding, format?: ECDHKeyFormat): string;
        /**
         * Computes the shared secret using `otherPublicKey` as the other
         * party's public key and returns the computed shared secret. The supplied
         * key is interpreted using specified `inputEncoding`, and the returned secret
         * is encoded using the specified `outputEncoding`.
         * If the `inputEncoding` is not
         * provided, `otherPublicKey` is expected to be a `Buffer`, `TypedArray`, or `DataView`.
         *
         * If `outputEncoding` is given a string will be returned; otherwise a `Buffer` is returned.
         *
         * `ecdh.computeSecret` will throw an`ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY` error when `otherPublicKey` lies outside of the elliptic curve. Since `otherPublicKey` is
         * usually supplied from a remote user over an insecure network,
         * be sure to handle this exception accordingly.
         * @since v0.11.14
         * @param inputEncoding The `encoding` of the `otherPublicKey` string.
         * @param outputEncoding The `encoding` of the return value.
         */
        computeSecret(otherPublicKey: NodeJS.ArrayBufferView): Buffer;
        computeSecret(otherPublicKey: string, inputEncoding: BinaryToTextEncoding): Buffer;
        computeSecret(otherPublicKey: NodeJS.ArrayBufferView, outputEncoding: BinaryToTextEncoding): string;
        computeSecret(
            otherPublicKey: string,
            inputEncoding: BinaryToTextEncoding,
            outputEncoding: BinaryToTextEncoding,
        ): string;
        /**
         * If `encoding` is specified, a string is returned; otherwise a `Buffer` is
         * returned.
         * @since v0.11.14
         * @param encoding The `encoding` of the return value.
         * @return The EC Diffie-Hellman in the specified `encoding`.
         */
        getPrivateKey(): Buffer;
        getPrivateKey(encoding: BinaryToTextEncoding): string;
        /**
         * The `format` argument specifies point encoding and can be `'compressed'` or `'uncompressed'`. If `format` is not specified the point will be returned in`'uncompressed'` format.
         *
         * If `encoding` is specified, a string is returned; otherwise a `Buffer` is
         * returned.
         * @since v0.11.14
         * @param encoding The `encoding` of the return value.
         * @param [format='uncompressed']
         * @return The EC Diffie-Hellman public key in the specified `encoding` and `format`.
         */
        getPublicKey(encoding?: null, format?: ECDHKeyFormat): Buffer;
        getPublicKey(encoding: BinaryToTextEncoding, format?: ECDHKeyFormat): string;
        /**
         * Sets the EC Diffie-Hellman private key.
         * If `encoding` is provided, `privateKey` is expected
         * to be a string; otherwise `privateKey` is expected to be a `Buffer`, `TypedArray`, or `DataView`.
         *
         * If `privateKey` is not valid for the curve specified when the `ECDH` object was
         * created, an error is thrown. Upon setting the private key, the associated
         * public point (key) is also generated and set in the `ECDH` object.
         * @since v0.11.14
         * @param encoding The `encoding` of the `privateKey` string.
         */
        setPrivateKey(privateKey: NodeJS.ArrayBufferView): void;
        setPrivateKey(privateKey: string, encoding: BinaryToTextEncoding): void;
    }
    /**
     * Creates an Elliptic Curve Diffie-Hellman (`ECDH`) key exchange object using a
     * predefined curve specified by the `curveName` string. Use {@link getCurves} to obtain a list of available curve names. On recent
     * OpenSSL releases, `openssl ecparam -list_curves` will also display the name
     * and description of each available elliptic curve.
     * @since v0.11.14
     */
    function createECDH(curveName: string): ECDH;
    /**
     * This function compares the underlying bytes that represent the given `ArrayBuffer`, `TypedArray`, or `DataView` instances using a constant-time
     * algorithm.
     *
     * This function does not leak timing information that
     * would allow an attacker to guess one of the values. This is suitable for
     * comparing HMAC digests or secret values like authentication cookies or [capability urls](https://www.w3.org/TR/capability-urls/).
     *
     * `a` and `b` must both be `Buffer`s, `TypedArray`s, or `DataView`s, and they
     * must have the same byte length. An error is thrown if `a` and `b` have
     * different byte lengths.
     *
     * If at least one of `a` and `b` is a `TypedArray` with more than one byte per
     * entry, such as `Uint16Array`, the result will be computed using the platform
     * byte order.
     *
     * **When both of the inputs are `Float32Array`s or `Float64Array`s, this function might return unexpected results due to IEEE 754**
     * **encoding of floating-point numbers. In particular, neither `x === y` nor `Object.is(x, y)` implies that the byte representations of two floating-point**
     * **numbers `x` and `y` are equal.**
     *
     * Use of `crypto.timingSafeEqual` does not guarantee that the _surrounding_ code
     * is timing-safe. Care should be taken to ensure that the surrounding code does
     * not introduce timing vulnerabilities.
     * @since v6.6.0
     */
    function timingSafeEqual(a: NodeJS.ArrayBufferView, b: NodeJS.ArrayBufferView): boolean;
    type KeyType = "rsa" | "rsa-pss" | "dsa" | "ec" | "ed25519" | "ed448" | "x25519" | "x448";
    type KeyFormat = "pem" | "der" | "jwk";
    interface BasePrivateKeyEncodingOptions<T extends KeyFormat> {
        format: T;
        cipher?: string | undefined;
        passphrase?: string | undefined;
    }
    interface KeyPairKeyObjectResult {
        publicKey: KeyObject;
        privateKey: KeyObject;
    }
    interface ED25519KeyPairKeyObjectOptions {}
    interface ED448KeyPairKeyObjectOptions {}
    interface X25519KeyPairKeyObjectOptions {}
    interface X448KeyPairKeyObjectOptions {}
    interface ECKeyPairKeyObjectOptions {
        /**
         * Name of the curve to use
         */
        namedCurve: string;
        /**
         * Must be `'named'` or `'explicit'`. Default: `'named'`.
         */
        paramEncoding?: "explicit" | "named" | undefined;
    }
    interface RSAKeyPairKeyObjectOptions {
        /**
         * Key size in bits
         */
        modulusLength: number;
        /**
         * Public exponent
         * @default 0x10001
         */
        publicExponent?: number | undefined;
    }
    interface RSAPSSKeyPairKeyObjectOptions {
        /**
         * Key size in bits
         */
        modulusLength: number;
        /**
         * Public exponent
         * @default 0x10001
         */
        publicExponent?: number | undefined;
        /**
         * Name of the message digest
         */
        hashAlgorithm?: string | undefined;
        /**
         * Name of the message digest used by MGF1
         */
        mgf1HashAlgorithm?: string | undefined;
        /**
         * Minimal salt length in bytes
         */
        saltLength?: string | undefined;
    }
    interface DSAKeyPairKeyObjectOptions {
        /**
         * Key size in bits
         */
        modulusLength: number;
        /**
         * Size of q in bits
         */
        divisorLength: number;
    }
    interface RSAKeyPairOptions<PubF extends KeyFormat, PrivF extends KeyFormat> {
        /**
         * Key size in bits
         */
        modulusLength: number;
        /**
         * Public exponent
         * @default 0x10001
         */
        publicExponent?: number | undefined;
        publicKeyEncoding: {
            type: "pkcs1" | "spki";
            format: PubF;
        };
        privateKeyEncoding: BasePrivateKeyEncodingOptions<PrivF> & {
            type: "pkcs1" | "pkcs8";
        };
    }
    interface RSAPSSKeyPairOptions<PubF extends KeyFormat, PrivF extends KeyFormat> {
        /**
         * Key size in bits
         */
        modulusLength: number;
        /**
         * Public exponent
         * @default 0x10001
         */
        publicExponent?: number | undefined;
        /**
         * Name of the message digest
         */
        hashAlgorithm?: string | undefined;
        /**
         * Name of the message digest used by MGF1
         */
        mgf1HashAlgorithm?: string | undefined;
        /**
         * Minimal salt length in bytes
         */
        saltLength?: string | undefined;
        publicKeyEncoding: {
            type: "spki";
            format: PubF;
        };
        privateKeyEncoding: BasePrivateKeyEncodingOptions<PrivF> & {
            type: "pkcs8";
        };
    }
    interface DSAKeyPairOptions<PubF extends KeyFormat, PrivF extends KeyFormat> {
        /**
         * Key size in bits
         */
        modulusLength: number;
        /**
         * Size of q in bits
         */
        divisorLength: number;
        publicKeyEncoding: {
            type: "spki";
            format: PubF;
        };
        privateKeyEncoding: BasePrivateKeyEncodingOptions<PrivF> & {
            type: "pkcs8";
        };
    }
    interface ECKeyPairOptions<PubF extends KeyFormat, PrivF extends KeyFormat> extends ECKeyPairKeyObjectOptions {
        publicKeyEncoding: {
            type: "pkcs1" | "spki";
            format: PubF;
        };
        privateKeyEncoding: BasePrivateKeyEncodingOptions<PrivF> & {
            type: "sec1" | "pkcs8";
        };
    }
    interface ED25519KeyPairOptions<PubF extends KeyFormat, PrivF extends KeyFormat> {
        publicKeyEncoding: {
            type: "spki";
            format: PubF;
        };
        privateKeyEncoding: BasePrivateKeyEncodingOptions<PrivF> & {
            type: "pkcs8";
        };
    }
    interface ED448KeyPairOptions<PubF extends KeyFormat, PrivF extends KeyFormat> {
        publicKeyEncoding: {
            type: "spki";
            format: PubF;
        };
        privateKeyEncoding: BasePrivateKeyEncodingOptions<PrivF> & {
            type: "pkcs8";
        };
    }
    interface X25519KeyPairOptions<PubF extends KeyFormat, PrivF extends KeyFormat> {
        publicKeyEncoding: {
            type: "spki";
            format: PubF;
        };
        privateKeyEncoding: BasePrivateKeyEncodingOptions<PrivF> & {
            type: "pkcs8";
        };
    }
    interface X448KeyPairOptions<PubF extends KeyFormat, PrivF extends KeyFormat> {
        publicKeyEncoding: {
            type: "spki";
            format: PubF;
        };
        privateKeyEncoding: BasePrivateKeyEncodingOptions<PrivF> & {
            type: "pkcs8";
        };
    }
    interface KeyPairSyncResult<T1 extends string | Buffer, T2 extends string | Buffer> {
        publicKey: T1;
        privateKey: T2;
    }
    /**
     * Generates a new asymmetric key pair of the given `type`. RSA, RSA-PSS, DSA, EC,
     * Ed25519, Ed448, X25519, X448, and DH are currently supported.
     *
     * If a `publicKeyEncoding` or `privateKeyEncoding` was specified, this function
     * behaves as if `keyObject.export()` had been called on its result. Otherwise,
     * the respective part of the key is returned as a `KeyObject`.
     *
     * When encoding public keys, it is recommended to use `'spki'`. When encoding
     * private keys, it is recommended to use `'pkcs8'` with a strong passphrase,
     * and to keep the passphrase confidential.
     *
     * ```js
     * const {
     *   generateKeyPairSync,
     * } = await import('node:crypto');
     *
     * const {
     *   publicKey,
     *   privateKey,
     * } = generateKeyPairSync('rsa', {
     *   modulusLength: 4096,
     *   publicKeyEncoding: {
     *     type: 'spki',
     *     format: 'pem',
     *   },
     *   privateKeyEncoding: {
     *     type: 'pkcs8',
     *     format: 'pem',
     *     cipher: 'aes-256-cbc',
     *     passphrase: 'top secret',
     *   },
     * });
     * ```
     *
     * The return value `{ publicKey, privateKey }` represents the generated key pair.
     * When PEM encoding was selected, the respective key will be a string, otherwise
     * it will be a buffer containing the data encoded as DER.
     * @since v10.12.0
     * @param type Must be `'rsa'`, `'rsa-pss'`, `'dsa'`, `'ec'`, `'ed25519'`, `'ed448'`, `'x25519'`, `'x448'`, or `'dh'`.
     */
    function generateKeyPairSync(
        type: "rsa",
        options: RSAKeyPairOptions<"pem", "pem">,
    ): KeyPairSyncResult<string, string>;
    function generateKeyPairSync(
        type: "rsa",
        options: RSAKeyPairOptions<"pem", "der">,
    ): KeyPairSyncResult<string, Buffer>;
    function generateKeyPairSync(
        type: "rsa",
        options: RSAKeyPairOptions<"der", "pem">,
    ): KeyPairSyncResult<Buffer, string>;
    function generateKeyPairSync(
        type: "rsa",
        options: RSAKeyPairOptions<"der", "der">,
    ): KeyPairSyncResult<Buffer, Buffer>;
    function generateKeyPairSync(type: "rsa", options: RSAKeyPairKeyObjectOptions): KeyPairKeyObjectResult;
    function generateKeyPairSync(
        type: "rsa-pss",
        options: RSAPSSKeyPairOptions<"pem", "pem">,
    ): KeyPairSyncResult<string, string>;
    function generateKeyPairSync(
        type: "rsa-pss",
        options: RSAPSSKeyPairOptions<"pem", "der">,
    ): KeyPairSyncResult<string, Buffer>;
    function generateKeyPairSync(
        type: "rsa-pss",
        options: RSAPSSKeyPairOptions<"der", "pem">,
    ): KeyPairSyncResult<Buffer, string>;
    function generateKeyPairSync(
        type: "rsa-pss",
        options: RSAPSSKeyPairOptions<"der", "der">,
    ): KeyPairSyncResult<Buffer, Buffer>;
    function generateKeyPairSync(type: "rsa-pss", options: RSAPSSKeyPairKeyObjectOptions): KeyPairKeyObjectResult;
    function generateKeyPairSync(
        type: "dsa",
        options: DSAKeyPairOptions<"pem", "pem">,
    ): KeyPairSyncResult<string, string>;
    function generateKeyPairSync(
        type: "dsa",
        options: DSAKeyPairOptions<"pem", "der">,
    ): KeyPairSyncResult<string, Buffer>;
    function generateKeyPairSync(
        type: "dsa",
        options: DSAKeyPairOptions<"der", "pem">,
    ): KeyPairSyncResult<Buffer, string>;
    function generateKeyPairSync(
        type: "dsa",
        options: DSAKeyPairOptions<"der", "der">,
    ): KeyPairSyncResult<Buffer, Buffer>;
    function generateKeyPairSync(type: "dsa", options: DSAKeyPairKeyObjectOptions): KeyPairKeyObjectResult;
    function generateKeyPairSync(
        type: "ec",
        options: ECKeyPairOptions<"pem", "pem">,
    ): KeyPairSyncResult<string, string>;
    function generateKeyPairSync(
        type: "ec",
        options: ECKeyPairOptions<"pem", "der">,
    ): KeyPairSyncResult<string, Buffer>;
    function generateKeyPairSync(
        type: "ec",
        options: ECKeyPairOptions<"der", "pem">,
    ): KeyPairSyncResult<Buffer, string>;
    function generateKeyPairSync(
        type: "ec",
        options: ECKeyPairOptions<"der", "der">,
    ): KeyPairSyncResult<Buffer, Buffer>;
    function generateKeyPairSync(type: "ec", options: ECKeyPairKeyObjectOptions): KeyPairKeyObjectResult;
    function generateKeyPairSync(
        type: "ed25519",
        options: ED25519KeyPairOptions<"pem", "pem">,
    ): KeyPairSyncResult<string, string>;
    function generateKeyPairSync(
        type: "ed25519",
        options: ED25519KeyPairOptions<"pem", "der">,
    ): KeyPairSyncResult<string, Buffer>;
    function generateKeyPairSync(
        type: "ed25519",
        options: ED25519KeyPairOptions<"der", "pem">,
    ): KeyPairSyncResult<Buffer, string>;
    function generateKeyPairSync(
        type: "ed25519",
        options: ED25519KeyPairOptions<"der", "der">,
    ): KeyPairSyncResult<Buffer, Buffer>;
    function generateKeyPairSync(type: "ed25519", options?: ED25519KeyPairKeyObjectOptions): KeyPairKeyObjectResult;
    function generateKeyPairSync(
        type: "ed448",
        options: ED448KeyPairOptions<"pem", "pem">,
    ): KeyPairSyncResult<string, string>;
    function generateKeyPairSync(
        type: "ed448",
        options: ED448KeyPairOptions<"pem", "der">,
    ): KeyPairSyncResult<string, Buffer>;
    function generateKeyPairSync(
        type: "ed448",
        options: ED448KeyPairOptions<"der", "pem">,
    ): KeyPairSyncResult<Buffer, string>;
    function generateKeyPairSync(
        type: "ed448",
        options: ED448KeyPairOptions<"der", "der">,
    ): KeyPairSyncResult<Buffer, Buffer>;
    function generateKeyPairSync(type: "ed448", options?: ED448KeyPairKeyObjectOptions): KeyPairKeyObjectResult;
    function generateKeyPairSync(
        type: "x25519",
        options: X25519KeyPairOptions<"pem", "pem">,
    ): KeyPairSyncResult<string, string>;
    function generateKeyPairSync(
        type: "x25519",
        options: X25519KeyPairOptions<"pem", "der">,
    ): KeyPairSyncResult<string, Buffer>;
    function generateKeyPairSync(
        type: "x25519",
        options: X25519KeyPairOptions<"der", "pem">,
    ): KeyPairSyncResult<Buffer, string>;
    function generateKeyPairSync(
        type: "x25519",
        options: X25519KeyPairOptions<"der", "der">,
    ): KeyPairSyncResult<Buffer, Buffer>;
    function generateKeyPairSync(type: "x25519", options?: X25519KeyPairKeyObjectOptions): KeyPairKeyObjectResult;
    function generateKeyPairSync(
        type: "x448",
        options: X448KeyPairOptions<"pem", "pem">,
    ): KeyPairSyncResult<string, string>;
    function generateKeyPairSync(
        type: "x448",
        options: X448KeyPairOptions<"pem", "der">,
    ): KeyPairSyncResult<string, Buffer>;
    function generateKeyPairSync(
        type: "x448",
        options: X448KeyPairOptions<"der", "pem">,
    ): KeyPairSyncResult<Buffer, string>;
    function generateKeyPairSync(
        type: "x448",
        options: X448KeyPairOptions<"der", "der">,
    ): KeyPairSyncResult<Buffer, Buffer>;
    function generateKeyPairSync(type: "x448", options?: X448KeyPairKeyObjectOptions): KeyPairKeyObjectResult;
    /**
     * Generates a new asymmetric key pair of the given `type`. RSA, RSA-PSS, DSA, EC,
     * Ed25519, Ed448, X25519, X448, and DH are currently supported.
     *
     * If a `publicKeyEncoding` or `privateKeyEncoding` was specified, this function
     * behaves as if `keyObject.export()` had been called on its result. Otherwise,
     * the respective part of the key is returned as a `KeyObject`.
     *
     * It is recommended to encode public keys as `'spki'` and private keys as `'pkcs8'` with encryption for long-term storage:
     *
     * ```js
     * const {
     *   generateKeyPair,
     * } = await import('node:crypto');
     *
     * generateKeyPair('rsa', {
     *   modulusLength: 4096,
     *   publicKeyEncoding: {
     *     type: 'spki',
     *     format: 'pem',
     *   },
     *   privateKeyEncoding: {
     *     type: 'pkcs8',
     *     format: 'pem',
     *     cipher: 'aes-256-cbc',
     *     passphrase: 'top secret',
     *   },
     * }, (err, publicKey, privateKey) => {
     *   // Handle errors and use the generated key pair.
     * });
     * ```
     *
     * On completion, `callback` will be called with `err` set to `undefined` and `publicKey` / `privateKey` representing the generated key pair.
     *
     * If this method is invoked as its `util.promisify()` ed version, it returns
     * a `Promise` for an `Object` with `publicKey` and `privateKey` properties.
     * @since v10.12.0
     * @param type Must be `'rsa'`, `'rsa-pss'`, `'dsa'`, `'ec'`, `'ed25519'`, `'ed448'`, `'x25519'`, `'x448'`, or `'dh'`.
     */
    function generateKeyPair(
        type: "rsa",
        options: RSAKeyPairOptions<"pem", "pem">,
        callback: (err: Error | null, publicKey: string, privateKey: string) => void,
    ): void;
    function generateKeyPair(
        type: "rsa",
        options: RSAKeyPairOptions<"pem", "der">,
        callback: (err: Error | null, publicKey: string, privateKey: Buffer) => void,
    ): void;
    function generateKeyPair(
        type: "rsa",
        options: RSAKeyPairOptions<"der", "pem">,
        callback: (err: Error | null, publicKey: Buffer, privateKey: string) => void,
    ): void;
    function generateKeyPair(
        type: "rsa",
        options: RSAKeyPairOptions<"der", "der">,
        callback: (err: Error | null, publicKey: Buffer, privateKey: Buffer) => void,
    ): void;
    function generateKeyPair(
        type: "rsa",
        options: RSAKeyPairKeyObjectOptions,
        callback: (err: Error | null, publicKey: KeyObject, privateKey: KeyObject) => void,
    ): void;
    function generateKeyPair(
        type: "rsa-pss",
        options: RSAPSSKeyPairOptions<"pem", "pem">,
        callback: (err: Error | null, publicKey: string, privateKey: string) => void,
    ): void;
    function generateKeyPair(
        type: "rsa-pss",
        options: RSAPSSKeyPairOptions<"pem", "der">,
        callback: (err: Error | null, publicKey: string, privateKey: Buffer) => void,
    ): void;
    function generateKeyPair(
        type: "rsa-pss",
        options: RSAPSSKeyPairOptions<"der", "pem">,
        callback: (err: Error | null, publicKey: Buffer, privateKey: string) => void,
    ): void;
    function generateKeyPair(
        type: "rsa-pss",
        options: RSAPSSKeyPairOptions<"der", "der">,
        callback: (err: Error | null, publicKey: Buffer, privateKey: Buffer) => void,
    ): void;
    function generateKeyPair(
        type: "rsa-pss",
        options: RSAPSSKeyPairKeyObjectOptions,
        callback: (err: Error | null, publicKey: KeyObject, privateKey: KeyObject) => void,
    ): void;
    function generateKeyPair(
        type: "dsa",
        options: DSAKeyPairOptions<"pem", "pem">,
        callback: (err: Error | null, publicKey: string, privateKey: string) => void,
    ): void;
    function generateKeyPair(
        type: "dsa",
        options: DSAKeyPairOptions<"pem", "der">,
        callback: (err: Error | null, publicKey: string, privateKey: Buffer) => void,
    ): void;
    function generateKeyPair(
        type: "dsa",
        options: DSAKeyPairOptions<"der", "pem">,
        callback: (err: Error | null, publicKey: Buffer, privateKey: string) => void,
    ): void;
    function generateKeyPair(
        type: "dsa",
        options: DSAKeyPairOptions<"der", "der">,
        callback: (err: Error | null, publicKey: Buffer, privateKey: Buffer) => void,
    ): void;
    function generateKeyPair(
        type: "dsa",
        options: DSAKeyPairKeyObjectOptions,
        callback: (err: Error | null, publicKey: KeyObject, privateKey: KeyObject) => void,
    ): void;
    function generateKeyPair(
        type: "ec",
        options: ECKeyPairOptions<"pem", "pem">,
        callback: (err: Error | null, publicKey: string, privateKey: string) => void,
    ): void;
    function generateKeyPair(
        type: "ec",
        options: ECKeyPairOptions<"pem", "der">,
        callback: (err: Error | null, publicKey: string, privateKey: Buffer) => void,
    ): void;
    function generateKeyPair(
        type: "ec",
        options: ECKeyPairOptions<"der", "pem">,
        callback: (err: Error | null, publicKey: Buffer, privateKey: string) => void,
    ): void;
    function generateKeyPair(
        type: "ec",
        options: ECKeyPairOptions<"der", "der">,
        callback: (err: Error | null, publicKey: Buffer, privateKey: Buffer) => void,
    ): void;
    function generateKeyPair(
        type: "ec",
        options: ECKeyPairKeyObjectOptions,
        callback: (err: Error | null, publicKey: KeyObject, privateKey: KeyObject) => void,
    ): void;
    function generateKeyPair(
        type: "ed25519",
        options: ED25519KeyPairOptions<"pem", "pem">,
        callback: (err: Error | null, publicKey: string, privateKey: string) => void,
    ): void;
    function generateKeyPair(
        type: "ed25519",
        options: ED25519KeyPairOptions<"pem", "der">,
        callback: (err: Error | null, publicKey: string, privateKey: Buffer) => void,
    ): void;
    function generateKeyPair(
        type: "ed25519",
        options: ED25519KeyPairOptions<"der", "pem">,
        callback: (err: Error | null, publicKey: Buffer, privateKey: string) => void,
    ): void;
    function generateKeyPair(
        type: "ed25519",
        options: ED25519KeyPairOptions<"der", "der">,
        callback: (err: Error | null, publicKey: Buffer, privateKey: Buffer) => void,
    ): void;
    function generateKeyPair(
        type: "ed25519",
        options: ED25519KeyPairKeyObjectOptions | undefined,
        callback: (err: Error | null, publicKey: KeyObject, privateKey: KeyObject) => void,
    ): void;
    function generateKeyPair(
        type: "ed448",
        options: ED448KeyPairOptions<"pem", "pem">,
        callback: (err: Error | null, publicKey: string, privateKey: string) => void,
    ): void;
    function generateKeyPair(
        type: "ed448",
        options: ED448KeyPairOptions<"pem", "der">,
        callback: (err: Error | null, publicKey: string, privateKey: Buffer) => void,
    ): void;
    function generateKeyPair(
        type: "ed448",
        options: ED448KeyPairOptions<"der", "pem">,
        callback: (err: Error | null, publicKey: Buffer, privateKey: string) => void,
    ): void;
    function generateKeyPair(
        type: "ed448",
        options: ED448KeyPairOptions<"der", "der">,
        callback: (err: Error | null, publicKey: Buffer, privateKey: Buffer) => void,
    ): void;
    function generateKeyPair(
        type: "ed448",
        options: ED448KeyPairKeyObjectOptions | undefined,
        callback: (err: Error | null, publicKey: KeyObject, privateKey: KeyObject) => void,
    ): void;
    function generateKeyPair(
        type: "x25519",
        options: X25519KeyPairOptions<"pem", "pem">,
        callback: (err: Error | null, publicKey: string, privateKey: string) => void,
    ): void;
    function generateKeyPair(
        type: "x25519",
        options: X25519KeyPairOptions<"pem", "der">,
        callback: (err: Error | null, publicKey: string, privateKey: Buffer) => void,
    ): void;
    function generateKeyPair(
        type: "x25519",
        options: X25519KeyPairOptions<"der", "pem">,
        callback: (err: Error | null, publicKey: Buffer, privateKey: string) => void,
    ): void;
    function generateKeyPair(
        type: "x25519",
        options: X25519KeyPairOptions<"der", "der">,
        callback: (err: Error | null, publicKey: Buffer, privateKey: Buffer) => void,
    ): void;
    function generateKeyPair(
        type: "x25519",
        options: X25519KeyPairKeyObjectOptions | undefined,
        callback: (err: Error | null, publicKey: KeyObject, privateKey: KeyObject) => void,
    ): void;
    function generateKeyPair(
        type: "x448",
        options: X448KeyPairOptions<"pem", "pem">,
        callback: (err: Error | null, publicKey: string, privateKey: string) => void,
    ): void;
    function generateKeyPair(
        type: "x448",
        options: X448KeyPairOptions<"pem", "der">,
        callback: (err: Error | null, publicKey: string, privateKey: Buffer) => void,
    ): void;
    function generateKeyPair(
        type: "x448",
        options: X448KeyPairOptions<"der", "pem">,
        callback: (err: Error | null, publicKey: Buffer, privateKey: string) => void,
    ): void;
    function generateKeyPair(
        type: "x448",
        options: X448KeyPairOptions<"der", "der">,
        callback: (err: Error | null, publicKey: Buffer, privateKey: Buffer) => void,
    ): void;
    function generateKeyPair(
        type: "x448",
        options: X448KeyPairKeyObjectOptions | undefined,
        callback: (err: Error | null, publicKey: KeyObject, privateKey: KeyObject) => void,
    ): void;
    namespace generateKeyPair {
        function __promisify__(
            type: "rsa",
            options: RSAKeyPairOptions<"pem", "pem">,
        ): Promise<{
            publicKey: string;
            privateKey: string;
        }>;
        function __promisify__(
            type: "rsa",
            options: RSAKeyPairOptions<"pem", "der">,
        ): Promise<{
            publicKey: string;
            privateKey: Buffer;
        }>;
        function __promisify__(
            type: "rsa",
            options: RSAKeyPairOptions<"der", "pem">,
        ): Promise<{
            publicKey: Buffer;
            privateKey: string;
        }>;
        function __promisify__(
            type: "rsa",
            options: RSAKeyPairOptions<"der", "der">,
        ): Promise<{
            publicKey: Buffer;
            privateKey: Buffer;
        }>;
        function __promisify__(type: "rsa", options: RSAKeyPairKeyObjectOptions): Promise<KeyPairKeyObjectResult>;
        function __promisify__(
            type: "rsa-pss",
            options: RSAPSSKeyPairOptions<"pem", "pem">,
        ): Promise<{
            publicKey: string;
            privateKey: string;
        }>;
        function __promisify__(
            type: "rsa-pss",
            options: RSAPSSKeyPairOptions<"pem", "der">,
        ): Promise<{
            publicKey: string;
            privateKey: Buffer;
        }>;
        function __promisify__(
            type: "rsa-pss",
            options: RSAPSSKeyPairOptions<"der", "pem">,
        ): Promise<{
            publicKey: Buffer;
            privateKey: string;
        }>;
        function __promisify__(
            type: "rsa-pss",
            options: RSAPSSKeyPairOptions<"der", "der">,
        ): Promise<{
            publicKey: Buffer;
            privateKey: Buffer;
        }>;
        function __promisify__(
            type: "rsa-pss",
            options: RSAPSSKeyPairKeyObjectOptions,
        ): Promise<KeyPairKeyObjectResult>;
        function __promisify__(
            type: "dsa",
            options: DSAKeyPairOptions<"pem", "pem">,
        ): Promise<{
            publicKey: string;
            privateKey: string;
        }>;
        function __promisify__(
            type: "dsa",
            options: DSAKeyPairOptions<"pem", "der">,
        ): Promise<{
            publicKey: string;
            privateKey: Buffer;
        }>;
        function __promisify__(
            type: "dsa",
            options: DSAKeyPairOptions<"der", "pem">,
        ): Promise<{
            publicKey: Buffer;
            privateKey: string;
        }>;
        function __promisify__(
            type: "dsa",
            options: DSAKeyPairOptions<"der", "der">,
        ): Promise<{
            publicKey: Buffer;
            privateKey: Buffer;
        }>;
        function __promisify__(type: "dsa", options: DSAKeyPairKeyObjectOptions): Promise<KeyPairKeyObjectResult>;
        function __promisify__(
            type: "ec",
            options: ECKeyPairOptions<"pem", "pem">,
        ): Promise<{
            publicKey: string;
            privateKey: string;
        }>;
        function __promisify__(
            type: "ec",
            options: ECKeyPairOptions<"pem", "der">,
        ): Promise<{
            publicKey: string;
            privateKey: Buffer;
        }>;
        function __promisify__(
            type: "ec",
            options: ECKeyPairOptions<"der", "pem">,
        ): Promise<{
            publicKey: Buffer;
            privateKey: string;
        }>;
        function __promisify__(
            type: "ec",
            options: ECKeyPairOptions<"der", "der">,
        ): Promise<{
            publicKey: Buffer;
            privateKey: Buffer;
        }>;
        function __promisify__(type: "ec", options: ECKeyPairKeyObjectOptions): Promise<KeyPairKeyObjectResult>;
        function __promisify__(
            type: "ed25519",
            options: ED25519KeyPairOptions<"pem", "pem">,
        ): Promise<{
            publicKey: string;
            privateKey: string;
        }>;
        function __promisify__(
            type: "ed25519",
            options: ED25519KeyPairOptions<"pem", "der">,
        ): Promise<{
            publicKey: string;
            privateKey: Buffer;
        }>;
        function __promisify__(
            type: "ed25519",
            options: ED25519KeyPairOptions<"der", "pem">,
        ): Promise<{
            publicKey: Buffer;
            privateKey: string;
        }>;
        function __promisify__(
            type: "ed25519",
            options: ED25519KeyPairOptions<"der", "der">,
        ): Promise<{
            publicKey: Buffer;
            privateKey: Buffer;
        }>;
        function __promisify__(
            type: "ed25519",
            options?: ED25519KeyPairKeyObjectOptions,
        ): Promise<KeyPairKeyObjectResult>;
        function __promisify__(
            type: "ed448",
            options: ED448KeyPairOptions<"pem", "pem">,
        ): Promise<{
            publicKey: string;
            privateKey: string;
        }>;
        function __promisify__(
            type: "ed448",
            options: ED448KeyPairOptions<"pem", "der">,
        ): Promise<{
            publicKey: string;
            privateKey: Buffer;
        }>;
        function __promisify__(
            type: "ed448",
            options: ED448KeyPairOptions<"der", "pem">,
        ): Promise<{
            publicKey: Buffer;
            privateKey: string;
        }>;
        function __promisify__(
            type: "ed448",
            options: ED448KeyPairOptions<"der", "der">,
        ): Promise<{
            publicKey: Buffer;
            privateKey: Buffer;
        }>;
        function __promisify__(type: "ed448", options?: ED448KeyPairKeyObjectOptions): Promise<KeyPairKeyObjectResult>;
        function __promisify__(
            type: "x25519",
            options: X25519KeyPairOptions<"pem", "pem">,
        ): Promise<{
            publicKey: string;
            privateKey: string;
        }>;
        function __promisify__(
            type: "x25519",
            options: X25519KeyPairOptions<"pem", "der">,
        ): Promise<{
            publicKey: string;
            privateKey: Buffer;
        }>;
        function __promisify__(
            type: "x25519",
            options: X25519KeyPairOptions<"der", "pem">,
        ): Promise<{
            publicKey: Buffer;
            privateKey: string;
        }>;
        function __promisify__(
            type: "x25519",
            options: X25519KeyPairOptions<"der", "der">,
        ): Promise<{
            publicKey: Buffer;
            privateKey: Buffer;
        }>;
        function __promisify__(
            type: "x25519",
            options?: X25519KeyPairKeyObjectOptions,
        ): Promise<KeyPairKeyObjectResult>;
        function __promisify__(
            type: "x448",
            options: X448KeyPairOptions<"pem", "pem">,
        ): Promise<{
            publicKey: string;
            privateKey: string;
        }>;
        function __promisify__(
            type: "x448",
            options: X448KeyPairOptions<"pem", "der">,
        ): Promise<{
            publicKey: string;
            privateKey: Buffer;
        }>;
        function __promisify__(
            type: "x448",
            options: X448KeyPairOptions<"der", "pem">,
        ): Promise<{
            publicKey: Buffer;
            privateKey: string;
        }>;
        function __promisify__(
            type: "x448",
            options: X448KeyPairOptions<"der", "der">,
        ): Promise<{
            publicKey: Buffer;
            privateKey: Buffer;
        }>;
        function __promisify__(type: "x448", options?: X448KeyPairKeyObjectOptions): Promise<KeyPairKeyObjectResult>;
    }
    /**
     * Calculates and returns the signature for `data` using the given private key and
     * algorithm. If `algorithm` is `null` or `undefined`, then the algorithm is
     * dependent upon the key type (especially Ed25519 and Ed448).
     *
     * If `key` is not a `KeyObject`, this function behaves as if `key` had been
     * passed to {@link createPrivateKey}. If it is an object, the following
     * additional properties can be passed:
     *
     * If the `callback` function is provided this function uses libuv's threadpool.
     * @since v12.0.0
     */
    function sign(
        algorithm: string | null | undefined,
        data: NodeJS.ArrayBufferView,
        key: KeyLike | SignKeyObjectInput | SignPrivateKeyInput | SignJsonWebKeyInput,
    ): Buffer;
    function sign(
        algorithm: string | null | undefined,
        data: NodeJS.ArrayBufferView,
        key: KeyLike | SignKeyObjectInput | SignPrivateKeyInput | SignJsonWebKeyInput,
        callback: (error: Error | null, data: Buffer) => void,
    ): void;
    /**
     * Verifies the given signature for `data` using the given key and algorithm. If `algorithm` is `null` or `undefined`, then the algorithm is dependent upon the
     * key type (especially Ed25519 and Ed448).
     *
     * If `key` is not a `KeyObject`, this function behaves as if `key` had been
     * passed to {@link createPublicKey}. If it is an object, the following
     * additional properties can be passed:
     *
     * The `signature` argument is the previously calculated signature for the `data`.
     *
     * Because public keys can be derived from private keys, a private key or a public
     * key may be passed for `key`.
     *
     * If the `callback` function is provided this function uses libuv's threadpool.
     * @since v12.0.0
     */
    function verify(
        algorithm: string | null | undefined,
        data: NodeJS.ArrayBufferView,
        key: KeyLike | VerifyKeyObjectInput | VerifyPublicKeyInput | VerifyJsonWebKeyInput,
        signature: NodeJS.ArrayBufferView,
    ): boolean;
    function verify(
        algorithm: string | null | undefined,
        data: NodeJS.ArrayBufferView,
        key: KeyLike | VerifyKeyObjectInput | VerifyPublicKeyInput | VerifyJsonWebKeyInput,
        signature: NodeJS.ArrayBufferView,
        callback: (error: Error | null, result: boolean) => void,
    ): void;
    /**
     * Computes the Diffie-Hellman secret based on a `privateKey` and a `publicKey`.
     * Both keys must have the same `asymmetricKeyType`, which must be one of `'dh'` (for Diffie-Hellman), `'ec'` (for ECDH), `'x448'`, or `'x25519'` (for ECDH-ES).
     * @since v13.9.0, v12.17.0
     */
    function diffieHellman(options: { privateKey: KeyObject; publicKey: KeyObject }): Buffer;
    /**
     * A utility for creating one-shot hash digests of data. It can be faster than the object-based `crypto.createHash()` when hashing a smaller amount of data
     * (<= 5MB) that's readily available. If the data can be big or if it is streamed, it's still recommended to use `crypto.createHash()` instead. The `algorithm`
     * is dependent on the available algorithms supported by the version of OpenSSL on the platform. Examples are `'sha256'`, `'sha512'`, etc. On recent releases
     * of OpenSSL, `openssl list -digest-algorithms` will display the available digest algorithms.
     *
     * Example:
     *
     * ```js
     * import crypto from 'node:crypto';
     * import { Buffer } from 'node:buffer';
     *
     * // Hashing a string and return the result as a hex-encoded string.
     * const string = 'Node.js';
     * // 10b3493287f831e81a438811a1ffba01f8cec4b7
     * console.log(crypto.hash('sha1', string));
     *
     * // Encode a base64-encoded string into a Buffer, hash it and return
     * // the result as a buffer.
     * const base64 = 'Tm9kZS5qcw==';
     * // <Buffer 10 b3 49 32 87 f8 31 e8 1a 43 88 11 a1 ff ba 01 f8 ce c4 b7>
     * console.log(crypto.hash('sha1', Buffer.from(base64, 'base64'), 'buffer'));
     * ```
     * @since v21.7.0, v20.12.0
     * @param data When `data` is a string, it will be encoded as UTF-8 before being hashed. If a different input encoding is desired for a string input, user
     *             could encode the string into a `TypedArray` using either `TextEncoder` or `Buffer.from()` and passing the encoded `TypedArray` into this API instead.
     * @param [outputEncoding='hex'] [Encoding](https://nodejs.org/docs/latest-v22.x/api/buffer.html#buffers-and-character-encodings) used to encode the returned digest.
     */
    function hash(algorithm: string, data: BinaryLike, outputEncoding?: BinaryToTextEncoding): string;
    function hash(algorithm: string, data: BinaryLike, outputEncoding: "buffer"): Buffer;
    function hash(
        algorithm: string,
        data: BinaryLike,
        outputEncoding?: BinaryToTextEncoding | "buffer",
    ): string | Buffer;
    type CipherMode = "cbc" | "ccm" | "cfb" | "ctr" | "ecb" | "gcm" | "ocb" | "ofb" | "stream" | "wrap" | "xts";
    interface CipherInfoOptions {
        /**
         * A test key length.
         */
        keyLength?: number | undefined;
        /**
         * A test IV length.
         */
        ivLength?: number | undefined;
    }
    interface CipherInfo {
        /**
         * The name of the cipher.
         */
        name: string;
        /**
         * The nid of the cipher.
         */
        nid: number;
        /**
         * The block size of the cipher in bytes.
         * This property is omitted when mode is 'stream'.
         */
        blockSize?: number | undefined;
        /**
         * The expected or default initialization vector length in bytes.
         * This property is omitted if the cipher does not use an initialization vector.
         */
        ivLength?: number | undefined;
        /**
         * The expected or default key length in bytes.
         */
        keyLength: number;
        /**
         * The cipher mode.
         */
        mode: CipherMode;
    }
    /**
     * Returns information about a given cipher.
     *
     * Some ciphers accept variable length keys and initialization vectors. By default,
     * the `crypto.getCipherInfo()` method will return the default values for these
     * ciphers. To test if a given key length or iv length is acceptable for given
     * cipher, use the `keyLength` and `ivLength` options. If the given values are
     * unacceptable, `undefined` will be returned.
     * @since v15.0.0
     * @param nameOrNid The name or nid of the cipher to query.
     */
    function getCipherInfo(nameOrNid: string | number, options?: CipherInfoOptions): CipherInfo | undefined;
    /**
     * HKDF is a simple key derivation function defined in RFC 5869\. The given `ikm`, `salt` and `info` are used with the `digest` to derive a key of `keylen` bytes.
     *
     * The supplied `callback` function is called with two arguments: `err` and `derivedKey`. If an errors occurs while deriving the key, `err` will be set;
     * otherwise `err` will be `null`. The successfully generated `derivedKey` will
     * be passed to the callback as an [ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer). An error will be thrown if any
     * of the input arguments specify invalid values or types.
     *
     * ```js
     * import { Buffer } from 'node:buffer';
     * const {
     *   hkdf,
     * } = await import('node:crypto');
     *
     * hkdf('sha512', 'key', 'salt', 'info', 64, (err, derivedKey) => {
     *   if (err) throw err;
     *   console.log(Buffer.from(derivedKey).toString('hex'));  // '24156e2...5391653'
     * });
     * ```
     * @since v15.0.0
     * @param digest The digest algorithm to use.
     * @param ikm The input keying material. Must be provided but can be zero-length.
     * @param salt The salt value. Must be provided but can be zero-length.
     * @param info Additional info value. Must be provided but can be zero-length, and cannot be more than 1024 bytes.
     * @param keylen The length of the key to generate. Must be greater than 0. The maximum allowable value is `255` times the number of bytes produced by the selected digest function (e.g. `sha512`
     * generates 64-byte hashes, making the maximum HKDF output 16320 bytes).
     */
    function hkdf(
        digest: string,
        irm: BinaryLike | KeyObject,
        salt: BinaryLike,
        info: BinaryLike,
        keylen: number,
        callback: (err: Error | null, derivedKey: ArrayBuffer) => void,
    ): void;
    /**
     * Provides a synchronous HKDF key derivation function as defined in RFC 5869\. The
     * given `ikm`, `salt` and `info` are used with the `digest` to derive a key of `keylen` bytes.
     *
     * The successfully generated `derivedKey` will be returned as an [ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer).
     *
     * An error will be thrown if any of the input arguments specify invalid values or
     * types, or if the derived key cannot be generated.
     *
     * ```js
     * import { Buffer } from 'node:buffer';
     * const {
     *   hkdfSync,
     * } = await import('node:crypto');
     *
     * const derivedKey = hkdfSync('sha512', 'key', 'salt', 'info', 64);
     * console.log(Buffer.from(derivedKey).toString('hex'));  // '24156e2...5391653'
     * ```
     * @since v15.0.0
     * @param digest The digest algorithm to use.
     * @param ikm The input keying material. Must be provided but can be zero-length.
     * @param salt The salt value. Must be provided but can be zero-length.
     * @param info Additional info value. Must be provided but can be zero-length, and cannot be more than 1024 bytes.
     * @param keylen The length of the key to generate. Must be greater than 0. The maximum allowable value is `255` times the number of bytes produced by the selected digest function (e.g. `sha512`
     * generates 64-byte hashes, making the maximum HKDF output 16320 bytes).
     */
    function hkdfSync(
        digest: string,
        ikm: BinaryLike | KeyObject,
        salt: BinaryLike,
        info: BinaryLike,
        keylen: number,
    ): ArrayBuffer;
    interface SecureHeapUsage {
        /**
         * The total allocated secure heap size as specified using the `--secure-heap=n` command-line flag.
         */
        total: number;
        /**
         * The minimum allocation from the secure heap as specified using the `--secure-heap-min` command-line flag.
         */
        min: number;
        /**
         * The total number of bytes currently allocated from the secure heap.
         */
        used: number;
        /**
         * The calculated ratio of `used` to `total` allocated bytes.
         */
        utilization: number;
    }
    /**
     * @since v15.6.0
     */
    function secureHeapUsed(): SecureHeapUsage;
    interface RandomUUIDOptions {
        /**
         * By default, to improve performance,
         * Node.js will pre-emptively generate and persistently cache enough
         * random data to generate up to 128 random UUIDs. To generate a UUID
         * without using the cache, set `disableEntropyCache` to `true`.
         *
         * @default `false`
         */
        disableEntropyCache?: boolean | undefined;
    }
    type UUID = `${string}-${string}-${string}-${string}-${string}`;
    /**
     * Generates a random [RFC 4122](https://www.rfc-editor.org/rfc/rfc4122.txt) version 4 UUID. The UUID is generated using a
     * cryptographic pseudorandom number generator.
     * @since v15.6.0, v14.17.0
     */
    function randomUUID(options?: RandomUUIDOptions): UUID;
    interface X509CheckOptions {
        /**
         * @default 'always'
         */
        subject?: "always" | "default" | "never" | undefined;
        /**
         * @default true
         */
        wildcards?: boolean | undefined;
        /**
         * @default true
         */
        partialWildcards?: boolean | undefined;
        /**
         * @default false
         */
        multiLabelWildcards?: boolean | undefined;
        /**
         * @default false
         */
        singleLabelSubdomains?: boolean | undefined;
    }
    /**
     * Encapsulates an X509 certificate and provides read-only access to
     * its information.
     *
     * ```js
     * const { X509Certificate } = await import('node:crypto');
     *
     * const x509 = new X509Certificate('{... pem encoded cert ...}');
     *
     * console.log(x509.subject);
     * ```
     * @since v15.6.0
     */
    class X509Certificate {
        /**
         * Will be \`true\` if this is a Certificate Authority (CA) certificate.
         * @since v15.6.0
         */
        readonly ca: boolean;
        /**
         * The SHA-1 fingerprint of this certificate.
         *
         * Because SHA-1 is cryptographically broken and because the security of SHA-1 is
         * significantly worse than that of algorithms that are commonly used to sign
         * certificates, consider using `x509.fingerprint256` instead.
         * @since v15.6.0
         */
        readonly fingerprint: string;
        /**
         * The SHA-256 fingerprint of this certificate.
         * @since v15.6.0
         */
        readonly fingerprint256: string;
        /**
         * The SHA-512 fingerprint of this certificate.
         *
         * Because computing the SHA-256 fingerprint is usually faster and because it is
         * only half the size of the SHA-512 fingerprint, `x509.fingerprint256` may be
         * a better choice. While SHA-512 presumably provides a higher level of security in
         * general, the security of SHA-256 matches that of most algorithms that are
         * commonly used to sign certificates.
         * @since v17.2.0, v16.14.0
         */
        readonly fingerprint512: string;
        /**
         * The complete subject of this certificate.
         * @since v15.6.0
         */
        readonly subject: string;
        /**
         * The subject alternative name specified for this certificate.
         *
         * This is a comma-separated list of subject alternative names. Each entry begins
         * with a string identifying the kind of the subject alternative name followed by
         * a colon and the value associated with the entry.
         *
         * Earlier versions of Node.js incorrectly assumed that it is safe to split this
         * property at the two-character sequence `', '` (see [CVE-2021-44532](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-44532)). However,
         * both malicious and legitimate certificates can contain subject alternative names
         * that include this sequence when represented as a string.
         *
         * After the prefix denoting the type of the entry, the remainder of each entry
         * might be enclosed in quotes to indicate that the value is a JSON string literal.
         * For backward compatibility, Node.js only uses JSON string literals within this
         * property when necessary to avoid ambiguity. Third-party code should be prepared
         * to handle both possible entry formats.
         * @since v15.6.0
         */
        readonly subjectAltName: string | undefined;
        /**
         * A textual representation of the certificate's authority information access
         * extension.
         *
         * This is a line feed separated list of access descriptions. Each line begins with
         * the access method and the kind of the access location, followed by a colon and
         * the value associated with the access location.
         *
         * After the prefix denoting the access method and the kind of the access location,
         * the remainder of each line might be enclosed in quotes to indicate that the
         * value is a JSON string literal. For backward compatibility, Node.js only uses
         * JSON string literals within this property when necessary to avoid ambiguity.
         * Third-party code should be prepared to handle both possible entry formats.
         * @since v15.6.0
         */
        readonly infoAccess: string | undefined;
        /**
         * An array detailing the key usages for this certificate.
         * @since v15.6.0
         */
        readonly keyUsage: string[];
        /**
         * The issuer identification included in this certificate.
         * @since v15.6.0
         */
        readonly issuer: string;
        /**
         * The issuer certificate or `undefined` if the issuer certificate is not
         * available.
         * @since v15.9.0
         */
        readonly issuerCertificate: X509Certificate | undefined;
        /**
         * The public key `KeyObject` for this certificate.
         * @since v15.6.0
         */
        readonly publicKey: KeyObject;
        /**
         * A `Buffer` containing the DER encoding of this certificate.
         * @since v15.6.0
         */
        readonly raw: Buffer;
        /**
         * The serial number of this certificate.
         *
         * Serial numbers are assigned by certificate authorities and do not uniquely
         * identify certificates. Consider using `x509.fingerprint256` as a unique
         * identifier instead.
         * @since v15.6.0
         */
        readonly serialNumber: string;
        /**
         * The date/time from which this certificate is considered valid.
         * @since v15.6.0
         */
        readonly validFrom: string;
        /**
         * The date/time from which this certificate is valid, encapsulated in a `Date` object.
         * @since v22.10.0
         */
        readonly validFromDate: Date;
        /**
         * The date/time until which this certificate is considered valid.
         * @since v15.6.0
         */
        readonly validTo: string;
        /**
         * The date/time until which this certificate is valid, encapsulated in a `Date` object.
         * @since v22.10.0
         */
        readonly validToDate: Date;
        constructor(buffer: BinaryLike);
        /**
         * Checks whether the certificate matches the given email address.
         *
         * If the `'subject'` option is undefined or set to `'default'`, the certificate
         * subject is only considered if the subject alternative name extension either does
         * not exist or does not contain any email addresses.
         *
         * If the `'subject'` option is set to `'always'` and if the subject alternative
         * name extension either does not exist or does not contain a matching email
         * address, the certificate subject is considered.
         *
         * If the `'subject'` option is set to `'never'`, the certificate subject is never
         * considered, even if the certificate contains no subject alternative names.
         * @since v15.6.0
         * @return Returns `email` if the certificate matches, `undefined` if it does not.
         */
        checkEmail(email: string, options?: Pick<X509CheckOptions, "subject">): string | undefined;
        /**
         * Checks whether the certificate matches the given host name.
         *
         * If the certificate matches the given host name, the matching subject name is
         * returned. The returned name might be an exact match (e.g., `foo.example.com`)
         * or it might contain wildcards (e.g., `*.example.com`). Because host name
         * comparisons are case-insensitive, the returned subject name might also differ
         * from the given `name` in capitalization.
         *
         * If the `'subject'` option is undefined or set to `'default'`, the certificate
         * subject is only considered if the subject alternative name extension either does
         * not exist or does not contain any DNS names. This behavior is consistent with [RFC 2818](https://www.rfc-editor.org/rfc/rfc2818.txt) ("HTTP Over TLS").
         *
         * If the `'subject'` option is set to `'always'` and if the subject alternative
         * name extension either does not exist or does not contain a matching DNS name,
         * the certificate subject is considered.
         *
         * If the `'subject'` option is set to `'never'`, the certificate subject is never
         * considered, even if the certificate contains no subject alternative names.
         * @since v15.6.0
         * @return Returns a subject name that matches `name`, or `undefined` if no subject name matches `name`.
         */
        checkHost(name: string, options?: X509CheckOptions): string | undefined;
        /**
         * Checks whether the certificate matches the given IP address (IPv4 or IPv6).
         *
         * Only [RFC 5280](https://www.rfc-editor.org/rfc/rfc5280.txt) `iPAddress` subject alternative names are considered, and they
         * must match the given `ip` address exactly. Other subject alternative names as
         * well as the subject field of the certificate are ignored.
         * @since v15.6.0
         * @return Returns `ip` if the certificate matches, `undefined` if it does not.
         */
        checkIP(ip: string): string | undefined;
        /**
         * Checks whether this certificate was potentially issued by the given `otherCert`
         * by comparing the certificate metadata.
         *
         * This is useful for pruning a list of possible issuer certificates which have been
         * selected using a more rudimentary filtering routine, i.e. just based on subject
         * and issuer names.
         *
         * Finally, to verify that this certificate's signature was produced by a private key
         * corresponding to `otherCert`'s public key use `x509.verify(publicKey)`
         * with `otherCert`'s public key represented as a `KeyObject`
         * like so
         *
         * ```js
         * if (!x509.verify(otherCert.publicKey)) {
         *   throw new Error('otherCert did not issue x509');
         * }
         * ```
         * @since v15.6.0
         */
        checkIssued(otherCert: X509Certificate): boolean;
        /**
         * Checks whether the public key for this certificate is consistent with
         * the given private key.
         * @since v15.6.0
         * @param privateKey A private key.
         */
        checkPrivateKey(privateKey: KeyObject): boolean;
        /**
         * There is no standard JSON encoding for X509 certificates. The`toJSON()` method returns a string containing the PEM encoded
         * certificate.
         * @since v15.6.0
         */
        toJSON(): string;
        /**
         * Returns information about this certificate using the legacy `certificate object` encoding.
         * @since v15.6.0
         */
        toLegacyObject(): PeerCertificate;
        /**
         * Returns the PEM-encoded certificate.
         * @since v15.6.0
         */
        toString(): string;
        /**
         * Verifies that this certificate was signed by the given public key.
         * Does not perform any other validation checks on the certificate.
         * @since v15.6.0
         * @param publicKey A public key.
         */
        verify(publicKey: KeyObject): boolean;
    }
    type LargeNumberLike = NodeJS.ArrayBufferView | SharedArrayBuffer | ArrayBuffer | bigint;
    interface GeneratePrimeOptions {
        add?: LargeNumberLike | undefined;
        rem?: LargeNumberLike | undefined;
        /**
         * @default false
         */
        safe?: boolean | undefined;
        bigint?: boolean | undefined;
    }
    interface GeneratePrimeOptionsBigInt extends GeneratePrimeOptions {
        bigint: true;
    }
    interface GeneratePrimeOptionsArrayBuffer extends GeneratePrimeOptions {
        bigint?: false | undefined;
    }
    /**
     * Generates a pseudorandom prime of `size` bits.
     *
     * If `options.safe` is `true`, the prime will be a safe prime -- that is, `(prime - 1) / 2` will also be a prime.
     *
     * The `options.add` and `options.rem` parameters can be used to enforce additional
     * requirements, e.g., for Diffie-Hellman:
     *
     * * If `options.add` and `options.rem` are both set, the prime will satisfy the
     * condition that `prime % add = rem`.
     * * If only `options.add` is set and `options.safe` is not `true`, the prime will
     * satisfy the condition that `prime % add = 1`.
     * * If only `options.add` is set and `options.safe` is set to `true`, the prime
     * will instead satisfy the condition that `prime % add = 3`. This is necessary
     * because `prime % add = 1` for `options.add > 2` would contradict the condition
     * enforced by `options.safe`.
     * * `options.rem` is ignored if `options.add` is not given.
     *
     * Both `options.add` and `options.rem` must be encoded as big-endian sequences
     * if given as an `ArrayBuffer`, `SharedArrayBuffer`, `TypedArray`, `Buffer`, or `DataView`.
     *
     * By default, the prime is encoded as a big-endian sequence of octets
     * in an [ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer). If the `bigint` option is `true`, then a
     * [bigint](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt) is provided.
     * @since v15.8.0
     * @param size The size (in bits) of the prime to generate.
     */
    function generatePrime(size: number, callback: (err: Error | null, prime: ArrayBuffer) => void): void;
    function generatePrime(
        size: number,
        options: GeneratePrimeOptionsBigInt,
        callback: (err: Error | null, prime: bigint) => void,
    ): void;
    function generatePrime(
        size: number,
        options: GeneratePrimeOptionsArrayBuffer,
        callback: (err: Error | null, prime: ArrayBuffer) => void,
    ): void;
    function generatePrime(
        size: number,
        options: GeneratePrimeOptions,
        callback: (err: Error | null, prime: ArrayBuffer | bigint) => void,
    ): void;
    /**
     * Generates a pseudorandom prime of `size` bits.
     *
     * If `options.safe` is `true`, the prime will be a safe prime -- that is, `(prime - 1) / 2` will also be a prime.
     *
     * The `options.add` and `options.rem` parameters can be used to enforce additional
     * requirements, e.g., for Diffie-Hellman:
     *
     * * If `options.add` and `options.rem` are both set, the prime will satisfy the
     * condition that `prime % add = rem`.
     * * If only `options.add` is set and `options.safe` is not `true`, the prime will
     * satisfy the condition that `prime % add = 1`.
     * * If only `options.add` is set and `options.safe` is set to `true`, the prime
     * will instead satisfy the condition that `prime % add = 3`. This is necessary
     * because `prime % add = 1` for `options.add > 2` would contradict the condition
     * enforced by `options.safe`.
     * * `options.rem` is ignored if `options.add` is not given.
     *
     * Both `options.add` and `options.rem` must be encoded as big-endian sequences
     * if given as an `ArrayBuffer`, `SharedArrayBuffer`, `TypedArray`, `Buffer`, or `DataView`.
     *
     * By default, the prime is encoded as a big-endian sequence of octets
     * in an [ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer). If the `bigint` option is `true`, then a
     * [bigint](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt) is provided.
     * @since v15.8.0
     * @param size The size (in bits) of the prime to generate.
     */
    function generatePrimeSync(size: number): ArrayBuffer;
    function generatePrimeSync(size: number, options: GeneratePrimeOptionsBigInt): bigint;
    function generatePrimeSync(size: number, options: GeneratePrimeOptionsArrayBuffer): ArrayBuffer;
    function generatePrimeSync(size: number, options: GeneratePrimeOptions): ArrayBuffer | bigint;
    interface CheckPrimeOptions {
        /**
         * The number of Miller-Rabin probabilistic primality iterations to perform.
         * When the value is 0 (zero), a number of checks is used that yields a false positive rate of at most `2**-64` for random input.
         * Care must be used when selecting a number of checks.
         * Refer to the OpenSSL documentation for the BN_is_prime_ex function nchecks options for more details.
         *
         * @default 0
         */
        checks?: number | undefined;
    }
    /**
     * Checks the primality of the `candidate`.
     * @since v15.8.0
     * @param candidate A possible prime encoded as a sequence of big endian octets of arbitrary length.
     */
    function checkPrime(value: LargeNumberLike, callback: (err: Error | null, result: boolean) => void): void;
    function checkPrime(
        value: LargeNumberLike,
        options: CheckPrimeOptions,
        callback: (err: Error | null, result: boolean) => void,
    ): void;
    /**
     * Checks the primality of the `candidate`.
     * @since v15.8.0
     * @param candidate A possible prime encoded as a sequence of big endian octets of arbitrary length.
     * @return `true` if the candidate is a prime with an error probability less than `0.25 ** options.checks`.
     */
    function checkPrimeSync(candidate: LargeNumberLike, options?: CheckPrimeOptions): boolean;
    /**
     * Load and set the `engine` for some or all OpenSSL functions (selected by flags).
     *
     * `engine` could be either an id or a path to the engine's shared library.
     *
     * The optional `flags` argument uses `ENGINE_METHOD_ALL` by default. The `flags` is a bit field taking one of or a mix of the following flags (defined in `crypto.constants`):
     *
     * * `crypto.constants.ENGINE_METHOD_RSA`
     * * `crypto.constants.ENGINE_METHOD_DSA`
     * * `crypto.constants.ENGINE_METHOD_DH`
     * * `crypto.constants.ENGINE_METHOD_RAND`
     * * `crypto.constants.ENGINE_METHOD_EC`
     * * `crypto.constants.ENGINE_METHOD_CIPHERS`
     * * `crypto.constants.ENGINE_METHOD_DIGESTS`
     * * `crypto.constants.ENGINE_METHOD_PKEY_METHS`
     * * `crypto.constants.ENGINE_METHOD_PKEY_ASN1_METHS`
     * * `crypto.constants.ENGINE_METHOD_ALL`
     * * `crypto.constants.ENGINE_METHOD_NONE`
     * @since v0.11.11
     * @param flags
     */
    function setEngine(engine: string, flags?: number): void;
    /**
     * A convenient alias for {@link webcrypto.getRandomValues}. This
     * implementation is not compliant with the Web Crypto spec, to write
     * web-compatible code use {@link webcrypto.getRandomValues} instead.
     * @since v17.4.0
     * @return Returns `typedArray`.
     */
    function getRandomValues<T extends webcrypto.BufferSource>(typedArray: T): T;
    /**
     * A convenient alias for `crypto.webcrypto.subtle`.
     * @since v17.4.0
     */
    const subtle: webcrypto.SubtleCrypto;
    /**
     * An implementation of the Web Crypto API standard.
     *
     * See the {@link https://nodejs.org/docs/latest/api/webcrypto.html Web Crypto API documentation} for details.
     * @since v15.0.0
     */
    const webcrypto: webcrypto.Crypto;
    namespace webcrypto {
        type BufferSource = ArrayBufferView | ArrayBuffer;
        type KeyFormat = "jwk" | "pkcs8" | "raw" | "spki";
        type KeyType = "private" | "public" | "secret";
        type KeyUsage =
            | "decrypt"
            | "deriveBits"
            | "deriveKey"
            | "encrypt"
            | "sign"
            | "unwrapKey"
            | "verify"
            | "wrapKey";
        type AlgorithmIdentifier = Algorithm | string;
        type HashAlgorithmIdentifier = AlgorithmIdentifier;
        type NamedCurve = string;
        type BigInteger = Uint8Array;
        interface AesCbcParams extends Algorithm {
            iv: BufferSource;
        }
        interface AesCtrParams extends Algorithm {
            counter: BufferSource;
            length: number;
        }
        interface AesDerivedKeyParams extends Algorithm {
            length: number;
        }
        interface AesGcmParams extends Algorithm {
            additionalData?: BufferSource;
            iv: BufferSource;
            tagLength?: number;
        }
        interface AesKeyAlgorithm extends KeyAlgorithm {
            length: number;
        }
        interface AesKeyGenParams extends Algorithm {
            length: number;
        }
        interface Algorithm {
            name: string;
        }
        interface EcKeyAlgorithm extends KeyAlgorithm {
            namedCurve: NamedCurve;
        }
        interface EcKeyGenParams extends Algorithm {
            namedCurve: NamedCurve;
        }
        interface EcKeyImportParams extends Algorithm {
            namedCurve: NamedCurve;
        }
        interface EcdhKeyDeriveParams extends Algorithm {
            public: CryptoKey;
        }
        interface EcdsaParams extends Algorithm {
            hash: HashAlgorithmIdentifier;
        }
        interface Ed448Params extends Algorithm {
            context?: BufferSource;
        }
        interface HkdfParams extends Algorithm {
            hash: HashAlgorithmIdentifier;
            info: BufferSource;
            salt: BufferSource;
        }
        interface HmacImportParams extends Algorithm {
            hash: HashAlgorithmIdentifier;
            length?: number;
        }
        interface HmacKeyAlgorithm extends KeyAlgorithm {
            hash: KeyAlgorithm;
            length: number;
        }
        interface HmacKeyGenParams extends Algorithm {
            hash: HashAlgorithmIdentifier;
            length?: number;
        }
        interface JsonWebKey {
            alg?: string;
            crv?: string;
            d?: string;
            dp?: string;
            dq?: string;
            e?: string;
            ext?: boolean;
            k?: string;
            key_ops?: string[];
            kty?: string;
            n?: string;
            oth?: RsaOtherPrimesInfo[];
            p?: string;
            q?: string;
            qi?: string;
            use?: string;
            x?: string;
            y?: string;
        }
        interface KeyAlgorithm {
            name: string;
        }
        interface Pbkdf2Params extends Algorithm {
            hash: HashAlgorithmIdentifier;
            iterations: number;
            salt: BufferSource;
        }
        interface RsaHashedImportParams extends Algorithm {
            hash: HashAlgorithmIdentifier;
        }
        interface RsaHashedKeyAlgorithm extends RsaKeyAlgorithm {
            hash: KeyAlgorithm;
        }
        interface RsaHashedKeyGenParams extends RsaKeyGenParams {
            hash: HashAlgorithmIdentifier;
        }
        interface RsaKeyAlgorithm extends KeyAlgorithm {
            modulusLength: number;
            publicExponent: BigInteger;
        }
        interface RsaKeyGenParams extends Algorithm {
            modulusLength: number;
            publicExponent: BigInteger;
        }
        interface RsaOaepParams extends Algorithm {
            label?: BufferSource;
        }
        interface RsaOtherPrimesInfo {
            d?: string;
            r?: string;
            t?: string;
        }
        interface RsaPssParams extends Algorithm {
            saltLength: number;
        }
        /**
         * Importing the `webcrypto` object (`import { webcrypto } from 'node:crypto'`) gives an instance of the `Crypto` class.
         * `Crypto` is a singleton that provides access to the remainder of the crypto API.
         * @since v15.0.0
         */
        interface Crypto {
            /**
             * Provides access to the `SubtleCrypto` API.
             * @since v15.0.0
             */
            readonly subtle: SubtleCrypto;
            /**
             * Generates cryptographically strong random values.
             * The given `typedArray` is filled with random values, and a reference to `typedArray` is returned.
             *
             * The given `typedArray` must be an integer-based instance of {@link NodeJS.TypedArray}, i.e. `Float32Array` and `Float64Array` are not accepted.
             *
             * An error will be thrown if the given `typedArray` is larger than 65,536 bytes.
             * @since v15.0.0
             */
            getRandomValues<T extends Exclude<NodeJS.TypedArray, Float32Array | Float64Array>>(typedArray: T): T;
            /**
             * Generates a random {@link https://www.rfc-editor.org/rfc/rfc4122.txt RFC 4122} version 4 UUID.
             * The UUID is generated using a cryptographic pseudorandom number generator.
             * @since v16.7.0
             */
            randomUUID(): UUID;
            CryptoKey: CryptoKeyConstructor;
        }
        // This constructor throws ILLEGAL_CONSTRUCTOR so it should not be newable.
        interface CryptoKeyConstructor {
            /** Illegal constructor */
            (_: { readonly _: unique symbol }): never; // Allows instanceof to work but not be callable by the user.
            readonly length: 0;
            readonly name: "CryptoKey";
            readonly prototype: CryptoKey;
        }
        /**
         * @since v15.0.0
         */
        interface CryptoKey {
            /**
             * An object detailing the algorithm for which the key can be used along with additional algorithm-specific parameters.
             * @since v15.0.0
             */
            readonly algorithm: KeyAlgorithm;
            /**
             * When `true`, the {@link CryptoKey} can be extracted using either `subtleCrypto.exportKey()` or `subtleCrypto.wrapKey()`.
             * @since v15.0.0
             */
            readonly extractable: boolean;
            /**
             * A string identifying whether the key is a symmetric (`'secret'`) or asymmetric (`'private'` or `'public'`) key.
             * @since v15.0.0
             */
            readonly type: KeyType;
            /**
             * An array of strings identifying the operations for which the key may be used.
             *
             * The possible usages are:
             * - `'encrypt'` - The key may be used to encrypt data.
             * - `'decrypt'` - The key may be used to decrypt data.
             * - `'sign'` - The key may be used to generate digital signatures.
             * - `'verify'` - The key may be used to verify digital signatures.
             * - `'deriveKey'` - The key may be used to derive a new key.
             * - `'deriveBits'` - The key may be used to derive bits.
             * - `'wrapKey'` - The key may be used to wrap another key.
             * - `'unwrapKey'` - The key may be used to unwrap another key.
             *
             * Valid key usages depend on the key algorithm (identified by `cryptokey.algorithm.name`).
             * @since v15.0.0
             */
            readonly usages: KeyUsage[];
        }
        /**
         * The `CryptoKeyPair` is a simple dictionary object with `publicKey` and `privateKey` properties, representing an asymmetric key pair.
         * @since v15.0.0
         */
        interface CryptoKeyPair {
            /**
             * A {@link CryptoKey} whose type will be `'private'`.
             * @since v15.0.0
             */
            privateKey: CryptoKey;
            /**
             * A {@link CryptoKey} whose type will be `'public'`.
             * @since v15.0.0
             */
            publicKey: CryptoKey;
        }
        /**
         * @since v15.0.0
         */
        interface SubtleCrypto {
            /**
             * Using the method and parameters specified in `algorithm` and the keying material provided by `key`,
             * `subtle.decrypt()` attempts to decipher the provided `data`. If successful,
             * the returned promise will be resolved with an `<ArrayBuffer>` containing the plaintext result.
             *
             * The algorithms currently supported include:
             *
             * - `'RSA-OAEP'`
             * - `'AES-CTR'`
             * - `'AES-CBC'`
             * - `'AES-GCM'`
             * @since v15.0.0
             */
            decrypt(
                algorithm: AlgorithmIdentifier | RsaOaepParams | AesCtrParams | AesCbcParams | AesGcmParams,
                key: CryptoKey,
                data: BufferSource,
            ): Promise<ArrayBuffer>;
            /**
             * Using the method and parameters specified in `algorithm` and the keying material provided by `baseKey`,
             * `subtle.deriveBits()` attempts to generate `length` bits.
             * The Node.js implementation requires that when `length` is a number it must be multiple of `8`.
             * When `length` is `null` the maximum number of bits for a given algorithm is generated. This is allowed
             * for the `'ECDH'`, `'X25519'`, and `'X448'` algorithms.
             * If successful, the returned promise will be resolved with an `<ArrayBuffer>` containing the generated data.
             *
             * The algorithms currently supported include:
             *
             * - `'ECDH'`
             * - `'X25519'`
             * - `'X448'`
             * - `'HKDF'`
             * - `'PBKDF2'`
             * @since v15.0.0
             */
            deriveBits(
                algorithm: EcdhKeyDeriveParams,
                baseKey: CryptoKey,
                length?: number | null,
            ): Promise<ArrayBuffer>;
            deriveBits(
                algorithm: EcdhKeyDeriveParams | HkdfParams | Pbkdf2Params,
                baseKey: CryptoKey,
                length: number,
            ): Promise<ArrayBuffer>;
            /**
             * Using the method and parameters specified in `algorithm`, and the keying material provided by `baseKey`,
             * `subtle.deriveKey()` attempts to generate a new <CryptoKey>` based on the method and parameters in `derivedKeyAlgorithm`.
             *
             * Calling `subtle.deriveKey()` is equivalent to calling `subtle.deriveBits()` to generate raw keying material,
             * then passing the result into the `subtle.importKey()` method using the `deriveKeyAlgorithm`, `extractable`, and `keyUsages` parameters as input.
             *
             * The algorithms currently supported include:
             *
             * - `'ECDH'`
             * - `'X25519'`
             * - `'X448'`
             * - `'HKDF'`
             * - `'PBKDF2'`
             * @param keyUsages See {@link https://nodejs.org/docs/latest/api/webcrypto.html#cryptokeyusages Key usages}.
             * @since v15.0.0
             */
            deriveKey(
                algorithm: EcdhKeyDeriveParams | HkdfParams | Pbkdf2Params,
                baseKey: CryptoKey,
                derivedKeyAlgorithm: AlgorithmIdentifier | HmacImportParams | AesDerivedKeyParams,
                extractable: boolean,
                keyUsages: readonly KeyUsage[],
            ): Promise<CryptoKey>;
            /**
             * Using the method identified by `algorithm`, `subtle.digest()` attempts to generate a digest of `data`.
             * If successful, the returned promise is resolved with an `<ArrayBuffer>` containing the computed digest.
             *
             * If `algorithm` is provided as a `<string>`, it must be one of:
             *
             * - `'SHA-1'`
             * - `'SHA-256'`
             * - `'SHA-384'`
             * - `'SHA-512'`
             *
             * If `algorithm` is provided as an `<Object>`, it must have a `name` property whose value is one of the above.
             * @since v15.0.0
             */
            digest(algorithm: AlgorithmIdentifier, data: BufferSource): Promise<ArrayBuffer>;
            /**
             * Using the method and parameters specified by `algorithm` and the keying material provided by `key`,
             * `subtle.encrypt()` attempts to encipher `data`. If successful,
             * the returned promise is resolved with an `<ArrayBuffer>` containing the encrypted result.
             *
             * The algorithms currently supported include:
             *
             * - `'RSA-OAEP'`
             * - `'AES-CTR'`
             * - `'AES-CBC'`
             * - `'AES-GCM'`
             * @since v15.0.0
             */
            encrypt(
                algorithm: AlgorithmIdentifier | RsaOaepParams | AesCtrParams | AesCbcParams | AesGcmParams,
                key: CryptoKey,
                data: BufferSource,
            ): Promise<ArrayBuffer>;
            /**
             * Exports the given key into the specified format, if supported.
             *
             * If the `<CryptoKey>` is not extractable, the returned promise will reject.
             *
             * When `format` is either `'pkcs8'` or `'spki'` and the export is successful,
             * the returned promise will be resolved with an `<ArrayBuffer>` containing the exported key data.
             *
             * When `format` is `'jwk'` and the export is successful, the returned promise will be resolved with a
             * JavaScript object conforming to the {@link https://tools.ietf.org/html/rfc7517 JSON Web Key} specification.
             * @param format Must be one of `'raw'`, `'pkcs8'`, `'spki'`, or `'jwk'`.
             * @returns `<Promise>` containing `<ArrayBuffer>`.
             * @since v15.0.0
             */
            exportKey(format: "jwk", key: CryptoKey): Promise<JsonWebKey>;
            exportKey(format: Exclude<KeyFormat, "jwk">, key: CryptoKey): Promise<ArrayBuffer>;
            /**
             * Using the method and parameters provided in `algorithm`,
             * `subtle.generateKey()` attempts to generate new keying material.
             * Depending the method used, the method may generate either a single `<CryptoKey>` or a `<CryptoKeyPair>`.
             *
             * The `<CryptoKeyPair>` (public and private key) generating algorithms supported include:
             *
             * - `'RSASSA-PKCS1-v1_5'`
             * - `'RSA-PSS'`
             * - `'RSA-OAEP'`
             * - `'ECDSA'`
             * - `'Ed25519'`
             * - `'Ed448'`
             * - `'ECDH'`
             * - `'X25519'`
             * - `'X448'`
             * The `<CryptoKey>` (secret key) generating algorithms supported include:
             *
             * - `'HMAC'`
             * - `'AES-CTR'`
             * - `'AES-CBC'`
             * - `'AES-GCM'`
             * - `'AES-KW'`
             * @param keyUsages See {@link https://nodejs.org/docs/latest/api/webcrypto.html#cryptokeyusages Key usages}.
             * @since v15.0.0
             */
            generateKey(
                algorithm: RsaHashedKeyGenParams | EcKeyGenParams,
                extractable: boolean,
                keyUsages: readonly KeyUsage[],
            ): Promise<CryptoKeyPair>;
            generateKey(
                algorithm: AesKeyGenParams | HmacKeyGenParams | Pbkdf2Params,
                extractable: boolean,
                keyUsages: readonly KeyUsage[],
            ): Promise<CryptoKey>;
            generateKey(
                algorithm: AlgorithmIdentifier,
                extractable: boolean,
                keyUsages: KeyUsage[],
            ): Promise<CryptoKeyPair | CryptoKey>;
            /**
             * The `subtle.importKey()` method attempts to interpret the provided `keyData` as the given `format`
             * to create a `<CryptoKey>` instance using the provided `algorithm`, `extractable`, and `keyUsages` arguments.
             * If the import is successful, the returned promise will be resolved with the created `<CryptoKey>`.
             *
             * If importing a `'PBKDF2'` key, `extractable` must be `false`.
             * @param format Must be one of `'raw'`, `'pkcs8'`, `'spki'`, or `'jwk'`.
             * @param keyUsages See {@link https://nodejs.org/docs/latest/api/webcrypto.html#cryptokeyusages Key usages}.
             * @since v15.0.0
             */
            importKey(
                format: "jwk",
                keyData: JsonWebKey,
                algorithm:
                    | AlgorithmIdentifier
                    | RsaHashedImportParams
                    | EcKeyImportParams
                    | HmacImportParams
                    | AesKeyAlgorithm,
                extractable: boolean,
                keyUsages: readonly KeyUsage[],
            ): Promise<CryptoKey>;
            importKey(
                format: Exclude<KeyFormat, "jwk">,
                keyData: BufferSource,
                algorithm:
                    | AlgorithmIdentifier
                    | RsaHashedImportParams
                    | EcKeyImportParams
                    | HmacImportParams
                    | AesKeyAlgorithm,
                extractable: boolean,
                keyUsages: KeyUsage[],
            ): Promise<CryptoKey>;
            /**
             * Using the method and parameters given by `algorithm` and the keying material provided by `key`,
             * `subtle.sign()` attempts to generate a cryptographic signature of `data`. If successful,
             * the returned promise is resolved with an `<ArrayBuffer>` containing the generated signature.
             *
             * The algorithms currently supported include:
             *
             * - `'RSASSA-PKCS1-v1_5'`
             * - `'RSA-PSS'`
             * - `'ECDSA'`
             * - `'Ed25519'`
             * - `'Ed448'`
             * - `'HMAC'`
             * @since v15.0.0
             */
            sign(
                algorithm: AlgorithmIdentifier | RsaPssParams | EcdsaParams | Ed448Params,
                key: CryptoKey,
                data: BufferSource,
            ): Promise<ArrayBuffer>;
            /**
             * In cryptography, "wrapping a key" refers to exporting and then encrypting the keying material.
             * The `subtle.unwrapKey()` method attempts to decrypt a wrapped key and create a `<CryptoKey>` instance.
             * It is equivalent to calling `subtle.decrypt()` first on the encrypted key data (using the `wrappedKey`, `unwrapAlgo`, and `unwrappingKey` arguments as input)
             * then passing the results in to the `subtle.importKey()` method using the `unwrappedKeyAlgo`, `extractable`, and `keyUsages` arguments as inputs.
             * If successful, the returned promise is resolved with a `<CryptoKey>` object.
             *
             * The wrapping algorithms currently supported include:
             *
             * - `'RSA-OAEP'`
             * - `'AES-CTR'`
             * - `'AES-CBC'`
             * - `'AES-GCM'`
             * - `'AES-KW'`
             *
             * The unwrapped key algorithms supported include:
             *
             * - `'RSASSA-PKCS1-v1_5'`
             * - `'RSA-PSS'`
             * - `'RSA-OAEP'`
             * - `'ECDSA'`
             * - `'Ed25519'`
             * - `'Ed448'`
             * - `'ECDH'`
             * - `'X25519'`
             * - `'X448'`
             * - `'HMAC'`
             * - `'AES-CTR'`
             * - `'AES-CBC'`
             * - `'AES-GCM'`
             * - `'AES-KW'`
             * @param format Must be one of `'raw'`, `'pkcs8'`, `'spki'`, or `'jwk'`.
             * @param keyUsages See {@link https://nodejs.org/docs/latest/api/webcrypto.html#cryptokeyusages Key usages}.
             * @since v15.0.0
             */
            unwrapKey(
                format: KeyFormat,
                wrappedKey: BufferSource,
                unwrappingKey: CryptoKey,
                unwrapAlgorithm: AlgorithmIdentifier | RsaOaepParams | AesCtrParams | AesCbcParams | AesGcmParams,
                unwrappedKeyAlgorithm:
                    | AlgorithmIdentifier
                    | RsaHashedImportParams
                    | EcKeyImportParams
                    | HmacImportParams
                    | AesKeyAlgorithm,
                extractable: boolean,
                keyUsages: KeyUsage[],
            ): Promise<CryptoKey>;
            /**
             * Using the method and parameters given in `algorithm` and the keying material provided by `key`,
             * `subtle.verify()` attempts to verify that `signature` is a valid cryptographic signature of `data`.
             * The returned promise is resolved with either `true` or `false`.
             *
             * The algorithms currently supported include:
             *
             * - `'RSASSA-PKCS1-v1_5'`
             * - `'RSA-PSS'`
             * - `'ECDSA'`
             * - `'Ed25519'`
             * - `'Ed448'`
             * - `'HMAC'`
             * @since v15.0.0
             */
            verify(
                algorithm: AlgorithmIdentifier | RsaPssParams | EcdsaParams | Ed448Params,
                key: CryptoKey,
                signature: BufferSource,
                data: BufferSource,
            ): Promise<boolean>;
            /**
             * In cryptography, "wrapping a key" refers to exporting and then encrypting the keying material.
             * The `subtle.wrapKey()` method exports the keying material into the format identified by `format`,
             * then encrypts it using the method and parameters specified by `wrapAlgo` and the keying material provided by `wrappingKey`.
             * It is the equivalent to calling `subtle.exportKey()` using `format` and `key` as the arguments,
             * then passing the result to the `subtle.encrypt()` method using `wrappingKey` and `wrapAlgo` as inputs.
             * If successful, the returned promise will be resolved with an `<ArrayBuffer>` containing the encrypted key data.
             *
             * The wrapping algorithms currently supported include:
             *
             * - `'RSA-OAEP'`
             * - `'AES-CTR'`
             * - `'AES-CBC'`
             * - `'AES-GCM'`
             * - `'AES-KW'`
             * @param format Must be one of `'raw'`, `'pkcs8'`, `'spki'`, or `'jwk'`.
             * @since v15.0.0
             */
            wrapKey(
                format: KeyFormat,
                key: CryptoKey,
                wrappingKey: CryptoKey,
                wrapAlgorithm: AlgorithmIdentifier | RsaOaepParams | AesCtrParams | AesCbcParams | AesGcmParams,
            ): Promise<ArrayBuffer>;
        }
    }

    global {
        var crypto: typeof globalThis extends {
            crypto: infer T;
            onmessage: any;
        } ? T
            : webcrypto.Crypto;
    }
}
declare module "node:crypto" {
    export * from "crypto";
}

```

## ./lib/lambda/node_modules/@types/node/dgram.d.ts

```typescript
/**
 * The `node:dgram` module provides an implementation of UDP datagram sockets.
 *
 * ```js
 * import dgram from 'node:dgram';
 *
 * const server = dgram.createSocket('udp4');
 *
 * server.on('error', (err) => {
 *   console.error(`server error:\n${err.stack}`);
 *   server.close();
 * });
 *
 * server.on('message', (msg, rinfo) => {
 *   console.log(`server got: ${msg} from ${rinfo.address}:${rinfo.port}`);
 * });
 *
 * server.on('listening', () => {
 *   const address = server.address();
 *   console.log(`server listening ${address.address}:${address.port}`);
 * });
 *
 * server.bind(41234);
 * // Prints: server listening 0.0.0.0:41234
 * ```
 * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/dgram.js)
 */
declare module "dgram" {
    import { AddressInfo, BlockList } from "node:net";
    import * as dns from "node:dns";
    import { Abortable, EventEmitter } from "node:events";
    interface RemoteInfo {
        address: string;
        family: "IPv4" | "IPv6";
        port: number;
        size: number;
    }
    interface BindOptions {
        port?: number | undefined;
        address?: string | undefined;
        exclusive?: boolean | undefined;
        fd?: number | undefined;
    }
    type SocketType = "udp4" | "udp6";
    interface SocketOptions extends Abortable {
        type: SocketType;
        reuseAddr?: boolean | undefined;
        reusePort?: boolean | undefined;
        /**
         * @default false
         */
        ipv6Only?: boolean | undefined;
        recvBufferSize?: number | undefined;
        sendBufferSize?: number | undefined;
        lookup?:
            | ((
                hostname: string,
                options: dns.LookupOneOptions,
                callback: (err: NodeJS.ErrnoException | null, address: string, family: number) => void,
            ) => void)
            | undefined;
        receiveBlockList?: BlockList | undefined;
        sendBlockList?: BlockList | undefined;
    }
    /**
     * Creates a `dgram.Socket` object. Once the socket is created, calling `socket.bind()` will instruct the socket to begin listening for datagram
     * messages. When `address` and `port` are not passed to `socket.bind()` the
     * method will bind the socket to the "all interfaces" address on a random port
     * (it does the right thing for both `udp4` and `udp6` sockets). The bound address
     * and port can be retrieved using `socket.address().address` and `socket.address().port`.
     *
     * If the `signal` option is enabled, calling `.abort()` on the corresponding `AbortController` is similar to calling `.close()` on the socket:
     *
     * ```js
     * const controller = new AbortController();
     * const { signal } = controller;
     * const server = dgram.createSocket({ type: 'udp4', signal });
     * server.on('message', (msg, rinfo) => {
     *   console.log(`server got: ${msg} from ${rinfo.address}:${rinfo.port}`);
     * });
     * // Later, when you want to close the server.
     * controller.abort();
     * ```
     * @since v0.11.13
     * @param options Available options are:
     * @param callback Attached as a listener for `'message'` events. Optional.
     */
    function createSocket(type: SocketType, callback?: (msg: Buffer, rinfo: RemoteInfo) => void): Socket;
    function createSocket(options: SocketOptions, callback?: (msg: Buffer, rinfo: RemoteInfo) => void): Socket;
    /**
     * Encapsulates the datagram functionality.
     *
     * New instances of `dgram.Socket` are created using {@link createSocket}.
     * The `new` keyword is not to be used to create `dgram.Socket` instances.
     * @since v0.1.99
     */
    class Socket extends EventEmitter {
        /**
         * Tells the kernel to join a multicast group at the given `multicastAddress` and `multicastInterface` using the `IP_ADD_MEMBERSHIP` socket option. If the `multicastInterface` argument is not
         * specified, the operating system will choose
         * one interface and will add membership to it. To add membership to every
         * available interface, call `addMembership` multiple times, once per interface.
         *
         * When called on an unbound socket, this method will implicitly bind to a random
         * port, listening on all interfaces.
         *
         * When sharing a UDP socket across multiple `cluster` workers, the`socket.addMembership()` function must be called only once or an`EADDRINUSE` error will occur:
         *
         * ```js
         * import cluster from 'node:cluster';
         * import dgram from 'node:dgram';
         *
         * if (cluster.isPrimary) {
         *   cluster.fork(); // Works ok.
         *   cluster.fork(); // Fails with EADDRINUSE.
         * } else {
         *   const s = dgram.createSocket('udp4');
         *   s.bind(1234, () => {
         *     s.addMembership('224.0.0.114');
         *   });
         * }
         * ```
         * @since v0.6.9
         */
        addMembership(multicastAddress: string, multicastInterface?: string): void;
        /**
         * Returns an object containing the address information for a socket.
         * For UDP sockets, this object will contain `address`, `family`, and `port` properties.
         *
         * This method throws `EBADF` if called on an unbound socket.
         * @since v0.1.99
         */
        address(): AddressInfo;
        /**
         * For UDP sockets, causes the `dgram.Socket` to listen for datagram
         * messages on a named `port` and optional `address`. If `port` is not
         * specified or is `0`, the operating system will attempt to bind to a
         * random port. If `address` is not specified, the operating system will
         * attempt to listen on all addresses. Once binding is complete, a `'listening'` event is emitted and the optional `callback` function is
         * called.
         *
         * Specifying both a `'listening'` event listener and passing a `callback` to the `socket.bind()` method is not harmful but not very
         * useful.
         *
         * A bound datagram socket keeps the Node.js process running to receive
         * datagram messages.
         *
         * If binding fails, an `'error'` event is generated. In rare case (e.g.
         * attempting to bind with a closed socket), an `Error` may be thrown.
         *
         * Example of a UDP server listening on port 41234:
         *
         * ```js
         * import dgram from 'node:dgram';
         *
         * const server = dgram.createSocket('udp4');
         *
         * server.on('error', (err) => {
         *   console.error(`server error:\n${err.stack}`);
         *   server.close();
         * });
         *
         * server.on('message', (msg, rinfo) => {
         *   console.log(`server got: ${msg} from ${rinfo.address}:${rinfo.port}`);
         * });
         *
         * server.on('listening', () => {
         *   const address = server.address();
         *   console.log(`server listening ${address.address}:${address.port}`);
         * });
         *
         * server.bind(41234);
         * // Prints: server listening 0.0.0.0:41234
         * ```
         * @since v0.1.99
         * @param callback with no parameters. Called when binding is complete.
         */
        bind(port?: number, address?: string, callback?: () => void): this;
        bind(port?: number, callback?: () => void): this;
        bind(callback?: () => void): this;
        bind(options: BindOptions, callback?: () => void): this;
        /**
         * Close the underlying socket and stop listening for data on it. If a callback is
         * provided, it is added as a listener for the `'close'` event.
         * @since v0.1.99
         * @param callback Called when the socket has been closed.
         */
        close(callback?: () => void): this;
        /**
         * Associates the `dgram.Socket` to a remote address and port. Every
         * message sent by this handle is automatically sent to that destination. Also,
         * the socket will only receive messages from that remote peer.
         * Trying to call `connect()` on an already connected socket will result
         * in an `ERR_SOCKET_DGRAM_IS_CONNECTED` exception. If `address` is not
         * provided, `'127.0.0.1'` (for `udp4` sockets) or `'::1'` (for `udp6` sockets)
         * will be used by default. Once the connection is complete, a `'connect'` event
         * is emitted and the optional `callback` function is called. In case of failure,
         * the `callback` is called or, failing this, an `'error'` event is emitted.
         * @since v12.0.0
         * @param callback Called when the connection is completed or on error.
         */
        connect(port: number, address?: string, callback?: () => void): void;
        connect(port: number, callback: () => void): void;
        /**
         * A synchronous function that disassociates a connected `dgram.Socket` from
         * its remote address. Trying to call `disconnect()` on an unbound or already
         * disconnected socket will result in an `ERR_SOCKET_DGRAM_NOT_CONNECTED` exception.
         * @since v12.0.0
         */
        disconnect(): void;
        /**
         * Instructs the kernel to leave a multicast group at `multicastAddress` using the `IP_DROP_MEMBERSHIP` socket option. This method is automatically called by the
         * kernel when the socket is closed or the process terminates, so most apps will
         * never have reason to call this.
         *
         * If `multicastInterface` is not specified, the operating system will attempt to
         * drop membership on all valid interfaces.
         * @since v0.6.9
         */
        dropMembership(multicastAddress: string, multicastInterface?: string): void;
        /**
         * This method throws `ERR_SOCKET_BUFFER_SIZE` if called on an unbound socket.
         * @since v8.7.0
         * @return the `SO_RCVBUF` socket receive buffer size in bytes.
         */
        getRecvBufferSize(): number;
        /**
         * This method throws `ERR_SOCKET_BUFFER_SIZE` if called on an unbound socket.
         * @since v8.7.0
         * @return the `SO_SNDBUF` socket send buffer size in bytes.
         */
        getSendBufferSize(): number;
        /**
         * @since v18.8.0, v16.19.0
         * @return Number of bytes queued for sending.
         */
        getSendQueueSize(): number;
        /**
         * @since v18.8.0, v16.19.0
         * @return Number of send requests currently in the queue awaiting to be processed.
         */
        getSendQueueCount(): number;
        /**
         * By default, binding a socket will cause it to block the Node.js process from
         * exiting as long as the socket is open. The `socket.unref()` method can be used
         * to exclude the socket from the reference counting that keeps the Node.js
         * process active. The `socket.ref()` method adds the socket back to the reference
         * counting and restores the default behavior.
         *
         * Calling `socket.ref()` multiples times will have no additional effect.
         *
         * The `socket.ref()` method returns a reference to the socket so calls can be
         * chained.
         * @since v0.9.1
         */
        ref(): this;
        /**
         * Returns an object containing the `address`, `family`, and `port` of the remote
         * endpoint. This method throws an `ERR_SOCKET_DGRAM_NOT_CONNECTED` exception
         * if the socket is not connected.
         * @since v12.0.0
         */
        remoteAddress(): AddressInfo;
        /**
         * Broadcasts a datagram on the socket.
         * For connectionless sockets, the destination `port` and `address` must be
         * specified. Connected sockets, on the other hand, will use their associated
         * remote endpoint, so the `port` and `address` arguments must not be set.
         *
         * The `msg` argument contains the message to be sent.
         * Depending on its type, different behavior can apply. If `msg` is a `Buffer`,
         * any `TypedArray` or a `DataView`,
         * the `offset` and `length` specify the offset within the `Buffer` where the
         * message begins and the number of bytes in the message, respectively.
         * If `msg` is a `String`, then it is automatically converted to a `Buffer` with `'utf8'` encoding. With messages that
         * contain multi-byte characters, `offset` and `length` will be calculated with
         * respect to `byte length` and not the character position.
         * If `msg` is an array, `offset` and `length` must not be specified.
         *
         * The `address` argument is a string. If the value of `address` is a host name,
         * DNS will be used to resolve the address of the host. If `address` is not
         * provided or otherwise nullish, `'127.0.0.1'` (for `udp4` sockets) or `'::1'` (for `udp6` sockets) will be used by default.
         *
         * If the socket has not been previously bound with a call to `bind`, the socket
         * is assigned a random port number and is bound to the "all interfaces" address
         * (`'0.0.0.0'` for `udp4` sockets, `'::0'` for `udp6` sockets.)
         *
         * An optional `callback` function may be specified to as a way of reporting
         * DNS errors or for determining when it is safe to reuse the `buf` object.
         * DNS lookups delay the time to send for at least one tick of the
         * Node.js event loop.
         *
         * The only way to know for sure that the datagram has been sent is by using a `callback`. If an error occurs and a `callback` is given, the error will be
         * passed as the first argument to the `callback`. If a `callback` is not given,
         * the error is emitted as an `'error'` event on the `socket` object.
         *
         * Offset and length are optional but both _must_ be set if either are used.
         * They are supported only when the first argument is a `Buffer`, a `TypedArray`,
         * or a `DataView`.
         *
         * This method throws `ERR_SOCKET_BAD_PORT` if called on an unbound socket.
         *
         * Example of sending a UDP packet to a port on `localhost`;
         *
         * ```js
         * import dgram from 'node:dgram';
         * import { Buffer } from 'node:buffer';
         *
         * const message = Buffer.from('Some bytes');
         * const client = dgram.createSocket('udp4');
         * client.send(message, 41234, 'localhost', (err) => {
         *   client.close();
         * });
         * ```
         *
         * Example of sending a UDP packet composed of multiple buffers to a port on`127.0.0.1`;
         *
         * ```js
         * import dgram from 'node:dgram';
         * import { Buffer } from 'node:buffer';
         *
         * const buf1 = Buffer.from('Some ');
         * const buf2 = Buffer.from('bytes');
         * const client = dgram.createSocket('udp4');
         * client.send([buf1, buf2], 41234, (err) => {
         *   client.close();
         * });
         * ```
         *
         * Sending multiple buffers might be faster or slower depending on the
         * application and operating system. Run benchmarks to
         * determine the optimal strategy on a case-by-case basis. Generally speaking,
         * however, sending multiple buffers is faster.
         *
         * Example of sending a UDP packet using a socket connected to a port on `localhost`:
         *
         * ```js
         * import dgram from 'node:dgram';
         * import { Buffer } from 'node:buffer';
         *
         * const message = Buffer.from('Some bytes');
         * const client = dgram.createSocket('udp4');
         * client.connect(41234, 'localhost', (err) => {
         *   client.send(message, (err) => {
         *     client.close();
         *   });
         * });
         * ```
         * @since v0.1.99
         * @param msg Message to be sent.
         * @param offset Offset in the buffer where the message starts.
         * @param length Number of bytes in the message.
         * @param port Destination port.
         * @param address Destination host name or IP address.
         * @param callback Called when the message has been sent.
         */
        send(
            msg: string | NodeJS.ArrayBufferView | readonly any[],
            port?: number,
            address?: string,
            callback?: (error: Error | null, bytes: number) => void,
        ): void;
        send(
            msg: string | NodeJS.ArrayBufferView | readonly any[],
            port?: number,
            callback?: (error: Error | null, bytes: number) => void,
        ): void;
        send(
            msg: string | NodeJS.ArrayBufferView | readonly any[],
            callback?: (error: Error | null, bytes: number) => void,
        ): void;
        send(
            msg: string | NodeJS.ArrayBufferView,
            offset: number,
            length: number,
            port?: number,
            address?: string,
            callback?: (error: Error | null, bytes: number) => void,
        ): void;
        send(
            msg: string | NodeJS.ArrayBufferView,
            offset: number,
            length: number,
            port?: number,
            callback?: (error: Error | null, bytes: number) => void,
        ): void;
        send(
            msg: string | NodeJS.ArrayBufferView,
            offset: number,
            length: number,
            callback?: (error: Error | null, bytes: number) => void,
        ): void;
        /**
         * Sets or clears the `SO_BROADCAST` socket option. When set to `true`, UDP
         * packets may be sent to a local interface's broadcast address.
         *
         * This method throws `EBADF` if called on an unbound socket.
         * @since v0.6.9
         */
        setBroadcast(flag: boolean): void;
        /**
         * _All references to scope in this section are referring to [IPv6 Zone Indices](https://en.wikipedia.org/wiki/IPv6_address#Scoped_literal_IPv6_addresses), which are defined by [RFC
         * 4007](https://tools.ietf.org/html/rfc4007). In string form, an IP_
         * _with a scope index is written as `'IP%scope'` where scope is an interface name_
         * _or interface number._
         *
         * Sets the default outgoing multicast interface of the socket to a chosen
         * interface or back to system interface selection. The `multicastInterface` must
         * be a valid string representation of an IP from the socket's family.
         *
         * For IPv4 sockets, this should be the IP configured for the desired physical
         * interface. All packets sent to multicast on the socket will be sent on the
         * interface determined by the most recent successful use of this call.
         *
         * For IPv6 sockets, `multicastInterface` should include a scope to indicate the
         * interface as in the examples that follow. In IPv6, individual `send` calls can
         * also use explicit scope in addresses, so only packets sent to a multicast
         * address without specifying an explicit scope are affected by the most recent
         * successful use of this call.
         *
         * This method throws `EBADF` if called on an unbound socket.
         *
         * #### Example: IPv6 outgoing multicast interface
         *
         * On most systems, where scope format uses the interface name:
         *
         * ```js
         * const socket = dgram.createSocket('udp6');
         *
         * socket.bind(1234, () => {
         *   socket.setMulticastInterface('::%eth1');
         * });
         * ```
         *
         * On Windows, where scope format uses an interface number:
         *
         * ```js
         * const socket = dgram.createSocket('udp6');
         *
         * socket.bind(1234, () => {
         *   socket.setMulticastInterface('::%2');
         * });
         * ```
         *
         * #### Example: IPv4 outgoing multicast interface
         *
         * All systems use an IP of the host on the desired physical interface:
         *
         * ```js
         * const socket = dgram.createSocket('udp4');
         *
         * socket.bind(1234, () => {
         *   socket.setMulticastInterface('10.0.0.2');
         * });
         * ```
         * @since v8.6.0
         */
        setMulticastInterface(multicastInterface: string): void;
        /**
         * Sets or clears the `IP_MULTICAST_LOOP` socket option. When set to `true`,
         * multicast packets will also be received on the local interface.
         *
         * This method throws `EBADF` if called on an unbound socket.
         * @since v0.3.8
         */
        setMulticastLoopback(flag: boolean): boolean;
        /**
         * Sets the `IP_MULTICAST_TTL` socket option. While TTL generally stands for
         * "Time to Live", in this context it specifies the number of IP hops that a
         * packet is allowed to travel through, specifically for multicast traffic. Each
         * router or gateway that forwards a packet decrements the TTL. If the TTL is
         * decremented to 0 by a router, it will not be forwarded.
         *
         * The `ttl` argument may be between 0 and 255\. The default on most systems is `1`.
         *
         * This method throws `EBADF` if called on an unbound socket.
         * @since v0.3.8
         */
        setMulticastTTL(ttl: number): number;
        /**
         * Sets the `SO_RCVBUF` socket option. Sets the maximum socket receive buffer
         * in bytes.
         *
         * This method throws `ERR_SOCKET_BUFFER_SIZE` if called on an unbound socket.
         * @since v8.7.0
         */
        setRecvBufferSize(size: number): void;
        /**
         * Sets the `SO_SNDBUF` socket option. Sets the maximum socket send buffer
         * in bytes.
         *
         * This method throws `ERR_SOCKET_BUFFER_SIZE` if called on an unbound socket.
         * @since v8.7.0
         */
        setSendBufferSize(size: number): void;
        /**
         * Sets the `IP_TTL` socket option. While TTL generally stands for "Time to Live",
         * in this context it specifies the number of IP hops that a packet is allowed to
         * travel through. Each router or gateway that forwards a packet decrements the
         * TTL. If the TTL is decremented to 0 by a router, it will not be forwarded.
         * Changing TTL values is typically done for network probes or when multicasting.
         *
         * The `ttl` argument may be between 1 and 255\. The default on most systems
         * is 64.
         *
         * This method throws `EBADF` if called on an unbound socket.
         * @since v0.1.101
         */
        setTTL(ttl: number): number;
        /**
         * By default, binding a socket will cause it to block the Node.js process from
         * exiting as long as the socket is open. The `socket.unref()` method can be used
         * to exclude the socket from the reference counting that keeps the Node.js
         * process active, allowing the process to exit even if the socket is still
         * listening.
         *
         * Calling `socket.unref()` multiple times will have no additional effect.
         *
         * The `socket.unref()` method returns a reference to the socket so calls can be
         * chained.
         * @since v0.9.1
         */
        unref(): this;
        /**
         * Tells the kernel to join a source-specific multicast channel at the given `sourceAddress` and `groupAddress`, using the `multicastInterface` with the `IP_ADD_SOURCE_MEMBERSHIP` socket
         * option. If the `multicastInterface` argument
         * is not specified, the operating system will choose one interface and will add
         * membership to it. To add membership to every available interface, call `socket.addSourceSpecificMembership()` multiple times, once per interface.
         *
         * When called on an unbound socket, this method will implicitly bind to a random
         * port, listening on all interfaces.
         * @since v13.1.0, v12.16.0
         */
        addSourceSpecificMembership(sourceAddress: string, groupAddress: string, multicastInterface?: string): void;
        /**
         * Instructs the kernel to leave a source-specific multicast channel at the given `sourceAddress` and `groupAddress` using the `IP_DROP_SOURCE_MEMBERSHIP` socket option. This method is
         * automatically called by the kernel when the
         * socket is closed or the process terminates, so most apps will never have
         * reason to call this.
         *
         * If `multicastInterface` is not specified, the operating system will attempt to
         * drop membership on all valid interfaces.
         * @since v13.1.0, v12.16.0
         */
        dropSourceSpecificMembership(sourceAddress: string, groupAddress: string, multicastInterface?: string): void;
        /**
         * events.EventEmitter
         * 1. close
         * 2. connect
         * 3. error
         * 4. listening
         * 5. message
         */
        addListener(event: string, listener: (...args: any[]) => void): this;
        addListener(event: "close", listener: () => void): this;
        addListener(event: "connect", listener: () => void): this;
        addListener(event: "error", listener: (err: Error) => void): this;
        addListener(event: "listening", listener: () => void): this;
        addListener(event: "message", listener: (msg: Buffer, rinfo: RemoteInfo) => void): this;
        emit(event: string | symbol, ...args: any[]): boolean;
        emit(event: "close"): boolean;
        emit(event: "connect"): boolean;
        emit(event: "error", err: Error): boolean;
        emit(event: "listening"): boolean;
        emit(event: "message", msg: Buffer, rinfo: RemoteInfo): boolean;
        on(event: string, listener: (...args: any[]) => void): this;
        on(event: "close", listener: () => void): this;
        on(event: "connect", listener: () => void): this;
        on(event: "error", listener: (err: Error) => void): this;
        on(event: "listening", listener: () => void): this;
        on(event: "message", listener: (msg: Buffer, rinfo: RemoteInfo) => void): this;
        once(event: string, listener: (...args: any[]) => void): this;
        once(event: "close", listener: () => void): this;
        once(event: "connect", listener: () => void): this;
        once(event: "error", listener: (err: Error) => void): this;
        once(event: "listening", listener: () => void): this;
        once(event: "message", listener: (msg: Buffer, rinfo: RemoteInfo) => void): this;
        prependListener(event: string, listener: (...args: any[]) => void): this;
        prependListener(event: "close", listener: () => void): this;
        prependListener(event: "connect", listener: () => void): this;
        prependListener(event: "error", listener: (err: Error) => void): this;
        prependListener(event: "listening", listener: () => void): this;
        prependListener(event: "message", listener: (msg: Buffer, rinfo: RemoteInfo) => void): this;
        prependOnceListener(event: string, listener: (...args: any[]) => void): this;
        prependOnceListener(event: "close", listener: () => void): this;
        prependOnceListener(event: "connect", listener: () => void): this;
        prependOnceListener(event: "error", listener: (err: Error) => void): this;
        prependOnceListener(event: "listening", listener: () => void): this;
        prependOnceListener(event: "message", listener: (msg: Buffer, rinfo: RemoteInfo) => void): this;
        /**
         * Calls `socket.close()` and returns a promise that fulfills when the socket has closed.
         * @since v20.5.0
         */
        [Symbol.asyncDispose](): Promise<void>;
    }
}
declare module "node:dgram" {
    export * from "dgram";
}

```

## ./lib/lambda/node_modules/@types/node/diagnostics_channel.d.ts

```typescript
/**
 * The `node:diagnostics_channel` module provides an API to create named channels
 * to report arbitrary message data for diagnostics purposes.
 *
 * It can be accessed using:
 *
 * ```js
 * import diagnostics_channel from 'node:diagnostics_channel';
 * ```
 *
 * It is intended that a module writer wanting to report diagnostics messages
 * will create one or many top-level channels to report messages through.
 * Channels may also be acquired at runtime but it is not encouraged
 * due to the additional overhead of doing so. Channels may be exported for
 * convenience, but as long as the name is known it can be acquired anywhere.
 *
 * If you intend for your module to produce diagnostics data for others to
 * consume it is recommended that you include documentation of what named
 * channels are used along with the shape of the message data. Channel names
 * should generally include the module name to avoid collisions with data from
 * other modules.
 * @since v15.1.0, v14.17.0
 * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/diagnostics_channel.js)
 */
declare module "diagnostics_channel" {
    import { AsyncLocalStorage } from "node:async_hooks";
    /**
     * Check if there are active subscribers to the named channel. This is helpful if
     * the message you want to send might be expensive to prepare.
     *
     * This API is optional but helpful when trying to publish messages from very
     * performance-sensitive code.
     *
     * ```js
     * import diagnostics_channel from 'node:diagnostics_channel';
     *
     * if (diagnostics_channel.hasSubscribers('my-channel')) {
     *   // There are subscribers, prepare and publish message
     * }
     * ```
     * @since v15.1.0, v14.17.0
     * @param name The channel name
     * @return If there are active subscribers
     */
    function hasSubscribers(name: string | symbol): boolean;
    /**
     * This is the primary entry-point for anyone wanting to publish to a named
     * channel. It produces a channel object which is optimized to reduce overhead at
     * publish time as much as possible.
     *
     * ```js
     * import diagnostics_channel from 'node:diagnostics_channel';
     *
     * const channel = diagnostics_channel.channel('my-channel');
     * ```
     * @since v15.1.0, v14.17.0
     * @param name The channel name
     * @return The named channel object
     */
    function channel(name: string | symbol): Channel;
    type ChannelListener = (message: unknown, name: string | symbol) => void;
    /**
     * Register a message handler to subscribe to this channel. This message handler
     * will be run synchronously whenever a message is published to the channel. Any
     * errors thrown in the message handler will trigger an `'uncaughtException'`.
     *
     * ```js
     * import diagnostics_channel from 'node:diagnostics_channel';
     *
     * diagnostics_channel.subscribe('my-channel', (message, name) => {
     *   // Received data
     * });
     * ```
     * @since v18.7.0, v16.17.0
     * @param name The channel name
     * @param onMessage The handler to receive channel messages
     */
    function subscribe(name: string | symbol, onMessage: ChannelListener): void;
    /**
     * Remove a message handler previously registered to this channel with {@link subscribe}.
     *
     * ```js
     * import diagnostics_channel from 'node:diagnostics_channel';
     *
     * function onMessage(message, name) {
     *   // Received data
     * }
     *
     * diagnostics_channel.subscribe('my-channel', onMessage);
     *
     * diagnostics_channel.unsubscribe('my-channel', onMessage);
     * ```
     * @since v18.7.0, v16.17.0
     * @param name The channel name
     * @param onMessage The previous subscribed handler to remove
     * @return `true` if the handler was found, `false` otherwise.
     */
    function unsubscribe(name: string | symbol, onMessage: ChannelListener): boolean;
    /**
     * Creates a `TracingChannel` wrapper for the given `TracingChannel Channels`. If a name is given, the corresponding tracing
     * channels will be created in the form of `tracing:${name}:${eventType}` where `eventType` corresponds to the types of `TracingChannel Channels`.
     *
     * ```js
     * import diagnostics_channel from 'node:diagnostics_channel';
     *
     * const channelsByName = diagnostics_channel.tracingChannel('my-channel');
     *
     * // or...
     *
     * const channelsByCollection = diagnostics_channel.tracingChannel({
     *   start: diagnostics_channel.channel('tracing:my-channel:start'),
     *   end: diagnostics_channel.channel('tracing:my-channel:end'),
     *   asyncStart: diagnostics_channel.channel('tracing:my-channel:asyncStart'),
     *   asyncEnd: diagnostics_channel.channel('tracing:my-channel:asyncEnd'),
     *   error: diagnostics_channel.channel('tracing:my-channel:error'),
     * });
     * ```
     * @since v19.9.0
     * @experimental
     * @param nameOrChannels Channel name or object containing all the `TracingChannel Channels`
     * @return Collection of channels to trace with
     */
    function tracingChannel<
        StoreType = unknown,
        ContextType extends object = StoreType extends object ? StoreType : object,
    >(
        nameOrChannels: string | TracingChannelCollection<StoreType, ContextType>,
    ): TracingChannel<StoreType, ContextType>;
    /**
     * The class `Channel` represents an individual named channel within the data
     * pipeline. It is used to track subscribers and to publish messages when there
     * are subscribers present. It exists as a separate object to avoid channel
     * lookups at publish time, enabling very fast publish speeds and allowing
     * for heavy use while incurring very minimal cost. Channels are created with {@link channel}, constructing a channel directly
     * with `new Channel(name)` is not supported.
     * @since v15.1.0, v14.17.0
     */
    class Channel<StoreType = unknown, ContextType = StoreType> {
        readonly name: string | symbol;
        /**
         * Check if there are active subscribers to this channel. This is helpful if
         * the message you want to send might be expensive to prepare.
         *
         * This API is optional but helpful when trying to publish messages from very
         * performance-sensitive code.
         *
         * ```js
         * import diagnostics_channel from 'node:diagnostics_channel';
         *
         * const channel = diagnostics_channel.channel('my-channel');
         *
         * if (channel.hasSubscribers) {
         *   // There are subscribers, prepare and publish message
         * }
         * ```
         * @since v15.1.0, v14.17.0
         */
        readonly hasSubscribers: boolean;
        private constructor(name: string | symbol);
        /**
         * Publish a message to any subscribers to the channel. This will trigger
         * message handlers synchronously so they will execute within the same context.
         *
         * ```js
         * import diagnostics_channel from 'node:diagnostics_channel';
         *
         * const channel = diagnostics_channel.channel('my-channel');
         *
         * channel.publish({
         *   some: 'message',
         * });
         * ```
         * @since v15.1.0, v14.17.0
         * @param message The message to send to the channel subscribers
         */
        publish(message: unknown): void;
        /**
         * Register a message handler to subscribe to this channel. This message handler
         * will be run synchronously whenever a message is published to the channel. Any
         * errors thrown in the message handler will trigger an `'uncaughtException'`.
         *
         * ```js
         * import diagnostics_channel from 'node:diagnostics_channel';
         *
         * const channel = diagnostics_channel.channel('my-channel');
         *
         * channel.subscribe((message, name) => {
         *   // Received data
         * });
         * ```
         * @since v15.1.0, v14.17.0
         * @deprecated Since v18.7.0,v16.17.0 - Use {@link subscribe(name, onMessage)}
         * @param onMessage The handler to receive channel messages
         */
        subscribe(onMessage: ChannelListener): void;
        /**
         * Remove a message handler previously registered to this channel with `channel.subscribe(onMessage)`.
         *
         * ```js
         * import diagnostics_channel from 'node:diagnostics_channel';
         *
         * const channel = diagnostics_channel.channel('my-channel');
         *
         * function onMessage(message, name) {
         *   // Received data
         * }
         *
         * channel.subscribe(onMessage);
         *
         * channel.unsubscribe(onMessage);
         * ```
         * @since v15.1.0, v14.17.0
         * @deprecated Since v18.7.0,v16.17.0 - Use {@link unsubscribe(name, onMessage)}
         * @param onMessage The previous subscribed handler to remove
         * @return `true` if the handler was found, `false` otherwise.
         */
        unsubscribe(onMessage: ChannelListener): void;
        /**
         * When `channel.runStores(context, ...)` is called, the given context data
         * will be applied to any store bound to the channel. If the store has already been
         * bound the previous `transform` function will be replaced with the new one.
         * The `transform` function may be omitted to set the given context data as the
         * context directly.
         *
         * ```js
         * import diagnostics_channel from 'node:diagnostics_channel';
         * import { AsyncLocalStorage } from 'node:async_hooks';
         *
         * const store = new AsyncLocalStorage();
         *
         * const channel = diagnostics_channel.channel('my-channel');
         *
         * channel.bindStore(store, (data) => {
         *   return { data };
         * });
         * ```
         * @since v19.9.0
         * @experimental
         * @param store The store to which to bind the context data
         * @param transform Transform context data before setting the store context
         */
        bindStore(store: AsyncLocalStorage<StoreType>, transform?: (context: ContextType) => StoreType): void;
        /**
         * Remove a message handler previously registered to this channel with `channel.bindStore(store)`.
         *
         * ```js
         * import diagnostics_channel from 'node:diagnostics_channel';
         * import { AsyncLocalStorage } from 'node:async_hooks';
         *
         * const store = new AsyncLocalStorage();
         *
         * const channel = diagnostics_channel.channel('my-channel');
         *
         * channel.bindStore(store);
         * channel.unbindStore(store);
         * ```
         * @since v19.9.0
         * @experimental
         * @param store The store to unbind from the channel.
         * @return `true` if the store was found, `false` otherwise.
         */
        unbindStore(store: AsyncLocalStorage<StoreType>): boolean;
        /**
         * Applies the given data to any AsyncLocalStorage instances bound to the channel
         * for the duration of the given function, then publishes to the channel within
         * the scope of that data is applied to the stores.
         *
         * If a transform function was given to `channel.bindStore(store)` it will be
         * applied to transform the message data before it becomes the context value for
         * the store. The prior storage context is accessible from within the transform
         * function in cases where context linking is required.
         *
         * The context applied to the store should be accessible in any async code which
         * continues from execution which began during the given function, however
         * there are some situations in which `context loss` may occur.
         *
         * ```js
         * import diagnostics_channel from 'node:diagnostics_channel';
         * import { AsyncLocalStorage } from 'node:async_hooks';
         *
         * const store = new AsyncLocalStorage();
         *
         * const channel = diagnostics_channel.channel('my-channel');
         *
         * channel.bindStore(store, (message) => {
         *   const parent = store.getStore();
         *   return new Span(message, parent);
         * });
         * channel.runStores({ some: 'message' }, () => {
         *   store.getStore(); // Span({ some: 'message' })
         * });
         * ```
         * @since v19.9.0
         * @experimental
         * @param context Message to send to subscribers and bind to stores
         * @param fn Handler to run within the entered storage context
         * @param thisArg The receiver to be used for the function call.
         * @param args Optional arguments to pass to the function.
         */
        runStores<ThisArg = any, Args extends any[] = any[], Result = any>(
            context: ContextType,
            fn: (this: ThisArg, ...args: Args) => Result,
            thisArg?: ThisArg,
            ...args: Args
        ): Result;
    }
    interface TracingChannelSubscribers<ContextType extends object> {
        start: (message: ContextType) => void;
        end: (
            message: ContextType & {
                error?: unknown;
                result?: unknown;
            },
        ) => void;
        asyncStart: (
            message: ContextType & {
                error?: unknown;
                result?: unknown;
            },
        ) => void;
        asyncEnd: (
            message: ContextType & {
                error?: unknown;
                result?: unknown;
            },
        ) => void;
        error: (
            message: ContextType & {
                error: unknown;
            },
        ) => void;
    }
    interface TracingChannelCollection<StoreType = unknown, ContextType = StoreType> {
        start: Channel<StoreType, ContextType>;
        end: Channel<StoreType, ContextType>;
        asyncStart: Channel<StoreType, ContextType>;
        asyncEnd: Channel<StoreType, ContextType>;
        error: Channel<StoreType, ContextType>;
    }
    /**
     * The class `TracingChannel` is a collection of `TracingChannel Channels` which
     * together express a single traceable action. It is used to formalize and
     * simplify the process of producing events for tracing application flow. {@link tracingChannel} is used to construct a `TracingChannel`. As with `Channel` it is recommended to create and reuse a
     * single `TracingChannel` at the top-level of the file rather than creating them
     * dynamically.
     * @since v19.9.0
     * @experimental
     */
    class TracingChannel<StoreType = unknown, ContextType extends object = {}> implements TracingChannelCollection {
        start: Channel<StoreType, ContextType>;
        end: Channel<StoreType, ContextType>;
        asyncStart: Channel<StoreType, ContextType>;
        asyncEnd: Channel<StoreType, ContextType>;
        error: Channel<StoreType, ContextType>;
        /**
         * Helper to subscribe a collection of functions to the corresponding channels.
         * This is the same as calling `channel.subscribe(onMessage)` on each channel
         * individually.
         *
         * ```js
         * import diagnostics_channel from 'node:diagnostics_channel';
         *
         * const channels = diagnostics_channel.tracingChannel('my-channel');
         *
         * channels.subscribe({
         *   start(message) {
         *     // Handle start message
         *   },
         *   end(message) {
         *     // Handle end message
         *   },
         *   asyncStart(message) {
         *     // Handle asyncStart message
         *   },
         *   asyncEnd(message) {
         *     // Handle asyncEnd message
         *   },
         *   error(message) {
         *     // Handle error message
         *   },
         * });
         * ```
         * @since v19.9.0
         * @experimental
         * @param subscribers Set of `TracingChannel Channels` subscribers
         */
        subscribe(subscribers: TracingChannelSubscribers<ContextType>): void;
        /**
         * Helper to unsubscribe a collection of functions from the corresponding channels.
         * This is the same as calling `channel.unsubscribe(onMessage)` on each channel
         * individually.
         *
         * ```js
         * import diagnostics_channel from 'node:diagnostics_channel';
         *
         * const channels = diagnostics_channel.tracingChannel('my-channel');
         *
         * channels.unsubscribe({
         *   start(message) {
         *     // Handle start message
         *   },
         *   end(message) {
         *     // Handle end message
         *   },
         *   asyncStart(message) {
         *     // Handle asyncStart message
         *   },
         *   asyncEnd(message) {
         *     // Handle asyncEnd message
         *   },
         *   error(message) {
         *     // Handle error message
         *   },
         * });
         * ```
         * @since v19.9.0
         * @experimental
         * @param subscribers Set of `TracingChannel Channels` subscribers
         * @return `true` if all handlers were successfully unsubscribed, and `false` otherwise.
         */
        unsubscribe(subscribers: TracingChannelSubscribers<ContextType>): void;
        /**
         * Trace a synchronous function call. This will always produce a `start event` and `end event` around the execution and may produce an `error event` if the given function throws an error.
         * This will run the given function using `channel.runStores(context, ...)` on the `start` channel which ensures all
         * events should have any bound stores set to match this trace context.
         *
         * To ensure only correct trace graphs are formed, events will only be published if subscribers are present prior to starting the trace. Subscriptions
         * which are added after the trace begins will not receive future events from that trace, only future traces will be seen.
         *
         * ```js
         * import diagnostics_channel from 'node:diagnostics_channel';
         *
         * const channels = diagnostics_channel.tracingChannel('my-channel');
         *
         * channels.traceSync(() => {
         *   // Do something
         * }, {
         *   some: 'thing',
         * });
         * ```
         * @since v19.9.0
         * @experimental
         * @param fn Function to wrap a trace around
         * @param context Shared object to correlate events through
         * @param thisArg The receiver to be used for the function call
         * @param args Optional arguments to pass to the function
         * @return The return value of the given function
         */
        traceSync<ThisArg = any, Args extends any[] = any[], Result = any>(
            fn: (this: ThisArg, ...args: Args) => Result,
            context?: ContextType,
            thisArg?: ThisArg,
            ...args: Args
        ): Result;
        /**
         * Trace a promise-returning function call. This will always produce a `start event` and `end event` around the synchronous portion of the
         * function execution, and will produce an `asyncStart event` and `asyncEnd event` when a promise continuation is reached. It may also
         * produce an `error event` if the given function throws an error or the
         * returned promise rejects. This will run the given function using `channel.runStores(context, ...)` on the `start` channel which ensures all
         * events should have any bound stores set to match this trace context.
         *
         * To ensure only correct trace graphs are formed, events will only be published if subscribers are present prior to starting the trace. Subscriptions
         * which are added after the trace begins will not receive future events from that trace, only future traces will be seen.
         *
         * ```js
         * import diagnostics_channel from 'node:diagnostics_channel';
         *
         * const channels = diagnostics_channel.tracingChannel('my-channel');
         *
         * channels.tracePromise(async () => {
         *   // Do something
         * }, {
         *   some: 'thing',
         * });
         * ```
         * @since v19.9.0
         * @experimental
         * @param fn Promise-returning function to wrap a trace around
         * @param context Shared object to correlate trace events through
         * @param thisArg The receiver to be used for the function call
         * @param args Optional arguments to pass to the function
         * @return Chained from promise returned by the given function
         */
        tracePromise<ThisArg = any, Args extends any[] = any[], Result = any>(
            fn: (this: ThisArg, ...args: Args) => Promise<Result>,
            context?: ContextType,
            thisArg?: ThisArg,
            ...args: Args
        ): Promise<Result>;
        /**
         * Trace a callback-receiving function call. This will always produce a `start event` and `end event` around the synchronous portion of the
         * function execution, and will produce a `asyncStart event` and `asyncEnd event` around the callback execution. It may also produce an `error event` if the given function throws an error or
         * the returned
         * promise rejects. This will run the given function using `channel.runStores(context, ...)` on the `start` channel which ensures all
         * events should have any bound stores set to match this trace context.
         *
         * The `position` will be -1 by default to indicate the final argument should
         * be used as the callback.
         *
         * ```js
         * import diagnostics_channel from 'node:diagnostics_channel';
         *
         * const channels = diagnostics_channel.tracingChannel('my-channel');
         *
         * channels.traceCallback((arg1, callback) => {
         *   // Do something
         *   callback(null, 'result');
         * }, 1, {
         *   some: 'thing',
         * }, thisArg, arg1, callback);
         * ```
         *
         * The callback will also be run with `channel.runStores(context, ...)` which
         * enables context loss recovery in some cases.
         *
         * To ensure only correct trace graphs are formed, events will only be published if subscribers are present prior to starting the trace. Subscriptions
         * which are added after the trace begins will not receive future events from that trace, only future traces will be seen.
         *
         * ```js
         * import diagnostics_channel from 'node:diagnostics_channel';
         * import { AsyncLocalStorage } from 'node:async_hooks';
         *
         * const channels = diagnostics_channel.tracingChannel('my-channel');
         * const myStore = new AsyncLocalStorage();
         *
         * // The start channel sets the initial store data to something
         * // and stores that store data value on the trace context object
         * channels.start.bindStore(myStore, (data) => {
         *   const span = new Span(data);
         *   data.span = span;
         *   return span;
         * });
         *
         * // Then asyncStart can restore from that data it stored previously
         * channels.asyncStart.bindStore(myStore, (data) => {
         *   return data.span;
         * });
         * ```
         * @since v19.9.0
         * @experimental
         * @param fn callback using function to wrap a trace around
         * @param position Zero-indexed argument position of expected callback
         * @param context Shared object to correlate trace events through
         * @param thisArg The receiver to be used for the function call
         * @param args Optional arguments to pass to the function
         * @return The return value of the given function
         */
        traceCallback<ThisArg = any, Args extends any[] = any[], Result = any>(
            fn: (this: ThisArg, ...args: Args) => Result,
            position?: number,
            context?: ContextType,
            thisArg?: ThisArg,
            ...args: Args
        ): Result;
        /**
         * `true` if any of the individual channels has a subscriber, `false` if not.
         *
         * This is a helper method available on a {@link TracingChannel} instance to check
         * if any of the [TracingChannel Channels](https://nodejs.org/api/diagnostics_channel.html#tracingchannel-channels) have subscribers.
         * A `true` is returned if any of them have at least one subscriber, a `false` is returned otherwise.
         *
         * ```js
         * const diagnostics_channel = require('node:diagnostics_channel');
         *
         * const channels = diagnostics_channel.tracingChannel('my-channel');
         *
         * if (channels.hasSubscribers) {
         *   // Do something
         * }
         * ```
         * @since v22.0.0, v20.13.0
         */
        readonly hasSubscribers: boolean;
    }
}
declare module "node:diagnostics_channel" {
    export * from "diagnostics_channel";
}

```

## ./lib/lambda/node_modules/@types/node/dns.d.ts

```typescript
/**
 * The `node:dns` module enables name resolution. For example, use it to look up IP
 * addresses of host names.
 *
 * Although named for the [Domain Name System (DNS)](https://en.wikipedia.org/wiki/Domain_Name_System), it does not always use the
 * DNS protocol for lookups. {@link lookup} uses the operating system
 * facilities to perform name resolution. It may not need to perform any network
 * communication. To perform name resolution the way other applications on the same
 * system do, use {@link lookup}.
 *
 * ```js
 * import dns from 'node:dns';
 *
 * dns.lookup('example.org', (err, address, family) => {
 *   console.log('address: %j family: IPv%s', address, family);
 * });
 * // address: "93.184.216.34" family: IPv4
 * ```
 *
 * All other functions in the `node:dns` module connect to an actual DNS server to
 * perform name resolution. They will always use the network to perform DNS
 * queries. These functions do not use the same set of configuration files used by {@link lookup} (e.g. `/etc/hosts`). Use these functions to always perform
 * DNS queries, bypassing other name-resolution facilities.
 *
 * ```js
 * import dns from 'node:dns';
 *
 * dns.resolve4('archive.org', (err, addresses) => {
 *   if (err) throw err;
 *
 *   console.log(`addresses: ${JSON.stringify(addresses)}`);
 *
 *   addresses.forEach((a) => {
 *     dns.reverse(a, (err, hostnames) => {
 *       if (err) {
 *         throw err;
 *       }
 *       console.log(`reverse for ${a}: ${JSON.stringify(hostnames)}`);
 *     });
 *   });
 * });
 * ```
 *
 * See the [Implementation considerations section](https://nodejs.org/docs/latest-v22.x/api/dns.html#implementation-considerations) for more information.
 * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/dns.js)
 */
declare module "dns" {
    import * as dnsPromises from "node:dns/promises";
    // Supported getaddrinfo flags.
    /**
     * Limits returned address types to the types of non-loopback addresses configured on the system. For example, IPv4 addresses are
     * only returned if the current system has at least one IPv4 address configured.
     */
    export const ADDRCONFIG: number;
    /**
     * If the IPv6 family was specified, but no IPv6 addresses were found, then return IPv4 mapped IPv6 addresses. It is not supported
     * on some operating systems (e.g. FreeBSD 10.1).
     */
    export const V4MAPPED: number;
    /**
     * If `dns.V4MAPPED` is specified, return resolved IPv6 addresses as
     * well as IPv4 mapped IPv6 addresses.
     */
    export const ALL: number;
    export interface LookupOptions {
        /**
         * The record family. Must be `4`, `6`, or `0`. For backward compatibility reasons, `'IPv4'` and `'IPv6'` are interpreted
         * as `4` and `6` respectively. The value 0 indicates that either an IPv4 or IPv6 address is returned. If the value `0` is used
         * with `{ all: true } (see below)`, both IPv4 and IPv6 addresses are returned.
         * @default 0
         */
        family?: number | "IPv4" | "IPv6" | undefined;
        /**
         * One or more [supported `getaddrinfo`](https://nodejs.org/docs/latest-v22.x/api/dns.html#supported-getaddrinfo-flags) flags. Multiple flags may be
         * passed by bitwise `OR`ing their values.
         */
        hints?: number | undefined;
        /**
         * When `true`, the callback returns all resolved addresses in an array. Otherwise, returns a single address.
         * @default false
         */
        all?: boolean | undefined;
        /**
         * When `verbatim`, the resolved addresses are return unsorted. When `ipv4first`, the resolved addresses are sorted
         * by placing IPv4 addresses before IPv6 addresses. When `ipv6first`, the resolved addresses are sorted by placing IPv6
         * addresses before IPv4 addresses. Default value is configurable using
         * {@link setDefaultResultOrder} or [`--dns-result-order`](https://nodejs.org/docs/latest-v22.x/api/cli.html#--dns-result-orderorder).
         * @default `verbatim` (addresses are not reordered)
         * @since v22.1.0
         */
        order?: "ipv4first" | "ipv6first" | "verbatim" | undefined;
        /**
         * When `true`, the callback receives IPv4 and IPv6 addresses in the order the DNS resolver returned them. When `false`, IPv4
         * addresses are placed before IPv6 addresses. This option will be deprecated in favor of `order`. When both are specified,
         * `order` has higher precedence. New code should only use `order`. Default value is configurable using {@link setDefaultResultOrder}
         * @default true (addresses are not reordered)
         * @deprecated Please use `order` option
         */
        verbatim?: boolean | undefined;
    }
    export interface LookupOneOptions extends LookupOptions {
        all?: false | undefined;
    }
    export interface LookupAllOptions extends LookupOptions {
        all: true;
    }
    export interface LookupAddress {
        /**
         * A string representation of an IPv4 or IPv6 address.
         */
        address: string;
        /**
         * `4` or `6`, denoting the family of `address`, or `0` if the address is not an IPv4 or IPv6 address. `0` is a likely indicator of a
         * bug in the name resolution service used by the operating system.
         */
        family: number;
    }
    /**
     * Resolves a host name (e.g. `'nodejs.org'`) into the first found A (IPv4) or
     * AAAA (IPv6) record. All `option` properties are optional. If `options` is an
     * integer, then it must be `4` or `6`  if `options` is `0` or not provided, then
     * IPv4 and IPv6 addresses are both returned if found.
     *
     * With the `all` option set to `true`, the arguments for `callback` change to `(err, addresses)`, with `addresses` being an array of objects with the
     * properties `address` and `family`.
     *
     * On error, `err` is an `Error` object, where `err.code` is the error code.
     * Keep in mind that `err.code` will be set to `'ENOTFOUND'` not only when
     * the host name does not exist but also when the lookup fails in other ways
     * such as no available file descriptors.
     *
     * `dns.lookup()` does not necessarily have anything to do with the DNS protocol.
     * The implementation uses an operating system facility that can associate names
     * with addresses and vice versa. This implementation can have subtle but
     * important consequences on the behavior of any Node.js program. Please take some
     * time to consult the [Implementation considerations section](https://nodejs.org/docs/latest-v22.x/api/dns.html#implementation-considerations)
     * before using `dns.lookup()`.
     *
     * Example usage:
     *
     * ```js
     * import dns from 'node:dns';
     * const options = {
     *   family: 6,
     *   hints: dns.ADDRCONFIG | dns.V4MAPPED,
     * };
     * dns.lookup('example.com', options, (err, address, family) =>
     *   console.log('address: %j family: IPv%s', address, family));
     * // address: "2606:2800:220:1:248:1893:25c8:1946" family: IPv6
     *
     * // When options.all is true, the result will be an Array.
     * options.all = true;
     * dns.lookup('example.com', options, (err, addresses) =>
     *   console.log('addresses: %j', addresses));
     * // addresses: [{"address":"2606:2800:220:1:248:1893:25c8:1946","family":6}]
     * ```
     *
     * If this method is invoked as its [util.promisify()](https://nodejs.org/docs/latest-v22.x/api/util.html#utilpromisifyoriginal) ed
     * version, and `all` is not set to `true`, it returns a `Promise` for an `Object` with `address` and `family` properties.
     * @since v0.1.90
     */
    export function lookup(
        hostname: string,
        family: number,
        callback: (err: NodeJS.ErrnoException | null, address: string, family: number) => void,
    ): void;
    export function lookup(
        hostname: string,
        options: LookupOneOptions,
        callback: (err: NodeJS.ErrnoException | null, address: string, family: number) => void,
    ): void;
    export function lookup(
        hostname: string,
        options: LookupAllOptions,
        callback: (err: NodeJS.ErrnoException | null, addresses: LookupAddress[]) => void,
    ): void;
    export function lookup(
        hostname: string,
        options: LookupOptions,
        callback: (err: NodeJS.ErrnoException | null, address: string | LookupAddress[], family: number) => void,
    ): void;
    export function lookup(
        hostname: string,
        callback: (err: NodeJS.ErrnoException | null, address: string, family: number) => void,
    ): void;
    export namespace lookup {
        function __promisify__(hostname: string, options: LookupAllOptions): Promise<LookupAddress[]>;
        function __promisify__(hostname: string, options?: LookupOneOptions | number): Promise<LookupAddress>;
        function __promisify__(hostname: string, options: LookupOptions): Promise<LookupAddress | LookupAddress[]>;
    }
    /**
     * Resolves the given `address` and `port` into a host name and service using
     * the operating system's underlying `getnameinfo` implementation.
     *
     * If `address` is not a valid IP address, a `TypeError` will be thrown.
     * The `port` will be coerced to a number. If it is not a legal port, a `TypeError` will be thrown.
     *
     * On an error, `err` is an [`Error`](https://nodejs.org/docs/latest-v22.x/api/errors.html#class-error) object,
     * where `err.code` is the error code.
     *
     * ```js
     * import dns from 'node:dns';
     * dns.lookupService('127.0.0.1', 22, (err, hostname, service) => {
     *   console.log(hostname, service);
     *   // Prints: localhost ssh
     * });
     * ```
     *
     * If this method is invoked as its [util.promisify()](https://nodejs.org/docs/latest-v22.x/api/util.html#utilpromisifyoriginal) ed
     * version, it returns a `Promise` for an `Object` with `hostname` and `service` properties.
     * @since v0.11.14
     */
    export function lookupService(
        address: string,
        port: number,
        callback: (err: NodeJS.ErrnoException | null, hostname: string, service: string) => void,
    ): void;
    export namespace lookupService {
        function __promisify__(
            address: string,
            port: number,
        ): Promise<{
            hostname: string;
            service: string;
        }>;
    }
    export interface ResolveOptions {
        ttl: boolean;
    }
    export interface ResolveWithTtlOptions extends ResolveOptions {
        ttl: true;
    }
    export interface RecordWithTtl {
        address: string;
        ttl: number;
    }
    /** @deprecated Use `AnyARecord` or `AnyAaaaRecord` instead. */
    export type AnyRecordWithTtl = AnyARecord | AnyAaaaRecord;
    export interface AnyARecord extends RecordWithTtl {
        type: "A";
    }
    export interface AnyAaaaRecord extends RecordWithTtl {
        type: "AAAA";
    }
    export interface CaaRecord {
        critical: number;
        issue?: string | undefined;
        issuewild?: string | undefined;
        iodef?: string | undefined;
        contactemail?: string | undefined;
        contactphone?: string | undefined;
    }
    export interface AnyCaaRecord extends CaaRecord {
        type: "CAA";
    }
    export interface MxRecord {
        priority: number;
        exchange: string;
    }
    export interface AnyMxRecord extends MxRecord {
        type: "MX";
    }
    export interface NaptrRecord {
        flags: string;
        service: string;
        regexp: string;
        replacement: string;
        order: number;
        preference: number;
    }
    export interface AnyNaptrRecord extends NaptrRecord {
        type: "NAPTR";
    }
    export interface SoaRecord {
        nsname: string;
        hostmaster: string;
        serial: number;
        refresh: number;
        retry: number;
        expire: number;
        minttl: number;
    }
    export interface AnySoaRecord extends SoaRecord {
        type: "SOA";
    }
    export interface SrvRecord {
        priority: number;
        weight: number;
        port: number;
        name: string;
    }
    export interface AnySrvRecord extends SrvRecord {
        type: "SRV";
    }
    export interface TlsaRecord {
        certUsage: number;
        selector: number;
        match: number;
        data: ArrayBuffer;
    }
    export interface AnyTlsaRecord extends TlsaRecord {
        type: "TLSA";
    }
    export interface AnyTxtRecord {
        type: "TXT";
        entries: string[];
    }
    export interface AnyNsRecord {
        type: "NS";
        value: string;
    }
    export interface AnyPtrRecord {
        type: "PTR";
        value: string;
    }
    export interface AnyCnameRecord {
        type: "CNAME";
        value: string;
    }
    export type AnyRecord =
        | AnyARecord
        | AnyAaaaRecord
        | AnyCaaRecord
        | AnyCnameRecord
        | AnyMxRecord
        | AnyNaptrRecord
        | AnyNsRecord
        | AnyPtrRecord
        | AnySoaRecord
        | AnySrvRecord
        | AnyTlsaRecord
        | AnyTxtRecord;
    /**
     * Uses the DNS protocol to resolve a host name (e.g. `'nodejs.org'`) into an array
     * of the resource records. The `callback` function has arguments `(err, records)`. When successful, `records` will be an array of resource
     * records. The type and structure of individual results varies based on `rrtype`:
     *
     * <omitted>
     *
     * On error, `err` is an [`Error`](https://nodejs.org/docs/latest-v22.x/api/errors.html#class-error) object,
     * where `err.code` is one of the `DNS error codes`.
     * @since v0.1.27
     * @param hostname Host name to resolve.
     * @param [rrtype='A'] Resource record type.
     */
    export function resolve(
        hostname: string,
        callback: (err: NodeJS.ErrnoException | null, addresses: string[]) => void,
    ): void;
    export function resolve(
        hostname: string,
        rrtype: "A" | "AAAA" | "CNAME" | "NS" | "PTR",
        callback: (err: NodeJS.ErrnoException | null, addresses: string[]) => void,
    ): void;
    export function resolve(
        hostname: string,
        rrtype: "ANY",
        callback: (err: NodeJS.ErrnoException | null, addresses: AnyRecord[]) => void,
    ): void;
    export function resolve(
        hostname: string,
        rrtype: "CAA",
        callback: (err: NodeJS.ErrnoException | null, address: CaaRecord[]) => void,
    ): void;
    export function resolve(
        hostname: string,
        rrtype: "MX",
        callback: (err: NodeJS.ErrnoException | null, addresses: MxRecord[]) => void,
    ): void;
    export function resolve(
        hostname: string,
        rrtype: "NAPTR",
        callback: (err: NodeJS.ErrnoException | null, addresses: NaptrRecord[]) => void,
    ): void;
    export function resolve(
        hostname: string,
        rrtype: "SOA",
        callback: (err: NodeJS.ErrnoException | null, addresses: SoaRecord) => void,
    ): void;
    export function resolve(
        hostname: string,
        rrtype: "SRV",
        callback: (err: NodeJS.ErrnoException | null, addresses: SrvRecord[]) => void,
    ): void;
    export function resolve(
        hostname: string,
        rrtype: "TLSA",
        callback: (err: NodeJS.ErrnoException | null, addresses: TlsaRecord[]) => void,
    ): void;
    export function resolve(
        hostname: string,
        rrtype: "TXT",
        callback: (err: NodeJS.ErrnoException | null, addresses: string[][]) => void,
    ): void;
    export function resolve(
        hostname: string,
        rrtype: string,
        callback: (
            err: NodeJS.ErrnoException | null,
            addresses:
                | string[]
                | CaaRecord[]
                | MxRecord[]
                | NaptrRecord[]
                | SoaRecord
                | SrvRecord[]
                | TlsaRecord[]
                | string[][]
                | AnyRecord[],
        ) => void,
    ): void;
    export namespace resolve {
        function __promisify__(hostname: string, rrtype?: "A" | "AAAA" | "CNAME" | "NS" | "PTR"): Promise<string[]>;
        function __promisify__(hostname: string, rrtype: "ANY"): Promise<AnyRecord[]>;
        function __promisify__(hostname: string, rrtype: "CAA"): Promise<CaaRecord[]>;
        function __promisify__(hostname: string, rrtype: "MX"): Promise<MxRecord[]>;
        function __promisify__(hostname: string, rrtype: "NAPTR"): Promise<NaptrRecord[]>;
        function __promisify__(hostname: string, rrtype: "SOA"): Promise<SoaRecord>;
        function __promisify__(hostname: string, rrtype: "SRV"): Promise<SrvRecord[]>;
        function __promisify__(hostname: string, rrtype: "TLSA"): Promise<TlsaRecord[]>;
        function __promisify__(hostname: string, rrtype: "TXT"): Promise<string[][]>;
        function __promisify__(
            hostname: string,
            rrtype: string,
        ): Promise<
            | string[]
            | CaaRecord[]
            | MxRecord[]
            | NaptrRecord[]
            | SoaRecord
            | SrvRecord[]
            | TlsaRecord[]
            | string[][]
            | AnyRecord[]
        >;
    }
    /**
     * Uses the DNS protocol to resolve a IPv4 addresses (`A` records) for the `hostname`. The `addresses` argument passed to the `callback` function
     * will contain an array of IPv4 addresses (e.g.`['74.125.79.104', '74.125.79.105', '74.125.79.106']`).
     * @since v0.1.16
     * @param hostname Host name to resolve.
     */
    export function resolve4(
        hostname: string,
        callback: (err: NodeJS.ErrnoException | null, addresses: string[]) => void,
    ): void;
    export function resolve4(
        hostname: string,
        options: ResolveWithTtlOptions,
        callback: (err: NodeJS.ErrnoException | null, addresses: RecordWithTtl[]) => void,
    ): void;
    export function resolve4(
        hostname: string,
        options: ResolveOptions,
        callback: (err: NodeJS.ErrnoException | null, addresses: string[] | RecordWithTtl[]) => void,
    ): void;
    export namespace resolve4 {
        function __promisify__(hostname: string): Promise<string[]>;
        function __promisify__(hostname: string, options: ResolveWithTtlOptions): Promise<RecordWithTtl[]>;
        function __promisify__(hostname: string, options?: ResolveOptions): Promise<string[] | RecordWithTtl[]>;
    }
    /**
     * Uses the DNS protocol to resolve IPv6 addresses (`AAAA` records) for the `hostname`. The `addresses` argument passed to the `callback` function
     * will contain an array of IPv6 addresses.
     * @since v0.1.16
     * @param hostname Host name to resolve.
     */
    export function resolve6(
        hostname: string,
        callback: (err: NodeJS.ErrnoException | null, addresses: string[]) => void,
    ): void;
    export function resolve6(
        hostname: string,
        options: ResolveWithTtlOptions,
        callback: (err: NodeJS.ErrnoException | null, addresses: RecordWithTtl[]) => void,
    ): void;
    export function resolve6(
        hostname: string,
        options: ResolveOptions,
        callback: (err: NodeJS.ErrnoException | null, addresses: string[] | RecordWithTtl[]) => void,
    ): void;
    export namespace resolve6 {
        function __promisify__(hostname: string): Promise<string[]>;
        function __promisify__(hostname: string, options: ResolveWithTtlOptions): Promise<RecordWithTtl[]>;
        function __promisify__(hostname: string, options?: ResolveOptions): Promise<string[] | RecordWithTtl[]>;
    }
    /**
     * Uses the DNS protocol to resolve `CNAME` records for the `hostname`. The `addresses` argument passed to the `callback` function
     * will contain an array of canonical name records available for the `hostname` (e.g. `['bar.example.com']`).
     * @since v0.3.2
     */
    export function resolveCname(
        hostname: string,
        callback: (err: NodeJS.ErrnoException | null, addresses: string[]) => void,
    ): void;
    export namespace resolveCname {
        function __promisify__(hostname: string): Promise<string[]>;
    }
    /**
     * Uses the DNS protocol to resolve `CAA` records for the `hostname`. The `addresses` argument passed to the `callback` function
     * will contain an array of certification authority authorization records
     * available for the `hostname` (e.g. `[{critical: 0, iodef: 'mailto:pki@example.com'}, {critical: 128, issue: 'pki.example.com'}]`).
     * @since v15.0.0, v14.17.0
     */
    export function resolveCaa(
        hostname: string,
        callback: (err: NodeJS.ErrnoException | null, records: CaaRecord[]) => void,
    ): void;
    export namespace resolveCaa {
        function __promisify__(hostname: string): Promise<CaaRecord[]>;
    }
    /**
     * Uses the DNS protocol to resolve mail exchange records (`MX` records) for the `hostname`. The `addresses` argument passed to the `callback` function will
     * contain an array of objects containing both a `priority` and `exchange` property (e.g. `[{priority: 10, exchange: 'mx.example.com'}, ...]`).
     * @since v0.1.27
     */
    export function resolveMx(
        hostname: string,
        callback: (err: NodeJS.ErrnoException | null, addresses: MxRecord[]) => void,
    ): void;
    export namespace resolveMx {
        function __promisify__(hostname: string): Promise<MxRecord[]>;
    }
    /**
     * Uses the DNS protocol to resolve regular expression-based records (`NAPTR` records) for the `hostname`. The `addresses` argument passed to the `callback` function will contain an array of
     * objects with the following properties:
     *
     * * `flags`
     * * `service`
     * * `regexp`
     * * `replacement`
     * * `order`
     * * `preference`
     *
     * ```js
     * {
     *   flags: 's',
     *   service: 'SIP+D2U',
     *   regexp: '',
     *   replacement: '_sip._udp.example.com',
     *   order: 30,
     *   preference: 100
     * }
     * ```
     * @since v0.9.12
     */
    export function resolveNaptr(
        hostname: string,
        callback: (err: NodeJS.ErrnoException | null, addresses: NaptrRecord[]) => void,
    ): void;
    export namespace resolveNaptr {
        function __promisify__(hostname: string): Promise<NaptrRecord[]>;
    }
    /**
     * Uses the DNS protocol to resolve name server records (`NS` records) for the `hostname`. The `addresses` argument passed to the `callback` function will
     * contain an array of name server records available for `hostname` (e.g. `['ns1.example.com', 'ns2.example.com']`).
     * @since v0.1.90
     */
    export function resolveNs(
        hostname: string,
        callback: (err: NodeJS.ErrnoException | null, addresses: string[]) => void,
    ): void;
    export namespace resolveNs {
        function __promisify__(hostname: string): Promise<string[]>;
    }
    /**
     * Uses the DNS protocol to resolve pointer records (`PTR` records) for the `hostname`. The `addresses` argument passed to the `callback` function will
     * be an array of strings containing the reply records.
     * @since v6.0.0
     */
    export function resolvePtr(
        hostname: string,
        callback: (err: NodeJS.ErrnoException | null, addresses: string[]) => void,
    ): void;
    export namespace resolvePtr {
        function __promisify__(hostname: string): Promise<string[]>;
    }
    /**
     * Uses the DNS protocol to resolve a start of authority record (`SOA` record) for
     * the `hostname`. The `address` argument passed to the `callback` function will
     * be an object with the following properties:
     *
     * * `nsname`
     * * `hostmaster`
     * * `serial`
     * * `refresh`
     * * `retry`
     * * `expire`
     * * `minttl`
     *
     * ```js
     * {
     *   nsname: 'ns.example.com',
     *   hostmaster: 'root.example.com',
     *   serial: 2013101809,
     *   refresh: 10000,
     *   retry: 2400,
     *   expire: 604800,
     *   minttl: 3600
     * }
     * ```
     * @since v0.11.10
     */
    export function resolveSoa(
        hostname: string,
        callback: (err: NodeJS.ErrnoException | null, address: SoaRecord) => void,
    ): void;
    export namespace resolveSoa {
        function __promisify__(hostname: string): Promise<SoaRecord>;
    }
    /**
     * Uses the DNS protocol to resolve service records (`SRV` records) for the `hostname`. The `addresses` argument passed to the `callback` function will
     * be an array of objects with the following properties:
     *
     * * `priority`
     * * `weight`
     * * `port`
     * * `name`
     *
     * ```js
     * {
     *   priority: 10,
     *   weight: 5,
     *   port: 21223,
     *   name: 'service.example.com'
     * }
     * ```
     * @since v0.1.27
     */
    export function resolveSrv(
        hostname: string,
        callback: (err: NodeJS.ErrnoException | null, addresses: SrvRecord[]) => void,
    ): void;
    export namespace resolveSrv {
        function __promisify__(hostname: string): Promise<SrvRecord[]>;
    }
    /**
     * Uses the DNS protocol to resolve certificate associations (`TLSA` records) for
     * the `hostname`. The `records` argument passed to the `callback` function is an
     * array of objects with these properties:
     *
     * * `certUsage`
     * * `selector`
     * * `match`
     * * `data`
     *
     * ```js
     * {
     *   certUsage: 3,
     *   selector: 1,
     *   match: 1,
     *   data: [ArrayBuffer]
     * }
     * ```
     * @since v22.15.0
     */
    export function resolveTlsa(
        hostname: string,
        callback: (err: NodeJS.ErrnoException | null, addresses: TlsaRecord[]) => void,
    ): void;
    export namespace resolveTlsa {
        function __promisify__(hostname: string): Promise<TlsaRecord[]>;
    }
    /**
     * Uses the DNS protocol to resolve text queries (`TXT` records) for the `hostname`. The `records` argument passed to the `callback` function is a
     * two-dimensional array of the text records available for `hostname` (e.g.`[ ['v=spf1 ip4:0.0.0.0 ', '~all' ] ]`). Each sub-array contains TXT chunks of
     * one record. Depending on the use case, these could be either joined together or
     * treated separately.
     * @since v0.1.27
     */
    export function resolveTxt(
        hostname: string,
        callback: (err: NodeJS.ErrnoException | null, addresses: string[][]) => void,
    ): void;
    export namespace resolveTxt {
        function __promisify__(hostname: string): Promise<string[][]>;
    }
    /**
     * Uses the DNS protocol to resolve all records (also known as `ANY` or `*` query).
     * The `ret` argument passed to the `callback` function will be an array containing
     * various types of records. Each object has a property `type` that indicates the
     * type of the current record. And depending on the `type`, additional properties
     * will be present on the object:
     *
     * <omitted>
     *
     * Here is an example of the `ret` object passed to the callback:
     *
     * ```js
     * [ { type: 'A', address: '127.0.0.1', ttl: 299 },
     *   { type: 'CNAME', value: 'example.com' },
     *   { type: 'MX', exchange: 'alt4.aspmx.l.example.com', priority: 50 },
     *   { type: 'NS', value: 'ns1.example.com' },
     *   { type: 'TXT', entries: [ 'v=spf1 include:_spf.example.com ~all' ] },
     *   { type: 'SOA',
     *     nsname: 'ns1.example.com',
     *     hostmaster: 'admin.example.com',
     *     serial: 156696742,
     *     refresh: 900,
     *     retry: 900,
     *     expire: 1800,
     *     minttl: 60 } ]
     * ```
     *
     * DNS server operators may choose not to respond to `ANY` queries. It may be better to call individual methods like {@link resolve4}, {@link resolveMx}, and so on. For more details, see
     * [RFC 8482](https://tools.ietf.org/html/rfc8482).
     */
    export function resolveAny(
        hostname: string,
        callback: (err: NodeJS.ErrnoException | null, addresses: AnyRecord[]) => void,
    ): void;
    export namespace resolveAny {
        function __promisify__(hostname: string): Promise<AnyRecord[]>;
    }
    /**
     * Performs a reverse DNS query that resolves an IPv4 or IPv6 address to an
     * array of host names.
     *
     * On error, `err` is an [`Error`](https://nodejs.org/docs/latest-v22.x/api/errors.html#class-error) object, where `err.code` is
     * one of the [DNS error codes](https://nodejs.org/docs/latest-v22.x/api/dns.html#error-codes).
     * @since v0.1.16
     */
    export function reverse(
        ip: string,
        callback: (err: NodeJS.ErrnoException | null, hostnames: string[]) => void,
    ): void;
    /**
     * Get the default value for `order` in {@link lookup} and [`dnsPromises.lookup()`](https://nodejs.org/docs/latest-v22.x/api/dns.html#dnspromiseslookuphostname-options).
     * The value could be:
     *
     * * `ipv4first`: for `order` defaulting to `ipv4first`.
     * * `ipv6first`: for `order` defaulting to `ipv6first`.
     * * `verbatim`: for `order` defaulting to `verbatim`.
     * @since v18.17.0
     */
    export function getDefaultResultOrder(): "ipv4first" | "ipv6first" | "verbatim";
    /**
     * Sets the IP address and port of servers to be used when performing DNS
     * resolution. The `servers` argument is an array of [RFC 5952](https://tools.ietf.org/html/rfc5952#section-6) formatted
     * addresses. If the port is the IANA default DNS port (53) it can be omitted.
     *
     * ```js
     * dns.setServers([
     *   '4.4.4.4',
     *   '[2001:4860:4860::8888]',
     *   '4.4.4.4:1053',
     *   '[2001:4860:4860::8888]:1053',
     * ]);
     * ```
     *
     * An error will be thrown if an invalid address is provided.
     *
     * The `dns.setServers()` method must not be called while a DNS query is in
     * progress.
     *
     * The {@link setServers} method affects only {@link resolve}, `dns.resolve*()` and {@link reverse} (and specifically _not_ {@link lookup}).
     *
     * This method works much like [resolve.conf](https://man7.org/linux/man-pages/man5/resolv.conf.5.html).
     * That is, if attempting to resolve with the first server provided results in a `NOTFOUND` error, the `resolve()` method will _not_ attempt to resolve with
     * subsequent servers provided. Fallback DNS servers will only be used if the
     * earlier ones time out or result in some other error.
     * @since v0.11.3
     * @param servers array of [RFC 5952](https://datatracker.ietf.org/doc/html/rfc5952#section-6) formatted addresses
     */
    export function setServers(servers: readonly string[]): void;
    /**
     * Returns an array of IP address strings, formatted according to [RFC 5952](https://tools.ietf.org/html/rfc5952#section-6),
     * that are currently configured for DNS resolution. A string will include a port
     * section if a custom port is used.
     *
     * ```js
     * [
     *   '4.4.4.4',
     *   '2001:4860:4860::8888',
     *   '4.4.4.4:1053',
     *   '[2001:4860:4860::8888]:1053',
     * ]
     * ```
     * @since v0.11.3
     */
    export function getServers(): string[];
    /**
     * Set the default value of `order` in {@link lookup} and [`dnsPromises.lookup()`](https://nodejs.org/docs/latest-v22.x/api/dns.html#dnspromiseslookuphostname-options).
     * The value could be:
     *
     * * `ipv4first`: sets default `order` to `ipv4first`.
     * * `ipv6first`: sets default `order` to `ipv6first`.
     * * `verbatim`: sets default `order` to `verbatim`.
     *
     * The default is `verbatim` and {@link setDefaultResultOrder} have higher
     * priority than [`--dns-result-order`](https://nodejs.org/docs/latest-v22.x/api/cli.html#--dns-result-orderorder). When using
     * [worker threads](https://nodejs.org/docs/latest-v22.x/api/worker_threads.html), {@link setDefaultResultOrder} from the main
     * thread won't affect the default dns orders in workers.
     * @since v16.4.0, v14.18.0
     * @param order must be `'ipv4first'`, `'ipv6first'` or `'verbatim'`.
     */
    export function setDefaultResultOrder(order: "ipv4first" | "ipv6first" | "verbatim"): void;
    // Error codes
    export const NODATA: "ENODATA";
    export const FORMERR: "EFORMERR";
    export const SERVFAIL: "ESERVFAIL";
    export const NOTFOUND: "ENOTFOUND";
    export const NOTIMP: "ENOTIMP";
    export const REFUSED: "EREFUSED";
    export const BADQUERY: "EBADQUERY";
    export const BADNAME: "EBADNAME";
    export const BADFAMILY: "EBADFAMILY";
    export const BADRESP: "EBADRESP";
    export const CONNREFUSED: "ECONNREFUSED";
    export const TIMEOUT: "ETIMEOUT";
    export const EOF: "EOF";
    export const FILE: "EFILE";
    export const NOMEM: "ENOMEM";
    export const DESTRUCTION: "EDESTRUCTION";
    export const BADSTR: "EBADSTR";
    export const BADFLAGS: "EBADFLAGS";
    export const NONAME: "ENONAME";
    export const BADHINTS: "EBADHINTS";
    export const NOTINITIALIZED: "ENOTINITIALIZED";
    export const LOADIPHLPAPI: "ELOADIPHLPAPI";
    export const ADDRGETNETWORKPARAMS: "EADDRGETNETWORKPARAMS";
    export const CANCELLED: "ECANCELLED";
    export interface ResolverOptions {
        /**
         * Query timeout in milliseconds, or `-1` to use the default timeout.
         */
        timeout?: number | undefined;
        /**
         * The number of tries the resolver will try contacting each name server before giving up.
         * @default 4
         */
        tries?: number | undefined;
    }
    /**
     * An independent resolver for DNS requests.
     *
     * Creating a new resolver uses the default server settings. Setting
     * the servers used for a resolver using [`resolver.setServers()`](https://nodejs.org/docs/latest-v22.x/api/dns.html#dnssetserversservers) does not affect
     * other resolvers:
     *
     * ```js
     * import { Resolver } from 'node:dns';
     * const resolver = new Resolver();
     * resolver.setServers(['4.4.4.4']);
     *
     * // This request will use the server at 4.4.4.4, independent of global settings.
     * resolver.resolve4('example.org', (err, addresses) => {
     *   // ...
     * });
     * ```
     *
     * The following methods from the `node:dns` module are available:
     *
     * * `resolver.getServers()`
     * * `resolver.resolve()`
     * * `resolver.resolve4()`
     * * `resolver.resolve6()`
     * * `resolver.resolveAny()`
     * * `resolver.resolveCaa()`
     * * `resolver.resolveCname()`
     * * `resolver.resolveMx()`
     * * `resolver.resolveNaptr()`
     * * `resolver.resolveNs()`
     * * `resolver.resolvePtr()`
     * * `resolver.resolveSoa()`
     * * `resolver.resolveSrv()`
     * * `resolver.resolveTxt()`
     * * `resolver.reverse()`
     * * `resolver.setServers()`
     * @since v8.3.0
     */
    export class Resolver {
        constructor(options?: ResolverOptions);
        /**
         * Cancel all outstanding DNS queries made by this resolver. The corresponding
         * callbacks will be called with an error with code `ECANCELLED`.
         * @since v8.3.0
         */
        cancel(): void;
        getServers: typeof getServers;
        resolve: typeof resolve;
        resolve4: typeof resolve4;
        resolve6: typeof resolve6;
        resolveAny: typeof resolveAny;
        resolveCaa: typeof resolveCaa;
        resolveCname: typeof resolveCname;
        resolveMx: typeof resolveMx;
        resolveNaptr: typeof resolveNaptr;
        resolveNs: typeof resolveNs;
        resolvePtr: typeof resolvePtr;
        resolveSoa: typeof resolveSoa;
        resolveSrv: typeof resolveSrv;
        resolveTlsa: typeof resolveTlsa;
        resolveTxt: typeof resolveTxt;
        reverse: typeof reverse;
        /**
         * The resolver instance will send its requests from the specified IP address.
         * This allows programs to specify outbound interfaces when used on multi-homed
         * systems.
         *
         * If a v4 or v6 address is not specified, it is set to the default and the
         * operating system will choose a local address automatically.
         *
         * The resolver will use the v4 local address when making requests to IPv4 DNS
         * servers, and the v6 local address when making requests to IPv6 DNS servers.
         * The `rrtype` of resolution requests has no impact on the local address used.
         * @since v15.1.0, v14.17.0
         * @param [ipv4='0.0.0.0'] A string representation of an IPv4 address.
         * @param [ipv6='::0'] A string representation of an IPv6 address.
         */
        setLocalAddress(ipv4?: string, ipv6?: string): void;
        setServers: typeof setServers;
    }
    export { dnsPromises as promises };
}
declare module "node:dns" {
    export * from "dns";
}

```

## ./lib/lambda/node_modules/@types/node/domain.d.ts

```typescript
/**
 * **This module is pending deprecation.** Once a replacement API has been
 * finalized, this module will be fully deprecated. Most developers should
 * **not** have cause to use this module. Users who absolutely must have
 * the functionality that domains provide may rely on it for the time being
 * but should expect to have to migrate to a different solution
 * in the future.
 *
 * Domains provide a way to handle multiple different IO operations as a
 * single group. If any of the event emitters or callbacks registered to a
 * domain emit an `'error'` event, or throw an error, then the domain object
 * will be notified, rather than losing the context of the error in the `process.on('uncaughtException')` handler, or causing the program to
 * exit immediately with an error code.
 * @deprecated Since v1.4.2 - Deprecated
 * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/domain.js)
 */
declare module "domain" {
    import EventEmitter = require("node:events");
    /**
     * The `Domain` class encapsulates the functionality of routing errors and
     * uncaught exceptions to the active `Domain` object.
     *
     * To handle the errors that it catches, listen to its `'error'` event.
     */
    class Domain extends EventEmitter {
        /**
         * An array of timers and event emitters that have been explicitly added
         * to the domain.
         */
        members: Array<EventEmitter | NodeJS.Timer>;
        /**
         * The `enter()` method is plumbing used by the `run()`, `bind()`, and `intercept()` methods to set the active domain. It sets `domain.active` and `process.domain` to the domain, and implicitly
         * pushes the domain onto the domain
         * stack managed by the domain module (see {@link exit} for details on the
         * domain stack). The call to `enter()` delimits the beginning of a chain of
         * asynchronous calls and I/O operations bound to a domain.
         *
         * Calling `enter()` changes only the active domain, and does not alter the domain
         * itself. `enter()` and `exit()` can be called an arbitrary number of times on a
         * single domain.
         */
        enter(): void;
        /**
         * The `exit()` method exits the current domain, popping it off the domain stack.
         * Any time execution is going to switch to the context of a different chain of
         * asynchronous calls, it's important to ensure that the current domain is exited.
         * The call to `exit()` delimits either the end of or an interruption to the chain
         * of asynchronous calls and I/O operations bound to a domain.
         *
         * If there are multiple, nested domains bound to the current execution context, `exit()` will exit any domains nested within this domain.
         *
         * Calling `exit()` changes only the active domain, and does not alter the domain
         * itself. `enter()` and `exit()` can be called an arbitrary number of times on a
         * single domain.
         */
        exit(): void;
        /**
         * Run the supplied function in the context of the domain, implicitly
         * binding all event emitters, timers, and low-level requests that are
         * created in that context. Optionally, arguments can be passed to
         * the function.
         *
         * This is the most basic way to use a domain.
         *
         * ```js
         * import domain from 'node:domain';
         * import fs from 'node:fs';
         * const d = domain.create();
         * d.on('error', (er) => {
         *   console.error('Caught error!', er);
         * });
         * d.run(() => {
         *   process.nextTick(() => {
         *     setTimeout(() => { // Simulating some various async stuff
         *       fs.open('non-existent file', 'r', (er, fd) => {
         *         if (er) throw er;
         *         // proceed...
         *       });
         *     }, 100);
         *   });
         * });
         * ```
         *
         * In this example, the `d.on('error')` handler will be triggered, rather
         * than crashing the program.
         */
        run<T>(fn: (...args: any[]) => T, ...args: any[]): T;
        /**
         * Explicitly adds an emitter to the domain. If any event handlers called by
         * the emitter throw an error, or if the emitter emits an `'error'` event, it
         * will be routed to the domain's `'error'` event, just like with implicit
         * binding.
         *
         * This also works with timers that are returned from `setInterval()` and `setTimeout()`. If their callback function throws, it will be caught by
         * the domain `'error'` handler.
         *
         * If the Timer or `EventEmitter` was already bound to a domain, it is removed
         * from that one, and bound to this one instead.
         * @param emitter emitter or timer to be added to the domain
         */
        add(emitter: EventEmitter | NodeJS.Timer): void;
        /**
         * The opposite of {@link add}. Removes domain handling from the
         * specified emitter.
         * @param emitter emitter or timer to be removed from the domain
         */
        remove(emitter: EventEmitter | NodeJS.Timer): void;
        /**
         * The returned function will be a wrapper around the supplied callback
         * function. When the returned function is called, any errors that are
         * thrown will be routed to the domain's `'error'` event.
         *
         * ```js
         * const d = domain.create();
         *
         * function readSomeFile(filename, cb) {
         *   fs.readFile(filename, 'utf8', d.bind((er, data) => {
         *     // If this throws, it will also be passed to the domain.
         *     return cb(er, data ? JSON.parse(data) : null);
         *   }));
         * }
         *
         * d.on('error', (er) => {
         *   // An error occurred somewhere. If we throw it now, it will crash the program
         *   // with the normal line number and stack message.
         * });
         * ```
         * @param callback The callback function
         * @return The bound function
         */
        bind<T extends Function>(callback: T): T;
        /**
         * This method is almost identical to {@link bind}. However, in
         * addition to catching thrown errors, it will also intercept `Error` objects sent as the first argument to the function.
         *
         * In this way, the common `if (err) return callback(err);` pattern can be replaced
         * with a single error handler in a single place.
         *
         * ```js
         * const d = domain.create();
         *
         * function readSomeFile(filename, cb) {
         *   fs.readFile(filename, 'utf8', d.intercept((data) => {
         *     // Note, the first argument is never passed to the
         *     // callback since it is assumed to be the 'Error' argument
         *     // and thus intercepted by the domain.
         *
         *     // If this throws, it will also be passed to the domain
         *     // so the error-handling logic can be moved to the 'error'
         *     // event on the domain instead of being repeated throughout
         *     // the program.
         *     return cb(null, JSON.parse(data));
         *   }));
         * }
         *
         * d.on('error', (er) => {
         *   // An error occurred somewhere. If we throw it now, it will crash the program
         *   // with the normal line number and stack message.
         * });
         * ```
         * @param callback The callback function
         * @return The intercepted function
         */
        intercept<T extends Function>(callback: T): T;
    }
    function create(): Domain;
}
declare module "node:domain" {
    export * from "domain";
}

```

## ./lib/lambda/node_modules/@types/node/events.d.ts

```typescript
/**
 * Much of the Node.js core API is built around an idiomatic asynchronous
 * event-driven architecture in which certain kinds of objects (called "emitters")
 * emit named events that cause `Function` objects ("listeners") to be called.
 *
 * For instance: a `net.Server` object emits an event each time a peer
 * connects to it; a `fs.ReadStream` emits an event when the file is opened;
 * a `stream` emits an event whenever data is available to be read.
 *
 * All objects that emit events are instances of the `EventEmitter` class. These
 * objects expose an `eventEmitter.on()` function that allows one or more
 * functions to be attached to named events emitted by the object. Typically,
 * event names are camel-cased strings but any valid JavaScript property key
 * can be used.
 *
 * When the `EventEmitter` object emits an event, all of the functions attached
 * to that specific event are called _synchronously_. Any values returned by the
 * called listeners are _ignored_ and discarded.
 *
 * The following example shows a simple `EventEmitter` instance with a single
 * listener. The `eventEmitter.on()` method is used to register listeners, while
 * the `eventEmitter.emit()` method is used to trigger the event.
 *
 * ```js
 * import { EventEmitter } from 'node:events';
 *
 * class MyEmitter extends EventEmitter {}
 *
 * const myEmitter = new MyEmitter();
 * myEmitter.on('event', () => {
 *   console.log('an event occurred!');
 * });
 * myEmitter.emit('event');
 * ```
 * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/events.js)
 */
declare module "events" {
    import { AsyncResource, AsyncResourceOptions } from "node:async_hooks";
    interface EventEmitterOptions {
        /**
         * Enables automatic capturing of promise rejection.
         */
        captureRejections?: boolean | undefined;
    }
    interface StaticEventEmitterOptions {
        /**
         * Can be used to cancel awaiting events.
         */
        signal?: AbortSignal | undefined;
    }
    interface StaticEventEmitterIteratorOptions extends StaticEventEmitterOptions {
        /**
         * Names of events that will end the iteration.
         */
        close?: string[] | undefined;
        /**
         * The high watermark. The emitter is paused every time the size of events being buffered is higher than it.
         * Supported only on emitters implementing `pause()` and `resume()` methods.
         * @default Number.MAX_SAFE_INTEGER
         */
        highWaterMark?: number | undefined;
        /**
         * The low watermark. The emitter is resumed every time the size of events being buffered is lower than it.
         * Supported only on emitters implementing `pause()` and `resume()` methods.
         * @default 1
         */
        lowWaterMark?: number | undefined;
    }
    interface EventEmitter<T extends EventMap<T> = DefaultEventMap> extends NodeJS.EventEmitter<T> {}
    type EventMap<T> = Record<keyof T, any[]> | DefaultEventMap;
    type DefaultEventMap = [never];
    type AnyRest = [...args: any[]];
    type Args<K, T> = T extends DefaultEventMap ? AnyRest : (
        K extends keyof T ? T[K] : never
    );
    type Key<K, T> = T extends DefaultEventMap ? string | symbol : K | keyof T;
    type Key2<K, T> = T extends DefaultEventMap ? string | symbol : K & keyof T;
    type Listener<K, T, F> = T extends DefaultEventMap ? F : (
        K extends keyof T ? (
                T[K] extends unknown[] ? (...args: T[K]) => void : never
            )
            : never
    );
    type Listener1<K, T> = Listener<K, T, (...args: any[]) => void>;
    type Listener2<K, T> = Listener<K, T, Function>;

    /**
     * The `EventEmitter` class is defined and exposed by the `node:events` module:
     *
     * ```js
     * import { EventEmitter } from 'node:events';
     * ```
     *
     * All `EventEmitter`s emit the event `'newListener'` when new listeners are
     * added and `'removeListener'` when existing listeners are removed.
     *
     * It supports the following option:
     * @since v0.1.26
     */
    class EventEmitter<T extends EventMap<T> = DefaultEventMap> {
        constructor(options?: EventEmitterOptions);

        [EventEmitter.captureRejectionSymbol]?<K>(error: Error, event: Key<K, T>, ...args: Args<K, T>): void;

        /**
         * Creates a `Promise` that is fulfilled when the `EventEmitter` emits the given
         * event or that is rejected if the `EventEmitter` emits `'error'` while waiting.
         * The `Promise` will resolve with an array of all the arguments emitted to the
         * given event.
         *
         * This method is intentionally generic and works with the web platform [EventTarget](https://dom.spec.whatwg.org/#interface-eventtarget) interface, which has no special`'error'` event
         * semantics and does not listen to the `'error'` event.
         *
         * ```js
         * import { once, EventEmitter } from 'node:events';
         * import process from 'node:process';
         *
         * const ee = new EventEmitter();
         *
         * process.nextTick(() => {
         *   ee.emit('myevent', 42);
         * });
         *
         * const [value] = await once(ee, 'myevent');
         * console.log(value);
         *
         * const err = new Error('kaboom');
         * process.nextTick(() => {
         *   ee.emit('error', err);
         * });
         *
         * try {
         *   await once(ee, 'myevent');
         * } catch (err) {
         *   console.error('error happened', err);
         * }
         * ```
         *
         * The special handling of the `'error'` event is only used when `events.once()` is used to wait for another event. If `events.once()` is used to wait for the
         * '`error'` event itself, then it is treated as any other kind of event without
         * special handling:
         *
         * ```js
         * import { EventEmitter, once } from 'node:events';
         *
         * const ee = new EventEmitter();
         *
         * once(ee, 'error')
         *   .then(([err]) => console.log('ok', err.message))
         *   .catch((err) => console.error('error', err.message));
         *
         * ee.emit('error', new Error('boom'));
         *
         * // Prints: ok boom
         * ```
         *
         * An `AbortSignal` can be used to cancel waiting for the event:
         *
         * ```js
         * import { EventEmitter, once } from 'node:events';
         *
         * const ee = new EventEmitter();
         * const ac = new AbortController();
         *
         * async function foo(emitter, event, signal) {
         *   try {
         *     await once(emitter, event, { signal });
         *     console.log('event emitted!');
         *   } catch (error) {
         *     if (error.name === 'AbortError') {
         *       console.error('Waiting for the event was canceled!');
         *     } else {
         *       console.error('There was an error', error.message);
         *     }
         *   }
         * }
         *
         * foo(ee, 'foo', ac.signal);
         * ac.abort(); // Abort waiting for the event
         * ee.emit('foo'); // Prints: Waiting for the event was canceled!
         * ```
         * @since v11.13.0, v10.16.0
         */
        static once(
            emitter: NodeJS.EventEmitter,
            eventName: string | symbol,
            options?: StaticEventEmitterOptions,
        ): Promise<any[]>;
        static once(emitter: EventTarget, eventName: string, options?: StaticEventEmitterOptions): Promise<any[]>;
        /**
         * ```js
         * import { on, EventEmitter } from 'node:events';
         * import process from 'node:process';
         *
         * const ee = new EventEmitter();
         *
         * // Emit later on
         * process.nextTick(() => {
         *   ee.emit('foo', 'bar');
         *   ee.emit('foo', 42);
         * });
         *
         * for await (const event of on(ee, 'foo')) {
         *   // The execution of this inner block is synchronous and it
         *   // processes one event at a time (even with await). Do not use
         *   // if concurrent execution is required.
         *   console.log(event); // prints ['bar'] [42]
         * }
         * // Unreachable here
         * ```
         *
         * Returns an `AsyncIterator` that iterates `eventName` events. It will throw
         * if the `EventEmitter` emits `'error'`. It removes all listeners when
         * exiting the loop. The `value` returned by each iteration is an array
         * composed of the emitted event arguments.
         *
         * An `AbortSignal` can be used to cancel waiting on events:
         *
         * ```js
         * import { on, EventEmitter } from 'node:events';
         * import process from 'node:process';
         *
         * const ac = new AbortController();
         *
         * (async () => {
         *   const ee = new EventEmitter();
         *
         *   // Emit later on
         *   process.nextTick(() => {
         *     ee.emit('foo', 'bar');
         *     ee.emit('foo', 42);
         *   });
         *
         *   for await (const event of on(ee, 'foo', { signal: ac.signal })) {
         *     // The execution of this inner block is synchronous and it
         *     // processes one event at a time (even with await). Do not use
         *     // if concurrent execution is required.
         *     console.log(event); // prints ['bar'] [42]
         *   }
         *   // Unreachable here
         * })();
         *
         * process.nextTick(() => ac.abort());
         * ```
         *
         * Use the `close` option to specify an array of event names that will end the iteration:
         *
         * ```js
         * import { on, EventEmitter } from 'node:events';
         * import process from 'node:process';
         *
         * const ee = new EventEmitter();
         *
         * // Emit later on
         * process.nextTick(() => {
         *   ee.emit('foo', 'bar');
         *   ee.emit('foo', 42);
         *   ee.emit('close');
         * });
         *
         * for await (const event of on(ee, 'foo', { close: ['close'] })) {
         *   console.log(event); // prints ['bar'] [42]
         * }
         * // the loop will exit after 'close' is emitted
         * console.log('done'); // prints 'done'
         * ```
         * @since v13.6.0, v12.16.0
         * @return An `AsyncIterator` that iterates `eventName` events emitted by the `emitter`
         */
        static on(
            emitter: NodeJS.EventEmitter,
            eventName: string | symbol,
            options?: StaticEventEmitterIteratorOptions,
        ): NodeJS.AsyncIterator<any[]>;
        static on(
            emitter: EventTarget,
            eventName: string,
            options?: StaticEventEmitterIteratorOptions,
        ): NodeJS.AsyncIterator<any[]>;
        /**
         * A class method that returns the number of listeners for the given `eventName` registered on the given `emitter`.
         *
         * ```js
         * import { EventEmitter, listenerCount } from 'node:events';
         *
         * const myEmitter = new EventEmitter();
         * myEmitter.on('event', () => {});
         * myEmitter.on('event', () => {});
         * console.log(listenerCount(myEmitter, 'event'));
         * // Prints: 2
         * ```
         * @since v0.9.12
         * @deprecated Since v3.2.0 - Use `listenerCount` instead.
         * @param emitter The emitter to query
         * @param eventName The event name
         */
        static listenerCount(emitter: NodeJS.EventEmitter, eventName: string | symbol): number;
        /**
         * Returns a copy of the array of listeners for the event named `eventName`.
         *
         * For `EventEmitter`s this behaves exactly the same as calling `.listeners` on
         * the emitter.
         *
         * For `EventTarget`s this is the only way to get the event listeners for the
         * event target. This is useful for debugging and diagnostic purposes.
         *
         * ```js
         * import { getEventListeners, EventEmitter } from 'node:events';
         *
         * {
         *   const ee = new EventEmitter();
         *   const listener = () => console.log('Events are fun');
         *   ee.on('foo', listener);
         *   console.log(getEventListeners(ee, 'foo')); // [ [Function: listener] ]
         * }
         * {
         *   const et = new EventTarget();
         *   const listener = () => console.log('Events are fun');
         *   et.addEventListener('foo', listener);
         *   console.log(getEventListeners(et, 'foo')); // [ [Function: listener] ]
         * }
         * ```
         * @since v15.2.0, v14.17.0
         */
        static getEventListeners(emitter: EventTarget | NodeJS.EventEmitter, name: string | symbol): Function[];
        /**
         * Returns the currently set max amount of listeners.
         *
         * For `EventEmitter`s this behaves exactly the same as calling `.getMaxListeners` on
         * the emitter.
         *
         * For `EventTarget`s this is the only way to get the max event listeners for the
         * event target. If the number of event handlers on a single EventTarget exceeds
         * the max set, the EventTarget will print a warning.
         *
         * ```js
         * import { getMaxListeners, setMaxListeners, EventEmitter } from 'node:events';
         *
         * {
         *   const ee = new EventEmitter();
         *   console.log(getMaxListeners(ee)); // 10
         *   setMaxListeners(11, ee);
         *   console.log(getMaxListeners(ee)); // 11
         * }
         * {
         *   const et = new EventTarget();
         *   console.log(getMaxListeners(et)); // 10
         *   setMaxListeners(11, et);
         *   console.log(getMaxListeners(et)); // 11
         * }
         * ```
         * @since v19.9.0
         */
        static getMaxListeners(emitter: EventTarget | NodeJS.EventEmitter): number;
        /**
         * ```js
         * import { setMaxListeners, EventEmitter } from 'node:events';
         *
         * const target = new EventTarget();
         * const emitter = new EventEmitter();
         *
         * setMaxListeners(5, target, emitter);
         * ```
         * @since v15.4.0
         * @param n A non-negative number. The maximum number of listeners per `EventTarget` event.
         * @param eventTargets Zero or more {EventTarget} or {EventEmitter} instances. If none are specified, `n` is set as the default max for all newly created {EventTarget} and {EventEmitter}
         * objects.
         */
        static setMaxListeners(n?: number, ...eventTargets: Array<EventTarget | NodeJS.EventEmitter>): void;
        /**
         * Listens once to the `abort` event on the provided `signal`.
         *
         * Listening to the `abort` event on abort signals is unsafe and may
         * lead to resource leaks since another third party with the signal can
         * call `e.stopImmediatePropagation()`. Unfortunately Node.js cannot change
         * this since it would violate the web standard. Additionally, the original
         * API makes it easy to forget to remove listeners.
         *
         * This API allows safely using `AbortSignal`s in Node.js APIs by solving these
         * two issues by listening to the event such that `stopImmediatePropagation` does
         * not prevent the listener from running.
         *
         * Returns a disposable so that it may be unsubscribed from more easily.
         *
         * ```js
         * import { addAbortListener } from 'node:events';
         *
         * function example(signal) {
         *   let disposable;
         *   try {
         *     signal.addEventListener('abort', (e) => e.stopImmediatePropagation());
         *     disposable = addAbortListener(signal, (e) => {
         *       // Do something when signal is aborted.
         *     });
         *   } finally {
         *     disposable?.[Symbol.dispose]();
         *   }
         * }
         * ```
         * @since v20.5.0
         * @return Disposable that removes the `abort` listener.
         */
        static addAbortListener(signal: AbortSignal, resource: (event: Event) => void): Disposable;
        /**
         * This symbol shall be used to install a listener for only monitoring `'error'` events. Listeners installed using this symbol are called before the regular `'error'` listeners are called.
         *
         * Installing a listener using this symbol does not change the behavior once an `'error'` event is emitted. Therefore, the process will still crash if no
         * regular `'error'` listener is installed.
         * @since v13.6.0, v12.17.0
         */
        static readonly errorMonitor: unique symbol;
        /**
         * Value: `Symbol.for('nodejs.rejection')`
         *
         * See how to write a custom `rejection handler`.
         * @since v13.4.0, v12.16.0
         */
        static readonly captureRejectionSymbol: unique symbol;
        /**
         * Value: [boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)
         *
         * Change the default `captureRejections` option on all new `EventEmitter` objects.
         * @since v13.4.0, v12.16.0
         */
        static captureRejections: boolean;
        /**
         * By default, a maximum of `10` listeners can be registered for any single
         * event. This limit can be changed for individual `EventEmitter` instances
         * using the `emitter.setMaxListeners(n)` method. To change the default
         * for _all_`EventEmitter` instances, the `events.defaultMaxListeners` property
         * can be used. If this value is not a positive number, a `RangeError` is thrown.
         *
         * Take caution when setting the `events.defaultMaxListeners` because the
         * change affects _all_ `EventEmitter` instances, including those created before
         * the change is made. However, calling `emitter.setMaxListeners(n)` still has
         * precedence over `events.defaultMaxListeners`.
         *
         * This is not a hard limit. The `EventEmitter` instance will allow
         * more listeners to be added but will output a trace warning to stderr indicating
         * that a "possible EventEmitter memory leak" has been detected. For any single
         * `EventEmitter`, the `emitter.getMaxListeners()` and `emitter.setMaxListeners()` methods can be used to
         * temporarily avoid this warning:
         *
         * ```js
         * import { EventEmitter } from 'node:events';
         * const emitter = new EventEmitter();
         * emitter.setMaxListeners(emitter.getMaxListeners() + 1);
         * emitter.once('event', () => {
         *   // do stuff
         *   emitter.setMaxListeners(Math.max(emitter.getMaxListeners() - 1, 0));
         * });
         * ```
         *
         * The `--trace-warnings` command-line flag can be used to display the
         * stack trace for such warnings.
         *
         * The emitted warning can be inspected with `process.on('warning')` and will
         * have the additional `emitter`, `type`, and `count` properties, referring to
         * the event emitter instance, the event's name and the number of attached
         * listeners, respectively.
         * Its `name` property is set to `'MaxListenersExceededWarning'`.
         * @since v0.11.2
         */
        static defaultMaxListeners: number;
    }
    import internal = require("node:events");
    namespace EventEmitter {
        // Should just be `export { EventEmitter }`, but that doesn't work in TypeScript 3.4
        export { internal as EventEmitter };
        export interface Abortable {
            /**
             * When provided the corresponding `AbortController` can be used to cancel an asynchronous action.
             */
            signal?: AbortSignal | undefined;
        }

        export interface EventEmitterReferencingAsyncResource extends AsyncResource {
            readonly eventEmitter: EventEmitterAsyncResource;
        }

        export interface EventEmitterAsyncResourceOptions extends AsyncResourceOptions, EventEmitterOptions {
            /**
             * The type of async event, this is required when instantiating `EventEmitterAsyncResource`
             * directly rather than as a child class.
             * @default new.target.name if instantiated as a child class.
             */
            name?: string | undefined;
        }

        /**
         * Integrates `EventEmitter` with `AsyncResource` for `EventEmitter`s that
         * require manual async tracking. Specifically, all events emitted by instances
         * of `events.EventEmitterAsyncResource` will run within its `async context`.
         *
         * ```js
         * import { EventEmitterAsyncResource, EventEmitter } from 'node:events';
         * import { notStrictEqual, strictEqual } from 'node:assert';
         * import { executionAsyncId, triggerAsyncId } from 'node:async_hooks';
         *
         * // Async tracking tooling will identify this as 'Q'.
         * const ee1 = new EventEmitterAsyncResource({ name: 'Q' });
         *
         * // 'foo' listeners will run in the EventEmitters async context.
         * ee1.on('foo', () => {
         *   strictEqual(executionAsyncId(), ee1.asyncId);
         *   strictEqual(triggerAsyncId(), ee1.triggerAsyncId);
         * });
         *
         * const ee2 = new EventEmitter();
         *
         * // 'foo' listeners on ordinary EventEmitters that do not track async
         * // context, however, run in the same async context as the emit().
         * ee2.on('foo', () => {
         *   notStrictEqual(executionAsyncId(), ee2.asyncId);
         *   notStrictEqual(triggerAsyncId(), ee2.triggerAsyncId);
         * });
         *
         * Promise.resolve().then(() => {
         *   ee1.emit('foo');
         *   ee2.emit('foo');
         * });
         * ```
         *
         * The `EventEmitterAsyncResource` class has the same methods and takes the
         * same options as `EventEmitter` and `AsyncResource` themselves.
         * @since v17.4.0, v16.14.0
         */
        export class EventEmitterAsyncResource extends EventEmitter {
            /**
             * @param options Only optional in child class.
             */
            constructor(options?: EventEmitterAsyncResourceOptions);
            /**
             * Call all `destroy` hooks. This should only ever be called once. An error will
             * be thrown if it is called more than once. This **must** be manually called. If
             * the resource is left to be collected by the GC then the `destroy` hooks will
             * never be called.
             */
            emitDestroy(): void;
            /**
             * The unique `asyncId` assigned to the resource.
             */
            readonly asyncId: number;
            /**
             * The same triggerAsyncId that is passed to the AsyncResource constructor.
             */
            readonly triggerAsyncId: number;
            /**
             * The returned `AsyncResource` object has an additional `eventEmitter` property
             * that provides a reference to this `EventEmitterAsyncResource`.
             */
            readonly asyncResource: EventEmitterReferencingAsyncResource;
        }
        /**
         * The `NodeEventTarget` is a Node.js-specific extension to `EventTarget`
         * that emulates a subset of the `EventEmitter` API.
         * @since v14.5.0
         */
        export interface NodeEventTarget extends EventTarget {
            /**
             * Node.js-specific extension to the `EventTarget` class that emulates the
             * equivalent `EventEmitter` API. The only difference between `addListener()` and
             * `addEventListener()` is that `addListener()` will return a reference to the
             * `EventTarget`.
             * @since v14.5.0
             */
            addListener(type: string, listener: (arg: any) => void): this;
            /**
             * Node.js-specific extension to the `EventTarget` class that dispatches the
             * `arg` to the list of handlers for `type`.
             * @since v15.2.0
             * @returns `true` if event listeners registered for the `type` exist,
             * otherwise `false`.
             */
            emit(type: string, arg: any): boolean;
            /**
             * Node.js-specific extension to the `EventTarget` class that returns an array
             * of event `type` names for which event listeners are registered.
             * @since 14.5.0
             */
            eventNames(): string[];
            /**
             * Node.js-specific extension to the `EventTarget` class that returns the number
             * of event listeners registered for the `type`.
             * @since v14.5.0
             */
            listenerCount(type: string): number;
            /**
             * Node.js-specific extension to the `EventTarget` class that sets the number
             * of max event listeners as `n`.
             * @since v14.5.0
             */
            setMaxListeners(n: number): void;
            /**
             * Node.js-specific extension to the `EventTarget` class that returns the number
             * of max event listeners.
             * @since v14.5.0
             */
            getMaxListeners(): number;
            /**
             * Node.js-specific alias for `eventTarget.removeEventListener()`.
             * @since v14.5.0
             */
            off(type: string, listener: (arg: any) => void, options?: EventListenerOptions): this;
            /**
             * Node.js-specific alias for `eventTarget.addEventListener()`.
             * @since v14.5.0
             */
            on(type: string, listener: (arg: any) => void): this;
            /**
             * Node.js-specific extension to the `EventTarget` class that adds a `once`
             * listener for the given event `type`. This is equivalent to calling `on`
             * with the `once` option set to `true`.
             * @since v14.5.0
             */
            once(type: string, listener: (arg: any) => void): this;
            /**
             * Node.js-specific extension to the `EventTarget` class. If `type` is specified,
             * removes all registered listeners for `type`, otherwise removes all registered
             * listeners.
             * @since v14.5.0
             */
            removeAllListeners(type?: string): this;
            /**
             * Node.js-specific extension to the `EventTarget` class that removes the
             * `listener` for the given `type`. The only difference between `removeListener()`
             * and `removeEventListener()` is that `removeListener()` will return a reference
             * to the `EventTarget`.
             * @since v14.5.0
             */
            removeListener(type: string, listener: (arg: any) => void, options?: EventListenerOptions): this;
        }
    }
    global {
        namespace NodeJS {
            interface EventEmitter<T extends EventMap<T> = DefaultEventMap> {
                [EventEmitter.captureRejectionSymbol]?<K>(error: Error, event: Key<K, T>, ...args: Args<K, T>): void;
                /**
                 * Alias for `emitter.on(eventName, listener)`.
                 * @since v0.1.26
                 */
                addListener<K>(eventName: Key<K, T>, listener: Listener1<K, T>): this;
                /**
                 * Adds the `listener` function to the end of the listeners array for the event
                 * named `eventName`. No checks are made to see if the `listener` has already
                 * been added. Multiple calls passing the same combination of `eventName` and
                 * `listener` will result in the `listener` being added, and called, multiple times.
                 *
                 * ```js
                 * server.on('connection', (stream) => {
                 *   console.log('someone connected!');
                 * });
                 * ```
                 *
                 * Returns a reference to the `EventEmitter`, so that calls can be chained.
                 *
                 * By default, event listeners are invoked in the order they are added. The `emitter.prependListener()` method can be used as an alternative to add the
                 * event listener to the beginning of the listeners array.
                 *
                 * ```js
                 * import { EventEmitter } from 'node:events';
                 * const myEE = new EventEmitter();
                 * myEE.on('foo', () => console.log('a'));
                 * myEE.prependListener('foo', () => console.log('b'));
                 * myEE.emit('foo');
                 * // Prints:
                 * //   b
                 * //   a
                 * ```
                 * @since v0.1.101
                 * @param eventName The name of the event.
                 * @param listener The callback function
                 */
                on<K>(eventName: Key<K, T>, listener: Listener1<K, T>): this;
                /**
                 * Adds a **one-time** `listener` function for the event named `eventName`. The
                 * next time `eventName` is triggered, this listener is removed and then invoked.
                 *
                 * ```js
                 * server.once('connection', (stream) => {
                 *   console.log('Ah, we have our first user!');
                 * });
                 * ```
                 *
                 * Returns a reference to the `EventEmitter`, so that calls can be chained.
                 *
                 * By default, event listeners are invoked in the order they are added. The `emitter.prependOnceListener()` method can be used as an alternative to add the
                 * event listener to the beginning of the listeners array.
                 *
                 * ```js
                 * import { EventEmitter } from 'node:events';
                 * const myEE = new EventEmitter();
                 * myEE.once('foo', () => console.log('a'));
                 * myEE.prependOnceListener('foo', () => console.log('b'));
                 * myEE.emit('foo');
                 * // Prints:
                 * //   b
                 * //   a
                 * ```
                 * @since v0.3.0
                 * @param eventName The name of the event.
                 * @param listener The callback function
                 */
                once<K>(eventName: Key<K, T>, listener: Listener1<K, T>): this;
                /**
                 * Removes the specified `listener` from the listener array for the event named `eventName`.
                 *
                 * ```js
                 * const callback = (stream) => {
                 *   console.log('someone connected!');
                 * };
                 * server.on('connection', callback);
                 * // ...
                 * server.removeListener('connection', callback);
                 * ```
                 *
                 * `removeListener()` will remove, at most, one instance of a listener from the
                 * listener array. If any single listener has been added multiple times to the
                 * listener array for the specified `eventName`, then `removeListener()` must be
                 * called multiple times to remove each instance.
                 *
                 * Once an event is emitted, all listeners attached to it at the
                 * time of emitting are called in order. This implies that any `removeListener()` or `removeAllListeners()` calls _after_ emitting and _before_ the last listener finishes execution
                 * will not remove them from`emit()` in progress. Subsequent events behave as expected.
                 *
                 * ```js
                 * import { EventEmitter } from 'node:events';
                 * class MyEmitter extends EventEmitter {}
                 * const myEmitter = new MyEmitter();
                 *
                 * const callbackA = () => {
                 *   console.log('A');
                 *   myEmitter.removeListener('event', callbackB);
                 * };
                 *
                 * const callbackB = () => {
                 *   console.log('B');
                 * };
                 *
                 * myEmitter.on('event', callbackA);
                 *
                 * myEmitter.on('event', callbackB);
                 *
                 * // callbackA removes listener callbackB but it will still be called.
                 * // Internal listener array at time of emit [callbackA, callbackB]
                 * myEmitter.emit('event');
                 * // Prints:
                 * //   A
                 * //   B
                 *
                 * // callbackB is now removed.
                 * // Internal listener array [callbackA]
                 * myEmitter.emit('event');
                 * // Prints:
                 * //   A
                 * ```
                 *
                 * Because listeners are managed using an internal array, calling this will
                 * change the position indices of any listener registered _after_ the listener
                 * being removed. This will not impact the order in which listeners are called,
                 * but it means that any copies of the listener array as returned by
                 * the `emitter.listeners()` method will need to be recreated.
                 *
                 * When a single function has been added as a handler multiple times for a single
                 * event (as in the example below), `removeListener()` will remove the most
                 * recently added instance. In the example the `once('ping')` listener is removed:
                 *
                 * ```js
                 * import { EventEmitter } from 'node:events';
                 * const ee = new EventEmitter();
                 *
                 * function pong() {
                 *   console.log('pong');
                 * }
                 *
                 * ee.on('ping', pong);
                 * ee.once('ping', pong);
                 * ee.removeListener('ping', pong);
                 *
                 * ee.emit('ping');
                 * ee.emit('ping');
                 * ```
                 *
                 * Returns a reference to the `EventEmitter`, so that calls can be chained.
                 * @since v0.1.26
                 */
                removeListener<K>(eventName: Key<K, T>, listener: Listener1<K, T>): this;
                /**
                 * Alias for `emitter.removeListener()`.
                 * @since v10.0.0
                 */
                off<K>(eventName: Key<K, T>, listener: Listener1<K, T>): this;
                /**
                 * Removes all listeners, or those of the specified `eventName`.
                 *
                 * It is bad practice to remove listeners added elsewhere in the code,
                 * particularly when the `EventEmitter` instance was created by some other
                 * component or module (e.g. sockets or file streams).
                 *
                 * Returns a reference to the `EventEmitter`, so that calls can be chained.
                 * @since v0.1.26
                 */
                removeAllListeners(eventName?: Key<unknown, T>): this;
                /**
                 * By default `EventEmitter`s will print a warning if more than `10` listeners are
                 * added for a particular event. This is a useful default that helps finding
                 * memory leaks. The `emitter.setMaxListeners()` method allows the limit to be
                 * modified for this specific `EventEmitter` instance. The value can be set to `Infinity` (or `0`) to indicate an unlimited number of listeners.
                 *
                 * Returns a reference to the `EventEmitter`, so that calls can be chained.
                 * @since v0.3.5
                 */
                setMaxListeners(n: number): this;
                /**
                 * Returns the current max listener value for the `EventEmitter` which is either
                 * set by `emitter.setMaxListeners(n)` or defaults to {@link EventEmitter.defaultMaxListeners}.
                 * @since v1.0.0
                 */
                getMaxListeners(): number;
                /**
                 * Returns a copy of the array of listeners for the event named `eventName`.
                 *
                 * ```js
                 * server.on('connection', (stream) => {
                 *   console.log('someone connected!');
                 * });
                 * console.log(util.inspect(server.listeners('connection')));
                 * // Prints: [ [Function] ]
                 * ```
                 * @since v0.1.26
                 */
                listeners<K>(eventName: Key<K, T>): Array<Listener2<K, T>>;
                /**
                 * Returns a copy of the array of listeners for the event named `eventName`,
                 * including any wrappers (such as those created by `.once()`).
                 *
                 * ```js
                 * import { EventEmitter } from 'node:events';
                 * const emitter = new EventEmitter();
                 * emitter.once('log', () => console.log('log once'));
                 *
                 * // Returns a new Array with a function `onceWrapper` which has a property
                 * // `listener` which contains the original listener bound above
                 * const listeners = emitter.rawListeners('log');
                 * const logFnWrapper = listeners[0];
                 *
                 * // Logs "log once" to the console and does not unbind the `once` event
                 * logFnWrapper.listener();
                 *
                 * // Logs "log once" to the console and removes the listener
                 * logFnWrapper();
                 *
                 * emitter.on('log', () => console.log('log persistently'));
                 * // Will return a new Array with a single function bound by `.on()` above
                 * const newListeners = emitter.rawListeners('log');
                 *
                 * // Logs "log persistently" twice
                 * newListeners[0]();
                 * emitter.emit('log');
                 * ```
                 * @since v9.4.0
                 */
                rawListeners<K>(eventName: Key<K, T>): Array<Listener2<K, T>>;
                /**
                 * Synchronously calls each of the listeners registered for the event named `eventName`, in the order they were registered, passing the supplied arguments
                 * to each.
                 *
                 * Returns `true` if the event had listeners, `false` otherwise.
                 *
                 * ```js
                 * import { EventEmitter } from 'node:events';
                 * const myEmitter = new EventEmitter();
                 *
                 * // First listener
                 * myEmitter.on('event', function firstListener() {
                 *   console.log('Helloooo! first listener');
                 * });
                 * // Second listener
                 * myEmitter.on('event', function secondListener(arg1, arg2) {
                 *   console.log(`event with parameters ${arg1}, ${arg2} in second listener`);
                 * });
                 * // Third listener
                 * myEmitter.on('event', function thirdListener(...args) {
                 *   const parameters = args.join(', ');
                 *   console.log(`event with parameters ${parameters} in third listener`);
                 * });
                 *
                 * console.log(myEmitter.listeners('event'));
                 *
                 * myEmitter.emit('event', 1, 2, 3, 4, 5);
                 *
                 * // Prints:
                 * // [
                 * //   [Function: firstListener],
                 * //   [Function: secondListener],
                 * //   [Function: thirdListener]
                 * // ]
                 * // Helloooo! first listener
                 * // event with parameters 1, 2 in second listener
                 * // event with parameters 1, 2, 3, 4, 5 in third listener
                 * ```
                 * @since v0.1.26
                 */
                emit<K>(eventName: Key<K, T>, ...args: Args<K, T>): boolean;
                /**
                 * Returns the number of listeners listening for the event named `eventName`.
                 * If `listener` is provided, it will return how many times the listener is found
                 * in the list of the listeners of the event.
                 * @since v3.2.0
                 * @param eventName The name of the event being listened for
                 * @param listener The event handler function
                 */
                listenerCount<K>(eventName: Key<K, T>, listener?: Listener2<K, T>): number;
                /**
                 * Adds the `listener` function to the _beginning_ of the listeners array for the
                 * event named `eventName`. No checks are made to see if the `listener` has
                 * already been added. Multiple calls passing the same combination of `eventName`
                 * and `listener` will result in the `listener` being added, and called, multiple times.
                 *
                 * ```js
                 * server.prependListener('connection', (stream) => {
                 *   console.log('someone connected!');
                 * });
                 * ```
                 *
                 * Returns a reference to the `EventEmitter`, so that calls can be chained.
                 * @since v6.0.0
                 * @param eventName The name of the event.
                 * @param listener The callback function
                 */
                prependListener<K>(eventName: Key<K, T>, listener: Listener1<K, T>): this;
                /**
                 * Adds a **one-time**`listener` function for the event named `eventName` to the _beginning_ of the listeners array. The next time `eventName` is triggered, this
                 * listener is removed, and then invoked.
                 *
                 * ```js
                 * server.prependOnceListener('connection', (stream) => {
                 *   console.log('Ah, we have our first user!');
                 * });
                 * ```
                 *
                 * Returns a reference to the `EventEmitter`, so that calls can be chained.
                 * @since v6.0.0
                 * @param eventName The name of the event.
                 * @param listener The callback function
                 */
                prependOnceListener<K>(eventName: Key<K, T>, listener: Listener1<K, T>): this;
                /**
                 * Returns an array listing the events for which the emitter has registered
                 * listeners. The values in the array are strings or `Symbol`s.
                 *
                 * ```js
                 * import { EventEmitter } from 'node:events';
                 *
                 * const myEE = new EventEmitter();
                 * myEE.on('foo', () => {});
                 * myEE.on('bar', () => {});
                 *
                 * const sym = Symbol('symbol');
                 * myEE.on(sym, () => {});
                 *
                 * console.log(myEE.eventNames());
                 * // Prints: [ 'foo', 'bar', Symbol(symbol) ]
                 * ```
                 * @since v6.0.0
                 */
                eventNames(): Array<(string | symbol) & Key2<unknown, T>>;
            }
        }
    }
    export = EventEmitter;
}
declare module "node:events" {
    import events = require("events");
    export = events;
}

```

## ./lib/lambda/node_modules/@types/node/fs.d.ts

```typescript
/**
 * The `node:fs` module enables interacting with the file system in a
 * way modeled on standard POSIX functions.
 *
 * To use the promise-based APIs:
 *
 * ```js
 * import * as fs from 'node:fs/promises';
 * ```
 *
 * To use the callback and sync APIs:
 *
 * ```js
 * import * as fs from 'node:fs';
 * ```
 *
 * All file system operations have synchronous, callback, and promise-based
 * forms, and are accessible using both CommonJS syntax and ES6 Modules (ESM).
 * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/fs.js)
 */
declare module "fs" {
    import * as stream from "node:stream";
    import { Abortable, EventEmitter } from "node:events";
    import { URL } from "node:url";
    import * as promises from "node:fs/promises";
    export { promises };
    /**
     * Valid types for path values in "fs".
     */
    export type PathLike = string | Buffer | URL;
    export type PathOrFileDescriptor = PathLike | number;
    export type TimeLike = string | number | Date;
    export type NoParamCallback = (err: NodeJS.ErrnoException | null) => void;
    export type BufferEncodingOption =
        | "buffer"
        | {
            encoding: "buffer";
        };
    export interface ObjectEncodingOptions {
        encoding?: BufferEncoding | null | undefined;
    }
    export type EncodingOption = ObjectEncodingOptions | BufferEncoding | undefined | null;
    export type OpenMode = number | string;
    export type Mode = number | string;
    export interface StatsBase<T> {
        isFile(): boolean;
        isDirectory(): boolean;
        isBlockDevice(): boolean;
        isCharacterDevice(): boolean;
        isSymbolicLink(): boolean;
        isFIFO(): boolean;
        isSocket(): boolean;
        dev: T;
        ino: T;
        mode: T;
        nlink: T;
        uid: T;
        gid: T;
        rdev: T;
        size: T;
        blksize: T;
        blocks: T;
        atimeMs: T;
        mtimeMs: T;
        ctimeMs: T;
        birthtimeMs: T;
        atime: Date;
        mtime: Date;
        ctime: Date;
        birthtime: Date;
    }
    export interface Stats extends StatsBase<number> {}
    /**
     * A `fs.Stats` object provides information about a file.
     *
     * Objects returned from {@link stat}, {@link lstat}, {@link fstat}, and
     * their synchronous counterparts are of this type.
     * If `bigint` in the `options` passed to those methods is true, the numeric values
     * will be `bigint` instead of `number`, and the object will contain additional
     * nanosecond-precision properties suffixed with `Ns`. `Stat` objects are not to be created directly using the `new` keyword.
     *
     * ```console
     * Stats {
     *   dev: 2114,
     *   ino: 48064969,
     *   mode: 33188,
     *   nlink: 1,
     *   uid: 85,
     *   gid: 100,
     *   rdev: 0,
     *   size: 527,
     *   blksize: 4096,
     *   blocks: 8,
     *   atimeMs: 1318289051000.1,
     *   mtimeMs: 1318289051000.1,
     *   ctimeMs: 1318289051000.1,
     *   birthtimeMs: 1318289051000.1,
     *   atime: Mon, 10 Oct 2011 23:24:11 GMT,
     *   mtime: Mon, 10 Oct 2011 23:24:11 GMT,
     *   ctime: Mon, 10 Oct 2011 23:24:11 GMT,
     *   birthtime: Mon, 10 Oct 2011 23:24:11 GMT }
     * ```
     *
     * `bigint` version:
     *
     * ```console
     * BigIntStats {
     *   dev: 2114n,
     *   ino: 48064969n,
     *   mode: 33188n,
     *   nlink: 1n,
     *   uid: 85n,
     *   gid: 100n,
     *   rdev: 0n,
     *   size: 527n,
     *   blksize: 4096n,
     *   blocks: 8n,
     *   atimeMs: 1318289051000n,
     *   mtimeMs: 1318289051000n,
     *   ctimeMs: 1318289051000n,
     *   birthtimeMs: 1318289051000n,
     *   atimeNs: 1318289051000000000n,
     *   mtimeNs: 1318289051000000000n,
     *   ctimeNs: 1318289051000000000n,
     *   birthtimeNs: 1318289051000000000n,
     *   atime: Mon, 10 Oct 2011 23:24:11 GMT,
     *   mtime: Mon, 10 Oct 2011 23:24:11 GMT,
     *   ctime: Mon, 10 Oct 2011 23:24:11 GMT,
     *   birthtime: Mon, 10 Oct 2011 23:24:11 GMT }
     * ```
     * @since v0.1.21
     */
    export class Stats {
        private constructor();
    }
    export interface StatsFsBase<T> {
        /** Type of file system. */
        type: T;
        /**  Optimal transfer block size. */
        bsize: T;
        /**  Total data blocks in file system. */
        blocks: T;
        /** Free blocks in file system. */
        bfree: T;
        /** Available blocks for unprivileged users */
        bavail: T;
        /** Total file nodes in file system. */
        files: T;
        /** Free file nodes in file system. */
        ffree: T;
    }
    export interface StatsFs extends StatsFsBase<number> {}
    /**
     * Provides information about a mounted file system.
     *
     * Objects returned from {@link statfs} and its synchronous counterpart are of
     * this type. If `bigint` in the `options` passed to those methods is `true`, the
     * numeric values will be `bigint` instead of `number`.
     *
     * ```console
     * StatFs {
     *   type: 1397114950,
     *   bsize: 4096,
     *   blocks: 121938943,
     *   bfree: 61058895,
     *   bavail: 61058895,
     *   files: 999,
     *   ffree: 1000000
     * }
     * ```
     *
     * `bigint` version:
     *
     * ```console
     * StatFs {
     *   type: 1397114950n,
     *   bsize: 4096n,
     *   blocks: 121938943n,
     *   bfree: 61058895n,
     *   bavail: 61058895n,
     *   files: 999n,
     *   ffree: 1000000n
     * }
     * ```
     * @since v19.6.0, v18.15.0
     */
    export class StatsFs {}
    export interface BigIntStatsFs extends StatsFsBase<bigint> {}
    export interface StatFsOptions {
        bigint?: boolean | undefined;
    }
    /**
     * A representation of a directory entry, which can be a file or a subdirectory
     * within the directory, as returned by reading from an `fs.Dir`. The
     * directory entry is a combination of the file name and file type pairs.
     *
     * Additionally, when {@link readdir} or {@link readdirSync} is called with
     * the `withFileTypes` option set to `true`, the resulting array is filled with `fs.Dirent` objects, rather than strings or `Buffer` s.
     * @since v10.10.0
     */
    export class Dirent<Name extends string | Buffer = string> {
        /**
         * Returns `true` if the `fs.Dirent` object describes a regular file.
         * @since v10.10.0
         */
        isFile(): boolean;
        /**
         * Returns `true` if the `fs.Dirent` object describes a file system
         * directory.
         * @since v10.10.0
         */
        isDirectory(): boolean;
        /**
         * Returns `true` if the `fs.Dirent` object describes a block device.
         * @since v10.10.0
         */
        isBlockDevice(): boolean;
        /**
         * Returns `true` if the `fs.Dirent` object describes a character device.
         * @since v10.10.0
         */
        isCharacterDevice(): boolean;
        /**
         * Returns `true` if the `fs.Dirent` object describes a symbolic link.
         * @since v10.10.0
         */
        isSymbolicLink(): boolean;
        /**
         * Returns `true` if the `fs.Dirent` object describes a first-in-first-out
         * (FIFO) pipe.
         * @since v10.10.0
         */
        isFIFO(): boolean;
        /**
         * Returns `true` if the `fs.Dirent` object describes a socket.
         * @since v10.10.0
         */
        isSocket(): boolean;
        /**
         * The file name that this `fs.Dirent` object refers to. The type of this
         * value is determined by the `options.encoding` passed to {@link readdir} or {@link readdirSync}.
         * @since v10.10.0
         */
        name: Name;
        /**
         * The path to the parent directory of the file this `fs.Dirent` object refers to.
         * @since v20.12.0, v18.20.0
         */
        parentPath: string;
        /**
         * Alias for `dirent.parentPath`.
         * @since v20.1.0
         * @deprecated Since v20.12.0
         */
        path: string;
    }
    /**
     * A class representing a directory stream.
     *
     * Created by {@link opendir}, {@link opendirSync}, or `fsPromises.opendir()`.
     *
     * ```js
     * import { opendir } from 'node:fs/promises';
     *
     * try {
     *   const dir = await opendir('./');
     *   for await (const dirent of dir)
     *     console.log(dirent.name);
     * } catch (err) {
     *   console.error(err);
     * }
     * ```
     *
     * When using the async iterator, the `fs.Dir` object will be automatically
     * closed after the iterator exits.
     * @since v12.12.0
     */
    export class Dir implements AsyncIterable<Dirent> {
        /**
         * The read-only path of this directory as was provided to {@link opendir},{@link opendirSync}, or `fsPromises.opendir()`.
         * @since v12.12.0
         */
        readonly path: string;
        /**
         * Asynchronously iterates over the directory via `readdir(3)` until all entries have been read.
         */
        [Symbol.asyncIterator](): NodeJS.AsyncIterator<Dirent>;
        /**
         * Asynchronously close the directory's underlying resource handle.
         * Subsequent reads will result in errors.
         *
         * A promise is returned that will be fulfilled after the resource has been
         * closed.
         * @since v12.12.0
         */
        close(): Promise<void>;
        close(cb: NoParamCallback): void;
        /**
         * Synchronously close the directory's underlying resource handle.
         * Subsequent reads will result in errors.
         * @since v12.12.0
         */
        closeSync(): void;
        /**
         * Asynchronously read the next directory entry via [`readdir(3)`](http://man7.org/linux/man-pages/man3/readdir.3.html) as an `fs.Dirent`.
         *
         * A promise is returned that will be fulfilled with an `fs.Dirent`, or `null` if there are no more directory entries to read.
         *
         * Directory entries returned by this function are in no particular order as
         * provided by the operating system's underlying directory mechanisms.
         * Entries added or removed while iterating over the directory might not be
         * included in the iteration results.
         * @since v12.12.0
         * @return containing {fs.Dirent|null}
         */
        read(): Promise<Dirent | null>;
        read(cb: (err: NodeJS.ErrnoException | null, dirEnt: Dirent | null) => void): void;
        /**
         * Synchronously read the next directory entry as an `fs.Dirent`. See the
         * POSIX [`readdir(3)`](http://man7.org/linux/man-pages/man3/readdir.3.html) documentation for more detail.
         *
         * If there are no more directory entries to read, `null` will be returned.
         *
         * Directory entries returned by this function are in no particular order as
         * provided by the operating system's underlying directory mechanisms.
         * Entries added or removed while iterating over the directory might not be
         * included in the iteration results.
         * @since v12.12.0
         */
        readSync(): Dirent | null;
        /**
         * Calls `dir.close()` if the directory handle is open, and returns a promise that
         * fulfills when disposal is complete.
         * @since v22.17.0
         * @experimental
         */
        [Symbol.asyncDispose](): Promise<void>;
        /**
         * Calls `dir.closeSync()` if the directory handle is open, and returns
         * `undefined`.
         * @since v22.17.0
         * @experimental
         */
        [Symbol.dispose](): void;
    }
    /**
     * Class: fs.StatWatcher
     * @since v14.3.0, v12.20.0
     * Extends `EventEmitter`
     * A successful call to {@link watchFile} method will return a new fs.StatWatcher object.
     */
    export interface StatWatcher extends EventEmitter {
        /**
         * When called, requests that the Node.js event loop _not_ exit so long as the `fs.StatWatcher` is active. Calling `watcher.ref()` multiple times will have
         * no effect.
         *
         * By default, all `fs.StatWatcher` objects are "ref'ed", making it normally
         * unnecessary to call `watcher.ref()` unless `watcher.unref()` had been
         * called previously.
         * @since v14.3.0, v12.20.0
         */
        ref(): this;
        /**
         * When called, the active `fs.StatWatcher` object will not require the Node.js
         * event loop to remain active. If there is no other activity keeping the
         * event loop running, the process may exit before the `fs.StatWatcher` object's
         * callback is invoked. Calling `watcher.unref()` multiple times will have
         * no effect.
         * @since v14.3.0, v12.20.0
         */
        unref(): this;
    }
    export interface FSWatcher extends EventEmitter {
        /**
         * Stop watching for changes on the given `fs.FSWatcher`. Once stopped, the `fs.FSWatcher` object is no longer usable.
         * @since v0.5.8
         */
        close(): void;
        /**
         * When called, requests that the Node.js event loop _not_ exit so long as the `fs.FSWatcher` is active. Calling `watcher.ref()` multiple times will have
         * no effect.
         *
         * By default, all `fs.FSWatcher` objects are "ref'ed", making it normally
         * unnecessary to call `watcher.ref()` unless `watcher.unref()` had been
         * called previously.
         * @since v14.3.0, v12.20.0
         */
        ref(): this;
        /**
         * When called, the active `fs.FSWatcher` object will not require the Node.js
         * event loop to remain active. If there is no other activity keeping the
         * event loop running, the process may exit before the `fs.FSWatcher` object's
         * callback is invoked. Calling `watcher.unref()` multiple times will have
         * no effect.
         * @since v14.3.0, v12.20.0
         */
        unref(): this;
        /**
         * events.EventEmitter
         *   1. change
         *   2. close
         *   3. error
         */
        addListener(event: string, listener: (...args: any[]) => void): this;
        addListener(event: "change", listener: (eventType: string, filename: string | Buffer) => void): this;
        addListener(event: "close", listener: () => void): this;
        addListener(event: "error", listener: (error: Error) => void): this;
        on(event: string, listener: (...args: any[]) => void): this;
        on(event: "change", listener: (eventType: string, filename: string | Buffer) => void): this;
        on(event: "close", listener: () => void): this;
        on(event: "error", listener: (error: Error) => void): this;
        once(event: string, listener: (...args: any[]) => void): this;
        once(event: "change", listener: (eventType: string, filename: string | Buffer) => void): this;
        once(event: "close", listener: () => void): this;
        once(event: "error", listener: (error: Error) => void): this;
        prependListener(event: string, listener: (...args: any[]) => void): this;
        prependListener(event: "change", listener: (eventType: string, filename: string | Buffer) => void): this;
        prependListener(event: "close", listener: () => void): this;
        prependListener(event: "error", listener: (error: Error) => void): this;
        prependOnceListener(event: string, listener: (...args: any[]) => void): this;
        prependOnceListener(event: "change", listener: (eventType: string, filename: string | Buffer) => void): this;
        prependOnceListener(event: "close", listener: () => void): this;
        prependOnceListener(event: "error", listener: (error: Error) => void): this;
    }
    /**
     * Instances of `fs.ReadStream` are created and returned using the {@link createReadStream} function.
     * @since v0.1.93
     */
    export class ReadStream extends stream.Readable {
        close(callback?: (err?: NodeJS.ErrnoException | null) => void): void;
        /**
         * The number of bytes that have been read so far.
         * @since v6.4.0
         */
        bytesRead: number;
        /**
         * The path to the file the stream is reading from as specified in the first
         * argument to `fs.createReadStream()`. If `path` is passed as a string, then`readStream.path` will be a string. If `path` is passed as a `Buffer`, then`readStream.path` will be a
         * `Buffer`. If `fd` is specified, then`readStream.path` will be `undefined`.
         * @since v0.1.93
         */
        path: string | Buffer;
        /**
         * This property is `true` if the underlying file has not been opened yet,
         * i.e. before the `'ready'` event is emitted.
         * @since v11.2.0, v10.16.0
         */
        pending: boolean;
        /**
         * events.EventEmitter
         *   1. open
         *   2. close
         *   3. ready
         */
        addListener<K extends keyof ReadStreamEvents>(event: K, listener: ReadStreamEvents[K]): this;
        on<K extends keyof ReadStreamEvents>(event: K, listener: ReadStreamEvents[K]): this;
        once<K extends keyof ReadStreamEvents>(event: K, listener: ReadStreamEvents[K]): this;
        prependListener<K extends keyof ReadStreamEvents>(event: K, listener: ReadStreamEvents[K]): this;
        prependOnceListener<K extends keyof ReadStreamEvents>(event: K, listener: ReadStreamEvents[K]): this;
    }

    /**
     * The Keys are events of the ReadStream and the values are the functions that are called when the event is emitted.
     */
    type ReadStreamEvents = {
        close: () => void;
        data: (chunk: Buffer | string) => void;
        end: () => void;
        error: (err: Error) => void;
        open: (fd: number) => void;
        pause: () => void;
        readable: () => void;
        ready: () => void;
        resume: () => void;
    } & CustomEvents;

    /**
     * string & {} allows to allow any kind of strings for the event
     * but still allows to have auto completion for the normal events.
     */
    type CustomEvents = { [Key in string & {} | symbol]: (...args: any[]) => void };

    /**
     * The Keys are events of the WriteStream and the values are the functions that are called when the event is emitted.
     */
    type WriteStreamEvents = {
        close: () => void;
        drain: () => void;
        error: (err: Error) => void;
        finish: () => void;
        open: (fd: number) => void;
        pipe: (src: stream.Readable) => void;
        ready: () => void;
        unpipe: (src: stream.Readable) => void;
    } & CustomEvents;
    /**
     * * Extends `stream.Writable`
     *
     * Instances of `fs.WriteStream` are created and returned using the {@link createWriteStream} function.
     * @since v0.1.93
     */
    export class WriteStream extends stream.Writable {
        /**
         * Closes `writeStream`. Optionally accepts a
         * callback that will be executed once the `writeStream`is closed.
         * @since v0.9.4
         */
        close(callback?: (err?: NodeJS.ErrnoException | null) => void): void;
        /**
         * The number of bytes written so far. Does not include data that is still queued
         * for writing.
         * @since v0.4.7
         */
        bytesWritten: number;
        /**
         * The path to the file the stream is writing to as specified in the first
         * argument to {@link createWriteStream}. If `path` is passed as a string, then`writeStream.path` will be a string. If `path` is passed as a `Buffer`, then`writeStream.path` will be a
         * `Buffer`.
         * @since v0.1.93
         */
        path: string | Buffer;
        /**
         * This property is `true` if the underlying file has not been opened yet,
         * i.e. before the `'ready'` event is emitted.
         * @since v11.2.0
         */
        pending: boolean;
        /**
         * events.EventEmitter
         *   1. open
         *   2. close
         *   3. ready
         */
        addListener<K extends keyof WriteStreamEvents>(event: K, listener: WriteStreamEvents[K]): this;
        on<K extends keyof WriteStreamEvents>(event: K, listener: WriteStreamEvents[K]): this;
        once<K extends keyof WriteStreamEvents>(event: K, listener: WriteStreamEvents[K]): this;
        prependListener<K extends keyof WriteStreamEvents>(event: K, listener: WriteStreamEvents[K]): this;
        prependOnceListener<K extends keyof WriteStreamEvents>(event: K, listener: WriteStreamEvents[K]): this;
    }
    /**
     * Asynchronously rename file at `oldPath` to the pathname provided
     * as `newPath`. In the case that `newPath` already exists, it will
     * be overwritten. If there is a directory at `newPath`, an error will
     * be raised instead. No arguments other than a possible exception are
     * given to the completion callback.
     *
     * See also: [`rename(2)`](http://man7.org/linux/man-pages/man2/rename.2.html).
     *
     * ```js
     * import { rename } from 'node:fs';
     *
     * rename('oldFile.txt', 'newFile.txt', (err) => {
     *   if (err) throw err;
     *   console.log('Rename complete!');
     * });
     * ```
     * @since v0.0.2
     */
    export function rename(oldPath: PathLike, newPath: PathLike, callback: NoParamCallback): void;
    export namespace rename {
        /**
         * Asynchronous rename(2) - Change the name or location of a file or directory.
         * @param oldPath A path to a file. If a URL is provided, it must use the `file:` protocol.
         * URL support is _experimental_.
         * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.
         * URL support is _experimental_.
         */
        function __promisify__(oldPath: PathLike, newPath: PathLike): Promise<void>;
    }
    /**
     * Renames the file from `oldPath` to `newPath`. Returns `undefined`.
     *
     * See the POSIX [`rename(2)`](http://man7.org/linux/man-pages/man2/rename.2.html) documentation for more details.
     * @since v0.1.21
     */
    export function renameSync(oldPath: PathLike, newPath: PathLike): void;
    /**
     * Truncates the file. No arguments other than a possible exception are
     * given to the completion callback. A file descriptor can also be passed as the
     * first argument. In this case, `fs.ftruncate()` is called.
     *
     * ```js
     * import { truncate } from 'node:fs';
     * // Assuming that 'path/file.txt' is a regular file.
     * truncate('path/file.txt', (err) => {
     *   if (err) throw err;
     *   console.log('path/file.txt was truncated');
     * });
     * ```
     *
     * Passing a file descriptor is deprecated and may result in an error being thrown
     * in the future.
     *
     * See the POSIX [`truncate(2)`](http://man7.org/linux/man-pages/man2/truncate.2.html) documentation for more details.
     * @since v0.8.6
     * @param [len=0]
     */
    export function truncate(path: PathLike, len: number | undefined, callback: NoParamCallback): void;
    /**
     * Asynchronous truncate(2) - Truncate a file to a specified length.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     */
    export function truncate(path: PathLike, callback: NoParamCallback): void;
    export namespace truncate {
        /**
         * Asynchronous truncate(2) - Truncate a file to a specified length.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param len If not specified, defaults to `0`.
         */
        function __promisify__(path: PathLike, len?: number): Promise<void>;
    }
    /**
     * Truncates the file. Returns `undefined`. A file descriptor can also be
     * passed as the first argument. In this case, `fs.ftruncateSync()` is called.
     *
     * Passing a file descriptor is deprecated and may result in an error being thrown
     * in the future.
     * @since v0.8.6
     * @param [len=0]
     */
    export function truncateSync(path: PathLike, len?: number): void;
    /**
     * Truncates the file descriptor. No arguments other than a possible exception are
     * given to the completion callback.
     *
     * See the POSIX [`ftruncate(2)`](http://man7.org/linux/man-pages/man2/ftruncate.2.html) documentation for more detail.
     *
     * If the file referred to by the file descriptor was larger than `len` bytes, only
     * the first `len` bytes will be retained in the file.
     *
     * For example, the following program retains only the first four bytes of the
     * file:
     *
     * ```js
     * import { open, close, ftruncate } from 'node:fs';
     *
     * function closeFd(fd) {
     *   close(fd, (err) => {
     *     if (err) throw err;
     *   });
     * }
     *
     * open('temp.txt', 'r+', (err, fd) => {
     *   if (err) throw err;
     *
     *   try {
     *     ftruncate(fd, 4, (err) => {
     *       closeFd(fd);
     *       if (err) throw err;
     *     });
     *   } catch (err) {
     *     closeFd(fd);
     *     if (err) throw err;
     *   }
     * });
     * ```
     *
     * If the file previously was shorter than `len` bytes, it is extended, and the
     * extended part is filled with null bytes (`'\0'`):
     *
     * If `len` is negative then `0` will be used.
     * @since v0.8.6
     * @param [len=0]
     */
    export function ftruncate(fd: number, len: number | undefined, callback: NoParamCallback): void;
    /**
     * Asynchronous ftruncate(2) - Truncate a file to a specified length.
     * @param fd A file descriptor.
     */
    export function ftruncate(fd: number, callback: NoParamCallback): void;
    export namespace ftruncate {
        /**
         * Asynchronous ftruncate(2) - Truncate a file to a specified length.
         * @param fd A file descriptor.
         * @param len If not specified, defaults to `0`.
         */
        function __promisify__(fd: number, len?: number): Promise<void>;
    }
    /**
     * Truncates the file descriptor. Returns `undefined`.
     *
     * For detailed information, see the documentation of the asynchronous version of
     * this API: {@link ftruncate}.
     * @since v0.8.6
     * @param [len=0]
     */
    export function ftruncateSync(fd: number, len?: number): void;
    /**
     * Asynchronously changes owner and group of a file. No arguments other than a
     * possible exception are given to the completion callback.
     *
     * See the POSIX [`chown(2)`](http://man7.org/linux/man-pages/man2/chown.2.html) documentation for more detail.
     * @since v0.1.97
     */
    export function chown(path: PathLike, uid: number, gid: number, callback: NoParamCallback): void;
    export namespace chown {
        /**
         * Asynchronous chown(2) - Change ownership of a file.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         */
        function __promisify__(path: PathLike, uid: number, gid: number): Promise<void>;
    }
    /**
     * Synchronously changes owner and group of a file. Returns `undefined`.
     * This is the synchronous version of {@link chown}.
     *
     * See the POSIX [`chown(2)`](http://man7.org/linux/man-pages/man2/chown.2.html) documentation for more detail.
     * @since v0.1.97
     */
    export function chownSync(path: PathLike, uid: number, gid: number): void;
    /**
     * Sets the owner of the file. No arguments other than a possible exception are
     * given to the completion callback.
     *
     * See the POSIX [`fchown(2)`](http://man7.org/linux/man-pages/man2/fchown.2.html) documentation for more detail.
     * @since v0.4.7
     */
    export function fchown(fd: number, uid: number, gid: number, callback: NoParamCallback): void;
    export namespace fchown {
        /**
         * Asynchronous fchown(2) - Change ownership of a file.
         * @param fd A file descriptor.
         */
        function __promisify__(fd: number, uid: number, gid: number): Promise<void>;
    }
    /**
     * Sets the owner of the file. Returns `undefined`.
     *
     * See the POSIX [`fchown(2)`](http://man7.org/linux/man-pages/man2/fchown.2.html) documentation for more detail.
     * @since v0.4.7
     * @param uid The file's new owner's user id.
     * @param gid The file's new group's group id.
     */
    export function fchownSync(fd: number, uid: number, gid: number): void;
    /**
     * Set the owner of the symbolic link. No arguments other than a possible
     * exception are given to the completion callback.
     *
     * See the POSIX [`lchown(2)`](http://man7.org/linux/man-pages/man2/lchown.2.html) documentation for more detail.
     */
    export function lchown(path: PathLike, uid: number, gid: number, callback: NoParamCallback): void;
    export namespace lchown {
        /**
         * Asynchronous lchown(2) - Change ownership of a file. Does not dereference symbolic links.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         */
        function __promisify__(path: PathLike, uid: number, gid: number): Promise<void>;
    }
    /**
     * Set the owner for the path. Returns `undefined`.
     *
     * See the POSIX [`lchown(2)`](http://man7.org/linux/man-pages/man2/lchown.2.html) documentation for more details.
     * @param uid The file's new owner's user id.
     * @param gid The file's new group's group id.
     */
    export function lchownSync(path: PathLike, uid: number, gid: number): void;
    /**
     * Changes the access and modification times of a file in the same way as {@link utimes}, with the difference that if the path refers to a symbolic
     * link, then the link is not dereferenced: instead, the timestamps of the
     * symbolic link itself are changed.
     *
     * No arguments other than a possible exception are given to the completion
     * callback.
     * @since v14.5.0, v12.19.0
     */
    export function lutimes(path: PathLike, atime: TimeLike, mtime: TimeLike, callback: NoParamCallback): void;
    export namespace lutimes {
        /**
         * Changes the access and modification times of a file in the same way as `fsPromises.utimes()`,
         * with the difference that if the path refers to a symbolic link, then the link is not
         * dereferenced: instead, the timestamps of the symbolic link itself are changed.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param atime The last access time. If a string is provided, it will be coerced to number.
         * @param mtime The last modified time. If a string is provided, it will be coerced to number.
         */
        function __promisify__(path: PathLike, atime: TimeLike, mtime: TimeLike): Promise<void>;
    }
    /**
     * Change the file system timestamps of the symbolic link referenced by `path`.
     * Returns `undefined`, or throws an exception when parameters are incorrect or
     * the operation fails. This is the synchronous version of {@link lutimes}.
     * @since v14.5.0, v12.19.0
     */
    export function lutimesSync(path: PathLike, atime: TimeLike, mtime: TimeLike): void;
    /**
     * Asynchronously changes the permissions of a file. No arguments other than a
     * possible exception are given to the completion callback.
     *
     * See the POSIX [`chmod(2)`](http://man7.org/linux/man-pages/man2/chmod.2.html) documentation for more detail.
     *
     * ```js
     * import { chmod } from 'node:fs';
     *
     * chmod('my_file.txt', 0o775, (err) => {
     *   if (err) throw err;
     *   console.log('The permissions for file "my_file.txt" have been changed!');
     * });
     * ```
     * @since v0.1.30
     */
    export function chmod(path: PathLike, mode: Mode, callback: NoParamCallback): void;
    export namespace chmod {
        /**
         * Asynchronous chmod(2) - Change permissions of a file.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.
         */
        function __promisify__(path: PathLike, mode: Mode): Promise<void>;
    }
    /**
     * For detailed information, see the documentation of the asynchronous version of
     * this API: {@link chmod}.
     *
     * See the POSIX [`chmod(2)`](http://man7.org/linux/man-pages/man2/chmod.2.html) documentation for more detail.
     * @since v0.6.7
     */
    export function chmodSync(path: PathLike, mode: Mode): void;
    /**
     * Sets the permissions on the file. No arguments other than a possible exception
     * are given to the completion callback.
     *
     * See the POSIX [`fchmod(2)`](http://man7.org/linux/man-pages/man2/fchmod.2.html) documentation for more detail.
     * @since v0.4.7
     */
    export function fchmod(fd: number, mode: Mode, callback: NoParamCallback): void;
    export namespace fchmod {
        /**
         * Asynchronous fchmod(2) - Change permissions of a file.
         * @param fd A file descriptor.
         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.
         */
        function __promisify__(fd: number, mode: Mode): Promise<void>;
    }
    /**
     * Sets the permissions on the file. Returns `undefined`.
     *
     * See the POSIX [`fchmod(2)`](http://man7.org/linux/man-pages/man2/fchmod.2.html) documentation for more detail.
     * @since v0.4.7
     */
    export function fchmodSync(fd: number, mode: Mode): void;
    /**
     * Changes the permissions on a symbolic link. No arguments other than a possible
     * exception are given to the completion callback.
     *
     * This method is only implemented on macOS.
     *
     * See the POSIX [`lchmod(2)`](https://www.freebsd.org/cgi/man.cgi?query=lchmod&sektion=2) documentation for more detail.
     * @deprecated Since v0.4.7
     */
    export function lchmod(path: PathLike, mode: Mode, callback: NoParamCallback): void;
    /** @deprecated */
    export namespace lchmod {
        /**
         * Asynchronous lchmod(2) - Change permissions of a file. Does not dereference symbolic links.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.
         */
        function __promisify__(path: PathLike, mode: Mode): Promise<void>;
    }
    /**
     * Changes the permissions on a symbolic link. Returns `undefined`.
     *
     * This method is only implemented on macOS.
     *
     * See the POSIX [`lchmod(2)`](https://www.freebsd.org/cgi/man.cgi?query=lchmod&sektion=2) documentation for more detail.
     * @deprecated Since v0.4.7
     */
    export function lchmodSync(path: PathLike, mode: Mode): void;
    /**
     * Asynchronous [`stat(2)`](http://man7.org/linux/man-pages/man2/stat.2.html). The callback gets two arguments `(err, stats)` where`stats` is an `fs.Stats` object.
     *
     * In case of an error, the `err.code` will be one of `Common System Errors`.
     *
     * {@link stat} follows symbolic links. Use {@link lstat} to look at the
     * links themselves.
     *
     * Using `fs.stat()` to check for the existence of a file before calling`fs.open()`, `fs.readFile()`, or `fs.writeFile()` is not recommended.
     * Instead, user code should open/read/write the file directly and handle the
     * error raised if the file is not available.
     *
     * To check if a file exists without manipulating it afterwards, {@link access} is recommended.
     *
     * For example, given the following directory structure:
     *
     * ```text
     * - txtDir
     * -- file.txt
     * - app.js
     * ```
     *
     * The next program will check for the stats of the given paths:
     *
     * ```js
     * import { stat } from 'node:fs';
     *
     * const pathsToCheck = ['./txtDir', './txtDir/file.txt'];
     *
     * for (let i = 0; i < pathsToCheck.length; i++) {
     *   stat(pathsToCheck[i], (err, stats) => {
     *     console.log(stats.isDirectory());
     *     console.log(stats);
     *   });
     * }
     * ```
     *
     * The resulting output will resemble:
     *
     * ```console
     * true
     * Stats {
     *   dev: 16777220,
     *   mode: 16877,
     *   nlink: 3,
     *   uid: 501,
     *   gid: 20,
     *   rdev: 0,
     *   blksize: 4096,
     *   ino: 14214262,
     *   size: 96,
     *   blocks: 0,
     *   atimeMs: 1561174653071.963,
     *   mtimeMs: 1561174614583.3518,
     *   ctimeMs: 1561174626623.5366,
     *   birthtimeMs: 1561174126937.2893,
     *   atime: 2019-06-22T03:37:33.072Z,
     *   mtime: 2019-06-22T03:36:54.583Z,
     *   ctime: 2019-06-22T03:37:06.624Z,
     *   birthtime: 2019-06-22T03:28:46.937Z
     * }
     * false
     * Stats {
     *   dev: 16777220,
     *   mode: 33188,
     *   nlink: 1,
     *   uid: 501,
     *   gid: 20,
     *   rdev: 0,
     *   blksize: 4096,
     *   ino: 14214074,
     *   size: 8,
     *   blocks: 8,
     *   atimeMs: 1561174616618.8555,
     *   mtimeMs: 1561174614584,
     *   ctimeMs: 1561174614583.8145,
     *   birthtimeMs: 1561174007710.7478,
     *   atime: 2019-06-22T03:36:56.619Z,
     *   mtime: 2019-06-22T03:36:54.584Z,
     *   ctime: 2019-06-22T03:36:54.584Z,
     *   birthtime: 2019-06-22T03:26:47.711Z
     * }
     * ```
     * @since v0.0.2
     */
    export function stat(path: PathLike, callback: (err: NodeJS.ErrnoException | null, stats: Stats) => void): void;
    export function stat(
        path: PathLike,
        options:
            | (StatOptions & {
                bigint?: false | undefined;
            })
            | undefined,
        callback: (err: NodeJS.ErrnoException | null, stats: Stats) => void,
    ): void;
    export function stat(
        path: PathLike,
        options: StatOptions & {
            bigint: true;
        },
        callback: (err: NodeJS.ErrnoException | null, stats: BigIntStats) => void,
    ): void;
    export function stat(
        path: PathLike,
        options: StatOptions | undefined,
        callback: (err: NodeJS.ErrnoException | null, stats: Stats | BigIntStats) => void,
    ): void;
    export namespace stat {
        /**
         * Asynchronous stat(2) - Get file status.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         */
        function __promisify__(
            path: PathLike,
            options?: StatOptions & {
                bigint?: false | undefined;
            },
        ): Promise<Stats>;
        function __promisify__(
            path: PathLike,
            options: StatOptions & {
                bigint: true;
            },
        ): Promise<BigIntStats>;
        function __promisify__(path: PathLike, options?: StatOptions): Promise<Stats | BigIntStats>;
    }
    export interface StatSyncFn extends Function {
        (path: PathLike, options?: undefined): Stats;
        (
            path: PathLike,
            options?: StatSyncOptions & {
                bigint?: false | undefined;
                throwIfNoEntry: false;
            },
        ): Stats | undefined;
        (
            path: PathLike,
            options: StatSyncOptions & {
                bigint: true;
                throwIfNoEntry: false;
            },
        ): BigIntStats | undefined;
        (
            path: PathLike,
            options?: StatSyncOptions & {
                bigint?: false | undefined;
            },
        ): Stats;
        (
            path: PathLike,
            options: StatSyncOptions & {
                bigint: true;
            },
        ): BigIntStats;
        (
            path: PathLike,
            options: StatSyncOptions & {
                bigint: boolean;
                throwIfNoEntry?: false | undefined;
            },
        ): Stats | BigIntStats;
        (path: PathLike, options?: StatSyncOptions): Stats | BigIntStats | undefined;
    }
    /**
     * Synchronous stat(2) - Get file status.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     */
    export const statSync: StatSyncFn;
    /**
     * Invokes the callback with the `fs.Stats` for the file descriptor.
     *
     * See the POSIX [`fstat(2)`](http://man7.org/linux/man-pages/man2/fstat.2.html) documentation for more detail.
     * @since v0.1.95
     */
    export function fstat(fd: number, callback: (err: NodeJS.ErrnoException | null, stats: Stats) => void): void;
    export function fstat(
        fd: number,
        options:
            | (StatOptions & {
                bigint?: false | undefined;
            })
            | undefined,
        callback: (err: NodeJS.ErrnoException | null, stats: Stats) => void,
    ): void;
    export function fstat(
        fd: number,
        options: StatOptions & {
            bigint: true;
        },
        callback: (err: NodeJS.ErrnoException | null, stats: BigIntStats) => void,
    ): void;
    export function fstat(
        fd: number,
        options: StatOptions | undefined,
        callback: (err: NodeJS.ErrnoException | null, stats: Stats | BigIntStats) => void,
    ): void;
    export namespace fstat {
        /**
         * Asynchronous fstat(2) - Get file status.
         * @param fd A file descriptor.
         */
        function __promisify__(
            fd: number,
            options?: StatOptions & {
                bigint?: false | undefined;
            },
        ): Promise<Stats>;
        function __promisify__(
            fd: number,
            options: StatOptions & {
                bigint: true;
            },
        ): Promise<BigIntStats>;
        function __promisify__(fd: number, options?: StatOptions): Promise<Stats | BigIntStats>;
    }
    /**
     * Retrieves the `fs.Stats` for the file descriptor.
     *
     * See the POSIX [`fstat(2)`](http://man7.org/linux/man-pages/man2/fstat.2.html) documentation for more detail.
     * @since v0.1.95
     */
    export function fstatSync(
        fd: number,
        options?: StatOptions & {
            bigint?: false | undefined;
        },
    ): Stats;
    export function fstatSync(
        fd: number,
        options: StatOptions & {
            bigint: true;
        },
    ): BigIntStats;
    export function fstatSync(fd: number, options?: StatOptions): Stats | BigIntStats;
    /**
     * Retrieves the `fs.Stats` for the symbolic link referred to by the path.
     * The callback gets two arguments `(err, stats)` where `stats` is a `fs.Stats` object. `lstat()` is identical to `stat()`, except that if `path` is a symbolic
     * link, then the link itself is stat-ed, not the file that it refers to.
     *
     * See the POSIX [`lstat(2)`](http://man7.org/linux/man-pages/man2/lstat.2.html) documentation for more details.
     * @since v0.1.30
     */
    export function lstat(path: PathLike, callback: (err: NodeJS.ErrnoException | null, stats: Stats) => void): void;
    export function lstat(
        path: PathLike,
        options:
            | (StatOptions & {
                bigint?: false | undefined;
            })
            | undefined,
        callback: (err: NodeJS.ErrnoException | null, stats: Stats) => void,
    ): void;
    export function lstat(
        path: PathLike,
        options: StatOptions & {
            bigint: true;
        },
        callback: (err: NodeJS.ErrnoException | null, stats: BigIntStats) => void,
    ): void;
    export function lstat(
        path: PathLike,
        options: StatOptions | undefined,
        callback: (err: NodeJS.ErrnoException | null, stats: Stats | BigIntStats) => void,
    ): void;
    export namespace lstat {
        /**
         * Asynchronous lstat(2) - Get file status. Does not dereference symbolic links.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         */
        function __promisify__(
            path: PathLike,
            options?: StatOptions & {
                bigint?: false | undefined;
            },
        ): Promise<Stats>;
        function __promisify__(
            path: PathLike,
            options: StatOptions & {
                bigint: true;
            },
        ): Promise<BigIntStats>;
        function __promisify__(path: PathLike, options?: StatOptions): Promise<Stats | BigIntStats>;
    }
    /**
     * Asynchronous [`statfs(2)`](http://man7.org/linux/man-pages/man2/statfs.2.html). Returns information about the mounted file system which
     * contains `path`. The callback gets two arguments `(err, stats)` where `stats`is an `fs.StatFs` object.
     *
     * In case of an error, the `err.code` will be one of `Common System Errors`.
     * @since v19.6.0, v18.15.0
     * @param path A path to an existing file or directory on the file system to be queried.
     */
    export function statfs(path: PathLike, callback: (err: NodeJS.ErrnoException | null, stats: StatsFs) => void): void;
    export function statfs(
        path: PathLike,
        options:
            | (StatFsOptions & {
                bigint?: false | undefined;
            })
            | undefined,
        callback: (err: NodeJS.ErrnoException | null, stats: StatsFs) => void,
    ): void;
    export function statfs(
        path: PathLike,
        options: StatFsOptions & {
            bigint: true;
        },
        callback: (err: NodeJS.ErrnoException | null, stats: BigIntStatsFs) => void,
    ): void;
    export function statfs(
        path: PathLike,
        options: StatFsOptions | undefined,
        callback: (err: NodeJS.ErrnoException | null, stats: StatsFs | BigIntStatsFs) => void,
    ): void;
    export namespace statfs {
        /**
         * Asynchronous statfs(2) - Returns information about the mounted file system which contains path. The callback gets two arguments (err, stats) where stats is an <fs.StatFs> object.
         * @param path A path to an existing file or directory on the file system to be queried.
         */
        function __promisify__(
            path: PathLike,
            options?: StatFsOptions & {
                bigint?: false | undefined;
            },
        ): Promise<StatsFs>;
        function __promisify__(
            path: PathLike,
            options: StatFsOptions & {
                bigint: true;
            },
        ): Promise<BigIntStatsFs>;
        function __promisify__(path: PathLike, options?: StatFsOptions): Promise<StatsFs | BigIntStatsFs>;
    }
    /**
     * Synchronous [`statfs(2)`](http://man7.org/linux/man-pages/man2/statfs.2.html). Returns information about the mounted file system which
     * contains `path`.
     *
     * In case of an error, the `err.code` will be one of `Common System Errors`.
     * @since v19.6.0, v18.15.0
     * @param path A path to an existing file or directory on the file system to be queried.
     */
    export function statfsSync(
        path: PathLike,
        options?: StatFsOptions & {
            bigint?: false | undefined;
        },
    ): StatsFs;
    export function statfsSync(
        path: PathLike,
        options: StatFsOptions & {
            bigint: true;
        },
    ): BigIntStatsFs;
    export function statfsSync(path: PathLike, options?: StatFsOptions): StatsFs | BigIntStatsFs;
    /**
     * Synchronous lstat(2) - Get file status. Does not dereference symbolic links.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     */
    export const lstatSync: StatSyncFn;
    /**
     * Creates a new link from the `existingPath` to the `newPath`. See the POSIX [`link(2)`](http://man7.org/linux/man-pages/man2/link.2.html) documentation for more detail. No arguments other than
     * a possible
     * exception are given to the completion callback.
     * @since v0.1.31
     */
    export function link(existingPath: PathLike, newPath: PathLike, callback: NoParamCallback): void;
    export namespace link {
        /**
         * Asynchronous link(2) - Create a new link (also known as a hard link) to an existing file.
         * @param existingPath A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.
         */
        function __promisify__(existingPath: PathLike, newPath: PathLike): Promise<void>;
    }
    /**
     * Creates a new link from the `existingPath` to the `newPath`. See the POSIX [`link(2)`](http://man7.org/linux/man-pages/man2/link.2.html) documentation for more detail. Returns `undefined`.
     * @since v0.1.31
     */
    export function linkSync(existingPath: PathLike, newPath: PathLike): void;
    /**
     * Creates the link called `path` pointing to `target`. No arguments other than a
     * possible exception are given to the completion callback.
     *
     * See the POSIX [`symlink(2)`](http://man7.org/linux/man-pages/man2/symlink.2.html) documentation for more details.
     *
     * The `type` argument is only available on Windows and ignored on other platforms.
     * It can be set to `'dir'`, `'file'`, or `'junction'`. If the `type` argument is
     * not a string, Node.js will autodetect `target` type and use `'file'` or `'dir'`.
     * If the `target` does not exist, `'file'` will be used. Windows junction points
     * require the destination path to be absolute. When using `'junction'`, the`target` argument will automatically be normalized to absolute path. Junction
     * points on NTFS volumes can only point to directories.
     *
     * Relative targets are relative to the link's parent directory.
     *
     * ```js
     * import { symlink } from 'node:fs';
     *
     * symlink('./mew', './mewtwo', callback);
     * ```
     *
     * The above example creates a symbolic link `mewtwo` which points to `mew` in the
     * same directory:
     *
     * ```bash
     * $ tree .
     * .
     *  mew
     *  mewtwo -> ./mew
     * ```
     * @since v0.1.31
     * @param [type='null']
     */
    export function symlink(
        target: PathLike,
        path: PathLike,
        type: symlink.Type | undefined | null,
        callback: NoParamCallback,
    ): void;
    /**
     * Asynchronous symlink(2) - Create a new symbolic link to an existing file.
     * @param target A path to an existing file. If a URL is provided, it must use the `file:` protocol.
     * @param path A path to the new symlink. If a URL is provided, it must use the `file:` protocol.
     */
    export function symlink(target: PathLike, path: PathLike, callback: NoParamCallback): void;
    export namespace symlink {
        /**
         * Asynchronous symlink(2) - Create a new symbolic link to an existing file.
         * @param target A path to an existing file. If a URL is provided, it must use the `file:` protocol.
         * @param path A path to the new symlink. If a URL is provided, it must use the `file:` protocol.
         * @param type May be set to `'dir'`, `'file'`, or `'junction'` (default is `'file'`) and is only available on Windows (ignored on other platforms).
         * When using `'junction'`, the `target` argument will automatically be normalized to an absolute path.
         */
        function __promisify__(target: PathLike, path: PathLike, type?: string | null): Promise<void>;
        type Type = "dir" | "file" | "junction";
    }
    /**
     * Returns `undefined`.
     *
     * For detailed information, see the documentation of the asynchronous version of
     * this API: {@link symlink}.
     * @since v0.1.31
     * @param [type='null']
     */
    export function symlinkSync(target: PathLike, path: PathLike, type?: symlink.Type | null): void;
    /**
     * Reads the contents of the symbolic link referred to by `path`. The callback gets
     * two arguments `(err, linkString)`.
     *
     * See the POSIX [`readlink(2)`](http://man7.org/linux/man-pages/man2/readlink.2.html) documentation for more details.
     *
     * The optional `options` argument can be a string specifying an encoding, or an
     * object with an `encoding` property specifying the character encoding to use for
     * the link path passed to the callback. If the `encoding` is set to `'buffer'`,
     * the link path returned will be passed as a `Buffer` object.
     * @since v0.1.31
     */
    export function readlink(
        path: PathLike,
        options: EncodingOption,
        callback: (err: NodeJS.ErrnoException | null, linkString: string) => void,
    ): void;
    /**
     * Asynchronous readlink(2) - read value of a symbolic link.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    export function readlink(
        path: PathLike,
        options: BufferEncodingOption,
        callback: (err: NodeJS.ErrnoException | null, linkString: Buffer) => void,
    ): void;
    /**
     * Asynchronous readlink(2) - read value of a symbolic link.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    export function readlink(
        path: PathLike,
        options: EncodingOption,
        callback: (err: NodeJS.ErrnoException | null, linkString: string | Buffer) => void,
    ): void;
    /**
     * Asynchronous readlink(2) - read value of a symbolic link.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     */
    export function readlink(
        path: PathLike,
        callback: (err: NodeJS.ErrnoException | null, linkString: string) => void,
    ): void;
    export namespace readlink {
        /**
         * Asynchronous readlink(2) - read value of a symbolic link.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
         */
        function __promisify__(path: PathLike, options?: EncodingOption): Promise<string>;
        /**
         * Asynchronous readlink(2) - read value of a symbolic link.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
         */
        function __promisify__(path: PathLike, options: BufferEncodingOption): Promise<Buffer>;
        /**
         * Asynchronous readlink(2) - read value of a symbolic link.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
         */
        function __promisify__(path: PathLike, options?: EncodingOption): Promise<string | Buffer>;
    }
    /**
     * Returns the symbolic link's string value.
     *
     * See the POSIX [`readlink(2)`](http://man7.org/linux/man-pages/man2/readlink.2.html) documentation for more details.
     *
     * The optional `options` argument can be a string specifying an encoding, or an
     * object with an `encoding` property specifying the character encoding to use for
     * the link path returned. If the `encoding` is set to `'buffer'`,
     * the link path returned will be passed as a `Buffer` object.
     * @since v0.1.31
     */
    export function readlinkSync(path: PathLike, options?: EncodingOption): string;
    /**
     * Synchronous readlink(2) - read value of a symbolic link.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    export function readlinkSync(path: PathLike, options: BufferEncodingOption): Buffer;
    /**
     * Synchronous readlink(2) - read value of a symbolic link.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    export function readlinkSync(path: PathLike, options?: EncodingOption): string | Buffer;
    /**
     * Asynchronously computes the canonical pathname by resolving `.`, `..`, and
     * symbolic links.
     *
     * A canonical pathname is not necessarily unique. Hard links and bind mounts can
     * expose a file system entity through many pathnames.
     *
     * This function behaves like [`realpath(3)`](http://man7.org/linux/man-pages/man3/realpath.3.html), with some exceptions:
     *
     * 1. No case conversion is performed on case-insensitive file systems.
     * 2. The maximum number of symbolic links is platform-independent and generally
     * (much) higher than what the native [`realpath(3)`](http://man7.org/linux/man-pages/man3/realpath.3.html) implementation supports.
     *
     * The `callback` gets two arguments `(err, resolvedPath)`. May use `process.cwd` to resolve relative paths.
     *
     * Only paths that can be converted to UTF8 strings are supported.
     *
     * The optional `options` argument can be a string specifying an encoding, or an
     * object with an `encoding` property specifying the character encoding to use for
     * the path passed to the callback. If the `encoding` is set to `'buffer'`,
     * the path returned will be passed as a `Buffer` object.
     *
     * If `path` resolves to a socket or a pipe, the function will return a system
     * dependent name for that object.
     * @since v0.1.31
     */
    export function realpath(
        path: PathLike,
        options: EncodingOption,
        callback: (err: NodeJS.ErrnoException | null, resolvedPath: string) => void,
    ): void;
    /**
     * Asynchronous realpath(3) - return the canonicalized absolute pathname.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    export function realpath(
        path: PathLike,
        options: BufferEncodingOption,
        callback: (err: NodeJS.ErrnoException | null, resolvedPath: Buffer) => void,
    ): void;
    /**
     * Asynchronous realpath(3) - return the canonicalized absolute pathname.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    export function realpath(
        path: PathLike,
        options: EncodingOption,
        callback: (err: NodeJS.ErrnoException | null, resolvedPath: string | Buffer) => void,
    ): void;
    /**
     * Asynchronous realpath(3) - return the canonicalized absolute pathname.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     */
    export function realpath(
        path: PathLike,
        callback: (err: NodeJS.ErrnoException | null, resolvedPath: string) => void,
    ): void;
    export namespace realpath {
        /**
         * Asynchronous realpath(3) - return the canonicalized absolute pathname.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
         */
        function __promisify__(path: PathLike, options?: EncodingOption): Promise<string>;
        /**
         * Asynchronous realpath(3) - return the canonicalized absolute pathname.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
         */
        function __promisify__(path: PathLike, options: BufferEncodingOption): Promise<Buffer>;
        /**
         * Asynchronous realpath(3) - return the canonicalized absolute pathname.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
         */
        function __promisify__(path: PathLike, options?: EncodingOption): Promise<string | Buffer>;
        /**
         * Asynchronous [`realpath(3)`](http://man7.org/linux/man-pages/man3/realpath.3.html).
         *
         * The `callback` gets two arguments `(err, resolvedPath)`.
         *
         * Only paths that can be converted to UTF8 strings are supported.
         *
         * The optional `options` argument can be a string specifying an encoding, or an
         * object with an `encoding` property specifying the character encoding to use for
         * the path passed to the callback. If the `encoding` is set to `'buffer'`,
         * the path returned will be passed as a `Buffer` object.
         *
         * On Linux, when Node.js is linked against musl libc, the procfs file system must
         * be mounted on `/proc` in order for this function to work. Glibc does not have
         * this restriction.
         * @since v9.2.0
         */
        function native(
            path: PathLike,
            options: EncodingOption,
            callback: (err: NodeJS.ErrnoException | null, resolvedPath: string) => void,
        ): void;
        function native(
            path: PathLike,
            options: BufferEncodingOption,
            callback: (err: NodeJS.ErrnoException | null, resolvedPath: Buffer) => void,
        ): void;
        function native(
            path: PathLike,
            options: EncodingOption,
            callback: (err: NodeJS.ErrnoException | null, resolvedPath: string | Buffer) => void,
        ): void;
        function native(
            path: PathLike,
            callback: (err: NodeJS.ErrnoException | null, resolvedPath: string) => void,
        ): void;
    }
    /**
     * Returns the resolved pathname.
     *
     * For detailed information, see the documentation of the asynchronous version of
     * this API: {@link realpath}.
     * @since v0.1.31
     */
    export function realpathSync(path: PathLike, options?: EncodingOption): string;
    /**
     * Synchronous realpath(3) - return the canonicalized absolute pathname.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    export function realpathSync(path: PathLike, options: BufferEncodingOption): Buffer;
    /**
     * Synchronous realpath(3) - return the canonicalized absolute pathname.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    export function realpathSync(path: PathLike, options?: EncodingOption): string | Buffer;
    export namespace realpathSync {
        function native(path: PathLike, options?: EncodingOption): string;
        function native(path: PathLike, options: BufferEncodingOption): Buffer;
        function native(path: PathLike, options?: EncodingOption): string | Buffer;
    }
    /**
     * Asynchronously removes a file or symbolic link. No arguments other than a
     * possible exception are given to the completion callback.
     *
     * ```js
     * import { unlink } from 'node:fs';
     * // Assuming that 'path/file.txt' is a regular file.
     * unlink('path/file.txt', (err) => {
     *   if (err) throw err;
     *   console.log('path/file.txt was deleted');
     * });
     * ```
     *
     * `fs.unlink()` will not work on a directory, empty or otherwise. To remove a
     * directory, use {@link rmdir}.
     *
     * See the POSIX [`unlink(2)`](http://man7.org/linux/man-pages/man2/unlink.2.html) documentation for more details.
     * @since v0.0.2
     */
    export function unlink(path: PathLike, callback: NoParamCallback): void;
    export namespace unlink {
        /**
         * Asynchronous unlink(2) - delete a name and possibly the file it refers to.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         */
        function __promisify__(path: PathLike): Promise<void>;
    }
    /**
     * Synchronous [`unlink(2)`](http://man7.org/linux/man-pages/man2/unlink.2.html). Returns `undefined`.
     * @since v0.1.21
     */
    export function unlinkSync(path: PathLike): void;
    export interface RmDirOptions {
        /**
         * If an `EBUSY`, `EMFILE`, `ENFILE`, `ENOTEMPTY`, or
         * `EPERM` error is encountered, Node.js will retry the operation with a linear
         * backoff wait of `retryDelay` ms longer on each try. This option represents the
         * number of retries. This option is ignored if the `recursive` option is not
         * `true`.
         * @default 0
         */
        maxRetries?: number | undefined;
        /**
         * @deprecated since v14.14.0 In future versions of Node.js and will trigger a warning
         * `fs.rmdir(path, { recursive: true })` will throw if `path` does not exist or is a file.
         * Use `fs.rm(path, { recursive: true, force: true })` instead.
         *
         * If `true`, perform a recursive directory removal. In
         * recursive mode, operations are retried on failure.
         * @default false
         */
        recursive?: boolean | undefined;
        /**
         * The amount of time in milliseconds to wait between retries.
         * This option is ignored if the `recursive` option is not `true`.
         * @default 100
         */
        retryDelay?: number | undefined;
    }
    /**
     * Asynchronous [`rmdir(2)`](http://man7.org/linux/man-pages/man2/rmdir.2.html). No arguments other than a possible exception are given
     * to the completion callback.
     *
     * Using `fs.rmdir()` on a file (not a directory) results in an `ENOENT` error on
     * Windows and an `ENOTDIR` error on POSIX.
     *
     * To get a behavior similar to the `rm -rf` Unix command, use {@link rm} with options `{ recursive: true, force: true }`.
     * @since v0.0.2
     */
    export function rmdir(path: PathLike, callback: NoParamCallback): void;
    export function rmdir(path: PathLike, options: RmDirOptions, callback: NoParamCallback): void;
    export namespace rmdir {
        /**
         * Asynchronous rmdir(2) - delete a directory.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         */
        function __promisify__(path: PathLike, options?: RmDirOptions): Promise<void>;
    }
    /**
     * Synchronous [`rmdir(2)`](http://man7.org/linux/man-pages/man2/rmdir.2.html). Returns `undefined`.
     *
     * Using `fs.rmdirSync()` on a file (not a directory) results in an `ENOENT` error
     * on Windows and an `ENOTDIR` error on POSIX.
     *
     * To get a behavior similar to the `rm -rf` Unix command, use {@link rmSync} with options `{ recursive: true, force: true }`.
     * @since v0.1.21
     */
    export function rmdirSync(path: PathLike, options?: RmDirOptions): void;
    export interface RmOptions {
        /**
         * When `true`, exceptions will be ignored if `path` does not exist.
         * @default false
         */
        force?: boolean | undefined;
        /**
         * If an `EBUSY`, `EMFILE`, `ENFILE`, `ENOTEMPTY`, or
         * `EPERM` error is encountered, Node.js will retry the operation with a linear
         * backoff wait of `retryDelay` ms longer on each try. This option represents the
         * number of retries. This option is ignored if the `recursive` option is not
         * `true`.
         * @default 0
         */
        maxRetries?: number | undefined;
        /**
         * If `true`, perform a recursive directory removal. In
         * recursive mode, operations are retried on failure.
         * @default false
         */
        recursive?: boolean | undefined;
        /**
         * The amount of time in milliseconds to wait between retries.
         * This option is ignored if the `recursive` option is not `true`.
         * @default 100
         */
        retryDelay?: number | undefined;
    }
    /**
     * Asynchronously removes files and directories (modeled on the standard POSIX `rm` utility). No arguments other than a possible exception are given to the
     * completion callback.
     * @since v14.14.0
     */
    export function rm(path: PathLike, callback: NoParamCallback): void;
    export function rm(path: PathLike, options: RmOptions, callback: NoParamCallback): void;
    export namespace rm {
        /**
         * Asynchronously removes files and directories (modeled on the standard POSIX `rm` utility).
         */
        function __promisify__(path: PathLike, options?: RmOptions): Promise<void>;
    }
    /**
     * Synchronously removes files and directories (modeled on the standard POSIX `rm` utility). Returns `undefined`.
     * @since v14.14.0
     */
    export function rmSync(path: PathLike, options?: RmOptions): void;
    export interface MakeDirectoryOptions {
        /**
         * Indicates whether parent folders should be created.
         * If a folder was created, the path to the first created folder will be returned.
         * @default false
         */
        recursive?: boolean | undefined;
        /**
         * A file mode. If a string is passed, it is parsed as an octal integer. If not specified
         * @default 0o777
         */
        mode?: Mode | undefined;
    }
    /**
     * Asynchronously creates a directory.
     *
     * The callback is given a possible exception and, if `recursive` is `true`, the
     * first directory path created, `(err[, path])`.`path` can still be `undefined` when `recursive` is `true`, if no directory was
     * created (for instance, if it was previously created).
     *
     * The optional `options` argument can be an integer specifying `mode` (permission
     * and sticky bits), or an object with a `mode` property and a `recursive` property indicating whether parent directories should be created. Calling `fs.mkdir()` when `path` is a directory that
     * exists results in an error only
     * when `recursive` is false. If `recursive` is false and the directory exists,
     * an `EEXIST` error occurs.
     *
     * ```js
     * import { mkdir } from 'node:fs';
     *
     * // Create ./tmp/a/apple, regardless of whether ./tmp and ./tmp/a exist.
     * mkdir('./tmp/a/apple', { recursive: true }, (err) => {
     *   if (err) throw err;
     * });
     * ```
     *
     * On Windows, using `fs.mkdir()` on the root directory even with recursion will
     * result in an error:
     *
     * ```js
     * import { mkdir } from 'node:fs';
     *
     * mkdir('/', { recursive: true }, (err) => {
     *   // => [Error: EPERM: operation not permitted, mkdir 'C:\']
     * });
     * ```
     *
     * See the POSIX [`mkdir(2)`](http://man7.org/linux/man-pages/man2/mkdir.2.html) documentation for more details.
     * @since v0.1.8
     */
    export function mkdir(
        path: PathLike,
        options: MakeDirectoryOptions & {
            recursive: true;
        },
        callback: (err: NodeJS.ErrnoException | null, path?: string) => void,
    ): void;
    /**
     * Asynchronous mkdir(2) - create a directory.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
     * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
     */
    export function mkdir(
        path: PathLike,
        options:
            | Mode
            | (MakeDirectoryOptions & {
                recursive?: false | undefined;
            })
            | null
            | undefined,
        callback: NoParamCallback,
    ): void;
    /**
     * Asynchronous mkdir(2) - create a directory.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
     * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
     */
    export function mkdir(
        path: PathLike,
        options: Mode | MakeDirectoryOptions | null | undefined,
        callback: (err: NodeJS.ErrnoException | null, path?: string) => void,
    ): void;
    /**
     * Asynchronous mkdir(2) - create a directory with a mode of `0o777`.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     */
    export function mkdir(path: PathLike, callback: NoParamCallback): void;
    export namespace mkdir {
        /**
         * Asynchronous mkdir(2) - create a directory.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
         * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
         */
        function __promisify__(
            path: PathLike,
            options: MakeDirectoryOptions & {
                recursive: true;
            },
        ): Promise<string | undefined>;
        /**
         * Asynchronous mkdir(2) - create a directory.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
         * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
         */
        function __promisify__(
            path: PathLike,
            options?:
                | Mode
                | (MakeDirectoryOptions & {
                    recursive?: false | undefined;
                })
                | null,
        ): Promise<void>;
        /**
         * Asynchronous mkdir(2) - create a directory.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
         * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
         */
        function __promisify__(
            path: PathLike,
            options?: Mode | MakeDirectoryOptions | null,
        ): Promise<string | undefined>;
    }
    /**
     * Synchronously creates a directory. Returns `undefined`, or if `recursive` is `true`, the first directory path created.
     * This is the synchronous version of {@link mkdir}.
     *
     * See the POSIX [`mkdir(2)`](http://man7.org/linux/man-pages/man2/mkdir.2.html) documentation for more details.
     * @since v0.1.21
     */
    export function mkdirSync(
        path: PathLike,
        options: MakeDirectoryOptions & {
            recursive: true;
        },
    ): string | undefined;
    /**
     * Synchronous mkdir(2) - create a directory.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
     * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
     */
    export function mkdirSync(
        path: PathLike,
        options?:
            | Mode
            | (MakeDirectoryOptions & {
                recursive?: false | undefined;
            })
            | null,
    ): void;
    /**
     * Synchronous mkdir(2) - create a directory.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
     * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
     */
    export function mkdirSync(path: PathLike, options?: Mode | MakeDirectoryOptions | null): string | undefined;
    /**
     * Creates a unique temporary directory.
     *
     * Generates six random characters to be appended behind a required `prefix` to create a unique temporary directory. Due to platform
     * inconsistencies, avoid trailing `X` characters in `prefix`. Some platforms,
     * notably the BSDs, can return more than six random characters, and replace
     * trailing `X` characters in `prefix` with random characters.
     *
     * The created directory path is passed as a string to the callback's second
     * parameter.
     *
     * The optional `options` argument can be a string specifying an encoding, or an
     * object with an `encoding` property specifying the character encoding to use.
     *
     * ```js
     * import { mkdtemp } from 'node:fs';
     * import { join } from 'node:path';
     * import { tmpdir } from 'node:os';
     *
     * mkdtemp(join(tmpdir(), 'foo-'), (err, directory) => {
     *   if (err) throw err;
     *   console.log(directory);
     *   // Prints: /tmp/foo-itXde2 or C:\Users\...\AppData\Local\Temp\foo-itXde2
     * });
     * ```
     *
     * The `fs.mkdtemp()` method will append the six randomly selected characters
     * directly to the `prefix` string. For instance, given a directory `/tmp`, if the
     * intention is to create a temporary directory _within_`/tmp`, the `prefix`must end with a trailing platform-specific path separator
     * (`import { sep } from 'node:path'`).
     *
     * ```js
     * import { tmpdir } from 'node:os';
     * import { mkdtemp } from 'node:fs';
     *
     * // The parent directory for the new temporary directory
     * const tmpDir = tmpdir();
     *
     * // This method is *INCORRECT*:
     * mkdtemp(tmpDir, (err, directory) => {
     *   if (err) throw err;
     *   console.log(directory);
     *   // Will print something similar to `/tmpabc123`.
     *   // A new temporary directory is created at the file system root
     *   // rather than *within* the /tmp directory.
     * });
     *
     * // This method is *CORRECT*:
     * import { sep } from 'node:path';
     * mkdtemp(`${tmpDir}${sep}`, (err, directory) => {
     *   if (err) throw err;
     *   console.log(directory);
     *   // Will print something similar to `/tmp/abc123`.
     *   // A new temporary directory is created within
     *   // the /tmp directory.
     * });
     * ```
     * @since v5.10.0
     */
    export function mkdtemp(
        prefix: string,
        options: EncodingOption,
        callback: (err: NodeJS.ErrnoException | null, folder: string) => void,
    ): void;
    /**
     * Asynchronously creates a unique temporary directory.
     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    export function mkdtemp(
        prefix: string,
        options:
            | "buffer"
            | {
                encoding: "buffer";
            },
        callback: (err: NodeJS.ErrnoException | null, folder: Buffer) => void,
    ): void;
    /**
     * Asynchronously creates a unique temporary directory.
     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    export function mkdtemp(
        prefix: string,
        options: EncodingOption,
        callback: (err: NodeJS.ErrnoException | null, folder: string | Buffer) => void,
    ): void;
    /**
     * Asynchronously creates a unique temporary directory.
     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
     */
    export function mkdtemp(
        prefix: string,
        callback: (err: NodeJS.ErrnoException | null, folder: string) => void,
    ): void;
    export namespace mkdtemp {
        /**
         * Asynchronously creates a unique temporary directory.
         * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
         */
        function __promisify__(prefix: string, options?: EncodingOption): Promise<string>;
        /**
         * Asynchronously creates a unique temporary directory.
         * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
         */
        function __promisify__(prefix: string, options: BufferEncodingOption): Promise<Buffer>;
        /**
         * Asynchronously creates a unique temporary directory.
         * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
         */
        function __promisify__(prefix: string, options?: EncodingOption): Promise<string | Buffer>;
    }
    /**
     * Returns the created directory path.
     *
     * For detailed information, see the documentation of the asynchronous version of
     * this API: {@link mkdtemp}.
     *
     * The optional `options` argument can be a string specifying an encoding, or an
     * object with an `encoding` property specifying the character encoding to use.
     * @since v5.10.0
     */
    export function mkdtempSync(prefix: string, options?: EncodingOption): string;
    /**
     * Synchronously creates a unique temporary directory.
     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    export function mkdtempSync(prefix: string, options: BufferEncodingOption): Buffer;
    /**
     * Synchronously creates a unique temporary directory.
     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    export function mkdtempSync(prefix: string, options?: EncodingOption): string | Buffer;
    /**
     * Reads the contents of a directory. The callback gets two arguments `(err, files)` where `files` is an array of the names of the files in the directory excluding `'.'` and `'..'`.
     *
     * See the POSIX [`readdir(3)`](http://man7.org/linux/man-pages/man3/readdir.3.html) documentation for more details.
     *
     * The optional `options` argument can be a string specifying an encoding, or an
     * object with an `encoding` property specifying the character encoding to use for
     * the filenames passed to the callback. If the `encoding` is set to `'buffer'`,
     * the filenames returned will be passed as `Buffer` objects.
     *
     * If `options.withFileTypes` is set to `true`, the `files` array will contain `fs.Dirent` objects.
     * @since v0.1.8
     */
    export function readdir(
        path: PathLike,
        options:
            | {
                encoding: BufferEncoding | null;
                withFileTypes?: false | undefined;
                recursive?: boolean | undefined;
            }
            | BufferEncoding
            | undefined
            | null,
        callback: (err: NodeJS.ErrnoException | null, files: string[]) => void,
    ): void;
    /**
     * Asynchronous readdir(3) - read a directory.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    export function readdir(
        path: PathLike,
        options:
            | {
                encoding: "buffer";
                withFileTypes?: false | undefined;
                recursive?: boolean | undefined;
            }
            | "buffer",
        callback: (err: NodeJS.ErrnoException | null, files: Buffer[]) => void,
    ): void;
    /**
     * Asynchronous readdir(3) - read a directory.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    export function readdir(
        path: PathLike,
        options:
            | (ObjectEncodingOptions & {
                withFileTypes?: false | undefined;
                recursive?: boolean | undefined;
            })
            | BufferEncoding
            | undefined
            | null,
        callback: (err: NodeJS.ErrnoException | null, files: string[] | Buffer[]) => void,
    ): void;
    /**
     * Asynchronous readdir(3) - read a directory.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     */
    export function readdir(
        path: PathLike,
        callback: (err: NodeJS.ErrnoException | null, files: string[]) => void,
    ): void;
    /**
     * Asynchronous readdir(3) - read a directory.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options If called with `withFileTypes: true` the result data will be an array of Dirent.
     */
    export function readdir(
        path: PathLike,
        options: ObjectEncodingOptions & {
            withFileTypes: true;
            recursive?: boolean | undefined;
        },
        callback: (err: NodeJS.ErrnoException | null, files: Dirent[]) => void,
    ): void;
    /**
     * Asynchronous readdir(3) - read a directory.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options Must include `withFileTypes: true` and `encoding: 'buffer'`.
     */
    export function readdir(
        path: PathLike,
        options: {
            encoding: "buffer";
            withFileTypes: true;
            recursive?: boolean | undefined;
        },
        callback: (err: NodeJS.ErrnoException | null, files: Dirent<Buffer>[]) => void,
    ): void;
    export namespace readdir {
        /**
         * Asynchronous readdir(3) - read a directory.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
         */
        function __promisify__(
            path: PathLike,
            options?:
                | {
                    encoding: BufferEncoding | null;
                    withFileTypes?: false | undefined;
                    recursive?: boolean | undefined;
                }
                | BufferEncoding
                | null,
        ): Promise<string[]>;
        /**
         * Asynchronous readdir(3) - read a directory.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
         */
        function __promisify__(
            path: PathLike,
            options:
                | "buffer"
                | {
                    encoding: "buffer";
                    withFileTypes?: false | undefined;
                    recursive?: boolean | undefined;
                },
        ): Promise<Buffer[]>;
        /**
         * Asynchronous readdir(3) - read a directory.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
         */
        function __promisify__(
            path: PathLike,
            options?:
                | (ObjectEncodingOptions & {
                    withFileTypes?: false | undefined;
                    recursive?: boolean | undefined;
                })
                | BufferEncoding
                | null,
        ): Promise<string[] | Buffer[]>;
        /**
         * Asynchronous readdir(3) - read a directory.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param options If called with `withFileTypes: true` the result data will be an array of Dirent
         */
        function __promisify__(
            path: PathLike,
            options: ObjectEncodingOptions & {
                withFileTypes: true;
                recursive?: boolean | undefined;
            },
        ): Promise<Dirent[]>;
        /**
         * Asynchronous readdir(3) - read a directory.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param options Must include `withFileTypes: true` and `encoding: 'buffer'`.
         */
        function __promisify__(
            path: PathLike,
            options: {
                encoding: "buffer";
                withFileTypes: true;
                recursive?: boolean | undefined;
            },
        ): Promise<Dirent<Buffer>[]>;
    }
    /**
     * Reads the contents of the directory.
     *
     * See the POSIX [`readdir(3)`](http://man7.org/linux/man-pages/man3/readdir.3.html) documentation for more details.
     *
     * The optional `options` argument can be a string specifying an encoding, or an
     * object with an `encoding` property specifying the character encoding to use for
     * the filenames returned. If the `encoding` is set to `'buffer'`,
     * the filenames returned will be passed as `Buffer` objects.
     *
     * If `options.withFileTypes` is set to `true`, the result will contain `fs.Dirent` objects.
     * @since v0.1.21
     */
    export function readdirSync(
        path: PathLike,
        options?:
            | {
                encoding: BufferEncoding | null;
                withFileTypes?: false | undefined;
                recursive?: boolean | undefined;
            }
            | BufferEncoding
            | null,
    ): string[];
    /**
     * Synchronous readdir(3) - read a directory.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    export function readdirSync(
        path: PathLike,
        options:
            | {
                encoding: "buffer";
                withFileTypes?: false | undefined;
                recursive?: boolean | undefined;
            }
            | "buffer",
    ): Buffer[];
    /**
     * Synchronous readdir(3) - read a directory.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
     */
    export function readdirSync(
        path: PathLike,
        options?:
            | (ObjectEncodingOptions & {
                withFileTypes?: false | undefined;
                recursive?: boolean | undefined;
            })
            | BufferEncoding
            | null,
    ): string[] | Buffer[];
    /**
     * Synchronous readdir(3) - read a directory.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options If called with `withFileTypes: true` the result data will be an array of Dirent.
     */
    export function readdirSync(
        path: PathLike,
        options: ObjectEncodingOptions & {
            withFileTypes: true;
            recursive?: boolean | undefined;
        },
    ): Dirent[];
    /**
     * Synchronous readdir(3) - read a directory.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param options Must include `withFileTypes: true` and `encoding: 'buffer'`.
     */
    export function readdirSync(
        path: PathLike,
        options: {
            encoding: "buffer";
            withFileTypes: true;
            recursive?: boolean | undefined;
        },
    ): Dirent<Buffer>[];
    /**
     * Closes the file descriptor. No arguments other than a possible exception are
     * given to the completion callback.
     *
     * Calling `fs.close()` on any file descriptor (`fd`) that is currently in use
     * through any other `fs` operation may lead to undefined behavior.
     *
     * See the POSIX [`close(2)`](http://man7.org/linux/man-pages/man2/close.2.html) documentation for more detail.
     * @since v0.0.2
     */
    export function close(fd: number, callback?: NoParamCallback): void;
    export namespace close {
        /**
         * Asynchronous close(2) - close a file descriptor.
         * @param fd A file descriptor.
         */
        function __promisify__(fd: number): Promise<void>;
    }
    /**
     * Closes the file descriptor. Returns `undefined`.
     *
     * Calling `fs.closeSync()` on any file descriptor (`fd`) that is currently in use
     * through any other `fs` operation may lead to undefined behavior.
     *
     * See the POSIX [`close(2)`](http://man7.org/linux/man-pages/man2/close.2.html) documentation for more detail.
     * @since v0.1.21
     */
    export function closeSync(fd: number): void;
    /**
     * Asynchronous file open. See the POSIX [`open(2)`](http://man7.org/linux/man-pages/man2/open.2.html) documentation for more details.
     *
     * `mode` sets the file mode (permission and sticky bits), but only if the file was
     * created. On Windows, only the write permission can be manipulated; see {@link chmod}.
     *
     * The callback gets two arguments `(err, fd)`.
     *
     * Some characters (`< > : " / \ | ? *`) are reserved under Windows as documented
     * by [Naming Files, Paths, and Namespaces](https://docs.microsoft.com/en-us/windows/desktop/FileIO/naming-a-file). Under NTFS, if the filename contains
     * a colon, Node.js will open a file system stream, as described by [this MSDN page](https://docs.microsoft.com/en-us/windows/desktop/FileIO/using-streams).
     *
     * Functions based on `fs.open()` exhibit this behavior as well:`fs.writeFile()`, `fs.readFile()`, etc.
     * @since v0.0.2
     * @param [flags='r'] See `support of file system `flags``.
     * @param [mode=0o666]
     */
    export function open(
        path: PathLike,
        flags: OpenMode | undefined,
        mode: Mode | undefined | null,
        callback: (err: NodeJS.ErrnoException | null, fd: number) => void,
    ): void;
    /**
     * Asynchronous open(2) - open and possibly create a file. If the file is created, its mode will be `0o666`.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * @param [flags='r'] See `support of file system `flags``.
     */
    export function open(
        path: PathLike,
        flags: OpenMode | undefined,
        callback: (err: NodeJS.ErrnoException | null, fd: number) => void,
    ): void;
    /**
     * Asynchronous open(2) - open and possibly create a file. If the file is created, its mode will be `0o666`.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     */
    export function open(path: PathLike, callback: (err: NodeJS.ErrnoException | null, fd: number) => void): void;
    export namespace open {
        /**
         * Asynchronous open(2) - open and possibly create a file.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param mode A file mode. If a string is passed, it is parsed as an octal integer. If not supplied, defaults to `0o666`.
         */
        function __promisify__(path: PathLike, flags: OpenMode, mode?: Mode | null): Promise<number>;
    }
    /**
     * Returns an integer representing the file descriptor.
     *
     * For detailed information, see the documentation of the asynchronous version of
     * this API: {@link open}.
     * @since v0.1.21
     * @param [flags='r']
     * @param [mode=0o666]
     */
    export function openSync(path: PathLike, flags: OpenMode, mode?: Mode | null): number;
    /**
     * Change the file system timestamps of the object referenced by `path`.
     *
     * The `atime` and `mtime` arguments follow these rules:
     *
     * * Values can be either numbers representing Unix epoch time in seconds, `Date`s, or a numeric string like `'123456789.0'`.
     * * If the value can not be converted to a number, or is `NaN`, `Infinity`, or `-Infinity`, an `Error` will be thrown.
     * @since v0.4.2
     */
    export function utimes(path: PathLike, atime: TimeLike, mtime: TimeLike, callback: NoParamCallback): void;
    export namespace utimes {
        /**
         * Asynchronously change file timestamps of the file referenced by the supplied path.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * @param atime The last access time. If a string is provided, it will be coerced to number.
         * @param mtime The last modified time. If a string is provided, it will be coerced to number.
         */
        function __promisify__(path: PathLike, atime: TimeLike, mtime: TimeLike): Promise<void>;
    }
    /**
     * Returns `undefined`.
     *
     * For detailed information, see the documentation of the asynchronous version of
     * this API: {@link utimes}.
     * @since v0.4.2
     */
    export function utimesSync(path: PathLike, atime: TimeLike, mtime: TimeLike): void;
    /**
     * Change the file system timestamps of the object referenced by the supplied file
     * descriptor. See {@link utimes}.
     * @since v0.4.2
     */
    export function futimes(fd: number, atime: TimeLike, mtime: TimeLike, callback: NoParamCallback): void;
    export namespace futimes {
        /**
         * Asynchronously change file timestamps of the file referenced by the supplied file descriptor.
         * @param fd A file descriptor.
         * @param atime The last access time. If a string is provided, it will be coerced to number.
         * @param mtime The last modified time. If a string is provided, it will be coerced to number.
         */
        function __promisify__(fd: number, atime: TimeLike, mtime: TimeLike): Promise<void>;
    }
    /**
     * Synchronous version of {@link futimes}. Returns `undefined`.
     * @since v0.4.2
     */
    export function futimesSync(fd: number, atime: TimeLike, mtime: TimeLike): void;
    /**
     * Request that all data for the open file descriptor is flushed to the storage
     * device. The specific implementation is operating system and device specific.
     * Refer to the POSIX [`fsync(2)`](http://man7.org/linux/man-pages/man2/fsync.2.html) documentation for more detail. No arguments other
     * than a possible exception are given to the completion callback.
     * @since v0.1.96
     */
    export function fsync(fd: number, callback: NoParamCallback): void;
    export namespace fsync {
        /**
         * Asynchronous fsync(2) - synchronize a file's in-core state with the underlying storage device.
         * @param fd A file descriptor.
         */
        function __promisify__(fd: number): Promise<void>;
    }
    /**
     * Request that all data for the open file descriptor is flushed to the storage
     * device. The specific implementation is operating system and device specific.
     * Refer to the POSIX [`fsync(2)`](http://man7.org/linux/man-pages/man2/fsync.2.html) documentation for more detail. Returns `undefined`.
     * @since v0.1.96
     */
    export function fsyncSync(fd: number): void;
    export interface WriteOptions {
        /**
         * @default 0
         */
        offset?: number | undefined;
        /**
         * @default `buffer.byteLength - offset`
         */
        length?: number | undefined;
        /**
         * @default null
         */
        position?: number | null | undefined;
    }
    /**
     * Write `buffer` to the file specified by `fd`.
     *
     * `offset` determines the part of the buffer to be written, and `length` is
     * an integer specifying the number of bytes to write.
     *
     * `position` refers to the offset from the beginning of the file where this data
     * should be written. If `typeof position !== 'number'`, the data will be written
     * at the current position. See [`pwrite(2)`](http://man7.org/linux/man-pages/man2/pwrite.2.html).
     *
     * The callback will be given three arguments `(err, bytesWritten, buffer)` where `bytesWritten` specifies how many _bytes_ were written from `buffer`.
     *
     * If this method is invoked as its `util.promisify()` ed version, it returns
     * a promise for an `Object` with `bytesWritten` and `buffer` properties.
     *
     * It is unsafe to use `fs.write()` multiple times on the same file without waiting
     * for the callback. For this scenario, {@link createWriteStream} is
     * recommended.
     *
     * On Linux, positional writes don't work when the file is opened in append mode.
     * The kernel ignores the position argument and always appends the data to
     * the end of the file.
     * @since v0.0.2
     * @param [offset=0]
     * @param [length=buffer.byteLength - offset]
     * @param [position='null']
     */
    export function write<TBuffer extends NodeJS.ArrayBufferView>(
        fd: number,
        buffer: TBuffer,
        offset: number | undefined | null,
        length: number | undefined | null,
        position: number | undefined | null,
        callback: (err: NodeJS.ErrnoException | null, written: number, buffer: TBuffer) => void,
    ): void;
    /**
     * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.
     * @param fd A file descriptor.
     * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.
     * @param length The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.
     */
    export function write<TBuffer extends NodeJS.ArrayBufferView>(
        fd: number,
        buffer: TBuffer,
        offset: number | undefined | null,
        length: number | undefined | null,
        callback: (err: NodeJS.ErrnoException | null, written: number, buffer: TBuffer) => void,
    ): void;
    /**
     * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.
     * @param fd A file descriptor.
     * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.
     */
    export function write<TBuffer extends NodeJS.ArrayBufferView>(
        fd: number,
        buffer: TBuffer,
        offset: number | undefined | null,
        callback: (err: NodeJS.ErrnoException | null, written: number, buffer: TBuffer) => void,
    ): void;
    /**
     * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.
     * @param fd A file descriptor.
     */
    export function write<TBuffer extends NodeJS.ArrayBufferView>(
        fd: number,
        buffer: TBuffer,
        callback: (err: NodeJS.ErrnoException | null, written: number, buffer: TBuffer) => void,
    ): void;
    /**
     * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.
     * @param fd A file descriptor.
     * @param options An object with the following properties:
     * * `offset` The part of the buffer to be written. If not supplied, defaults to `0`.
     * * `length` The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.
     * * `position` The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
     */
    export function write<TBuffer extends NodeJS.ArrayBufferView>(
        fd: number,
        buffer: TBuffer,
        options: WriteOptions,
        callback: (err: NodeJS.ErrnoException | null, written: number, buffer: TBuffer) => void,
    ): void;
    /**
     * Asynchronously writes `string` to the file referenced by the supplied file descriptor.
     * @param fd A file descriptor.
     * @param string A string to write.
     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
     * @param encoding The expected string encoding.
     */
    export function write(
        fd: number,
        string: string,
        position: number | undefined | null,
        encoding: BufferEncoding | undefined | null,
        callback: (err: NodeJS.ErrnoException | null, written: number, str: string) => void,
    ): void;
    /**
     * Asynchronously writes `string` to the file referenced by the supplied file descriptor.
     * @param fd A file descriptor.
     * @param string A string to write.
     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
     */
    export function write(
        fd: number,
        string: string,
        position: number | undefined | null,
        callback: (err: NodeJS.ErrnoException | null, written: number, str: string) => void,
    ): void;
    /**
     * Asynchronously writes `string` to the file referenced by the supplied file descriptor.
     * @param fd A file descriptor.
     * @param string A string to write.
     */
    export function write(
        fd: number,
        string: string,
        callback: (err: NodeJS.ErrnoException | null, written: number, str: string) => void,
    ): void;
    export namespace write {
        /**
         * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.
         * @param fd A file descriptor.
         * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.
         * @param length The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.
         * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
         */
        function __promisify__<TBuffer extends NodeJS.ArrayBufferView>(
            fd: number,
            buffer?: TBuffer,
            offset?: number,
            length?: number,
            position?: number | null,
        ): Promise<{
            bytesWritten: number;
            buffer: TBuffer;
        }>;
        /**
         * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.
         * @param fd A file descriptor.
         * @param options An object with the following properties:
         * * `offset` The part of the buffer to be written. If not supplied, defaults to `0`.
         * * `length` The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.
         * * `position` The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
         */
        function __promisify__<TBuffer extends NodeJS.ArrayBufferView>(
            fd: number,
            buffer?: TBuffer,
            options?: WriteOptions,
        ): Promise<{
            bytesWritten: number;
            buffer: TBuffer;
        }>;
        /**
         * Asynchronously writes `string` to the file referenced by the supplied file descriptor.
         * @param fd A file descriptor.
         * @param string A string to write.
         * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
         * @param encoding The expected string encoding.
         */
        function __promisify__(
            fd: number,
            string: string,
            position?: number | null,
            encoding?: BufferEncoding | null,
        ): Promise<{
            bytesWritten: number;
            buffer: string;
        }>;
    }
    /**
     * For detailed information, see the documentation of the asynchronous version of
     * this API: {@link write}.
     * @since v0.1.21
     * @param [offset=0]
     * @param [length=buffer.byteLength - offset]
     * @param [position='null']
     * @return The number of bytes written.
     */
    export function writeSync(
        fd: number,
        buffer: NodeJS.ArrayBufferView,
        offset?: number | null,
        length?: number | null,
        position?: number | null,
    ): number;
    /**
     * Synchronously writes `string` to the file referenced by the supplied file descriptor, returning the number of bytes written.
     * @param fd A file descriptor.
     * @param string A string to write.
     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
     * @param encoding The expected string encoding.
     */
    export function writeSync(
        fd: number,
        string: string,
        position?: number | null,
        encoding?: BufferEncoding | null,
    ): number;
    export type ReadPosition = number | bigint;
    export interface ReadSyncOptions {
        /**
         * @default 0
         */
        offset?: number | undefined;
        /**
         * @default `length of buffer`
         */
        length?: number | undefined;
        /**
         * @default null
         */
        position?: ReadPosition | null | undefined;
    }
    export interface ReadAsyncOptions<TBuffer extends NodeJS.ArrayBufferView> extends ReadSyncOptions {
        buffer?: TBuffer;
    }
    /**
     * Read data from the file specified by `fd`.
     *
     * The callback is given the three arguments, `(err, bytesRead, buffer)`.
     *
     * If the file is not modified concurrently, the end-of-file is reached when the
     * number of bytes read is zero.
     *
     * If this method is invoked as its `util.promisify()` ed version, it returns
     * a promise for an `Object` with `bytesRead` and `buffer` properties.
     * @since v0.0.2
     * @param buffer The buffer that the data will be written to.
     * @param offset The position in `buffer` to write the data to.
     * @param length The number of bytes to read.
     * @param position Specifies where to begin reading from in the file. If `position` is `null` or `-1 `, data will be read from the current file position, and the file position will be updated. If
     * `position` is an integer, the file position will be unchanged.
     */
    export function read<TBuffer extends NodeJS.ArrayBufferView>(
        fd: number,
        buffer: TBuffer,
        offset: number,
        length: number,
        position: ReadPosition | null,
        callback: (err: NodeJS.ErrnoException | null, bytesRead: number, buffer: TBuffer) => void,
    ): void;
    /**
     * Similar to the above `fs.read` function, this version takes an optional `options` object.
     * If not otherwise specified in an `options` object,
     * `buffer` defaults to `Buffer.alloc(16384)`,
     * `offset` defaults to `0`,
     * `length` defaults to `buffer.byteLength`, `- offset` as of Node 17.6.0
     * `position` defaults to `null`
     * @since v12.17.0, 13.11.0
     */
    export function read<TBuffer extends NodeJS.ArrayBufferView>(
        fd: number,
        options: ReadAsyncOptions<TBuffer>,
        callback: (err: NodeJS.ErrnoException | null, bytesRead: number, buffer: TBuffer) => void,
    ): void;
    export function read<TBuffer extends NodeJS.ArrayBufferView>(
        fd: number,
        buffer: TBuffer,
        options: ReadSyncOptions,
        callback: (err: NodeJS.ErrnoException | null, bytesRead: number, buffer: TBuffer) => void,
    ): void;
    export function read<TBuffer extends NodeJS.ArrayBufferView>(
        fd: number,
        buffer: TBuffer,
        callback: (err: NodeJS.ErrnoException | null, bytesRead: number, buffer: TBuffer) => void,
    ): void;
    export function read(
        fd: number,
        callback: (err: NodeJS.ErrnoException | null, bytesRead: number, buffer: NodeJS.ArrayBufferView) => void,
    ): void;
    export namespace read {
        /**
         * @param fd A file descriptor.
         * @param buffer The buffer that the data will be written to.
         * @param offset The offset in the buffer at which to start writing.
         * @param length The number of bytes to read.
         * @param position The offset from the beginning of the file from which data should be read. If `null`, data will be read from the current position.
         */
        function __promisify__<TBuffer extends NodeJS.ArrayBufferView>(
            fd: number,
            buffer: TBuffer,
            offset: number,
            length: number,
            position: ReadPosition | null,
        ): Promise<{
            bytesRead: number;
            buffer: TBuffer;
        }>;
        function __promisify__<TBuffer extends NodeJS.ArrayBufferView>(
            fd: number,
            options: ReadAsyncOptions<TBuffer>,
        ): Promise<{
            bytesRead: number;
            buffer: TBuffer;
        }>;
        function __promisify__(fd: number): Promise<{
            bytesRead: number;
            buffer: NodeJS.ArrayBufferView;
        }>;
    }
    /**
     * Returns the number of `bytesRead`.
     *
     * For detailed information, see the documentation of the asynchronous version of
     * this API: {@link read}.
     * @since v0.1.21
     * @param [position='null']
     */
    export function readSync(
        fd: number,
        buffer: NodeJS.ArrayBufferView,
        offset: number,
        length: number,
        position: ReadPosition | null,
    ): number;
    /**
     * Similar to the above `fs.readSync` function, this version takes an optional `options` object.
     * If no `options` object is specified, it will default with the above values.
     */
    export function readSync(fd: number, buffer: NodeJS.ArrayBufferView, opts?: ReadSyncOptions): number;
    /**
     * Asynchronously reads the entire contents of a file.
     *
     * ```js
     * import { readFile } from 'node:fs';
     *
     * readFile('/etc/passwd', (err, data) => {
     *   if (err) throw err;
     *   console.log(data);
     * });
     * ```
     *
     * The callback is passed two arguments `(err, data)`, where `data` is the
     * contents of the file.
     *
     * If no encoding is specified, then the raw buffer is returned.
     *
     * If `options` is a string, then it specifies the encoding:
     *
     * ```js
     * import { readFile } from 'node:fs';
     *
     * readFile('/etc/passwd', 'utf8', callback);
     * ```
     *
     * When the path is a directory, the behavior of `fs.readFile()` and {@link readFileSync} is platform-specific. On macOS, Linux, and Windows, an
     * error will be returned. On FreeBSD, a representation of the directory's contents
     * will be returned.
     *
     * ```js
     * import { readFile } from 'node:fs';
     *
     * // macOS, Linux, and Windows
     * readFile('<directory>', (err, data) => {
     *   // => [Error: EISDIR: illegal operation on a directory, read <directory>]
     * });
     *
     * //  FreeBSD
     * readFile('<directory>', (err, data) => {
     *   // => null, <data>
     * });
     * ```
     *
     * It is possible to abort an ongoing request using an `AbortSignal`. If a
     * request is aborted the callback is called with an `AbortError`:
     *
     * ```js
     * import { readFile } from 'node:fs';
     *
     * const controller = new AbortController();
     * const signal = controller.signal;
     * readFile(fileInfo[0].name, { signal }, (err, buf) => {
     *   // ...
     * });
     * // When you want to abort the request
     * controller.abort();
     * ```
     *
     * The `fs.readFile()` function buffers the entire file. To minimize memory costs,
     * when possible prefer streaming via `fs.createReadStream()`.
     *
     * Aborting an ongoing request does not abort individual operating
     * system requests but rather the internal buffering `fs.readFile` performs.
     * @since v0.1.29
     * @param path filename or file descriptor
     */
    export function readFile(
        path: PathOrFileDescriptor,
        options:
            | ({
                encoding?: null | undefined;
                flag?: string | undefined;
            } & Abortable)
            | undefined
            | null,
        callback: (err: NodeJS.ErrnoException | null, data: NonSharedBuffer) => void,
    ): void;
    /**
     * Asynchronously reads the entire contents of a file.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
     * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.
     * If a flag is not provided, it defaults to `'r'`.
     */
    export function readFile(
        path: PathOrFileDescriptor,
        options:
            | ({
                encoding: BufferEncoding;
                flag?: string | undefined;
            } & Abortable)
            | BufferEncoding,
        callback: (err: NodeJS.ErrnoException | null, data: string) => void,
    ): void;
    /**
     * Asynchronously reads the entire contents of a file.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
     * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.
     * If a flag is not provided, it defaults to `'r'`.
     */
    export function readFile(
        path: PathOrFileDescriptor,
        options:
            | (ObjectEncodingOptions & {
                flag?: string | undefined;
            } & Abortable)
            | BufferEncoding
            | undefined
            | null,
        callback: (err: NodeJS.ErrnoException | null, data: string | NonSharedBuffer) => void,
    ): void;
    /**
     * Asynchronously reads the entire contents of a file.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
     */
    export function readFile(
        path: PathOrFileDescriptor,
        callback: (err: NodeJS.ErrnoException | null, data: NonSharedBuffer) => void,
    ): void;
    export namespace readFile {
        /**
         * Asynchronously reads the entire contents of a file.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
         * @param options An object that may contain an optional flag.
         * If a flag is not provided, it defaults to `'r'`.
         */
        function __promisify__(
            path: PathOrFileDescriptor,
            options?: {
                encoding?: null | undefined;
                flag?: string | undefined;
            } | null,
        ): Promise<NonSharedBuffer>;
        /**
         * Asynchronously reads the entire contents of a file.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * URL support is _experimental_.
         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
         * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.
         * If a flag is not provided, it defaults to `'r'`.
         */
        function __promisify__(
            path: PathOrFileDescriptor,
            options:
                | {
                    encoding: BufferEncoding;
                    flag?: string | undefined;
                }
                | BufferEncoding,
        ): Promise<string>;
        /**
         * Asynchronously reads the entire contents of a file.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * URL support is _experimental_.
         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
         * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.
         * If a flag is not provided, it defaults to `'r'`.
         */
        function __promisify__(
            path: PathOrFileDescriptor,
            options?:
                | (ObjectEncodingOptions & {
                    flag?: string | undefined;
                })
                | BufferEncoding
                | null,
        ): Promise<string | NonSharedBuffer>;
    }
    /**
     * Returns the contents of the `path`.
     *
     * For detailed information, see the documentation of the asynchronous version of
     * this API: {@link readFile}.
     *
     * If the `encoding` option is specified then this function returns a
     * string. Otherwise it returns a buffer.
     *
     * Similar to {@link readFile}, when the path is a directory, the behavior of `fs.readFileSync()` is platform-specific.
     *
     * ```js
     * import { readFileSync } from 'node:fs';
     *
     * // macOS, Linux, and Windows
     * readFileSync('<directory>');
     * // => [Error: EISDIR: illegal operation on a directory, read <directory>]
     *
     * //  FreeBSD
     * readFileSync('<directory>'); // => <data>
     * ```
     * @since v0.1.8
     * @param path filename or file descriptor
     */
    export function readFileSync(
        path: PathOrFileDescriptor,
        options?: {
            encoding?: null | undefined;
            flag?: string | undefined;
        } | null,
    ): NonSharedBuffer;
    /**
     * Synchronously reads the entire contents of a file.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
     * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.
     * If a flag is not provided, it defaults to `'r'`.
     */
    export function readFileSync(
        path: PathOrFileDescriptor,
        options:
            | {
                encoding: BufferEncoding;
                flag?: string | undefined;
            }
            | BufferEncoding,
    ): string;
    /**
     * Synchronously reads the entire contents of a file.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
     * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.
     * If a flag is not provided, it defaults to `'r'`.
     */
    export function readFileSync(
        path: PathOrFileDescriptor,
        options?:
            | (ObjectEncodingOptions & {
                flag?: string | undefined;
            })
            | BufferEncoding
            | null,
    ): string | NonSharedBuffer;
    export type WriteFileOptions =
        | (
            & ObjectEncodingOptions
            & Abortable
            & {
                mode?: Mode | undefined;
                flag?: string | undefined;
                flush?: boolean | undefined;
            }
        )
        | BufferEncoding
        | null;
    /**
     * When `file` is a filename, asynchronously writes data to the file, replacing the
     * file if it already exists. `data` can be a string or a buffer.
     *
     * When `file` is a file descriptor, the behavior is similar to calling `fs.write()` directly (which is recommended). See the notes below on using
     * a file descriptor.
     *
     * The `encoding` option is ignored if `data` is a buffer.
     *
     * The `mode` option only affects the newly created file. See {@link open} for more details.
     *
     * ```js
     * import { writeFile } from 'node:fs';
     * import { Buffer } from 'node:buffer';
     *
     * const data = new Uint8Array(Buffer.from('Hello Node.js'));
     * writeFile('message.txt', data, (err) => {
     *   if (err) throw err;
     *   console.log('The file has been saved!');
     * });
     * ```
     *
     * If `options` is a string, then it specifies the encoding:
     *
     * ```js
     * import { writeFile } from 'node:fs';
     *
     * writeFile('message.txt', 'Hello Node.js', 'utf8', callback);
     * ```
     *
     * It is unsafe to use `fs.writeFile()` multiple times on the same file without
     * waiting for the callback. For this scenario, {@link createWriteStream} is
     * recommended.
     *
     * Similarly to `fs.readFile` \- `fs.writeFile` is a convenience method that
     * performs multiple `write` calls internally to write the buffer passed to it.
     * For performance sensitive code consider using {@link createWriteStream}.
     *
     * It is possible to use an `AbortSignal` to cancel an `fs.writeFile()`.
     * Cancelation is "best effort", and some amount of data is likely still
     * to be written.
     *
     * ```js
     * import { writeFile } from 'node:fs';
     * import { Buffer } from 'node:buffer';
     *
     * const controller = new AbortController();
     * const { signal } = controller;
     * const data = new Uint8Array(Buffer.from('Hello Node.js'));
     * writeFile('message.txt', data, { signal }, (err) => {
     *   // When a request is aborted - the callback is called with an AbortError
     * });
     * // When the request should be aborted
     * controller.abort();
     * ```
     *
     * Aborting an ongoing request does not abort individual operating
     * system requests but rather the internal buffering `fs.writeFile` performs.
     * @since v0.1.29
     * @param file filename or file descriptor
     */
    export function writeFile(
        file: PathOrFileDescriptor,
        data: string | NodeJS.ArrayBufferView,
        options: WriteFileOptions,
        callback: NoParamCallback,
    ): void;
    /**
     * Asynchronously writes data to a file, replacing the file if it already exists.
     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.
     */
    export function writeFile(
        path: PathOrFileDescriptor,
        data: string | NodeJS.ArrayBufferView,
        callback: NoParamCallback,
    ): void;
    export namespace writeFile {
        /**
         * Asynchronously writes data to a file, replacing the file if it already exists.
         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
         * URL support is _experimental_.
         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
         * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.
         * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.
         * If `encoding` is not supplied, the default of `'utf8'` is used.
         * If `mode` is not supplied, the default of `0o666` is used.
         * If `mode` is a string, it is parsed as an octal integer.
         * If `flag` is not supplied, the default of `'w'` is used.
         */
        function __promisify__(
            path: PathOrFileDescriptor,
            data: string | NodeJS.ArrayBufferView,
            options?: WriteFileOptions,
        ): Promise<void>;
    }
    /**
     * Returns `undefined`.
     *
     * The `mode` option only affects the newly created file. See {@link open} for more details.
     *
     * For detailed information, see the documentation of the asynchronous version of
     * this API: {@link writeFile}.
     * @since v0.1.29
     * @param file filename or file descriptor
     */
    export function writeFileSync(
        file: PathOrFileDescriptor,
        data: string | NodeJS.ArrayBufferView,
        options?: WriteFileOptions,
    ): void;
    /**
     * Asynchronously append data to a file, creating the file if it does not yet
     * exist. `data` can be a string or a `Buffer`.
     *
     * The `mode` option only affects the newly created file. See {@link open} for more details.
     *
     * ```js
     * import { appendFile } from 'node:fs';
     *
     * appendFile('message.txt', 'data to append', (err) => {
     *   if (err) throw err;
     *   console.log('The "data to append" was appended to file!');
     * });
     * ```
     *
     * If `options` is a string, then it specifies the encoding:
     *
     * ```js
     * import { appendFile } from 'node:fs';
     *
     * appendFile('message.txt', 'data to append', 'utf8', callback);
     * ```
     *
     * The `path` may be specified as a numeric file descriptor that has been opened
     * for appending (using `fs.open()` or `fs.openSync()`). The file descriptor will
     * not be closed automatically.
     *
     * ```js
     * import { open, close, appendFile } from 'node:fs';
     *
     * function closeFd(fd) {
     *   close(fd, (err) => {
     *     if (err) throw err;
     *   });
     * }
     *
     * open('message.txt', 'a', (err, fd) => {
     *   if (err) throw err;
     *
     *   try {
     *     appendFile(fd, 'data to append', 'utf8', (err) => {
     *       closeFd(fd);
     *       if (err) throw err;
     *     });
     *   } catch (err) {
     *     closeFd(fd);
     *     throw err;
     *   }
     * });
     * ```
     * @since v0.6.7
     * @param path filename or file descriptor
     */
    export function appendFile(
        path: PathOrFileDescriptor,
        data: string | Uint8Array,
        options: WriteFileOptions,
        callback: NoParamCallback,
    ): void;
    /**
     * Asynchronously append data to a file, creating the file if it does not exist.
     * @param file A path to a file. If a URL is provided, it must use the `file:` protocol.
     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.
     */
    export function appendFile(file: PathOrFileDescriptor, data: string | Uint8Array, callback: NoParamCallback): void;
    export namespace appendFile {
        /**
         * Asynchronously append data to a file, creating the file if it does not exist.
         * @param file A path to a file. If a URL is provided, it must use the `file:` protocol.
         * URL support is _experimental_.
         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
         * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.
         * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.
         * If `encoding` is not supplied, the default of `'utf8'` is used.
         * If `mode` is not supplied, the default of `0o666` is used.
         * If `mode` is a string, it is parsed as an octal integer.
         * If `flag` is not supplied, the default of `'a'` is used.
         */
        function __promisify__(
            file: PathOrFileDescriptor,
            data: string | Uint8Array,
            options?: WriteFileOptions,
        ): Promise<void>;
    }
    /**
     * Synchronously append data to a file, creating the file if it does not yet
     * exist. `data` can be a string or a `Buffer`.
     *
     * The `mode` option only affects the newly created file. See {@link open} for more details.
     *
     * ```js
     * import { appendFileSync } from 'node:fs';
     *
     * try {
     *   appendFileSync('message.txt', 'data to append');
     *   console.log('The "data to append" was appended to file!');
     * } catch (err) {
     *   // Handle the error
     * }
     * ```
     *
     * If `options` is a string, then it specifies the encoding:
     *
     * ```js
     * import { appendFileSync } from 'node:fs';
     *
     * appendFileSync('message.txt', 'data to append', 'utf8');
     * ```
     *
     * The `path` may be specified as a numeric file descriptor that has been opened
     * for appending (using `fs.open()` or `fs.openSync()`). The file descriptor will
     * not be closed automatically.
     *
     * ```js
     * import { openSync, closeSync, appendFileSync } from 'node:fs';
     *
     * let fd;
     *
     * try {
     *   fd = openSync('message.txt', 'a');
     *   appendFileSync(fd, 'data to append', 'utf8');
     * } catch (err) {
     *   // Handle the error
     * } finally {
     *   if (fd !== undefined)
     *     closeSync(fd);
     * }
     * ```
     * @since v0.6.7
     * @param path filename or file descriptor
     */
    export function appendFileSync(
        path: PathOrFileDescriptor,
        data: string | Uint8Array,
        options?: WriteFileOptions,
    ): void;
    /**
     * Watch for changes on `filename`. The callback `listener` will be called each
     * time the file is accessed.
     *
     * The `options` argument may be omitted. If provided, it should be an object. The `options` object may contain a boolean named `persistent` that indicates
     * whether the process should continue to run as long as files are being watched.
     * The `options` object may specify an `interval` property indicating how often the
     * target should be polled in milliseconds.
     *
     * The `listener` gets two arguments the current stat object and the previous
     * stat object:
     *
     * ```js
     * import { watchFile } from 'node:fs';
     *
     * watchFile('message.text', (curr, prev) => {
     *   console.log(`the current mtime is: ${curr.mtime}`);
     *   console.log(`the previous mtime was: ${prev.mtime}`);
     * });
     * ```
     *
     * These stat objects are instances of `fs.Stat`. If the `bigint` option is `true`,
     * the numeric values in these objects are specified as `BigInt`s.
     *
     * To be notified when the file was modified, not just accessed, it is necessary
     * to compare `curr.mtimeMs` and `prev.mtimeMs`.
     *
     * When an `fs.watchFile` operation results in an `ENOENT` error, it
     * will invoke the listener once, with all the fields zeroed (or, for dates, the
     * Unix Epoch). If the file is created later on, the listener will be called
     * again, with the latest stat objects. This is a change in functionality since
     * v0.10.
     *
     * Using {@link watch} is more efficient than `fs.watchFile` and `fs.unwatchFile`. `fs.watch` should be used instead of `fs.watchFile` and `fs.unwatchFile` when possible.
     *
     * When a file being watched by `fs.watchFile()` disappears and reappears,
     * then the contents of `previous` in the second callback event (the file's
     * reappearance) will be the same as the contents of `previous` in the first
     * callback event (its disappearance).
     *
     * This happens when:
     *
     * * the file is deleted, followed by a restore
     * * the file is renamed and then renamed a second time back to its original name
     * @since v0.1.31
     */
    export interface WatchFileOptions {
        bigint?: boolean | undefined;
        persistent?: boolean | undefined;
        interval?: number | undefined;
    }
    /**
     * Watch for changes on `filename`. The callback `listener` will be called each
     * time the file is accessed.
     *
     * The `options` argument may be omitted. If provided, it should be an object. The `options` object may contain a boolean named `persistent` that indicates
     * whether the process should continue to run as long as files are being watched.
     * The `options` object may specify an `interval` property indicating how often the
     * target should be polled in milliseconds.
     *
     * The `listener` gets two arguments the current stat object and the previous
     * stat object:
     *
     * ```js
     * import { watchFile } from 'node:fs';
     *
     * watchFile('message.text', (curr, prev) => {
     *   console.log(`the current mtime is: ${curr.mtime}`);
     *   console.log(`the previous mtime was: ${prev.mtime}`);
     * });
     * ```
     *
     * These stat objects are instances of `fs.Stat`. If the `bigint` option is `true`,
     * the numeric values in these objects are specified as `BigInt`s.
     *
     * To be notified when the file was modified, not just accessed, it is necessary
     * to compare `curr.mtimeMs` and `prev.mtimeMs`.
     *
     * When an `fs.watchFile` operation results in an `ENOENT` error, it
     * will invoke the listener once, with all the fields zeroed (or, for dates, the
     * Unix Epoch). If the file is created later on, the listener will be called
     * again, with the latest stat objects. This is a change in functionality since
     * v0.10.
     *
     * Using {@link watch} is more efficient than `fs.watchFile` and `fs.unwatchFile`. `fs.watch` should be used instead of `fs.watchFile` and `fs.unwatchFile` when possible.
     *
     * When a file being watched by `fs.watchFile()` disappears and reappears,
     * then the contents of `previous` in the second callback event (the file's
     * reappearance) will be the same as the contents of `previous` in the first
     * callback event (its disappearance).
     *
     * This happens when:
     *
     * * the file is deleted, followed by a restore
     * * the file is renamed and then renamed a second time back to its original name
     * @since v0.1.31
     */
    export function watchFile(
        filename: PathLike,
        options:
            | (WatchFileOptions & {
                bigint?: false | undefined;
            })
            | undefined,
        listener: StatsListener,
    ): StatWatcher;
    export function watchFile(
        filename: PathLike,
        options:
            | (WatchFileOptions & {
                bigint: true;
            })
            | undefined,
        listener: BigIntStatsListener,
    ): StatWatcher;
    /**
     * Watch for changes on `filename`. The callback `listener` will be called each time the file is accessed.
     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
     */
    export function watchFile(filename: PathLike, listener: StatsListener): StatWatcher;
    /**
     * Stop watching for changes on `filename`. If `listener` is specified, only that
     * particular listener is removed. Otherwise, _all_ listeners are removed,
     * effectively stopping watching of `filename`.
     *
     * Calling `fs.unwatchFile()` with a filename that is not being watched is a
     * no-op, not an error.
     *
     * Using {@link watch} is more efficient than `fs.watchFile()` and `fs.unwatchFile()`. `fs.watch()` should be used instead of `fs.watchFile()` and `fs.unwatchFile()` when possible.
     * @since v0.1.31
     * @param listener Optional, a listener previously attached using `fs.watchFile()`
     */
    export function unwatchFile(filename: PathLike, listener?: StatsListener): void;
    export function unwatchFile(filename: PathLike, listener?: BigIntStatsListener): void;
    export interface WatchOptions extends Abortable {
        encoding?: BufferEncoding | "buffer" | undefined;
        persistent?: boolean | undefined;
        recursive?: boolean | undefined;
    }
    export interface WatchOptionsWithBufferEncoding extends WatchOptions {
        encoding: "buffer";
    }
    export interface WatchOptionsWithStringEncoding extends WatchOptions {
        encoding?: BufferEncoding | undefined;
    }
    export type WatchEventType = "rename" | "change";
    export type WatchListener<T> = (event: WatchEventType, filename: T | null) => void;
    export type StatsListener = (curr: Stats, prev: Stats) => void;
    export type BigIntStatsListener = (curr: BigIntStats, prev: BigIntStats) => void;
    /**
     * Watch for changes on `filename`, where `filename` is either a file or a
     * directory.
     *
     * The second argument is optional. If `options` is provided as a string, it
     * specifies the `encoding`. Otherwise `options` should be passed as an object.
     *
     * The listener callback gets two arguments `(eventType, filename)`. `eventType`is either `'rename'` or `'change'`, and `filename` is the name of the file
     * which triggered the event.
     *
     * On most platforms, `'rename'` is emitted whenever a filename appears or
     * disappears in the directory.
     *
     * The listener callback is attached to the `'change'` event fired by `fs.FSWatcher`, but it is not the same thing as the `'change'` value of `eventType`.
     *
     * If a `signal` is passed, aborting the corresponding AbortController will close
     * the returned `fs.FSWatcher`.
     * @since v0.5.10
     * @param listener
     */
    export function watch(
        filename: PathLike,
        options?: WatchOptionsWithStringEncoding | BufferEncoding | null,
        listener?: WatchListener<string>,
    ): FSWatcher;
    export function watch(
        filename: PathLike,
        options: WatchOptionsWithBufferEncoding | "buffer",
        listener: WatchListener<Buffer>,
    ): FSWatcher;
    export function watch(
        filename: PathLike,
        options: WatchOptions | BufferEncoding | "buffer" | null,
        listener: WatchListener<string | Buffer>,
    ): FSWatcher;
    export function watch(filename: PathLike, listener: WatchListener<string>): FSWatcher;
    /**
     * Test whether or not the given path exists by checking with the file system.
     * Then call the `callback` argument with either true or false:
     *
     * ```js
     * import { exists } from 'node:fs';
     *
     * exists('/etc/passwd', (e) => {
     *   console.log(e ? 'it exists' : 'no passwd!');
     * });
     * ```
     *
     * **The parameters for this callback are not consistent with other Node.js**
     * **callbacks.** Normally, the first parameter to a Node.js callback is an `err` parameter, optionally followed by other parameters. The `fs.exists()` callback
     * has only one boolean parameter. This is one reason `fs.access()` is recommended
     * instead of `fs.exists()`.
     *
     * Using `fs.exists()` to check for the existence of a file before calling `fs.open()`, `fs.readFile()`, or `fs.writeFile()` is not recommended. Doing
     * so introduces a race condition, since other processes may change the file's
     * state between the two calls. Instead, user code should open/read/write the
     * file directly and handle the error raised if the file does not exist.
     *
     * **write (NOT RECOMMENDED)**
     *
     * ```js
     * import { exists, open, close } from 'node:fs';
     *
     * exists('myfile', (e) => {
     *   if (e) {
     *     console.error('myfile already exists');
     *   } else {
     *     open('myfile', 'wx', (err, fd) => {
     *       if (err) throw err;
     *
     *       try {
     *         writeMyData(fd);
     *       } finally {
     *         close(fd, (err) => {
     *           if (err) throw err;
     *         });
     *       }
     *     });
     *   }
     * });
     * ```
     *
     * **write (RECOMMENDED)**
     *
     * ```js
     * import { open, close } from 'node:fs';
     * open('myfile', 'wx', (err, fd) => {
     *   if (err) {
     *     if (err.code === 'EEXIST') {
     *       console.error('myfile already exists');
     *       return;
     *     }
     *
     *     throw err;
     *   }
     *
     *   try {
     *     writeMyData(fd);
     *   } finally {
     *     close(fd, (err) => {
     *       if (err) throw err;
     *     });
     *   }
     * });
     * ```
     *
     * **read (NOT RECOMMENDED)**
     *
     * ```js
     * import { open, close, exists } from 'node:fs';
     *
     * exists('myfile', (e) => {
     *   if (e) {
     *     open('myfile', 'r', (err, fd) => {
     *       if (err) throw err;
     *
     *       try {
     *         readMyData(fd);
     *       } finally {
     *         close(fd, (err) => {
     *           if (err) throw err;
     *         });
     *       }
     *     });
     *   } else {
     *     console.error('myfile does not exist');
     *   }
     * });
     * ```
     *
     * **read (RECOMMENDED)**
     *
     * ```js
     * import { open, close } from 'node:fs';
     *
     * open('myfile', 'r', (err, fd) => {
     *   if (err) {
     *     if (err.code === 'ENOENT') {
     *       console.error('myfile does not exist');
     *       return;
     *     }
     *
     *     throw err;
     *   }
     *
     *   try {
     *     readMyData(fd);
     *   } finally {
     *     close(fd, (err) => {
     *       if (err) throw err;
     *     });
     *   }
     * });
     * ```
     *
     * The "not recommended" examples above check for existence and then use the
     * file; the "recommended" examples are better because they use the file directly
     * and handle the error, if any.
     *
     * In general, check for the existence of a file only if the file won't be
     * used directly, for example when its existence is a signal from another
     * process.
     * @since v0.0.2
     * @deprecated Since v1.0.0 - Use {@link stat} or {@link access} instead.
     */
    export function exists(path: PathLike, callback: (exists: boolean) => void): void;
    /** @deprecated */
    export namespace exists {
        /**
         * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
         * URL support is _experimental_.
         */
        function __promisify__(path: PathLike): Promise<boolean>;
    }
    /**
     * Returns `true` if the path exists, `false` otherwise.
     *
     * For detailed information, see the documentation of the asynchronous version of
     * this API: {@link exists}.
     *
     * `fs.exists()` is deprecated, but `fs.existsSync()` is not. The `callback` parameter to `fs.exists()` accepts parameters that are inconsistent with other
     * Node.js callbacks. `fs.existsSync()` does not use a callback.
     *
     * ```js
     * import { existsSync } from 'node:fs';
     *
     * if (existsSync('/etc/passwd'))
     *   console.log('The path exists.');
     * ```
     * @since v0.1.21
     */
    export function existsSync(path: PathLike): boolean;
    export namespace constants {
        // File Access Constants
        /** Constant for fs.access(). File is visible to the calling process. */
        const F_OK: number;
        /** Constant for fs.access(). File can be read by the calling process. */
        const R_OK: number;
        /** Constant for fs.access(). File can be written by the calling process. */
        const W_OK: number;
        /** Constant for fs.access(). File can be executed by the calling process. */
        const X_OK: number;
        // File Copy Constants
        /** Constant for fs.copyFile. Flag indicating the destination file should not be overwritten if it already exists. */
        const COPYFILE_EXCL: number;
        /**
         * Constant for fs.copyFile. copy operation will attempt to create a copy-on-write reflink.
         * If the underlying platform does not support copy-on-write, then a fallback copy mechanism is used.
         */
        const COPYFILE_FICLONE: number;
        /**
         * Constant for fs.copyFile. Copy operation will attempt to create a copy-on-write reflink.
         * If the underlying platform does not support copy-on-write, then the operation will fail with an error.
         */
        const COPYFILE_FICLONE_FORCE: number;
        // File Open Constants
        /** Constant for fs.open(). Flag indicating to open a file for read-only access. */
        const O_RDONLY: number;
        /** Constant for fs.open(). Flag indicating to open a file for write-only access. */
        const O_WRONLY: number;
        /** Constant for fs.open(). Flag indicating to open a file for read-write access. */
        const O_RDWR: number;
        /** Constant for fs.open(). Flag indicating to create the file if it does not already exist. */
        const O_CREAT: number;
        /** Constant for fs.open(). Flag indicating that opening a file should fail if the O_CREAT flag is set and the file already exists. */
        const O_EXCL: number;
        /**
         * Constant for fs.open(). Flag indicating that if path identifies a terminal device,
         * opening the path shall not cause that terminal to become the controlling terminal for the process
         * (if the process does not already have one).
         */
        const O_NOCTTY: number;
        /** Constant for fs.open(). Flag indicating that if the file exists and is a regular file, and the file is opened successfully for write access, its length shall be truncated to zero. */
        const O_TRUNC: number;
        /** Constant for fs.open(). Flag indicating that data will be appended to the end of the file. */
        const O_APPEND: number;
        /** Constant for fs.open(). Flag indicating that the open should fail if the path is not a directory. */
        const O_DIRECTORY: number;
        /**
         * constant for fs.open().
         * Flag indicating reading accesses to the file system will no longer result in
         * an update to the atime information associated with the file.
         * This flag is available on Linux operating systems only.
         */
        const O_NOATIME: number;
        /** Constant for fs.open(). Flag indicating that the open should fail if the path is a symbolic link. */
        const O_NOFOLLOW: number;
        /** Constant for fs.open(). Flag indicating that the file is opened for synchronous I/O. */
        const O_SYNC: number;
        /** Constant for fs.open(). Flag indicating that the file is opened for synchronous I/O with write operations waiting for data integrity. */
        const O_DSYNC: number;
        /** Constant for fs.open(). Flag indicating to open the symbolic link itself rather than the resource it is pointing to. */
        const O_SYMLINK: number;
        /** Constant for fs.open(). When set, an attempt will be made to minimize caching effects of file I/O. */
        const O_DIRECT: number;
        /** Constant for fs.open(). Flag indicating to open the file in nonblocking mode when possible. */
        const O_NONBLOCK: number;
        // File Type Constants
        /** Constant for fs.Stats mode property for determining a file's type. Bit mask used to extract the file type code. */
        const S_IFMT: number;
        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a regular file. */
        const S_IFREG: number;
        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a directory. */
        const S_IFDIR: number;
        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a character-oriented device file. */
        const S_IFCHR: number;
        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a block-oriented device file. */
        const S_IFBLK: number;
        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a FIFO/pipe. */
        const S_IFIFO: number;
        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a symbolic link. */
        const S_IFLNK: number;
        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a socket. */
        const S_IFSOCK: number;
        // File Mode Constants
        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable, writable and executable by owner. */
        const S_IRWXU: number;
        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable by owner. */
        const S_IRUSR: number;
        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating writable by owner. */
        const S_IWUSR: number;
        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating executable by owner. */
        const S_IXUSR: number;
        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable, writable and executable by group. */
        const S_IRWXG: number;
        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable by group. */
        const S_IRGRP: number;
        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating writable by group. */
        const S_IWGRP: number;
        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating executable by group. */
        const S_IXGRP: number;
        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable, writable and executable by others. */
        const S_IRWXO: number;
        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable by others. */
        const S_IROTH: number;
        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating writable by others. */
        const S_IWOTH: number;
        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating executable by others. */
        const S_IXOTH: number;
        /**
         * When set, a memory file mapping is used to access the file. This flag
         * is available on Windows operating systems only. On other operating systems,
         * this flag is ignored.
         */
        const UV_FS_O_FILEMAP: number;
    }
    /**
     * Tests a user's permissions for the file or directory specified by `path`.
     * The `mode` argument is an optional integer that specifies the accessibility
     * checks to be performed. `mode` should be either the value `fs.constants.F_OK` or a mask consisting of the bitwise OR of any of `fs.constants.R_OK`, `fs.constants.W_OK`, and `fs.constants.X_OK`
     * (e.g.`fs.constants.W_OK | fs.constants.R_OK`). Check `File access constants` for
     * possible values of `mode`.
     *
     * The final argument, `callback`, is a callback function that is invoked with
     * a possible error argument. If any of the accessibility checks fail, the error
     * argument will be an `Error` object. The following examples check if `package.json` exists, and if it is readable or writable.
     *
     * ```js
     * import { access, constants } from 'node:fs';
     *
     * const file = 'package.json';
     *
     * // Check if the file exists in the current directory.
     * access(file, constants.F_OK, (err) => {
     *   console.log(`${file} ${err ? 'does not exist' : 'exists'}`);
     * });
     *
     * // Check if the file is readable.
     * access(file, constants.R_OK, (err) => {
     *   console.log(`${file} ${err ? 'is not readable' : 'is readable'}`);
     * });
     *
     * // Check if the file is writable.
     * access(file, constants.W_OK, (err) => {
     *   console.log(`${file} ${err ? 'is not writable' : 'is writable'}`);
     * });
     *
     * // Check if the file is readable and writable.
     * access(file, constants.R_OK | constants.W_OK, (err) => {
     *   console.log(`${file} ${err ? 'is not' : 'is'} readable and writable`);
     * });
     * ```
     *
     * Do not use `fs.access()` to check for the accessibility of a file before calling `fs.open()`, `fs.readFile()`, or `fs.writeFile()`. Doing
     * so introduces a race condition, since other processes may change the file's
     * state between the two calls. Instead, user code should open/read/write the
     * file directly and handle the error raised if the file is not accessible.
     *
     * **write (NOT RECOMMENDED)**
     *
     * ```js
     * import { access, open, close } from 'node:fs';
     *
     * access('myfile', (err) => {
     *   if (!err) {
     *     console.error('myfile already exists');
     *     return;
     *   }
     *
     *   open('myfile', 'wx', (err, fd) => {
     *     if (err) throw err;
     *
     *     try {
     *       writeMyData(fd);
     *     } finally {
     *       close(fd, (err) => {
     *         if (err) throw err;
     *       });
     *     }
     *   });
     * });
     * ```
     *
     * **write (RECOMMENDED)**
     *
     * ```js
     * import { open, close } from 'node:fs';
     *
     * open('myfile', 'wx', (err, fd) => {
     *   if (err) {
     *     if (err.code === 'EEXIST') {
     *       console.error('myfile already exists');
     *       return;
     *     }
     *
     *     throw err;
     *   }
     *
     *   try {
     *     writeMyData(fd);
     *   } finally {
     *     close(fd, (err) => {
     *       if (err) throw err;
     *     });
     *   }
     * });
     * ```
     *
     * **read (NOT RECOMMENDED)**
     *
     * ```js
     * import { access, open, close } from 'node:fs';
     * access('myfile', (err) => {
     *   if (err) {
     *     if (err.code === 'ENOENT') {
     *       console.error('myfile does not exist');
     *       return;
     *     }
     *
     *     throw err;
     *   }
     *
     *   open('myfile', 'r', (err, fd) => {
     *     if (err) throw err;
     *
     *     try {
     *       readMyData(fd);
     *     } finally {
     *       close(fd, (err) => {
     *         if (err) throw err;
     *       });
     *     }
     *   });
     * });
     * ```
     *
     * **read (RECOMMENDED)**
     *
     * ```js
     * import { open, close } from 'node:fs';
     *
     * open('myfile', 'r', (err, fd) => {
     *   if (err) {
     *     if (err.code === 'ENOENT') {
     *       console.error('myfile does not exist');
     *       return;
     *     }
     *
     *     throw err;
     *   }
     *
     *   try {
     *     readMyData(fd);
     *   } finally {
     *     close(fd, (err) => {
     *       if (err) throw err;
     *     });
     *   }
     * });
     * ```
     *
     * The "not recommended" examples above check for accessibility and then use the
     * file; the "recommended" examples are better because they use the file directly
     * and handle the error, if any.
     *
     * In general, check for the accessibility of a file only if the file will not be
     * used directly, for example when its accessibility is a signal from another
     * process.
     *
     * On Windows, access-control policies (ACLs) on a directory may limit access to
     * a file or directory. The `fs.access()` function, however, does not check the
     * ACL and therefore may report that a path is accessible even if the ACL restricts
     * the user from reading or writing to it.
     * @since v0.11.15
     * @param [mode=fs.constants.F_OK]
     */
    export function access(path: PathLike, mode: number | undefined, callback: NoParamCallback): void;
    /**
     * Asynchronously tests a user's permissions for the file specified by path.
     * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
     */
    export function access(path: PathLike, callback: NoParamCallback): void;
    export namespace access {
        /**
         * Asynchronously tests a user's permissions for the file specified by path.
         * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
         * URL support is _experimental_.
         */
        function __promisify__(path: PathLike, mode?: number): Promise<void>;
    }
    /**
     * Synchronously tests a user's permissions for the file or directory specified
     * by `path`. The `mode` argument is an optional integer that specifies the
     * accessibility checks to be performed. `mode` should be either the value `fs.constants.F_OK` or a mask consisting of the bitwise OR of any of `fs.constants.R_OK`, `fs.constants.W_OK`, and
     * `fs.constants.X_OK` (e.g.`fs.constants.W_OK | fs.constants.R_OK`). Check `File access constants` for
     * possible values of `mode`.
     *
     * If any of the accessibility checks fail, an `Error` will be thrown. Otherwise,
     * the method will return `undefined`.
     *
     * ```js
     * import { accessSync, constants } from 'node:fs';
     *
     * try {
     *   accessSync('etc/passwd', constants.R_OK | constants.W_OK);
     *   console.log('can read/write');
     * } catch (err) {
     *   console.error('no access!');
     * }
     * ```
     * @since v0.11.15
     * @param [mode=fs.constants.F_OK]
     */
    export function accessSync(path: PathLike, mode?: number): void;
    interface StreamOptions {
        flags?: string | undefined;
        encoding?: BufferEncoding | undefined;
        fd?: number | promises.FileHandle | undefined;
        mode?: number | undefined;
        autoClose?: boolean | undefined;
        emitClose?: boolean | undefined;
        start?: number | undefined;
        signal?: AbortSignal | null | undefined;
        highWaterMark?: number | undefined;
    }
    interface FSImplementation {
        open?: (...args: any[]) => any;
        close?: (...args: any[]) => any;
    }
    interface CreateReadStreamFSImplementation extends FSImplementation {
        read: (...args: any[]) => any;
    }
    interface CreateWriteStreamFSImplementation extends FSImplementation {
        write: (...args: any[]) => any;
        writev?: (...args: any[]) => any;
    }
    interface ReadStreamOptions extends StreamOptions {
        fs?: CreateReadStreamFSImplementation | null | undefined;
        end?: number | undefined;
    }
    interface WriteStreamOptions extends StreamOptions {
        fs?: CreateWriteStreamFSImplementation | null | undefined;
        flush?: boolean | undefined;
    }
    /**
     * `options` can include `start` and `end` values to read a range of bytes from
     * the file instead of the entire file. Both `start` and `end` are inclusive and
     * start counting at 0, allowed values are in the
     * \[0, [`Number.MAX_SAFE_INTEGER`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER)\] range. If `fd` is specified and `start` is
     * omitted or `undefined`, `fs.createReadStream()` reads sequentially from the
     * current file position. The `encoding` can be any one of those accepted by `Buffer`.
     *
     * If `fd` is specified, `ReadStream` will ignore the `path` argument and will use
     * the specified file descriptor. This means that no `'open'` event will be
     * emitted. `fd` should be blocking; non-blocking `fd`s should be passed to `net.Socket`.
     *
     * If `fd` points to a character device that only supports blocking reads
     * (such as keyboard or sound card), read operations do not finish until data is
     * available. This can prevent the process from exiting and the stream from
     * closing naturally.
     *
     * By default, the stream will emit a `'close'` event after it has been
     * destroyed.  Set the `emitClose` option to `false` to change this behavior.
     *
     * By providing the `fs` option, it is possible to override the corresponding `fs` implementations for `open`, `read`, and `close`. When providing the `fs` option,
     * an override for `read` is required. If no `fd` is provided, an override for `open` is also required. If `autoClose` is `true`, an override for `close` is
     * also required.
     *
     * ```js
     * import { createReadStream } from 'node:fs';
     *
     * // Create a stream from some character device.
     * const stream = createReadStream('/dev/input/event0');
     * setTimeout(() => {
     *   stream.close(); // This may not close the stream.
     *   // Artificially marking end-of-stream, as if the underlying resource had
     *   // indicated end-of-file by itself, allows the stream to close.
     *   // This does not cancel pending read operations, and if there is such an
     *   // operation, the process may still not be able to exit successfully
     *   // until it finishes.
     *   stream.push(null);
     *   stream.read(0);
     * }, 100);
     * ```
     *
     * If `autoClose` is false, then the file descriptor won't be closed, even if
     * there's an error. It is the application's responsibility to close it and make
     * sure there's no file descriptor leak. If `autoClose` is set to true (default
     * behavior), on `'error'` or `'end'` the file descriptor will be closed
     * automatically.
     *
     * `mode` sets the file mode (permission and sticky bits), but only if the
     * file was created.
     *
     * An example to read the last 10 bytes of a file which is 100 bytes long:
     *
     * ```js
     * import { createReadStream } from 'node:fs';
     *
     * createReadStream('sample.txt', { start: 90, end: 99 });
     * ```
     *
     * If `options` is a string, then it specifies the encoding.
     * @since v0.1.31
     */
    export function createReadStream(path: PathLike, options?: BufferEncoding | ReadStreamOptions): ReadStream;
    /**
     * `options` may also include a `start` option to allow writing data at some
     * position past the beginning of the file, allowed values are in the
     * \[0, [`Number.MAX_SAFE_INTEGER`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER)\] range. Modifying a file rather than
     * replacing it may require the `flags` option to be set to `r+` rather than the
     * default `w`. The `encoding` can be any one of those accepted by `Buffer`.
     *
     * If `autoClose` is set to true (default behavior) on `'error'` or `'finish'` the file descriptor will be closed automatically. If `autoClose` is false,
     * then the file descriptor won't be closed, even if there's an error.
     * It is the application's responsibility to close it and make sure there's no
     * file descriptor leak.
     *
     * By default, the stream will emit a `'close'` event after it has been
     * destroyed.  Set the `emitClose` option to `false` to change this behavior.
     *
     * By providing the `fs` option it is possible to override the corresponding `fs` implementations for `open`, `write`, `writev`, and `close`. Overriding `write()` without `writev()` can reduce
     * performance as some optimizations (`_writev()`)
     * will be disabled. When providing the `fs` option, overrides for at least one of `write` and `writev` are required. If no `fd` option is supplied, an override
     * for `open` is also required. If `autoClose` is `true`, an override for `close` is also required.
     *
     * Like `fs.ReadStream`, if `fd` is specified, `fs.WriteStream` will ignore the `path` argument and will use the specified file descriptor. This means that no `'open'` event will be
     * emitted. `fd` should be blocking; non-blocking `fd`s
     * should be passed to `net.Socket`.
     *
     * If `options` is a string, then it specifies the encoding.
     * @since v0.1.31
     */
    export function createWriteStream(path: PathLike, options?: BufferEncoding | WriteStreamOptions): WriteStream;
    /**
     * Forces all currently queued I/O operations associated with the file to the
     * operating system's synchronized I/O completion state. Refer to the POSIX [`fdatasync(2)`](http://man7.org/linux/man-pages/man2/fdatasync.2.html) documentation for details. No arguments other
     * than a possible
     * exception are given to the completion callback.
     * @since v0.1.96
     */
    export function fdatasync(fd: number, callback: NoParamCallback): void;
    export namespace fdatasync {
        /**
         * Asynchronous fdatasync(2) - synchronize a file's in-core state with storage device.
         * @param fd A file descriptor.
         */
        function __promisify__(fd: number): Promise<void>;
    }
    /**
     * Forces all currently queued I/O operations associated with the file to the
     * operating system's synchronized I/O completion state. Refer to the POSIX [`fdatasync(2)`](http://man7.org/linux/man-pages/man2/fdatasync.2.html) documentation for details. Returns `undefined`.
     * @since v0.1.96
     */
    export function fdatasyncSync(fd: number): void;
    /**
     * Asynchronously copies `src` to `dest`. By default, `dest` is overwritten if it
     * already exists. No arguments other than a possible exception are given to the
     * callback function. Node.js makes no guarantees about the atomicity of the copy
     * operation. If an error occurs after the destination file has been opened for
     * writing, Node.js will attempt to remove the destination.
     *
     * `mode` is an optional integer that specifies the behavior
     * of the copy operation. It is possible to create a mask consisting of the bitwise
     * OR of two or more values (e.g.`fs.constants.COPYFILE_EXCL | fs.constants.COPYFILE_FICLONE`).
     *
     * * `fs.constants.COPYFILE_EXCL`: The copy operation will fail if `dest` already
     * exists.
     * * `fs.constants.COPYFILE_FICLONE`: The copy operation will attempt to create a
     * copy-on-write reflink. If the platform does not support copy-on-write, then a
     * fallback copy mechanism is used.
     * * `fs.constants.COPYFILE_FICLONE_FORCE`: The copy operation will attempt to
     * create a copy-on-write reflink. If the platform does not support
     * copy-on-write, then the operation will fail.
     *
     * ```js
     * import { copyFile, constants } from 'node:fs';
     *
     * function callback(err) {
     *   if (err) throw err;
     *   console.log('source.txt was copied to destination.txt');
     * }
     *
     * // destination.txt will be created or overwritten by default.
     * copyFile('source.txt', 'destination.txt', callback);
     *
     * // By using COPYFILE_EXCL, the operation will fail if destination.txt exists.
     * copyFile('source.txt', 'destination.txt', constants.COPYFILE_EXCL, callback);
     * ```
     * @since v8.5.0
     * @param src source filename to copy
     * @param dest destination filename of the copy operation
     * @param [mode=0] modifiers for copy operation.
     */
    export function copyFile(src: PathLike, dest: PathLike, callback: NoParamCallback): void;
    export function copyFile(src: PathLike, dest: PathLike, mode: number, callback: NoParamCallback): void;
    export namespace copyFile {
        function __promisify__(src: PathLike, dst: PathLike, mode?: number): Promise<void>;
    }
    /**
     * Synchronously copies `src` to `dest`. By default, `dest` is overwritten if it
     * already exists. Returns `undefined`. Node.js makes no guarantees about the
     * atomicity of the copy operation. If an error occurs after the destination file
     * has been opened for writing, Node.js will attempt to remove the destination.
     *
     * `mode` is an optional integer that specifies the behavior
     * of the copy operation. It is possible to create a mask consisting of the bitwise
     * OR of two or more values (e.g.`fs.constants.COPYFILE_EXCL | fs.constants.COPYFILE_FICLONE`).
     *
     * * `fs.constants.COPYFILE_EXCL`: The copy operation will fail if `dest` already
     * exists.
     * * `fs.constants.COPYFILE_FICLONE`: The copy operation will attempt to create a
     * copy-on-write reflink. If the platform does not support copy-on-write, then a
     * fallback copy mechanism is used.
     * * `fs.constants.COPYFILE_FICLONE_FORCE`: The copy operation will attempt to
     * create a copy-on-write reflink. If the platform does not support
     * copy-on-write, then the operation will fail.
     *
     * ```js
     * import { copyFileSync, constants } from 'node:fs';
     *
     * // destination.txt will be created or overwritten by default.
     * copyFileSync('source.txt', 'destination.txt');
     * console.log('source.txt was copied to destination.txt');
     *
     * // By using COPYFILE_EXCL, the operation will fail if destination.txt exists.
     * copyFileSync('source.txt', 'destination.txt', constants.COPYFILE_EXCL);
     * ```
     * @since v8.5.0
     * @param src source filename to copy
     * @param dest destination filename of the copy operation
     * @param [mode=0] modifiers for copy operation.
     */
    export function copyFileSync(src: PathLike, dest: PathLike, mode?: number): void;
    /**
     * Write an array of `ArrayBufferView`s to the file specified by `fd` using `writev()`.
     *
     * `position` is the offset from the beginning of the file where this data
     * should be written. If `typeof position !== 'number'`, the data will be written
     * at the current position.
     *
     * The callback will be given three arguments: `err`, `bytesWritten`, and `buffers`. `bytesWritten` is how many bytes were written from `buffers`.
     *
     * If this method is `util.promisify()` ed, it returns a promise for an `Object` with `bytesWritten` and `buffers` properties.
     *
     * It is unsafe to use `fs.writev()` multiple times on the same file without
     * waiting for the callback. For this scenario, use {@link createWriteStream}.
     *
     * On Linux, positional writes don't work when the file is opened in append mode.
     * The kernel ignores the position argument and always appends the data to
     * the end of the file.
     * @since v12.9.0
     * @param [position='null']
     */
    export function writev(
        fd: number,
        buffers: readonly NodeJS.ArrayBufferView[],
        cb: (err: NodeJS.ErrnoException | null, bytesWritten: number, buffers: NodeJS.ArrayBufferView[]) => void,
    ): void;
    export function writev(
        fd: number,
        buffers: readonly NodeJS.ArrayBufferView[],
        position: number | null,
        cb: (err: NodeJS.ErrnoException | null, bytesWritten: number, buffers: NodeJS.ArrayBufferView[]) => void,
    ): void;
    export interface WriteVResult {
        bytesWritten: number;
        buffers: NodeJS.ArrayBufferView[];
    }
    export namespace writev {
        function __promisify__(
            fd: number,
            buffers: readonly NodeJS.ArrayBufferView[],
            position?: number,
        ): Promise<WriteVResult>;
    }
    /**
     * For detailed information, see the documentation of the asynchronous version of
     * this API: {@link writev}.
     * @since v12.9.0
     * @param [position='null']
     * @return The number of bytes written.
     */
    export function writevSync(fd: number, buffers: readonly NodeJS.ArrayBufferView[], position?: number): number;
    /**
     * Read from a file specified by `fd` and write to an array of `ArrayBufferView`s
     * using `readv()`.
     *
     * `position` is the offset from the beginning of the file from where data
     * should be read. If `typeof position !== 'number'`, the data will be read
     * from the current position.
     *
     * The callback will be given three arguments: `err`, `bytesRead`, and `buffers`. `bytesRead` is how many bytes were read from the file.
     *
     * If this method is invoked as its `util.promisify()` ed version, it returns
     * a promise for an `Object` with `bytesRead` and `buffers` properties.
     * @since v13.13.0, v12.17.0
     * @param [position='null']
     */
    export function readv(
        fd: number,
        buffers: readonly NodeJS.ArrayBufferView[],
        cb: (err: NodeJS.ErrnoException | null, bytesRead: number, buffers: NodeJS.ArrayBufferView[]) => void,
    ): void;
    export function readv(
        fd: number,
        buffers: readonly NodeJS.ArrayBufferView[],
        position: number | null,
        cb: (err: NodeJS.ErrnoException | null, bytesRead: number, buffers: NodeJS.ArrayBufferView[]) => void,
    ): void;
    export interface ReadVResult {
        bytesRead: number;
        buffers: NodeJS.ArrayBufferView[];
    }
    export namespace readv {
        function __promisify__(
            fd: number,
            buffers: readonly NodeJS.ArrayBufferView[],
            position?: number,
        ): Promise<ReadVResult>;
    }
    /**
     * For detailed information, see the documentation of the asynchronous version of
     * this API: {@link readv}.
     * @since v13.13.0, v12.17.0
     * @param [position='null']
     * @return The number of bytes read.
     */
    export function readvSync(fd: number, buffers: readonly NodeJS.ArrayBufferView[], position?: number): number;

    export interface OpenAsBlobOptions {
        /**
         * An optional mime type for the blob.
         *
         * @default 'undefined'
         */
        type?: string | undefined;
    }

    /**
     * Returns a `Blob` whose data is backed by the given file.
     *
     * The file must not be modified after the `Blob` is created. Any modifications
     * will cause reading the `Blob` data to fail with a `DOMException` error.
     * Synchronous stat operations on the file when the `Blob` is created, and before
     * each read in order to detect whether the file data has been modified on disk.
     *
     * ```js
     * import { openAsBlob } from 'node:fs';
     *
     * const blob = await openAsBlob('the.file.txt');
     * const ab = await blob.arrayBuffer();
     * blob.stream();
     * ```
     * @since v19.8.0
     */
    export function openAsBlob(path: PathLike, options?: OpenAsBlobOptions): Promise<Blob>;

    export interface OpenDirOptions {
        /**
         * @default 'utf8'
         */
        encoding?: BufferEncoding | undefined;
        /**
         * Number of directory entries that are buffered
         * internally when reading from the directory. Higher values lead to better
         * performance but higher memory usage.
         * @default 32
         */
        bufferSize?: number | undefined;
        /**
         * @default false
         */
        recursive?: boolean | undefined;
    }
    /**
     * Synchronously open a directory. See [`opendir(3)`](http://man7.org/linux/man-pages/man3/opendir.3.html).
     *
     * Creates an `fs.Dir`, which contains all further functions for reading from
     * and cleaning up the directory.
     *
     * The `encoding` option sets the encoding for the `path` while opening the
     * directory and subsequent read operations.
     * @since v12.12.0
     */
    export function opendirSync(path: PathLike, options?: OpenDirOptions): Dir;
    /**
     * Asynchronously open a directory. See the POSIX [`opendir(3)`](http://man7.org/linux/man-pages/man3/opendir.3.html) documentation for
     * more details.
     *
     * Creates an `fs.Dir`, which contains all further functions for reading from
     * and cleaning up the directory.
     *
     * The `encoding` option sets the encoding for the `path` while opening the
     * directory and subsequent read operations.
     * @since v12.12.0
     */
    export function opendir(path: PathLike, cb: (err: NodeJS.ErrnoException | null, dir: Dir) => void): void;
    export function opendir(
        path: PathLike,
        options: OpenDirOptions,
        cb: (err: NodeJS.ErrnoException | null, dir: Dir) => void,
    ): void;
    export namespace opendir {
        function __promisify__(path: PathLike, options?: OpenDirOptions): Promise<Dir>;
    }
    export interface BigIntStats extends StatsBase<bigint> {
        atimeNs: bigint;
        mtimeNs: bigint;
        ctimeNs: bigint;
        birthtimeNs: bigint;
    }
    export interface BigIntOptions {
        bigint: true;
    }
    export interface StatOptions {
        bigint?: boolean | undefined;
    }
    export interface StatSyncOptions extends StatOptions {
        throwIfNoEntry?: boolean | undefined;
    }
    interface CopyOptionsBase {
        /**
         * Dereference symlinks
         * @default false
         */
        dereference?: boolean | undefined;
        /**
         * When `force` is `false`, and the destination
         * exists, throw an error.
         * @default false
         */
        errorOnExist?: boolean | undefined;
        /**
         * Overwrite existing file or directory. _The copy
         * operation will ignore errors if you set this to false and the destination
         * exists. Use the `errorOnExist` option to change this behavior.
         * @default true
         */
        force?: boolean | undefined;
        /**
         * Modifiers for copy operation. See `mode` flag of {@link copyFileSync()}
         */
        mode?: number | undefined;
        /**
         * When `true` timestamps from `src` will
         * be preserved.
         * @default false
         */
        preserveTimestamps?: boolean | undefined;
        /**
         * Copy directories recursively.
         * @default false
         */
        recursive?: boolean | undefined;
        /**
         * When true, path resolution for symlinks will be skipped
         * @default false
         */
        verbatimSymlinks?: boolean | undefined;
    }
    export interface CopyOptions extends CopyOptionsBase {
        /**
         * Function to filter copied files/directories. Return
         * `true` to copy the item, `false` to ignore it.
         */
        filter?: ((source: string, destination: string) => boolean | Promise<boolean>) | undefined;
    }
    export interface CopySyncOptions extends CopyOptionsBase {
        /**
         * Function to filter copied files/directories. Return
         * `true` to copy the item, `false` to ignore it.
         */
        filter?: ((source: string, destination: string) => boolean) | undefined;
    }
    /**
     * Asynchronously copies the entire directory structure from `src` to `dest`,
     * including subdirectories and files.
     *
     * When copying a directory to another directory, globs are not supported and
     * behavior is similar to `cp dir1/ dir2/`.
     * @since v16.7.0
     * @experimental
     * @param src source path to copy.
     * @param dest destination path to copy to.
     */
    export function cp(
        source: string | URL,
        destination: string | URL,
        callback: (err: NodeJS.ErrnoException | null) => void,
    ): void;
    export function cp(
        source: string | URL,
        destination: string | URL,
        opts: CopyOptions,
        callback: (err: NodeJS.ErrnoException | null) => void,
    ): void;
    /**
     * Synchronously copies the entire directory structure from `src` to `dest`,
     * including subdirectories and files.
     *
     * When copying a directory to another directory, globs are not supported and
     * behavior is similar to `cp dir1/ dir2/`.
     * @since v16.7.0
     * @experimental
     * @param src source path to copy.
     * @param dest destination path to copy to.
     */
    export function cpSync(source: string | URL, destination: string | URL, opts?: CopySyncOptions): void;

    interface _GlobOptions<T extends Dirent | string> {
        /**
         * Current working directory.
         * @default process.cwd()
         */
        cwd?: string | URL | undefined;
        /**
         * `true` if the glob should return paths as `Dirent`s, `false` otherwise.
         * @default false
         * @since v22.2.0
         */
        withFileTypes?: boolean | undefined;
        /**
         * Function to filter out files/directories or a
         * list of glob patterns to be excluded. If a function is provided, return
         * `true` to exclude the item, `false` to include it.
         * @default undefined
         */
        exclude?: ((fileName: T) => boolean) | readonly string[] | undefined;
    }
    export interface GlobOptions extends _GlobOptions<Dirent | string> {}
    export interface GlobOptionsWithFileTypes extends _GlobOptions<Dirent> {
        withFileTypes: true;
    }
    export interface GlobOptionsWithoutFileTypes extends _GlobOptions<string> {
        withFileTypes?: false | undefined;
    }

    /**
     * Retrieves the files matching the specified pattern.
     *
     * ```js
     * import { glob } from 'node:fs';
     *
     * glob('*.js', (err, matches) => {
     *   if (err) throw err;
     *   console.log(matches);
     * });
     * ```
     * @since v22.0.0
     */
    export function glob(
        pattern: string | readonly string[],
        callback: (err: NodeJS.ErrnoException | null, matches: string[]) => void,
    ): void;
    export function glob(
        pattern: string | readonly string[],
        options: GlobOptionsWithFileTypes,
        callback: (
            err: NodeJS.ErrnoException | null,
            matches: Dirent[],
        ) => void,
    ): void;
    export function glob(
        pattern: string | readonly string[],
        options: GlobOptionsWithoutFileTypes,
        callback: (
            err: NodeJS.ErrnoException | null,
            matches: string[],
        ) => void,
    ): void;
    export function glob(
        pattern: string | readonly string[],
        options: GlobOptions,
        callback: (
            err: NodeJS.ErrnoException | null,
            matches: Dirent[] | string[],
        ) => void,
    ): void;
    /**
     * ```js
     * import { globSync } from 'node:fs';
     *
     * console.log(globSync('*.js'));
     * ```
     * @since v22.0.0
     * @returns paths of files that match the pattern.
     */
    export function globSync(pattern: string | readonly string[]): string[];
    export function globSync(
        pattern: string | readonly string[],
        options: GlobOptionsWithFileTypes,
    ): Dirent[];
    export function globSync(
        pattern: string | readonly string[],
        options: GlobOptionsWithoutFileTypes,
    ): string[];
    export function globSync(
        pattern: string | readonly string[],
        options: GlobOptions,
    ): Dirent[] | string[];
}
declare module "node:fs" {
    export * from "fs";
}

```

## ./lib/lambda/node_modules/@types/node/globals.d.ts

```typescript
declare var global: typeof globalThis;

declare var process: NodeJS.Process;
declare var console: Console;

interface ErrorConstructor {
    /**
     * Creates a `.stack` property on `targetObject`, which when accessed returns
     * a string representing the location in the code at which
     * `Error.captureStackTrace()` was called.
     *
     * ```js
     * const myObject = {};
     * Error.captureStackTrace(myObject);
     * myObject.stack;  // Similar to `new Error().stack`
     * ```
     *
     * The first line of the trace will be prefixed with
     * `${myObject.name}: ${myObject.message}`.
     *
     * The optional `constructorOpt` argument accepts a function. If given, all frames
     * above `constructorOpt`, including `constructorOpt`, will be omitted from the
     * generated stack trace.
     *
     * The `constructorOpt` argument is useful for hiding implementation
     * details of error generation from the user. For instance:
     *
     * ```js
     * function a() {
     *   b();
     * }
     *
     * function b() {
     *   c();
     * }
     *
     * function c() {
     *   // Create an error without stack trace to avoid calculating the stack trace twice.
     *   const { stackTraceLimit } = Error;
     *   Error.stackTraceLimit = 0;
     *   const error = new Error();
     *   Error.stackTraceLimit = stackTraceLimit;
     *
     *   // Capture the stack trace above function b
     *   Error.captureStackTrace(error, b); // Neither function c, nor b is included in the stack trace
     *   throw error;
     * }
     *
     * a();
     * ```
     */
    captureStackTrace(targetObject: object, constructorOpt?: Function): void;
    /**
     * @see https://v8.dev/docs/stack-trace-api#customizing-stack-traces
     */
    prepareStackTrace(err: Error, stackTraces: NodeJS.CallSite[]): any;
    /**
     * The `Error.stackTraceLimit` property specifies the number of stack frames
     * collected by a stack trace (whether generated by `new Error().stack` or
     * `Error.captureStackTrace(obj)`).
     *
     * The default value is `10` but may be set to any valid JavaScript number. Changes
     * will affect any stack trace captured _after_ the value has been changed.
     *
     * If set to a non-number value, or set to a negative number, stack traces will
     * not capture any frames.
     */
    stackTraceLimit: number;
}

/**
 * Enable this API with the `--expose-gc` CLI flag.
 */
declare var gc: NodeJS.GCFunction | undefined;

declare namespace NodeJS {
    interface CallSite {
        getColumnNumber(): number | null;
        getEnclosingColumnNumber(): number | null;
        getEnclosingLineNumber(): number | null;
        getEvalOrigin(): string | undefined;
        getFileName(): string | null;
        getFunction(): Function | undefined;
        getFunctionName(): string | null;
        getLineNumber(): number | null;
        getMethodName(): string | null;
        getPosition(): number;
        getPromiseIndex(): number | null;
        getScriptHash(): string;
        getScriptNameOrSourceURL(): string | null;
        getThis(): unknown;
        getTypeName(): string | null;
        isAsync(): boolean;
        isConstructor(): boolean;
        isEval(): boolean;
        isNative(): boolean;
        isPromiseAll(): boolean;
        isToplevel(): boolean;
    }

    interface ErrnoException extends Error {
        errno?: number | undefined;
        code?: string | undefined;
        path?: string | undefined;
        syscall?: string | undefined;
    }

    interface ReadableStream extends EventEmitter {
        readable: boolean;
        read(size?: number): string | Buffer;
        setEncoding(encoding: BufferEncoding): this;
        pause(): this;
        resume(): this;
        isPaused(): boolean;
        pipe<T extends WritableStream>(destination: T, options?: { end?: boolean | undefined }): T;
        unpipe(destination?: WritableStream): this;
        unshift(chunk: string | Uint8Array, encoding?: BufferEncoding): void;
        wrap(oldStream: ReadableStream): this;
        [Symbol.asyncIterator](): AsyncIterableIterator<string | Buffer>;
    }

    interface WritableStream extends EventEmitter {
        writable: boolean;
        write(buffer: Uint8Array | string, cb?: (err?: Error | null) => void): boolean;
        write(str: string, encoding?: BufferEncoding, cb?: (err?: Error | null) => void): boolean;
        end(cb?: () => void): this;
        end(data: string | Uint8Array, cb?: () => void): this;
        end(str: string, encoding?: BufferEncoding, cb?: () => void): this;
    }

    interface ReadWriteStream extends ReadableStream, WritableStream {}

    interface RefCounted {
        ref(): this;
        unref(): this;
    }

    interface Dict<T> {
        [key: string]: T | undefined;
    }

    interface ReadOnlyDict<T> {
        readonly [key: string]: T | undefined;
    }

    type PartialOptions<T> = { [K in keyof T]?: T[K] | undefined };

    interface GCFunction {
        (minor?: boolean): void;
        (options: NodeJS.GCOptions & { execution: "async" }): Promise<void>;
        (options: NodeJS.GCOptions): void;
    }

    interface GCOptions {
        execution?: "sync" | "async" | undefined;
        flavor?: "regular" | "last-resort" | undefined;
        type?: "major-snapshot" | "major" | "minor" | undefined;
        filename?: string | undefined;
    }

    /** An iterable iterator returned by the Node.js API. */
    // Default TReturn/TNext in v22 is `any`, for compatibility with the previously-used IterableIterator.
    interface Iterator<T, TReturn = any, TNext = any> extends IteratorObject<T, TReturn, TNext> {
        [Symbol.iterator](): NodeJS.Iterator<T, TReturn, TNext>;
    }

    /** An async iterable iterator returned by the Node.js API. */
    // Default TReturn/TNext in v22 is `any`, for compatibility with the previously-used AsyncIterableIterator.
    interface AsyncIterator<T, TReturn = any, TNext = any> extends AsyncIteratorObject<T, TReturn, TNext> {
        [Symbol.asyncIterator](): NodeJS.AsyncIterator<T, TReturn, TNext>;
    }
}

```

## ./lib/lambda/node_modules/@types/node/globals.typedarray.d.ts

```typescript
export {}; // Make this a module

declare global {
    namespace NodeJS {
        type TypedArray<TArrayBuffer extends ArrayBufferLike = ArrayBufferLike> =
            | Uint8Array<TArrayBuffer>
            | Uint8ClampedArray<TArrayBuffer>
            | Uint16Array<TArrayBuffer>
            | Uint32Array<TArrayBuffer>
            | Int8Array<TArrayBuffer>
            | Int16Array<TArrayBuffer>
            | Int32Array<TArrayBuffer>
            | BigUint64Array<TArrayBuffer>
            | BigInt64Array<TArrayBuffer>
            | Float32Array<TArrayBuffer>
            | Float64Array<TArrayBuffer>;
        type ArrayBufferView<TArrayBuffer extends ArrayBufferLike = ArrayBufferLike> =
            | TypedArray<TArrayBuffer>
            | DataView<TArrayBuffer>;
    }
}

```

## ./lib/lambda/node_modules/@types/node/http.d.ts

```typescript
/**
 * To use the HTTP server and client one must import the `node:http` module.
 *
 * The HTTP interfaces in Node.js are designed to support many features
 * of the protocol which have been traditionally difficult to use.
 * In particular, large, possibly chunk-encoded, messages. The interface is
 * careful to never buffer entire requests or responses, so the
 * user is able to stream data.
 *
 * HTTP message headers are represented by an object like this:
 *
 * ```json
 * { "content-length": "123",
 *   "content-type": "text/plain",
 *   "connection": "keep-alive",
 *   "host": "example.com",
 *   "accept": "*" }
 * ```
 *
 * Keys are lowercased. Values are not modified.
 *
 * In order to support the full spectrum of possible HTTP applications, the Node.js
 * HTTP API is very low-level. It deals with stream handling and message
 * parsing only. It parses a message into headers and body but it does not
 * parse the actual headers or the body.
 *
 * See `message.headers` for details on how duplicate headers are handled.
 *
 * The raw headers as they were received are retained in the `rawHeaders` property, which is an array of `[key, value, key2, value2, ...]`. For
 * example, the previous message header object might have a `rawHeaders` list like the following:
 *
 * ```js
 * [ 'ConTent-Length', '123456',
 *   'content-LENGTH', '123',
 *   'content-type', 'text/plain',
 *   'CONNECTION', 'keep-alive',
 *   'Host', 'example.com',
 *   'accepT', '*' ]
 * ```
 * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/http.js)
 */
declare module "http" {
    import * as stream from "node:stream";
    import { URL } from "node:url";
    import { LookupOptions } from "node:dns";
    import { EventEmitter } from "node:events";
    import { LookupFunction, Server as NetServer, Socket, TcpSocketConnectOpts } from "node:net";
    // incoming headers will never contain number
    interface IncomingHttpHeaders extends NodeJS.Dict<string | string[]> {
        accept?: string | undefined;
        "accept-encoding"?: string | undefined;
        "accept-language"?: string | undefined;
        "accept-patch"?: string | undefined;
        "accept-ranges"?: string | undefined;
        "access-control-allow-credentials"?: string | undefined;
        "access-control-allow-headers"?: string | undefined;
        "access-control-allow-methods"?: string | undefined;
        "access-control-allow-origin"?: string | undefined;
        "access-control-expose-headers"?: string | undefined;
        "access-control-max-age"?: string | undefined;
        "access-control-request-headers"?: string | undefined;
        "access-control-request-method"?: string | undefined;
        age?: string | undefined;
        allow?: string | undefined;
        "alt-svc"?: string | undefined;
        authorization?: string | undefined;
        "cache-control"?: string | undefined;
        connection?: string | undefined;
        "content-disposition"?: string | undefined;
        "content-encoding"?: string | undefined;
        "content-language"?: string | undefined;
        "content-length"?: string | undefined;
        "content-location"?: string | undefined;
        "content-range"?: string | undefined;
        "content-type"?: string | undefined;
        cookie?: string | undefined;
        date?: string | undefined;
        etag?: string | undefined;
        expect?: string | undefined;
        expires?: string | undefined;
        forwarded?: string | undefined;
        from?: string | undefined;
        host?: string | undefined;
        "if-match"?: string | undefined;
        "if-modified-since"?: string | undefined;
        "if-none-match"?: string | undefined;
        "if-unmodified-since"?: string | undefined;
        "last-modified"?: string | undefined;
        location?: string | undefined;
        origin?: string | undefined;
        pragma?: string | undefined;
        "proxy-authenticate"?: string | undefined;
        "proxy-authorization"?: string | undefined;
        "public-key-pins"?: string | undefined;
        range?: string | undefined;
        referer?: string | undefined;
        "retry-after"?: string | undefined;
        "sec-fetch-site"?: string | undefined;
        "sec-fetch-mode"?: string | undefined;
        "sec-fetch-user"?: string | undefined;
        "sec-fetch-dest"?: string | undefined;
        "sec-websocket-accept"?: string | undefined;
        "sec-websocket-extensions"?: string | undefined;
        "sec-websocket-key"?: string | undefined;
        "sec-websocket-protocol"?: string | undefined;
        "sec-websocket-version"?: string | undefined;
        "set-cookie"?: string[] | undefined;
        "strict-transport-security"?: string | undefined;
        tk?: string | undefined;
        trailer?: string | undefined;
        "transfer-encoding"?: string | undefined;
        upgrade?: string | undefined;
        "user-agent"?: string | undefined;
        vary?: string | undefined;
        via?: string | undefined;
        warning?: string | undefined;
        "www-authenticate"?: string | undefined;
    }
    // outgoing headers allows numbers (as they are converted internally to strings)
    type OutgoingHttpHeader = number | string | string[];
    interface OutgoingHttpHeaders extends NodeJS.Dict<OutgoingHttpHeader> {
        accept?: string | string[] | undefined;
        "accept-charset"?: string | string[] | undefined;
        "accept-encoding"?: string | string[] | undefined;
        "accept-language"?: string | string[] | undefined;
        "accept-ranges"?: string | undefined;
        "access-control-allow-credentials"?: string | undefined;
        "access-control-allow-headers"?: string | undefined;
        "access-control-allow-methods"?: string | undefined;
        "access-control-allow-origin"?: string | undefined;
        "access-control-expose-headers"?: string | undefined;
        "access-control-max-age"?: string | undefined;
        "access-control-request-headers"?: string | undefined;
        "access-control-request-method"?: string | undefined;
        age?: string | undefined;
        allow?: string | undefined;
        authorization?: string | undefined;
        "cache-control"?: string | undefined;
        "cdn-cache-control"?: string | undefined;
        connection?: string | string[] | undefined;
        "content-disposition"?: string | undefined;
        "content-encoding"?: string | undefined;
        "content-language"?: string | undefined;
        "content-length"?: string | number | undefined;
        "content-location"?: string | undefined;
        "content-range"?: string | undefined;
        "content-security-policy"?: string | undefined;
        "content-security-policy-report-only"?: string | undefined;
        "content-type"?: string | undefined;
        cookie?: string | string[] | undefined;
        dav?: string | string[] | undefined;
        dnt?: string | undefined;
        date?: string | undefined;
        etag?: string | undefined;
        expect?: string | undefined;
        expires?: string | undefined;
        forwarded?: string | undefined;
        from?: string | undefined;
        host?: string | undefined;
        "if-match"?: string | undefined;
        "if-modified-since"?: string | undefined;
        "if-none-match"?: string | undefined;
        "if-range"?: string | undefined;
        "if-unmodified-since"?: string | undefined;
        "last-modified"?: string | undefined;
        link?: string | string[] | undefined;
        location?: string | undefined;
        "max-forwards"?: string | undefined;
        origin?: string | undefined;
        pragma?: string | string[] | undefined;
        "proxy-authenticate"?: string | string[] | undefined;
        "proxy-authorization"?: string | undefined;
        "public-key-pins"?: string | undefined;
        "public-key-pins-report-only"?: string | undefined;
        range?: string | undefined;
        referer?: string | undefined;
        "referrer-policy"?: string | undefined;
        refresh?: string | undefined;
        "retry-after"?: string | undefined;
        "sec-websocket-accept"?: string | undefined;
        "sec-websocket-extensions"?: string | string[] | undefined;
        "sec-websocket-key"?: string | undefined;
        "sec-websocket-protocol"?: string | string[] | undefined;
        "sec-websocket-version"?: string | undefined;
        server?: string | undefined;
        "set-cookie"?: string | string[] | undefined;
        "strict-transport-security"?: string | undefined;
        te?: string | undefined;
        trailer?: string | undefined;
        "transfer-encoding"?: string | undefined;
        "user-agent"?: string | undefined;
        upgrade?: string | undefined;
        "upgrade-insecure-requests"?: string | undefined;
        vary?: string | undefined;
        via?: string | string[] | undefined;
        warning?: string | undefined;
        "www-authenticate"?: string | string[] | undefined;
        "x-content-type-options"?: string | undefined;
        "x-dns-prefetch-control"?: string | undefined;
        "x-frame-options"?: string | undefined;
        "x-xss-protection"?: string | undefined;
    }
    interface ClientRequestArgs extends Pick<LookupOptions, "hints"> {
        _defaultAgent?: Agent | undefined;
        agent?: Agent | boolean | undefined;
        auth?: string | null | undefined;
        createConnection?:
            | ((
                options: ClientRequestArgs,
                oncreate: (err: Error | null, socket: stream.Duplex) => void,
            ) => stream.Duplex | null | undefined)
            | undefined;
        defaultPort?: number | string | undefined;
        family?: number | undefined;
        headers?: OutgoingHttpHeaders | readonly string[] | undefined;
        host?: string | null | undefined;
        hostname?: string | null | undefined;
        insecureHTTPParser?: boolean | undefined;
        localAddress?: string | undefined;
        localPort?: number | undefined;
        lookup?: LookupFunction | undefined;
        /**
         * @default 16384
         */
        maxHeaderSize?: number | undefined;
        method?: string | undefined;
        path?: string | null | undefined;
        port?: number | string | null | undefined;
        protocol?: string | null | undefined;
        setDefaultHeaders?: boolean | undefined;
        setHost?: boolean | undefined;
        signal?: AbortSignal | undefined;
        socketPath?: string | undefined;
        timeout?: number | undefined;
        uniqueHeaders?: Array<string | string[]> | undefined;
        joinDuplicateHeaders?: boolean | undefined;
    }
    interface ServerOptions<
        Request extends typeof IncomingMessage = typeof IncomingMessage,
        Response extends typeof ServerResponse<InstanceType<Request>> = typeof ServerResponse,
    > {
        /**
         * Specifies the `IncomingMessage` class to be used. Useful for extending the original `IncomingMessage`.
         */
        IncomingMessage?: Request | undefined;
        /**
         * Specifies the `ServerResponse` class to be used. Useful for extending the original `ServerResponse`.
         */
        ServerResponse?: Response | undefined;
        /**
         * Sets the timeout value in milliseconds for receiving the entire request from the client.
         * @see Server.requestTimeout for more information.
         * @default 300000
         * @since v18.0.0
         */
        requestTimeout?: number | undefined;
        /**
         * It joins the field line values of multiple headers in a request with `, ` instead of discarding the duplicates.
         * @default false
         * @since v18.14.0
         */
        joinDuplicateHeaders?: boolean | undefined;
        /**
         * The number of milliseconds of inactivity a server needs to wait for additional incoming data,
         * after it has finished writing the last response, before a socket will be destroyed.
         * @see Server.keepAliveTimeout for more information.
         * @default 5000
         * @since v18.0.0
         */
        keepAliveTimeout?: number | undefined;
        /**
         * Sets the interval value in milliseconds to check for request and headers timeout in incomplete requests.
         * @default 30000
         */
        connectionsCheckingInterval?: number | undefined;
        /**
         * Sets the timeout value in milliseconds for receiving the complete HTTP headers from the client.
         * See {@link Server.headersTimeout} for more information.
         * @default 60000
         * @since 18.0.0
         */
        headersTimeout?: number | undefined;
        /**
         * Optionally overrides all `socket`s' `readableHighWaterMark` and `writableHighWaterMark`.
         * This affects `highWaterMark` property of both `IncomingMessage` and `ServerResponse`.
         * Default: @see stream.getDefaultHighWaterMark().
         * @since v20.1.0
         */
        highWaterMark?: number | undefined;
        /**
         * Use an insecure HTTP parser that accepts invalid HTTP headers when `true`.
         * Using the insecure parser should be avoided.
         * See --insecure-http-parser for more information.
         * @default false
         */
        insecureHTTPParser?: boolean | undefined;
        /**
         * Optionally overrides the value of `--max-http-header-size` for requests received by
         * this server, i.e. the maximum length of request headers in bytes.
         * @default 16384
         * @since v13.3.0
         */
        maxHeaderSize?: number | undefined;
        /**
         * If set to `true`, it disables the use of Nagle's algorithm immediately after a new incoming connection is received.
         * @default true
         * @since v16.5.0
         */
        noDelay?: boolean | undefined;
        /**
         * If set to `true`, it forces the server to respond with a 400 (Bad Request) status code
         * to any HTTP/1.1 request message that lacks a Host header (as mandated by the specification).
         * @default true
         * @since 20.0.0
         */
        requireHostHeader?: boolean | undefined;
        /**
         * If set to `true`, it enables keep-alive functionality on the socket immediately after a new incoming connection is received,
         * similarly on what is done in `socket.setKeepAlive([enable][, initialDelay])`.
         * @default false
         * @since v16.5.0
         */
        keepAlive?: boolean | undefined;
        /**
         * If set to a positive number, it sets the initial delay before the first keepalive probe is sent on an idle socket.
         * @default 0
         * @since v16.5.0
         */
        keepAliveInitialDelay?: number | undefined;
        /**
         * A list of response headers that should be sent only once.
         * If the header's value is an array, the items will be joined using `; `.
         */
        uniqueHeaders?: Array<string | string[]> | undefined;
        /**
         * If set to `true`, an error is thrown when writing to an HTTP response which does not have a body.
         * @default false
         * @since v18.17.0, v20.2.0
         */
        rejectNonStandardBodyWrites?: boolean | undefined;
    }
    type RequestListener<
        Request extends typeof IncomingMessage = typeof IncomingMessage,
        Response extends typeof ServerResponse<InstanceType<Request>> = typeof ServerResponse,
    > = (req: InstanceType<Request>, res: InstanceType<Response> & { req: InstanceType<Request> }) => void;
    /**
     * @since v0.1.17
     */
    class Server<
        Request extends typeof IncomingMessage = typeof IncomingMessage,
        Response extends typeof ServerResponse<InstanceType<Request>> = typeof ServerResponse,
    > extends NetServer {
        constructor(requestListener?: RequestListener<Request, Response>);
        constructor(options: ServerOptions<Request, Response>, requestListener?: RequestListener<Request, Response>);
        /**
         * Sets the timeout value for sockets, and emits a `'timeout'` event on
         * the Server object, passing the socket as an argument, if a timeout
         * occurs.
         *
         * If there is a `'timeout'` event listener on the Server object, then it
         * will be called with the timed-out socket as an argument.
         *
         * By default, the Server does not timeout sockets. However, if a callback
         * is assigned to the Server's `'timeout'` event, timeouts must be handled
         * explicitly.
         * @since v0.9.12
         * @param [msecs=0 (no timeout)]
         */
        setTimeout(msecs?: number, callback?: (socket: Socket) => void): this;
        setTimeout(callback: (socket: Socket) => void): this;
        /**
         * Limits maximum incoming headers count. If set to 0, no limit will be applied.
         * @since v0.7.0
         */
        maxHeadersCount: number | null;
        /**
         * The maximum number of requests socket can handle
         * before closing keep alive connection.
         *
         * A value of `0` will disable the limit.
         *
         * When the limit is reached it will set the `Connection` header value to `close`,
         * but will not actually close the connection, subsequent requests sent
         * after the limit is reached will get `503 Service Unavailable` as a response.
         * @since v16.10.0
         */
        maxRequestsPerSocket: number | null;
        /**
         * The number of milliseconds of inactivity before a socket is presumed
         * to have timed out.
         *
         * A value of `0` will disable the timeout behavior on incoming connections.
         *
         * The socket timeout logic is set up on connection, so changing this
         * value only affects new connections to the server, not any existing connections.
         * @since v0.9.12
         */
        timeout: number;
        /**
         * Limit the amount of time the parser will wait to receive the complete HTTP
         * headers.
         *
         * If the timeout expires, the server responds with status 408 without
         * forwarding the request to the request listener and then closes the connection.
         *
         * It must be set to a non-zero value (e.g. 120 seconds) to protect against
         * potential Denial-of-Service attacks in case the server is deployed without a
         * reverse proxy in front.
         * @since v11.3.0, v10.14.0
         */
        headersTimeout: number;
        /**
         * The number of milliseconds of inactivity a server needs to wait for additional
         * incoming data, after it has finished writing the last response, before a socket
         * will be destroyed. If the server receives new data before the keep-alive
         * timeout has fired, it will reset the regular inactivity timeout, i.e., `server.timeout`.
         *
         * A value of `0` will disable the keep-alive timeout behavior on incoming
         * connections.
         * A value of `0` makes the http server behave similarly to Node.js versions prior
         * to 8.0.0, which did not have a keep-alive timeout.
         *
         * The socket timeout logic is set up on connection, so changing this value only
         * affects new connections to the server, not any existing connections.
         * @since v8.0.0
         */
        keepAliveTimeout: number;
        /**
         * Sets the timeout value in milliseconds for receiving the entire request from
         * the client.
         *
         * If the timeout expires, the server responds with status 408 without
         * forwarding the request to the request listener and then closes the connection.
         *
         * It must be set to a non-zero value (e.g. 120 seconds) to protect against
         * potential Denial-of-Service attacks in case the server is deployed without a
         * reverse proxy in front.
         * @since v14.11.0
         */
        requestTimeout: number;
        /**
         * Closes all connections connected to this server.
         * @since v18.2.0
         */
        closeAllConnections(): void;
        /**
         * Closes all connections connected to this server which are not sending a request
         * or waiting for a response.
         * @since v18.2.0
         */
        closeIdleConnections(): void;
        addListener(event: string, listener: (...args: any[]) => void): this;
        addListener(event: "close", listener: () => void): this;
        addListener(event: "connection", listener: (socket: Socket) => void): this;
        addListener(event: "error", listener: (err: Error) => void): this;
        addListener(event: "listening", listener: () => void): this;
        addListener(event: "checkContinue", listener: RequestListener<Request, Response>): this;
        addListener(event: "checkExpectation", listener: RequestListener<Request, Response>): this;
        addListener(event: "clientError", listener: (err: Error, socket: stream.Duplex) => void): this;
        addListener(
            event: "connect",
            listener: (req: InstanceType<Request>, socket: stream.Duplex, head: Buffer) => void,
        ): this;
        addListener(event: "dropRequest", listener: (req: InstanceType<Request>, socket: stream.Duplex) => void): this;
        addListener(event: "request", listener: RequestListener<Request, Response>): this;
        addListener(
            event: "upgrade",
            listener: (req: InstanceType<Request>, socket: stream.Duplex, head: Buffer) => void,
        ): this;
        emit(event: string, ...args: any[]): boolean;
        emit(event: "close"): boolean;
        emit(event: "connection", socket: Socket): boolean;
        emit(event: "error", err: Error): boolean;
        emit(event: "listening"): boolean;
        emit(
            event: "checkContinue",
            req: InstanceType<Request>,
            res: InstanceType<Response> & { req: InstanceType<Request> },
        ): boolean;
        emit(
            event: "checkExpectation",
            req: InstanceType<Request>,
            res: InstanceType<Response> & { req: InstanceType<Request> },
        ): boolean;
        emit(event: "clientError", err: Error, socket: stream.Duplex): boolean;
        emit(event: "connect", req: InstanceType<Request>, socket: stream.Duplex, head: Buffer): boolean;
        emit(event: "dropRequest", req: InstanceType<Request>, socket: stream.Duplex): boolean;
        emit(
            event: "request",
            req: InstanceType<Request>,
            res: InstanceType<Response> & { req: InstanceType<Request> },
        ): boolean;
        emit(event: "upgrade", req: InstanceType<Request>, socket: stream.Duplex, head: Buffer): boolean;
        on(event: string, listener: (...args: any[]) => void): this;
        on(event: "close", listener: () => void): this;
        on(event: "connection", listener: (socket: Socket) => void): this;
        on(event: "error", listener: (err: Error) => void): this;
        on(event: "listening", listener: () => void): this;
        on(event: "checkContinue", listener: RequestListener<Request, Response>): this;
        on(event: "checkExpectation", listener: RequestListener<Request, Response>): this;
        on(event: "clientError", listener: (err: Error, socket: stream.Duplex) => void): this;
        on(event: "connect", listener: (req: InstanceType<Request>, socket: stream.Duplex, head: Buffer) => void): this;
        on(event: "dropRequest", listener: (req: InstanceType<Request>, socket: stream.Duplex) => void): this;
        on(event: "request", listener: RequestListener<Request, Response>): this;
        on(event: "upgrade", listener: (req: InstanceType<Request>, socket: stream.Duplex, head: Buffer) => void): this;
        once(event: string, listener: (...args: any[]) => void): this;
        once(event: "close", listener: () => void): this;
        once(event: "connection", listener: (socket: Socket) => void): this;
        once(event: "error", listener: (err: Error) => void): this;
        once(event: "listening", listener: () => void): this;
        once(event: "checkContinue", listener: RequestListener<Request, Response>): this;
        once(event: "checkExpectation", listener: RequestListener<Request, Response>): this;
        once(event: "clientError", listener: (err: Error, socket: stream.Duplex) => void): this;
        once(
            event: "connect",
            listener: (req: InstanceType<Request>, socket: stream.Duplex, head: Buffer) => void,
        ): this;
        once(event: "dropRequest", listener: (req: InstanceType<Request>, socket: stream.Duplex) => void): this;
        once(event: "request", listener: RequestListener<Request, Response>): this;
        once(
            event: "upgrade",
            listener: (req: InstanceType<Request>, socket: stream.Duplex, head: Buffer) => void,
        ): this;
        prependListener(event: string, listener: (...args: any[]) => void): this;
        prependListener(event: "close", listener: () => void): this;
        prependListener(event: "connection", listener: (socket: Socket) => void): this;
        prependListener(event: "error", listener: (err: Error) => void): this;
        prependListener(event: "listening", listener: () => void): this;
        prependListener(event: "checkContinue", listener: RequestListener<Request, Response>): this;
        prependListener(event: "checkExpectation", listener: RequestListener<Request, Response>): this;
        prependListener(event: "clientError", listener: (err: Error, socket: stream.Duplex) => void): this;
        prependListener(
            event: "connect",
            listener: (req: InstanceType<Request>, socket: stream.Duplex, head: Buffer) => void,
        ): this;
        prependListener(
            event: "dropRequest",
            listener: (req: InstanceType<Request>, socket: stream.Duplex) => void,
        ): this;
        prependListener(event: "request", listener: RequestListener<Request, Response>): this;
        prependListener(
            event: "upgrade",
            listener: (req: InstanceType<Request>, socket: stream.Duplex, head: Buffer) => void,
        ): this;
        prependOnceListener(event: string, listener: (...args: any[]) => void): this;
        prependOnceListener(event: "close", listener: () => void): this;
        prependOnceListener(event: "connection", listener: (socket: Socket) => void): this;
        prependOnceListener(event: "error", listener: (err: Error) => void): this;
        prependOnceListener(event: "listening", listener: () => void): this;
        prependOnceListener(event: "checkContinue", listener: RequestListener<Request, Response>): this;
        prependOnceListener(event: "checkExpectation", listener: RequestListener<Request, Response>): this;
        prependOnceListener(event: "clientError", listener: (err: Error, socket: stream.Duplex) => void): this;
        prependOnceListener(
            event: "connect",
            listener: (req: InstanceType<Request>, socket: stream.Duplex, head: Buffer) => void,
        ): this;
        prependOnceListener(
            event: "dropRequest",
            listener: (req: InstanceType<Request>, socket: stream.Duplex) => void,
        ): this;
        prependOnceListener(event: "request", listener: RequestListener<Request, Response>): this;
        prependOnceListener(
            event: "upgrade",
            listener: (req: InstanceType<Request>, socket: stream.Duplex, head: Buffer) => void,
        ): this;
    }
    /**
     * This class serves as the parent class of {@link ClientRequest} and {@link ServerResponse}. It is an abstract outgoing message from
     * the perspective of the participants of an HTTP transaction.
     * @since v0.1.17
     */
    class OutgoingMessage<Request extends IncomingMessage = IncomingMessage> extends stream.Writable {
        readonly req: Request;
        chunkedEncoding: boolean;
        shouldKeepAlive: boolean;
        useChunkedEncodingByDefault: boolean;
        sendDate: boolean;
        /**
         * @deprecated Use `writableEnded` instead.
         */
        finished: boolean;
        /**
         * Read-only. `true` if the headers were sent, otherwise `false`.
         * @since v0.9.3
         */
        readonly headersSent: boolean;
        /**
         * Alias of `outgoingMessage.socket`.
         * @since v0.3.0
         * @deprecated Since v15.12.0,v14.17.1 - Use `socket` instead.
         */
        readonly connection: Socket | null;
        /**
         * Reference to the underlying socket. Usually, users will not want to access
         * this property.
         *
         * After calling `outgoingMessage.end()`, this property will be nulled.
         * @since v0.3.0
         */
        readonly socket: Socket | null;
        constructor();
        /**
         * Once a socket is associated with the message and is connected, `socket.setTimeout()` will be called with `msecs` as the first parameter.
         * @since v0.9.12
         * @param callback Optional function to be called when a timeout occurs. Same as binding to the `timeout` event.
         */
        setTimeout(msecs: number, callback?: () => void): this;
        /**
         * Sets a single header value. If the header already exists in the to-be-sent
         * headers, its value will be replaced. Use an array of strings to send multiple
         * headers with the same name.
         * @since v0.4.0
         * @param name Header name
         * @param value Header value
         */
        setHeader(name: string, value: number | string | readonly string[]): this;
        /**
         * Sets multiple header values for implicit headers. headers must be an instance of
         * `Headers` or `Map`, if a header already exists in the to-be-sent headers, its
         * value will be replaced.
         *
         * ```js
         * const headers = new Headers({ foo: 'bar' });
         * outgoingMessage.setHeaders(headers);
         * ```
         *
         * or
         *
         * ```js
         * const headers = new Map([['foo', 'bar']]);
         * outgoingMessage.setHeaders(headers);
         * ```
         *
         * When headers have been set with `outgoingMessage.setHeaders()`, they will be
         * merged with any headers passed to `response.writeHead()`, with the headers passed
         * to `response.writeHead()` given precedence.
         *
         * ```js
         * // Returns content-type = text/plain
         * const server = http.createServer((req, res) => {
         *   const headers = new Headers({ 'Content-Type': 'text/html' });
         *   res.setHeaders(headers);
         *   res.writeHead(200, { 'Content-Type': 'text/plain' });
         *   res.end('ok');
         * });
         * ```
         *
         * @since v19.6.0, v18.15.0
         * @param name Header name
         * @param value Header value
         */
        setHeaders(headers: Headers | Map<string, number | string | readonly string[]>): this;
        /**
         * Append a single header value to the header object.
         *
         * If the value is an array, this is equivalent to calling this method multiple
         * times.
         *
         * If there were no previous values for the header, this is equivalent to calling `outgoingMessage.setHeader(name, value)`.
         *
         * Depending of the value of `options.uniqueHeaders` when the client request or the
         * server were created, this will end up in the header being sent multiple times or
         * a single time with values joined using `; `.
         * @since v18.3.0, v16.17.0
         * @param name Header name
         * @param value Header value
         */
        appendHeader(name: string, value: string | readonly string[]): this;
        /**
         * Gets the value of the HTTP header with the given name. If that header is not
         * set, the returned value will be `undefined`.
         * @since v0.4.0
         * @param name Name of header
         */
        getHeader(name: string): number | string | string[] | undefined;
        /**
         * Returns a shallow copy of the current outgoing headers. Since a shallow
         * copy is used, array values may be mutated without additional calls to
         * various header-related HTTP module methods. The keys of the returned
         * object are the header names and the values are the respective header
         * values. All header names are lowercase.
         *
         * The object returned by the `outgoingMessage.getHeaders()` method does
         * not prototypically inherit from the JavaScript `Object`. This means that
         * typical `Object` methods such as `obj.toString()`, `obj.hasOwnProperty()`,
         * and others are not defined and will not work.
         *
         * ```js
         * outgoingMessage.setHeader('Foo', 'bar');
         * outgoingMessage.setHeader('Set-Cookie', ['foo=bar', 'bar=baz']);
         *
         * const headers = outgoingMessage.getHeaders();
         * // headers === { foo: 'bar', 'set-cookie': ['foo=bar', 'bar=baz'] }
         * ```
         * @since v7.7.0
         */
        getHeaders(): OutgoingHttpHeaders;
        /**
         * Returns an array containing the unique names of the current outgoing headers.
         * All names are lowercase.
         * @since v7.7.0
         */
        getHeaderNames(): string[];
        /**
         * Returns `true` if the header identified by `name` is currently set in the
         * outgoing headers. The header name is case-insensitive.
         *
         * ```js
         * const hasContentType = outgoingMessage.hasHeader('content-type');
         * ```
         * @since v7.7.0
         */
        hasHeader(name: string): boolean;
        /**
         * Removes a header that is queued for implicit sending.
         *
         * ```js
         * outgoingMessage.removeHeader('Content-Encoding');
         * ```
         * @since v0.4.0
         * @param name Header name
         */
        removeHeader(name: string): void;
        /**
         * Adds HTTP trailers (headers but at the end of the message) to the message.
         *
         * Trailers will **only** be emitted if the message is chunked encoded. If not,
         * the trailers will be silently discarded.
         *
         * HTTP requires the `Trailer` header to be sent to emit trailers,
         * with a list of header field names in its value, e.g.
         *
         * ```js
         * message.writeHead(200, { 'Content-Type': 'text/plain',
         *                          'Trailer': 'Content-MD5' });
         * message.write(fileData);
         * message.addTrailers({ 'Content-MD5': '7895bf4b8828b55ceaf47747b4bca667' });
         * message.end();
         * ```
         *
         * Attempting to set a header field name or value that contains invalid characters
         * will result in a `TypeError` being thrown.
         * @since v0.3.0
         */
        addTrailers(headers: OutgoingHttpHeaders | ReadonlyArray<[string, string]>): void;
        /**
         * Flushes the message headers.
         *
         * For efficiency reason, Node.js normally buffers the message headers
         * until `outgoingMessage.end()` is called or the first chunk of message data
         * is written. It then tries to pack the headers and data into a single TCP
         * packet.
         *
         * It is usually desired (it saves a TCP round-trip), but not when the first
         * data is not sent until possibly much later. `outgoingMessage.flushHeaders()` bypasses the optimization and kickstarts the message.
         * @since v1.6.0
         */
        flushHeaders(): void;
    }
    /**
     * This object is created internally by an HTTP server, not by the user. It is
     * passed as the second parameter to the `'request'` event.
     * @since v0.1.17
     */
    class ServerResponse<Request extends IncomingMessage = IncomingMessage> extends OutgoingMessage<Request> {
        /**
         * When using implicit headers (not calling `response.writeHead()` explicitly),
         * this property controls the status code that will be sent to the client when
         * the headers get flushed.
         *
         * ```js
         * response.statusCode = 404;
         * ```
         *
         * After response header was sent to the client, this property indicates the
         * status code which was sent out.
         * @since v0.4.0
         */
        statusCode: number;
        /**
         * When using implicit headers (not calling `response.writeHead()` explicitly),
         * this property controls the status message that will be sent to the client when
         * the headers get flushed. If this is left as `undefined` then the standard
         * message for the status code will be used.
         *
         * ```js
         * response.statusMessage = 'Not found';
         * ```
         *
         * After response header was sent to the client, this property indicates the
         * status message which was sent out.
         * @since v0.11.8
         */
        statusMessage: string;
        /**
         * If set to `true`, Node.js will check whether the `Content-Length` header value and the size of the body, in bytes, are equal.
         * Mismatching the `Content-Length` header value will result
         * in an `Error` being thrown, identified by `code:``'ERR_HTTP_CONTENT_LENGTH_MISMATCH'`.
         * @since v18.10.0, v16.18.0
         */
        strictContentLength: boolean;
        constructor(req: Request);
        assignSocket(socket: Socket): void;
        detachSocket(socket: Socket): void;
        /**
         * Sends an HTTP/1.1 100 Continue message to the client, indicating that
         * the request body should be sent. See the `'checkContinue'` event on `Server`.
         * @since v0.3.0
         */
        writeContinue(callback?: () => void): void;
        /**
         * Sends an HTTP/1.1 103 Early Hints message to the client with a Link header,
         * indicating that the user agent can preload/preconnect the linked resources.
         * The `hints` is an object containing the values of headers to be sent with
         * early hints message. The optional `callback` argument will be called when
         * the response message has been written.
         *
         * **Example**
         *
         * ```js
         * const earlyHintsLink = '</styles.css>; rel=preload; as=style';
         * response.writeEarlyHints({
         *   'link': earlyHintsLink,
         * });
         *
         * const earlyHintsLinks = [
         *   '</styles.css>; rel=preload; as=style',
         *   '</scripts.js>; rel=preload; as=script',
         * ];
         * response.writeEarlyHints({
         *   'link': earlyHintsLinks,
         *   'x-trace-id': 'id for diagnostics',
         * });
         *
         * const earlyHintsCallback = () => console.log('early hints message sent');
         * response.writeEarlyHints({
         *   'link': earlyHintsLinks,
         * }, earlyHintsCallback);
         * ```
         * @since v18.11.0
         * @param hints An object containing the values of headers
         * @param callback Will be called when the response message has been written
         */
        writeEarlyHints(hints: Record<string, string | string[]>, callback?: () => void): void;
        /**
         * Sends a response header to the request. The status code is a 3-digit HTTP
         * status code, like `404`. The last argument, `headers`, are the response headers.
         * Optionally one can give a human-readable `statusMessage` as the second
         * argument.
         *
         * `headers` may be an `Array` where the keys and values are in the same list.
         * It is _not_ a list of tuples. So, the even-numbered offsets are key values,
         * and the odd-numbered offsets are the associated values. The array is in the same
         * format as `request.rawHeaders`.
         *
         * Returns a reference to the `ServerResponse`, so that calls can be chained.
         *
         * ```js
         * const body = 'hello world';
         * response
         *   .writeHead(200, {
         *     'Content-Length': Buffer.byteLength(body),
         *     'Content-Type': 'text/plain',
         *   })
         *   .end(body);
         * ```
         *
         * This method must only be called once on a message and it must
         * be called before `response.end()` is called.
         *
         * If `response.write()` or `response.end()` are called before calling
         * this, the implicit/mutable headers will be calculated and call this function.
         *
         * When headers have been set with `response.setHeader()`, they will be merged
         * with any headers passed to `response.writeHead()`, with the headers passed
         * to `response.writeHead()` given precedence.
         *
         * If this method is called and `response.setHeader()` has not been called,
         * it will directly write the supplied header values onto the network channel
         * without caching internally, and the `response.getHeader()` on the header
         * will not yield the expected result. If progressive population of headers is
         * desired with potential future retrieval and modification, use `response.setHeader()` instead.
         *
         * ```js
         * // Returns content-type = text/plain
         * const server = http.createServer((req, res) => {
         *   res.setHeader('Content-Type', 'text/html');
         *   res.setHeader('X-Foo', 'bar');
         *   res.writeHead(200, { 'Content-Type': 'text/plain' });
         *   res.end('ok');
         * });
         * ```
         *
         * `Content-Length` is read in bytes, not characters. Use `Buffer.byteLength()` to determine the length of the body in bytes. Node.js
         * will check whether `Content-Length` and the length of the body which has
         * been transmitted are equal or not.
         *
         * Attempting to set a header field name or value that contains invalid characters
         * will result in a \[`Error`\]\[\] being thrown.
         * @since v0.1.30
         */
        writeHead(
            statusCode: number,
            statusMessage?: string,
            headers?: OutgoingHttpHeaders | OutgoingHttpHeader[],
        ): this;
        writeHead(statusCode: number, headers?: OutgoingHttpHeaders | OutgoingHttpHeader[]): this;
        /**
         * Sends a HTTP/1.1 102 Processing message to the client, indicating that
         * the request body should be sent.
         * @since v10.0.0
         */
        writeProcessing(callback?: () => void): void;
    }
    interface InformationEvent {
        statusCode: number;
        statusMessage: string;
        httpVersion: string;
        httpVersionMajor: number;
        httpVersionMinor: number;
        headers: IncomingHttpHeaders;
        rawHeaders: string[];
    }
    /**
     * This object is created internally and returned from {@link request}. It
     * represents an _in-progress_ request whose header has already been queued. The
     * header is still mutable using the `setHeader(name, value)`, `getHeader(name)`, `removeHeader(name)` API. The actual header will
     * be sent along with the first data chunk or when calling `request.end()`.
     *
     * To get the response, add a listener for `'response'` to the request object. `'response'` will be emitted from the request object when the response
     * headers have been received. The `'response'` event is executed with one
     * argument which is an instance of {@link IncomingMessage}.
     *
     * During the `'response'` event, one can add listeners to the
     * response object; particularly to listen for the `'data'` event.
     *
     * If no `'response'` handler is added, then the response will be
     * entirely discarded. However, if a `'response'` event handler is added,
     * then the data from the response object **must** be consumed, either by
     * calling `response.read()` whenever there is a `'readable'` event, or
     * by adding a `'data'` handler, or by calling the `.resume()` method.
     * Until the data is consumed, the `'end'` event will not fire. Also, until
     * the data is read it will consume memory that can eventually lead to a
     * 'process out of memory' error.
     *
     * For backward compatibility, `res` will only emit `'error'` if there is an `'error'` listener registered.
     *
     * Set `Content-Length` header to limit the response body size.
     * If `response.strictContentLength` is set to `true`, mismatching the `Content-Length` header value will result in an `Error` being thrown,
     * identified by `code:``'ERR_HTTP_CONTENT_LENGTH_MISMATCH'`.
     *
     * `Content-Length` value should be in bytes, not characters. Use `Buffer.byteLength()` to determine the length of the body in bytes.
     * @since v0.1.17
     */
    class ClientRequest extends OutgoingMessage {
        /**
         * The `request.aborted` property will be `true` if the request has
         * been aborted.
         * @since v0.11.14
         * @deprecated Since v17.0.0, v16.12.0 - Check `destroyed` instead.
         */
        aborted: boolean;
        /**
         * The request host.
         * @since v14.5.0, v12.19.0
         */
        host: string;
        /**
         * The request protocol.
         * @since v14.5.0, v12.19.0
         */
        protocol: string;
        /**
         * When sending request through a keep-alive enabled agent, the underlying socket
         * might be reused. But if server closes connection at unfortunate time, client
         * may run into a 'ECONNRESET' error.
         *
         * ```js
         * import http from 'node:http';
         *
         * // Server has a 5 seconds keep-alive timeout by default
         * http
         *   .createServer((req, res) => {
         *     res.write('hello\n');
         *     res.end();
         *   })
         *   .listen(3000);
         *
         * setInterval(() => {
         *   // Adapting a keep-alive agent
         *   http.get('http://localhost:3000', { agent }, (res) => {
         *     res.on('data', (data) => {
         *       // Do nothing
         *     });
         *   });
         * }, 5000); // Sending request on 5s interval so it's easy to hit idle timeout
         * ```
         *
         * By marking a request whether it reused socket or not, we can do
         * automatic error retry base on it.
         *
         * ```js
         * import http from 'node:http';
         * const agent = new http.Agent({ keepAlive: true });
         *
         * function retriableRequest() {
         *   const req = http
         *     .get('http://localhost:3000', { agent }, (res) => {
         *       // ...
         *     })
         *     .on('error', (err) => {
         *       // Check if retry is needed
         *       if (req.reusedSocket &#x26;&#x26; err.code === 'ECONNRESET') {
         *         retriableRequest();
         *       }
         *     });
         * }
         *
         * retriableRequest();
         * ```
         * @since v13.0.0, v12.16.0
         */
        reusedSocket: boolean;
        /**
         * Limits maximum response headers count. If set to 0, no limit will be applied.
         */
        maxHeadersCount: number;
        constructor(url: string | URL | ClientRequestArgs, cb?: (res: IncomingMessage) => void);
        /**
         * The request method.
         * @since v0.1.97
         */
        method: string;
        /**
         * The request path.
         * @since v0.4.0
         */
        path: string;
        /**
         * Marks the request as aborting. Calling this will cause remaining data
         * in the response to be dropped and the socket to be destroyed.
         * @since v0.3.8
         * @deprecated Since v14.1.0,v13.14.0 - Use `destroy` instead.
         */
        abort(): void;
        onSocket(socket: Socket): void;
        /**
         * Once a socket is assigned to this request and is connected `socket.setTimeout()` will be called.
         * @since v0.5.9
         * @param timeout Milliseconds before a request times out.
         * @param callback Optional function to be called when a timeout occurs. Same as binding to the `'timeout'` event.
         */
        setTimeout(timeout: number, callback?: () => void): this;
        /**
         * Once a socket is assigned to this request and is connected `socket.setNoDelay()` will be called.
         * @since v0.5.9
         */
        setNoDelay(noDelay?: boolean): void;
        /**
         * Once a socket is assigned to this request and is connected `socket.setKeepAlive()` will be called.
         * @since v0.5.9
         */
        setSocketKeepAlive(enable?: boolean, initialDelay?: number): void;
        /**
         * Returns an array containing the unique names of the current outgoing raw
         * headers. Header names are returned with their exact casing being set.
         *
         * ```js
         * request.setHeader('Foo', 'bar');
         * request.setHeader('Set-Cookie', ['foo=bar', 'bar=baz']);
         *
         * const headerNames = request.getRawHeaderNames();
         * // headerNames === ['Foo', 'Set-Cookie']
         * ```
         * @since v15.13.0, v14.17.0
         */
        getRawHeaderNames(): string[];
        /**
         * @deprecated
         */
        addListener(event: "abort", listener: () => void): this;
        addListener(
            event: "connect",
            listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void,
        ): this;
        addListener(event: "continue", listener: () => void): this;
        addListener(event: "information", listener: (info: InformationEvent) => void): this;
        addListener(event: "response", listener: (response: IncomingMessage) => void): this;
        addListener(event: "socket", listener: (socket: Socket) => void): this;
        addListener(event: "timeout", listener: () => void): this;
        addListener(
            event: "upgrade",
            listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void,
        ): this;
        addListener(event: "close", listener: () => void): this;
        addListener(event: "drain", listener: () => void): this;
        addListener(event: "error", listener: (err: Error) => void): this;
        addListener(event: "finish", listener: () => void): this;
        addListener(event: "pipe", listener: (src: stream.Readable) => void): this;
        addListener(event: "unpipe", listener: (src: stream.Readable) => void): this;
        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
        /**
         * @deprecated
         */
        on(event: "abort", listener: () => void): this;
        on(event: "connect", listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void): this;
        on(event: "continue", listener: () => void): this;
        on(event: "information", listener: (info: InformationEvent) => void): this;
        on(event: "response", listener: (response: IncomingMessage) => void): this;
        on(event: "socket", listener: (socket: Socket) => void): this;
        on(event: "timeout", listener: () => void): this;
        on(event: "upgrade", listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void): this;
        on(event: "close", listener: () => void): this;
        on(event: "drain", listener: () => void): this;
        on(event: "error", listener: (err: Error) => void): this;
        on(event: "finish", listener: () => void): this;
        on(event: "pipe", listener: (src: stream.Readable) => void): this;
        on(event: "unpipe", listener: (src: stream.Readable) => void): this;
        on(event: string | symbol, listener: (...args: any[]) => void): this;
        /**
         * @deprecated
         */
        once(event: "abort", listener: () => void): this;
        once(event: "connect", listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void): this;
        once(event: "continue", listener: () => void): this;
        once(event: "information", listener: (info: InformationEvent) => void): this;
        once(event: "response", listener: (response: IncomingMessage) => void): this;
        once(event: "socket", listener: (socket: Socket) => void): this;
        once(event: "timeout", listener: () => void): this;
        once(event: "upgrade", listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void): this;
        once(event: "close", listener: () => void): this;
        once(event: "drain", listener: () => void): this;
        once(event: "error", listener: (err: Error) => void): this;
        once(event: "finish", listener: () => void): this;
        once(event: "pipe", listener: (src: stream.Readable) => void): this;
        once(event: "unpipe", listener: (src: stream.Readable) => void): this;
        once(event: string | symbol, listener: (...args: any[]) => void): this;
        /**
         * @deprecated
         */
        prependListener(event: "abort", listener: () => void): this;
        prependListener(
            event: "connect",
            listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void,
        ): this;
        prependListener(event: "continue", listener: () => void): this;
        prependListener(event: "information", listener: (info: InformationEvent) => void): this;
        prependListener(event: "response", listener: (response: IncomingMessage) => void): this;
        prependListener(event: "socket", listener: (socket: Socket) => void): this;
        prependListener(event: "timeout", listener: () => void): this;
        prependListener(
            event: "upgrade",
            listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void,
        ): this;
        prependListener(event: "close", listener: () => void): this;
        prependListener(event: "drain", listener: () => void): this;
        prependListener(event: "error", listener: (err: Error) => void): this;
        prependListener(event: "finish", listener: () => void): this;
        prependListener(event: "pipe", listener: (src: stream.Readable) => void): this;
        prependListener(event: "unpipe", listener: (src: stream.Readable) => void): this;
        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
        /**
         * @deprecated
         */
        prependOnceListener(event: "abort", listener: () => void): this;
        prependOnceListener(
            event: "connect",
            listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void,
        ): this;
        prependOnceListener(event: "continue", listener: () => void): this;
        prependOnceListener(event: "information", listener: (info: InformationEvent) => void): this;
        prependOnceListener(event: "response", listener: (response: IncomingMessage) => void): this;
        prependOnceListener(event: "socket", listener: (socket: Socket) => void): this;
        prependOnceListener(event: "timeout", listener: () => void): this;
        prependOnceListener(
            event: "upgrade",
            listener: (response: IncomingMessage, socket: Socket, head: Buffer) => void,
        ): this;
        prependOnceListener(event: "close", listener: () => void): this;
        prependOnceListener(event: "drain", listener: () => void): this;
        prependOnceListener(event: "error", listener: (err: Error) => void): this;
        prependOnceListener(event: "finish", listener: () => void): this;
        prependOnceListener(event: "pipe", listener: (src: stream.Readable) => void): this;
        prependOnceListener(event: "unpipe", listener: (src: stream.Readable) => void): this;
        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
    }
    /**
     * An `IncomingMessage` object is created by {@link Server} or {@link ClientRequest} and passed as the first argument to the `'request'` and `'response'` event respectively. It may be used to
     * access response
     * status, headers, and data.
     *
     * Different from its `socket` value which is a subclass of `stream.Duplex`, the `IncomingMessage` itself extends `stream.Readable` and is created separately to
     * parse and emit the incoming HTTP headers and payload, as the underlying socket
     * may be reused multiple times in case of keep-alive.
     * @since v0.1.17
     */
    class IncomingMessage extends stream.Readable {
        constructor(socket: Socket);
        /**
         * The `message.aborted` property will be `true` if the request has
         * been aborted.
         * @since v10.1.0
         * @deprecated Since v17.0.0,v16.12.0 - Check `message.destroyed` from <a href="stream.html#class-streamreadable" class="type">stream.Readable</a>.
         */
        aborted: boolean;
        /**
         * In case of server request, the HTTP version sent by the client. In the case of
         * client response, the HTTP version of the connected-to server.
         * Probably either `'1.1'` or `'1.0'`.
         *
         * Also `message.httpVersionMajor` is the first integer and `message.httpVersionMinor` is the second.
         * @since v0.1.1
         */
        httpVersion: string;
        httpVersionMajor: number;
        httpVersionMinor: number;
        /**
         * The `message.complete` property will be `true` if a complete HTTP message has
         * been received and successfully parsed.
         *
         * This property is particularly useful as a means of determining if a client or
         * server fully transmitted a message before a connection was terminated:
         *
         * ```js
         * const req = http.request({
         *   host: '127.0.0.1',
         *   port: 8080,
         *   method: 'POST',
         * }, (res) => {
         *   res.resume();
         *   res.on('end', () => {
         *     if (!res.complete)
         *       console.error(
         *         'The connection was terminated while the message was still being sent');
         *   });
         * });
         * ```
         * @since v0.3.0
         */
        complete: boolean;
        /**
         * Alias for `message.socket`.
         * @since v0.1.90
         * @deprecated Since v16.0.0 - Use `socket`.
         */
        connection: Socket;
        /**
         * The `net.Socket` object associated with the connection.
         *
         * With HTTPS support, use `request.socket.getPeerCertificate()` to obtain the
         * client's authentication details.
         *
         * This property is guaranteed to be an instance of the `net.Socket` class,
         * a subclass of `stream.Duplex`, unless the user specified a socket
         * type other than `net.Socket` or internally nulled.
         * @since v0.3.0
         */
        socket: Socket;
        /**
         * The request/response headers object.
         *
         * Key-value pairs of header names and values. Header names are lower-cased.
         *
         * ```js
         * // Prints something like:
         * //
         * // { 'user-agent': 'curl/7.22.0',
         * //   host: '127.0.0.1:8000',
         * //   accept: '*' }
         * console.log(request.headers);
         * ```
         *
         * Duplicates in raw headers are handled in the following ways, depending on the
         * header name:
         *
         * * Duplicates of `age`, `authorization`, `content-length`, `content-type`, `etag`, `expires`, `from`, `host`, `if-modified-since`, `if-unmodified-since`, `last-modified`, `location`,
         * `max-forwards`, `proxy-authorization`, `referer`, `retry-after`, `server`, or `user-agent` are discarded.
         * To allow duplicate values of the headers listed above to be joined,
         * use the option `joinDuplicateHeaders` in {@link request} and {@link createServer}. See RFC 9110 Section 5.3 for more
         * information.
         * * `set-cookie` is always an array. Duplicates are added to the array.
         * * For duplicate `cookie` headers, the values are joined together with `; `.
         * * For all other headers, the values are joined together with `, `.
         * @since v0.1.5
         */
        headers: IncomingHttpHeaders;
        /**
         * Similar to `message.headers`, but there is no join logic and the values are
         * always arrays of strings, even for headers received just once.
         *
         * ```js
         * // Prints something like:
         * //
         * // { 'user-agent': ['curl/7.22.0'],
         * //   host: ['127.0.0.1:8000'],
         * //   accept: ['*'] }
         * console.log(request.headersDistinct);
         * ```
         * @since v18.3.0, v16.17.0
         */
        headersDistinct: NodeJS.Dict<string[]>;
        /**
         * The raw request/response headers list exactly as they were received.
         *
         * The keys and values are in the same list. It is _not_ a
         * list of tuples. So, the even-numbered offsets are key values, and the
         * odd-numbered offsets are the associated values.
         *
         * Header names are not lowercased, and duplicates are not merged.
         *
         * ```js
         * // Prints something like:
         * //
         * // [ 'user-agent',
         * //   'this is invalid because there can be only one',
         * //   'User-Agent',
         * //   'curl/7.22.0',
         * //   'Host',
         * //   '127.0.0.1:8000',
         * //   'ACCEPT',
         * //   '*' ]
         * console.log(request.rawHeaders);
         * ```
         * @since v0.11.6
         */
        rawHeaders: string[];
        /**
         * The request/response trailers object. Only populated at the `'end'` event.
         * @since v0.3.0
         */
        trailers: NodeJS.Dict<string>;
        /**
         * Similar to `message.trailers`, but there is no join logic and the values are
         * always arrays of strings, even for headers received just once.
         * Only populated at the `'end'` event.
         * @since v18.3.0, v16.17.0
         */
        trailersDistinct: NodeJS.Dict<string[]>;
        /**
         * The raw request/response trailer keys and values exactly as they were
         * received. Only populated at the `'end'` event.
         * @since v0.11.6
         */
        rawTrailers: string[];
        /**
         * Calls `message.socket.setTimeout(msecs, callback)`.
         * @since v0.5.9
         */
        setTimeout(msecs: number, callback?: () => void): this;
        /**
         * **Only valid for request obtained from {@link Server}.**
         *
         * The request method as a string. Read only. Examples: `'GET'`, `'DELETE'`.
         * @since v0.1.1
         */
        method?: string | undefined;
        /**
         * **Only valid for request obtained from {@link Server}.**
         *
         * Request URL string. This contains only the URL that is present in the actual
         * HTTP request. Take the following request:
         *
         * ```http
         * GET /status?name=ryan HTTP/1.1
         * Accept: text/plain
         * ```
         *
         * To parse the URL into its parts:
         *
         * ```js
         * new URL(`http://${process.env.HOST ?? 'localhost'}${request.url}`);
         * ```
         *
         * When `request.url` is `'/status?name=ryan'` and `process.env.HOST` is undefined:
         *
         * ```console
         * $ node
         * > new URL(`http://${process.env.HOST ?? 'localhost'}${request.url}`);
         * URL {
         *   href: 'http://localhost/status?name=ryan',
         *   origin: 'http://localhost',
         *   protocol: 'http:',
         *   username: '',
         *   password: '',
         *   host: 'localhost',
         *   hostname: 'localhost',
         *   port: '',
         *   pathname: '/status',
         *   search: '?name=ryan',
         *   searchParams: URLSearchParams { 'name' => 'ryan' },
         *   hash: ''
         * }
         * ```
         *
         * Ensure that you set `process.env.HOST` to the server's host name, or consider replacing this part entirely. If using `req.headers.host`, ensure proper
         * validation is used, as clients may specify a custom `Host` header.
         * @since v0.1.90
         */
        url?: string | undefined;
        /**
         * **Only valid for response obtained from {@link ClientRequest}.**
         *
         * The 3-digit HTTP response status code. E.G. `404`.
         * @since v0.1.1
         */
        statusCode?: number | undefined;
        /**
         * **Only valid for response obtained from {@link ClientRequest}.**
         *
         * The HTTP response status message (reason phrase). E.G. `OK` or `Internal Server Error`.
         * @since v0.11.10
         */
        statusMessage?: string | undefined;
        /**
         * Calls `destroy()` on the socket that received the `IncomingMessage`. If `error` is provided, an `'error'` event is emitted on the socket and `error` is passed
         * as an argument to any listeners on the event.
         * @since v0.3.0
         */
        destroy(error?: Error): this;
    }
    interface AgentOptions extends NodeJS.PartialOptions<TcpSocketConnectOpts> {
        /**
         * Keep sockets around in a pool to be used by other requests in the future. Default = false
         */
        keepAlive?: boolean | undefined;
        /**
         * When using HTTP KeepAlive, how often to send TCP KeepAlive packets over sockets being kept alive. Default = 1000.
         * Only relevant if keepAlive is set to true.
         */
        keepAliveMsecs?: number | undefined;
        /**
         * Maximum number of sockets to allow per host. Default for Node 0.10 is 5, default for Node 0.12 is Infinity
         */
        maxSockets?: number | undefined;
        /**
         * Maximum number of sockets allowed for all hosts in total. Each request will use a new socket until the maximum is reached. Default: Infinity.
         */
        maxTotalSockets?: number | undefined;
        /**
         * Maximum number of sockets to leave open in a free state. Only relevant if keepAlive is set to true. Default = 256.
         */
        maxFreeSockets?: number | undefined;
        /**
         * Socket timeout in milliseconds. This will set the timeout after the socket is connected.
         */
        timeout?: number | undefined;
        /**
         * Scheduling strategy to apply when picking the next free socket to use.
         * @default `lifo`
         */
        scheduling?: "fifo" | "lifo" | undefined;
    }
    /**
     * An `Agent` is responsible for managing connection persistence
     * and reuse for HTTP clients. It maintains a queue of pending requests
     * for a given host and port, reusing a single socket connection for each
     * until the queue is empty, at which time the socket is either destroyed
     * or put into a pool where it is kept to be used again for requests to the
     * same host and port. Whether it is destroyed or pooled depends on the `keepAlive` `option`.
     *
     * Pooled connections have TCP Keep-Alive enabled for them, but servers may
     * still close idle connections, in which case they will be removed from the
     * pool and a new connection will be made when a new HTTP request is made for
     * that host and port. Servers may also refuse to allow multiple requests
     * over the same connection, in which case the connection will have to be
     * remade for every request and cannot be pooled. The `Agent` will still make
     * the requests to that server, but each one will occur over a new connection.
     *
     * When a connection is closed by the client or the server, it is removed
     * from the pool. Any unused sockets in the pool will be unrefed so as not
     * to keep the Node.js process running when there are no outstanding requests.
     * (see `socket.unref()`).
     *
     * It is good practice, to `destroy()` an `Agent` instance when it is no
     * longer in use, because unused sockets consume OS resources.
     *
     * Sockets are removed from an agent when the socket emits either
     * a `'close'` event or an `'agentRemove'` event. When intending to keep one
     * HTTP request open for a long time without keeping it in the agent, something
     * like the following may be done:
     *
     * ```js
     * http.get(options, (res) => {
     *   // Do stuff
     * }).on('socket', (socket) => {
     *   socket.emit('agentRemove');
     * });
     * ```
     *
     * An agent may also be used for an individual request. By providing `{agent: false}` as an option to the `http.get()` or `http.request()` functions, a one-time use `Agent` with default options
     * will be used
     * for the client connection.
     *
     * `agent:false`:
     *
     * ```js
     * http.get({
     *   hostname: 'localhost',
     *   port: 80,
     *   path: '/',
     *   agent: false,  // Create a new agent just for this one request
     * }, (res) => {
     *   // Do stuff with response
     * });
     * ```
     *
     * `options` in [`socket.connect()`](https://nodejs.org/docs/latest-v22.x/api/net.html#socketconnectoptions-connectlistener) are also supported.
     *
     * To configure any of them, a custom {@link Agent} instance must be created.
     *
     * ```js
     * import http from 'node:http';
     * const keepAliveAgent = new http.Agent({ keepAlive: true });
     * options.agent = keepAliveAgent;
     * http.request(options, onResponseCallback)
     * ```
     * @since v0.3.4
     */
    class Agent extends EventEmitter {
        /**
         * By default set to 256. For agents with `keepAlive` enabled, this
         * sets the maximum number of sockets that will be left open in the free
         * state.
         * @since v0.11.7
         */
        maxFreeSockets: number;
        /**
         * By default set to `Infinity`. Determines how many concurrent sockets the agent
         * can have open per origin. Origin is the returned value of `agent.getName()`.
         * @since v0.3.6
         */
        maxSockets: number;
        /**
         * By default set to `Infinity`. Determines how many concurrent sockets the agent
         * can have open. Unlike `maxSockets`, this parameter applies across all origins.
         * @since v14.5.0, v12.19.0
         */
        maxTotalSockets: number;
        /**
         * An object which contains arrays of sockets currently awaiting use by
         * the agent when `keepAlive` is enabled. Do not modify.
         *
         * Sockets in the `freeSockets` list will be automatically destroyed and
         * removed from the array on `'timeout'`.
         * @since v0.11.4
         */
        readonly freeSockets: NodeJS.ReadOnlyDict<Socket[]>;
        /**
         * An object which contains arrays of sockets currently in use by the
         * agent. Do not modify.
         * @since v0.3.6
         */
        readonly sockets: NodeJS.ReadOnlyDict<Socket[]>;
        /**
         * An object which contains queues of requests that have not yet been assigned to
         * sockets. Do not modify.
         * @since v0.5.9
         */
        readonly requests: NodeJS.ReadOnlyDict<IncomingMessage[]>;
        constructor(opts?: AgentOptions);
        /**
         * Destroy any sockets that are currently in use by the agent.
         *
         * It is usually not necessary to do this. However, if using an
         * agent with `keepAlive` enabled, then it is best to explicitly shut down
         * the agent when it is no longer needed. Otherwise,
         * sockets might stay open for quite a long time before the server
         * terminates them.
         * @since v0.11.4
         */
        destroy(): void;
        /**
         * Produces a socket/stream to be used for HTTP requests.
         *
         * By default, this function is the same as `net.createConnection()`. However,
         * custom agents may override this method in case greater flexibility is desired.
         *
         * A socket/stream can be supplied in one of two ways: by returning the
         * socket/stream from this function, or by passing the socket/stream to `callback`.
         *
         * This method is guaranteed to return an instance of the `net.Socket` class,
         * a subclass of `stream.Duplex`, unless the user specifies a socket
         * type other than `net.Socket`.
         *
         * `callback` has a signature of `(err, stream)`.
         * @since v0.11.4
         * @param options Options containing connection details. Check `createConnection` for the format of the options
         * @param callback Callback function that receives the created socket
         */
        createConnection(
            options: ClientRequestArgs,
            callback?: (err: Error | null, stream: stream.Duplex) => void,
        ): stream.Duplex | null | undefined;
        /**
         * Called when `socket` is detached from a request and could be persisted by the`Agent`. Default behavior is to:
         *
         * ```js
         * socket.setKeepAlive(true, this.keepAliveMsecs);
         * socket.unref();
         * return true;
         * ```
         *
         * This method can be overridden by a particular `Agent` subclass. If this
         * method returns a falsy value, the socket will be destroyed instead of persisting
         * it for use with the next request.
         *
         * The `socket` argument can be an instance of `net.Socket`, a subclass of `stream.Duplex`.
         * @since v8.1.0
         */
        keepSocketAlive(socket: stream.Duplex): void;
        /**
         * Called when `socket` is attached to `request` after being persisted because of
         * the keep-alive options. Default behavior is to:
         *
         * ```js
         * socket.ref();
         * ```
         *
         * This method can be overridden by a particular `Agent` subclass.
         *
         * The `socket` argument can be an instance of `net.Socket`, a subclass of `stream.Duplex`.
         * @since v8.1.0
         */
        reuseSocket(socket: stream.Duplex, request: ClientRequest): void;
        /**
         * Get a unique name for a set of request options, to determine whether a
         * connection can be reused. For an HTTP agent, this returns`host:port:localAddress` or `host:port:localAddress:family`. For an HTTPS agent,
         * the name includes the CA, cert, ciphers, and other HTTPS/TLS-specific options
         * that determine socket reusability.
         * @since v0.11.4
         * @param options A set of options providing information for name generation
         */
        getName(options?: ClientRequestArgs): string;
    }
    const METHODS: string[];
    const STATUS_CODES: {
        [errorCode: number]: string | undefined;
        [errorCode: string]: string | undefined;
    };
    /**
     * Returns a new instance of {@link Server}.
     *
     * The `requestListener` is a function which is automatically
     * added to the `'request'` event.
     *
     * ```js
     * import http from 'node:http';
     *
     * // Create a local server to receive data from
     * const server = http.createServer((req, res) => {
     *   res.writeHead(200, { 'Content-Type': 'application/json' });
     *   res.end(JSON.stringify({
     *     data: 'Hello World!',
     *   }));
     * });
     *
     * server.listen(8000);
     * ```
     *
     * ```js
     * import http from 'node:http';
     *
     * // Create a local server to receive data from
     * const server = http.createServer();
     *
     * // Listen to the request event
     * server.on('request', (request, res) => {
     *   res.writeHead(200, { 'Content-Type': 'application/json' });
     *   res.end(JSON.stringify({
     *     data: 'Hello World!',
     *   }));
     * });
     *
     * server.listen(8000);
     * ```
     * @since v0.1.13
     */
    function createServer<
        Request extends typeof IncomingMessage = typeof IncomingMessage,
        Response extends typeof ServerResponse<InstanceType<Request>> = typeof ServerResponse,
    >(requestListener?: RequestListener<Request, Response>): Server<Request, Response>;
    function createServer<
        Request extends typeof IncomingMessage = typeof IncomingMessage,
        Response extends typeof ServerResponse<InstanceType<Request>> = typeof ServerResponse,
    >(
        options: ServerOptions<Request, Response>,
        requestListener?: RequestListener<Request, Response>,
    ): Server<Request, Response>;
    // although RequestOptions are passed as ClientRequestArgs to ClientRequest directly,
    // create interface RequestOptions would make the naming more clear to developers
    interface RequestOptions extends ClientRequestArgs {}
    /**
     * `options` in `socket.connect()` are also supported.
     *
     * Node.js maintains several connections per server to make HTTP requests.
     * This function allows one to transparently issue requests.
     *
     * `url` can be a string or a `URL` object. If `url` is a
     * string, it is automatically parsed with `new URL()`. If it is a `URL` object, it will be automatically converted to an ordinary `options` object.
     *
     * If both `url` and `options` are specified, the objects are merged, with the `options` properties taking precedence.
     *
     * The optional `callback` parameter will be added as a one-time listener for
     * the `'response'` event.
     *
     * `http.request()` returns an instance of the {@link ClientRequest} class. The `ClientRequest` instance is a writable stream. If one needs to
     * upload a file with a POST request, then write to the `ClientRequest` object.
     *
     * ```js
     * import http from 'node:http';
     * import { Buffer } from 'node:buffer';
     *
     * const postData = JSON.stringify({
     *   'msg': 'Hello World!',
     * });
     *
     * const options = {
     *   hostname: 'www.google.com',
     *   port: 80,
     *   path: '/upload',
     *   method: 'POST',
     *   headers: {
     *     'Content-Type': 'application/json',
     *     'Content-Length': Buffer.byteLength(postData),
     *   },
     * };
     *
     * const req = http.request(options, (res) => {
     *   console.log(`STATUS: ${res.statusCode}`);
     *   console.log(`HEADERS: ${JSON.stringify(res.headers)}`);
     *   res.setEncoding('utf8');
     *   res.on('data', (chunk) => {
     *     console.log(`BODY: ${chunk}`);
     *   });
     *   res.on('end', () => {
     *     console.log('No more data in response.');
     *   });
     * });
     *
     * req.on('error', (e) => {
     *   console.error(`problem with request: ${e.message}`);
     * });
     *
     * // Write data to request body
     * req.write(postData);
     * req.end();
     * ```
     *
     * In the example `req.end()` was called. With `http.request()` one
     * must always call `req.end()` to signify the end of the request -
     * even if there is no data being written to the request body.
     *
     * If any error is encountered during the request (be that with DNS resolution,
     * TCP level errors, or actual HTTP parse errors) an `'error'` event is emitted
     * on the returned request object. As with all `'error'` events, if no listeners
     * are registered the error will be thrown.
     *
     * There are a few special headers that should be noted.
     *
     * * Sending a 'Connection: keep-alive' will notify Node.js that the connection to
     * the server should be persisted until the next request.
     * * Sending a 'Content-Length' header will disable the default chunked encoding.
     * * Sending an 'Expect' header will immediately send the request headers.
     * Usually, when sending 'Expect: 100-continue', both a timeout and a listener
     * for the `'continue'` event should be set. See RFC 2616 Section 8.2.3 for more
     * information.
     * * Sending an Authorization header will override using the `auth` option
     * to compute basic authentication.
     *
     * Example using a `URL` as `options`:
     *
     * ```js
     * const options = new URL('http://abc:xyz@example.com');
     *
     * const req = http.request(options, (res) => {
     *   // ...
     * });
     * ```
     *
     * In a successful request, the following events will be emitted in the following
     * order:
     *
     * * `'socket'`
     * * `'response'`
     *    * `'data'` any number of times, on the `res` object
     *    (`'data'` will not be emitted at all if the response body is empty, for
     *    instance, in most redirects)
     *    * `'end'` on the `res` object
     * * `'close'`
     *
     * In the case of a connection error, the following events will be emitted:
     *
     * * `'socket'`
     * * `'error'`
     * * `'close'`
     *
     * In the case of a premature connection close before the response is received,
     * the following events will be emitted in the following order:
     *
     * * `'socket'`
     * * `'error'` with an error with message `'Error: socket hang up'` and code `'ECONNRESET'`
     * * `'close'`
     *
     * In the case of a premature connection close after the response is received,
     * the following events will be emitted in the following order:
     *
     * * `'socket'`
     * * `'response'`
     *    * `'data'` any number of times, on the `res` object
     * * (connection closed here)
     * * `'aborted'` on the `res` object
     * * `'close'`
     * * `'error'` on the `res` object with an error with message `'Error: aborted'` and code `'ECONNRESET'`
     * * `'close'` on the `res` object
     *
     * If `req.destroy()` is called before a socket is assigned, the following
     * events will be emitted in the following order:
     *
     * * (`req.destroy()` called here)
     * * `'error'` with an error with message `'Error: socket hang up'` and code `'ECONNRESET'`, or the error with which `req.destroy()` was called
     * * `'close'`
     *
     * If `req.destroy()` is called before the connection succeeds, the following
     * events will be emitted in the following order:
     *
     * * `'socket'`
     * * (`req.destroy()` called here)
     * * `'error'` with an error with message `'Error: socket hang up'` and code `'ECONNRESET'`, or the error with which `req.destroy()` was called
     * * `'close'`
     *
     * If `req.destroy()` is called after the response is received, the following
     * events will be emitted in the following order:
     *
     * * `'socket'`
     * * `'response'`
     *    * `'data'` any number of times, on the `res` object
     * * (`req.destroy()` called here)
     * * `'aborted'` on the `res` object
     * * `'close'`
     * * `'error'` on the `res` object with an error with message `'Error: aborted'` and code `'ECONNRESET'`, or the error with which `req.destroy()` was called
     * * `'close'` on the `res` object
     *
     * If `req.abort()` is called before a socket is assigned, the following
     * events will be emitted in the following order:
     *
     * * (`req.abort()` called here)
     * * `'abort'`
     * * `'close'`
     *
     * If `req.abort()` is called before the connection succeeds, the following
     * events will be emitted in the following order:
     *
     * * `'socket'`
     * * (`req.abort()` called here)
     * * `'abort'`
     * * `'error'` with an error with message `'Error: socket hang up'` and code `'ECONNRESET'`
     * * `'close'`
     *
     * If `req.abort()` is called after the response is received, the following
     * events will be emitted in the following order:
     *
     * * `'socket'`
     * * `'response'`
     *    * `'data'` any number of times, on the `res` object
     * * (`req.abort()` called here)
     * * `'abort'`
     * * `'aborted'` on the `res` object
     * * `'error'` on the `res` object with an error with message `'Error: aborted'` and code `'ECONNRESET'`.
     * * `'close'`
     * * `'close'` on the `res` object
     *
     * Setting the `timeout` option or using the `setTimeout()` function will
     * not abort the request or do anything besides add a `'timeout'` event.
     *
     * Passing an `AbortSignal` and then calling `abort()` on the corresponding `AbortController` will behave the same way as calling `.destroy()` on the
     * request. Specifically, the `'error'` event will be emitted with an error with
     * the message `'AbortError: The operation was aborted'`, the code `'ABORT_ERR'` and the `cause`, if one was provided.
     * @since v0.3.6
     */
    function request(options: RequestOptions | string | URL, callback?: (res: IncomingMessage) => void): ClientRequest;
    function request(
        url: string | URL,
        options: RequestOptions,
        callback?: (res: IncomingMessage) => void,
    ): ClientRequest;
    /**
     * Since most requests are GET requests without bodies, Node.js provides this
     * convenience method. The only difference between this method and {@link request} is that it sets the method to GET by default and calls `req.end()` automatically. The callback must take care to
     * consume the response
     * data for reasons stated in {@link ClientRequest} section.
     *
     * The `callback` is invoked with a single argument that is an instance of {@link IncomingMessage}.
     *
     * JSON fetching example:
     *
     * ```js
     * http.get('http://localhost:8000/', (res) => {
     *   const { statusCode } = res;
     *   const contentType = res.headers['content-type'];
     *
     *   let error;
     *   // Any 2xx status code signals a successful response but
     *   // here we're only checking for 200.
     *   if (statusCode !== 200) {
     *     error = new Error('Request Failed.\n' +
     *                       `Status Code: ${statusCode}`);
     *   } else if (!/^application\/json/.test(contentType)) {
     *     error = new Error('Invalid content-type.\n' +
     *                       `Expected application/json but received ${contentType}`);
     *   }
     *   if (error) {
     *     console.error(error.message);
     *     // Consume response data to free up memory
     *     res.resume();
     *     return;
     *   }
     *
     *   res.setEncoding('utf8');
     *   let rawData = '';
     *   res.on('data', (chunk) => { rawData += chunk; });
     *   res.on('end', () => {
     *     try {
     *       const parsedData = JSON.parse(rawData);
     *       console.log(parsedData);
     *     } catch (e) {
     *       console.error(e.message);
     *     }
     *   });
     * }).on('error', (e) => {
     *   console.error(`Got error: ${e.message}`);
     * });
     *
     * // Create a local server to receive data from
     * const server = http.createServer((req, res) => {
     *   res.writeHead(200, { 'Content-Type': 'application/json' });
     *   res.end(JSON.stringify({
     *     data: 'Hello World!',
     *   }));
     * });
     *
     * server.listen(8000);
     * ```
     * @since v0.3.6
     * @param options Accepts the same `options` as {@link request}, with the method set to GET by default.
     */
    function get(options: RequestOptions | string | URL, callback?: (res: IncomingMessage) => void): ClientRequest;
    function get(url: string | URL, options: RequestOptions, callback?: (res: IncomingMessage) => void): ClientRequest;
    /**
     * Performs the low-level validations on the provided `name` that are done when `res.setHeader(name, value)` is called.
     *
     * Passing illegal value as `name` will result in a `TypeError` being thrown,
     * identified by `code: 'ERR_INVALID_HTTP_TOKEN'`.
     *
     * It is not necessary to use this method before passing headers to an HTTP request
     * or response. The HTTP module will automatically validate such headers.
     *
     * Example:
     *
     * ```js
     * import { validateHeaderName } from 'node:http';
     *
     * try {
     *   validateHeaderName('');
     * } catch (err) {
     *   console.error(err instanceof TypeError); // --> true
     *   console.error(err.code); // --> 'ERR_INVALID_HTTP_TOKEN'
     *   console.error(err.message); // --> 'Header name must be a valid HTTP token [""]'
     * }
     * ```
     * @since v14.3.0
     * @param [label='Header name'] Label for error message.
     */
    function validateHeaderName(name: string): void;
    /**
     * Performs the low-level validations on the provided `value` that are done when `res.setHeader(name, value)` is called.
     *
     * Passing illegal value as `value` will result in a `TypeError` being thrown.
     *
     * * Undefined value error is identified by `code: 'ERR_HTTP_INVALID_HEADER_VALUE'`.
     * * Invalid value character error is identified by `code: 'ERR_INVALID_CHAR'`.
     *
     * It is not necessary to use this method before passing headers to an HTTP request
     * or response. The HTTP module will automatically validate such headers.
     *
     * Examples:
     *
     * ```js
     * import { validateHeaderValue } from 'node:http';
     *
     * try {
     *   validateHeaderValue('x-my-header', undefined);
     * } catch (err) {
     *   console.error(err instanceof TypeError); // --> true
     *   console.error(err.code === 'ERR_HTTP_INVALID_HEADER_VALUE'); // --> true
     *   console.error(err.message); // --> 'Invalid value "undefined" for header "x-my-header"'
     * }
     *
     * try {
     *   validateHeaderValue('x-my-header', 'om');
     * } catch (err) {
     *   console.error(err instanceof TypeError); // --> true
     *   console.error(err.code === 'ERR_INVALID_CHAR'); // --> true
     *   console.error(err.message); // --> 'Invalid character in header content ["x-my-header"]'
     * }
     * ```
     * @since v14.3.0
     * @param name Header name
     * @param value Header value
     */
    function validateHeaderValue(name: string, value: string): void;
    /**
     * Set the maximum number of idle HTTP parsers.
     * @since v18.8.0, v16.18.0
     * @param [max=1000]
     */
    function setMaxIdleHTTPParsers(max: number): void;
    /**
     * Global instance of `Agent` which is used as the default for all HTTP client
     * requests. Diverges from a default `Agent` configuration by having `keepAlive`
     * enabled and a `timeout` of 5 seconds.
     * @since v0.5.9
     */
    let globalAgent: Agent;
    /**
     * Read-only property specifying the maximum allowed size of HTTP headers in bytes.
     * Defaults to 16KB. Configurable using the `--max-http-header-size` CLI option.
     */
    const maxHeaderSize: number;
    /**
     * A browser-compatible implementation of `WebSocket`.
     * @since v22.5.0
     */
    const WebSocket: typeof import("undici-types").WebSocket;
    /**
     * @since v22.5.0
     */
    const CloseEvent: typeof import("undici-types").CloseEvent;
    /**
     * @since v22.5.0
     */
    const MessageEvent: typeof import("undici-types").MessageEvent;
}
declare module "node:http" {
    export * from "http";
}

```

## ./lib/lambda/node_modules/@types/node/http2.d.ts

```typescript
/**
 * The `node:http2` module provides an implementation of the [HTTP/2](https://tools.ietf.org/html/rfc7540) protocol.
 * It can be accessed using:
 *
 * ```js
 * import http2 from 'node:http2';
 * ```
 * @since v8.4.0
 * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/http2.js)
 */
declare module "http2" {
    import EventEmitter = require("node:events");
    import * as fs from "node:fs";
    import * as net from "node:net";
    import * as stream from "node:stream";
    import * as tls from "node:tls";
    import * as url from "node:url";
    import {
        IncomingHttpHeaders as Http1IncomingHttpHeaders,
        IncomingMessage,
        OutgoingHttpHeaders,
        ServerResponse,
    } from "node:http";
    export { OutgoingHttpHeaders } from "node:http";
    export interface IncomingHttpStatusHeader {
        ":status"?: number | undefined;
    }
    export interface IncomingHttpHeaders extends Http1IncomingHttpHeaders {
        ":path"?: string | undefined;
        ":method"?: string | undefined;
        ":authority"?: string | undefined;
        ":scheme"?: string | undefined;
    }
    // Http2Stream
    export interface StreamPriorityOptions {
        exclusive?: boolean | undefined;
        parent?: number | undefined;
        weight?: number | undefined;
        silent?: boolean | undefined;
    }
    export interface StreamState {
        localWindowSize?: number | undefined;
        state?: number | undefined;
        localClose?: number | undefined;
        remoteClose?: number | undefined;
        sumDependencyWeight?: number | undefined;
        weight?: number | undefined;
    }
    export interface ServerStreamResponseOptions {
        endStream?: boolean | undefined;
        waitForTrailers?: boolean | undefined;
    }
    export interface StatOptions {
        offset: number;
        length: number;
    }
    export interface ServerStreamFileResponseOptions {
        statCheck?:
            | ((stats: fs.Stats, headers: OutgoingHttpHeaders, statOptions: StatOptions) => void)
            | undefined;
        waitForTrailers?: boolean | undefined;
        offset?: number | undefined;
        length?: number | undefined;
    }
    export interface ServerStreamFileResponseOptionsWithError extends ServerStreamFileResponseOptions {
        onError?: ((err: NodeJS.ErrnoException) => void) | undefined;
    }
    export interface Http2Stream extends stream.Duplex {
        /**
         * Set to `true` if the `Http2Stream` instance was aborted abnormally. When set,
         * the `'aborted'` event will have been emitted.
         * @since v8.4.0
         */
        readonly aborted: boolean;
        /**
         * This property shows the number of characters currently buffered to be written.
         * See `net.Socket.bufferSize` for details.
         * @since v11.2.0, v10.16.0
         */
        readonly bufferSize: number;
        /**
         * Set to `true` if the `Http2Stream` instance has been closed.
         * @since v9.4.0
         */
        readonly closed: boolean;
        /**
         * Set to `true` if the `Http2Stream` instance has been destroyed and is no longer
         * usable.
         * @since v8.4.0
         */
        readonly destroyed: boolean;
        /**
         * Set to `true` if the `END_STREAM` flag was set in the request or response
         * HEADERS frame received, indicating that no additional data should be received
         * and the readable side of the `Http2Stream` will be closed.
         * @since v10.11.0
         */
        readonly endAfterHeaders: boolean;
        /**
         * The numeric stream identifier of this `Http2Stream` instance. Set to `undefined` if the stream identifier has not yet been assigned.
         * @since v8.4.0
         */
        readonly id?: number | undefined;
        /**
         * Set to `true` if the `Http2Stream` instance has not yet been assigned a
         * numeric stream identifier.
         * @since v9.4.0
         */
        readonly pending: boolean;
        /**
         * Set to the `RST_STREAM` `error code` reported when the `Http2Stream` is
         * destroyed after either receiving an `RST_STREAM` frame from the connected peer,
         * calling `http2stream.close()`, or `http2stream.destroy()`. Will be `undefined` if the `Http2Stream` has not been closed.
         * @since v8.4.0
         */
        readonly rstCode: number;
        /**
         * An object containing the outbound headers sent for this `Http2Stream`.
         * @since v9.5.0
         */
        readonly sentHeaders: OutgoingHttpHeaders;
        /**
         * An array of objects containing the outbound informational (additional) headers
         * sent for this `Http2Stream`.
         * @since v9.5.0
         */
        readonly sentInfoHeaders?: OutgoingHttpHeaders[] | undefined;
        /**
         * An object containing the outbound trailers sent for this `HttpStream`.
         * @since v9.5.0
         */
        readonly sentTrailers?: OutgoingHttpHeaders | undefined;
        /**
         * A reference to the `Http2Session` instance that owns this `Http2Stream`. The
         * value will be `undefined` after the `Http2Stream` instance is destroyed.
         * @since v8.4.0
         */
        readonly session: Http2Session | undefined;
        /**
         * Provides miscellaneous information about the current state of the `Http2Stream`.
         *
         * A current state of this `Http2Stream`.
         * @since v8.4.0
         */
        readonly state: StreamState;
        /**
         * Closes the `Http2Stream` instance by sending an `RST_STREAM` frame to the
         * connected HTTP/2 peer.
         * @since v8.4.0
         * @param [code=http2.constants.NGHTTP2_NO_ERROR] Unsigned 32-bit integer identifying the error code.
         * @param callback An optional function registered to listen for the `'close'` event.
         */
        close(code?: number, callback?: () => void): void;
        /**
         * Updates the priority for this `Http2Stream` instance.
         * @since v8.4.0
         */
        priority(options: StreamPriorityOptions): void;
        /**
         * ```js
         * import http2 from 'node:http2';
         * const client = http2.connect('http://example.org:8000');
         * const { NGHTTP2_CANCEL } = http2.constants;
         * const req = client.request({ ':path': '/' });
         *
         * // Cancel the stream if there's no activity after 5 seconds
         * req.setTimeout(5000, () => req.close(NGHTTP2_CANCEL));
         * ```
         * @since v8.4.0
         */
        setTimeout(msecs: number, callback?: () => void): void;
        /**
         * Sends a trailing `HEADERS` frame to the connected HTTP/2 peer. This method
         * will cause the `Http2Stream` to be immediately closed and must only be
         * called after the `'wantTrailers'` event has been emitted. When sending a
         * request or sending a response, the `options.waitForTrailers` option must be set
         * in order to keep the `Http2Stream` open after the final `DATA` frame so that
         * trailers can be sent.
         *
         * ```js
         * import http2 from 'node:http2';
         * const server = http2.createServer();
         * server.on('stream', (stream) => {
         *   stream.respond(undefined, { waitForTrailers: true });
         *   stream.on('wantTrailers', () => {
         *     stream.sendTrailers({ xyz: 'abc' });
         *   });
         *   stream.end('Hello World');
         * });
         * ```
         *
         * The HTTP/1 specification forbids trailers from containing HTTP/2 pseudo-header
         * fields (e.g. `':method'`, `':path'`, etc).
         * @since v10.0.0
         */
        sendTrailers(headers: OutgoingHttpHeaders): void;
        addListener(event: "aborted", listener: () => void): this;
        addListener(event: "close", listener: () => void): this;
        addListener(event: "data", listener: (chunk: Buffer | string) => void): this;
        addListener(event: "drain", listener: () => void): this;
        addListener(event: "end", listener: () => void): this;
        addListener(event: "error", listener: (err: Error) => void): this;
        addListener(event: "finish", listener: () => void): this;
        addListener(event: "frameError", listener: (frameType: number, errorCode: number) => void): this;
        addListener(event: "pipe", listener: (src: stream.Readable) => void): this;
        addListener(event: "unpipe", listener: (src: stream.Readable) => void): this;
        addListener(event: "streamClosed", listener: (code: number) => void): this;
        addListener(event: "timeout", listener: () => void): this;
        addListener(event: "trailers", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;
        addListener(event: "wantTrailers", listener: () => void): this;
        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
        emit(event: "aborted"): boolean;
        emit(event: "close"): boolean;
        emit(event: "data", chunk: Buffer | string): boolean;
        emit(event: "drain"): boolean;
        emit(event: "end"): boolean;
        emit(event: "error", err: Error): boolean;
        emit(event: "finish"): boolean;
        emit(event: "frameError", frameType: number, errorCode: number): boolean;
        emit(event: "pipe", src: stream.Readable): boolean;
        emit(event: "unpipe", src: stream.Readable): boolean;
        emit(event: "streamClosed", code: number): boolean;
        emit(event: "timeout"): boolean;
        emit(event: "trailers", trailers: IncomingHttpHeaders, flags: number): boolean;
        emit(event: "wantTrailers"): boolean;
        emit(event: string | symbol, ...args: any[]): boolean;
        on(event: "aborted", listener: () => void): this;
        on(event: "close", listener: () => void): this;
        on(event: "data", listener: (chunk: Buffer | string) => void): this;
        on(event: "drain", listener: () => void): this;
        on(event: "end", listener: () => void): this;
        on(event: "error", listener: (err: Error) => void): this;
        on(event: "finish", listener: () => void): this;
        on(event: "frameError", listener: (frameType: number, errorCode: number) => void): this;
        on(event: "pipe", listener: (src: stream.Readable) => void): this;
        on(event: "unpipe", listener: (src: stream.Readable) => void): this;
        on(event: "streamClosed", listener: (code: number) => void): this;
        on(event: "timeout", listener: () => void): this;
        on(event: "trailers", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;
        on(event: "wantTrailers", listener: () => void): this;
        on(event: string | symbol, listener: (...args: any[]) => void): this;
        once(event: "aborted", listener: () => void): this;
        once(event: "close", listener: () => void): this;
        once(event: "data", listener: (chunk: Buffer | string) => void): this;
        once(event: "drain", listener: () => void): this;
        once(event: "end", listener: () => void): this;
        once(event: "error", listener: (err: Error) => void): this;
        once(event: "finish", listener: () => void): this;
        once(event: "frameError", listener: (frameType: number, errorCode: number) => void): this;
        once(event: "pipe", listener: (src: stream.Readable) => void): this;
        once(event: "unpipe", listener: (src: stream.Readable) => void): this;
        once(event: "streamClosed", listener: (code: number) => void): this;
        once(event: "timeout", listener: () => void): this;
        once(event: "trailers", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;
        once(event: "wantTrailers", listener: () => void): this;
        once(event: string | symbol, listener: (...args: any[]) => void): this;
        prependListener(event: "aborted", listener: () => void): this;
        prependListener(event: "close", listener: () => void): this;
        prependListener(event: "data", listener: (chunk: Buffer | string) => void): this;
        prependListener(event: "drain", listener: () => void): this;
        prependListener(event: "end", listener: () => void): this;
        prependListener(event: "error", listener: (err: Error) => void): this;
        prependListener(event: "finish", listener: () => void): this;
        prependListener(event: "frameError", listener: (frameType: number, errorCode: number) => void): this;
        prependListener(event: "pipe", listener: (src: stream.Readable) => void): this;
        prependListener(event: "unpipe", listener: (src: stream.Readable) => void): this;
        prependListener(event: "streamClosed", listener: (code: number) => void): this;
        prependListener(event: "timeout", listener: () => void): this;
        prependListener(event: "trailers", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;
        prependListener(event: "wantTrailers", listener: () => void): this;
        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
        prependOnceListener(event: "aborted", listener: () => void): this;
        prependOnceListener(event: "close", listener: () => void): this;
        prependOnceListener(event: "data", listener: (chunk: Buffer | string) => void): this;
        prependOnceListener(event: "drain", listener: () => void): this;
        prependOnceListener(event: "end", listener: () => void): this;
        prependOnceListener(event: "error", listener: (err: Error) => void): this;
        prependOnceListener(event: "finish", listener: () => void): this;
        prependOnceListener(event: "frameError", listener: (frameType: number, errorCode: number) => void): this;
        prependOnceListener(event: "pipe", listener: (src: stream.Readable) => void): this;
        prependOnceListener(event: "unpipe", listener: (src: stream.Readable) => void): this;
        prependOnceListener(event: "streamClosed", listener: (code: number) => void): this;
        prependOnceListener(event: "timeout", listener: () => void): this;
        prependOnceListener(event: "trailers", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;
        prependOnceListener(event: "wantTrailers", listener: () => void): this;
        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
    }
    export interface ClientHttp2Stream extends Http2Stream {
        addListener(event: "continue", listener: () => {}): this;
        addListener(
            event: "headers",
            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,
        ): this;
        addListener(event: "push", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;
        addListener(
            event: "response",
            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,
        ): this;
        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
        emit(event: "continue"): boolean;
        emit(event: "headers", headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number): boolean;
        emit(event: "push", headers: IncomingHttpHeaders, flags: number): boolean;
        emit(event: "response", headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number): boolean;
        emit(event: string | symbol, ...args: any[]): boolean;
        on(event: "continue", listener: () => {}): this;
        on(
            event: "headers",
            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,
        ): this;
        on(event: "push", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;
        on(
            event: "response",
            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,
        ): this;
        on(event: string | symbol, listener: (...args: any[]) => void): this;
        once(event: "continue", listener: () => {}): this;
        once(
            event: "headers",
            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,
        ): this;
        once(event: "push", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;
        once(
            event: "response",
            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,
        ): this;
        once(event: string | symbol, listener: (...args: any[]) => void): this;
        prependListener(event: "continue", listener: () => {}): this;
        prependListener(
            event: "headers",
            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,
        ): this;
        prependListener(event: "push", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;
        prependListener(
            event: "response",
            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,
        ): this;
        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
        prependOnceListener(event: "continue", listener: () => {}): this;
        prependOnceListener(
            event: "headers",
            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,
        ): this;
        prependOnceListener(event: "push", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;
        prependOnceListener(
            event: "response",
            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,
        ): this;
        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
    }
    export interface ServerHttp2Stream extends Http2Stream {
        /**
         * True if headers were sent, false otherwise (read-only).
         * @since v8.4.0
         */
        readonly headersSent: boolean;
        /**
         * Read-only property mapped to the `SETTINGS_ENABLE_PUSH` flag of the remote
         * client's most recent `SETTINGS` frame. Will be `true` if the remote peer
         * accepts push streams, `false` otherwise. Settings are the same for every `Http2Stream` in the same `Http2Session`.
         * @since v8.4.0
         */
        readonly pushAllowed: boolean;
        /**
         * Sends an additional informational `HEADERS` frame to the connected HTTP/2 peer.
         * @since v8.4.0
         */
        additionalHeaders(headers: OutgoingHttpHeaders): void;
        /**
         * Initiates a push stream. The callback is invoked with the new `Http2Stream` instance created for the push stream passed as the second argument, or an `Error` passed as the first argument.
         *
         * ```js
         * import http2 from 'node:http2';
         * const server = http2.createServer();
         * server.on('stream', (stream) => {
         *   stream.respond({ ':status': 200 });
         *   stream.pushStream({ ':path': '/' }, (err, pushStream, headers) => {
         *     if (err) throw err;
         *     pushStream.respond({ ':status': 200 });
         *     pushStream.end('some pushed data');
         *   });
         *   stream.end('some data');
         * });
         * ```
         *
         * Setting the weight of a push stream is not allowed in the `HEADERS` frame. Pass
         * a `weight` value to `http2stream.priority` with the `silent` option set to `true` to enable server-side bandwidth balancing between concurrent streams.
         *
         * Calling `http2stream.pushStream()` from within a pushed stream is not permitted
         * and will throw an error.
         * @since v8.4.0
         * @param callback Callback that is called once the push stream has been initiated.
         */
        pushStream(
            headers: OutgoingHttpHeaders,
            callback?: (err: Error | null, pushStream: ServerHttp2Stream, headers: OutgoingHttpHeaders) => void,
        ): void;
        pushStream(
            headers: OutgoingHttpHeaders,
            options?: StreamPriorityOptions,
            callback?: (err: Error | null, pushStream: ServerHttp2Stream, headers: OutgoingHttpHeaders) => void,
        ): void;
        /**
         * ```js
         * import http2 from 'node:http2';
         * const server = http2.createServer();
         * server.on('stream', (stream) => {
         *   stream.respond({ ':status': 200 });
         *   stream.end('some data');
         * });
         * ```
         *
         * Initiates a response. When the `options.waitForTrailers` option is set, the `'wantTrailers'` event
         * will be emitted immediately after queuing the last chunk of payload data to be sent.
         * The `http2stream.sendTrailers()` method can then be used to send trailing header fields to the peer.
         *
         * When `options.waitForTrailers` is set, the `Http2Stream` will not automatically
         * close when the final `DATA` frame is transmitted. User code must call either `http2stream.sendTrailers()` or `http2stream.close()` to close the `Http2Stream`.
         *
         * ```js
         * import http2 from 'node:http2';
         * const server = http2.createServer();
         * server.on('stream', (stream) => {
         *   stream.respond({ ':status': 200 }, { waitForTrailers: true });
         *   stream.on('wantTrailers', () => {
         *     stream.sendTrailers({ ABC: 'some value to send' });
         *   });
         *   stream.end('some data');
         * });
         * ```
         * @since v8.4.0
         */
        respond(headers?: OutgoingHttpHeaders, options?: ServerStreamResponseOptions): void;
        /**
         * Initiates a response whose data is read from the given file descriptor. No
         * validation is performed on the given file descriptor. If an error occurs while
         * attempting to read data using the file descriptor, the `Http2Stream` will be
         * closed using an `RST_STREAM` frame using the standard `INTERNAL_ERROR` code.
         *
         * When used, the `Http2Stream` object's `Duplex` interface will be closed
         * automatically.
         *
         * ```js
         * import http2 from 'node:http2';
         * import fs from 'node:fs';
         *
         * const server = http2.createServer();
         * server.on('stream', (stream) => {
         *   const fd = fs.openSync('/some/file', 'r');
         *
         *   const stat = fs.fstatSync(fd);
         *   const headers = {
         *     'content-length': stat.size,
         *     'last-modified': stat.mtime.toUTCString(),
         *     'content-type': 'text/plain; charset=utf-8',
         *   };
         *   stream.respondWithFD(fd, headers);
         *   stream.on('close', () => fs.closeSync(fd));
         * });
         * ```
         *
         * The optional `options.statCheck` function may be specified to give user code
         * an opportunity to set additional content headers based on the `fs.Stat` details
         * of the given fd. If the `statCheck` function is provided, the `http2stream.respondWithFD()` method will
         * perform an `fs.fstat()` call to collect details on the provided file descriptor.
         *
         * The `offset` and `length` options may be used to limit the response to a
         * specific range subset. This can be used, for instance, to support HTTP Range
         * requests.
         *
         * The file descriptor or `FileHandle` is not closed when the stream is closed,
         * so it will need to be closed manually once it is no longer needed.
         * Using the same file descriptor concurrently for multiple streams
         * is not supported and may result in data loss. Re-using a file descriptor
         * after a stream has finished is supported.
         *
         * When the `options.waitForTrailers` option is set, the `'wantTrailers'` event
         * will be emitted immediately after queuing the last chunk of payload data to be
         * sent. The `http2stream.sendTrailers()` method can then be used to sent trailing
         * header fields to the peer.
         *
         * When `options.waitForTrailers` is set, the `Http2Stream` will not automatically
         * close when the final `DATA` frame is transmitted. User code _must_ call either `http2stream.sendTrailers()`
         * or `http2stream.close()` to close the `Http2Stream`.
         *
         * ```js
         * import http2 from 'node:http2';
         * import fs from 'node:fs';
         *
         * const server = http2.createServer();
         * server.on('stream', (stream) => {
         *   const fd = fs.openSync('/some/file', 'r');
         *
         *   const stat = fs.fstatSync(fd);
         *   const headers = {
         *     'content-length': stat.size,
         *     'last-modified': stat.mtime.toUTCString(),
         *     'content-type': 'text/plain; charset=utf-8',
         *   };
         *   stream.respondWithFD(fd, headers, { waitForTrailers: true });
         *   stream.on('wantTrailers', () => {
         *     stream.sendTrailers({ ABC: 'some value to send' });
         *   });
         *
         *   stream.on('close', () => fs.closeSync(fd));
         * });
         * ```
         * @since v8.4.0
         * @param fd A readable file descriptor.
         */
        respondWithFD(
            fd: number | fs.promises.FileHandle,
            headers?: OutgoingHttpHeaders,
            options?: ServerStreamFileResponseOptions,
        ): void;
        /**
         * Sends a regular file as the response. The `path` must specify a regular file
         * or an `'error'` event will be emitted on the `Http2Stream` object.
         *
         * When used, the `Http2Stream` object's `Duplex` interface will be closed
         * automatically.
         *
         * The optional `options.statCheck` function may be specified to give user code
         * an opportunity to set additional content headers based on the `fs.Stat` details
         * of the given file:
         *
         * If an error occurs while attempting to read the file data, the `Http2Stream` will be closed using an
         * `RST_STREAM` frame using the standard `INTERNAL_ERROR` code.
         * If the `onError` callback is defined, then it will be called. Otherwise, the stream will be destroyed.
         *
         * Example using a file path:
         *
         * ```js
         * import http2 from 'node:http2';
         * const server = http2.createServer();
         * server.on('stream', (stream) => {
         *   function statCheck(stat, headers) {
         *     headers['last-modified'] = stat.mtime.toUTCString();
         *   }
         *
         *   function onError(err) {
         *     // stream.respond() can throw if the stream has been destroyed by
         *     // the other side.
         *     try {
         *       if (err.code === 'ENOENT') {
         *         stream.respond({ ':status': 404 });
         *       } else {
         *         stream.respond({ ':status': 500 });
         *       }
         *     } catch (err) {
         *       // Perform actual error handling.
         *       console.error(err);
         *     }
         *     stream.end();
         *   }
         *
         *   stream.respondWithFile('/some/file',
         *                          { 'content-type': 'text/plain; charset=utf-8' },
         *                          { statCheck, onError });
         * });
         * ```
         *
         * The `options.statCheck` function may also be used to cancel the send operation
         * by returning `false`. For instance, a conditional request may check the stat
         * results to determine if the file has been modified to return an appropriate `304` response:
         *
         * ```js
         * import http2 from 'node:http2';
         * const server = http2.createServer();
         * server.on('stream', (stream) => {
         *   function statCheck(stat, headers) {
         *     // Check the stat here...
         *     stream.respond({ ':status': 304 });
         *     return false; // Cancel the send operation
         *   }
         *   stream.respondWithFile('/some/file',
         *                          { 'content-type': 'text/plain; charset=utf-8' },
         *                          { statCheck });
         * });
         * ```
         *
         * The `content-length` header field will be automatically set.
         *
         * The `offset` and `length` options may be used to limit the response to a
         * specific range subset. This can be used, for instance, to support HTTP Range
         * requests.
         *
         * The `options.onError` function may also be used to handle all the errors
         * that could happen before the delivery of the file is initiated. The
         * default behavior is to destroy the stream.
         *
         * When the `options.waitForTrailers` option is set, the `'wantTrailers'` event
         * will be emitted immediately after queuing the last chunk of payload data to be
         * sent. The `http2stream.sendTrailers()` method can then be used to sent trailing
         * header fields to the peer.
         *
         * When `options.waitForTrailers` is set, the `Http2Stream` will not automatically
         * close when the final `DATA` frame is transmitted. User code must call either`http2stream.sendTrailers()` or `http2stream.close()` to close the`Http2Stream`.
         *
         * ```js
         * import http2 from 'node:http2';
         * const server = http2.createServer();
         * server.on('stream', (stream) => {
         *   stream.respondWithFile('/some/file',
         *                          { 'content-type': 'text/plain; charset=utf-8' },
         *                          { waitForTrailers: true });
         *   stream.on('wantTrailers', () => {
         *     stream.sendTrailers({ ABC: 'some value to send' });
         *   });
         * });
         * ```
         * @since v8.4.0
         */
        respondWithFile(
            path: string,
            headers?: OutgoingHttpHeaders,
            options?: ServerStreamFileResponseOptionsWithError,
        ): void;
    }
    // Http2Session
    export interface Settings {
        headerTableSize?: number | undefined;
        enablePush?: boolean | undefined;
        initialWindowSize?: number | undefined;
        maxFrameSize?: number | undefined;
        maxConcurrentStreams?: number | undefined;
        maxHeaderListSize?: number | undefined;
        enableConnectProtocol?: boolean | undefined;
    }
    export interface ClientSessionRequestOptions {
        endStream?: boolean | undefined;
        exclusive?: boolean | undefined;
        parent?: number | undefined;
        weight?: number | undefined;
        waitForTrailers?: boolean | undefined;
        signal?: AbortSignal | undefined;
    }
    export interface SessionState {
        effectiveLocalWindowSize?: number | undefined;
        effectiveRecvDataLength?: number | undefined;
        nextStreamID?: number | undefined;
        localWindowSize?: number | undefined;
        lastProcStreamID?: number | undefined;
        remoteWindowSize?: number | undefined;
        outboundQueueSize?: number | undefined;
        deflateDynamicTableSize?: number | undefined;
        inflateDynamicTableSize?: number | undefined;
    }
    export interface Http2Session extends EventEmitter {
        /**
         * Value will be `undefined` if the `Http2Session` is not yet connected to a
         * socket, `h2c` if the `Http2Session` is not connected to a `TLSSocket`, or
         * will return the value of the connected `TLSSocket`'s own `alpnProtocol` property.
         * @since v9.4.0
         */
        readonly alpnProtocol?: string | undefined;
        /**
         * Will be `true` if this `Http2Session` instance has been closed, otherwise `false`.
         * @since v9.4.0
         */
        readonly closed: boolean;
        /**
         * Will be `true` if this `Http2Session` instance is still connecting, will be set
         * to `false` before emitting `connect` event and/or calling the `http2.connect` callback.
         * @since v10.0.0
         */
        readonly connecting: boolean;
        /**
         * Will be `true` if this `Http2Session` instance has been destroyed and must no
         * longer be used, otherwise `false`.
         * @since v8.4.0
         */
        readonly destroyed: boolean;
        /**
         * Value is `undefined` if the `Http2Session` session socket has not yet been
         * connected, `true` if the `Http2Session` is connected with a `TLSSocket`,
         * and `false` if the `Http2Session` is connected to any other kind of socket
         * or stream.
         * @since v9.4.0
         */
        readonly encrypted?: boolean | undefined;
        /**
         * A prototype-less object describing the current local settings of this `Http2Session`.
         * The local settings are local to _this_`Http2Session` instance.
         * @since v8.4.0
         */
        readonly localSettings: Settings;
        /**
         * If the `Http2Session` is connected to a `TLSSocket`, the `originSet` property
         * will return an `Array` of origins for which the `Http2Session` may be
         * considered authoritative.
         *
         * The `originSet` property is only available when using a secure TLS connection.
         * @since v9.4.0
         */
        readonly originSet?: string[] | undefined;
        /**
         * Indicates whether the `Http2Session` is currently waiting for acknowledgment of
         * a sent `SETTINGS` frame. Will be `true` after calling the `http2session.settings()` method.
         * Will be `false` once all sent `SETTINGS` frames have been acknowledged.
         * @since v8.4.0
         */
        readonly pendingSettingsAck: boolean;
        /**
         * A prototype-less object describing the current remote settings of this`Http2Session`.
         * The remote settings are set by the _connected_ HTTP/2 peer.
         * @since v8.4.0
         */
        readonly remoteSettings: Settings;
        /**
         * Returns a `Proxy` object that acts as a `net.Socket` (or `tls.TLSSocket`) but
         * limits available methods to ones safe to use with HTTP/2.
         *
         * `destroy`, `emit`, `end`, `pause`, `read`, `resume`, and `write` will throw
         * an error with code `ERR_HTTP2_NO_SOCKET_MANIPULATION`. See `Http2Session and Sockets` for more information.
         *
         * `setTimeout` method will be called on this `Http2Session`.
         *
         * All other interactions will be routed directly to the socket.
         * @since v8.4.0
         */
        readonly socket: net.Socket | tls.TLSSocket;
        /**
         * Provides miscellaneous information about the current state of the`Http2Session`.
         *
         * An object describing the current status of this `Http2Session`.
         * @since v8.4.0
         */
        readonly state: SessionState;
        /**
         * The `http2session.type` will be equal to `http2.constants.NGHTTP2_SESSION_SERVER` if this `Http2Session` instance is a
         * server, and `http2.constants.NGHTTP2_SESSION_CLIENT` if the instance is a
         * client.
         * @since v8.4.0
         */
        readonly type: number;
        /**
         * Gracefully closes the `Http2Session`, allowing any existing streams to
         * complete on their own and preventing new `Http2Stream` instances from being
         * created. Once closed, `http2session.destroy()`_might_ be called if there
         * are no open `Http2Stream` instances.
         *
         * If specified, the `callback` function is registered as a handler for the`'close'` event.
         * @since v9.4.0
         */
        close(callback?: () => void): void;
        /**
         * Immediately terminates the `Http2Session` and the associated `net.Socket` or `tls.TLSSocket`.
         *
         * Once destroyed, the `Http2Session` will emit the `'close'` event. If `error` is not undefined, an `'error'` event will be emitted immediately before the `'close'` event.
         *
         * If there are any remaining open `Http2Streams` associated with the `Http2Session`, those will also be destroyed.
         * @since v8.4.0
         * @param error An `Error` object if the `Http2Session` is being destroyed due to an error.
         * @param code The HTTP/2 error code to send in the final `GOAWAY` frame. If unspecified, and `error` is not undefined, the default is `INTERNAL_ERROR`, otherwise defaults to `NO_ERROR`.
         */
        destroy(error?: Error, code?: number): void;
        /**
         * Transmits a `GOAWAY` frame to the connected peer _without_ shutting down the`Http2Session`.
         * @since v9.4.0
         * @param code An HTTP/2 error code
         * @param lastStreamID The numeric ID of the last processed `Http2Stream`
         * @param opaqueData A `TypedArray` or `DataView` instance containing additional data to be carried within the `GOAWAY` frame.
         */
        goaway(code?: number, lastStreamID?: number, opaqueData?: NodeJS.ArrayBufferView): void;
        /**
         * Sends a `PING` frame to the connected HTTP/2 peer. A `callback` function must
         * be provided. The method will return `true` if the `PING` was sent, `false` otherwise.
         *
         * The maximum number of outstanding (unacknowledged) pings is determined by the `maxOutstandingPings` configuration option. The default maximum is 10.
         *
         * If provided, the `payload` must be a `Buffer`, `TypedArray`, or `DataView` containing 8 bytes of data that will be transmitted with the `PING` and
         * returned with the ping acknowledgment.
         *
         * The callback will be invoked with three arguments: an error argument that will
         * be `null` if the `PING` was successfully acknowledged, a `duration` argument
         * that reports the number of milliseconds elapsed since the ping was sent and the
         * acknowledgment was received, and a `Buffer` containing the 8-byte `PING` payload.
         *
         * ```js
         * session.ping(Buffer.from('abcdefgh'), (err, duration, payload) => {
         *   if (!err) {
         *     console.log(`Ping acknowledged in ${duration} milliseconds`);
         *     console.log(`With payload '${payload.toString()}'`);
         *   }
         * });
         * ```
         *
         * If the `payload` argument is not specified, the default payload will be the
         * 64-bit timestamp (little endian) marking the start of the `PING` duration.
         * @since v8.9.3
         * @param payload Optional ping payload.
         */
        ping(callback: (err: Error | null, duration: number, payload: Buffer) => void): boolean;
        ping(
            payload: NodeJS.ArrayBufferView,
            callback: (err: Error | null, duration: number, payload: Buffer) => void,
        ): boolean;
        /**
         * Calls `ref()` on this `Http2Session` instance's underlying `net.Socket`.
         * @since v9.4.0
         */
        ref(): void;
        /**
         * Sets the local endpoint's window size.
         * The `windowSize` is the total window size to set, not
         * the delta.
         *
         * ```js
         * import http2 from 'node:http2';
         *
         * const server = http2.createServer();
         * const expectedWindowSize = 2 ** 20;
         * server.on('connect', (session) => {
         *
         *   // Set local window size to be 2 ** 20
         *   session.setLocalWindowSize(expectedWindowSize);
         * });
         * ```
         * @since v15.3.0, v14.18.0
         */
        setLocalWindowSize(windowSize: number): void;
        /**
         * Used to set a callback function that is called when there is no activity on
         * the `Http2Session` after `msecs` milliseconds. The given `callback` is
         * registered as a listener on the `'timeout'` event.
         * @since v8.4.0
         */
        setTimeout(msecs: number, callback?: () => void): void;
        /**
         * Updates the current local settings for this `Http2Session` and sends a new `SETTINGS` frame to the connected HTTP/2 peer.
         *
         * Once called, the `http2session.pendingSettingsAck` property will be `true` while the session is waiting for the remote peer to acknowledge the new
         * settings.
         *
         * The new settings will not become effective until the `SETTINGS` acknowledgment
         * is received and the `'localSettings'` event is emitted. It is possible to send
         * multiple `SETTINGS` frames while acknowledgment is still pending.
         * @since v8.4.0
         * @param callback Callback that is called once the session is connected or right away if the session is already connected.
         */
        settings(
            settings: Settings,
            callback?: (err: Error | null, settings: Settings, duration: number) => void,
        ): void;
        /**
         * Calls `unref()` on this `Http2Session`instance's underlying `net.Socket`.
         * @since v9.4.0
         */
        unref(): void;
        addListener(event: "close", listener: () => void): this;
        addListener(event: "error", listener: (err: Error) => void): this;
        addListener(
            event: "frameError",
            listener: (frameType: number, errorCode: number, streamID: number) => void,
        ): this;
        addListener(
            event: "goaway",
            listener: (errorCode: number, lastStreamID: number, opaqueData?: Buffer) => void,
        ): this;
        addListener(event: "localSettings", listener: (settings: Settings) => void): this;
        addListener(event: "ping", listener: () => void): this;
        addListener(event: "remoteSettings", listener: (settings: Settings) => void): this;
        addListener(event: "timeout", listener: () => void): this;
        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
        emit(event: "close"): boolean;
        emit(event: "error", err: Error): boolean;
        emit(event: "frameError", frameType: number, errorCode: number, streamID: number): boolean;
        emit(event: "goaway", errorCode: number, lastStreamID: number, opaqueData?: Buffer): boolean;
        emit(event: "localSettings", settings: Settings): boolean;
        emit(event: "ping"): boolean;
        emit(event: "remoteSettings", settings: Settings): boolean;
        emit(event: "timeout"): boolean;
        emit(event: string | symbol, ...args: any[]): boolean;
        on(event: "close", listener: () => void): this;
        on(event: "error", listener: (err: Error) => void): this;
        on(event: "frameError", listener: (frameType: number, errorCode: number, streamID: number) => void): this;
        on(event: "goaway", listener: (errorCode: number, lastStreamID: number, opaqueData?: Buffer) => void): this;
        on(event: "localSettings", listener: (settings: Settings) => void): this;
        on(event: "ping", listener: () => void): this;
        on(event: "remoteSettings", listener: (settings: Settings) => void): this;
        on(event: "timeout", listener: () => void): this;
        on(event: string | symbol, listener: (...args: any[]) => void): this;
        once(event: "close", listener: () => void): this;
        once(event: "error", listener: (err: Error) => void): this;
        once(event: "frameError", listener: (frameType: number, errorCode: number, streamID: number) => void): this;
        once(event: "goaway", listener: (errorCode: number, lastStreamID: number, opaqueData?: Buffer) => void): this;
        once(event: "localSettings", listener: (settings: Settings) => void): this;
        once(event: "ping", listener: () => void): this;
        once(event: "remoteSettings", listener: (settings: Settings) => void): this;
        once(event: "timeout", listener: () => void): this;
        once(event: string | symbol, listener: (...args: any[]) => void): this;
        prependListener(event: "close", listener: () => void): this;
        prependListener(event: "error", listener: (err: Error) => void): this;
        prependListener(
            event: "frameError",
            listener: (frameType: number, errorCode: number, streamID: number) => void,
        ): this;
        prependListener(
            event: "goaway",
            listener: (errorCode: number, lastStreamID: number, opaqueData?: Buffer) => void,
        ): this;
        prependListener(event: "localSettings", listener: (settings: Settings) => void): this;
        prependListener(event: "ping", listener: () => void): this;
        prependListener(event: "remoteSettings", listener: (settings: Settings) => void): this;
        prependListener(event: "timeout", listener: () => void): this;
        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
        prependOnceListener(event: "close", listener: () => void): this;
        prependOnceListener(event: "error", listener: (err: Error) => void): this;
        prependOnceListener(
            event: "frameError",
            listener: (frameType: number, errorCode: number, streamID: number) => void,
        ): this;
        prependOnceListener(
            event: "goaway",
            listener: (errorCode: number, lastStreamID: number, opaqueData?: Buffer) => void,
        ): this;
        prependOnceListener(event: "localSettings", listener: (settings: Settings) => void): this;
        prependOnceListener(event: "ping", listener: () => void): this;
        prependOnceListener(event: "remoteSettings", listener: (settings: Settings) => void): this;
        prependOnceListener(event: "timeout", listener: () => void): this;
        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
    }
    export interface ClientHttp2Session extends Http2Session {
        /**
         * For HTTP/2 Client `Http2Session` instances only, the `http2session.request()` creates and returns an `Http2Stream` instance that can be used to send an
         * HTTP/2 request to the connected server.
         *
         * When a `ClientHttp2Session` is first created, the socket may not yet be
         * connected. if `clienthttp2session.request()` is called during this time, the
         * actual request will be deferred until the socket is ready to go.
         * If the `session` is closed before the actual request be executed, an `ERR_HTTP2_GOAWAY_SESSION` is thrown.
         *
         * This method is only available if `http2session.type` is equal to `http2.constants.NGHTTP2_SESSION_CLIENT`.
         *
         * ```js
         * import http2 from 'node:http2';
         * const clientSession = http2.connect('https://localhost:1234');
         * const {
         *   HTTP2_HEADER_PATH,
         *   HTTP2_HEADER_STATUS,
         * } = http2.constants;
         *
         * const req = clientSession.request({ [HTTP2_HEADER_PATH]: '/' });
         * req.on('response', (headers) => {
         *   console.log(headers[HTTP2_HEADER_STATUS]);
         *   req.on('data', (chunk) => { // ..  });
         *   req.on('end', () => { // ..  });
         * });
         * ```
         *
         * When the `options.waitForTrailers` option is set, the `'wantTrailers'` event
         * is emitted immediately after queuing the last chunk of payload data to be sent.
         * The `http2stream.sendTrailers()` method can then be called to send trailing
         * headers to the peer.
         *
         * When `options.waitForTrailers` is set, the `Http2Stream` will not automatically
         * close when the final `DATA` frame is transmitted. User code must call either`http2stream.sendTrailers()` or `http2stream.close()` to close the`Http2Stream`.
         *
         * When `options.signal` is set with an `AbortSignal` and then `abort` on the
         * corresponding `AbortController` is called, the request will emit an `'error'`event with an `AbortError` error.
         *
         * The `:method` and `:path` pseudo-headers are not specified within `headers`,
         * they respectively default to:
         *
         * * `:method` \= `'GET'`
         * * `:path` \= `/`
         * @since v8.4.0
         */
        request(
            headers?: OutgoingHttpHeaders | readonly string[],
            options?: ClientSessionRequestOptions,
        ): ClientHttp2Stream;
        addListener(event: "altsvc", listener: (alt: string, origin: string, stream: number) => void): this;
        addListener(event: "origin", listener: (origins: string[]) => void): this;
        addListener(
            event: "connect",
            listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void,
        ): this;
        addListener(
            event: "stream",
            listener: (
                stream: ClientHttp2Stream,
                headers: IncomingHttpHeaders & IncomingHttpStatusHeader,
                flags: number,
            ) => void,
        ): this;
        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
        emit(event: "altsvc", alt: string, origin: string, stream: number): boolean;
        emit(event: "origin", origins: readonly string[]): boolean;
        emit(event: "connect", session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket): boolean;
        emit(
            event: "stream",
            stream: ClientHttp2Stream,
            headers: IncomingHttpHeaders & IncomingHttpStatusHeader,
            flags: number,
        ): boolean;
        emit(event: string | symbol, ...args: any[]): boolean;
        on(event: "altsvc", listener: (alt: string, origin: string, stream: number) => void): this;
        on(event: "origin", listener: (origins: string[]) => void): this;
        on(event: "connect", listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;
        on(
            event: "stream",
            listener: (
                stream: ClientHttp2Stream,
                headers: IncomingHttpHeaders & IncomingHttpStatusHeader,
                flags: number,
            ) => void,
        ): this;
        on(event: string | symbol, listener: (...args: any[]) => void): this;
        once(event: "altsvc", listener: (alt: string, origin: string, stream: number) => void): this;
        once(event: "origin", listener: (origins: string[]) => void): this;
        once(
            event: "connect",
            listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void,
        ): this;
        once(
            event: "stream",
            listener: (
                stream: ClientHttp2Stream,
                headers: IncomingHttpHeaders & IncomingHttpStatusHeader,
                flags: number,
            ) => void,
        ): this;
        once(event: string | symbol, listener: (...args: any[]) => void): this;
        prependListener(event: "altsvc", listener: (alt: string, origin: string, stream: number) => void): this;
        prependListener(event: "origin", listener: (origins: string[]) => void): this;
        prependListener(
            event: "connect",
            listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void,
        ): this;
        prependListener(
            event: "stream",
            listener: (
                stream: ClientHttp2Stream,
                headers: IncomingHttpHeaders & IncomingHttpStatusHeader,
                flags: number,
            ) => void,
        ): this;
        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
        prependOnceListener(event: "altsvc", listener: (alt: string, origin: string, stream: number) => void): this;
        prependOnceListener(event: "origin", listener: (origins: string[]) => void): this;
        prependOnceListener(
            event: "connect",
            listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void,
        ): this;
        prependOnceListener(
            event: "stream",
            listener: (
                stream: ClientHttp2Stream,
                headers: IncomingHttpHeaders & IncomingHttpStatusHeader,
                flags: number,
            ) => void,
        ): this;
        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
    }
    export interface AlternativeServiceOptions {
        origin: number | string | url.URL;
    }
    export interface ServerHttp2Session<
        Http1Request extends typeof IncomingMessage = typeof IncomingMessage,
        Http1Response extends typeof ServerResponse<InstanceType<Http1Request>> = typeof ServerResponse,
        Http2Request extends typeof Http2ServerRequest = typeof Http2ServerRequest,
        Http2Response extends typeof Http2ServerResponse<InstanceType<Http2Request>> = typeof Http2ServerResponse,
    > extends Http2Session {
        readonly server:
            | Http2Server<Http1Request, Http1Response, Http2Request, Http2Response>
            | Http2SecureServer<Http1Request, Http1Response, Http2Request, Http2Response>;
        /**
         * Submits an `ALTSVC` frame (as defined by [RFC 7838](https://tools.ietf.org/html/rfc7838)) to the connected client.
         *
         * ```js
         * import http2 from 'node:http2';
         *
         * const server = http2.createServer();
         * server.on('session', (session) => {
         *   // Set altsvc for origin https://example.org:80
         *   session.altsvc('h2=":8000"', 'https://example.org:80');
         * });
         *
         * server.on('stream', (stream) => {
         *   // Set altsvc for a specific stream
         *   stream.session.altsvc('h2=":8000"', stream.id);
         * });
         * ```
         *
         * Sending an `ALTSVC` frame with a specific stream ID indicates that the alternate
         * service is associated with the origin of the given `Http2Stream`.
         *
         * The `alt` and origin string _must_ contain only ASCII bytes and are
         * strictly interpreted as a sequence of ASCII bytes. The special value `'clear'`may be passed to clear any previously set alternative service for a given
         * domain.
         *
         * When a string is passed for the `originOrStream` argument, it will be parsed as
         * a URL and the origin will be derived. For instance, the origin for the
         * HTTP URL `'https://example.org/foo/bar'` is the ASCII string`'https://example.org'`. An error will be thrown if either the given string
         * cannot be parsed as a URL or if a valid origin cannot be derived.
         *
         * A `URL` object, or any object with an `origin` property, may be passed as`originOrStream`, in which case the value of the `origin` property will be
         * used. The value of the `origin` property _must_ be a properly serialized
         * ASCII origin.
         * @since v9.4.0
         * @param alt A description of the alternative service configuration as defined by `RFC 7838`.
         * @param originOrStream Either a URL string specifying the origin (or an `Object` with an `origin` property) or the numeric identifier of an active `Http2Stream` as given by the
         * `http2stream.id` property.
         */
        altsvc(alt: string, originOrStream: number | string | url.URL | AlternativeServiceOptions): void;
        /**
         * Submits an `ORIGIN` frame (as defined by [RFC 8336](https://tools.ietf.org/html/rfc8336)) to the connected client
         * to advertise the set of origins for which the server is capable of providing
         * authoritative responses.
         *
         * ```js
         * import http2 from 'node:http2';
         * const options = getSecureOptionsSomehow();
         * const server = http2.createSecureServer(options);
         * server.on('stream', (stream) => {
         *   stream.respond();
         *   stream.end('ok');
         * });
         * server.on('session', (session) => {
         *   session.origin('https://example.com', 'https://example.org');
         * });
         * ```
         *
         * When a string is passed as an `origin`, it will be parsed as a URL and the
         * origin will be derived. For instance, the origin for the HTTP URL `'https://example.org/foo/bar'` is the ASCII string` 'https://example.org'`. An error will be thrown if either the given
         * string
         * cannot be parsed as a URL or if a valid origin cannot be derived.
         *
         * A `URL` object, or any object with an `origin` property, may be passed as
         * an `origin`, in which case the value of the `origin` property will be
         * used. The value of the `origin` property _must_ be a properly serialized
         * ASCII origin.
         *
         * Alternatively, the `origins` option may be used when creating a new HTTP/2
         * server using the `http2.createSecureServer()` method:
         *
         * ```js
         * import http2 from 'node:http2';
         * const options = getSecureOptionsSomehow();
         * options.origins = ['https://example.com', 'https://example.org'];
         * const server = http2.createSecureServer(options);
         * server.on('stream', (stream) => {
         *   stream.respond();
         *   stream.end('ok');
         * });
         * ```
         * @since v10.12.0
         * @param origins One or more URL Strings passed as separate arguments.
         */
        origin(
            ...origins: Array<
                | string
                | url.URL
                | {
                    origin: string;
                }
            >
        ): void;
        addListener(
            event: "connect",
            listener: (
                session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>,
                socket: net.Socket | tls.TLSSocket,
            ) => void,
        ): this;
        addListener(
            event: "stream",
            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
        ): this;
        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
        emit(
            event: "connect",
            session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>,
            socket: net.Socket | tls.TLSSocket,
        ): boolean;
        emit(event: "stream", stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number): boolean;
        emit(event: string | symbol, ...args: any[]): boolean;
        on(
            event: "connect",
            listener: (
                session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>,
                socket: net.Socket | tls.TLSSocket,
            ) => void,
        ): this;
        on(
            event: "stream",
            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
        ): this;
        on(event: string | symbol, listener: (...args: any[]) => void): this;
        once(
            event: "connect",
            listener: (
                session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>,
                socket: net.Socket | tls.TLSSocket,
            ) => void,
        ): this;
        once(
            event: "stream",
            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
        ): this;
        once(event: string | symbol, listener: (...args: any[]) => void): this;
        prependListener(
            event: "connect",
            listener: (
                session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>,
                socket: net.Socket | tls.TLSSocket,
            ) => void,
        ): this;
        prependListener(
            event: "stream",
            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
        ): this;
        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
        prependOnceListener(
            event: "connect",
            listener: (
                session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>,
                socket: net.Socket | tls.TLSSocket,
            ) => void,
        ): this;
        prependOnceListener(
            event: "stream",
            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
        ): this;
        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
    }
    // Http2Server
    export interface SessionOptions {
        /**
         * Sets the maximum dynamic table size for deflating header fields.
         * @default 4Kib
         */
        maxDeflateDynamicTableSize?: number | undefined;
        /**
         * Sets the maximum number of settings entries per `SETTINGS` frame.
         * The minimum value allowed is `1`.
         * @default 32
         */
        maxSettings?: number | undefined;
        /**
         * Sets the maximum memory that the `Http2Session` is permitted to use.
         * The value is expressed in terms of number of megabytes, e.g. `1` equal 1 megabyte.
         * The minimum value allowed is `1`.
         * This is a credit based limit, existing `Http2Stream`s may cause this limit to be exceeded,
         * but new `Http2Stream` instances will be rejected while this limit is exceeded.
         * The current number of `Http2Stream` sessions, the current memory use of the header compression tables,
         * current data queued to be sent, and unacknowledged `PING` and `SETTINGS` frames are all counted towards the current limit.
         * @default 10
         */
        maxSessionMemory?: number | undefined;
        /**
         * Sets the maximum number of header entries.
         * This is similar to `server.maxHeadersCount` or `request.maxHeadersCount` in the `node:http` module.
         * The minimum value is `1`.
         * @default 128
         */
        maxHeaderListPairs?: number | undefined;
        /**
         * Sets the maximum number of outstanding, unacknowledged pings.
         * @default 10
         */
        maxOutstandingPings?: number | undefined;
        /**
         * Sets the maximum allowed size for a serialized, compressed block of headers.
         * Attempts to send headers that exceed this limit will result in
         * a `'frameError'` event being emitted and the stream being closed and destroyed.
         */
        maxSendHeaderBlockLength?: number | undefined;
        /**
         * Strategy used for determining the amount of padding to use for `HEADERS` and `DATA` frames.
         * @default http2.constants.PADDING_STRATEGY_NONE
         */
        paddingStrategy?: number | undefined;
        /**
         * Sets the maximum number of concurrent streams for the remote peer as if a `SETTINGS` frame had been received.
         * Will be overridden if the remote peer sets its own value for `maxConcurrentStreams`.
         * @default 100
         */
        peerMaxConcurrentStreams?: number | undefined;
        /**
         * The initial settings to send to the remote peer upon connection.
         */
        settings?: Settings | undefined;
        /**
         * The array of integer values determines the settings types,
         * which are included in the `CustomSettings`-property of the received remoteSettings.
         * Please see the `CustomSettings`-property of the `Http2Settings` object for more information, on the allowed setting types.
         */
        remoteCustomSettings?: number[] | undefined;
        /**
         * Specifies a timeout in milliseconds that
         * a server should wait when an [`'unknownProtocol'`][] is emitted. If the
         * socket has not been destroyed by that time the server will destroy it.
         * @default 100000
         */
        unknownProtocolTimeout?: number | undefined;
        /**
         * If `true`, it turns on strict leading
         * and trailing whitespace validation for HTTP/2 header field names and values
         * as per [RFC-9113](https://www.rfc-editor.org/rfc/rfc9113.html#section-8.2.1).
         * @since v24.2.0
         * @default true
         */
        strictFieldWhitespaceValidation?: boolean | undefined;
    }
    export interface ClientSessionOptions extends SessionOptions {
        /**
         * Sets the maximum number of reserved push streams the client will accept at any given time.
         * Once the current number of currently reserved push streams exceeds reaches this limit,
         * new push streams sent by the server will be automatically rejected.
         * The minimum allowed value is 0. The maximum allowed value is 2<sup>32</sup>-1.
         * A negative value sets this option to the maximum allowed value.
         * @default 200
         */
        maxReservedRemoteStreams?: number | undefined;
        /**
         * An optional callback that receives the `URL` instance passed to `connect` and the `options` object,
         * and returns any `Duplex` stream that is to be used as the connection for this session.
         */
        createConnection?: ((authority: url.URL, option: SessionOptions) => stream.Duplex) | undefined;
        /**
         * The protocol to connect with, if not set in the `authority`.
         * Value may be either `'http:'` or `'https:'`.
         * @default 'https:'
         */
        protocol?: "http:" | "https:" | undefined;
    }
    export interface ServerSessionOptions<
        Http1Request extends typeof IncomingMessage = typeof IncomingMessage,
        Http1Response extends typeof ServerResponse<InstanceType<Http1Request>> = typeof ServerResponse,
        Http2Request extends typeof Http2ServerRequest = typeof Http2ServerRequest,
        Http2Response extends typeof Http2ServerResponse<InstanceType<Http2Request>> = typeof Http2ServerResponse,
    > extends SessionOptions {
        streamResetBurst?: number | undefined;
        streamResetRate?: number | undefined;
        Http1IncomingMessage?: Http1Request | undefined;
        Http1ServerResponse?: Http1Response | undefined;
        Http2ServerRequest?: Http2Request | undefined;
        Http2ServerResponse?: Http2Response | undefined;
    }
    export interface SecureClientSessionOptions extends ClientSessionOptions, tls.ConnectionOptions {}
    export interface SecureServerSessionOptions<
        Http1Request extends typeof IncomingMessage = typeof IncomingMessage,
        Http1Response extends typeof ServerResponse<InstanceType<Http1Request>> = typeof ServerResponse,
        Http2Request extends typeof Http2ServerRequest = typeof Http2ServerRequest,
        Http2Response extends typeof Http2ServerResponse<InstanceType<Http2Request>> = typeof Http2ServerResponse,
    > extends ServerSessionOptions<Http1Request, Http1Response, Http2Request, Http2Response>, tls.TlsOptions {}
    export interface ServerOptions<
        Http1Request extends typeof IncomingMessage = typeof IncomingMessage,
        Http1Response extends typeof ServerResponse<InstanceType<Http1Request>> = typeof ServerResponse,
        Http2Request extends typeof Http2ServerRequest = typeof Http2ServerRequest,
        Http2Response extends typeof Http2ServerResponse<InstanceType<Http2Request>> = typeof Http2ServerResponse,
    > extends ServerSessionOptions<Http1Request, Http1Response, Http2Request, Http2Response> {}
    export interface SecureServerOptions<
        Http1Request extends typeof IncomingMessage = typeof IncomingMessage,
        Http1Response extends typeof ServerResponse<InstanceType<Http1Request>> = typeof ServerResponse,
        Http2Request extends typeof Http2ServerRequest = typeof Http2ServerRequest,
        Http2Response extends typeof Http2ServerResponse<InstanceType<Http2Request>> = typeof Http2ServerResponse,
    > extends SecureServerSessionOptions<Http1Request, Http1Response, Http2Request, Http2Response> {
        allowHTTP1?: boolean | undefined;
        origins?: string[] | undefined;
    }
    interface HTTP2ServerCommon {
        setTimeout(msec?: number, callback?: () => void): this;
        /**
         * Throws ERR_HTTP2_INVALID_SETTING_VALUE for invalid settings values.
         * Throws ERR_INVALID_ARG_TYPE for invalid settings argument.
         */
        updateSettings(settings: Settings): void;
    }
    export interface Http2Server<
        Http1Request extends typeof IncomingMessage = typeof IncomingMessage,
        Http1Response extends typeof ServerResponse<InstanceType<Http1Request>> = typeof ServerResponse,
        Http2Request extends typeof Http2ServerRequest = typeof Http2ServerRequest,
        Http2Response extends typeof Http2ServerResponse<InstanceType<Http2Request>> = typeof Http2ServerResponse,
    > extends net.Server, HTTP2ServerCommon {
        addListener(
            event: "checkContinue",
            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
        ): this;
        addListener(
            event: "request",
            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
        ): this;
        addListener(
            event: "session",
            listener: (session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>) => void,
        ): this;
        addListener(event: "sessionError", listener: (err: Error) => void): this;
        addListener(
            event: "stream",
            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
        ): this;
        addListener(event: "timeout", listener: () => void): this;
        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
        emit(
            event: "checkContinue",
            request: InstanceType<Http2Request>,
            response: InstanceType<Http2Response>,
        ): boolean;
        emit(event: "request", request: InstanceType<Http2Request>, response: InstanceType<Http2Response>): boolean;
        emit(
            event: "session",
            session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>,
        ): boolean;
        emit(event: "sessionError", err: Error): boolean;
        emit(event: "stream", stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number): boolean;
        emit(event: "timeout"): boolean;
        emit(event: string | symbol, ...args: any[]): boolean;
        on(
            event: "checkContinue",
            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
        ): this;
        on(
            event: "request",
            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
        ): this;
        on(
            event: "session",
            listener: (session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>) => void,
        ): this;
        on(event: "sessionError", listener: (err: Error) => void): this;
        on(
            event: "stream",
            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
        ): this;
        on(event: "timeout", listener: () => void): this;
        on(event: string | symbol, listener: (...args: any[]) => void): this;
        once(
            event: "checkContinue",
            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
        ): this;
        once(
            event: "request",
            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
        ): this;
        once(
            event: "session",
            listener: (session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>) => void,
        ): this;
        once(event: "sessionError", listener: (err: Error) => void): this;
        once(
            event: "stream",
            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
        ): this;
        once(event: "timeout", listener: () => void): this;
        once(event: string | symbol, listener: (...args: any[]) => void): this;
        prependListener(
            event: "checkContinue",
            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
        ): this;
        prependListener(
            event: "request",
            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
        ): this;
        prependListener(
            event: "session",
            listener: (session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>) => void,
        ): this;
        prependListener(event: "sessionError", listener: (err: Error) => void): this;
        prependListener(
            event: "stream",
            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
        ): this;
        prependListener(event: "timeout", listener: () => void): this;
        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
        prependOnceListener(
            event: "checkContinue",
            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
        ): this;
        prependOnceListener(
            event: "request",
            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
        ): this;
        prependOnceListener(
            event: "session",
            listener: (session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>) => void,
        ): this;
        prependOnceListener(event: "sessionError", listener: (err: Error) => void): this;
        prependOnceListener(
            event: "stream",
            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
        ): this;
        prependOnceListener(event: "timeout", listener: () => void): this;
        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
    }
    export interface Http2SecureServer<
        Http1Request extends typeof IncomingMessage = typeof IncomingMessage,
        Http1Response extends typeof ServerResponse<InstanceType<Http1Request>> = typeof ServerResponse,
        Http2Request extends typeof Http2ServerRequest = typeof Http2ServerRequest,
        Http2Response extends typeof Http2ServerResponse<InstanceType<Http2Request>> = typeof Http2ServerResponse,
    > extends tls.Server, HTTP2ServerCommon {
        addListener(
            event: "checkContinue",
            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
        ): this;
        addListener(
            event: "request",
            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
        ): this;
        addListener(
            event: "session",
            listener: (session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>) => void,
        ): this;
        addListener(event: "sessionError", listener: (err: Error) => void): this;
        addListener(
            event: "stream",
            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
        ): this;
        addListener(event: "timeout", listener: () => void): this;
        addListener(event: "unknownProtocol", listener: (socket: tls.TLSSocket) => void): this;
        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
        emit(
            event: "checkContinue",
            request: InstanceType<Http2Request>,
            response: InstanceType<Http2Response>,
        ): boolean;
        emit(event: "request", request: InstanceType<Http2Request>, response: InstanceType<Http2Response>): boolean;
        emit(
            event: "session",
            session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>,
        ): boolean;
        emit(event: "sessionError", err: Error): boolean;
        emit(event: "stream", stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number): boolean;
        emit(event: "timeout"): boolean;
        emit(event: "unknownProtocol", socket: tls.TLSSocket): boolean;
        emit(event: string | symbol, ...args: any[]): boolean;
        on(
            event: "checkContinue",
            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
        ): this;
        on(
            event: "request",
            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
        ): this;
        on(
            event: "session",
            listener: (session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>) => void,
        ): this;
        on(event: "sessionError", listener: (err: Error) => void): this;
        on(
            event: "stream",
            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
        ): this;
        on(event: "timeout", listener: () => void): this;
        on(event: "unknownProtocol", listener: (socket: tls.TLSSocket) => void): this;
        on(event: string | symbol, listener: (...args: any[]) => void): this;
        once(
            event: "checkContinue",
            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
        ): this;
        once(
            event: "request",
            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
        ): this;
        once(
            event: "session",
            listener: (session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>) => void,
        ): this;
        once(event: "sessionError", listener: (err: Error) => void): this;
        once(
            event: "stream",
            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
        ): this;
        once(event: "timeout", listener: () => void): this;
        once(event: "unknownProtocol", listener: (socket: tls.TLSSocket) => void): this;
        once(event: string | symbol, listener: (...args: any[]) => void): this;
        prependListener(
            event: "checkContinue",
            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
        ): this;
        prependListener(
            event: "request",
            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
        ): this;
        prependListener(
            event: "session",
            listener: (session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>) => void,
        ): this;
        prependListener(event: "sessionError", listener: (err: Error) => void): this;
        prependListener(
            event: "stream",
            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
        ): this;
        prependListener(event: "timeout", listener: () => void): this;
        prependListener(event: "unknownProtocol", listener: (socket: tls.TLSSocket) => void): this;
        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
        prependOnceListener(
            event: "checkContinue",
            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
        ): this;
        prependOnceListener(
            event: "request",
            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
        ): this;
        prependOnceListener(
            event: "session",
            listener: (session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>) => void,
        ): this;
        prependOnceListener(event: "sessionError", listener: (err: Error) => void): this;
        prependOnceListener(
            event: "stream",
            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
        ): this;
        prependOnceListener(event: "timeout", listener: () => void): this;
        prependOnceListener(event: "unknownProtocol", listener: (socket: tls.TLSSocket) => void): this;
        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
    }
    /**
     * A `Http2ServerRequest` object is created by {@link Server} or {@link SecureServer} and passed as the first argument to the `'request'` event. It may be used to access a request status,
     * headers, and
     * data.
     * @since v8.4.0
     */
    export class Http2ServerRequest extends stream.Readable {
        constructor(
            stream: ServerHttp2Stream,
            headers: IncomingHttpHeaders,
            options: stream.ReadableOptions,
            rawHeaders: readonly string[],
        );
        /**
         * The `request.aborted` property will be `true` if the request has
         * been aborted.
         * @since v10.1.0
         */
        readonly aborted: boolean;
        /**
         * The request authority pseudo header field. Because HTTP/2 allows requests
         * to set either `:authority` or `host`, this value is derived from `req.headers[':authority']` if present. Otherwise, it is derived from `req.headers['host']`.
         * @since v8.4.0
         */
        readonly authority: string;
        /**
         * See `request.socket`.
         * @since v8.4.0
         * @deprecated Since v13.0.0 - Use `socket`.
         */
        readonly connection: net.Socket | tls.TLSSocket;
        /**
         * The `request.complete` property will be `true` if the request has
         * been completed, aborted, or destroyed.
         * @since v12.10.0
         */
        readonly complete: boolean;
        /**
         * The request/response headers object.
         *
         * Key-value pairs of header names and values. Header names are lower-cased.
         *
         * ```js
         * // Prints something like:
         * //
         * // { 'user-agent': 'curl/7.22.0',
         * //   host: '127.0.0.1:8000',
         * //   accept: '*' }
         * console.log(request.headers);
         * ```
         *
         * See `HTTP/2 Headers Object`.
         *
         * In HTTP/2, the request path, host name, protocol, and method are represented as
         * special headers prefixed with the `:` character (e.g. `':path'`). These special
         * headers will be included in the `request.headers` object. Care must be taken not
         * to inadvertently modify these special headers or errors may occur. For instance,
         * removing all headers from the request will cause errors to occur:
         *
         * ```js
         * removeAllHeaders(request.headers);
         * assert(request.url);   // Fails because the :path header has been removed
         * ```
         * @since v8.4.0
         */
        readonly headers: IncomingHttpHeaders;
        /**
         * In case of server request, the HTTP version sent by the client. In the case of
         * client response, the HTTP version of the connected-to server. Returns `'2.0'`.
         *
         * Also `message.httpVersionMajor` is the first integer and `message.httpVersionMinor` is the second.
         * @since v8.4.0
         */
        readonly httpVersion: string;
        readonly httpVersionMinor: number;
        readonly httpVersionMajor: number;
        /**
         * The request method as a string. Read-only. Examples: `'GET'`, `'DELETE'`.
         * @since v8.4.0
         */
        readonly method: string;
        /**
         * The raw request/response headers list exactly as they were received.
         *
         * The keys and values are in the same list. It is _not_ a
         * list of tuples. So, the even-numbered offsets are key values, and the
         * odd-numbered offsets are the associated values.
         *
         * Header names are not lowercased, and duplicates are not merged.
         *
         * ```js
         * // Prints something like:
         * //
         * // [ 'user-agent',
         * //   'this is invalid because there can be only one',
         * //   'User-Agent',
         * //   'curl/7.22.0',
         * //   'Host',
         * //   '127.0.0.1:8000',
         * //   'ACCEPT',
         * //   '*' ]
         * console.log(request.rawHeaders);
         * ```
         * @since v8.4.0
         */
        readonly rawHeaders: string[];
        /**
         * The raw request/response trailer keys and values exactly as they were
         * received. Only populated at the `'end'` event.
         * @since v8.4.0
         */
        readonly rawTrailers: string[];
        /**
         * The request scheme pseudo header field indicating the scheme
         * portion of the target URL.
         * @since v8.4.0
         */
        readonly scheme: string;
        /**
         * Returns a `Proxy` object that acts as a `net.Socket` (or `tls.TLSSocket`) but
         * applies getters, setters, and methods based on HTTP/2 logic.
         *
         * `destroyed`, `readable`, and `writable` properties will be retrieved from and
         * set on `request.stream`.
         *
         * `destroy`, `emit`, `end`, `on` and `once` methods will be called on `request.stream`.
         *
         * `setTimeout` method will be called on `request.stream.session`.
         *
         * `pause`, `read`, `resume`, and `write` will throw an error with code `ERR_HTTP2_NO_SOCKET_MANIPULATION`. See `Http2Session and Sockets` for
         * more information.
         *
         * All other interactions will be routed directly to the socket. With TLS support,
         * use `request.socket.getPeerCertificate()` to obtain the client's
         * authentication details.
         * @since v8.4.0
         */
        readonly socket: net.Socket | tls.TLSSocket;
        /**
         * The `Http2Stream` object backing the request.
         * @since v8.4.0
         */
        readonly stream: ServerHttp2Stream;
        /**
         * The request/response trailers object. Only populated at the `'end'` event.
         * @since v8.4.0
         */
        readonly trailers: IncomingHttpHeaders;
        /**
         * Request URL string. This contains only the URL that is present in the actual
         * HTTP request. If the request is:
         *
         * ```http
         * GET /status?name=ryan HTTP/1.1
         * Accept: text/plain
         * ```
         *
         * Then `request.url` will be:
         *
         * ```js
         * '/status?name=ryan'
         * ```
         *
         * To parse the url into its parts, `new URL()` can be used:
         *
         * ```console
         * $ node
         * > new URL('/status?name=ryan', 'http://example.com')
         * URL {
         *   href: 'http://example.com/status?name=ryan',
         *   origin: 'http://example.com',
         *   protocol: 'http:',
         *   username: '',
         *   password: '',
         *   host: 'example.com',
         *   hostname: 'example.com',
         *   port: '',
         *   pathname: '/status',
         *   search: '?name=ryan',
         *   searchParams: URLSearchParams { 'name' => 'ryan' },
         *   hash: ''
         * }
         * ```
         * @since v8.4.0
         */
        url: string;
        /**
         * Sets the `Http2Stream`'s timeout value to `msecs`. If a callback is
         * provided, then it is added as a listener on the `'timeout'` event on
         * the response object.
         *
         * If no `'timeout'` listener is added to the request, the response, or
         * the server, then `Http2Stream`s are destroyed when they time out. If a
         * handler is assigned to the request, the response, or the server's `'timeout'`events, timed out sockets must be handled explicitly.
         * @since v8.4.0
         */
        setTimeout(msecs: number, callback?: () => void): void;
        read(size?: number): Buffer | string | null;
        addListener(event: "aborted", listener: (hadError: boolean, code: number) => void): this;
        addListener(event: "close", listener: () => void): this;
        addListener(event: "data", listener: (chunk: Buffer | string) => void): this;
        addListener(event: "end", listener: () => void): this;
        addListener(event: "readable", listener: () => void): this;
        addListener(event: "error", listener: (err: Error) => void): this;
        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
        emit(event: "aborted", hadError: boolean, code: number): boolean;
        emit(event: "close"): boolean;
        emit(event: "data", chunk: Buffer | string): boolean;
        emit(event: "end"): boolean;
        emit(event: "readable"): boolean;
        emit(event: "error", err: Error): boolean;
        emit(event: string | symbol, ...args: any[]): boolean;
        on(event: "aborted", listener: (hadError: boolean, code: number) => void): this;
        on(event: "close", listener: () => void): this;
        on(event: "data", listener: (chunk: Buffer | string) => void): this;
        on(event: "end", listener: () => void): this;
        on(event: "readable", listener: () => void): this;
        on(event: "error", listener: (err: Error) => void): this;
        on(event: string | symbol, listener: (...args: any[]) => void): this;
        once(event: "aborted", listener: (hadError: boolean, code: number) => void): this;
        once(event: "close", listener: () => void): this;
        once(event: "data", listener: (chunk: Buffer | string) => void): this;
        once(event: "end", listener: () => void): this;
        once(event: "readable", listener: () => void): this;
        once(event: "error", listener: (err: Error) => void): this;
        once(event: string | symbol, listener: (...args: any[]) => void): this;
        prependListener(event: "aborted", listener: (hadError: boolean, code: number) => void): this;
        prependListener(event: "close", listener: () => void): this;
        prependListener(event: "data", listener: (chunk: Buffer | string) => void): this;
        prependListener(event: "end", listener: () => void): this;
        prependListener(event: "readable", listener: () => void): this;
        prependListener(event: "error", listener: (err: Error) => void): this;
        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
        prependOnceListener(event: "aborted", listener: (hadError: boolean, code: number) => void): this;
        prependOnceListener(event: "close", listener: () => void): this;
        prependOnceListener(event: "data", listener: (chunk: Buffer | string) => void): this;
        prependOnceListener(event: "end", listener: () => void): this;
        prependOnceListener(event: "readable", listener: () => void): this;
        prependOnceListener(event: "error", listener: (err: Error) => void): this;
        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
    }
    /**
     * This object is created internally by an HTTP server, not by the user. It is
     * passed as the second parameter to the `'request'` event.
     * @since v8.4.0
     */
    export class Http2ServerResponse<Request extends Http2ServerRequest = Http2ServerRequest> extends stream.Writable {
        constructor(stream: ServerHttp2Stream);
        /**
         * See `response.socket`.
         * @since v8.4.0
         * @deprecated Since v13.0.0 - Use `socket`.
         */
        readonly connection: net.Socket | tls.TLSSocket;
        /**
         * Append a single header value to the header object.
         *
         * If the value is an array, this is equivalent to calling this method multiple times.
         *
         * If there were no previous values for the header, this is equivalent to calling {@link setHeader}.
         *
         * Attempting to set a header field name or value that contains invalid characters will result in a
         * [TypeError](https://nodejs.org/docs/latest-v22.x/api/errors.html#class-typeerror) being thrown.
         *
         * ```js
         * // Returns headers including "set-cookie: a" and "set-cookie: b"
         * const server = http2.createServer((req, res) => {
         *   res.setHeader('set-cookie', 'a');
         *   res.appendHeader('set-cookie', 'b');
         *   res.writeHead(200);
         *   res.end('ok');
         * });
         * ```
         * @since v20.12.0
         */
        appendHeader(name: string, value: string | string[]): void;
        /**
         * Boolean value that indicates whether the response has completed. Starts
         * as `false`. After `response.end()` executes, the value will be `true`.
         * @since v8.4.0
         * @deprecated Since v13.4.0,v12.16.0 - Use `writableEnded`.
         */
        readonly finished: boolean;
        /**
         * True if headers were sent, false otherwise (read-only).
         * @since v8.4.0
         */
        readonly headersSent: boolean;
        /**
         * A reference to the original HTTP2 `request` object.
         * @since v15.7.0
         */
        readonly req: Request;
        /**
         * Returns a `Proxy` object that acts as a `net.Socket` (or `tls.TLSSocket`) but
         * applies getters, setters, and methods based on HTTP/2 logic.
         *
         * `destroyed`, `readable`, and `writable` properties will be retrieved from and
         * set on `response.stream`.
         *
         * `destroy`, `emit`, `end`, `on` and `once` methods will be called on `response.stream`.
         *
         * `setTimeout` method will be called on `response.stream.session`.
         *
         * `pause`, `read`, `resume`, and `write` will throw an error with code `ERR_HTTP2_NO_SOCKET_MANIPULATION`. See `Http2Session and Sockets` for
         * more information.
         *
         * All other interactions will be routed directly to the socket.
         *
         * ```js
         * import http2 from 'node:http2';
         * const server = http2.createServer((req, res) => {
         *   const ip = req.socket.remoteAddress;
         *   const port = req.socket.remotePort;
         *   res.end(`Your IP address is ${ip} and your source port is ${port}.`);
         * }).listen(3000);
         * ```
         * @since v8.4.0
         */
        readonly socket: net.Socket | tls.TLSSocket;
        /**
         * The `Http2Stream` object backing the response.
         * @since v8.4.0
         */
        readonly stream: ServerHttp2Stream;
        /**
         * When true, the Date header will be automatically generated and sent in
         * the response if it is not already present in the headers. Defaults to true.
         *
         * This should only be disabled for testing; HTTP requires the Date header
         * in responses.
         * @since v8.4.0
         */
        sendDate: boolean;
        /**
         * When using implicit headers (not calling `response.writeHead()` explicitly),
         * this property controls the status code that will be sent to the client when
         * the headers get flushed.
         *
         * ```js
         * response.statusCode = 404;
         * ```
         *
         * After response header was sent to the client, this property indicates the
         * status code which was sent out.
         * @since v8.4.0
         */
        statusCode: number;
        /**
         * Status message is not supported by HTTP/2 (RFC 7540 8.1.2.4). It returns
         * an empty string.
         * @since v8.4.0
         */
        statusMessage: "";
        /**
         * This method adds HTTP trailing headers (a header but at the end of the
         * message) to the response.
         *
         * Attempting to set a header field name or value that contains invalid characters
         * will result in a `TypeError` being thrown.
         * @since v8.4.0
         */
        addTrailers(trailers: OutgoingHttpHeaders): void;
        /**
         * This method signals to the server that all of the response headers and body
         * have been sent; that server should consider this message complete.
         * The method, `response.end()`, MUST be called on each response.
         *
         * If `data` is specified, it is equivalent to calling `response.write(data, encoding)` followed by `response.end(callback)`.
         *
         * If `callback` is specified, it will be called when the response stream
         * is finished.
         * @since v8.4.0
         */
        end(callback?: () => void): this;
        end(data: string | Uint8Array, callback?: () => void): this;
        end(data: string | Uint8Array, encoding: BufferEncoding, callback?: () => void): this;
        /**
         * Reads out a header that has already been queued but not sent to the client.
         * The name is case-insensitive.
         *
         * ```js
         * const contentType = response.getHeader('content-type');
         * ```
         * @since v8.4.0
         */
        getHeader(name: string): string;
        /**
         * Returns an array containing the unique names of the current outgoing headers.
         * All header names are lowercase.
         *
         * ```js
         * response.setHeader('Foo', 'bar');
         * response.setHeader('Set-Cookie', ['foo=bar', 'bar=baz']);
         *
         * const headerNames = response.getHeaderNames();
         * // headerNames === ['foo', 'set-cookie']
         * ```
         * @since v8.4.0
         */
        getHeaderNames(): string[];
        /**
         * Returns a shallow copy of the current outgoing headers. Since a shallow copy
         * is used, array values may be mutated without additional calls to various
         * header-related http module methods. The keys of the returned object are the
         * header names and the values are the respective header values. All header names
         * are lowercase.
         *
         * The object returned by the `response.getHeaders()` method _does not_ prototypically inherit from the JavaScript `Object`. This means that typical `Object` methods such as `obj.toString()`,
         * `obj.hasOwnProperty()`, and others
         * are not defined and _will not work_.
         *
         * ```js
         * response.setHeader('Foo', 'bar');
         * response.setHeader('Set-Cookie', ['foo=bar', 'bar=baz']);
         *
         * const headers = response.getHeaders();
         * // headers === { foo: 'bar', 'set-cookie': ['foo=bar', 'bar=baz'] }
         * ```
         * @since v8.4.0
         */
        getHeaders(): OutgoingHttpHeaders;
        /**
         * Returns `true` if the header identified by `name` is currently set in the
         * outgoing headers. The header name matching is case-insensitive.
         *
         * ```js
         * const hasContentType = response.hasHeader('content-type');
         * ```
         * @since v8.4.0
         */
        hasHeader(name: string): boolean;
        /**
         * Removes a header that has been queued for implicit sending.
         *
         * ```js
         * response.removeHeader('Content-Encoding');
         * ```
         * @since v8.4.0
         */
        removeHeader(name: string): void;
        /**
         * Sets a single header value for implicit headers. If this header already exists
         * in the to-be-sent headers, its value will be replaced. Use an array of strings
         * here to send multiple headers with the same name.
         *
         * ```js
         * response.setHeader('Content-Type', 'text/html; charset=utf-8');
         * ```
         *
         * or
         *
         * ```js
         * response.setHeader('Set-Cookie', ['type=ninja', 'language=javascript']);
         * ```
         *
         * Attempting to set a header field name or value that contains invalid characters
         * will result in a `TypeError` being thrown.
         *
         * When headers have been set with `response.setHeader()`, they will be merged
         * with any headers passed to `response.writeHead()`, with the headers passed
         * to `response.writeHead()` given precedence.
         *
         * ```js
         * // Returns content-type = text/plain
         * const server = http2.createServer((req, res) => {
         *   res.setHeader('Content-Type', 'text/html; charset=utf-8');
         *   res.setHeader('X-Foo', 'bar');
         *   res.writeHead(200, { 'Content-Type': 'text/plain; charset=utf-8' });
         *   res.end('ok');
         * });
         * ```
         * @since v8.4.0
         */
        setHeader(name: string, value: number | string | readonly string[]): void;
        /**
         * Sets the `Http2Stream`'s timeout value to `msecs`. If a callback is
         * provided, then it is added as a listener on the `'timeout'` event on
         * the response object.
         *
         * If no `'timeout'` listener is added to the request, the response, or
         * the server, then `Http2Stream` s are destroyed when they time out. If a
         * handler is assigned to the request, the response, or the server's `'timeout'` events, timed out sockets must be handled explicitly.
         * @since v8.4.0
         */
        setTimeout(msecs: number, callback?: () => void): void;
        /**
         * If this method is called and `response.writeHead()` has not been called,
         * it will switch to implicit header mode and flush the implicit headers.
         *
         * This sends a chunk of the response body. This method may
         * be called multiple times to provide successive parts of the body.
         *
         * In the `node:http` module, the response body is omitted when the
         * request is a HEAD request. Similarly, the `204` and `304` responses _must not_ include a message body.
         *
         * `chunk` can be a string or a buffer. If `chunk` is a string,
         * the second parameter specifies how to encode it into a byte stream.
         * By default the `encoding` is `'utf8'`. `callback` will be called when this chunk
         * of data is flushed.
         *
         * This is the raw HTTP body and has nothing to do with higher-level multi-part
         * body encodings that may be used.
         *
         * The first time `response.write()` is called, it will send the buffered
         * header information and the first chunk of the body to the client. The second
         * time `response.write()` is called, Node.js assumes data will be streamed,
         * and sends the new data separately. That is, the response is buffered up to the
         * first chunk of the body.
         *
         * Returns `true` if the entire data was flushed successfully to the kernel
         * buffer. Returns `false` if all or part of the data was queued in user memory.`'drain'` will be emitted when the buffer is free again.
         * @since v8.4.0
         */
        write(chunk: string | Uint8Array, callback?: (err: Error) => void): boolean;
        write(chunk: string | Uint8Array, encoding: BufferEncoding, callback?: (err: Error) => void): boolean;
        /**
         * Sends a status `100 Continue` to the client, indicating that the request body
         * should be sent. See the `'checkContinue'` event on `Http2Server` and `Http2SecureServer`.
         * @since v8.4.0
         */
        writeContinue(): void;
        /**
         * Sends a status `103 Early Hints` to the client with a Link header,
         * indicating that the user agent can preload/preconnect the linked resources.
         * The `hints` is an object containing the values of headers to be sent with
         * early hints message.
         *
         * **Example**
         *
         * ```js
         * const earlyHintsLink = '</styles.css>; rel=preload; as=style';
         * response.writeEarlyHints({
         *   'link': earlyHintsLink,
         * });
         *
         * const earlyHintsLinks = [
         *   '</styles.css>; rel=preload; as=style',
         *   '</scripts.js>; rel=preload; as=script',
         * ];
         * response.writeEarlyHints({
         *   'link': earlyHintsLinks,
         * });
         * ```
         * @since v18.11.0
         */
        writeEarlyHints(hints: Record<string, string | string[]>): void;
        /**
         * Sends a response header to the request. The status code is a 3-digit HTTP
         * status code, like `404`. The last argument, `headers`, are the response headers.
         *
         * Returns a reference to the `Http2ServerResponse`, so that calls can be chained.
         *
         * For compatibility with `HTTP/1`, a human-readable `statusMessage` may be
         * passed as the second argument. However, because the `statusMessage` has no
         * meaning within HTTP/2, the argument will have no effect and a process warning
         * will be emitted.
         *
         * ```js
         * const body = 'hello world';
         * response.writeHead(200, {
         *   'Content-Length': Buffer.byteLength(body),
         *   'Content-Type': 'text/plain; charset=utf-8',
         * });
         * ```
         *
         * `Content-Length` is given in bytes not characters. The`Buffer.byteLength()` API may be used to determine the number of bytes in a
         * given encoding. On outbound messages, Node.js does not check if Content-Length
         * and the length of the body being transmitted are equal or not. However, when
         * receiving messages, Node.js will automatically reject messages when the `Content-Length` does not match the actual payload size.
         *
         * This method may be called at most one time on a message before `response.end()` is called.
         *
         * If `response.write()` or `response.end()` are called before calling
         * this, the implicit/mutable headers will be calculated and call this function.
         *
         * When headers have been set with `response.setHeader()`, they will be merged
         * with any headers passed to `response.writeHead()`, with the headers passed
         * to `response.writeHead()` given precedence.
         *
         * ```js
         * // Returns content-type = text/plain
         * const server = http2.createServer((req, res) => {
         *   res.setHeader('Content-Type', 'text/html; charset=utf-8');
         *   res.setHeader('X-Foo', 'bar');
         *   res.writeHead(200, { 'Content-Type': 'text/plain; charset=utf-8' });
         *   res.end('ok');
         * });
         * ```
         *
         * Attempting to set a header field name or value that contains invalid characters
         * will result in a `TypeError` being thrown.
         * @since v8.4.0
         */
        writeHead(statusCode: number, headers?: OutgoingHttpHeaders): this;
        writeHead(statusCode: number, statusMessage: string, headers?: OutgoingHttpHeaders): this;
        /**
         * Call `http2stream.pushStream()` with the given headers, and wrap the
         * given `Http2Stream` on a newly created `Http2ServerResponse` as the callback
         * parameter if successful. When `Http2ServerRequest` is closed, the callback is
         * called with an error `ERR_HTTP2_INVALID_STREAM`.
         * @since v8.4.0
         * @param headers An object describing the headers
         * @param callback Called once `http2stream.pushStream()` is finished, or either when the attempt to create the pushed `Http2Stream` has failed or has been rejected, or the state of
         * `Http2ServerRequest` is closed prior to calling the `http2stream.pushStream()` method
         */
        createPushResponse(
            headers: OutgoingHttpHeaders,
            callback: (err: Error | null, res: Http2ServerResponse) => void,
        ): void;
        addListener(event: "close", listener: () => void): this;
        addListener(event: "drain", listener: () => void): this;
        addListener(event: "error", listener: (error: Error) => void): this;
        addListener(event: "finish", listener: () => void): this;
        addListener(event: "pipe", listener: (src: stream.Readable) => void): this;
        addListener(event: "unpipe", listener: (src: stream.Readable) => void): this;
        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
        emit(event: "close"): boolean;
        emit(event: "drain"): boolean;
        emit(event: "error", error: Error): boolean;
        emit(event: "finish"): boolean;
        emit(event: "pipe", src: stream.Readable): boolean;
        emit(event: "unpipe", src: stream.Readable): boolean;
        emit(event: string | symbol, ...args: any[]): boolean;
        on(event: "close", listener: () => void): this;
        on(event: "drain", listener: () => void): this;
        on(event: "error", listener: (error: Error) => void): this;
        on(event: "finish", listener: () => void): this;
        on(event: "pipe", listener: (src: stream.Readable) => void): this;
        on(event: "unpipe", listener: (src: stream.Readable) => void): this;
        on(event: string | symbol, listener: (...args: any[]) => void): this;
        once(event: "close", listener: () => void): this;
        once(event: "drain", listener: () => void): this;
        once(event: "error", listener: (error: Error) => void): this;
        once(event: "finish", listener: () => void): this;
        once(event: "pipe", listener: (src: stream.Readable) => void): this;
        once(event: "unpipe", listener: (src: stream.Readable) => void): this;
        once(event: string | symbol, listener: (...args: any[]) => void): this;
        prependListener(event: "close", listener: () => void): this;
        prependListener(event: "drain", listener: () => void): this;
        prependListener(event: "error", listener: (error: Error) => void): this;
        prependListener(event: "finish", listener: () => void): this;
        prependListener(event: "pipe", listener: (src: stream.Readable) => void): this;
        prependListener(event: "unpipe", listener: (src: stream.Readable) => void): this;
        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
        prependOnceListener(event: "close", listener: () => void): this;
        prependOnceListener(event: "drain", listener: () => void): this;
        prependOnceListener(event: "error", listener: (error: Error) => void): this;
        prependOnceListener(event: "finish", listener: () => void): this;
        prependOnceListener(event: "pipe", listener: (src: stream.Readable) => void): this;
        prependOnceListener(event: "unpipe", listener: (src: stream.Readable) => void): this;
        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
    }
    export namespace constants {
        const NGHTTP2_SESSION_SERVER: number;
        const NGHTTP2_SESSION_CLIENT: number;
        const NGHTTP2_STREAM_STATE_IDLE: number;
        const NGHTTP2_STREAM_STATE_OPEN: number;
        const NGHTTP2_STREAM_STATE_RESERVED_LOCAL: number;
        const NGHTTP2_STREAM_STATE_RESERVED_REMOTE: number;
        const NGHTTP2_STREAM_STATE_HALF_CLOSED_LOCAL: number;
        const NGHTTP2_STREAM_STATE_HALF_CLOSED_REMOTE: number;
        const NGHTTP2_STREAM_STATE_CLOSED: number;
        const NGHTTP2_NO_ERROR: number;
        const NGHTTP2_PROTOCOL_ERROR: number;
        const NGHTTP2_INTERNAL_ERROR: number;
        const NGHTTP2_FLOW_CONTROL_ERROR: number;
        const NGHTTP2_SETTINGS_TIMEOUT: number;
        const NGHTTP2_STREAM_CLOSED: number;
        const NGHTTP2_FRAME_SIZE_ERROR: number;
        const NGHTTP2_REFUSED_STREAM: number;
        const NGHTTP2_CANCEL: number;
        const NGHTTP2_COMPRESSION_ERROR: number;
        const NGHTTP2_CONNECT_ERROR: number;
        const NGHTTP2_ENHANCE_YOUR_CALM: number;
        const NGHTTP2_INADEQUATE_SECURITY: number;
        const NGHTTP2_HTTP_1_1_REQUIRED: number;
        const NGHTTP2_ERR_FRAME_SIZE_ERROR: number;
        const NGHTTP2_FLAG_NONE: number;
        const NGHTTP2_FLAG_END_STREAM: number;
        const NGHTTP2_FLAG_END_HEADERS: number;
        const NGHTTP2_FLAG_ACK: number;
        const NGHTTP2_FLAG_PADDED: number;
        const NGHTTP2_FLAG_PRIORITY: number;
        const DEFAULT_SETTINGS_HEADER_TABLE_SIZE: number;
        const DEFAULT_SETTINGS_ENABLE_PUSH: number;
        const DEFAULT_SETTINGS_INITIAL_WINDOW_SIZE: number;
        const DEFAULT_SETTINGS_MAX_FRAME_SIZE: number;
        const MAX_MAX_FRAME_SIZE: number;
        const MIN_MAX_FRAME_SIZE: number;
        const MAX_INITIAL_WINDOW_SIZE: number;
        const NGHTTP2_DEFAULT_WEIGHT: number;
        const NGHTTP2_SETTINGS_HEADER_TABLE_SIZE: number;
        const NGHTTP2_SETTINGS_ENABLE_PUSH: number;
        const NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS: number;
        const NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE: number;
        const NGHTTP2_SETTINGS_MAX_FRAME_SIZE: number;
        const NGHTTP2_SETTINGS_MAX_HEADER_LIST_SIZE: number;
        const PADDING_STRATEGY_NONE: number;
        const PADDING_STRATEGY_MAX: number;
        const PADDING_STRATEGY_CALLBACK: number;
        const HTTP2_HEADER_STATUS: string;
        const HTTP2_HEADER_METHOD: string;
        const HTTP2_HEADER_AUTHORITY: string;
        const HTTP2_HEADER_SCHEME: string;
        const HTTP2_HEADER_PATH: string;
        const HTTP2_HEADER_ACCEPT_CHARSET: string;
        const HTTP2_HEADER_ACCEPT_ENCODING: string;
        const HTTP2_HEADER_ACCEPT_LANGUAGE: string;
        const HTTP2_HEADER_ACCEPT_RANGES: string;
        const HTTP2_HEADER_ACCEPT: string;
        const HTTP2_HEADER_ACCESS_CONTROL_ALLOW_CREDENTIALS: string;
        const HTTP2_HEADER_ACCESS_CONTROL_ALLOW_HEADERS: string;
        const HTTP2_HEADER_ACCESS_CONTROL_ALLOW_METHODS: string;
        const HTTP2_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN: string;
        const HTTP2_HEADER_ACCESS_CONTROL_EXPOSE_HEADERS: string;
        const HTTP2_HEADER_ACCESS_CONTROL_REQUEST_HEADERS: string;
        const HTTP2_HEADER_ACCESS_CONTROL_REQUEST_METHOD: string;
        const HTTP2_HEADER_AGE: string;
        const HTTP2_HEADER_ALLOW: string;
        const HTTP2_HEADER_AUTHORIZATION: string;
        const HTTP2_HEADER_CACHE_CONTROL: string;
        const HTTP2_HEADER_CONNECTION: string;
        const HTTP2_HEADER_CONTENT_DISPOSITION: string;
        const HTTP2_HEADER_CONTENT_ENCODING: string;
        const HTTP2_HEADER_CONTENT_LANGUAGE: string;
        const HTTP2_HEADER_CONTENT_LENGTH: string;
        const HTTP2_HEADER_CONTENT_LOCATION: string;
        const HTTP2_HEADER_CONTENT_MD5: string;
        const HTTP2_HEADER_CONTENT_RANGE: string;
        const HTTP2_HEADER_CONTENT_TYPE: string;
        const HTTP2_HEADER_COOKIE: string;
        const HTTP2_HEADER_DATE: string;
        const HTTP2_HEADER_ETAG: string;
        const HTTP2_HEADER_EXPECT: string;
        const HTTP2_HEADER_EXPIRES: string;
        const HTTP2_HEADER_FROM: string;
        const HTTP2_HEADER_HOST: string;
        const HTTP2_HEADER_IF_MATCH: string;
        const HTTP2_HEADER_IF_MODIFIED_SINCE: string;
        const HTTP2_HEADER_IF_NONE_MATCH: string;
        const HTTP2_HEADER_IF_RANGE: string;
        const HTTP2_HEADER_IF_UNMODIFIED_SINCE: string;
        const HTTP2_HEADER_LAST_MODIFIED: string;
        const HTTP2_HEADER_LINK: string;
        const HTTP2_HEADER_LOCATION: string;
        const HTTP2_HEADER_MAX_FORWARDS: string;
        const HTTP2_HEADER_PREFER: string;
        const HTTP2_HEADER_PROXY_AUTHENTICATE: string;
        const HTTP2_HEADER_PROXY_AUTHORIZATION: string;
        const HTTP2_HEADER_RANGE: string;
        const HTTP2_HEADER_REFERER: string;
        const HTTP2_HEADER_REFRESH: string;
        const HTTP2_HEADER_RETRY_AFTER: string;
        const HTTP2_HEADER_SERVER: string;
        const HTTP2_HEADER_SET_COOKIE: string;
        const HTTP2_HEADER_STRICT_TRANSPORT_SECURITY: string;
        const HTTP2_HEADER_TRANSFER_ENCODING: string;
        const HTTP2_HEADER_TE: string;
        const HTTP2_HEADER_UPGRADE: string;
        const HTTP2_HEADER_USER_AGENT: string;
        const HTTP2_HEADER_VARY: string;
        const HTTP2_HEADER_VIA: string;
        const HTTP2_HEADER_WWW_AUTHENTICATE: string;
        const HTTP2_HEADER_HTTP2_SETTINGS: string;
        const HTTP2_HEADER_KEEP_ALIVE: string;
        const HTTP2_HEADER_PROXY_CONNECTION: string;
        const HTTP2_METHOD_ACL: string;
        const HTTP2_METHOD_BASELINE_CONTROL: string;
        const HTTP2_METHOD_BIND: string;
        const HTTP2_METHOD_CHECKIN: string;
        const HTTP2_METHOD_CHECKOUT: string;
        const HTTP2_METHOD_CONNECT: string;
        const HTTP2_METHOD_COPY: string;
        const HTTP2_METHOD_DELETE: string;
        const HTTP2_METHOD_GET: string;
        const HTTP2_METHOD_HEAD: string;
        const HTTP2_METHOD_LABEL: string;
        const HTTP2_METHOD_LINK: string;
        const HTTP2_METHOD_LOCK: string;
        const HTTP2_METHOD_MERGE: string;
        const HTTP2_METHOD_MKACTIVITY: string;
        const HTTP2_METHOD_MKCALENDAR: string;
        const HTTP2_METHOD_MKCOL: string;
        const HTTP2_METHOD_MKREDIRECTREF: string;
        const HTTP2_METHOD_MKWORKSPACE: string;
        const HTTP2_METHOD_MOVE: string;
        const HTTP2_METHOD_OPTIONS: string;
        const HTTP2_METHOD_ORDERPATCH: string;
        const HTTP2_METHOD_PATCH: string;
        const HTTP2_METHOD_POST: string;
        const HTTP2_METHOD_PRI: string;
        const HTTP2_METHOD_PROPFIND: string;
        const HTTP2_METHOD_PROPPATCH: string;
        const HTTP2_METHOD_PUT: string;
        const HTTP2_METHOD_REBIND: string;
        const HTTP2_METHOD_REPORT: string;
        const HTTP2_METHOD_SEARCH: string;
        const HTTP2_METHOD_TRACE: string;
        const HTTP2_METHOD_UNBIND: string;
        const HTTP2_METHOD_UNCHECKOUT: string;
        const HTTP2_METHOD_UNLINK: string;
        const HTTP2_METHOD_UNLOCK: string;
        const HTTP2_METHOD_UPDATE: string;
        const HTTP2_METHOD_UPDATEREDIRECTREF: string;
        const HTTP2_METHOD_VERSION_CONTROL: string;
        const HTTP_STATUS_CONTINUE: number;
        const HTTP_STATUS_SWITCHING_PROTOCOLS: number;
        const HTTP_STATUS_PROCESSING: number;
        const HTTP_STATUS_OK: number;
        const HTTP_STATUS_CREATED: number;
        const HTTP_STATUS_ACCEPTED: number;
        const HTTP_STATUS_NON_AUTHORITATIVE_INFORMATION: number;
        const HTTP_STATUS_NO_CONTENT: number;
        const HTTP_STATUS_RESET_CONTENT: number;
        const HTTP_STATUS_PARTIAL_CONTENT: number;
        const HTTP_STATUS_MULTI_STATUS: number;
        const HTTP_STATUS_ALREADY_REPORTED: number;
        const HTTP_STATUS_IM_USED: number;
        const HTTP_STATUS_MULTIPLE_CHOICES: number;
        const HTTP_STATUS_MOVED_PERMANENTLY: number;
        const HTTP_STATUS_FOUND: number;
        const HTTP_STATUS_SEE_OTHER: number;
        const HTTP_STATUS_NOT_MODIFIED: number;
        const HTTP_STATUS_USE_PROXY: number;
        const HTTP_STATUS_TEMPORARY_REDIRECT: number;
        const HTTP_STATUS_PERMANENT_REDIRECT: number;
        const HTTP_STATUS_BAD_REQUEST: number;
        const HTTP_STATUS_UNAUTHORIZED: number;
        const HTTP_STATUS_PAYMENT_REQUIRED: number;
        const HTTP_STATUS_FORBIDDEN: number;
        const HTTP_STATUS_NOT_FOUND: number;
        const HTTP_STATUS_METHOD_NOT_ALLOWED: number;
        const HTTP_STATUS_NOT_ACCEPTABLE: number;
        const HTTP_STATUS_PROXY_AUTHENTICATION_REQUIRED: number;
        const HTTP_STATUS_REQUEST_TIMEOUT: number;
        const HTTP_STATUS_CONFLICT: number;
        const HTTP_STATUS_GONE: number;
        const HTTP_STATUS_LENGTH_REQUIRED: number;
        const HTTP_STATUS_PRECONDITION_FAILED: number;
        const HTTP_STATUS_PAYLOAD_TOO_LARGE: number;
        const HTTP_STATUS_URI_TOO_LONG: number;
        const HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE: number;
        const HTTP_STATUS_RANGE_NOT_SATISFIABLE: number;
        const HTTP_STATUS_EXPECTATION_FAILED: number;
        const HTTP_STATUS_TEAPOT: number;
        const HTTP_STATUS_MISDIRECTED_REQUEST: number;
        const HTTP_STATUS_UNPROCESSABLE_ENTITY: number;
        const HTTP_STATUS_LOCKED: number;
        const HTTP_STATUS_FAILED_DEPENDENCY: number;
        const HTTP_STATUS_UNORDERED_COLLECTION: number;
        const HTTP_STATUS_UPGRADE_REQUIRED: number;
        const HTTP_STATUS_PRECONDITION_REQUIRED: number;
        const HTTP_STATUS_TOO_MANY_REQUESTS: number;
        const HTTP_STATUS_REQUEST_HEADER_FIELDS_TOO_LARGE: number;
        const HTTP_STATUS_UNAVAILABLE_FOR_LEGAL_REASONS: number;
        const HTTP_STATUS_INTERNAL_SERVER_ERROR: number;
        const HTTP_STATUS_NOT_IMPLEMENTED: number;
        const HTTP_STATUS_BAD_GATEWAY: number;
        const HTTP_STATUS_SERVICE_UNAVAILABLE: number;
        const HTTP_STATUS_GATEWAY_TIMEOUT: number;
        const HTTP_STATUS_HTTP_VERSION_NOT_SUPPORTED: number;
        const HTTP_STATUS_VARIANT_ALSO_NEGOTIATES: number;
        const HTTP_STATUS_INSUFFICIENT_STORAGE: number;
        const HTTP_STATUS_LOOP_DETECTED: number;
        const HTTP_STATUS_BANDWIDTH_LIMIT_EXCEEDED: number;
        const HTTP_STATUS_NOT_EXTENDED: number;
        const HTTP_STATUS_NETWORK_AUTHENTICATION_REQUIRED: number;
    }
    /**
     * This symbol can be set as a property on the HTTP/2 headers object with
     * an array value in order to provide a list of headers considered sensitive.
     */
    export const sensitiveHeaders: symbol;
    /**
     * Returns an object containing the default settings for an `Http2Session` instance. This method returns a new object instance every time it is called
     * so instances returned may be safely modified for use.
     * @since v8.4.0
     */
    export function getDefaultSettings(): Settings;
    /**
     * Returns a `Buffer` instance containing serialized representation of the given
     * HTTP/2 settings as specified in the [HTTP/2](https://tools.ietf.org/html/rfc7540) specification. This is intended
     * for use with the `HTTP2-Settings` header field.
     *
     * ```js
     * import http2 from 'node:http2';
     *
     * const packed = http2.getPackedSettings({ enablePush: false });
     *
     * console.log(packed.toString('base64'));
     * // Prints: AAIAAAAA
     * ```
     * @since v8.4.0
     */
    export function getPackedSettings(settings: Settings): Buffer;
    /**
     * Returns a `HTTP/2 Settings Object` containing the deserialized settings from
     * the given `Buffer` as generated by `http2.getPackedSettings()`.
     * @since v8.4.0
     * @param buf The packed settings.
     */
    export function getUnpackedSettings(buf: Uint8Array): Settings;
    /**
     * Returns a `net.Server` instance that creates and manages `Http2Session` instances.
     *
     * Since there are no browsers known that support [unencrypted HTTP/2](https://http2.github.io/faq/#does-http2-require-encryption), the use of {@link createSecureServer} is necessary when
     * communicating
     * with browser clients.
     *
     * ```js
     * import http2 from 'node:http2';
     *
     * // Create an unencrypted HTTP/2 server.
     * // Since there are no browsers known that support
     * // unencrypted HTTP/2, the use of `http2.createSecureServer()`
     * // is necessary when communicating with browser clients.
     * const server = http2.createServer();
     *
     * server.on('stream', (stream, headers) => {
     *   stream.respond({
     *     'content-type': 'text/html; charset=utf-8',
     *     ':status': 200,
     *   });
     *   stream.end('<h1>Hello World</h1>');
     * });
     *
     * server.listen(8000);
     * ```
     * @since v8.4.0
     * @param onRequestHandler See `Compatibility API`
     */
    export function createServer(
        onRequestHandler?: (request: Http2ServerRequest, response: Http2ServerResponse) => void,
    ): Http2Server;
    export function createServer<
        Http1Request extends typeof IncomingMessage = typeof IncomingMessage,
        Http1Response extends typeof ServerResponse<InstanceType<Http1Request>> = typeof ServerResponse,
        Http2Request extends typeof Http2ServerRequest = typeof Http2ServerRequest,
        Http2Response extends typeof Http2ServerResponse<InstanceType<Http2Request>> = typeof Http2ServerResponse,
    >(
        options: ServerOptions<Http1Request, Http1Response, Http2Request, Http2Response>,
        onRequestHandler?: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
    ): Http2Server<Http1Request, Http1Response, Http2Request, Http2Response>;
    /**
     * Returns a `tls.Server` instance that creates and manages `Http2Session` instances.
     *
     * ```js
     * import http2 from 'node:http2';
     * import fs from 'node:fs';
     *
     * const options = {
     *   key: fs.readFileSync('server-key.pem'),
     *   cert: fs.readFileSync('server-cert.pem'),
     * };
     *
     * // Create a secure HTTP/2 server
     * const server = http2.createSecureServer(options);
     *
     * server.on('stream', (stream, headers) => {
     *   stream.respond({
     *     'content-type': 'text/html; charset=utf-8',
     *     ':status': 200,
     *   });
     *   stream.end('<h1>Hello World</h1>');
     * });
     *
     * server.listen(8443);
     * ```
     * @since v8.4.0
     * @param onRequestHandler See `Compatibility API`
     */
    export function createSecureServer(
        onRequestHandler?: (request: Http2ServerRequest, response: Http2ServerResponse) => void,
    ): Http2SecureServer;
    export function createSecureServer<
        Http1Request extends typeof IncomingMessage = typeof IncomingMessage,
        Http1Response extends typeof ServerResponse<InstanceType<Http1Request>> = typeof ServerResponse,
        Http2Request extends typeof Http2ServerRequest = typeof Http2ServerRequest,
        Http2Response extends typeof Http2ServerResponse<InstanceType<Http2Request>> = typeof Http2ServerResponse,
    >(
        options: SecureServerOptions<Http1Request, Http1Response, Http2Request, Http2Response>,
        onRequestHandler?: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
    ): Http2SecureServer<Http1Request, Http1Response, Http2Request, Http2Response>;
    /**
     * Returns a `ClientHttp2Session` instance.
     *
     * ```js
     * import http2 from 'node:http2';
     * const client = http2.connect('https://localhost:1234');
     *
     * // Use the client
     *
     * client.close();
     * ```
     * @since v8.4.0
     * @param authority The remote HTTP/2 server to connect to. This must be in the form of a minimal, valid URL with the `http://` or `https://` prefix, host name, and IP port (if a non-default port
     * is used). Userinfo (user ID and password), path, querystring, and fragment details in the URL will be ignored.
     * @param listener Will be registered as a one-time listener of the {@link 'connect'} event.
     */
    export function connect(
        authority: string | url.URL,
        listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void,
    ): ClientHttp2Session;
    export function connect(
        authority: string | url.URL,
        options?: ClientSessionOptions | SecureClientSessionOptions,
        listener?: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void,
    ): ClientHttp2Session;
    /**
     * Create an HTTP/2 server session from an existing socket.
     * @param socket A Duplex Stream
     * @param options Any `{@link createServer}` options can be provided.
     * @since v20.12.0
     */
    export function performServerHandshake<
        Http1Request extends typeof IncomingMessage = typeof IncomingMessage,
        Http1Response extends typeof ServerResponse<InstanceType<Http1Request>> = typeof ServerResponse,
        Http2Request extends typeof Http2ServerRequest = typeof Http2ServerRequest,
        Http2Response extends typeof Http2ServerResponse<InstanceType<Http2Request>> = typeof Http2ServerResponse,
    >(
        socket: stream.Duplex,
        options?: ServerOptions<Http1Request, Http1Response, Http2Request, Http2Response>,
    ): ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>;
}
declare module "node:http2" {
    export * from "http2";
}

```

## ./lib/lambda/node_modules/@types/node/https.d.ts

```typescript
/**
 * HTTPS is the HTTP protocol over TLS/SSL. In Node.js this is implemented as a
 * separate module.
 * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/https.js)
 */
declare module "https" {
    import { Duplex } from "node:stream";
    import * as tls from "node:tls";
    import * as http from "node:http";
    import { URL } from "node:url";
    interface ServerOptions<
        Request extends typeof http.IncomingMessage = typeof http.IncomingMessage,
        Response extends typeof http.ServerResponse<InstanceType<Request>> = typeof http.ServerResponse,
    > extends http.ServerOptions<Request, Response>, tls.TlsOptions {}
    interface RequestOptions extends http.RequestOptions, tls.SecureContextOptions {
        checkServerIdentity?:
            | ((hostname: string, cert: tls.DetailedPeerCertificate) => Error | undefined)
            | undefined;
        rejectUnauthorized?: boolean | undefined; // Defaults to true
        servername?: string | undefined; // SNI TLS Extension
    }
    interface AgentOptions extends http.AgentOptions, tls.ConnectionOptions {
        maxCachedSessions?: number | undefined;
    }
    /**
     * An `Agent` object for HTTPS similar to `http.Agent`. See {@link request} for more information.
     * @since v0.4.5
     */
    class Agent extends http.Agent {
        constructor(options?: AgentOptions);
        options: AgentOptions;
        createConnection(
            options: RequestOptions,
            callback?: (err: Error | null, stream: Duplex) => void,
        ): Duplex | null | undefined;
        getName(options?: RequestOptions): string;
    }
    interface Server<
        Request extends typeof http.IncomingMessage = typeof http.IncomingMessage,
        Response extends typeof http.ServerResponse<InstanceType<Request>> = typeof http.ServerResponse,
    > extends http.Server<Request, Response> {}
    /**
     * See `http.Server` for more information.
     * @since v0.3.4
     */
    class Server<
        Request extends typeof http.IncomingMessage = typeof http.IncomingMessage,
        Response extends typeof http.ServerResponse<InstanceType<Request>> = typeof http.ServerResponse,
    > extends tls.Server {
        constructor(requestListener?: http.RequestListener<Request, Response>);
        constructor(
            options: ServerOptions<Request, Response>,
            requestListener?: http.RequestListener<Request, Response>,
        );
        /**
         * Closes all connections connected to this server.
         * @since v18.2.0
         */
        closeAllConnections(): void;
        /**
         * Closes all connections connected to this server which are not sending a request or waiting for a response.
         * @since v18.2.0
         */
        closeIdleConnections(): void;
        addListener(event: string, listener: (...args: any[]) => void): this;
        addListener(event: "keylog", listener: (line: Buffer, tlsSocket: tls.TLSSocket) => void): this;
        addListener(
            event: "newSession",
            listener: (sessionId: Buffer, sessionData: Buffer, callback: (err: Error, resp: Buffer) => void) => void,
        ): this;
        addListener(
            event: "OCSPRequest",
            listener: (
                certificate: Buffer,
                issuer: Buffer,
                callback: (err: Error | null, resp: Buffer) => void,
            ) => void,
        ): this;
        addListener(
            event: "resumeSession",
            listener: (sessionId: Buffer, callback: (err: Error, sessionData: Buffer) => void) => void,
        ): this;
        addListener(event: "secureConnection", listener: (tlsSocket: tls.TLSSocket) => void): this;
        addListener(event: "tlsClientError", listener: (err: Error, tlsSocket: tls.TLSSocket) => void): this;
        addListener(event: "close", listener: () => void): this;
        addListener(event: "connection", listener: (socket: Duplex) => void): this;
        addListener(event: "error", listener: (err: Error) => void): this;
        addListener(event: "listening", listener: () => void): this;
        addListener(event: "checkContinue", listener: http.RequestListener<Request, Response>): this;
        addListener(event: "checkExpectation", listener: http.RequestListener<Request, Response>): this;
        addListener(event: "clientError", listener: (err: Error, socket: Duplex) => void): this;
        addListener(
            event: "connect",
            listener: (req: InstanceType<Request>, socket: Duplex, head: Buffer) => void,
        ): this;
        addListener(event: "request", listener: http.RequestListener<Request, Response>): this;
        addListener(
            event: "upgrade",
            listener: (req: InstanceType<Request>, socket: Duplex, head: Buffer) => void,
        ): this;
        emit(event: string, ...args: any[]): boolean;
        emit(event: "keylog", line: Buffer, tlsSocket: tls.TLSSocket): boolean;
        emit(
            event: "newSession",
            sessionId: Buffer,
            sessionData: Buffer,
            callback: (err: Error, resp: Buffer) => void,
        ): boolean;
        emit(
            event: "OCSPRequest",
            certificate: Buffer,
            issuer: Buffer,
            callback: (err: Error | null, resp: Buffer) => void,
        ): boolean;
        emit(event: "resumeSession", sessionId: Buffer, callback: (err: Error, sessionData: Buffer) => void): boolean;
        emit(event: "secureConnection", tlsSocket: tls.TLSSocket): boolean;
        emit(event: "tlsClientError", err: Error, tlsSocket: tls.TLSSocket): boolean;
        emit(event: "close"): boolean;
        emit(event: "connection", socket: Duplex): boolean;
        emit(event: "error", err: Error): boolean;
        emit(event: "listening"): boolean;
        emit(
            event: "checkContinue",
            req: InstanceType<Request>,
            res: InstanceType<Response>,
        ): boolean;
        emit(
            event: "checkExpectation",
            req: InstanceType<Request>,
            res: InstanceType<Response>,
        ): boolean;
        emit(event: "clientError", err: Error, socket: Duplex): boolean;
        emit(event: "connect", req: InstanceType<Request>, socket: Duplex, head: Buffer): boolean;
        emit(
            event: "request",
            req: InstanceType<Request>,
            res: InstanceType<Response>,
        ): boolean;
        emit(event: "upgrade", req: InstanceType<Request>, socket: Duplex, head: Buffer): boolean;
        on(event: string, listener: (...args: any[]) => void): this;
        on(event: "keylog", listener: (line: Buffer, tlsSocket: tls.TLSSocket) => void): this;
        on(
            event: "newSession",
            listener: (sessionId: Buffer, sessionData: Buffer, callback: (err: Error, resp: Buffer) => void) => void,
        ): this;
        on(
            event: "OCSPRequest",
            listener: (
                certificate: Buffer,
                issuer: Buffer,
                callback: (err: Error | null, resp: Buffer) => void,
            ) => void,
        ): this;
        on(
            event: "resumeSession",
            listener: (sessionId: Buffer, callback: (err: Error, sessionData: Buffer) => void) => void,
        ): this;
        on(event: "secureConnection", listener: (tlsSocket: tls.TLSSocket) => void): this;
        on(event: "tlsClientError", listener: (err: Error, tlsSocket: tls.TLSSocket) => void): this;
        on(event: "close", listener: () => void): this;
        on(event: "connection", listener: (socket: Duplex) => void): this;
        on(event: "error", listener: (err: Error) => void): this;
        on(event: "listening", listener: () => void): this;
        on(event: "checkContinue", listener: http.RequestListener<Request, Response>): this;
        on(event: "checkExpectation", listener: http.RequestListener<Request, Response>): this;
        on(event: "clientError", listener: (err: Error, socket: Duplex) => void): this;
        on(event: "connect", listener: (req: InstanceType<Request>, socket: Duplex, head: Buffer) => void): this;
        on(event: "request", listener: http.RequestListener<Request, Response>): this;
        on(event: "upgrade", listener: (req: InstanceType<Request>, socket: Duplex, head: Buffer) => void): this;
        once(event: string, listener: (...args: any[]) => void): this;
        once(event: "keylog", listener: (line: Buffer, tlsSocket: tls.TLSSocket) => void): this;
        once(
            event: "newSession",
            listener: (sessionId: Buffer, sessionData: Buffer, callback: (err: Error, resp: Buffer) => void) => void,
        ): this;
        once(
            event: "OCSPRequest",
            listener: (
                certificate: Buffer,
                issuer: Buffer,
                callback: (err: Error | null, resp: Buffer) => void,
            ) => void,
        ): this;
        once(
            event: "resumeSession",
            listener: (sessionId: Buffer, callback: (err: Error, sessionData: Buffer) => void) => void,
        ): this;
        once(event: "secureConnection", listener: (tlsSocket: tls.TLSSocket) => void): this;
        once(event: "tlsClientError", listener: (err: Error, tlsSocket: tls.TLSSocket) => void): this;
        once(event: "close", listener: () => void): this;
        once(event: "connection", listener: (socket: Duplex) => void): this;
        once(event: "error", listener: (err: Error) => void): this;
        once(event: "listening", listener: () => void): this;
        once(event: "checkContinue", listener: http.RequestListener<Request, Response>): this;
        once(event: "checkExpectation", listener: http.RequestListener<Request, Response>): this;
        once(event: "clientError", listener: (err: Error, socket: Duplex) => void): this;
        once(event: "connect", listener: (req: InstanceType<Request>, socket: Duplex, head: Buffer) => void): this;
        once(event: "request", listener: http.RequestListener<Request, Response>): this;
        once(event: "upgrade", listener: (req: InstanceType<Request>, socket: Duplex, head: Buffer) => void): this;
        prependListener(event: string, listener: (...args: any[]) => void): this;
        prependListener(event: "keylog", listener: (line: Buffer, tlsSocket: tls.TLSSocket) => void): this;
        prependListener(
            event: "newSession",
            listener: (sessionId: Buffer, sessionData: Buffer, callback: (err: Error, resp: Buffer) => void) => void,
        ): this;
        prependListener(
            event: "OCSPRequest",
            listener: (
                certificate: Buffer,
                issuer: Buffer,
                callback: (err: Error | null, resp: Buffer) => void,
            ) => void,
        ): this;
        prependListener(
            event: "resumeSession",
            listener: (sessionId: Buffer, callback: (err: Error, sessionData: Buffer) => void) => void,
        ): this;
        prependListener(event: "secureConnection", listener: (tlsSocket: tls.TLSSocket) => void): this;
        prependListener(event: "tlsClientError", listener: (err: Error, tlsSocket: tls.TLSSocket) => void): this;
        prependListener(event: "close", listener: () => void): this;
        prependListener(event: "connection", listener: (socket: Duplex) => void): this;
        prependListener(event: "error", listener: (err: Error) => void): this;
        prependListener(event: "listening", listener: () => void): this;
        prependListener(event: "checkContinue", listener: http.RequestListener<Request, Response>): this;
        prependListener(event: "checkExpectation", listener: http.RequestListener<Request, Response>): this;
        prependListener(event: "clientError", listener: (err: Error, socket: Duplex) => void): this;
        prependListener(
            event: "connect",
            listener: (req: InstanceType<Request>, socket: Duplex, head: Buffer) => void,
        ): this;
        prependListener(event: "request", listener: http.RequestListener<Request, Response>): this;
        prependListener(
            event: "upgrade",
            listener: (req: InstanceType<Request>, socket: Duplex, head: Buffer) => void,
        ): this;
        prependOnceListener(event: string, listener: (...args: any[]) => void): this;
        prependOnceListener(event: "keylog", listener: (line: Buffer, tlsSocket: tls.TLSSocket) => void): this;
        prependOnceListener(
            event: "newSession",
            listener: (sessionId: Buffer, sessionData: Buffer, callback: (err: Error, resp: Buffer) => void) => void,
        ): this;
        prependOnceListener(
            event: "OCSPRequest",
            listener: (
                certificate: Buffer,
                issuer: Buffer,
                callback: (err: Error | null, resp: Buffer) => void,
            ) => void,
        ): this;
        prependOnceListener(
            event: "resumeSession",
            listener: (sessionId: Buffer, callback: (err: Error, sessionData: Buffer) => void) => void,
        ): this;
        prependOnceListener(event: "secureConnection", listener: (tlsSocket: tls.TLSSocket) => void): this;
        prependOnceListener(event: "tlsClientError", listener: (err: Error, tlsSocket: tls.TLSSocket) => void): this;
        prependOnceListener(event: "close", listener: () => void): this;
        prependOnceListener(event: "connection", listener: (socket: Duplex) => void): this;
        prependOnceListener(event: "error", listener: (err: Error) => void): this;
        prependOnceListener(event: "listening", listener: () => void): this;
        prependOnceListener(event: "checkContinue", listener: http.RequestListener<Request, Response>): this;
        prependOnceListener(event: "checkExpectation", listener: http.RequestListener<Request, Response>): this;
        prependOnceListener(event: "clientError", listener: (err: Error, socket: Duplex) => void): this;
        prependOnceListener(
            event: "connect",
            listener: (req: InstanceType<Request>, socket: Duplex, head: Buffer) => void,
        ): this;
        prependOnceListener(event: "request", listener: http.RequestListener<Request, Response>): this;
        prependOnceListener(
            event: "upgrade",
            listener: (req: InstanceType<Request>, socket: Duplex, head: Buffer) => void,
        ): this;
    }
    /**
     * ```js
     * // curl -k https://localhost:8000/
     * import https from 'node:https';
     * import fs from 'node:fs';
     *
     * const options = {
     *   key: fs.readFileSync('test/fixtures/keys/agent2-key.pem'),
     *   cert: fs.readFileSync('test/fixtures/keys/agent2-cert.pem'),
     * };
     *
     * https.createServer(options, (req, res) => {
     *   res.writeHead(200);
     *   res.end('hello world\n');
     * }).listen(8000);
     * ```
     *
     * Or
     *
     * ```js
     * import https from 'node:https';
     * import fs from 'node:fs';
     *
     * const options = {
     *   pfx: fs.readFileSync('test/fixtures/test_cert.pfx'),
     *   passphrase: 'sample',
     * };
     *
     * https.createServer(options, (req, res) => {
     *   res.writeHead(200);
     *   res.end('hello world\n');
     * }).listen(8000);
     * ```
     * @since v0.3.4
     * @param options Accepts `options` from `createServer`, `createSecureContext` and `createServer`.
     * @param requestListener A listener to be added to the `'request'` event.
     */
    function createServer<
        Request extends typeof http.IncomingMessage = typeof http.IncomingMessage,
        Response extends typeof http.ServerResponse<InstanceType<Request>> = typeof http.ServerResponse,
    >(requestListener?: http.RequestListener<Request, Response>): Server<Request, Response>;
    function createServer<
        Request extends typeof http.IncomingMessage = typeof http.IncomingMessage,
        Response extends typeof http.ServerResponse<InstanceType<Request>> = typeof http.ServerResponse,
    >(
        options: ServerOptions<Request, Response>,
        requestListener?: http.RequestListener<Request, Response>,
    ): Server<Request, Response>;
    /**
     * Makes a request to a secure web server.
     *
     * The following additional `options` from `tls.connect()` are also accepted: `ca`, `cert`, `ciphers`, `clientCertEngine`, `crl`, `dhparam`, `ecdhCurve`, `honorCipherOrder`, `key`, `passphrase`,
     * `pfx`, `rejectUnauthorized`, `secureOptions`, `secureProtocol`, `servername`, `sessionIdContext`, `highWaterMark`.
     *
     * `options` can be an object, a string, or a `URL` object. If `options` is a
     * string, it is automatically parsed with `new URL()`. If it is a `URL` object, it will be automatically converted to an ordinary `options` object.
     *
     * `https.request()` returns an instance of the `http.ClientRequest` class. The `ClientRequest` instance is a writable stream. If one needs to
     * upload a file with a POST request, then write to the `ClientRequest` object.
     *
     * ```js
     * import https from 'node:https';
     *
     * const options = {
     *   hostname: 'encrypted.google.com',
     *   port: 443,
     *   path: '/',
     *   method: 'GET',
     * };
     *
     * const req = https.request(options, (res) => {
     *   console.log('statusCode:', res.statusCode);
     *   console.log('headers:', res.headers);
     *
     *   res.on('data', (d) => {
     *     process.stdout.write(d);
     *   });
     * });
     *
     * req.on('error', (e) => {
     *   console.error(e);
     * });
     * req.end();
     * ```
     *
     * Example using options from `tls.connect()`:
     *
     * ```js
     * const options = {
     *   hostname: 'encrypted.google.com',
     *   port: 443,
     *   path: '/',
     *   method: 'GET',
     *   key: fs.readFileSync('test/fixtures/keys/agent2-key.pem'),
     *   cert: fs.readFileSync('test/fixtures/keys/agent2-cert.pem'),
     * };
     * options.agent = new https.Agent(options);
     *
     * const req = https.request(options, (res) => {
     *   // ...
     * });
     * ```
     *
     * Alternatively, opt out of connection pooling by not using an `Agent`.
     *
     * ```js
     * const options = {
     *   hostname: 'encrypted.google.com',
     *   port: 443,
     *   path: '/',
     *   method: 'GET',
     *   key: fs.readFileSync('test/fixtures/keys/agent2-key.pem'),
     *   cert: fs.readFileSync('test/fixtures/keys/agent2-cert.pem'),
     *   agent: false,
     * };
     *
     * const req = https.request(options, (res) => {
     *   // ...
     * });
     * ```
     *
     * Example using a `URL` as `options`:
     *
     * ```js
     * const options = new URL('https://abc:xyz@example.com');
     *
     * const req = https.request(options, (res) => {
     *   // ...
     * });
     * ```
     *
     * Example pinning on certificate fingerprint, or the public key (similar to`pin-sha256`):
     *
     * ```js
     * import tls from 'node:tls';
     * import https from 'node:https';
     * import crypto from 'node:crypto';
     *
     * function sha256(s) {
     *   return crypto.createHash('sha256').update(s).digest('base64');
     * }
     * const options = {
     *   hostname: 'github.com',
     *   port: 443,
     *   path: '/',
     *   method: 'GET',
     *   checkServerIdentity: function(host, cert) {
     *     // Make sure the certificate is issued to the host we are connected to
     *     const err = tls.checkServerIdentity(host, cert);
     *     if (err) {
     *       return err;
     *     }
     *
     *     // Pin the public key, similar to HPKP pin-sha256 pinning
     *     const pubkey256 = 'pL1+qb9HTMRZJmuC/bB/ZI9d302BYrrqiVuRyW+DGrU=';
     *     if (sha256(cert.pubkey) !== pubkey256) {
     *       const msg = 'Certificate verification error: ' +
     *         `The public key of '${cert.subject.CN}' ` +
     *         'does not match our pinned fingerprint';
     *       return new Error(msg);
     *     }
     *
     *     // Pin the exact certificate, rather than the pub key
     *     const cert256 = '25:FE:39:32:D9:63:8C:8A:FC:A1:9A:29:87:' +
     *       'D8:3E:4C:1D:98:DB:71:E4:1A:48:03:98:EA:22:6A:BD:8B:93:16';
     *     if (cert.fingerprint256 !== cert256) {
     *       const msg = 'Certificate verification error: ' +
     *         `The certificate of '${cert.subject.CN}' ` +
     *         'does not match our pinned fingerprint';
     *       return new Error(msg);
     *     }
     *
     *     // This loop is informational only.
     *     // Print the certificate and public key fingerprints of all certs in the
     *     // chain. Its common to pin the public key of the issuer on the public
     *     // internet, while pinning the public key of the service in sensitive
     *     // environments.
     *     do {
     *       console.log('Subject Common Name:', cert.subject.CN);
     *       console.log('  Certificate SHA256 fingerprint:', cert.fingerprint256);
     *
     *       hash = crypto.createHash('sha256');
     *       console.log('  Public key ping-sha256:', sha256(cert.pubkey));
     *
     *       lastprint256 = cert.fingerprint256;
     *       cert = cert.issuerCertificate;
     *     } while (cert.fingerprint256 !== lastprint256);
     *
     *   },
     * };
     *
     * options.agent = new https.Agent(options);
     * const req = https.request(options, (res) => {
     *   console.log('All OK. Server matched our pinned cert or public key');
     *   console.log('statusCode:', res.statusCode);
     *   // Print the HPKP values
     *   console.log('headers:', res.headers['public-key-pins']);
     *
     *   res.on('data', (d) => {});
     * });
     *
     * req.on('error', (e) => {
     *   console.error(e.message);
     * });
     * req.end();
     * ```
     *
     * Outputs for example:
     *
     * ```text
     * Subject Common Name: github.com
     *   Certificate SHA256 fingerprint: 25:FE:39:32:D9:63:8C:8A:FC:A1:9A:29:87:D8:3E:4C:1D:98:DB:71:E4:1A:48:03:98:EA:22:6A:BD:8B:93:16
     *   Public key ping-sha256: pL1+qb9HTMRZJmuC/bB/ZI9d302BYrrqiVuRyW+DGrU=
     * Subject Common Name: DigiCert SHA2 Extended Validation Server CA
     *   Certificate SHA256 fingerprint: 40:3E:06:2A:26:53:05:91:13:28:5B:AF:80:A0:D4:AE:42:2C:84:8C:9F:78:FA:D0:1F:C9:4B:C5:B8:7F:EF:1A
     *   Public key ping-sha256: RRM1dGqnDFsCJXBTHky16vi1obOlCgFFn/yOhI/y+ho=
     * Subject Common Name: DigiCert High Assurance EV Root CA
     *   Certificate SHA256 fingerprint: 74:31:E5:F4:C3:C1:CE:46:90:77:4F:0B:61:E0:54:40:88:3B:A9:A0:1E:D0:0B:A6:AB:D7:80:6E:D3:B1:18:CF
     *   Public key ping-sha256: WoiWRyIOVNa9ihaBciRSC7XHjliYS9VwUGOIud4PB18=
     * All OK. Server matched our pinned cert or public key
     * statusCode: 200
     * headers: max-age=0; pin-sha256="WoiWRyIOVNa9ihaBciRSC7XHjliYS9VwUGOIud4PB18="; pin-sha256="RRM1dGqnDFsCJXBTHky16vi1obOlCgFFn/yOhI/y+ho=";
     * pin-sha256="k2v657xBsOVe1PQRwOsHsw3bsGT2VzIqz5K+59sNQws="; pin-sha256="K87oWBWM9UZfyddvDfoxL+8lpNyoUB2ptGtn0fv6G2Q="; pin-sha256="IQBnNBEiFuhj+8x6X8XLgh01V9Ic5/V3IRQLNFFc7v4=";
     * pin-sha256="iie1VXtL7HzAMF+/PVPR9xzT80kQxdZeJ+zduCB3uj0="; pin-sha256="LvRiGEjRqfzurezaWuj8Wie2gyHMrW5Q06LspMnox7A="; includeSubDomains
     * ```
     * @since v0.3.6
     * @param options Accepts all `options` from `request`, with some differences in default values:
     */
    function request(
        options: RequestOptions | string | URL,
        callback?: (res: http.IncomingMessage) => void,
    ): http.ClientRequest;
    function request(
        url: string | URL,
        options: RequestOptions,
        callback?: (res: http.IncomingMessage) => void,
    ): http.ClientRequest;
    /**
     * Like `http.get()` but for HTTPS.
     *
     * `options` can be an object, a string, or a `URL` object. If `options` is a
     * string, it is automatically parsed with `new URL()`. If it is a `URL` object, it will be automatically converted to an ordinary `options` object.
     *
     * ```js
     * import https from 'node:https';
     *
     * https.get('https://encrypted.google.com/', (res) => {
     *   console.log('statusCode:', res.statusCode);
     *   console.log('headers:', res.headers);
     *
     *   res.on('data', (d) => {
     *     process.stdout.write(d);
     *   });
     *
     * }).on('error', (e) => {
     *   console.error(e);
     * });
     * ```
     * @since v0.3.6
     * @param options Accepts the same `options` as {@link request}, with the `method` always set to `GET`.
     */
    function get(
        options: RequestOptions | string | URL,
        callback?: (res: http.IncomingMessage) => void,
    ): http.ClientRequest;
    function get(
        url: string | URL,
        options: RequestOptions,
        callback?: (res: http.IncomingMessage) => void,
    ): http.ClientRequest;
    let globalAgent: Agent;
}
declare module "node:https" {
    export * from "https";
}

```

## ./lib/lambda/node_modules/@types/node/index.d.ts

```typescript
/**
 * License for programmatically and manually incorporated
 * documentation aka. `JSDoc` from https://github.com/nodejs/node/tree/master/doc
 *
 * Copyright Node.js contributors. All rights reserved.
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

// NOTE: These definitions support Node.js and TypeScript 5.7+.

// Reference required TypeScript libs:
/// <reference lib="es2020" />

// TypeScript backwards-compatibility definitions:
/// <reference path="compatibility/index.d.ts" />

// Definitions specific to TypeScript 5.7+:
/// <reference path="globals.typedarray.d.ts" />
/// <reference path="buffer.buffer.d.ts" />

// Definitions for Node.js modules that are not specific to any version of TypeScript:
/// <reference path="globals.d.ts" />
/// <reference path="web-globals/abortcontroller.d.ts" />
/// <reference path="web-globals/domexception.d.ts" />
/// <reference path="web-globals/events.d.ts" />
/// <reference path="web-globals/fetch.d.ts" />
/// <reference path="web-globals/navigator.d.ts" />
/// <reference path="web-globals/storage.d.ts" />
/// <reference path="assert.d.ts" />
/// <reference path="assert/strict.d.ts" />
/// <reference path="async_hooks.d.ts" />
/// <reference path="buffer.d.ts" />
/// <reference path="child_process.d.ts" />
/// <reference path="cluster.d.ts" />
/// <reference path="console.d.ts" />
/// <reference path="constants.d.ts" />
/// <reference path="crypto.d.ts" />
/// <reference path="dgram.d.ts" />
/// <reference path="diagnostics_channel.d.ts" />
/// <reference path="dns.d.ts" />
/// <reference path="dns/promises.d.ts" />
/// <reference path="domain.d.ts" />
/// <reference path="events.d.ts" />
/// <reference path="fs.d.ts" />
/// <reference path="fs/promises.d.ts" />
/// <reference path="http.d.ts" />
/// <reference path="http2.d.ts" />
/// <reference path="https.d.ts" />
/// <reference path="inspector.generated.d.ts" />
/// <reference path="module.d.ts" />
/// <reference path="net.d.ts" />
/// <reference path="os.d.ts" />
/// <reference path="path.d.ts" />
/// <reference path="perf_hooks.d.ts" />
/// <reference path="process.d.ts" />
/// <reference path="punycode.d.ts" />
/// <reference path="querystring.d.ts" />
/// <reference path="readline.d.ts" />
/// <reference path="readline/promises.d.ts" />
/// <reference path="repl.d.ts" />
/// <reference path="sea.d.ts" />
/// <reference path="sqlite.d.ts" />
/// <reference path="stream.d.ts" />
/// <reference path="stream/promises.d.ts" />
/// <reference path="stream/consumers.d.ts" />
/// <reference path="stream/web.d.ts" />
/// <reference path="string_decoder.d.ts" />
/// <reference path="test.d.ts" />
/// <reference path="timers.d.ts" />
/// <reference path="timers/promises.d.ts" />
/// <reference path="tls.d.ts" />
/// <reference path="trace_events.d.ts" />
/// <reference path="tty.d.ts" />
/// <reference path="url.d.ts" />
/// <reference path="util.d.ts" />
/// <reference path="v8.d.ts" />
/// <reference path="vm.d.ts" />
/// <reference path="wasi.d.ts" />
/// <reference path="worker_threads.d.ts" />
/// <reference path="zlib.d.ts" />

```

## ./lib/lambda/node_modules/@types/node/inspector.generated.d.ts

```typescript
// These definitions are automatically generated by the generate-inspector script.
// Do not edit this file directly.
// See scripts/generate-inspector/README.md for information on how to update the protocol definitions.
// Changes to the module itself should be added to the generator template (scripts/generate-inspector/inspector.d.ts.template).

/**
 * The `node:inspector` module provides an API for interacting with the V8
 * inspector.
 * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/inspector.js)
 */
declare module 'inspector' {
    import EventEmitter = require('node:events');

    interface InspectorNotification<T> {
        method: string;
        params: T;
    }

    namespace Schema {
        /**
         * Description of the protocol domain.
         */
        interface Domain {
            /**
             * Domain name.
             */
            name: string;
            /**
             * Domain version.
             */
            version: string;
        }
        interface GetDomainsReturnType {
            /**
             * List of supported domains.
             */
            domains: Domain[];
        }
    }
    namespace Runtime {
        /**
         * Unique script identifier.
         */
        type ScriptId = string;
        /**
         * Unique object identifier.
         */
        type RemoteObjectId = string;
        /**
         * Primitive value which cannot be JSON-stringified.
         */
        type UnserializableValue = string;
        /**
         * Mirror object referencing original JavaScript object.
         */
        interface RemoteObject {
            /**
             * Object type.
             */
            type: string;
            /**
             * Object subtype hint. Specified for <code>object</code> type values only.
             */
            subtype?: string | undefined;
            /**
             * Object class (constructor) name. Specified for <code>object</code> type values only.
             */
            className?: string | undefined;
            /**
             * Remote object value in case of primitive values or JSON values (if it was requested).
             */
            value?: any;
            /**
             * Primitive value which can not be JSON-stringified does not have <code>value</code>, but gets this property.
             */
            unserializableValue?: UnserializableValue | undefined;
            /**
             * String representation of the object.
             */
            description?: string | undefined;
            /**
             * Unique object identifier (for non-primitive values).
             */
            objectId?: RemoteObjectId | undefined;
            /**
             * Preview containing abbreviated property values. Specified for <code>object</code> type values only.
             * @experimental
             */
            preview?: ObjectPreview | undefined;
            /**
             * @experimental
             */
            customPreview?: CustomPreview | undefined;
        }
        /**
         * @experimental
         */
        interface CustomPreview {
            header: string;
            hasBody: boolean;
            formatterObjectId: RemoteObjectId;
            bindRemoteObjectFunctionId: RemoteObjectId;
            configObjectId?: RemoteObjectId | undefined;
        }
        /**
         * Object containing abbreviated remote object value.
         * @experimental
         */
        interface ObjectPreview {
            /**
             * Object type.
             */
            type: string;
            /**
             * Object subtype hint. Specified for <code>object</code> type values only.
             */
            subtype?: string | undefined;
            /**
             * String representation of the object.
             */
            description?: string | undefined;
            /**
             * True iff some of the properties or entries of the original object did not fit.
             */
            overflow: boolean;
            /**
             * List of the properties.
             */
            properties: PropertyPreview[];
            /**
             * List of the entries. Specified for <code>map</code> and <code>set</code> subtype values only.
             */
            entries?: EntryPreview[] | undefined;
        }
        /**
         * @experimental
         */
        interface PropertyPreview {
            /**
             * Property name.
             */
            name: string;
            /**
             * Object type. Accessor means that the property itself is an accessor property.
             */
            type: string;
            /**
             * User-friendly property value string.
             */
            value?: string | undefined;
            /**
             * Nested value preview.
             */
            valuePreview?: ObjectPreview | undefined;
            /**
             * Object subtype hint. Specified for <code>object</code> type values only.
             */
            subtype?: string | undefined;
        }
        /**
         * @experimental
         */
        interface EntryPreview {
            /**
             * Preview of the key. Specified for map-like collection entries.
             */
            key?: ObjectPreview | undefined;
            /**
             * Preview of the value.
             */
            value: ObjectPreview;
        }
        /**
         * Object property descriptor.
         */
        interface PropertyDescriptor {
            /**
             * Property name or symbol description.
             */
            name: string;
            /**
             * The value associated with the property.
             */
            value?: RemoteObject | undefined;
            /**
             * True if the value associated with the property may be changed (data descriptors only).
             */
            writable?: boolean | undefined;
            /**
             * A function which serves as a getter for the property, or <code>undefined</code> if there is no getter (accessor descriptors only).
             */
            get?: RemoteObject | undefined;
            /**
             * A function which serves as a setter for the property, or <code>undefined</code> if there is no setter (accessor descriptors only).
             */
            set?: RemoteObject | undefined;
            /**
             * True if the type of this property descriptor may be changed and if the property may be deleted from the corresponding object.
             */
            configurable: boolean;
            /**
             * True if this property shows up during enumeration of the properties on the corresponding object.
             */
            enumerable: boolean;
            /**
             * True if the result was thrown during the evaluation.
             */
            wasThrown?: boolean | undefined;
            /**
             * True if the property is owned for the object.
             */
            isOwn?: boolean | undefined;
            /**
             * Property symbol object, if the property is of the <code>symbol</code> type.
             */
            symbol?: RemoteObject | undefined;
        }
        /**
         * Object internal property descriptor. This property isn't normally visible in JavaScript code.
         */
        interface InternalPropertyDescriptor {
            /**
             * Conventional property name.
             */
            name: string;
            /**
             * The value associated with the property.
             */
            value?: RemoteObject | undefined;
        }
        /**
         * Represents function call argument. Either remote object id <code>objectId</code>, primitive <code>value</code>, unserializable primitive value or neither of (for undefined) them should be specified.
         */
        interface CallArgument {
            /**
             * Primitive value or serializable javascript object.
             */
            value?: any;
            /**
             * Primitive value which can not be JSON-stringified.
             */
            unserializableValue?: UnserializableValue | undefined;
            /**
             * Remote object handle.
             */
            objectId?: RemoteObjectId | undefined;
        }
        /**
         * Id of an execution context.
         */
        type ExecutionContextId = number;
        /**
         * Description of an isolated world.
         */
        interface ExecutionContextDescription {
            /**
             * Unique id of the execution context. It can be used to specify in which execution context script evaluation should be performed.
             */
            id: ExecutionContextId;
            /**
             * Execution context origin.
             */
            origin: string;
            /**
             * Human readable name describing given context.
             */
            name: string;
            /**
             * Embedder-specific auxiliary data.
             */
            auxData?: object | undefined;
        }
        /**
         * Detailed information about exception (or error) that was thrown during script compilation or execution.
         */
        interface ExceptionDetails {
            /**
             * Exception id.
             */
            exceptionId: number;
            /**
             * Exception text, which should be used together with exception object when available.
             */
            text: string;
            /**
             * Line number of the exception location (0-based).
             */
            lineNumber: number;
            /**
             * Column number of the exception location (0-based).
             */
            columnNumber: number;
            /**
             * Script ID of the exception location.
             */
            scriptId?: ScriptId | undefined;
            /**
             * URL of the exception location, to be used when the script was not reported.
             */
            url?: string | undefined;
            /**
             * JavaScript stack trace if available.
             */
            stackTrace?: StackTrace | undefined;
            /**
             * Exception object if available.
             */
            exception?: RemoteObject | undefined;
            /**
             * Identifier of the context where exception happened.
             */
            executionContextId?: ExecutionContextId | undefined;
        }
        /**
         * Number of milliseconds since epoch.
         */
        type Timestamp = number;
        /**
         * Stack entry for runtime errors and assertions.
         */
        interface CallFrame {
            /**
             * JavaScript function name.
             */
            functionName: string;
            /**
             * JavaScript script id.
             */
            scriptId: ScriptId;
            /**
             * JavaScript script name or url.
             */
            url: string;
            /**
             * JavaScript script line number (0-based).
             */
            lineNumber: number;
            /**
             * JavaScript script column number (0-based).
             */
            columnNumber: number;
        }
        /**
         * Call frames for assertions or error messages.
         */
        interface StackTrace {
            /**
             * String label of this stack trace. For async traces this may be a name of the function that initiated the async call.
             */
            description?: string | undefined;
            /**
             * JavaScript function name.
             */
            callFrames: CallFrame[];
            /**
             * Asynchronous JavaScript stack trace that preceded this stack, if available.
             */
            parent?: StackTrace | undefined;
            /**
             * Asynchronous JavaScript stack trace that preceded this stack, if available.
             * @experimental
             */
            parentId?: StackTraceId | undefined;
        }
        /**
         * Unique identifier of current debugger.
         * @experimental
         */
        type UniqueDebuggerId = string;
        /**
         * If <code>debuggerId</code> is set stack trace comes from another debugger and can be resolved there. This allows to track cross-debugger calls. See <code>Runtime.StackTrace</code> and <code>Debugger.paused</code> for usages.
         * @experimental
         */
        interface StackTraceId {
            id: string;
            debuggerId?: UniqueDebuggerId | undefined;
        }
        interface EvaluateParameterType {
            /**
             * Expression to evaluate.
             */
            expression: string;
            /**
             * Symbolic group name that can be used to release multiple objects.
             */
            objectGroup?: string | undefined;
            /**
             * Determines whether Command Line API should be available during the evaluation.
             */
            includeCommandLineAPI?: boolean | undefined;
            /**
             * In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides <code>setPauseOnException</code> state.
             */
            silent?: boolean | undefined;
            /**
             * Specifies in which execution context to perform evaluation. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
             */
            contextId?: ExecutionContextId | undefined;
            /**
             * Whether the result is expected to be a JSON object that should be sent by value.
             */
            returnByValue?: boolean | undefined;
            /**
             * Whether preview should be generated for the result.
             * @experimental
             */
            generatePreview?: boolean | undefined;
            /**
             * Whether execution should be treated as initiated by user in the UI.
             */
            userGesture?: boolean | undefined;
            /**
             * Whether execution should <code>await</code> for resulting value and return once awaited promise is resolved.
             */
            awaitPromise?: boolean | undefined;
        }
        interface AwaitPromiseParameterType {
            /**
             * Identifier of the promise.
             */
            promiseObjectId: RemoteObjectId;
            /**
             * Whether the result is expected to be a JSON object that should be sent by value.
             */
            returnByValue?: boolean | undefined;
            /**
             * Whether preview should be generated for the result.
             */
            generatePreview?: boolean | undefined;
        }
        interface CallFunctionOnParameterType {
            /**
             * Declaration of the function to call.
             */
            functionDeclaration: string;
            /**
             * Identifier of the object to call function on. Either objectId or executionContextId should be specified.
             */
            objectId?: RemoteObjectId | undefined;
            /**
             * Call arguments. All call arguments must belong to the same JavaScript world as the target object.
             */
            arguments?: CallArgument[] | undefined;
            /**
             * In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides <code>setPauseOnException</code> state.
             */
            silent?: boolean | undefined;
            /**
             * Whether the result is expected to be a JSON object which should be sent by value.
             */
            returnByValue?: boolean | undefined;
            /**
             * Whether preview should be generated for the result.
             * @experimental
             */
            generatePreview?: boolean | undefined;
            /**
             * Whether execution should be treated as initiated by user in the UI.
             */
            userGesture?: boolean | undefined;
            /**
             * Whether execution should <code>await</code> for resulting value and return once awaited promise is resolved.
             */
            awaitPromise?: boolean | undefined;
            /**
             * Specifies execution context which global object will be used to call function on. Either executionContextId or objectId should be specified.
             */
            executionContextId?: ExecutionContextId | undefined;
            /**
             * Symbolic group name that can be used to release multiple objects. If objectGroup is not specified and objectId is, objectGroup will be inherited from object.
             */
            objectGroup?: string | undefined;
        }
        interface GetPropertiesParameterType {
            /**
             * Identifier of the object to return properties for.
             */
            objectId: RemoteObjectId;
            /**
             * If true, returns properties belonging only to the element itself, not to its prototype chain.
             */
            ownProperties?: boolean | undefined;
            /**
             * If true, returns accessor properties (with getter/setter) only; internal properties are not returned either.
             * @experimental
             */
            accessorPropertiesOnly?: boolean | undefined;
            /**
             * Whether preview should be generated for the results.
             * @experimental
             */
            generatePreview?: boolean | undefined;
        }
        interface ReleaseObjectParameterType {
            /**
             * Identifier of the object to release.
             */
            objectId: RemoteObjectId;
        }
        interface ReleaseObjectGroupParameterType {
            /**
             * Symbolic object group name.
             */
            objectGroup: string;
        }
        interface SetCustomObjectFormatterEnabledParameterType {
            enabled: boolean;
        }
        interface CompileScriptParameterType {
            /**
             * Expression to compile.
             */
            expression: string;
            /**
             * Source url to be set for the script.
             */
            sourceURL: string;
            /**
             * Specifies whether the compiled script should be persisted.
             */
            persistScript: boolean;
            /**
             * Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
             */
            executionContextId?: ExecutionContextId | undefined;
        }
        interface RunScriptParameterType {
            /**
             * Id of the script to run.
             */
            scriptId: ScriptId;
            /**
             * Specifies in which execution context to perform script run. If the parameter is omitted the evaluation will be performed in the context of the inspected page.
             */
            executionContextId?: ExecutionContextId | undefined;
            /**
             * Symbolic group name that can be used to release multiple objects.
             */
            objectGroup?: string | undefined;
            /**
             * In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides <code>setPauseOnException</code> state.
             */
            silent?: boolean | undefined;
            /**
             * Determines whether Command Line API should be available during the evaluation.
             */
            includeCommandLineAPI?: boolean | undefined;
            /**
             * Whether the result is expected to be a JSON object which should be sent by value.
             */
            returnByValue?: boolean | undefined;
            /**
             * Whether preview should be generated for the result.
             */
            generatePreview?: boolean | undefined;
            /**
             * Whether execution should <code>await</code> for resulting value and return once awaited promise is resolved.
             */
            awaitPromise?: boolean | undefined;
        }
        interface QueryObjectsParameterType {
            /**
             * Identifier of the prototype to return objects for.
             */
            prototypeObjectId: RemoteObjectId;
        }
        interface GlobalLexicalScopeNamesParameterType {
            /**
             * Specifies in which execution context to lookup global scope variables.
             */
            executionContextId?: ExecutionContextId | undefined;
        }
        interface EvaluateReturnType {
            /**
             * Evaluation result.
             */
            result: RemoteObject;
            /**
             * Exception details.
             */
            exceptionDetails?: ExceptionDetails | undefined;
        }
        interface AwaitPromiseReturnType {
            /**
             * Promise result. Will contain rejected value if promise was rejected.
             */
            result: RemoteObject;
            /**
             * Exception details if stack strace is available.
             */
            exceptionDetails?: ExceptionDetails | undefined;
        }
        interface CallFunctionOnReturnType {
            /**
             * Call result.
             */
            result: RemoteObject;
            /**
             * Exception details.
             */
            exceptionDetails?: ExceptionDetails | undefined;
        }
        interface GetPropertiesReturnType {
            /**
             * Object properties.
             */
            result: PropertyDescriptor[];
            /**
             * Internal object properties (only of the element itself).
             */
            internalProperties?: InternalPropertyDescriptor[] | undefined;
            /**
             * Exception details.
             */
            exceptionDetails?: ExceptionDetails | undefined;
        }
        interface CompileScriptReturnType {
            /**
             * Id of the script.
             */
            scriptId?: ScriptId | undefined;
            /**
             * Exception details.
             */
            exceptionDetails?: ExceptionDetails | undefined;
        }
        interface RunScriptReturnType {
            /**
             * Run result.
             */
            result: RemoteObject;
            /**
             * Exception details.
             */
            exceptionDetails?: ExceptionDetails | undefined;
        }
        interface QueryObjectsReturnType {
            /**
             * Array with objects.
             */
            objects: RemoteObject;
        }
        interface GlobalLexicalScopeNamesReturnType {
            names: string[];
        }
        interface ExecutionContextCreatedEventDataType {
            /**
             * A newly created execution context.
             */
            context: ExecutionContextDescription;
        }
        interface ExecutionContextDestroyedEventDataType {
            /**
             * Id of the destroyed context
             */
            executionContextId: ExecutionContextId;
        }
        interface ExceptionThrownEventDataType {
            /**
             * Timestamp of the exception.
             */
            timestamp: Timestamp;
            exceptionDetails: ExceptionDetails;
        }
        interface ExceptionRevokedEventDataType {
            /**
             * Reason describing why exception was revoked.
             */
            reason: string;
            /**
             * The id of revoked exception, as reported in <code>exceptionThrown</code>.
             */
            exceptionId: number;
        }
        interface ConsoleAPICalledEventDataType {
            /**
             * Type of the call.
             */
            type: string;
            /**
             * Call arguments.
             */
            args: RemoteObject[];
            /**
             * Identifier of the context where the call was made.
             */
            executionContextId: ExecutionContextId;
            /**
             * Call timestamp.
             */
            timestamp: Timestamp;
            /**
             * Stack trace captured when the call was made.
             */
            stackTrace?: StackTrace | undefined;
            /**
             * Console context descriptor for calls on non-default console context (not console.*): 'anonymous#unique-logger-id' for call on unnamed context, 'name#unique-logger-id' for call on named context.
             * @experimental
             */
            context?: string | undefined;
        }
        interface InspectRequestedEventDataType {
            object: RemoteObject;
            hints: object;
        }
    }
    namespace Debugger {
        /**
         * Breakpoint identifier.
         */
        type BreakpointId = string;
        /**
         * Call frame identifier.
         */
        type CallFrameId = string;
        /**
         * Location in the source code.
         */
        interface Location {
            /**
             * Script identifier as reported in the <code>Debugger.scriptParsed</code>.
             */
            scriptId: Runtime.ScriptId;
            /**
             * Line number in the script (0-based).
             */
            lineNumber: number;
            /**
             * Column number in the script (0-based).
             */
            columnNumber?: number | undefined;
        }
        /**
         * Location in the source code.
         * @experimental
         */
        interface ScriptPosition {
            lineNumber: number;
            columnNumber: number;
        }
        /**
         * JavaScript call frame. Array of call frames form the call stack.
         */
        interface CallFrame {
            /**
             * Call frame identifier. This identifier is only valid while the virtual machine is paused.
             */
            callFrameId: CallFrameId;
            /**
             * Name of the JavaScript function called on this call frame.
             */
            functionName: string;
            /**
             * Location in the source code.
             */
            functionLocation?: Location | undefined;
            /**
             * Location in the source code.
             */
            location: Location;
            /**
             * JavaScript script name or url.
             */
            url: string;
            /**
             * Scope chain for this call frame.
             */
            scopeChain: Scope[];
            /**
             * <code>this</code> object for this call frame.
             */
            this: Runtime.RemoteObject;
            /**
             * The value being returned, if the function is at return point.
             */
            returnValue?: Runtime.RemoteObject | undefined;
        }
        /**
         * Scope description.
         */
        interface Scope {
            /**
             * Scope type.
             */
            type: string;
            /**
             * Object representing the scope. For <code>global</code> and <code>with</code> scopes it represents the actual object; for the rest of the scopes, it is artificial transient object enumerating scope variables as its properties.
             */
            object: Runtime.RemoteObject;
            name?: string | undefined;
            /**
             * Location in the source code where scope starts
             */
            startLocation?: Location | undefined;
            /**
             * Location in the source code where scope ends
             */
            endLocation?: Location | undefined;
        }
        /**
         * Search match for resource.
         */
        interface SearchMatch {
            /**
             * Line number in resource content.
             */
            lineNumber: number;
            /**
             * Line with match content.
             */
            lineContent: string;
        }
        interface BreakLocation {
            /**
             * Script identifier as reported in the <code>Debugger.scriptParsed</code>.
             */
            scriptId: Runtime.ScriptId;
            /**
             * Line number in the script (0-based).
             */
            lineNumber: number;
            /**
             * Column number in the script (0-based).
             */
            columnNumber?: number | undefined;
            type?: string | undefined;
        }
        interface SetBreakpointsActiveParameterType {
            /**
             * New value for breakpoints active state.
             */
            active: boolean;
        }
        interface SetSkipAllPausesParameterType {
            /**
             * New value for skip pauses state.
             */
            skip: boolean;
        }
        interface SetBreakpointByUrlParameterType {
            /**
             * Line number to set breakpoint at.
             */
            lineNumber: number;
            /**
             * URL of the resources to set breakpoint on.
             */
            url?: string | undefined;
            /**
             * Regex pattern for the URLs of the resources to set breakpoints on. Either <code>url</code> or <code>urlRegex</code> must be specified.
             */
            urlRegex?: string | undefined;
            /**
             * Script hash of the resources to set breakpoint on.
             */
            scriptHash?: string | undefined;
            /**
             * Offset in the line to set breakpoint at.
             */
            columnNumber?: number | undefined;
            /**
             * Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
             */
            condition?: string | undefined;
        }
        interface SetBreakpointParameterType {
            /**
             * Location to set breakpoint in.
             */
            location: Location;
            /**
             * Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true.
             */
            condition?: string | undefined;
        }
        interface RemoveBreakpointParameterType {
            breakpointId: BreakpointId;
        }
        interface GetPossibleBreakpointsParameterType {
            /**
             * Start of range to search possible breakpoint locations in.
             */
            start: Location;
            /**
             * End of range to search possible breakpoint locations in (excluding). When not specified, end of scripts is used as end of range.
             */
            end?: Location | undefined;
            /**
             * Only consider locations which are in the same (non-nested) function as start.
             */
            restrictToFunction?: boolean | undefined;
        }
        interface ContinueToLocationParameterType {
            /**
             * Location to continue to.
             */
            location: Location;
            targetCallFrames?: string | undefined;
        }
        interface PauseOnAsyncCallParameterType {
            /**
             * Debugger will pause when async call with given stack trace is started.
             */
            parentStackTraceId: Runtime.StackTraceId;
        }
        interface StepIntoParameterType {
            /**
             * Debugger will issue additional Debugger.paused notification if any async task is scheduled before next pause.
             * @experimental
             */
            breakOnAsyncCall?: boolean | undefined;
        }
        interface GetStackTraceParameterType {
            stackTraceId: Runtime.StackTraceId;
        }
        interface SearchInContentParameterType {
            /**
             * Id of the script to search in.
             */
            scriptId: Runtime.ScriptId;
            /**
             * String to search for.
             */
            query: string;
            /**
             * If true, search is case sensitive.
             */
            caseSensitive?: boolean | undefined;
            /**
             * If true, treats string parameter as regex.
             */
            isRegex?: boolean | undefined;
        }
        interface SetScriptSourceParameterType {
            /**
             * Id of the script to edit.
             */
            scriptId: Runtime.ScriptId;
            /**
             * New content of the script.
             */
            scriptSource: string;
            /**
             *  If true the change will not actually be applied. Dry run may be used to get result description without actually modifying the code.
             */
            dryRun?: boolean | undefined;
        }
        interface RestartFrameParameterType {
            /**
             * Call frame identifier to evaluate on.
             */
            callFrameId: CallFrameId;
        }
        interface GetScriptSourceParameterType {
            /**
             * Id of the script to get source for.
             */
            scriptId: Runtime.ScriptId;
        }
        interface SetPauseOnExceptionsParameterType {
            /**
             * Pause on exceptions mode.
             */
            state: string;
        }
        interface EvaluateOnCallFrameParameterType {
            /**
             * Call frame identifier to evaluate on.
             */
            callFrameId: CallFrameId;
            /**
             * Expression to evaluate.
             */
            expression: string;
            /**
             * String object group name to put result into (allows rapid releasing resulting object handles using <code>releaseObjectGroup</code>).
             */
            objectGroup?: string | undefined;
            /**
             * Specifies whether command line API should be available to the evaluated expression, defaults to false.
             */
            includeCommandLineAPI?: boolean | undefined;
            /**
             * In silent mode exceptions thrown during evaluation are not reported and do not pause execution. Overrides <code>setPauseOnException</code> state.
             */
            silent?: boolean | undefined;
            /**
             * Whether the result is expected to be a JSON object that should be sent by value.
             */
            returnByValue?: boolean | undefined;
            /**
             * Whether preview should be generated for the result.
             * @experimental
             */
            generatePreview?: boolean | undefined;
            /**
             * Whether to throw an exception if side effect cannot be ruled out during evaluation.
             */
            throwOnSideEffect?: boolean | undefined;
        }
        interface SetVariableValueParameterType {
            /**
             * 0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch' scope types are allowed. Other scopes could be manipulated manually.
             */
            scopeNumber: number;
            /**
             * Variable name.
             */
            variableName: string;
            /**
             * New variable value.
             */
            newValue: Runtime.CallArgument;
            /**
             * Id of callframe that holds variable.
             */
            callFrameId: CallFrameId;
        }
        interface SetReturnValueParameterType {
            /**
             * New return value.
             */
            newValue: Runtime.CallArgument;
        }
        interface SetAsyncCallStackDepthParameterType {
            /**
             * Maximum depth of async call stacks. Setting to <code>0</code> will effectively disable collecting async call stacks (default).
             */
            maxDepth: number;
        }
        interface SetBlackboxPatternsParameterType {
            /**
             * Array of regexps that will be used to check script url for blackbox state.
             */
            patterns: string[];
        }
        interface SetBlackboxedRangesParameterType {
            /**
             * Id of the script.
             */
            scriptId: Runtime.ScriptId;
            positions: ScriptPosition[];
        }
        interface EnableReturnType {
            /**
             * Unique identifier of the debugger.
             * @experimental
             */
            debuggerId: Runtime.UniqueDebuggerId;
        }
        interface SetBreakpointByUrlReturnType {
            /**
             * Id of the created breakpoint for further reference.
             */
            breakpointId: BreakpointId;
            /**
             * List of the locations this breakpoint resolved into upon addition.
             */
            locations: Location[];
        }
        interface SetBreakpointReturnType {
            /**
             * Id of the created breakpoint for further reference.
             */
            breakpointId: BreakpointId;
            /**
             * Location this breakpoint resolved into.
             */
            actualLocation: Location;
        }
        interface GetPossibleBreakpointsReturnType {
            /**
             * List of the possible breakpoint locations.
             */
            locations: BreakLocation[];
        }
        interface GetStackTraceReturnType {
            stackTrace: Runtime.StackTrace;
        }
        interface SearchInContentReturnType {
            /**
             * List of search matches.
             */
            result: SearchMatch[];
        }
        interface SetScriptSourceReturnType {
            /**
             * New stack trace in case editing has happened while VM was stopped.
             */
            callFrames?: CallFrame[] | undefined;
            /**
             * Whether current call stack  was modified after applying the changes.
             */
            stackChanged?: boolean | undefined;
            /**
             * Async stack trace, if any.
             */
            asyncStackTrace?: Runtime.StackTrace | undefined;
            /**
             * Async stack trace, if any.
             * @experimental
             */
            asyncStackTraceId?: Runtime.StackTraceId | undefined;
            /**
             * Exception details if any.
             */
            exceptionDetails?: Runtime.ExceptionDetails | undefined;
        }
        interface RestartFrameReturnType {
            /**
             * New stack trace.
             */
            callFrames: CallFrame[];
            /**
             * Async stack trace, if any.
             */
            asyncStackTrace?: Runtime.StackTrace | undefined;
            /**
             * Async stack trace, if any.
             * @experimental
             */
            asyncStackTraceId?: Runtime.StackTraceId | undefined;
        }
        interface GetScriptSourceReturnType {
            /**
             * Script source.
             */
            scriptSource: string;
        }
        interface EvaluateOnCallFrameReturnType {
            /**
             * Object wrapper for the evaluation result.
             */
            result: Runtime.RemoteObject;
            /**
             * Exception details.
             */
            exceptionDetails?: Runtime.ExceptionDetails | undefined;
        }
        interface ScriptParsedEventDataType {
            /**
             * Identifier of the script parsed.
             */
            scriptId: Runtime.ScriptId;
            /**
             * URL or name of the script parsed (if any).
             */
            url: string;
            /**
             * Line offset of the script within the resource with given URL (for script tags).
             */
            startLine: number;
            /**
             * Column offset of the script within the resource with given URL.
             */
            startColumn: number;
            /**
             * Last line of the script.
             */
            endLine: number;
            /**
             * Length of the last line of the script.
             */
            endColumn: number;
            /**
             * Specifies script creation context.
             */
            executionContextId: Runtime.ExecutionContextId;
            /**
             * Content hash of the script.
             */
            hash: string;
            /**
             * Embedder-specific auxiliary data.
             */
            executionContextAuxData?: object | undefined;
            /**
             * True, if this script is generated as a result of the live edit operation.
             * @experimental
             */
            isLiveEdit?: boolean | undefined;
            /**
             * URL of source map associated with script (if any).
             */
            sourceMapURL?: string | undefined;
            /**
             * True, if this script has sourceURL.
             */
            hasSourceURL?: boolean | undefined;
            /**
             * True, if this script is ES6 module.
             */
            isModule?: boolean | undefined;
            /**
             * This script length.
             */
            length?: number | undefined;
            /**
             * JavaScript top stack frame of where the script parsed event was triggered if available.
             * @experimental
             */
            stackTrace?: Runtime.StackTrace | undefined;
        }
        interface ScriptFailedToParseEventDataType {
            /**
             * Identifier of the script parsed.
             */
            scriptId: Runtime.ScriptId;
            /**
             * URL or name of the script parsed (if any).
             */
            url: string;
            /**
             * Line offset of the script within the resource with given URL (for script tags).
             */
            startLine: number;
            /**
             * Column offset of the script within the resource with given URL.
             */
            startColumn: number;
            /**
             * Last line of the script.
             */
            endLine: number;
            /**
             * Length of the last line of the script.
             */
            endColumn: number;
            /**
             * Specifies script creation context.
             */
            executionContextId: Runtime.ExecutionContextId;
            /**
             * Content hash of the script.
             */
            hash: string;
            /**
             * Embedder-specific auxiliary data.
             */
            executionContextAuxData?: object | undefined;
            /**
             * URL of source map associated with script (if any).
             */
            sourceMapURL?: string | undefined;
            /**
             * True, if this script has sourceURL.
             */
            hasSourceURL?: boolean | undefined;
            /**
             * True, if this script is ES6 module.
             */
            isModule?: boolean | undefined;
            /**
             * This script length.
             */
            length?: number | undefined;
            /**
             * JavaScript top stack frame of where the script parsed event was triggered if available.
             * @experimental
             */
            stackTrace?: Runtime.StackTrace | undefined;
        }
        interface BreakpointResolvedEventDataType {
            /**
             * Breakpoint unique identifier.
             */
            breakpointId: BreakpointId;
            /**
             * Actual breakpoint location.
             */
            location: Location;
        }
        interface PausedEventDataType {
            /**
             * Call stack the virtual machine stopped on.
             */
            callFrames: CallFrame[];
            /**
             * Pause reason.
             */
            reason: string;
            /**
             * Object containing break-specific auxiliary properties.
             */
            data?: object | undefined;
            /**
             * Hit breakpoints IDs
             */
            hitBreakpoints?: string[] | undefined;
            /**
             * Async stack trace, if any.
             */
            asyncStackTrace?: Runtime.StackTrace | undefined;
            /**
             * Async stack trace, if any.
             * @experimental
             */
            asyncStackTraceId?: Runtime.StackTraceId | undefined;
            /**
             * Just scheduled async call will have this stack trace as parent stack during async execution. This field is available only after <code>Debugger.stepInto</code> call with <code>breakOnAsynCall</code> flag.
             * @experimental
             */
            asyncCallStackTraceId?: Runtime.StackTraceId | undefined;
        }
    }
    namespace Console {
        /**
         * Console message.
         */
        interface ConsoleMessage {
            /**
             * Message source.
             */
            source: string;
            /**
             * Message severity.
             */
            level: string;
            /**
             * Message text.
             */
            text: string;
            /**
             * URL of the message origin.
             */
            url?: string | undefined;
            /**
             * Line number in the resource that generated this message (1-based).
             */
            line?: number | undefined;
            /**
             * Column number in the resource that generated this message (1-based).
             */
            column?: number | undefined;
        }
        interface MessageAddedEventDataType {
            /**
             * Console message that has been added.
             */
            message: ConsoleMessage;
        }
    }
    namespace Profiler {
        /**
         * Profile node. Holds callsite information, execution statistics and child nodes.
         */
        interface ProfileNode {
            /**
             * Unique id of the node.
             */
            id: number;
            /**
             * Function location.
             */
            callFrame: Runtime.CallFrame;
            /**
             * Number of samples where this node was on top of the call stack.
             */
            hitCount?: number | undefined;
            /**
             * Child node ids.
             */
            children?: number[] | undefined;
            /**
             * The reason of being not optimized. The function may be deoptimized or marked as don't optimize.
             */
            deoptReason?: string | undefined;
            /**
             * An array of source position ticks.
             */
            positionTicks?: PositionTickInfo[] | undefined;
        }
        /**
         * Profile.
         */
        interface Profile {
            /**
             * The list of profile nodes. First item is the root node.
             */
            nodes: ProfileNode[];
            /**
             * Profiling start timestamp in microseconds.
             */
            startTime: number;
            /**
             * Profiling end timestamp in microseconds.
             */
            endTime: number;
            /**
             * Ids of samples top nodes.
             */
            samples?: number[] | undefined;
            /**
             * Time intervals between adjacent samples in microseconds. The first delta is relative to the profile startTime.
             */
            timeDeltas?: number[] | undefined;
        }
        /**
         * Specifies a number of samples attributed to a certain source position.
         */
        interface PositionTickInfo {
            /**
             * Source line number (1-based).
             */
            line: number;
            /**
             * Number of samples attributed to the source line.
             */
            ticks: number;
        }
        /**
         * Coverage data for a source range.
         */
        interface CoverageRange {
            /**
             * JavaScript script source offset for the range start.
             */
            startOffset: number;
            /**
             * JavaScript script source offset for the range end.
             */
            endOffset: number;
            /**
             * Collected execution count of the source range.
             */
            count: number;
        }
        /**
         * Coverage data for a JavaScript function.
         */
        interface FunctionCoverage {
            /**
             * JavaScript function name.
             */
            functionName: string;
            /**
             * Source ranges inside the function with coverage data.
             */
            ranges: CoverageRange[];
            /**
             * Whether coverage data for this function has block granularity.
             */
            isBlockCoverage: boolean;
        }
        /**
         * Coverage data for a JavaScript script.
         */
        interface ScriptCoverage {
            /**
             * JavaScript script id.
             */
            scriptId: Runtime.ScriptId;
            /**
             * JavaScript script name or url.
             */
            url: string;
            /**
             * Functions contained in the script that has coverage data.
             */
            functions: FunctionCoverage[];
        }
        interface SetSamplingIntervalParameterType {
            /**
             * New sampling interval in microseconds.
             */
            interval: number;
        }
        interface StartPreciseCoverageParameterType {
            /**
             * Collect accurate call counts beyond simple 'covered' or 'not covered'.
             */
            callCount?: boolean | undefined;
            /**
             * Collect block-based coverage.
             */
            detailed?: boolean | undefined;
        }
        interface StopReturnType {
            /**
             * Recorded profile.
             */
            profile: Profile;
        }
        interface TakePreciseCoverageReturnType {
            /**
             * Coverage data for the current isolate.
             */
            result: ScriptCoverage[];
        }
        interface GetBestEffortCoverageReturnType {
            /**
             * Coverage data for the current isolate.
             */
            result: ScriptCoverage[];
        }
        interface ConsoleProfileStartedEventDataType {
            id: string;
            /**
             * Location of console.profile().
             */
            location: Debugger.Location;
            /**
             * Profile title passed as an argument to console.profile().
             */
            title?: string | undefined;
        }
        interface ConsoleProfileFinishedEventDataType {
            id: string;
            /**
             * Location of console.profileEnd().
             */
            location: Debugger.Location;
            profile: Profile;
            /**
             * Profile title passed as an argument to console.profile().
             */
            title?: string | undefined;
        }
    }
    namespace HeapProfiler {
        /**
         * Heap snapshot object id.
         */
        type HeapSnapshotObjectId = string;
        /**
         * Sampling Heap Profile node. Holds callsite information, allocation statistics and child nodes.
         */
        interface SamplingHeapProfileNode {
            /**
             * Function location.
             */
            callFrame: Runtime.CallFrame;
            /**
             * Allocations size in bytes for the node excluding children.
             */
            selfSize: number;
            /**
             * Child nodes.
             */
            children: SamplingHeapProfileNode[];
        }
        /**
         * Profile.
         */
        interface SamplingHeapProfile {
            head: SamplingHeapProfileNode;
        }
        interface StartTrackingHeapObjectsParameterType {
            trackAllocations?: boolean | undefined;
        }
        interface StopTrackingHeapObjectsParameterType {
            /**
             * If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken when the tracking is stopped.
             */
            reportProgress?: boolean | undefined;
        }
        interface TakeHeapSnapshotParameterType {
            /**
             * If true 'reportHeapSnapshotProgress' events will be generated while snapshot is being taken.
             */
            reportProgress?: boolean | undefined;
        }
        interface GetObjectByHeapObjectIdParameterType {
            objectId: HeapSnapshotObjectId;
            /**
             * Symbolic group name that can be used to release multiple objects.
             */
            objectGroup?: string | undefined;
        }
        interface AddInspectedHeapObjectParameterType {
            /**
             * Heap snapshot object id to be accessible by means of $x command line API.
             */
            heapObjectId: HeapSnapshotObjectId;
        }
        interface GetHeapObjectIdParameterType {
            /**
             * Identifier of the object to get heap object id for.
             */
            objectId: Runtime.RemoteObjectId;
        }
        interface StartSamplingParameterType {
            /**
             * Average sample interval in bytes. Poisson distribution is used for the intervals. The default value is 32768 bytes.
             */
            samplingInterval?: number | undefined;
        }
        interface GetObjectByHeapObjectIdReturnType {
            /**
             * Evaluation result.
             */
            result: Runtime.RemoteObject;
        }
        interface GetHeapObjectIdReturnType {
            /**
             * Id of the heap snapshot object corresponding to the passed remote object id.
             */
            heapSnapshotObjectId: HeapSnapshotObjectId;
        }
        interface StopSamplingReturnType {
            /**
             * Recorded sampling heap profile.
             */
            profile: SamplingHeapProfile;
        }
        interface GetSamplingProfileReturnType {
            /**
             * Return the sampling profile being collected.
             */
            profile: SamplingHeapProfile;
        }
        interface AddHeapSnapshotChunkEventDataType {
            chunk: string;
        }
        interface ReportHeapSnapshotProgressEventDataType {
            done: number;
            total: number;
            finished?: boolean | undefined;
        }
        interface LastSeenObjectIdEventDataType {
            lastSeenObjectId: number;
            timestamp: number;
        }
        interface HeapStatsUpdateEventDataType {
            /**
             * An array of triplets. Each triplet describes a fragment. The first integer is the fragment index, the second integer is a total count of objects for the fragment, the third integer is a total size of the objects for the fragment.
             */
            statsUpdate: number[];
        }
    }
    namespace NodeTracing {
        interface TraceConfig {
            /**
             * Controls how the trace buffer stores data.
             */
            recordMode?: string | undefined;
            /**
             * Included category filters.
             */
            includedCategories: string[];
        }
        interface StartParameterType {
            traceConfig: TraceConfig;
        }
        interface GetCategoriesReturnType {
            /**
             * A list of supported tracing categories.
             */
            categories: string[];
        }
        interface DataCollectedEventDataType {
            value: object[];
        }
    }
    namespace NodeWorker {
        type WorkerID = string;
        /**
         * Unique identifier of attached debugging session.
         */
        type SessionID = string;
        interface WorkerInfo {
            workerId: WorkerID;
            type: string;
            title: string;
            url: string;
        }
        interface SendMessageToWorkerParameterType {
            message: string;
            /**
             * Identifier of the session.
             */
            sessionId: SessionID;
        }
        interface EnableParameterType {
            /**
             * Whether to new workers should be paused until the frontend sends `Runtime.runIfWaitingForDebugger`
             * message to run them.
             */
            waitForDebuggerOnStart: boolean;
        }
        interface DetachParameterType {
            sessionId: SessionID;
        }
        interface AttachedToWorkerEventDataType {
            /**
             * Identifier assigned to the session used to send/receive messages.
             */
            sessionId: SessionID;
            workerInfo: WorkerInfo;
            waitingForDebugger: boolean;
        }
        interface DetachedFromWorkerEventDataType {
            /**
             * Detached session identifier.
             */
            sessionId: SessionID;
        }
        interface ReceivedMessageFromWorkerEventDataType {
            /**
             * Identifier of a session which sends a message.
             */
            sessionId: SessionID;
            message: string;
        }
    }
    namespace Network {
        /**
         * Resource type as it was perceived by the rendering engine.
         */
        type ResourceType = string;
        /**
         * Unique request identifier.
         */
        type RequestId = string;
        /**
         * UTC time in seconds, counted from January 1, 1970.
         */
        type TimeSinceEpoch = number;
        /**
         * Monotonically increasing time in seconds since an arbitrary point in the past.
         */
        type MonotonicTime = number;
        /**
         * Information about the request initiator.
         */
        interface Initiator {
            /**
             * Type of this initiator.
             */
            type: string;
            /**
             * Initiator JavaScript stack trace, set for Script only.
             * Requires the Debugger domain to be enabled.
             */
            stack?: Runtime.StackTrace | undefined;
            /**
             * Initiator URL, set for Parser type or for Script type (when script is importing module) or for SignedExchange type.
             */
            url?: string | undefined;
            /**
             * Initiator line number, set for Parser type or for Script type (when script is importing
             * module) (0-based).
             */
            lineNumber?: number | undefined;
            /**
             * Initiator column number, set for Parser type or for Script type (when script is importing
             * module) (0-based).
             */
            columnNumber?: number | undefined;
            /**
             * Set if another request triggered this request (e.g. preflight).
             */
            requestId?: RequestId | undefined;
        }
        /**
         * HTTP request data.
         */
        interface Request {
            url: string;
            method: string;
            headers: Headers;
            hasPostData: boolean;
        }
        /**
         * HTTP response data.
         */
        interface Response {
            url: string;
            status: number;
            statusText: string;
            headers: Headers;
            mimeType: string;
            charset: string;
        }
        /**
         * Request / response headers as keys / values of JSON object.
         */
        interface Headers {
        }
        interface GetRequestPostDataParameterType {
            /**
             * Identifier of the network request to get content for.
             */
            requestId: RequestId;
        }
        interface GetResponseBodyParameterType {
            /**
             * Identifier of the network request to get content for.
             */
            requestId: RequestId;
        }
        interface StreamResourceContentParameterType {
            /**
             * Identifier of the request to stream.
             */
            requestId: RequestId;
        }
        interface GetRequestPostDataReturnType {
            /**
             * Request body string, omitting files from multipart requests
             */
            postData: string;
        }
        interface GetResponseBodyReturnType {
            /**
             * Response body.
             */
            body: string;
            /**
             * True, if content was sent as base64.
             */
            base64Encoded: boolean;
        }
        interface StreamResourceContentReturnType {
            /**
             * Data that has been buffered until streaming is enabled.
             */
            bufferedData: string;
        }
        interface RequestWillBeSentEventDataType {
            /**
             * Request identifier.
             */
            requestId: RequestId;
            /**
             * Request data.
             */
            request: Request;
            /**
             * Request initiator.
             */
            initiator: Initiator;
            /**
             * Timestamp.
             */
            timestamp: MonotonicTime;
            /**
             * Timestamp.
             */
            wallTime: TimeSinceEpoch;
        }
        interface ResponseReceivedEventDataType {
            /**
             * Request identifier.
             */
            requestId: RequestId;
            /**
             * Timestamp.
             */
            timestamp: MonotonicTime;
            /**
             * Resource type.
             */
            type: ResourceType;
            /**
             * Response data.
             */
            response: Response;
        }
        interface LoadingFailedEventDataType {
            /**
             * Request identifier.
             */
            requestId: RequestId;
            /**
             * Timestamp.
             */
            timestamp: MonotonicTime;
            /**
             * Resource type.
             */
            type: ResourceType;
            /**
             * Error message.
             */
            errorText: string;
        }
        interface LoadingFinishedEventDataType {
            /**
             * Request identifier.
             */
            requestId: RequestId;
            /**
             * Timestamp.
             */
            timestamp: MonotonicTime;
        }
        interface DataReceivedEventDataType {
            /**
             * Request identifier.
             */
            requestId: RequestId;
            /**
             * Timestamp.
             */
            timestamp: MonotonicTime;
            /**
             * Data chunk length.
             */
            dataLength: number;
            /**
             * Actual bytes received (might be less than dataLength for compressed encodings).
             */
            encodedDataLength: number;
            /**
             * Data that was received.
             * @experimental
             */
            data?: string | undefined;
        }
    }
    namespace NodeRuntime {
        interface NotifyWhenWaitingForDisconnectParameterType {
            enabled: boolean;
        }
    }
    namespace Target {
        type SessionID = string;
        type TargetID = string;
        interface TargetInfo {
            targetId: TargetID;
            type: string;
            title: string;
            url: string;
            attached: boolean;
            canAccessOpener: boolean;
        }
        interface SetAutoAttachParameterType {
            autoAttach: boolean;
            waitForDebuggerOnStart: boolean;
        }
        interface TargetCreatedEventDataType {
            targetInfo: TargetInfo;
        }
        interface AttachedToTargetEventDataType {
            sessionId: SessionID;
            targetInfo: TargetInfo;
            waitingForDebugger: boolean;
        }
    }

    /**
     * The `inspector.Session` is used for dispatching messages to the V8 inspector
     * back-end and receiving message responses and notifications.
     */
    class Session extends EventEmitter {
        /**
         * Create a new instance of the inspector.Session class.
         * The inspector session needs to be connected through `session.connect()` before the messages can be dispatched to the inspector backend.
         */
        constructor();

        /**
         * Connects a session to the inspector back-end.
         */
        connect(): void;

        /**
         * Connects a session to the inspector back-end.
         * An exception will be thrown if this API was not called on a Worker thread.
         * @since v12.11.0
         */
        connectToMainThread(): void;

        /**
         * Immediately close the session. All pending message callbacks will be called with an error.
         * `session.connect()` will need to be called to be able to send messages again.
         * Reconnected session will lose all inspector state, such as enabled agents or configured breakpoints.
         */
        disconnect(): void;

        /**
         * Posts a message to the inspector back-end. `callback` will be notified when
         * a response is received. `callback` is a function that accepts two optional
         * arguments: error and message-specific result.
         *
         * ```js
         * session.post('Runtime.evaluate', { expression: '2 + 2' },
         *              (error, { result }) => console.log(result));
         * // Output: { type: 'number', value: 4, description: '4' }
         * ```
         *
         * The latest version of the V8 inspector protocol is published on the
         * [Chrome DevTools Protocol Viewer](https://chromedevtools.github.io/devtools-protocol/v8/).
         *
         * Node.js inspector supports all the Chrome DevTools Protocol domains declared
         * by V8. Chrome DevTools Protocol domain provides an interface for interacting
         * with one of the runtime agents used to inspect the application state and listen
         * to the run-time events.
         */
        post(method: string, callback?: (err: Error | null, params?: object) => void): void;
        post(method: string, params?: object, callback?: (err: Error | null, params?: object) => void): void;
        /**
         * Returns supported domains.
         */
        post(method: 'Schema.getDomains', callback?: (err: Error | null, params: Schema.GetDomainsReturnType) => void): void;
        /**
         * Evaluates expression on global object.
         */
        post(method: 'Runtime.evaluate', params?: Runtime.EvaluateParameterType, callback?: (err: Error | null, params: Runtime.EvaluateReturnType) => void): void;
        post(method: 'Runtime.evaluate', callback?: (err: Error | null, params: Runtime.EvaluateReturnType) => void): void;
        /**
         * Add handler to promise with given promise object id.
         */
        post(method: 'Runtime.awaitPromise', params?: Runtime.AwaitPromiseParameterType, callback?: (err: Error | null, params: Runtime.AwaitPromiseReturnType) => void): void;
        post(method: 'Runtime.awaitPromise', callback?: (err: Error | null, params: Runtime.AwaitPromiseReturnType) => void): void;
        /**
         * Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
         */
        post(method: 'Runtime.callFunctionOn', params?: Runtime.CallFunctionOnParameterType, callback?: (err: Error | null, params: Runtime.CallFunctionOnReturnType) => void): void;
        post(method: 'Runtime.callFunctionOn', callback?: (err: Error | null, params: Runtime.CallFunctionOnReturnType) => void): void;
        /**
         * Returns properties of a given object. Object group of the result is inherited from the target object.
         */
        post(method: 'Runtime.getProperties', params?: Runtime.GetPropertiesParameterType, callback?: (err: Error | null, params: Runtime.GetPropertiesReturnType) => void): void;
        post(method: 'Runtime.getProperties', callback?: (err: Error | null, params: Runtime.GetPropertiesReturnType) => void): void;
        /**
         * Releases remote object with given id.
         */
        post(method: 'Runtime.releaseObject', params?: Runtime.ReleaseObjectParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'Runtime.releaseObject', callback?: (err: Error | null) => void): void;
        /**
         * Releases all remote objects that belong to a given group.
         */
        post(method: 'Runtime.releaseObjectGroup', params?: Runtime.ReleaseObjectGroupParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'Runtime.releaseObjectGroup', callback?: (err: Error | null) => void): void;
        /**
         * Tells inspected instance to run if it was waiting for debugger to attach.
         */
        post(method: 'Runtime.runIfWaitingForDebugger', callback?: (err: Error | null) => void): void;
        /**
         * Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
         */
        post(method: 'Runtime.enable', callback?: (err: Error | null) => void): void;
        /**
         * Disables reporting of execution contexts creation.
         */
        post(method: 'Runtime.disable', callback?: (err: Error | null) => void): void;
        /**
         * Discards collected exceptions and console API calls.
         */
        post(method: 'Runtime.discardConsoleEntries', callback?: (err: Error | null) => void): void;
        /**
         * @experimental
         */
        post(method: 'Runtime.setCustomObjectFormatterEnabled', params?: Runtime.SetCustomObjectFormatterEnabledParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'Runtime.setCustomObjectFormatterEnabled', callback?: (err: Error | null) => void): void;
        /**
         * Compiles expression.
         */
        post(method: 'Runtime.compileScript', params?: Runtime.CompileScriptParameterType, callback?: (err: Error | null, params: Runtime.CompileScriptReturnType) => void): void;
        post(method: 'Runtime.compileScript', callback?: (err: Error | null, params: Runtime.CompileScriptReturnType) => void): void;
        /**
         * Runs script with given id in a given context.
         */
        post(method: 'Runtime.runScript', params?: Runtime.RunScriptParameterType, callback?: (err: Error | null, params: Runtime.RunScriptReturnType) => void): void;
        post(method: 'Runtime.runScript', callback?: (err: Error | null, params: Runtime.RunScriptReturnType) => void): void;
        post(method: 'Runtime.queryObjects', params?: Runtime.QueryObjectsParameterType, callback?: (err: Error | null, params: Runtime.QueryObjectsReturnType) => void): void;
        post(method: 'Runtime.queryObjects', callback?: (err: Error | null, params: Runtime.QueryObjectsReturnType) => void): void;
        /**
         * Returns all let, const and class variables from global scope.
         */
        post(
            method: 'Runtime.globalLexicalScopeNames',
            params?: Runtime.GlobalLexicalScopeNamesParameterType,
            callback?: (err: Error | null, params: Runtime.GlobalLexicalScopeNamesReturnType) => void
        ): void;
        post(method: 'Runtime.globalLexicalScopeNames', callback?: (err: Error | null, params: Runtime.GlobalLexicalScopeNamesReturnType) => void): void;
        /**
         * Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
         */
        post(method: 'Debugger.enable', callback?: (err: Error | null, params: Debugger.EnableReturnType) => void): void;
        /**
         * Disables debugger for given page.
         */
        post(method: 'Debugger.disable', callback?: (err: Error | null) => void): void;
        /**
         * Activates / deactivates all breakpoints on the page.
         */
        post(method: 'Debugger.setBreakpointsActive', params?: Debugger.SetBreakpointsActiveParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'Debugger.setBreakpointsActive', callback?: (err: Error | null) => void): void;
        /**
         * Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
         */
        post(method: 'Debugger.setSkipAllPauses', params?: Debugger.SetSkipAllPausesParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'Debugger.setSkipAllPauses', callback?: (err: Error | null) => void): void;
        /**
         * Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
         */
        post(method: 'Debugger.setBreakpointByUrl', params?: Debugger.SetBreakpointByUrlParameterType, callback?: (err: Error | null, params: Debugger.SetBreakpointByUrlReturnType) => void): void;
        post(method: 'Debugger.setBreakpointByUrl', callback?: (err: Error | null, params: Debugger.SetBreakpointByUrlReturnType) => void): void;
        /**
         * Sets JavaScript breakpoint at a given location.
         */
        post(method: 'Debugger.setBreakpoint', params?: Debugger.SetBreakpointParameterType, callback?: (err: Error | null, params: Debugger.SetBreakpointReturnType) => void): void;
        post(method: 'Debugger.setBreakpoint', callback?: (err: Error | null, params: Debugger.SetBreakpointReturnType) => void): void;
        /**
         * Removes JavaScript breakpoint.
         */
        post(method: 'Debugger.removeBreakpoint', params?: Debugger.RemoveBreakpointParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'Debugger.removeBreakpoint', callback?: (err: Error | null) => void): void;
        /**
         * Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
         */
        post(
            method: 'Debugger.getPossibleBreakpoints',
            params?: Debugger.GetPossibleBreakpointsParameterType,
            callback?: (err: Error | null, params: Debugger.GetPossibleBreakpointsReturnType) => void
        ): void;
        post(method: 'Debugger.getPossibleBreakpoints', callback?: (err: Error | null, params: Debugger.GetPossibleBreakpointsReturnType) => void): void;
        /**
         * Continues execution until specific location is reached.
         */
        post(method: 'Debugger.continueToLocation', params?: Debugger.ContinueToLocationParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'Debugger.continueToLocation', callback?: (err: Error | null) => void): void;
        /**
         * @experimental
         */
        post(method: 'Debugger.pauseOnAsyncCall', params?: Debugger.PauseOnAsyncCallParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'Debugger.pauseOnAsyncCall', callback?: (err: Error | null) => void): void;
        /**
         * Steps over the statement.
         */
        post(method: 'Debugger.stepOver', callback?: (err: Error | null) => void): void;
        /**
         * Steps into the function call.
         */
        post(method: 'Debugger.stepInto', params?: Debugger.StepIntoParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'Debugger.stepInto', callback?: (err: Error | null) => void): void;
        /**
         * Steps out of the function call.
         */
        post(method: 'Debugger.stepOut', callback?: (err: Error | null) => void): void;
        /**
         * Stops on the next JavaScript statement.
         */
        post(method: 'Debugger.pause', callback?: (err: Error | null) => void): void;
        /**
         * This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
         * @experimental
         */
        post(method: 'Debugger.scheduleStepIntoAsync', callback?: (err: Error | null) => void): void;
        /**
         * Resumes JavaScript execution.
         */
        post(method: 'Debugger.resume', callback?: (err: Error | null) => void): void;
        /**
         * Returns stack trace with given <code>stackTraceId</code>.
         * @experimental
         */
        post(method: 'Debugger.getStackTrace', params?: Debugger.GetStackTraceParameterType, callback?: (err: Error | null, params: Debugger.GetStackTraceReturnType) => void): void;
        post(method: 'Debugger.getStackTrace', callback?: (err: Error | null, params: Debugger.GetStackTraceReturnType) => void): void;
        /**
         * Searches for given string in script content.
         */
        post(method: 'Debugger.searchInContent', params?: Debugger.SearchInContentParameterType, callback?: (err: Error | null, params: Debugger.SearchInContentReturnType) => void): void;
        post(method: 'Debugger.searchInContent', callback?: (err: Error | null, params: Debugger.SearchInContentReturnType) => void): void;
        /**
         * Edits JavaScript source live.
         */
        post(method: 'Debugger.setScriptSource', params?: Debugger.SetScriptSourceParameterType, callback?: (err: Error | null, params: Debugger.SetScriptSourceReturnType) => void): void;
        post(method: 'Debugger.setScriptSource', callback?: (err: Error | null, params: Debugger.SetScriptSourceReturnType) => void): void;
        /**
         * Restarts particular call frame from the beginning.
         */
        post(method: 'Debugger.restartFrame', params?: Debugger.RestartFrameParameterType, callback?: (err: Error | null, params: Debugger.RestartFrameReturnType) => void): void;
        post(method: 'Debugger.restartFrame', callback?: (err: Error | null, params: Debugger.RestartFrameReturnType) => void): void;
        /**
         * Returns source for the script with given id.
         */
        post(method: 'Debugger.getScriptSource', params?: Debugger.GetScriptSourceParameterType, callback?: (err: Error | null, params: Debugger.GetScriptSourceReturnType) => void): void;
        post(method: 'Debugger.getScriptSource', callback?: (err: Error | null, params: Debugger.GetScriptSourceReturnType) => void): void;
        /**
         * Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
         */
        post(method: 'Debugger.setPauseOnExceptions', params?: Debugger.SetPauseOnExceptionsParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'Debugger.setPauseOnExceptions', callback?: (err: Error | null) => void): void;
        /**
         * Evaluates expression on a given call frame.
         */
        post(method: 'Debugger.evaluateOnCallFrame', params?: Debugger.EvaluateOnCallFrameParameterType, callback?: (err: Error | null, params: Debugger.EvaluateOnCallFrameReturnType) => void): void;
        post(method: 'Debugger.evaluateOnCallFrame', callback?: (err: Error | null, params: Debugger.EvaluateOnCallFrameReturnType) => void): void;
        /**
         * Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
         */
        post(method: 'Debugger.setVariableValue', params?: Debugger.SetVariableValueParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'Debugger.setVariableValue', callback?: (err: Error | null) => void): void;
        /**
         * Changes return value in top frame. Available only at return break position.
         * @experimental
         */
        post(method: 'Debugger.setReturnValue', params?: Debugger.SetReturnValueParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'Debugger.setReturnValue', callback?: (err: Error | null) => void): void;
        /**
         * Enables or disables async call stacks tracking.
         */
        post(method: 'Debugger.setAsyncCallStackDepth', params?: Debugger.SetAsyncCallStackDepthParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'Debugger.setAsyncCallStackDepth', callback?: (err: Error | null) => void): void;
        /**
         * Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
         * @experimental
         */
        post(method: 'Debugger.setBlackboxPatterns', params?: Debugger.SetBlackboxPatternsParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'Debugger.setBlackboxPatterns', callback?: (err: Error | null) => void): void;
        /**
         * Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
         * @experimental
         */
        post(method: 'Debugger.setBlackboxedRanges', params?: Debugger.SetBlackboxedRangesParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'Debugger.setBlackboxedRanges', callback?: (err: Error | null) => void): void;
        /**
         * Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
         */
        post(method: 'Console.enable', callback?: (err: Error | null) => void): void;
        /**
         * Disables console domain, prevents further console messages from being reported to the client.
         */
        post(method: 'Console.disable', callback?: (err: Error | null) => void): void;
        /**
         * Does nothing.
         */
        post(method: 'Console.clearMessages', callback?: (err: Error | null) => void): void;
        post(method: 'Profiler.enable', callback?: (err: Error | null) => void): void;
        post(method: 'Profiler.disable', callback?: (err: Error | null) => void): void;
        /**
         * Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
         */
        post(method: 'Profiler.setSamplingInterval', params?: Profiler.SetSamplingIntervalParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'Profiler.setSamplingInterval', callback?: (err: Error | null) => void): void;
        post(method: 'Profiler.start', callback?: (err: Error | null) => void): void;
        post(method: 'Profiler.stop', callback?: (err: Error | null, params: Profiler.StopReturnType) => void): void;
        /**
         * Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
         */
        post(method: 'Profiler.startPreciseCoverage', params?: Profiler.StartPreciseCoverageParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'Profiler.startPreciseCoverage', callback?: (err: Error | null) => void): void;
        /**
         * Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
         */
        post(method: 'Profiler.stopPreciseCoverage', callback?: (err: Error | null) => void): void;
        /**
         * Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
         */
        post(method: 'Profiler.takePreciseCoverage', callback?: (err: Error | null, params: Profiler.TakePreciseCoverageReturnType) => void): void;
        /**
         * Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
         */
        post(method: 'Profiler.getBestEffortCoverage', callback?: (err: Error | null, params: Profiler.GetBestEffortCoverageReturnType) => void): void;
        post(method: 'HeapProfiler.enable', callback?: (err: Error | null) => void): void;
        post(method: 'HeapProfiler.disable', callback?: (err: Error | null) => void): void;
        post(method: 'HeapProfiler.startTrackingHeapObjects', params?: HeapProfiler.StartTrackingHeapObjectsParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'HeapProfiler.startTrackingHeapObjects', callback?: (err: Error | null) => void): void;
        post(method: 'HeapProfiler.stopTrackingHeapObjects', params?: HeapProfiler.StopTrackingHeapObjectsParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'HeapProfiler.stopTrackingHeapObjects', callback?: (err: Error | null) => void): void;
        post(method: 'HeapProfiler.takeHeapSnapshot', params?: HeapProfiler.TakeHeapSnapshotParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'HeapProfiler.takeHeapSnapshot', callback?: (err: Error | null) => void): void;
        post(method: 'HeapProfiler.collectGarbage', callback?: (err: Error | null) => void): void;
        post(
            method: 'HeapProfiler.getObjectByHeapObjectId',
            params?: HeapProfiler.GetObjectByHeapObjectIdParameterType,
            callback?: (err: Error | null, params: HeapProfiler.GetObjectByHeapObjectIdReturnType) => void
        ): void;
        post(method: 'HeapProfiler.getObjectByHeapObjectId', callback?: (err: Error | null, params: HeapProfiler.GetObjectByHeapObjectIdReturnType) => void): void;
        /**
         * Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
         */
        post(method: 'HeapProfiler.addInspectedHeapObject', params?: HeapProfiler.AddInspectedHeapObjectParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'HeapProfiler.addInspectedHeapObject', callback?: (err: Error | null) => void): void;
        post(method: 'HeapProfiler.getHeapObjectId', params?: HeapProfiler.GetHeapObjectIdParameterType, callback?: (err: Error | null, params: HeapProfiler.GetHeapObjectIdReturnType) => void): void;
        post(method: 'HeapProfiler.getHeapObjectId', callback?: (err: Error | null, params: HeapProfiler.GetHeapObjectIdReturnType) => void): void;
        post(method: 'HeapProfiler.startSampling', params?: HeapProfiler.StartSamplingParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'HeapProfiler.startSampling', callback?: (err: Error | null) => void): void;
        post(method: 'HeapProfiler.stopSampling', callback?: (err: Error | null, params: HeapProfiler.StopSamplingReturnType) => void): void;
        post(method: 'HeapProfiler.getSamplingProfile', callback?: (err: Error | null, params: HeapProfiler.GetSamplingProfileReturnType) => void): void;
        /**
         * Gets supported tracing categories.
         */
        post(method: 'NodeTracing.getCategories', callback?: (err: Error | null, params: NodeTracing.GetCategoriesReturnType) => void): void;
        /**
         * Start trace events collection.
         */
        post(method: 'NodeTracing.start', params?: NodeTracing.StartParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'NodeTracing.start', callback?: (err: Error | null) => void): void;
        /**
         * Stop trace events collection. Remaining collected events will be sent as a sequence of
         * dataCollected events followed by tracingComplete event.
         */
        post(method: 'NodeTracing.stop', callback?: (err: Error | null) => void): void;
        /**
         * Sends protocol message over session with given id.
         */
        post(method: 'NodeWorker.sendMessageToWorker', params?: NodeWorker.SendMessageToWorkerParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'NodeWorker.sendMessageToWorker', callback?: (err: Error | null) => void): void;
        /**
         * Instructs the inspector to attach to running workers. Will also attach to new workers
         * as they start
         */
        post(method: 'NodeWorker.enable', params?: NodeWorker.EnableParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'NodeWorker.enable', callback?: (err: Error | null) => void): void;
        /**
         * Detaches from all running workers and disables attaching to new workers as they are started.
         */
        post(method: 'NodeWorker.disable', callback?: (err: Error | null) => void): void;
        /**
         * Detached from the worker with given sessionId.
         */
        post(method: 'NodeWorker.detach', params?: NodeWorker.DetachParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'NodeWorker.detach', callback?: (err: Error | null) => void): void;
        /**
         * Disables network tracking, prevents network events from being sent to the client.
         */
        post(method: 'Network.disable', callback?: (err: Error | null) => void): void;
        /**
         * Enables network tracking, network events will now be delivered to the client.
         */
        post(method: 'Network.enable', callback?: (err: Error | null) => void): void;
        /**
         * Returns post data sent with the request. Returns an error when no data was sent with the request.
         */
        post(method: 'Network.getRequestPostData', params?: Network.GetRequestPostDataParameterType, callback?: (err: Error | null, params: Network.GetRequestPostDataReturnType) => void): void;
        post(method: 'Network.getRequestPostData', callback?: (err: Error | null, params: Network.GetRequestPostDataReturnType) => void): void;
        /**
         * Returns content served for the given request.
         */
        post(method: 'Network.getResponseBody', params?: Network.GetResponseBodyParameterType, callback?: (err: Error | null, params: Network.GetResponseBodyReturnType) => void): void;
        post(method: 'Network.getResponseBody', callback?: (err: Error | null, params: Network.GetResponseBodyReturnType) => void): void;
        /**
         * Enables streaming of the response for the given requestId.
         * If enabled, the dataReceived event contains the data that was received during streaming.
         * @experimental
         */
        post(
            method: 'Network.streamResourceContent',
            params?: Network.StreamResourceContentParameterType,
            callback?: (err: Error | null, params: Network.StreamResourceContentReturnType) => void
        ): void;
        post(method: 'Network.streamResourceContent', callback?: (err: Error | null, params: Network.StreamResourceContentReturnType) => void): void;
        /**
         * Enable the NodeRuntime events except by `NodeRuntime.waitingForDisconnect`.
         */
        post(method: 'NodeRuntime.enable', callback?: (err: Error | null) => void): void;
        /**
         * Disable NodeRuntime events
         */
        post(method: 'NodeRuntime.disable', callback?: (err: Error | null) => void): void;
        /**
         * Enable the `NodeRuntime.waitingForDisconnect`.
         */
        post(method: 'NodeRuntime.notifyWhenWaitingForDisconnect', params?: NodeRuntime.NotifyWhenWaitingForDisconnectParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'NodeRuntime.notifyWhenWaitingForDisconnect', callback?: (err: Error | null) => void): void;
        post(method: 'Target.setAutoAttach', params?: Target.SetAutoAttachParameterType, callback?: (err: Error | null) => void): void;
        post(method: 'Target.setAutoAttach', callback?: (err: Error | null) => void): void;

        addListener(event: string, listener: (...args: any[]) => void): this;
        /**
         * Emitted when any notification from the V8 Inspector is received.
         */
        addListener(event: 'inspectorNotification', listener: (message: InspectorNotification<object>) => void): this;
        /**
         * Issued when new execution context is created.
         */
        addListener(event: 'Runtime.executionContextCreated', listener: (message: InspectorNotification<Runtime.ExecutionContextCreatedEventDataType>) => void): this;
        /**
         * Issued when execution context is destroyed.
         */
        addListener(event: 'Runtime.executionContextDestroyed', listener: (message: InspectorNotification<Runtime.ExecutionContextDestroyedEventDataType>) => void): this;
        /**
         * Issued when all executionContexts were cleared in browser
         */
        addListener(event: 'Runtime.executionContextsCleared', listener: () => void): this;
        /**
         * Issued when exception was thrown and unhandled.
         */
        addListener(event: 'Runtime.exceptionThrown', listener: (message: InspectorNotification<Runtime.ExceptionThrownEventDataType>) => void): this;
        /**
         * Issued when unhandled exception was revoked.
         */
        addListener(event: 'Runtime.exceptionRevoked', listener: (message: InspectorNotification<Runtime.ExceptionRevokedEventDataType>) => void): this;
        /**
         * Issued when console API was called.
         */
        addListener(event: 'Runtime.consoleAPICalled', listener: (message: InspectorNotification<Runtime.ConsoleAPICalledEventDataType>) => void): this;
        /**
         * Issued when object should be inspected (for example, as a result of inspect() command line API call).
         */
        addListener(event: 'Runtime.inspectRequested', listener: (message: InspectorNotification<Runtime.InspectRequestedEventDataType>) => void): this;
        /**
         * Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
         */
        addListener(event: 'Debugger.scriptParsed', listener: (message: InspectorNotification<Debugger.ScriptParsedEventDataType>) => void): this;
        /**
         * Fired when virtual machine fails to parse the script.
         */
        addListener(event: 'Debugger.scriptFailedToParse', listener: (message: InspectorNotification<Debugger.ScriptFailedToParseEventDataType>) => void): this;
        /**
         * Fired when breakpoint is resolved to an actual script and location.
         */
        addListener(event: 'Debugger.breakpointResolved', listener: (message: InspectorNotification<Debugger.BreakpointResolvedEventDataType>) => void): this;
        /**
         * Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
         */
        addListener(event: 'Debugger.paused', listener: (message: InspectorNotification<Debugger.PausedEventDataType>) => void): this;
        /**
         * Fired when the virtual machine resumed execution.
         */
        addListener(event: 'Debugger.resumed', listener: () => void): this;
        /**
         * Issued when new console message is added.
         */
        addListener(event: 'Console.messageAdded', listener: (message: InspectorNotification<Console.MessageAddedEventDataType>) => void): this;
        /**
         * Sent when new profile recording is started using console.profile() call.
         */
        addListener(event: 'Profiler.consoleProfileStarted', listener: (message: InspectorNotification<Profiler.ConsoleProfileStartedEventDataType>) => void): this;
        addListener(event: 'Profiler.consoleProfileFinished', listener: (message: InspectorNotification<Profiler.ConsoleProfileFinishedEventDataType>) => void): this;
        addListener(event: 'HeapProfiler.addHeapSnapshotChunk', listener: (message: InspectorNotification<HeapProfiler.AddHeapSnapshotChunkEventDataType>) => void): this;
        addListener(event: 'HeapProfiler.resetProfiles', listener: () => void): this;
        addListener(event: 'HeapProfiler.reportHeapSnapshotProgress', listener: (message: InspectorNotification<HeapProfiler.ReportHeapSnapshotProgressEventDataType>) => void): this;
        /**
         * If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
         */
        addListener(event: 'HeapProfiler.lastSeenObjectId', listener: (message: InspectorNotification<HeapProfiler.LastSeenObjectIdEventDataType>) => void): this;
        /**
         * If heap objects tracking has been started then backend may send update for one or more fragments
         */
        addListener(event: 'HeapProfiler.heapStatsUpdate', listener: (message: InspectorNotification<HeapProfiler.HeapStatsUpdateEventDataType>) => void): this;
        /**
         * Contains an bucket of collected trace events.
         */
        addListener(event: 'NodeTracing.dataCollected', listener: (message: InspectorNotification<NodeTracing.DataCollectedEventDataType>) => void): this;
        /**
         * Signals that tracing is stopped and there is no trace buffers pending flush, all data were
         * delivered via dataCollected events.
         */
        addListener(event: 'NodeTracing.tracingComplete', listener: () => void): this;
        /**
         * Issued when attached to a worker.
         */
        addListener(event: 'NodeWorker.attachedToWorker', listener: (message: InspectorNotification<NodeWorker.AttachedToWorkerEventDataType>) => void): this;
        /**
         * Issued when detached from the worker.
         */
        addListener(event: 'NodeWorker.detachedFromWorker', listener: (message: InspectorNotification<NodeWorker.DetachedFromWorkerEventDataType>) => void): this;
        /**
         * Notifies about a new protocol message received from the session
         * (session ID is provided in attachedToWorker notification).
         */
        addListener(event: 'NodeWorker.receivedMessageFromWorker', listener: (message: InspectorNotification<NodeWorker.ReceivedMessageFromWorkerEventDataType>) => void): this;
        /**
         * Fired when page is about to send HTTP request.
         */
        addListener(event: 'Network.requestWillBeSent', listener: (message: InspectorNotification<Network.RequestWillBeSentEventDataType>) => void): this;
        /**
         * Fired when HTTP response is available.
         */
        addListener(event: 'Network.responseReceived', listener: (message: InspectorNotification<Network.ResponseReceivedEventDataType>) => void): this;
        addListener(event: 'Network.loadingFailed', listener: (message: InspectorNotification<Network.LoadingFailedEventDataType>) => void): this;
        addListener(event: 'Network.loadingFinished', listener: (message: InspectorNotification<Network.LoadingFinishedEventDataType>) => void): this;
        /**
         * Fired when data chunk was received over the network.
         */
        addListener(event: 'Network.dataReceived', listener: (message: InspectorNotification<Network.DataReceivedEventDataType>) => void): this;
        /**
         * This event is fired instead of `Runtime.executionContextDestroyed` when
         * enabled.
         * It is fired when the Node process finished all code execution and is
         * waiting for all frontends to disconnect.
         */
        addListener(event: 'NodeRuntime.waitingForDisconnect', listener: () => void): this;
        /**
         * This event is fired when the runtime is waiting for the debugger. For
         * example, when inspector.waitingForDebugger is called
         */
        addListener(event: 'NodeRuntime.waitingForDebugger', listener: () => void): this;
        addListener(event: 'Target.targetCreated', listener: (message: InspectorNotification<Target.TargetCreatedEventDataType>) => void): this;
        addListener(event: 'Target.attachedToTarget', listener: (message: InspectorNotification<Target.AttachedToTargetEventDataType>) => void): this;
        emit(event: string | symbol, ...args: any[]): boolean;
        emit(event: 'inspectorNotification', message: InspectorNotification<object>): boolean;
        emit(event: 'Runtime.executionContextCreated', message: InspectorNotification<Runtime.ExecutionContextCreatedEventDataType>): boolean;
        emit(event: 'Runtime.executionContextDestroyed', message: InspectorNotification<Runtime.ExecutionContextDestroyedEventDataType>): boolean;
        emit(event: 'Runtime.executionContextsCleared'): boolean;
        emit(event: 'Runtime.exceptionThrown', message: InspectorNotification<Runtime.ExceptionThrownEventDataType>): boolean;
        emit(event: 'Runtime.exceptionRevoked', message: InspectorNotification<Runtime.ExceptionRevokedEventDataType>): boolean;
        emit(event: 'Runtime.consoleAPICalled', message: InspectorNotification<Runtime.ConsoleAPICalledEventDataType>): boolean;
        emit(event: 'Runtime.inspectRequested', message: InspectorNotification<Runtime.InspectRequestedEventDataType>): boolean;
        emit(event: 'Debugger.scriptParsed', message: InspectorNotification<Debugger.ScriptParsedEventDataType>): boolean;
        emit(event: 'Debugger.scriptFailedToParse', message: InspectorNotification<Debugger.ScriptFailedToParseEventDataType>): boolean;
        emit(event: 'Debugger.breakpointResolved', message: InspectorNotification<Debugger.BreakpointResolvedEventDataType>): boolean;
        emit(event: 'Debugger.paused', message: InspectorNotification<Debugger.PausedEventDataType>): boolean;
        emit(event: 'Debugger.resumed'): boolean;
        emit(event: 'Console.messageAdded', message: InspectorNotification<Console.MessageAddedEventDataType>): boolean;
        emit(event: 'Profiler.consoleProfileStarted', message: InspectorNotification<Profiler.ConsoleProfileStartedEventDataType>): boolean;
        emit(event: 'Profiler.consoleProfileFinished', message: InspectorNotification<Profiler.ConsoleProfileFinishedEventDataType>): boolean;
        emit(event: 'HeapProfiler.addHeapSnapshotChunk', message: InspectorNotification<HeapProfiler.AddHeapSnapshotChunkEventDataType>): boolean;
        emit(event: 'HeapProfiler.resetProfiles'): boolean;
        emit(event: 'HeapProfiler.reportHeapSnapshotProgress', message: InspectorNotification<HeapProfiler.ReportHeapSnapshotProgressEventDataType>): boolean;
        emit(event: 'HeapProfiler.lastSeenObjectId', message: InspectorNotification<HeapProfiler.LastSeenObjectIdEventDataType>): boolean;
        emit(event: 'HeapProfiler.heapStatsUpdate', message: InspectorNotification<HeapProfiler.HeapStatsUpdateEventDataType>): boolean;
        emit(event: 'NodeTracing.dataCollected', message: InspectorNotification<NodeTracing.DataCollectedEventDataType>): boolean;
        emit(event: 'NodeTracing.tracingComplete'): boolean;
        emit(event: 'NodeWorker.attachedToWorker', message: InspectorNotification<NodeWorker.AttachedToWorkerEventDataType>): boolean;
        emit(event: 'NodeWorker.detachedFromWorker', message: InspectorNotification<NodeWorker.DetachedFromWorkerEventDataType>): boolean;
        emit(event: 'NodeWorker.receivedMessageFromWorker', message: InspectorNotification<NodeWorker.ReceivedMessageFromWorkerEventDataType>): boolean;
        emit(event: 'Network.requestWillBeSent', message: InspectorNotification<Network.RequestWillBeSentEventDataType>): boolean;
        emit(event: 'Network.responseReceived', message: InspectorNotification<Network.ResponseReceivedEventDataType>): boolean;
        emit(event: 'Network.loadingFailed', message: InspectorNotification<Network.LoadingFailedEventDataType>): boolean;
        emit(event: 'Network.loadingFinished', message: InspectorNotification<Network.LoadingFinishedEventDataType>): boolean;
        emit(event: 'Network.dataReceived', message: InspectorNotification<Network.DataReceivedEventDataType>): boolean;
        emit(event: 'NodeRuntime.waitingForDisconnect'): boolean;
        emit(event: 'NodeRuntime.waitingForDebugger'): boolean;
        emit(event: 'Target.targetCreated', message: InspectorNotification<Target.TargetCreatedEventDataType>): boolean;
        emit(event: 'Target.attachedToTarget', message: InspectorNotification<Target.AttachedToTargetEventDataType>): boolean;
        on(event: string, listener: (...args: any[]) => void): this;
        /**
         * Emitted when any notification from the V8 Inspector is received.
         */
        on(event: 'inspectorNotification', listener: (message: InspectorNotification<object>) => void): this;
        /**
         * Issued when new execution context is created.
         */
        on(event: 'Runtime.executionContextCreated', listener: (message: InspectorNotification<Runtime.ExecutionContextCreatedEventDataType>) => void): this;
        /**
         * Issued when execution context is destroyed.
         */
        on(event: 'Runtime.executionContextDestroyed', listener: (message: InspectorNotification<Runtime.ExecutionContextDestroyedEventDataType>) => void): this;
        /**
         * Issued when all executionContexts were cleared in browser
         */
        on(event: 'Runtime.executionContextsCleared', listener: () => void): this;
        /**
         * Issued when exception was thrown and unhandled.
         */
        on(event: 'Runtime.exceptionThrown', listener: (message: InspectorNotification<Runtime.ExceptionThrownEventDataType>) => void): this;
        /**
         * Issued when unhandled exception was revoked.
         */
        on(event: 'Runtime.exceptionRevoked', listener: (message: InspectorNotification<Runtime.ExceptionRevokedEventDataType>) => void): this;
        /**
         * Issued when console API was called.
         */
        on(event: 'Runtime.consoleAPICalled', listener: (message: InspectorNotification<Runtime.ConsoleAPICalledEventDataType>) => void): this;
        /**
         * Issued when object should be inspected (for example, as a result of inspect() command line API call).
         */
        on(event: 'Runtime.inspectRequested', listener: (message: InspectorNotification<Runtime.InspectRequestedEventDataType>) => void): this;
        /**
         * Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
         */
        on(event: 'Debugger.scriptParsed', listener: (message: InspectorNotification<Debugger.ScriptParsedEventDataType>) => void): this;
        /**
         * Fired when virtual machine fails to parse the script.
         */
        on(event: 'Debugger.scriptFailedToParse', listener: (message: InspectorNotification<Debugger.ScriptFailedToParseEventDataType>) => void): this;
        /**
         * Fired when breakpoint is resolved to an actual script and location.
         */
        on(event: 'Debugger.breakpointResolved', listener: (message: InspectorNotification<Debugger.BreakpointResolvedEventDataType>) => void): this;
        /**
         * Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
         */
        on(event: 'Debugger.paused', listener: (message: InspectorNotification<Debugger.PausedEventDataType>) => void): this;
        /**
         * Fired when the virtual machine resumed execution.
         */
        on(event: 'Debugger.resumed', listener: () => void): this;
        /**
         * Issued when new console message is added.
         */
        on(event: 'Console.messageAdded', listener: (message: InspectorNotification<Console.MessageAddedEventDataType>) => void): this;
        /**
         * Sent when new profile recording is started using console.profile() call.
         */
        on(event: 'Profiler.consoleProfileStarted', listener: (message: InspectorNotification<Profiler.ConsoleProfileStartedEventDataType>) => void): this;
        on(event: 'Profiler.consoleProfileFinished', listener: (message: InspectorNotification<Profiler.ConsoleProfileFinishedEventDataType>) => void): this;
        on(event: 'HeapProfiler.addHeapSnapshotChunk', listener: (message: InspectorNotification<HeapProfiler.AddHeapSnapshotChunkEventDataType>) => void): this;
        on(event: 'HeapProfiler.resetProfiles', listener: () => void): this;
        on(event: 'HeapProfiler.reportHeapSnapshotProgress', listener: (message: InspectorNotification<HeapProfiler.ReportHeapSnapshotProgressEventDataType>) => void): this;
        /**
         * If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
         */
        on(event: 'HeapProfiler.lastSeenObjectId', listener: (message: InspectorNotification<HeapProfiler.LastSeenObjectIdEventDataType>) => void): this;
        /**
         * If heap objects tracking has been started then backend may send update for one or more fragments
         */
        on(event: 'HeapProfiler.heapStatsUpdate', listener: (message: InspectorNotification<HeapProfiler.HeapStatsUpdateEventDataType>) => void): this;
        /**
         * Contains an bucket of collected trace events.
         */
        on(event: 'NodeTracing.dataCollected', listener: (message: InspectorNotification<NodeTracing.DataCollectedEventDataType>) => void): this;
        /**
         * Signals that tracing is stopped and there is no trace buffers pending flush, all data were
         * delivered via dataCollected events.
         */
        on(event: 'NodeTracing.tracingComplete', listener: () => void): this;
        /**
         * Issued when attached to a worker.
         */
        on(event: 'NodeWorker.attachedToWorker', listener: (message: InspectorNotification<NodeWorker.AttachedToWorkerEventDataType>) => void): this;
        /**
         * Issued when detached from the worker.
         */
        on(event: 'NodeWorker.detachedFromWorker', listener: (message: InspectorNotification<NodeWorker.DetachedFromWorkerEventDataType>) => void): this;
        /**
         * Notifies about a new protocol message received from the session
         * (session ID is provided in attachedToWorker notification).
         */
        on(event: 'NodeWorker.receivedMessageFromWorker', listener: (message: InspectorNotification<NodeWorker.ReceivedMessageFromWorkerEventDataType>) => void): this;
        /**
         * Fired when page is about to send HTTP request.
         */
        on(event: 'Network.requestWillBeSent', listener: (message: InspectorNotification<Network.RequestWillBeSentEventDataType>) => void): this;
        /**
         * Fired when HTTP response is available.
         */
        on(event: 'Network.responseReceived', listener: (message: InspectorNotification<Network.ResponseReceivedEventDataType>) => void): this;
        on(event: 'Network.loadingFailed', listener: (message: InspectorNotification<Network.LoadingFailedEventDataType>) => void): this;
        on(event: 'Network.loadingFinished', listener: (message: InspectorNotification<Network.LoadingFinishedEventDataType>) => void): this;
        /**
         * Fired when data chunk was received over the network.
         */
        on(event: 'Network.dataReceived', listener: (message: InspectorNotification<Network.DataReceivedEventDataType>) => void): this;
        /**
         * This event is fired instead of `Runtime.executionContextDestroyed` when
         * enabled.
         * It is fired when the Node process finished all code execution and is
         * waiting for all frontends to disconnect.
         */
        on(event: 'NodeRuntime.waitingForDisconnect', listener: () => void): this;
        /**
         * This event is fired when the runtime is waiting for the debugger. For
         * example, when inspector.waitingForDebugger is called
         */
        on(event: 'NodeRuntime.waitingForDebugger', listener: () => void): this;
        on(event: 'Target.targetCreated', listener: (message: InspectorNotification<Target.TargetCreatedEventDataType>) => void): this;
        on(event: 'Target.attachedToTarget', listener: (message: InspectorNotification<Target.AttachedToTargetEventDataType>) => void): this;
        once(event: string, listener: (...args: any[]) => void): this;
        /**
         * Emitted when any notification from the V8 Inspector is received.
         */
        once(event: 'inspectorNotification', listener: (message: InspectorNotification<object>) => void): this;
        /**
         * Issued when new execution context is created.
         */
        once(event: 'Runtime.executionContextCreated', listener: (message: InspectorNotification<Runtime.ExecutionContextCreatedEventDataType>) => void): this;
        /**
         * Issued when execution context is destroyed.
         */
        once(event: 'Runtime.executionContextDestroyed', listener: (message: InspectorNotification<Runtime.ExecutionContextDestroyedEventDataType>) => void): this;
        /**
         * Issued when all executionContexts were cleared in browser
         */
        once(event: 'Runtime.executionContextsCleared', listener: () => void): this;
        /**
         * Issued when exception was thrown and unhandled.
         */
        once(event: 'Runtime.exceptionThrown', listener: (message: InspectorNotification<Runtime.ExceptionThrownEventDataType>) => void): this;
        /**
         * Issued when unhandled exception was revoked.
         */
        once(event: 'Runtime.exceptionRevoked', listener: (message: InspectorNotification<Runtime.ExceptionRevokedEventDataType>) => void): this;
        /**
         * Issued when console API was called.
         */
        once(event: 'Runtime.consoleAPICalled', listener: (message: InspectorNotification<Runtime.ConsoleAPICalledEventDataType>) => void): this;
        /**
         * Issued when object should be inspected (for example, as a result of inspect() command line API call).
         */
        once(event: 'Runtime.inspectRequested', listener: (message: InspectorNotification<Runtime.InspectRequestedEventDataType>) => void): this;
        /**
         * Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
         */
        once(event: 'Debugger.scriptParsed', listener: (message: InspectorNotification<Debugger.ScriptParsedEventDataType>) => void): this;
        /**
         * Fired when virtual machine fails to parse the script.
         */
        once(event: 'Debugger.scriptFailedToParse', listener: (message: InspectorNotification<Debugger.ScriptFailedToParseEventDataType>) => void): this;
        /**
         * Fired when breakpoint is resolved to an actual script and location.
         */
        once(event: 'Debugger.breakpointResolved', listener: (message: InspectorNotification<Debugger.BreakpointResolvedEventDataType>) => void): this;
        /**
         * Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
         */
        once(event: 'Debugger.paused', listener: (message: InspectorNotification<Debugger.PausedEventDataType>) => void): this;
        /**
         * Fired when the virtual machine resumed execution.
         */
        once(event: 'Debugger.resumed', listener: () => void): this;
        /**
         * Issued when new console message is added.
         */
        once(event: 'Console.messageAdded', listener: (message: InspectorNotification<Console.MessageAddedEventDataType>) => void): this;
        /**
         * Sent when new profile recording is started using console.profile() call.
         */
        once(event: 'Profiler.consoleProfileStarted', listener: (message: InspectorNotification<Profiler.ConsoleProfileStartedEventDataType>) => void): this;
        once(event: 'Profiler.consoleProfileFinished', listener: (message: InspectorNotification<Profiler.ConsoleProfileFinishedEventDataType>) => void): this;
        once(event: 'HeapProfiler.addHeapSnapshotChunk', listener: (message: InspectorNotification<HeapProfiler.AddHeapSnapshotChunkEventDataType>) => void): this;
        once(event: 'HeapProfiler.resetProfiles', listener: () => void): this;
        once(event: 'HeapProfiler.reportHeapSnapshotProgress', listener: (message: InspectorNotification<HeapProfiler.ReportHeapSnapshotProgressEventDataType>) => void): this;
        /**
         * If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
         */
        once(event: 'HeapProfiler.lastSeenObjectId', listener: (message: InspectorNotification<HeapProfiler.LastSeenObjectIdEventDataType>) => void): this;
        /**
         * If heap objects tracking has been started then backend may send update for one or more fragments
         */
        once(event: 'HeapProfiler.heapStatsUpdate', listener: (message: InspectorNotification<HeapProfiler.HeapStatsUpdateEventDataType>) => void): this;
        /**
         * Contains an bucket of collected trace events.
         */
        once(event: 'NodeTracing.dataCollected', listener: (message: InspectorNotification<NodeTracing.DataCollectedEventDataType>) => void): this;
        /**
         * Signals that tracing is stopped and there is no trace buffers pending flush, all data were
         * delivered via dataCollected events.
         */
        once(event: 'NodeTracing.tracingComplete', listener: () => void): this;
        /**
         * Issued when attached to a worker.
         */
        once(event: 'NodeWorker.attachedToWorker', listener: (message: InspectorNotification<NodeWorker.AttachedToWorkerEventDataType>) => void): this;
        /**
         * Issued when detached from the worker.
         */
        once(event: 'NodeWorker.detachedFromWorker', listener: (message: InspectorNotification<NodeWorker.DetachedFromWorkerEventDataType>) => void): this;
        /**
         * Notifies about a new protocol message received from the session
         * (session ID is provided in attachedToWorker notification).
         */
        once(event: 'NodeWorker.receivedMessageFromWorker', listener: (message: InspectorNotification<NodeWorker.ReceivedMessageFromWorkerEventDataType>) => void): this;
        /**
         * Fired when page is about to send HTTP request.
         */
        once(event: 'Network.requestWillBeSent', listener: (message: InspectorNotification<Network.RequestWillBeSentEventDataType>) => void): this;
        /**
         * Fired when HTTP response is available.
         */
        once(event: 'Network.responseReceived', listener: (message: InspectorNotification<Network.ResponseReceivedEventDataType>) => void): this;
        once(event: 'Network.loadingFailed', listener: (message: InspectorNotification<Network.LoadingFailedEventDataType>) => void): this;
        once(event: 'Network.loadingFinished', listener: (message: InspectorNotification<Network.LoadingFinishedEventDataType>) => void): this;
        /**
         * Fired when data chunk was received over the network.
         */
        once(event: 'Network.dataReceived', listener: (message: InspectorNotification<Network.DataReceivedEventDataType>) => void): this;
        /**
         * This event is fired instead of `Runtime.executionContextDestroyed` when
         * enabled.
         * It is fired when the Node process finished all code execution and is
         * waiting for all frontends to disconnect.
         */
        once(event: 'NodeRuntime.waitingForDisconnect', listener: () => void): this;
        /**
         * This event is fired when the runtime is waiting for the debugger. For
         * example, when inspector.waitingForDebugger is called
         */
        once(event: 'NodeRuntime.waitingForDebugger', listener: () => void): this;
        once(event: 'Target.targetCreated', listener: (message: InspectorNotification<Target.TargetCreatedEventDataType>) => void): this;
        once(event: 'Target.attachedToTarget', listener: (message: InspectorNotification<Target.AttachedToTargetEventDataType>) => void): this;
        prependListener(event: string, listener: (...args: any[]) => void): this;
        /**
         * Emitted when any notification from the V8 Inspector is received.
         */
        prependListener(event: 'inspectorNotification', listener: (message: InspectorNotification<object>) => void): this;
        /**
         * Issued when new execution context is created.
         */
        prependListener(event: 'Runtime.executionContextCreated', listener: (message: InspectorNotification<Runtime.ExecutionContextCreatedEventDataType>) => void): this;
        /**
         * Issued when execution context is destroyed.
         */
        prependListener(event: 'Runtime.executionContextDestroyed', listener: (message: InspectorNotification<Runtime.ExecutionContextDestroyedEventDataType>) => void): this;
        /**
         * Issued when all executionContexts were cleared in browser
         */
        prependListener(event: 'Runtime.executionContextsCleared', listener: () => void): this;
        /**
         * Issued when exception was thrown and unhandled.
         */
        prependListener(event: 'Runtime.exceptionThrown', listener: (message: InspectorNotification<Runtime.ExceptionThrownEventDataType>) => void): this;
        /**
         * Issued when unhandled exception was revoked.
         */
        prependListener(event: 'Runtime.exceptionRevoked', listener: (message: InspectorNotification<Runtime.ExceptionRevokedEventDataType>) => void): this;
        /**
         * Issued when console API was called.
         */
        prependListener(event: 'Runtime.consoleAPICalled', listener: (message: InspectorNotification<Runtime.ConsoleAPICalledEventDataType>) => void): this;
        /**
         * Issued when object should be inspected (for example, as a result of inspect() command line API call).
         */
        prependListener(event: 'Runtime.inspectRequested', listener: (message: InspectorNotification<Runtime.InspectRequestedEventDataType>) => void): this;
        /**
         * Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
         */
        prependListener(event: 'Debugger.scriptParsed', listener: (message: InspectorNotification<Debugger.ScriptParsedEventDataType>) => void): this;
        /**
         * Fired when virtual machine fails to parse the script.
         */
        prependListener(event: 'Debugger.scriptFailedToParse', listener: (message: InspectorNotification<Debugger.ScriptFailedToParseEventDataType>) => void): this;
        /**
         * Fired when breakpoint is resolved to an actual script and location.
         */
        prependListener(event: 'Debugger.breakpointResolved', listener: (message: InspectorNotification<Debugger.BreakpointResolvedEventDataType>) => void): this;
        /**
         * Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
         */
        prependListener(event: 'Debugger.paused', listener: (message: InspectorNotification<Debugger.PausedEventDataType>) => void): this;
        /**
         * Fired when the virtual machine resumed execution.
         */
        prependListener(event: 'Debugger.resumed', listener: () => void): this;
        /**
         * Issued when new console message is added.
         */
        prependListener(event: 'Console.messageAdded', listener: (message: InspectorNotification<Console.MessageAddedEventDataType>) => void): this;
        /**
         * Sent when new profile recording is started using console.profile() call.
         */
        prependListener(event: 'Profiler.consoleProfileStarted', listener: (message: InspectorNotification<Profiler.ConsoleProfileStartedEventDataType>) => void): this;
        prependListener(event: 'Profiler.consoleProfileFinished', listener: (message: InspectorNotification<Profiler.ConsoleProfileFinishedEventDataType>) => void): this;
        prependListener(event: 'HeapProfiler.addHeapSnapshotChunk', listener: (message: InspectorNotification<HeapProfiler.AddHeapSnapshotChunkEventDataType>) => void): this;
        prependListener(event: 'HeapProfiler.resetProfiles', listener: () => void): this;
        prependListener(event: 'HeapProfiler.reportHeapSnapshotProgress', listener: (message: InspectorNotification<HeapProfiler.ReportHeapSnapshotProgressEventDataType>) => void): this;
        /**
         * If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
         */
        prependListener(event: 'HeapProfiler.lastSeenObjectId', listener: (message: InspectorNotification<HeapProfiler.LastSeenObjectIdEventDataType>) => void): this;
        /**
         * If heap objects tracking has been started then backend may send update for one or more fragments
         */
        prependListener(event: 'HeapProfiler.heapStatsUpdate', listener: (message: InspectorNotification<HeapProfiler.HeapStatsUpdateEventDataType>) => void): this;
        /**
         * Contains an bucket of collected trace events.
         */
        prependListener(event: 'NodeTracing.dataCollected', listener: (message: InspectorNotification<NodeTracing.DataCollectedEventDataType>) => void): this;
        /**
         * Signals that tracing is stopped and there is no trace buffers pending flush, all data were
         * delivered via dataCollected events.
         */
        prependListener(event: 'NodeTracing.tracingComplete', listener: () => void): this;
        /**
         * Issued when attached to a worker.
         */
        prependListener(event: 'NodeWorker.attachedToWorker', listener: (message: InspectorNotification<NodeWorker.AttachedToWorkerEventDataType>) => void): this;
        /**
         * Issued when detached from the worker.
         */
        prependListener(event: 'NodeWorker.detachedFromWorker', listener: (message: InspectorNotification<NodeWorker.DetachedFromWorkerEventDataType>) => void): this;
        /**
         * Notifies about a new protocol message received from the session
         * (session ID is provided in attachedToWorker notification).
         */
        prependListener(event: 'NodeWorker.receivedMessageFromWorker', listener: (message: InspectorNotification<NodeWorker.ReceivedMessageFromWorkerEventDataType>) => void): this;
        /**
         * Fired when page is about to send HTTP request.
         */
        prependListener(event: 'Network.requestWillBeSent', listener: (message: InspectorNotification<Network.RequestWillBeSentEventDataType>) => void): this;
        /**
         * Fired when HTTP response is available.
         */
        prependListener(event: 'Network.responseReceived', listener: (message: InspectorNotification<Network.ResponseReceivedEventDataType>) => void): this;
        prependListener(event: 'Network.loadingFailed', listener: (message: InspectorNotification<Network.LoadingFailedEventDataType>) => void): this;
        prependListener(event: 'Network.loadingFinished', listener: (message: InspectorNotification<Network.LoadingFinishedEventDataType>) => void): this;
        /**
         * Fired when data chunk was received over the network.
         */
        prependListener(event: 'Network.dataReceived', listener: (message: InspectorNotification<Network.DataReceivedEventDataType>) => void): this;
        /**
         * This event is fired instead of `Runtime.executionContextDestroyed` when
         * enabled.
         * It is fired when the Node process finished all code execution and is
         * waiting for all frontends to disconnect.
         */
        prependListener(event: 'NodeRuntime.waitingForDisconnect', listener: () => void): this;
        /**
         * This event is fired when the runtime is waiting for the debugger. For
         * example, when inspector.waitingForDebugger is called
         */
        prependListener(event: 'NodeRuntime.waitingForDebugger', listener: () => void): this;
        prependListener(event: 'Target.targetCreated', listener: (message: InspectorNotification<Target.TargetCreatedEventDataType>) => void): this;
        prependListener(event: 'Target.attachedToTarget', listener: (message: InspectorNotification<Target.AttachedToTargetEventDataType>) => void): this;
        prependOnceListener(event: string, listener: (...args: any[]) => void): this;
        /**
         * Emitted when any notification from the V8 Inspector is received.
         */
        prependOnceListener(event: 'inspectorNotification', listener: (message: InspectorNotification<object>) => void): this;
        /**
         * Issued when new execution context is created.
         */
        prependOnceListener(event: 'Runtime.executionContextCreated', listener: (message: InspectorNotification<Runtime.ExecutionContextCreatedEventDataType>) => void): this;
        /**
         * Issued when execution context is destroyed.
         */
        prependOnceListener(event: 'Runtime.executionContextDestroyed', listener: (message: InspectorNotification<Runtime.ExecutionContextDestroyedEventDataType>) => void): this;
        /**
         * Issued when all executionContexts were cleared in browser
         */
        prependOnceListener(event: 'Runtime.executionContextsCleared', listener: () => void): this;
        /**
         * Issued when exception was thrown and unhandled.
         */
        prependOnceListener(event: 'Runtime.exceptionThrown', listener: (message: InspectorNotification<Runtime.ExceptionThrownEventDataType>) => void): this;
        /**
         * Issued when unhandled exception was revoked.
         */
        prependOnceListener(event: 'Runtime.exceptionRevoked', listener: (message: InspectorNotification<Runtime.ExceptionRevokedEventDataType>) => void): this;
        /**
         * Issued when console API was called.
         */
        prependOnceListener(event: 'Runtime.consoleAPICalled', listener: (message: InspectorNotification<Runtime.ConsoleAPICalledEventDataType>) => void): this;
        /**
         * Issued when object should be inspected (for example, as a result of inspect() command line API call).
         */
        prependOnceListener(event: 'Runtime.inspectRequested', listener: (message: InspectorNotification<Runtime.InspectRequestedEventDataType>) => void): this;
        /**
         * Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
         */
        prependOnceListener(event: 'Debugger.scriptParsed', listener: (message: InspectorNotification<Debugger.ScriptParsedEventDataType>) => void): this;
        /**
         * Fired when virtual machine fails to parse the script.
         */
        prependOnceListener(event: 'Debugger.scriptFailedToParse', listener: (message: InspectorNotification<Debugger.ScriptFailedToParseEventDataType>) => void): this;
        /**
         * Fired when breakpoint is resolved to an actual script and location.
         */
        prependOnceListener(event: 'Debugger.breakpointResolved', listener: (message: InspectorNotification<Debugger.BreakpointResolvedEventDataType>) => void): this;
        /**
         * Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
         */
        prependOnceListener(event: 'Debugger.paused', listener: (message: InspectorNotification<Debugger.PausedEventDataType>) => void): this;
        /**
         * Fired when the virtual machine resumed execution.
         */
        prependOnceListener(event: 'Debugger.resumed', listener: () => void): this;
        /**
         * Issued when new console message is added.
         */
        prependOnceListener(event: 'Console.messageAdded', listener: (message: InspectorNotification<Console.MessageAddedEventDataType>) => void): this;
        /**
         * Sent when new profile recording is started using console.profile() call.
         */
        prependOnceListener(event: 'Profiler.consoleProfileStarted', listener: (message: InspectorNotification<Profiler.ConsoleProfileStartedEventDataType>) => void): this;
        prependOnceListener(event: 'Profiler.consoleProfileFinished', listener: (message: InspectorNotification<Profiler.ConsoleProfileFinishedEventDataType>) => void): this;
        prependOnceListener(event: 'HeapProfiler.addHeapSnapshotChunk', listener: (message: InspectorNotification<HeapProfiler.AddHeapSnapshotChunkEventDataType>) => void): this;
        prependOnceListener(event: 'HeapProfiler.resetProfiles', listener: () => void): this;
        prependOnceListener(event: 'HeapProfiler.reportHeapSnapshotProgress', listener: (message: InspectorNotification<HeapProfiler.ReportHeapSnapshotProgressEventDataType>) => void): this;
        /**
         * If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
         */
        prependOnceListener(event: 'HeapProfiler.lastSeenObjectId', listener: (message: InspectorNotification<HeapProfiler.LastSeenObjectIdEventDataType>) => void): this;
        /**
         * If heap objects tracking has been started then backend may send update for one or more fragments
         */
        prependOnceListener(event: 'HeapProfiler.heapStatsUpdate', listener: (message: InspectorNotification<HeapProfiler.HeapStatsUpdateEventDataType>) => void): this;
        /**
         * Contains an bucket of collected trace events.
         */
        prependOnceListener(event: 'NodeTracing.dataCollected', listener: (message: InspectorNotification<NodeTracing.DataCollectedEventDataType>) => void): this;
        /**
         * Signals that tracing is stopped and there is no trace buffers pending flush, all data were
         * delivered via dataCollected events.
         */
        prependOnceListener(event: 'NodeTracing.tracingComplete', listener: () => void): this;
        /**
         * Issued when attached to a worker.
         */
        prependOnceListener(event: 'NodeWorker.attachedToWorker', listener: (message: InspectorNotification<NodeWorker.AttachedToWorkerEventDataType>) => void): this;
        /**
         * Issued when detached from the worker.
         */
        prependOnceListener(event: 'NodeWorker.detachedFromWorker', listener: (message: InspectorNotification<NodeWorker.DetachedFromWorkerEventDataType>) => void): this;
        /**
         * Notifies about a new protocol message received from the session
         * (session ID is provided in attachedToWorker notification).
         */
        prependOnceListener(event: 'NodeWorker.receivedMessageFromWorker', listener: (message: InspectorNotification<NodeWorker.ReceivedMessageFromWorkerEventDataType>) => void): this;
        /**
         * Fired when page is about to send HTTP request.
         */
        prependOnceListener(event: 'Network.requestWillBeSent', listener: (message: InspectorNotification<Network.RequestWillBeSentEventDataType>) => void): this;
        /**
         * Fired when HTTP response is available.
         */
        prependOnceListener(event: 'Network.responseReceived', listener: (message: InspectorNotification<Network.ResponseReceivedEventDataType>) => void): this;
        prependOnceListener(event: 'Network.loadingFailed', listener: (message: InspectorNotification<Network.LoadingFailedEventDataType>) => void): this;
        prependOnceListener(event: 'Network.loadingFinished', listener: (message: InspectorNotification<Network.LoadingFinishedEventDataType>) => void): this;
        /**
         * Fired when data chunk was received over the network.
         */
        prependOnceListener(event: 'Network.dataReceived', listener: (message: InspectorNotification<Network.DataReceivedEventDataType>) => void): this;
        /**
         * This event is fired instead of `Runtime.executionContextDestroyed` when
         * enabled.
         * It is fired when the Node process finished all code execution and is
         * waiting for all frontends to disconnect.
         */
        prependOnceListener(event: 'NodeRuntime.waitingForDisconnect', listener: () => void): this;
        /**
         * This event is fired when the runtime is waiting for the debugger. For
         * example, when inspector.waitingForDebugger is called
         */
        prependOnceListener(event: 'NodeRuntime.waitingForDebugger', listener: () => void): this;
        prependOnceListener(event: 'Target.targetCreated', listener: (message: InspectorNotification<Target.TargetCreatedEventDataType>) => void): this;
        prependOnceListener(event: 'Target.attachedToTarget', listener: (message: InspectorNotification<Target.AttachedToTargetEventDataType>) => void): this;
    }

    /**
     * Activate inspector on host and port. Equivalent to `node --inspect=[[host:]port]`, but can be done programmatically after node has
     * started.
     *
     * If wait is `true`, will block until a client has connected to the inspect port
     * and flow control has been passed to the debugger client.
     *
     * See the [security warning](https://nodejs.org/docs/latest-v22.x/api/cli.html#warning-binding-inspector-to-a-public-ipport-combination-is-insecure)
     * regarding the `host` parameter usage.
     * @param port Port to listen on for inspector connections. Defaults to what was specified on the CLI.
     * @param host Host to listen on for inspector connections. Defaults to what was specified on the CLI.
     * @param wait Block until a client has connected. Defaults to what was specified on the CLI.
     * @returns Disposable that calls `inspector.close()`.
     */
    function open(port?: number, host?: string, wait?: boolean): Disposable;

    /**
     * Deactivate the inspector. Blocks until there are no active connections.
     */
    function close(): void;

    /**
     * Return the URL of the active inspector, or `undefined` if there is none.
     *
     * ```console
     * $ node --inspect -p 'inspector.url()'
     * Debugger listening on ws://127.0.0.1:9229/166e272e-7a30-4d09-97ce-f1c012b43c34
     * For help, see: https://nodejs.org/en/docs/inspector
     * ws://127.0.0.1:9229/166e272e-7a30-4d09-97ce-f1c012b43c34
     *
     * $ node --inspect=localhost:3000 -p 'inspector.url()'
     * Debugger listening on ws://localhost:3000/51cf8d0e-3c36-4c59-8efd-54519839e56a
     * For help, see: https://nodejs.org/en/docs/inspector
     * ws://localhost:3000/51cf8d0e-3c36-4c59-8efd-54519839e56a
     *
     * $ node -p 'inspector.url()'
     * undefined
     * ```
     */
    function url(): string | undefined;

    /**
     * Blocks until a client (existing or connected later) has sent `Runtime.runIfWaitingForDebugger` command.
     *
     * An exception will be thrown if there is no active inspector.
     * @since v12.7.0
     */
    function waitForDebugger(): void;

    // These methods are exposed by the V8 inspector console API (inspector/v8-console.h).
    // The method signatures differ from those of the Node.js console, and are deliberately
    // typed permissively.
    interface InspectorConsole {
        debug(...data: any[]): void;
        error(...data: any[]): void;
        info(...data: any[]): void;
        log(...data: any[]): void;
        warn(...data: any[]): void;
        dir(...data: any[]): void;
        dirxml(...data: any[]): void;
        table(...data: any[]): void;
        trace(...data: any[]): void;
        group(...data: any[]): void;
        groupCollapsed(...data: any[]): void;
        groupEnd(...data: any[]): void;
        clear(...data: any[]): void;
        count(label?: any): void;
        countReset(label?: any): void;
        assert(value?: any, ...data: any[]): void;
        profile(label?: any): void;
        profileEnd(label?: any): void;
        time(label?: any): void;
        timeLog(label?: any): void;
        timeStamp(label?: any): void;
    }

    /**
     * An object to send messages to the remote inspector console.
     * @since v11.0.0
     */
    const console: InspectorConsole;

    // DevTools protocol event broadcast methods
    namespace Network {
        /**
         * This feature is only available with the `--experimental-network-inspection` flag enabled.
         *
         * Broadcasts the `Network.requestWillBeSent` event to connected frontends. This event indicates that
         * the application is about to send an HTTP request.
         * @since v22.6.0
         */
        function requestWillBeSent(params: RequestWillBeSentEventDataType): void;
        /**
         * This feature is only available with the `--experimental-network-inspection` flag enabled.
         *
         * Broadcasts the `Network.dataReceived` event to connected frontends, or buffers the data if
         * `Network.streamResourceContent` command was not invoked for the given request yet.
         *
         * Also enables `Network.getResponseBody` command to retrieve the response data.
         * @since v22.17.0
         */
        function dataReceived(params: DataReceivedEventDataType): void;
        /**
         * This feature is only available with the `--experimental-network-inspection` flag enabled.
         *
         * Enables `Network.getRequestPostData` command to retrieve the request data.
         * @since v22.18.0
         */
        function dataSent(params: unknown): void;
        /**
         * This feature is only available with the `--experimental-network-inspection` flag enabled.
         *
         * Broadcasts the `Network.responseReceived` event to connected frontends. This event indicates that
         * HTTP response is available.
         * @since v22.6.0
         */
        function responseReceived(params: ResponseReceivedEventDataType): void;
        /**
         * This feature is only available with the `--experimental-network-inspection` flag enabled.
         *
         * Broadcasts the `Network.loadingFinished` event to connected frontends. This event indicates that
         * HTTP request has finished loading.
         * @since v22.6.0
         */
        function loadingFinished(params: LoadingFinishedEventDataType): void;
        /**
         * This feature is only available with the `--experimental-network-inspection` flag enabled.
         *
         * Broadcasts the `Network.loadingFailed` event to connected frontends. This event indicates that
         * HTTP request has failed to load.
         * @since v22.7.0
         */
        function loadingFailed(params: LoadingFailedEventDataType): void;
    }
}

/**
 * The `node:inspector` module provides an API for interacting with the V8
 * inspector.
 */
declare module 'node:inspector' {
    export * from 'inspector';
}

/**
 * The `node:inspector/promises` module provides an API for interacting with the V8
 * inspector.
 * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/inspector/promises.js)
 * @since v19.0.0
 */
declare module 'inspector/promises' {
    import EventEmitter = require('node:events');
    import {
        open,
        close,
        url,
        waitForDebugger,
        console,
        InspectorNotification,
        Schema,
        Runtime,
        Debugger,
        Console,
        Profiler,
        HeapProfiler,
        NodeTracing,
        NodeWorker,
        Network,
        NodeRuntime,
        Target,
    } from 'inspector';

    /**
     * The `inspector.Session` is used for dispatching messages to the V8 inspector
     * back-end and receiving message responses and notifications.
     * @since v19.0.0
     */
    class Session extends EventEmitter {
        /**
         * Create a new instance of the `inspector.Session` class.
         * The inspector session needs to be connected through `session.connect()` before the messages can be dispatched to the inspector backend.
         */
        constructor();

        /**
         * Connects a session to the inspector back-end.
         */
        connect(): void;

        /**
         * Connects a session to the inspector back-end.
         * An exception will be thrown if this API was not called on a Worker thread.
         */
        connectToMainThread(): void;

        /**
         * Immediately close the session. All pending message callbacks will be called with an error.
         * `session.connect()` will need to be called to be able to send messages again.
         * Reconnected session will lose all inspector state, such as enabled agents or configured breakpoints.
         */
        disconnect(): void;

        /**
         * Posts a message to the inspector back-end.
         *
         * ```js
         * import { Session } from 'node:inspector/promises';
         * try {
         *   const session = new Session();
         *   session.connect();
         *   const result = await session.post('Runtime.evaluate', { expression: '2 + 2' });
         *   console.log(result);
         * } catch (error) {
         *   console.error(error);
         * }
         * // Output: { result: { type: 'number', value: 4, description: '4' } }
         * ```
         *
         * The latest version of the V8 inspector protocol is published on the
         * [Chrome DevTools Protocol Viewer](https://chromedevtools.github.io/devtools-protocol/v8/).
         *
         * Node.js inspector supports all the Chrome DevTools Protocol domains declared
         * by V8. Chrome DevTools Protocol domain provides an interface for interacting
         * with one of the runtime agents used to inspect the application state and listen
         * to the run-time events.
         */
        post(method: string, params?: object): Promise<void>;
        /**
         * Returns supported domains.
         */
        post(method: 'Schema.getDomains'): Promise<Schema.GetDomainsReturnType>;
        /**
         * Evaluates expression on global object.
         */
        post(method: 'Runtime.evaluate', params?: Runtime.EvaluateParameterType): Promise<Runtime.EvaluateReturnType>;
        /**
         * Add handler to promise with given promise object id.
         */
        post(method: 'Runtime.awaitPromise', params?: Runtime.AwaitPromiseParameterType): Promise<Runtime.AwaitPromiseReturnType>;
        /**
         * Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
         */
        post(method: 'Runtime.callFunctionOn', params?: Runtime.CallFunctionOnParameterType): Promise<Runtime.CallFunctionOnReturnType>;
        /**
         * Returns properties of a given object. Object group of the result is inherited from the target object.
         */
        post(method: 'Runtime.getProperties', params?: Runtime.GetPropertiesParameterType): Promise<Runtime.GetPropertiesReturnType>;
        /**
         * Releases remote object with given id.
         */
        post(method: 'Runtime.releaseObject', params?: Runtime.ReleaseObjectParameterType): Promise<void>;
        /**
         * Releases all remote objects that belong to a given group.
         */
        post(method: 'Runtime.releaseObjectGroup', params?: Runtime.ReleaseObjectGroupParameterType): Promise<void>;
        /**
         * Tells inspected instance to run if it was waiting for debugger to attach.
         */
        post(method: 'Runtime.runIfWaitingForDebugger'): Promise<void>;
        /**
         * Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
         */
        post(method: 'Runtime.enable'): Promise<void>;
        /**
         * Disables reporting of execution contexts creation.
         */
        post(method: 'Runtime.disable'): Promise<void>;
        /**
         * Discards collected exceptions and console API calls.
         */
        post(method: 'Runtime.discardConsoleEntries'): Promise<void>;
        /**
         * @experimental
         */
        post(method: 'Runtime.setCustomObjectFormatterEnabled', params?: Runtime.SetCustomObjectFormatterEnabledParameterType): Promise<void>;
        /**
         * Compiles expression.
         */
        post(method: 'Runtime.compileScript', params?: Runtime.CompileScriptParameterType): Promise<Runtime.CompileScriptReturnType>;
        /**
         * Runs script with given id in a given context.
         */
        post(method: 'Runtime.runScript', params?: Runtime.RunScriptParameterType): Promise<Runtime.RunScriptReturnType>;
        post(method: 'Runtime.queryObjects', params?: Runtime.QueryObjectsParameterType): Promise<Runtime.QueryObjectsReturnType>;
        /**
         * Returns all let, const and class variables from global scope.
         */
        post(method: 'Runtime.globalLexicalScopeNames', params?: Runtime.GlobalLexicalScopeNamesParameterType): Promise<Runtime.GlobalLexicalScopeNamesReturnType>;
        /**
         * Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
         */
        post(method: 'Debugger.enable'): Promise<Debugger.EnableReturnType>;
        /**
         * Disables debugger for given page.
         */
        post(method: 'Debugger.disable'): Promise<void>;
        /**
         * Activates / deactivates all breakpoints on the page.
         */
        post(method: 'Debugger.setBreakpointsActive', params?: Debugger.SetBreakpointsActiveParameterType): Promise<void>;
        /**
         * Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
         */
        post(method: 'Debugger.setSkipAllPauses', params?: Debugger.SetSkipAllPausesParameterType): Promise<void>;
        /**
         * Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
         */
        post(method: 'Debugger.setBreakpointByUrl', params?: Debugger.SetBreakpointByUrlParameterType): Promise<Debugger.SetBreakpointByUrlReturnType>;
        /**
         * Sets JavaScript breakpoint at a given location.
         */
        post(method: 'Debugger.setBreakpoint', params?: Debugger.SetBreakpointParameterType): Promise<Debugger.SetBreakpointReturnType>;
        /**
         * Removes JavaScript breakpoint.
         */
        post(method: 'Debugger.removeBreakpoint', params?: Debugger.RemoveBreakpointParameterType): Promise<void>;
        /**
         * Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
         */
        post(method: 'Debugger.getPossibleBreakpoints', params?: Debugger.GetPossibleBreakpointsParameterType): Promise<Debugger.GetPossibleBreakpointsReturnType>;
        /**
         * Continues execution until specific location is reached.
         */
        post(method: 'Debugger.continueToLocation', params?: Debugger.ContinueToLocationParameterType): Promise<void>;
        /**
         * @experimental
         */
        post(method: 'Debugger.pauseOnAsyncCall', params?: Debugger.PauseOnAsyncCallParameterType): Promise<void>;
        /**
         * Steps over the statement.
         */
        post(method: 'Debugger.stepOver'): Promise<void>;
        /**
         * Steps into the function call.
         */
        post(method: 'Debugger.stepInto', params?: Debugger.StepIntoParameterType): Promise<void>;
        /**
         * Steps out of the function call.
         */
        post(method: 'Debugger.stepOut'): Promise<void>;
        /**
         * Stops on the next JavaScript statement.
         */
        post(method: 'Debugger.pause'): Promise<void>;
        /**
         * This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
         * @experimental
         */
        post(method: 'Debugger.scheduleStepIntoAsync'): Promise<void>;
        /**
         * Resumes JavaScript execution.
         */
        post(method: 'Debugger.resume'): Promise<void>;
        /**
         * Returns stack trace with given <code>stackTraceId</code>.
         * @experimental
         */
        post(method: 'Debugger.getStackTrace', params?: Debugger.GetStackTraceParameterType): Promise<Debugger.GetStackTraceReturnType>;
        /**
         * Searches for given string in script content.
         */
        post(method: 'Debugger.searchInContent', params?: Debugger.SearchInContentParameterType): Promise<Debugger.SearchInContentReturnType>;
        /**
         * Edits JavaScript source live.
         */
        post(method: 'Debugger.setScriptSource', params?: Debugger.SetScriptSourceParameterType): Promise<Debugger.SetScriptSourceReturnType>;
        /**
         * Restarts particular call frame from the beginning.
         */
        post(method: 'Debugger.restartFrame', params?: Debugger.RestartFrameParameterType): Promise<Debugger.RestartFrameReturnType>;
        /**
         * Returns source for the script with given id.
         */
        post(method: 'Debugger.getScriptSource', params?: Debugger.GetScriptSourceParameterType): Promise<Debugger.GetScriptSourceReturnType>;
        /**
         * Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
         */
        post(method: 'Debugger.setPauseOnExceptions', params?: Debugger.SetPauseOnExceptionsParameterType): Promise<void>;
        /**
         * Evaluates expression on a given call frame.
         */
        post(method: 'Debugger.evaluateOnCallFrame', params?: Debugger.EvaluateOnCallFrameParameterType): Promise<Debugger.EvaluateOnCallFrameReturnType>;
        /**
         * Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
         */
        post(method: 'Debugger.setVariableValue', params?: Debugger.SetVariableValueParameterType): Promise<void>;
        /**
         * Changes return value in top frame. Available only at return break position.
         * @experimental
         */
        post(method: 'Debugger.setReturnValue', params?: Debugger.SetReturnValueParameterType): Promise<void>;
        /**
         * Enables or disables async call stacks tracking.
         */
        post(method: 'Debugger.setAsyncCallStackDepth', params?: Debugger.SetAsyncCallStackDepthParameterType): Promise<void>;
        /**
         * Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
         * @experimental
         */
        post(method: 'Debugger.setBlackboxPatterns', params?: Debugger.SetBlackboxPatternsParameterType): Promise<void>;
        /**
         * Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
         * @experimental
         */
        post(method: 'Debugger.setBlackboxedRanges', params?: Debugger.SetBlackboxedRangesParameterType): Promise<void>;
        /**
         * Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
         */
        post(method: 'Console.enable'): Promise<void>;
        /**
         * Disables console domain, prevents further console messages from being reported to the client.
         */
        post(method: 'Console.disable'): Promise<void>;
        /**
         * Does nothing.
         */
        post(method: 'Console.clearMessages'): Promise<void>;
        post(method: 'Profiler.enable'): Promise<void>;
        post(method: 'Profiler.disable'): Promise<void>;
        /**
         * Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
         */
        post(method: 'Profiler.setSamplingInterval', params?: Profiler.SetSamplingIntervalParameterType): Promise<void>;
        post(method: 'Profiler.start'): Promise<void>;
        post(method: 'Profiler.stop'): Promise<Profiler.StopReturnType>;
        /**
         * Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
         */
        post(method: 'Profiler.startPreciseCoverage', params?: Profiler.StartPreciseCoverageParameterType): Promise<void>;
        /**
         * Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
         */
        post(method: 'Profiler.stopPreciseCoverage'): Promise<void>;
        /**
         * Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
         */
        post(method: 'Profiler.takePreciseCoverage'): Promise<Profiler.TakePreciseCoverageReturnType>;
        /**
         * Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
         */
        post(method: 'Profiler.getBestEffortCoverage'): Promise<Profiler.GetBestEffortCoverageReturnType>;
        post(method: 'HeapProfiler.enable'): Promise<void>;
        post(method: 'HeapProfiler.disable'): Promise<void>;
        post(method: 'HeapProfiler.startTrackingHeapObjects', params?: HeapProfiler.StartTrackingHeapObjectsParameterType): Promise<void>;
        post(method: 'HeapProfiler.stopTrackingHeapObjects', params?: HeapProfiler.StopTrackingHeapObjectsParameterType): Promise<void>;
        post(method: 'HeapProfiler.takeHeapSnapshot', params?: HeapProfiler.TakeHeapSnapshotParameterType): Promise<void>;
        post(method: 'HeapProfiler.collectGarbage'): Promise<void>;
        post(method: 'HeapProfiler.getObjectByHeapObjectId', params?: HeapProfiler.GetObjectByHeapObjectIdParameterType): Promise<HeapProfiler.GetObjectByHeapObjectIdReturnType>;
        /**
         * Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
         */
        post(method: 'HeapProfiler.addInspectedHeapObject', params?: HeapProfiler.AddInspectedHeapObjectParameterType): Promise<void>;
        post(method: 'HeapProfiler.getHeapObjectId', params?: HeapProfiler.GetHeapObjectIdParameterType): Promise<HeapProfiler.GetHeapObjectIdReturnType>;
        post(method: 'HeapProfiler.startSampling', params?: HeapProfiler.StartSamplingParameterType): Promise<void>;
        post(method: 'HeapProfiler.stopSampling'): Promise<HeapProfiler.StopSamplingReturnType>;
        post(method: 'HeapProfiler.getSamplingProfile'): Promise<HeapProfiler.GetSamplingProfileReturnType>;
        /**
         * Gets supported tracing categories.
         */
        post(method: 'NodeTracing.getCategories'): Promise<NodeTracing.GetCategoriesReturnType>;
        /**
         * Start trace events collection.
         */
        post(method: 'NodeTracing.start', params?: NodeTracing.StartParameterType): Promise<void>;
        /**
         * Stop trace events collection. Remaining collected events will be sent as a sequence of
         * dataCollected events followed by tracingComplete event.
         */
        post(method: 'NodeTracing.stop'): Promise<void>;
        /**
         * Sends protocol message over session with given id.
         */
        post(method: 'NodeWorker.sendMessageToWorker', params?: NodeWorker.SendMessageToWorkerParameterType): Promise<void>;
        /**
         * Instructs the inspector to attach to running workers. Will also attach to new workers
         * as they start
         */
        post(method: 'NodeWorker.enable', params?: NodeWorker.EnableParameterType): Promise<void>;
        /**
         * Detaches from all running workers and disables attaching to new workers as they are started.
         */
        post(method: 'NodeWorker.disable'): Promise<void>;
        /**
         * Detached from the worker with given sessionId.
         */
        post(method: 'NodeWorker.detach', params?: NodeWorker.DetachParameterType): Promise<void>;
        /**
         * Disables network tracking, prevents network events from being sent to the client.
         */
        post(method: 'Network.disable'): Promise<void>;
        /**
         * Enables network tracking, network events will now be delivered to the client.
         */
        post(method: 'Network.enable'): Promise<void>;
        /**
         * Returns post data sent with the request. Returns an error when no data was sent with the request.
         */
        post(method: 'Network.getRequestPostData', params?: Network.GetRequestPostDataParameterType): Promise<Network.GetRequestPostDataReturnType>;
        /**
         * Returns content served for the given request.
         */
        post(method: 'Network.getResponseBody', params?: Network.GetResponseBodyParameterType): Promise<Network.GetResponseBodyReturnType>;
        /**
         * Enables streaming of the response for the given requestId.
         * If enabled, the dataReceived event contains the data that was received during streaming.
         * @experimental
         */
        post(method: 'Network.streamResourceContent', params?: Network.StreamResourceContentParameterType): Promise<Network.StreamResourceContentReturnType>;
        /**
         * Enable the NodeRuntime events except by `NodeRuntime.waitingForDisconnect`.
         */
        post(method: 'NodeRuntime.enable'): Promise<void>;
        /**
         * Disable NodeRuntime events
         */
        post(method: 'NodeRuntime.disable'): Promise<void>;
        /**
         * Enable the `NodeRuntime.waitingForDisconnect`.
         */
        post(method: 'NodeRuntime.notifyWhenWaitingForDisconnect', params?: NodeRuntime.NotifyWhenWaitingForDisconnectParameterType): Promise<void>;
        post(method: 'Target.setAutoAttach', params?: Target.SetAutoAttachParameterType): Promise<void>;

        addListener(event: string, listener: (...args: any[]) => void): this;
        /**
         * Emitted when any notification from the V8 Inspector is received.
         */
        addListener(event: 'inspectorNotification', listener: (message: InspectorNotification<object>) => void): this;
        /**
         * Issued when new execution context is created.
         */
        addListener(event: 'Runtime.executionContextCreated', listener: (message: InspectorNotification<Runtime.ExecutionContextCreatedEventDataType>) => void): this;
        /**
         * Issued when execution context is destroyed.
         */
        addListener(event: 'Runtime.executionContextDestroyed', listener: (message: InspectorNotification<Runtime.ExecutionContextDestroyedEventDataType>) => void): this;
        /**
         * Issued when all executionContexts were cleared in browser
         */
        addListener(event: 'Runtime.executionContextsCleared', listener: () => void): this;
        /**
         * Issued when exception was thrown and unhandled.
         */
        addListener(event: 'Runtime.exceptionThrown', listener: (message: InspectorNotification<Runtime.ExceptionThrownEventDataType>) => void): this;
        /**
         * Issued when unhandled exception was revoked.
         */
        addListener(event: 'Runtime.exceptionRevoked', listener: (message: InspectorNotification<Runtime.ExceptionRevokedEventDataType>) => void): this;
        /**
         * Issued when console API was called.
         */
        addListener(event: 'Runtime.consoleAPICalled', listener: (message: InspectorNotification<Runtime.ConsoleAPICalledEventDataType>) => void): this;
        /**
         * Issued when object should be inspected (for example, as a result of inspect() command line API call).
         */
        addListener(event: 'Runtime.inspectRequested', listener: (message: InspectorNotification<Runtime.InspectRequestedEventDataType>) => void): this;
        /**
         * Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
         */
        addListener(event: 'Debugger.scriptParsed', listener: (message: InspectorNotification<Debugger.ScriptParsedEventDataType>) => void): this;
        /**
         * Fired when virtual machine fails to parse the script.
         */
        addListener(event: 'Debugger.scriptFailedToParse', listener: (message: InspectorNotification<Debugger.ScriptFailedToParseEventDataType>) => void): this;
        /**
         * Fired when breakpoint is resolved to an actual script and location.
         */
        addListener(event: 'Debugger.breakpointResolved', listener: (message: InspectorNotification<Debugger.BreakpointResolvedEventDataType>) => void): this;
        /**
         * Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
         */
        addListener(event: 'Debugger.paused', listener: (message: InspectorNotification<Debugger.PausedEventDataType>) => void): this;
        /**
         * Fired when the virtual machine resumed execution.
         */
        addListener(event: 'Debugger.resumed', listener: () => void): this;
        /**
         * Issued when new console message is added.
         */
        addListener(event: 'Console.messageAdded', listener: (message: InspectorNotification<Console.MessageAddedEventDataType>) => void): this;
        /**
         * Sent when new profile recording is started using console.profile() call.
         */
        addListener(event: 'Profiler.consoleProfileStarted', listener: (message: InspectorNotification<Profiler.ConsoleProfileStartedEventDataType>) => void): this;
        addListener(event: 'Profiler.consoleProfileFinished', listener: (message: InspectorNotification<Profiler.ConsoleProfileFinishedEventDataType>) => void): this;
        addListener(event: 'HeapProfiler.addHeapSnapshotChunk', listener: (message: InspectorNotification<HeapProfiler.AddHeapSnapshotChunkEventDataType>) => void): this;
        addListener(event: 'HeapProfiler.resetProfiles', listener: () => void): this;
        addListener(event: 'HeapProfiler.reportHeapSnapshotProgress', listener: (message: InspectorNotification<HeapProfiler.ReportHeapSnapshotProgressEventDataType>) => void): this;
        /**
         * If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
         */
        addListener(event: 'HeapProfiler.lastSeenObjectId', listener: (message: InspectorNotification<HeapProfiler.LastSeenObjectIdEventDataType>) => void): this;
        /**
         * If heap objects tracking has been started then backend may send update for one or more fragments
         */
        addListener(event: 'HeapProfiler.heapStatsUpdate', listener: (message: InspectorNotification<HeapProfiler.HeapStatsUpdateEventDataType>) => void): this;
        /**
         * Contains an bucket of collected trace events.
         */
        addListener(event: 'NodeTracing.dataCollected', listener: (message: InspectorNotification<NodeTracing.DataCollectedEventDataType>) => void): this;
        /**
         * Signals that tracing is stopped and there is no trace buffers pending flush, all data were
         * delivered via dataCollected events.
         */
        addListener(event: 'NodeTracing.tracingComplete', listener: () => void): this;
        /**
         * Issued when attached to a worker.
         */
        addListener(event: 'NodeWorker.attachedToWorker', listener: (message: InspectorNotification<NodeWorker.AttachedToWorkerEventDataType>) => void): this;
        /**
         * Issued when detached from the worker.
         */
        addListener(event: 'NodeWorker.detachedFromWorker', listener: (message: InspectorNotification<NodeWorker.DetachedFromWorkerEventDataType>) => void): this;
        /**
         * Notifies about a new protocol message received from the session
         * (session ID is provided in attachedToWorker notification).
         */
        addListener(event: 'NodeWorker.receivedMessageFromWorker', listener: (message: InspectorNotification<NodeWorker.ReceivedMessageFromWorkerEventDataType>) => void): this;
        /**
         * Fired when page is about to send HTTP request.
         */
        addListener(event: 'Network.requestWillBeSent', listener: (message: InspectorNotification<Network.RequestWillBeSentEventDataType>) => void): this;
        /**
         * Fired when HTTP response is available.
         */
        addListener(event: 'Network.responseReceived', listener: (message: InspectorNotification<Network.ResponseReceivedEventDataType>) => void): this;
        addListener(event: 'Network.loadingFailed', listener: (message: InspectorNotification<Network.LoadingFailedEventDataType>) => void): this;
        addListener(event: 'Network.loadingFinished', listener: (message: InspectorNotification<Network.LoadingFinishedEventDataType>) => void): this;
        /**
         * Fired when data chunk was received over the network.
         */
        addListener(event: 'Network.dataReceived', listener: (message: InspectorNotification<Network.DataReceivedEventDataType>) => void): this;
        /**
         * This event is fired instead of `Runtime.executionContextDestroyed` when
         * enabled.
         * It is fired when the Node process finished all code execution and is
         * waiting for all frontends to disconnect.
         */
        addListener(event: 'NodeRuntime.waitingForDisconnect', listener: () => void): this;
        /**
         * This event is fired when the runtime is waiting for the debugger. For
         * example, when inspector.waitingForDebugger is called
         */
        addListener(event: 'NodeRuntime.waitingForDebugger', listener: () => void): this;
        addListener(event: 'Target.targetCreated', listener: (message: InspectorNotification<Target.TargetCreatedEventDataType>) => void): this;
        addListener(event: 'Target.attachedToTarget', listener: (message: InspectorNotification<Target.AttachedToTargetEventDataType>) => void): this;
        emit(event: string | symbol, ...args: any[]): boolean;
        emit(event: 'inspectorNotification', message: InspectorNotification<object>): boolean;
        emit(event: 'Runtime.executionContextCreated', message: InspectorNotification<Runtime.ExecutionContextCreatedEventDataType>): boolean;
        emit(event: 'Runtime.executionContextDestroyed', message: InspectorNotification<Runtime.ExecutionContextDestroyedEventDataType>): boolean;
        emit(event: 'Runtime.executionContextsCleared'): boolean;
        emit(event: 'Runtime.exceptionThrown', message: InspectorNotification<Runtime.ExceptionThrownEventDataType>): boolean;
        emit(event: 'Runtime.exceptionRevoked', message: InspectorNotification<Runtime.ExceptionRevokedEventDataType>): boolean;
        emit(event: 'Runtime.consoleAPICalled', message: InspectorNotification<Runtime.ConsoleAPICalledEventDataType>): boolean;
        emit(event: 'Runtime.inspectRequested', message: InspectorNotification<Runtime.InspectRequestedEventDataType>): boolean;
        emit(event: 'Debugger.scriptParsed', message: InspectorNotification<Debugger.ScriptParsedEventDataType>): boolean;
        emit(event: 'Debugger.scriptFailedToParse', message: InspectorNotification<Debugger.ScriptFailedToParseEventDataType>): boolean;
        emit(event: 'Debugger.breakpointResolved', message: InspectorNotification<Debugger.BreakpointResolvedEventDataType>): boolean;
        emit(event: 'Debugger.paused', message: InspectorNotification<Debugger.PausedEventDataType>): boolean;
        emit(event: 'Debugger.resumed'): boolean;
        emit(event: 'Console.messageAdded', message: InspectorNotification<Console.MessageAddedEventDataType>): boolean;
        emit(event: 'Profiler.consoleProfileStarted', message: InspectorNotification<Profiler.ConsoleProfileStartedEventDataType>): boolean;
        emit(event: 'Profiler.consoleProfileFinished', message: InspectorNotification<Profiler.ConsoleProfileFinishedEventDataType>): boolean;
        emit(event: 'HeapProfiler.addHeapSnapshotChunk', message: InspectorNotification<HeapProfiler.AddHeapSnapshotChunkEventDataType>): boolean;
        emit(event: 'HeapProfiler.resetProfiles'): boolean;
        emit(event: 'HeapProfiler.reportHeapSnapshotProgress', message: InspectorNotification<HeapProfiler.ReportHeapSnapshotProgressEventDataType>): boolean;
        emit(event: 'HeapProfiler.lastSeenObjectId', message: InspectorNotification<HeapProfiler.LastSeenObjectIdEventDataType>): boolean;
        emit(event: 'HeapProfiler.heapStatsUpdate', message: InspectorNotification<HeapProfiler.HeapStatsUpdateEventDataType>): boolean;
        emit(event: 'NodeTracing.dataCollected', message: InspectorNotification<NodeTracing.DataCollectedEventDataType>): boolean;
        emit(event: 'NodeTracing.tracingComplete'): boolean;
        emit(event: 'NodeWorker.attachedToWorker', message: InspectorNotification<NodeWorker.AttachedToWorkerEventDataType>): boolean;
        emit(event: 'NodeWorker.detachedFromWorker', message: InspectorNotification<NodeWorker.DetachedFromWorkerEventDataType>): boolean;
        emit(event: 'NodeWorker.receivedMessageFromWorker', message: InspectorNotification<NodeWorker.ReceivedMessageFromWorkerEventDataType>): boolean;
        emit(event: 'Network.requestWillBeSent', message: InspectorNotification<Network.RequestWillBeSentEventDataType>): boolean;
        emit(event: 'Network.responseReceived', message: InspectorNotification<Network.ResponseReceivedEventDataType>): boolean;
        emit(event: 'Network.loadingFailed', message: InspectorNotification<Network.LoadingFailedEventDataType>): boolean;
        emit(event: 'Network.loadingFinished', message: InspectorNotification<Network.LoadingFinishedEventDataType>): boolean;
        emit(event: 'Network.dataReceived', message: InspectorNotification<Network.DataReceivedEventDataType>): boolean;
        emit(event: 'NodeRuntime.waitingForDisconnect'): boolean;
        emit(event: 'NodeRuntime.waitingForDebugger'): boolean;
        emit(event: 'Target.targetCreated', message: InspectorNotification<Target.TargetCreatedEventDataType>): boolean;
        emit(event: 'Target.attachedToTarget', message: InspectorNotification<Target.AttachedToTargetEventDataType>): boolean;
        on(event: string, listener: (...args: any[]) => void): this;
        /**
         * Emitted when any notification from the V8 Inspector is received.
         */
        on(event: 'inspectorNotification', listener: (message: InspectorNotification<object>) => void): this;
        /**
         * Issued when new execution context is created.
         */
        on(event: 'Runtime.executionContextCreated', listener: (message: InspectorNotification<Runtime.ExecutionContextCreatedEventDataType>) => void): this;
        /**
         * Issued when execution context is destroyed.
         */
        on(event: 'Runtime.executionContextDestroyed', listener: (message: InspectorNotification<Runtime.ExecutionContextDestroyedEventDataType>) => void): this;
        /**
         * Issued when all executionContexts were cleared in browser
         */
        on(event: 'Runtime.executionContextsCleared', listener: () => void): this;
        /**
         * Issued when exception was thrown and unhandled.
         */
        on(event: 'Runtime.exceptionThrown', listener: (message: InspectorNotification<Runtime.ExceptionThrownEventDataType>) => void): this;
        /**
         * Issued when unhandled exception was revoked.
         */
        on(event: 'Runtime.exceptionRevoked', listener: (message: InspectorNotification<Runtime.ExceptionRevokedEventDataType>) => void): this;
        /**
         * Issued when console API was called.
         */
        on(event: 'Runtime.consoleAPICalled', listener: (message: InspectorNotification<Runtime.ConsoleAPICalledEventDataType>) => void): this;
        /**
         * Issued when object should be inspected (for example, as a result of inspect() command line API call).
         */
        on(event: 'Runtime.inspectRequested', listener: (message: InspectorNotification<Runtime.InspectRequestedEventDataType>) => void): this;
        /**
         * Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
         */
        on(event: 'Debugger.scriptParsed', listener: (message: InspectorNotification<Debugger.ScriptParsedEventDataType>) => void): this;
        /**
         * Fired when virtual machine fails to parse the script.
         */
        on(event: 'Debugger.scriptFailedToParse', listener: (message: InspectorNotification<Debugger.ScriptFailedToParseEventDataType>) => void): this;
        /**
         * Fired when breakpoint is resolved to an actual script and location.
         */
        on(event: 'Debugger.breakpointResolved', listener: (message: InspectorNotification<Debugger.BreakpointResolvedEventDataType>) => void): this;
        /**
         * Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
         */
        on(event: 'Debugger.paused', listener: (message: InspectorNotification<Debugger.PausedEventDataType>) => void): this;
        /**
         * Fired when the virtual machine resumed execution.
         */
        on(event: 'Debugger.resumed', listener: () => void): this;
        /**
         * Issued when new console message is added.
         */
        on(event: 'Console.messageAdded', listener: (message: InspectorNotification<Console.MessageAddedEventDataType>) => void): this;
        /**
         * Sent when new profile recording is started using console.profile() call.
         */
        on(event: 'Profiler.consoleProfileStarted', listener: (message: InspectorNotification<Profiler.ConsoleProfileStartedEventDataType>) => void): this;
        on(event: 'Profiler.consoleProfileFinished', listener: (message: InspectorNotification<Profiler.ConsoleProfileFinishedEventDataType>) => void): this;
        on(event: 'HeapProfiler.addHeapSnapshotChunk', listener: (message: InspectorNotification<HeapProfiler.AddHeapSnapshotChunkEventDataType>) => void): this;
        on(event: 'HeapProfiler.resetProfiles', listener: () => void): this;
        on(event: 'HeapProfiler.reportHeapSnapshotProgress', listener: (message: InspectorNotification<HeapProfiler.ReportHeapSnapshotProgressEventDataType>) => void): this;
        /**
         * If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
         */
        on(event: 'HeapProfiler.lastSeenObjectId', listener: (message: InspectorNotification<HeapProfiler.LastSeenObjectIdEventDataType>) => void): this;
        /**
         * If heap objects tracking has been started then backend may send update for one or more fragments
         */
        on(event: 'HeapProfiler.heapStatsUpdate', listener: (message: InspectorNotification<HeapProfiler.HeapStatsUpdateEventDataType>) => void): this;
        /**
         * Contains an bucket of collected trace events.
         */
        on(event: 'NodeTracing.dataCollected', listener: (message: InspectorNotification<NodeTracing.DataCollectedEventDataType>) => void): this;
        /**
         * Signals that tracing is stopped and there is no trace buffers pending flush, all data were
         * delivered via dataCollected events.
         */
        on(event: 'NodeTracing.tracingComplete', listener: () => void): this;
        /**
         * Issued when attached to a worker.
         */
        on(event: 'NodeWorker.attachedToWorker', listener: (message: InspectorNotification<NodeWorker.AttachedToWorkerEventDataType>) => void): this;
        /**
         * Issued when detached from the worker.
         */
        on(event: 'NodeWorker.detachedFromWorker', listener: (message: InspectorNotification<NodeWorker.DetachedFromWorkerEventDataType>) => void): this;
        /**
         * Notifies about a new protocol message received from the session
         * (session ID is provided in attachedToWorker notification).
         */
        on(event: 'NodeWorker.receivedMessageFromWorker', listener: (message: InspectorNotification<NodeWorker.ReceivedMessageFromWorkerEventDataType>) => void): this;
        /**
         * Fired when page is about to send HTTP request.
         */
        on(event: 'Network.requestWillBeSent', listener: (message: InspectorNotification<Network.RequestWillBeSentEventDataType>) => void): this;
        /**
         * Fired when HTTP response is available.
         */
        on(event: 'Network.responseReceived', listener: (message: InspectorNotification<Network.ResponseReceivedEventDataType>) => void): this;
        on(event: 'Network.loadingFailed', listener: (message: InspectorNotification<Network.LoadingFailedEventDataType>) => void): this;
        on(event: 'Network.loadingFinished', listener: (message: InspectorNotification<Network.LoadingFinishedEventDataType>) => void): this;
        /**
         * Fired when data chunk was received over the network.
         */
        on(event: 'Network.dataReceived', listener: (message: InspectorNotification<Network.DataReceivedEventDataType>) => void): this;
        /**
         * This event is fired instead of `Runtime.executionContextDestroyed` when
         * enabled.
         * It is fired when the Node process finished all code execution and is
         * waiting for all frontends to disconnect.
         */
        on(event: 'NodeRuntime.waitingForDisconnect', listener: () => void): this;
        /**
         * This event is fired when the runtime is waiting for the debugger. For
         * example, when inspector.waitingForDebugger is called
         */
        on(event: 'NodeRuntime.waitingForDebugger', listener: () => void): this;
        on(event: 'Target.targetCreated', listener: (message: InspectorNotification<Target.TargetCreatedEventDataType>) => void): this;
        on(event: 'Target.attachedToTarget', listener: (message: InspectorNotification<Target.AttachedToTargetEventDataType>) => void): this;
        once(event: string, listener: (...args: any[]) => void): this;
        /**
         * Emitted when any notification from the V8 Inspector is received.
         */
        once(event: 'inspectorNotification', listener: (message: InspectorNotification<object>) => void): this;
        /**
         * Issued when new execution context is created.
         */
        once(event: 'Runtime.executionContextCreated', listener: (message: InspectorNotification<Runtime.ExecutionContextCreatedEventDataType>) => void): this;
        /**
         * Issued when execution context is destroyed.
         */
        once(event: 'Runtime.executionContextDestroyed', listener: (message: InspectorNotification<Runtime.ExecutionContextDestroyedEventDataType>) => void): this;
        /**
         * Issued when all executionContexts were cleared in browser
         */
        once(event: 'Runtime.executionContextsCleared', listener: () => void): this;
        /**
         * Issued when exception was thrown and unhandled.
         */
        once(event: 'Runtime.exceptionThrown', listener: (message: InspectorNotification<Runtime.ExceptionThrownEventDataType>) => void): this;
        /**
         * Issued when unhandled exception was revoked.
         */
        once(event: 'Runtime.exceptionRevoked', listener: (message: InspectorNotification<Runtime.ExceptionRevokedEventDataType>) => void): this;
        /**
         * Issued when console API was called.
         */
        once(event: 'Runtime.consoleAPICalled', listener: (message: InspectorNotification<Runtime.ConsoleAPICalledEventDataType>) => void): this;
        /**
         * Issued when object should be inspected (for example, as a result of inspect() command line API call).
         */
        once(event: 'Runtime.inspectRequested', listener: (message: InspectorNotification<Runtime.InspectRequestedEventDataType>) => void): this;
        /**
         * Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
         */
        once(event: 'Debugger.scriptParsed', listener: (message: InspectorNotification<Debugger.ScriptParsedEventDataType>) => void): this;
        /**
         * Fired when virtual machine fails to parse the script.
         */
        once(event: 'Debugger.scriptFailedToParse', listener: (message: InspectorNotification<Debugger.ScriptFailedToParseEventDataType>) => void): this;
        /**
         * Fired when breakpoint is resolved to an actual script and location.
         */
        once(event: 'Debugger.breakpointResolved', listener: (message: InspectorNotification<Debugger.BreakpointResolvedEventDataType>) => void): this;
        /**
         * Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
         */
        once(event: 'Debugger.paused', listener: (message: InspectorNotification<Debugger.PausedEventDataType>) => void): this;
        /**
         * Fired when the virtual machine resumed execution.
         */
        once(event: 'Debugger.resumed', listener: () => void): this;
        /**
         * Issued when new console message is added.
         */
        once(event: 'Console.messageAdded', listener: (message: InspectorNotification<Console.MessageAddedEventDataType>) => void): this;
        /**
         * Sent when new profile recording is started using console.profile() call.
         */
        once(event: 'Profiler.consoleProfileStarted', listener: (message: InspectorNotification<Profiler.ConsoleProfileStartedEventDataType>) => void): this;
        once(event: 'Profiler.consoleProfileFinished', listener: (message: InspectorNotification<Profiler.ConsoleProfileFinishedEventDataType>) => void): this;
        once(event: 'HeapProfiler.addHeapSnapshotChunk', listener: (message: InspectorNotification<HeapProfiler.AddHeapSnapshotChunkEventDataType>) => void): this;
        once(event: 'HeapProfiler.resetProfiles', listener: () => void): this;
        once(event: 'HeapProfiler.reportHeapSnapshotProgress', listener: (message: InspectorNotification<HeapProfiler.ReportHeapSnapshotProgressEventDataType>) => void): this;
        /**
         * If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
         */
        once(event: 'HeapProfiler.lastSeenObjectId', listener: (message: InspectorNotification<HeapProfiler.LastSeenObjectIdEventDataType>) => void): this;
        /**
         * If heap objects tracking has been started then backend may send update for one or more fragments
         */
        once(event: 'HeapProfiler.heapStatsUpdate', listener: (message: InspectorNotification<HeapProfiler.HeapStatsUpdateEventDataType>) => void): this;
        /**
         * Contains an bucket of collected trace events.
         */
        once(event: 'NodeTracing.dataCollected', listener: (message: InspectorNotification<NodeTracing.DataCollectedEventDataType>) => void): this;
        /**
         * Signals that tracing is stopped and there is no trace buffers pending flush, all data were
         * delivered via dataCollected events.
         */
        once(event: 'NodeTracing.tracingComplete', listener: () => void): this;
        /**
         * Issued when attached to a worker.
         */
        once(event: 'NodeWorker.attachedToWorker', listener: (message: InspectorNotification<NodeWorker.AttachedToWorkerEventDataType>) => void): this;
        /**
         * Issued when detached from the worker.
         */
        once(event: 'NodeWorker.detachedFromWorker', listener: (message: InspectorNotification<NodeWorker.DetachedFromWorkerEventDataType>) => void): this;
        /**
         * Notifies about a new protocol message received from the session
         * (session ID is provided in attachedToWorker notification).
         */
        once(event: 'NodeWorker.receivedMessageFromWorker', listener: (message: InspectorNotification<NodeWorker.ReceivedMessageFromWorkerEventDataType>) => void): this;
        /**
         * Fired when page is about to send HTTP request.
         */
        once(event: 'Network.requestWillBeSent', listener: (message: InspectorNotification<Network.RequestWillBeSentEventDataType>) => void): this;
        /**
         * Fired when HTTP response is available.
         */
        once(event: 'Network.responseReceived', listener: (message: InspectorNotification<Network.ResponseReceivedEventDataType>) => void): this;
        once(event: 'Network.loadingFailed', listener: (message: InspectorNotification<Network.LoadingFailedEventDataType>) => void): this;
        once(event: 'Network.loadingFinished', listener: (message: InspectorNotification<Network.LoadingFinishedEventDataType>) => void): this;
        /**
         * Fired when data chunk was received over the network.
         */
        once(event: 'Network.dataReceived', listener: (message: InspectorNotification<Network.DataReceivedEventDataType>) => void): this;
        /**
         * This event is fired instead of `Runtime.executionContextDestroyed` when
         * enabled.
         * It is fired when the Node process finished all code execution and is
         * waiting for all frontends to disconnect.
         */
        once(event: 'NodeRuntime.waitingForDisconnect', listener: () => void): this;
        /**
         * This event is fired when the runtime is waiting for the debugger. For
         * example, when inspector.waitingForDebugger is called
         */
        once(event: 'NodeRuntime.waitingForDebugger', listener: () => void): this;
        once(event: 'Target.targetCreated', listener: (message: InspectorNotification<Target.TargetCreatedEventDataType>) => void): this;
        once(event: 'Target.attachedToTarget', listener: (message: InspectorNotification<Target.AttachedToTargetEventDataType>) => void): this;
        prependListener(event: string, listener: (...args: any[]) => void): this;
        /**
         * Emitted when any notification from the V8 Inspector is received.
         */
        prependListener(event: 'inspectorNotification', listener: (message: InspectorNotification<object>) => void): this;
        /**
         * Issued when new execution context is created.
         */
        prependListener(event: 'Runtime.executionContextCreated', listener: (message: InspectorNotification<Runtime.ExecutionContextCreatedEventDataType>) => void): this;
        /**
         * Issued when execution context is destroyed.
         */
        prependListener(event: 'Runtime.executionContextDestroyed', listener: (message: InspectorNotification<Runtime.ExecutionContextDestroyedEventDataType>) => void): this;
        /**
         * Issued when all executionContexts were cleared in browser
         */
        prependListener(event: 'Runtime.executionContextsCleared', listener: () => void): this;
        /**
         * Issued when exception was thrown and unhandled.
         */
        prependListener(event: 'Runtime.exceptionThrown', listener: (message: InspectorNotification<Runtime.ExceptionThrownEventDataType>) => void): this;
        /**
         * Issued when unhandled exception was revoked.
         */
        prependListener(event: 'Runtime.exceptionRevoked', listener: (message: InspectorNotification<Runtime.ExceptionRevokedEventDataType>) => void): this;
        /**
         * Issued when console API was called.
         */
        prependListener(event: 'Runtime.consoleAPICalled', listener: (message: InspectorNotification<Runtime.ConsoleAPICalledEventDataType>) => void): this;
        /**
         * Issued when object should be inspected (for example, as a result of inspect() command line API call).
         */
        prependListener(event: 'Runtime.inspectRequested', listener: (message: InspectorNotification<Runtime.InspectRequestedEventDataType>) => void): this;
        /**
         * Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
         */
        prependListener(event: 'Debugger.scriptParsed', listener: (message: InspectorNotification<Debugger.ScriptParsedEventDataType>) => void): this;
        /**
         * Fired when virtual machine fails to parse the script.
         */
        prependListener(event: 'Debugger.scriptFailedToParse', listener: (message: InspectorNotification<Debugger.ScriptFailedToParseEventDataType>) => void): this;
        /**
         * Fired when breakpoint is resolved to an actual script and location.
         */
        prependListener(event: 'Debugger.breakpointResolved', listener: (message: InspectorNotification<Debugger.BreakpointResolvedEventDataType>) => void): this;
        /**
         * Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
         */
        prependListener(event: 'Debugger.paused', listener: (message: InspectorNotification<Debugger.PausedEventDataType>) => void): this;
        /**
         * Fired when the virtual machine resumed execution.
         */
        prependListener(event: 'Debugger.resumed', listener: () => void): this;
        /**
         * Issued when new console message is added.
         */
        prependListener(event: 'Console.messageAdded', listener: (message: InspectorNotification<Console.MessageAddedEventDataType>) => void): this;
        /**
         * Sent when new profile recording is started using console.profile() call.
         */
        prependListener(event: 'Profiler.consoleProfileStarted', listener: (message: InspectorNotification<Profiler.ConsoleProfileStartedEventDataType>) => void): this;
        prependListener(event: 'Profiler.consoleProfileFinished', listener: (message: InspectorNotification<Profiler.ConsoleProfileFinishedEventDataType>) => void): this;
        prependListener(event: 'HeapProfiler.addHeapSnapshotChunk', listener: (message: InspectorNotification<HeapProfiler.AddHeapSnapshotChunkEventDataType>) => void): this;
        prependListener(event: 'HeapProfiler.resetProfiles', listener: () => void): this;
        prependListener(event: 'HeapProfiler.reportHeapSnapshotProgress', listener: (message: InspectorNotification<HeapProfiler.ReportHeapSnapshotProgressEventDataType>) => void): this;
        /**
         * If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
         */
        prependListener(event: 'HeapProfiler.lastSeenObjectId', listener: (message: InspectorNotification<HeapProfiler.LastSeenObjectIdEventDataType>) => void): this;
        /**
         * If heap objects tracking has been started then backend may send update for one or more fragments
         */
        prependListener(event: 'HeapProfiler.heapStatsUpdate', listener: (message: InspectorNotification<HeapProfiler.HeapStatsUpdateEventDataType>) => void): this;
        /**
         * Contains an bucket of collected trace events.
         */
        prependListener(event: 'NodeTracing.dataCollected', listener: (message: InspectorNotification<NodeTracing.DataCollectedEventDataType>) => void): this;
        /**
         * Signals that tracing is stopped and there is no trace buffers pending flush, all data were
         * delivered via dataCollected events.
         */
        prependListener(event: 'NodeTracing.tracingComplete', listener: () => void): this;
        /**
         * Issued when attached to a worker.
         */
        prependListener(event: 'NodeWorker.attachedToWorker', listener: (message: InspectorNotification<NodeWorker.AttachedToWorkerEventDataType>) => void): this;
        /**
         * Issued when detached from the worker.
         */
        prependListener(event: 'NodeWorker.detachedFromWorker', listener: (message: InspectorNotification<NodeWorker.DetachedFromWorkerEventDataType>) => void): this;
        /**
         * Notifies about a new protocol message received from the session
         * (session ID is provided in attachedToWorker notification).
         */
        prependListener(event: 'NodeWorker.receivedMessageFromWorker', listener: (message: InspectorNotification<NodeWorker.ReceivedMessageFromWorkerEventDataType>) => void): this;
        /**
         * Fired when page is about to send HTTP request.
         */
        prependListener(event: 'Network.requestWillBeSent', listener: (message: InspectorNotification<Network.RequestWillBeSentEventDataType>) => void): this;
        /**
         * Fired when HTTP response is available.
         */
        prependListener(event: 'Network.responseReceived', listener: (message: InspectorNotification<Network.ResponseReceivedEventDataType>) => void): this;
        prependListener(event: 'Network.loadingFailed', listener: (message: InspectorNotification<Network.LoadingFailedEventDataType>) => void): this;
        prependListener(event: 'Network.loadingFinished', listener: (message: InspectorNotification<Network.LoadingFinishedEventDataType>) => void): this;
        /**
         * Fired when data chunk was received over the network.
         */
        prependListener(event: 'Network.dataReceived', listener: (message: InspectorNotification<Network.DataReceivedEventDataType>) => void): this;
        /**
         * This event is fired instead of `Runtime.executionContextDestroyed` when
         * enabled.
         * It is fired when the Node process finished all code execution and is
         * waiting for all frontends to disconnect.
         */
        prependListener(event: 'NodeRuntime.waitingForDisconnect', listener: () => void): this;
        /**
         * This event is fired when the runtime is waiting for the debugger. For
         * example, when inspector.waitingForDebugger is called
         */
        prependListener(event: 'NodeRuntime.waitingForDebugger', listener: () => void): this;
        prependListener(event: 'Target.targetCreated', listener: (message: InspectorNotification<Target.TargetCreatedEventDataType>) => void): this;
        prependListener(event: 'Target.attachedToTarget', listener: (message: InspectorNotification<Target.AttachedToTargetEventDataType>) => void): this;
        prependOnceListener(event: string, listener: (...args: any[]) => void): this;
        /**
         * Emitted when any notification from the V8 Inspector is received.
         */
        prependOnceListener(event: 'inspectorNotification', listener: (message: InspectorNotification<object>) => void): this;
        /**
         * Issued when new execution context is created.
         */
        prependOnceListener(event: 'Runtime.executionContextCreated', listener: (message: InspectorNotification<Runtime.ExecutionContextCreatedEventDataType>) => void): this;
        /**
         * Issued when execution context is destroyed.
         */
        prependOnceListener(event: 'Runtime.executionContextDestroyed', listener: (message: InspectorNotification<Runtime.ExecutionContextDestroyedEventDataType>) => void): this;
        /**
         * Issued when all executionContexts were cleared in browser
         */
        prependOnceListener(event: 'Runtime.executionContextsCleared', listener: () => void): this;
        /**
         * Issued when exception was thrown and unhandled.
         */
        prependOnceListener(event: 'Runtime.exceptionThrown', listener: (message: InspectorNotification<Runtime.ExceptionThrownEventDataType>) => void): this;
        /**
         * Issued when unhandled exception was revoked.
         */
        prependOnceListener(event: 'Runtime.exceptionRevoked', listener: (message: InspectorNotification<Runtime.ExceptionRevokedEventDataType>) => void): this;
        /**
         * Issued when console API was called.
         */
        prependOnceListener(event: 'Runtime.consoleAPICalled', listener: (message: InspectorNotification<Runtime.ConsoleAPICalledEventDataType>) => void): this;
        /**
         * Issued when object should be inspected (for example, as a result of inspect() command line API call).
         */
        prependOnceListener(event: 'Runtime.inspectRequested', listener: (message: InspectorNotification<Runtime.InspectRequestedEventDataType>) => void): this;
        /**
         * Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
         */
        prependOnceListener(event: 'Debugger.scriptParsed', listener: (message: InspectorNotification<Debugger.ScriptParsedEventDataType>) => void): this;
        /**
         * Fired when virtual machine fails to parse the script.
         */
        prependOnceListener(event: 'Debugger.scriptFailedToParse', listener: (message: InspectorNotification<Debugger.ScriptFailedToParseEventDataType>) => void): this;
        /**
         * Fired when breakpoint is resolved to an actual script and location.
         */
        prependOnceListener(event: 'Debugger.breakpointResolved', listener: (message: InspectorNotification<Debugger.BreakpointResolvedEventDataType>) => void): this;
        /**
         * Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
         */
        prependOnceListener(event: 'Debugger.paused', listener: (message: InspectorNotification<Debugger.PausedEventDataType>) => void): this;
        /**
         * Fired when the virtual machine resumed execution.
         */
        prependOnceListener(event: 'Debugger.resumed', listener: () => void): this;
        /**
         * Issued when new console message is added.
         */
        prependOnceListener(event: 'Console.messageAdded', listener: (message: InspectorNotification<Console.MessageAddedEventDataType>) => void): this;
        /**
         * Sent when new profile recording is started using console.profile() call.
         */
        prependOnceListener(event: 'Profiler.consoleProfileStarted', listener: (message: InspectorNotification<Profiler.ConsoleProfileStartedEventDataType>) => void): this;
        prependOnceListener(event: 'Profiler.consoleProfileFinished', listener: (message: InspectorNotification<Profiler.ConsoleProfileFinishedEventDataType>) => void): this;
        prependOnceListener(event: 'HeapProfiler.addHeapSnapshotChunk', listener: (message: InspectorNotification<HeapProfiler.AddHeapSnapshotChunkEventDataType>) => void): this;
        prependOnceListener(event: 'HeapProfiler.resetProfiles', listener: () => void): this;
        prependOnceListener(event: 'HeapProfiler.reportHeapSnapshotProgress', listener: (message: InspectorNotification<HeapProfiler.ReportHeapSnapshotProgressEventDataType>) => void): this;
        /**
         * If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
         */
        prependOnceListener(event: 'HeapProfiler.lastSeenObjectId', listener: (message: InspectorNotification<HeapProfiler.LastSeenObjectIdEventDataType>) => void): this;
        /**
         * If heap objects tracking has been started then backend may send update for one or more fragments
         */
        prependOnceListener(event: 'HeapProfiler.heapStatsUpdate', listener: (message: InspectorNotification<HeapProfiler.HeapStatsUpdateEventDataType>) => void): this;
        /**
         * Contains an bucket of collected trace events.
         */
        prependOnceListener(event: 'NodeTracing.dataCollected', listener: (message: InspectorNotification<NodeTracing.DataCollectedEventDataType>) => void): this;
        /**
         * Signals that tracing is stopped and there is no trace buffers pending flush, all data were
         * delivered via dataCollected events.
         */
        prependOnceListener(event: 'NodeTracing.tracingComplete', listener: () => void): this;
        /**
         * Issued when attached to a worker.
         */
        prependOnceListener(event: 'NodeWorker.attachedToWorker', listener: (message: InspectorNotification<NodeWorker.AttachedToWorkerEventDataType>) => void): this;
        /**
         * Issued when detached from the worker.
         */
        prependOnceListener(event: 'NodeWorker.detachedFromWorker', listener: (message: InspectorNotification<NodeWorker.DetachedFromWorkerEventDataType>) => void): this;
        /**
         * Notifies about a new protocol message received from the session
         * (session ID is provided in attachedToWorker notification).
         */
        prependOnceListener(event: 'NodeWorker.receivedMessageFromWorker', listener: (message: InspectorNotification<NodeWorker.ReceivedMessageFromWorkerEventDataType>) => void): this;
        /**
         * Fired when page is about to send HTTP request.
         */
        prependOnceListener(event: 'Network.requestWillBeSent', listener: (message: InspectorNotification<Network.RequestWillBeSentEventDataType>) => void): this;
        /**
         * Fired when HTTP response is available.
         */
        prependOnceListener(event: 'Network.responseReceived', listener: (message: InspectorNotification<Network.ResponseReceivedEventDataType>) => void): this;
        prependOnceListener(event: 'Network.loadingFailed', listener: (message: InspectorNotification<Network.LoadingFailedEventDataType>) => void): this;
        prependOnceListener(event: 'Network.loadingFinished', listener: (message: InspectorNotification<Network.LoadingFinishedEventDataType>) => void): this;
        /**
         * Fired when data chunk was received over the network.
         */
        prependOnceListener(event: 'Network.dataReceived', listener: (message: InspectorNotification<Network.DataReceivedEventDataType>) => void): this;
        /**
         * This event is fired instead of `Runtime.executionContextDestroyed` when
         * enabled.
         * It is fired when the Node process finished all code execution and is
         * waiting for all frontends to disconnect.
         */
        prependOnceListener(event: 'NodeRuntime.waitingForDisconnect', listener: () => void): this;
        /**
         * This event is fired when the runtime is waiting for the debugger. For
         * example, when inspector.waitingForDebugger is called
         */
        prependOnceListener(event: 'NodeRuntime.waitingForDebugger', listener: () => void): this;
        prependOnceListener(event: 'Target.targetCreated', listener: (message: InspectorNotification<Target.TargetCreatedEventDataType>) => void): this;
        prependOnceListener(event: 'Target.attachedToTarget', listener: (message: InspectorNotification<Target.AttachedToTargetEventDataType>) => void): this;
    }

    export {
        Session,
        open,
        close,
        url,
        waitForDebugger,
        console,
        InspectorNotification,
        Schema,
        Runtime,
        Debugger,
        Console,
        Profiler,
        HeapProfiler,
        NodeTracing,
        NodeWorker,
        Network,
        NodeRuntime,
        Target,
    };
}

/**
 * The `node:inspector/promises` module provides an API for interacting with the V8
 * inspector.
 * @since v19.0.0
 */
declare module 'node:inspector/promises' {
    export * from 'inspector/promises';
}

```

## ./lib/lambda/node_modules/@types/node/module.d.ts

```typescript
/**
 * @since v0.3.7
 */
declare module "module" {
    import { URL } from "node:url";
    class Module {
        constructor(id: string, parent?: Module);
    }
    interface Module extends NodeJS.Module {}
    namespace Module {
        export { Module };
    }
    namespace Module {
        /**
         * A list of the names of all modules provided by Node.js. Can be used to verify
         * if a module is maintained by a third party or not.
         *
         * Note: the list doesn't contain prefix-only modules like `node:test`.
         * @since v9.3.0, v8.10.0, v6.13.0
         */
        const builtinModules: readonly string[];
        /**
         * @since v12.2.0
         * @param path Filename to be used to construct the require
         * function. Must be a file URL object, file URL string, or absolute path
         * string.
         */
        function createRequire(path: string | URL): NodeJS.Require;
        namespace constants {
            /**
             * The following constants are returned as the `status` field in the object returned by
             * {@link enableCompileCache} to indicate the result of the attempt to enable the
             * [module compile cache](https://nodejs.org/docs/latest-v22.x/api/module.html#module-compile-cache).
             * @since v22.8.0
             */
            namespace compileCacheStatus {
                /**
                 * Node.js has enabled the compile cache successfully. The directory used to store the
                 * compile cache will be returned in the `directory` field in the
                 * returned object.
                 */
                const ENABLED: number;
                /**
                 * The compile cache has already been enabled before, either by a previous call to
                 * {@link enableCompileCache}, or by the `NODE_COMPILE_CACHE=dir`
                 * environment variable. The directory used to store the
                 * compile cache will be returned in the `directory` field in the
                 * returned object.
                 */
                const ALREADY_ENABLED: number;
                /**
                 * Node.js fails to enable the compile cache. This can be caused by the lack of
                 * permission to use the specified directory, or various kinds of file system errors.
                 * The detail of the failure will be returned in the `message` field in the
                 * returned object.
                 */
                const FAILED: number;
                /**
                 * Node.js cannot enable the compile cache because the environment variable
                 * `NODE_DISABLE_COMPILE_CACHE=1` has been set.
                 */
                const DISABLED: number;
            }
        }
        interface EnableCompileCacheResult {
            /**
             * One of the {@link constants.compileCacheStatus}
             */
            status: number;
            /**
             * If Node.js cannot enable the compile cache, this contains
             * the error message. Only set if `status` is `module.constants.compileCacheStatus.FAILED`.
             */
            message?: string;
            /**
             * If the compile cache is enabled, this contains the directory
             * where the compile cache is stored. Only set if  `status` is
             * `module.constants.compileCacheStatus.ENABLED` or
             * `module.constants.compileCacheStatus.ALREADY_ENABLED`.
             */
            directory?: string;
        }
        /**
         * Enable [module compile cache](https://nodejs.org/docs/latest-v22.x/api/module.html#module-compile-cache)
         * in the current Node.js instance.
         *
         * If `cacheDir` is not specified, Node.js will either use the directory specified by the
         * `NODE_COMPILE_CACHE=dir` environment variable if it's set, or use
         * `path.join(os.tmpdir(), 'node-compile-cache')` otherwise. For general use cases, it's
         * recommended to call `module.enableCompileCache()` without specifying the `cacheDir`,
         * so that the directory can be overridden by the `NODE_COMPILE_CACHE` environment
         * variable when necessary.
         *
         * Since compile cache is supposed to be a quiet optimization that is not required for the
         * application to be functional, this method is designed to not throw any exception when the
         * compile cache cannot be enabled. Instead, it will return an object containing an error
         * message in the `message` field to aid debugging.
         * If compile cache is enabled successfully, the `directory` field in the returned object
         * contains the path to the directory where the compile cache is stored. The `status`
         * field in the returned object would be one of the `module.constants.compileCacheStatus`
         * values to indicate the result of the attempt to enable the
         * [module compile cache](https://nodejs.org/docs/latest-v22.x/api/module.html#module-compile-cache).
         *
         * This method only affects the current Node.js instance. To enable it in child worker threads,
         * either call this method in child worker threads too, or set the
         * `process.env.NODE_COMPILE_CACHE` value to compile cache directory so the behavior can
         * be inherited into the child workers. The directory can be obtained either from the
         * `directory` field returned by this method, or with {@link getCompileCacheDir}.
         * @since v22.8.0
         * @param cacheDir Optional path to specify the directory where the compile cache
         * will be stored/retrieved.
         */
        function enableCompileCache(cacheDir?: string): EnableCompileCacheResult;
        /**
         * Flush the [module compile cache](https://nodejs.org/docs/latest-v22.x/api/module.html#module-compile-cache)
         * accumulated from modules already loaded
         * in the current Node.js instance to disk. This returns after all the flushing
         * file system operations come to an end, no matter they succeed or not. If there
         * are any errors, this will fail silently, since compile cache misses should not
         * interfere with the actual operation of the application.
         * @since v22.10.0
         */
        function flushCompileCache(): void;
        /**
         * @since v22.8.0
         * @return Path to the [module compile cache](https://nodejs.org/docs/latest-v22.x/api/module.html#module-compile-cache)
         * directory if it is enabled, or `undefined` otherwise.
         */
        function getCompileCacheDir(): string | undefined;
        /**
         * ```text
         * /path/to/project
         *    packages/
         *      bar/
         *        bar.js
         *        package.json // name = '@foo/bar'
         *      qux/
         *        node_modules/
         *          some-package/
         *            package.json // name = 'some-package'
         *        qux.js
         *        package.json // name = '@foo/qux'
         *    main.js
         *    package.json // name = '@foo'
         * ```
         * ```js
         * // /path/to/project/packages/bar/bar.js
         * import { findPackageJSON } from 'node:module';
         *
         * findPackageJSON('..', import.meta.url);
         * // '/path/to/project/package.json'
         * // Same result when passing an absolute specifier instead:
         * findPackageJSON(new URL('../', import.meta.url));
         * findPackageJSON(import.meta.resolve('../'));
         *
         * findPackageJSON('some-package', import.meta.url);
         * // '/path/to/project/packages/bar/node_modules/some-package/package.json'
         * // When passing an absolute specifier, you might get a different result if the
         * // resolved module is inside a subfolder that has nested `package.json`.
         * findPackageJSON(import.meta.resolve('some-package'));
         * // '/path/to/project/packages/bar/node_modules/some-package/some-subfolder/package.json'
         *
         * findPackageJSON('@foo/qux', import.meta.url);
         * // '/path/to/project/packages/qux/package.json'
         * ```
         * @since v22.14.0
         * @param specifier The specifier for the module whose `package.json` to
         * retrieve. When passing a _bare specifier_, the `package.json` at the root of
         * the package is returned. When passing a _relative specifier_ or an _absolute specifier_,
         * the closest parent `package.json` is returned.
         * @param base The absolute location (`file:` URL string or FS path) of the
         * containing  module. For CJS, use `__filename` (not `__dirname`!); for ESM, use
         * `import.meta.url`. You do not need to pass it if `specifier` is an _absolute specifier_.
         * @returns A path if the `package.json` is found. When `startLocation`
         * is a package, the package's root `package.json`; when a relative or unresolved, the closest
         * `package.json` to the `startLocation`.
         */
        function findPackageJSON(specifier: string | URL, base?: string | URL): string | undefined;
        /**
         * @since v18.6.0, v16.17.0
         */
        function isBuiltin(moduleName: string): boolean;
        interface RegisterOptions<Data> {
            /**
             * If you want to resolve `specifier` relative to a
             * base URL, such as `import.meta.url`, you can pass that URL here. This
             * property is ignored if the `parentURL` is supplied as the second argument.
             * @default 'data:'
             */
            parentURL?: string | URL | undefined;
            /**
             * Any arbitrary, cloneable JavaScript value to pass into the
             * {@link initialize} hook.
             */
            data?: Data | undefined;
            /**
             * [Transferable objects](https://nodejs.org/docs/latest-v22.x/api/worker_threads.html#portpostmessagevalue-transferlist)
             * to be passed into the `initialize` hook.
             */
            transferList?: any[] | undefined;
        }
        /* eslint-disable @definitelytyped/no-unnecessary-generics */
        /**
         * Register a module that exports hooks that customize Node.js module
         * resolution and loading behavior. See
         * [Customization hooks](https://nodejs.org/docs/latest-v22.x/api/module.html#customization-hooks).
         *
         * This feature requires `--allow-worker` if used with the
         * [Permission Model](https://nodejs.org/docs/latest-v22.x/api/permissions.html#permission-model).
         * @since v20.6.0, v18.19.0
         * @param specifier Customization hooks to be registered; this should be
         * the same string that would be passed to `import()`, except that if it is
         * relative, it is resolved relative to `parentURL`.
         * @param parentURL f you want to resolve `specifier` relative to a base
         * URL, such as `import.meta.url`, you can pass that URL here.
         */
        function register<Data = any>(
            specifier: string | URL,
            parentURL?: string | URL,
            options?: RegisterOptions<Data>,
        ): void;
        function register<Data = any>(specifier: string | URL, options?: RegisterOptions<Data>): void;
        interface RegisterHooksOptions {
            /**
             * See [load hook](https://nodejs.org/docs/latest-v22.x/api/module.html#loadurl-context-nextload).
             * @default undefined
             */
            load?: LoadHookSync | undefined;
            /**
             * See [resolve hook](https://nodejs.org/docs/latest-v22.x/api/module.html#resolvespecifier-context-nextresolve).
             * @default undefined
             */
            resolve?: ResolveHookSync | undefined;
        }
        interface ModuleHooks {
            /**
             * Deregister the hook instance.
             */
            deregister(): void;
        }
        /**
         * Register [hooks](https://nodejs.org/docs/latest-v22.x/api/module.html#customization-hooks)
         * that customize Node.js module resolution and loading behavior.
         * @since v22.15.0
         * @experimental
         */
        function registerHooks(options: RegisterHooksOptions): ModuleHooks;
        interface StripTypeScriptTypesOptions {
            /**
             * Possible values are:
             * * `'strip'` Only strip type annotations without performing the transformation of TypeScript features.
             * * `'transform'` Strip type annotations and transform TypeScript features to JavaScript.
             * @default 'strip'
             */
            mode?: "strip" | "transform" | undefined;
            /**
             * Only when `mode` is `'transform'`, if `true`, a source map
             * will be generated for the transformed code.
             * @default false
             */
            sourceMap?: boolean | undefined;
            /**
             * Specifies the source url used in the source map.
             */
            sourceUrl?: string | undefined;
        }
        /**
         * `module.stripTypeScriptTypes()` removes type annotations from TypeScript code. It
         * can be used to strip type annotations from TypeScript code before running it
         * with `vm.runInContext()` or `vm.compileFunction()`.
         * By default, it will throw an error if the code contains TypeScript features
         * that require transformation such as `Enums`,
         * see [type-stripping](https://nodejs.org/docs/latest-v22.x/api/typescript.md#type-stripping) for more information.
         * When mode is `'transform'`, it also transforms TypeScript features to JavaScript,
         * see [transform TypeScript features](https://nodejs.org/docs/latest-v22.x/api/typescript.md#typescript-features) for more information.
         * When mode is `'strip'`, source maps are not generated, because locations are preserved.
         * If `sourceMap` is provided, when mode is `'strip'`, an error will be thrown.
         *
         * _WARNING_: The output of this function should not be considered stable across Node.js versions,
         * due to changes in the TypeScript parser.
         *
         * ```js
         * import { stripTypeScriptTypes } from 'node:module';
         * const code = 'const a: number = 1;';
         * const strippedCode = stripTypeScriptTypes(code);
         * console.log(strippedCode);
         * // Prints: const a         = 1;
         * ```
         *
         * If `sourceUrl` is provided, it will be used appended as a comment at the end of the output:
         *
         * ```js
         * import { stripTypeScriptTypes } from 'node:module';
         * const code = 'const a: number = 1;';
         * const strippedCode = stripTypeScriptTypes(code, { mode: 'strip', sourceUrl: 'source.ts' });
         * console.log(strippedCode);
         * // Prints: const a         = 1\n\n//# sourceURL=source.ts;
         * ```
         *
         * When `mode` is `'transform'`, the code is transformed to JavaScript:
         *
         * ```js
         * import { stripTypeScriptTypes } from 'node:module';
         * const code = `
         *   namespace MathUtil {
         *     export const add = (a: number, b: number) => a + b;
         *   }`;
         * const strippedCode = stripTypeScriptTypes(code, { mode: 'transform', sourceMap: true });
         * console.log(strippedCode);
         * // Prints:
         * // var MathUtil;
         * // (function(MathUtil) {
         * //     MathUtil.add = (a, b)=>a + b;
         * // })(MathUtil || (MathUtil = {}));
         * // # sourceMappingURL=data:application/json;base64, ...
         * ```
         * @since v22.13.0
         * @param code The code to strip type annotations from.
         * @returns The code with type annotations stripped.
         */
        function stripTypeScriptTypes(code: string, options?: StripTypeScriptTypesOptions): string;
        /* eslint-enable @definitelytyped/no-unnecessary-generics */
        /**
         * The `module.syncBuiltinESMExports()` method updates all the live bindings for
         * builtin `ES Modules` to match the properties of the `CommonJS` exports. It
         * does not add or remove exported names from the `ES Modules`.
         *
         * ```js
         * import fs from 'node:fs';
         * import assert from 'node:assert';
         * import { syncBuiltinESMExports } from 'node:module';
         *
         * fs.readFile = newAPI;
         *
         * delete fs.readFileSync;
         *
         * function newAPI() {
         *   // ...
         * }
         *
         * fs.newAPI = newAPI;
         *
         * syncBuiltinESMExports();
         *
         * import('node:fs').then((esmFS) => {
         *   // It syncs the existing readFile property with the new value
         *   assert.strictEqual(esmFS.readFile, newAPI);
         *   // readFileSync has been deleted from the required fs
         *   assert.strictEqual('readFileSync' in fs, false);
         *   // syncBuiltinESMExports() does not remove readFileSync from esmFS
         *   assert.strictEqual('readFileSync' in esmFS, true);
         *   // syncBuiltinESMExports() does not add names
         *   assert.strictEqual(esmFS.newAPI, undefined);
         * });
         * ```
         * @since v12.12.0
         */
        function syncBuiltinESMExports(): void;
        interface ImportAttributes extends NodeJS.Dict<string> {
            type?: string | undefined;
        }
        type ModuleFormat =
            | "builtin"
            | "commonjs"
            | "commonjs-typescript"
            | "json"
            | "module"
            | "module-typescript"
            | "wasm";
        type ModuleSource = string | ArrayBuffer | NodeJS.TypedArray;
        /**
         * The `initialize` hook provides a way to define a custom function that runs in
         * the hooks thread when the hooks module is initialized. Initialization happens
         * when the hooks module is registered via {@link register}.
         *
         * This hook can receive data from a {@link register} invocation, including
         * ports and other transferable objects. The return value of `initialize` can be a
         * `Promise`, in which case it will be awaited before the main application thread
         * execution resumes.
         */
        type InitializeHook<Data = any> = (data: Data) => void | Promise<void>;
        interface ResolveHookContext {
            /**
             * Export conditions of the relevant `package.json`
             */
            conditions: string[];
            /**
             *  An object whose key-value pairs represent the assertions for the module to import
             */
            importAttributes: ImportAttributes;
            /**
             * The module importing this one, or undefined if this is the Node.js entry point
             */
            parentURL: string | undefined;
        }
        interface ResolveFnOutput {
            /**
             * A hint to the load hook (it might be ignored); can be an intermediary value.
             */
            format?: string | null | undefined;
            /**
             * The import attributes to use when caching the module (optional; if excluded the input will be used)
             */
            importAttributes?: ImportAttributes | undefined;
            /**
             * A signal that this hook intends to terminate the chain of `resolve` hooks.
             * @default false
             */
            shortCircuit?: boolean | undefined;
            /**
             * The absolute URL to which this input resolves
             */
            url: string;
        }
        /**
         * The `resolve` hook chain is responsible for telling Node.js where to find and
         * how to cache a given `import` statement or expression, or `require` call. It can
         * optionally return a format (such as `'module'`) as a hint to the `load` hook. If
         * a format is specified, the `load` hook is ultimately responsible for providing
         * the final `format` value (and it is free to ignore the hint provided by
         * `resolve`); if `resolve` provides a `format`, a custom `load` hook is required
         * even if only to pass the value to the Node.js default `load` hook.
         */
        type ResolveHook = (
            specifier: string,
            context: ResolveHookContext,
            nextResolve: (
                specifier: string,
                context?: Partial<ResolveHookContext>,
            ) => ResolveFnOutput | Promise<ResolveFnOutput>,
        ) => ResolveFnOutput | Promise<ResolveFnOutput>;
        type ResolveHookSync = (
            specifier: string,
            context: ResolveHookContext,
            nextResolve: (
                specifier: string,
                context?: Partial<ResolveHookContext>,
            ) => ResolveFnOutput,
        ) => ResolveFnOutput;
        interface LoadHookContext {
            /**
             * Export conditions of the relevant `package.json`
             */
            conditions: string[];
            /**
             * The format optionally supplied by the `resolve` hook chain (can be an intermediary value).
             */
            format: string | null | undefined;
            /**
             *  An object whose key-value pairs represent the assertions for the module to import
             */
            importAttributes: ImportAttributes;
        }
        interface LoadFnOutput {
            format: string | null | undefined;
            /**
             * A signal that this hook intends to terminate the chain of `resolve` hooks.
             * @default false
             */
            shortCircuit?: boolean | undefined;
            /**
             * The source for Node.js to evaluate
             */
            source?: ModuleSource | undefined;
        }
        /**
         * The `load` hook provides a way to define a custom method of determining how a
         * URL should be interpreted, retrieved, and parsed. It is also in charge of
         * validating the import attributes.
         */
        type LoadHook = (
            url: string,
            context: LoadHookContext,
            nextLoad: (
                url: string,
                context?: Partial<LoadHookContext>,
            ) => LoadFnOutput | Promise<LoadFnOutput>,
        ) => LoadFnOutput | Promise<LoadFnOutput>;
        type LoadHookSync = (
            url: string,
            context: LoadHookContext,
            nextLoad: (
                url: string,
                context?: Partial<LoadHookContext>,
            ) => LoadFnOutput,
        ) => LoadFnOutput;
        interface SourceMapsSupport {
            /**
             * If the source maps support is enabled
             */
            enabled: boolean;
            /**
             * If the support is enabled for files in `node_modules`.
             */
            nodeModules: boolean;
            /**
             * If the support is enabled for generated code from `eval` or `new Function`.
             */
            generatedCode: boolean;
        }
        /**
         * This method returns whether the [Source Map v3](https://tc39.es/ecma426/) support for stack
         * traces is enabled.
         * @since v22.14.0
         */
        function getSourceMapsSupport(): SourceMapsSupport;
        /**
         * `path` is the resolved path for the file for which a corresponding source map
         * should be fetched.
         * @since v13.7.0, v12.17.0
         * @return Returns `module.SourceMap` if a source map is found, `undefined` otherwise.
         */
        function findSourceMap(path: string): SourceMap | undefined;
        interface SetSourceMapsSupportOptions {
            /**
             * If enabling the support for files in `node_modules`.
             * @default false
             */
            nodeModules?: boolean | undefined;
            /**
             * If enabling the support for generated code from `eval` or `new Function`.
             * @default false
             */
            generatedCode?: boolean | undefined;
        }
        /**
         * This function enables or disables the [Source Map v3](https://tc39.es/ecma426/) support for
         * stack traces.
         *
         * It provides same features as launching Node.js process with commandline options
         * `--enable-source-maps`, with additional options to alter the support for files
         * in `node_modules` or generated codes.
         *
         * Only source maps in JavaScript files that are loaded after source maps has been
         * enabled will be parsed and loaded. Preferably, use the commandline options
         * `--enable-source-maps` to avoid losing track of source maps of modules loaded
         * before this API call.
         * @since v22.14.0
         */
        function setSourceMapsSupport(enabled: boolean, options?: SetSourceMapsSupportOptions): void;
        interface SourceMapConstructorOptions {
            /**
             * @since v21.0.0, v20.5.0
             */
            lineLengths?: readonly number[] | undefined;
        }
        interface SourceMapPayload {
            file: string;
            version: number;
            sources: string[];
            sourcesContent: string[];
            names: string[];
            mappings: string;
            sourceRoot: string;
        }
        interface SourceMapping {
            generatedLine: number;
            generatedColumn: number;
            originalSource: string;
            originalLine: number;
            originalColumn: number;
        }
        interface SourceOrigin {
            /**
             * The name of the range in the source map, if one was provided
             */
            name: string | undefined;
            /**
             * The file name of the original source, as reported in the SourceMap
             */
            fileName: string;
            /**
             * The 1-indexed lineNumber of the corresponding call site in the original source
             */
            lineNumber: number;
            /**
             * The 1-indexed columnNumber of the corresponding call site in the original source
             */
            columnNumber: number;
        }
        /**
         * @since v13.7.0, v12.17.0
         */
        class SourceMap {
            constructor(payload: SourceMapPayload, options?: SourceMapConstructorOptions);
            /**
             * Getter for the payload used to construct the `SourceMap` instance.
             */
            readonly payload: SourceMapPayload;
            /**
             * Given a line offset and column offset in the generated source
             * file, returns an object representing the SourceMap range in the
             * original file if found, or an empty object if not.
             *
             * The object returned contains the following keys:
             *
             * The returned value represents the raw range as it appears in the
             * SourceMap, based on zero-indexed offsets, _not_ 1-indexed line and
             * column numbers as they appear in Error messages and CallSite
             * objects.
             *
             * To get the corresponding 1-indexed line and column numbers from a
             * lineNumber and columnNumber as they are reported by Error stacks
             * and CallSite objects, use `sourceMap.findOrigin(lineNumber, columnNumber)`
             * @param lineOffset The zero-indexed line number offset in the generated source
             * @param columnOffset The zero-indexed column number offset in the generated source
             */
            findEntry(lineOffset: number, columnOffset: number): SourceMapping | {};
            /**
             * Given a 1-indexed `lineNumber` and `columnNumber` from a call site in the generated source,
             * find the corresponding call site location in the original source.
             *
             * If the `lineNumber` and `columnNumber` provided are not found in any source map,
             * then an empty object is returned.
             * @param lineNumber The 1-indexed line number of the call site in the generated source
             * @param columnNumber The 1-indexed column number of the call site in the generated source
             */
            findOrigin(lineNumber: number, columnNumber: number): SourceOrigin | {};
        }
        function runMain(main?: string): void;
        function wrap(script: string): string;
    }
    global {
        interface ImportMeta {
            /**
             * The directory name of the current module.
             *
             * This is the same as the `path.dirname()` of the `import.meta.filename`.
             *
             * > **Caveat**: only present on `file:` modules.
             * @since v21.2.0, v20.11.0
             */
            dirname: string;
            /**
             * The full absolute path and filename of the current module, with
             * symlinks resolved.
             *
             * This is the same as the `url.fileURLToPath()` of the `import.meta.url`.
             *
             * > **Caveat** only local modules support this property. Modules not using the
             * > `file:` protocol will not provide it.
             * @since v21.2.0, v20.11.0
             */
            filename: string;
            /**
             * The absolute `file:` URL of the module.
             *
             * This is defined exactly the same as it is in browsers providing the URL of the
             * current module file.
             *
             * This enables useful patterns such as relative file loading:
             *
             * ```js
             * import { readFileSync } from 'node:fs';
             * const buffer = readFileSync(new URL('./data.proto', import.meta.url));
             * ```
             */
            url: string;
            /**
             * `import.meta.resolve` is a module-relative resolution function scoped to
             * each module, returning the URL string.
             *
             * ```js
             * const dependencyAsset = import.meta.resolve('component-lib/asset.css');
             * // file:///app/node_modules/component-lib/asset.css
             * import.meta.resolve('./dep.js');
             * // file:///app/dep.js
             * ```
             *
             * All features of the Node.js module resolution are supported. Dependency
             * resolutions are subject to the permitted exports resolutions within the package.
             *
             * **Caveats**:
             *
             * * This can result in synchronous file-system operations, which
             *   can impact performance similarly to `require.resolve`.
             * * This feature is not available within custom loaders (it would
             *   create a deadlock).
             * @since v13.9.0, v12.16.0
             * @param specifier The module specifier to resolve relative to the
             * current module.
             * @param parent An optional absolute parent module URL to resolve from.
             * **Default:** `import.meta.url`
             * @returns The absolute URL string that the specifier would resolve to.
             */
            resolve(specifier: string, parent?: string | URL): string;
            /**
             * `true` when the current module is the entry point of the current process; `false` otherwise.
             *
             * Equivalent to `require.main === module` in CommonJS.
             *
             * Analogous to Python's `__name__ == "__main__"`.
             *
             * ```js
             * export function foo() {
             *   return 'Hello, world';
             * }
             *
             * function main() {
             *   const message = foo();
             *   console.log(message);
             * }
             *
             * if (import.meta.main) main();
             * // `foo` can be imported from another module without possible side-effects from `main`
             * ```
             * @since v22.18.0
             * @experimental
             */
            main: boolean;
        }
        namespace NodeJS {
            interface Module {
                /**
                 * The module objects required for the first time by this one.
                 * @since v0.1.16
                 */
                children: Module[];
                /**
                 * The `module.exports` object is created by the `Module` system. Sometimes this is
                 * not acceptable; many want their module to be an instance of some class. To do
                 * this, assign the desired export object to `module.exports`.
                 * @since v0.1.16
                 */
                exports: any;
                /**
                 * The fully resolved filename of the module.
                 * @since v0.1.16
                 */
                filename: string;
                /**
                 * The identifier for the module. Typically this is the fully resolved
                 * filename.
                 * @since v0.1.16
                 */
                id: string;
                /**
                 * `true` if the module is running during the Node.js preload
                 * phase.
                 * @since v15.4.0, v14.17.0
                 */
                isPreloading: boolean;
                /**
                 * Whether or not the module is done loading, or is in the process of
                 * loading.
                 * @since v0.1.16
                 */
                loaded: boolean;
                /**
                 * The module that first required this one, or `null` if the current module is the
                 * entry point of the current process, or `undefined` if the module was loaded by
                 * something that is not a CommonJS module (e.g. REPL or `import`).
                 * @since v0.1.16
                 * @deprecated Please use `require.main` and `module.children` instead.
                 */
                parent: Module | null | undefined;
                /**
                 * The directory name of the module. This is usually the same as the
                 * `path.dirname()` of the `module.id`.
                 * @since v11.14.0
                 */
                path: string;
                /**
                 * The search paths for the module.
                 * @since v0.4.0
                 */
                paths: string[];
                /**
                 * The `module.require()` method provides a way to load a module as if
                 * `require()` was called from the original module.
                 * @since v0.5.1
                 */
                require(id: string): any;
            }
            interface Require {
                /**
                 * Used to import modules, `JSON`, and local files.
                 * @since v0.1.13
                 */
                (id: string): any;
                /**
                 * Modules are cached in this object when they are required. By deleting a key
                 * value from this object, the next `require` will reload the module.
                 * This does not apply to
                 * [native addons](https://nodejs.org/docs/latest-v22.x/api/addons.html),
                 * for which reloading will result in an error.
                 * @since v0.3.0
                 */
                cache: Dict<Module>;
                /**
                 * Instruct `require` on how to handle certain file extensions.
                 * @since v0.3.0
                 * @deprecated
                 */
                extensions: RequireExtensions;
                /**
                 * The `Module` object representing the entry script loaded when the Node.js
                 * process launched, or `undefined` if the entry point of the program is not a
                 * CommonJS module.
                 * @since v0.1.17
                 */
                main: Module | undefined;
                /**
                 * @since v0.3.0
                 */
                resolve: RequireResolve;
            }
            /** @deprecated */
            interface RequireExtensions extends Dict<(module: Module, filename: string) => any> {
                ".js": (module: Module, filename: string) => any;
                ".json": (module: Module, filename: string) => any;
                ".node": (module: Module, filename: string) => any;
            }
            interface RequireResolveOptions {
                /**
                 * Paths to resolve module location from. If present, these
                 * paths are used instead of the default resolution paths, with the exception
                 * of
                 * [GLOBAL\_FOLDERS](https://nodejs.org/docs/latest-v22.x/api/modules.html#loading-from-the-global-folders)
                 * like `$HOME/.node_modules`, which are
                 * always included. Each of these paths is used as a starting point for
                 * the module resolution algorithm, meaning that the `node_modules` hierarchy
                 * is checked from this location.
                 * @since v8.9.0
                 */
                paths?: string[] | undefined;
            }
            interface RequireResolve {
                /**
                 * Use the internal `require()` machinery to look up the location of a module,
                 * but rather than loading the module, just return the resolved filename.
                 *
                 * If the module can not be found, a `MODULE_NOT_FOUND` error is thrown.
                 * @since v0.3.0
                 * @param request The module path to resolve.
                 */
                (request: string, options?: RequireResolveOptions): string;
                /**
                 * Returns an array containing the paths searched during resolution of `request` or
                 * `null` if the `request` string references a core module, for example `http` or
                 * `fs`.
                 * @since v8.9.0
                 * @param request The module path whose lookup paths are being retrieved.
                 */
                paths(request: string): string[] | null;
            }
        }
        /**
         * The directory name of the current module. This is the same as the
         * `path.dirname()` of the `__filename`.
         * @since v0.1.27
         */
        var __dirname: string;
        /**
         * The file name of the current module. This is the current module file's absolute
         * path with symlinks resolved.
         *
         * For a main program this is not necessarily the same as the file name used in the
         * command line.
         * @since v0.0.1
         */
        var __filename: string;
        /**
         * The `exports` variable is available within a module's file-level scope, and is
         * assigned the value of `module.exports` before the module is evaluated.
         * @since v0.1.16
         */
        var exports: NodeJS.Module["exports"];
        /**
         * A reference to the current module.
         * @since v0.1.16
         */
        var module: NodeJS.Module;
        /**
         * @since v0.1.13
         */
        var require: NodeJS.Require;
        // Global-scope aliases for backwards compatibility with @types/node <13.0.x
        /** @deprecated Use `NodeJS.Module` instead. */
        interface NodeModule extends NodeJS.Module {}
        /** @deprecated Use `NodeJS.Require` instead. */
        interface NodeRequire extends NodeJS.Require {}
        /** @deprecated Use `NodeJS.RequireResolve` instead. */
        interface RequireResolve extends NodeJS.RequireResolve {}
    }
    export = Module;
}
declare module "node:module" {
    import module = require("module");
    export = module;
}

```

## ./lib/lambda/node_modules/@types/node/net.d.ts

```typescript
/**
 * > Stability: 2 - Stable
 *
 * The `node:net` module provides an asynchronous network API for creating stream-based
 * TCP or `IPC` servers ({@link createServer}) and clients
 * ({@link createConnection}).
 *
 * It can be accessed using:
 *
 * ```js
 * import net from 'node:net';
 * ```
 * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/net.js)
 */
declare module "net" {
    import * as stream from "node:stream";
    import { Abortable, EventEmitter } from "node:events";
    import * as dns from "node:dns";
    type LookupFunction = (
        hostname: string,
        options: dns.LookupOptions,
        callback: (err: NodeJS.ErrnoException | null, address: string | dns.LookupAddress[], family?: number) => void,
    ) => void;
    interface AddressInfo {
        address: string;
        family: string;
        port: number;
    }
    interface SocketConstructorOpts {
        fd?: number | undefined;
        allowHalfOpen?: boolean | undefined;
        onread?: OnReadOpts | undefined;
        readable?: boolean | undefined;
        writable?: boolean | undefined;
        signal?: AbortSignal | undefined;
    }
    interface OnReadOpts {
        buffer: Uint8Array | (() => Uint8Array);
        /**
         * This function is called for every chunk of incoming data.
         * Two arguments are passed to it: the number of bytes written to `buffer` and a reference to `buffer`.
         * Return `false` from this function to implicitly `pause()` the socket.
         */
        callback(bytesWritten: number, buffer: Uint8Array): boolean;
    }
    // TODO: remove empty ConnectOpts placeholder at next major @types/node version.
    /** @deprecated */
    interface ConnectOpts {}
    interface TcpSocketConnectOpts {
        port: number;
        host?: string | undefined;
        localAddress?: string | undefined;
        localPort?: number | undefined;
        hints?: number | undefined;
        family?: number | undefined;
        lookup?: LookupFunction | undefined;
        noDelay?: boolean | undefined;
        keepAlive?: boolean | undefined;
        keepAliveInitialDelay?: number | undefined;
        /**
         * @since v18.13.0
         */
        autoSelectFamily?: boolean | undefined;
        /**
         * @since v18.13.0
         */
        autoSelectFamilyAttemptTimeout?: number | undefined;
        blockList?: BlockList | undefined;
    }
    interface IpcSocketConnectOpts {
        path: string;
    }
    type SocketConnectOpts = TcpSocketConnectOpts | IpcSocketConnectOpts;
    type SocketReadyState = "opening" | "open" | "readOnly" | "writeOnly" | "closed";
    /**
     * This class is an abstraction of a TCP socket or a streaming `IPC` endpoint
     * (uses named pipes on Windows, and Unix domain sockets otherwise). It is also
     * an `EventEmitter`.
     *
     * A `net.Socket` can be created by the user and used directly to interact with
     * a server. For example, it is returned by {@link createConnection},
     * so the user can use it to talk to the server.
     *
     * It can also be created by Node.js and passed to the user when a connection
     * is received. For example, it is passed to the listeners of a `'connection'` event emitted on a {@link Server}, so the user can use
     * it to interact with the client.
     * @since v0.3.4
     */
    class Socket extends stream.Duplex {
        constructor(options?: SocketConstructorOpts);
        /**
         * Destroys the socket after all data is written. If the `finish` event was already emitted the socket is destroyed immediately.
         * If the socket is still writable it implicitly calls `socket.end()`.
         * @since v0.3.4
         */
        destroySoon(): void;
        /**
         * Sends data on the socket. The second parameter specifies the encoding in the
         * case of a string. It defaults to UTF8 encoding.
         *
         * Returns `true` if the entire data was flushed successfully to the kernel
         * buffer. Returns `false` if all or part of the data was queued in user memory.`'drain'` will be emitted when the buffer is again free.
         *
         * The optional `callback` parameter will be executed when the data is finally
         * written out, which may not be immediately.
         *
         * See `Writable` stream `write()` method for more
         * information.
         * @since v0.1.90
         * @param [encoding='utf8'] Only used when data is `string`.
         */
        write(buffer: Uint8Array | string, cb?: (err?: Error | null) => void): boolean;
        write(str: Uint8Array | string, encoding?: BufferEncoding, cb?: (err?: Error | null) => void): boolean;
        /**
         * Initiate a connection on a given socket.
         *
         * Possible signatures:
         *
         * * `socket.connect(options[, connectListener])`
         * * `socket.connect(path[, connectListener])` for `IPC` connections.
         * * `socket.connect(port[, host][, connectListener])` for TCP connections.
         * * Returns: `net.Socket` The socket itself.
         *
         * This function is asynchronous. When the connection is established, the `'connect'` event will be emitted. If there is a problem connecting,
         * instead of a `'connect'` event, an `'error'` event will be emitted with
         * the error passed to the `'error'` listener.
         * The last parameter `connectListener`, if supplied, will be added as a listener
         * for the `'connect'` event **once**.
         *
         * This function should only be used for reconnecting a socket after`'close'` has been emitted or otherwise it may lead to undefined
         * behavior.
         */
        connect(options: SocketConnectOpts, connectionListener?: () => void): this;
        connect(port: number, host: string, connectionListener?: () => void): this;
        connect(port: number, connectionListener?: () => void): this;
        connect(path: string, connectionListener?: () => void): this;
        /**
         * Set the encoding for the socket as a `Readable Stream`. See `readable.setEncoding()` for more information.
         * @since v0.1.90
         * @return The socket itself.
         */
        setEncoding(encoding?: BufferEncoding): this;
        /**
         * Pauses the reading of data. That is, `'data'` events will not be emitted.
         * Useful to throttle back an upload.
         * @return The socket itself.
         */
        pause(): this;
        /**
         * Close the TCP connection by sending an RST packet and destroy the stream.
         * If this TCP socket is in connecting status, it will send an RST packet and destroy this TCP socket once it is connected.
         * Otherwise, it will call `socket.destroy` with an `ERR_SOCKET_CLOSED` Error.
         * If this is not a TCP socket (for example, a pipe), calling this method will immediately throw an `ERR_INVALID_HANDLE_TYPE` Error.
         * @since v18.3.0, v16.17.0
         */
        resetAndDestroy(): this;
        /**
         * Resumes reading after a call to `socket.pause()`.
         * @return The socket itself.
         */
        resume(): this;
        /**
         * Sets the socket to timeout after `timeout` milliseconds of inactivity on
         * the socket. By default `net.Socket` do not have a timeout.
         *
         * When an idle timeout is triggered the socket will receive a `'timeout'` event but the connection will not be severed. The user must manually call `socket.end()` or `socket.destroy()` to
         * end the connection.
         *
         * ```js
         * socket.setTimeout(3000);
         * socket.on('timeout', () => {
         *   console.log('socket timeout');
         *   socket.end();
         * });
         * ```
         *
         * If `timeout` is 0, then the existing idle timeout is disabled.
         *
         * The optional `callback` parameter will be added as a one-time listener for the `'timeout'` event.
         * @since v0.1.90
         * @return The socket itself.
         */
        setTimeout(timeout: number, callback?: () => void): this;
        /**
         * Enable/disable the use of Nagle's algorithm.
         *
         * When a TCP connection is created, it will have Nagle's algorithm enabled.
         *
         * Nagle's algorithm delays data before it is sent via the network. It attempts
         * to optimize throughput at the expense of latency.
         *
         * Passing `true` for `noDelay` or not passing an argument will disable Nagle's
         * algorithm for the socket. Passing `false` for `noDelay` will enable Nagle's
         * algorithm.
         * @since v0.1.90
         * @param [noDelay=true]
         * @return The socket itself.
         */
        setNoDelay(noDelay?: boolean): this;
        /**
         * Enable/disable keep-alive functionality, and optionally set the initial
         * delay before the first keepalive probe is sent on an idle socket.
         *
         * Set `initialDelay` (in milliseconds) to set the delay between the last
         * data packet received and the first keepalive probe. Setting `0` for`initialDelay` will leave the value unchanged from the default
         * (or previous) setting.
         *
         * Enabling the keep-alive functionality will set the following socket options:
         *
         * * `SO_KEEPALIVE=1`
         * * `TCP_KEEPIDLE=initialDelay`
         * * `TCP_KEEPCNT=10`
         * * `TCP_KEEPINTVL=1`
         * @since v0.1.92
         * @param [enable=false]
         * @param [initialDelay=0]
         * @return The socket itself.
         */
        setKeepAlive(enable?: boolean, initialDelay?: number): this;
        /**
         * Returns the bound `address`, the address `family` name and `port` of the
         * socket as reported by the operating system:`{ port: 12346, family: 'IPv4', address: '127.0.0.1' }`
         * @since v0.1.90
         */
        address(): AddressInfo | {};
        /**
         * Calling `unref()` on a socket will allow the program to exit if this is the only
         * active socket in the event system. If the socket is already `unref`ed calling`unref()` again will have no effect.
         * @since v0.9.1
         * @return The socket itself.
         */
        unref(): this;
        /**
         * Opposite of `unref()`, calling `ref()` on a previously `unref`ed socket will _not_ let the program exit if it's the only socket left (the default behavior).
         * If the socket is `ref`ed calling `ref` again will have no effect.
         * @since v0.9.1
         * @return The socket itself.
         */
        ref(): this;
        /**
         * This property is only present if the family autoselection algorithm is enabled in `socket.connect(options)`
         * and it is an array of the addresses that have been attempted.
         *
         * Each address is a string in the form of `$IP:$PORT`.
         * If the connection was successful, then the last address is the one that the socket is currently connected to.
         * @since v19.4.0
         */
        readonly autoSelectFamilyAttemptedAddresses: string[];
        /**
         * This property shows the number of characters buffered for writing. The buffer
         * may contain strings whose length after encoding is not yet known. So this number
         * is only an approximation of the number of bytes in the buffer.
         *
         * `net.Socket` has the property that `socket.write()` always works. This is to
         * help users get up and running quickly. The computer cannot always keep up
         * with the amount of data that is written to a socket. The network connection
         * simply might be too slow. Node.js will internally queue up the data written to a
         * socket and send it out over the wire when it is possible.
         *
         * The consequence of this internal buffering is that memory may grow.
         * Users who experience large or growing `bufferSize` should attempt to
         * "throttle" the data flows in their program with `socket.pause()` and `socket.resume()`.
         * @since v0.3.8
         * @deprecated Since v14.6.0 - Use `writableLength` instead.
         */
        readonly bufferSize: number;
        /**
         * The amount of received bytes.
         * @since v0.5.3
         */
        readonly bytesRead: number;
        /**
         * The amount of bytes sent.
         * @since v0.5.3
         */
        readonly bytesWritten: number;
        /**
         * If `true`, `socket.connect(options[, connectListener])` was
         * called and has not yet finished. It will stay `true` until the socket becomes
         * connected, then it is set to `false` and the `'connect'` event is emitted. Note
         * that the `socket.connect(options[, connectListener])` callback is a listener for the `'connect'` event.
         * @since v6.1.0
         */
        readonly connecting: boolean;
        /**
         * This is `true` if the socket is not connected yet, either because `.connect()`has not yet been called or because it is still in the process of connecting
         * (see `socket.connecting`).
         * @since v11.2.0, v10.16.0
         */
        readonly pending: boolean;
        /**
         * See `writable.destroyed` for further details.
         */
        readonly destroyed: boolean;
        /**
         * The string representation of the local IP address the remote client is
         * connecting on. For example, in a server listening on `'0.0.0.0'`, if a client
         * connects on `'192.168.1.1'`, the value of `socket.localAddress` would be`'192.168.1.1'`.
         * @since v0.9.6
         */
        readonly localAddress?: string;
        /**
         * The numeric representation of the local port. For example, `80` or `21`.
         * @since v0.9.6
         */
        readonly localPort?: number;
        /**
         * The string representation of the local IP family. `'IPv4'` or `'IPv6'`.
         * @since v18.8.0, v16.18.0
         */
        readonly localFamily?: string;
        /**
         * This property represents the state of the connection as a string.
         *
         * * If the stream is connecting `socket.readyState` is `opening`.
         * * If the stream is readable and writable, it is `open`.
         * * If the stream is readable and not writable, it is `readOnly`.
         * * If the stream is not readable and writable, it is `writeOnly`.
         * @since v0.5.0
         */
        readonly readyState: SocketReadyState;
        /**
         * The string representation of the remote IP address. For example,`'74.125.127.100'` or `'2001:4860:a005::68'`. Value may be `undefined` if
         * the socket is destroyed (for example, if the client disconnected).
         * @since v0.5.10
         */
        readonly remoteAddress: string | undefined;
        /**
         * The string representation of the remote IP family. `'IPv4'` or `'IPv6'`. Value may be `undefined` if
         * the socket is destroyed (for example, if the client disconnected).
         * @since v0.11.14
         */
        readonly remoteFamily: string | undefined;
        /**
         * The numeric representation of the remote port. For example, `80` or `21`. Value may be `undefined` if
         * the socket is destroyed (for example, if the client disconnected).
         * @since v0.5.10
         */
        readonly remotePort: number | undefined;
        /**
         * The socket timeout in milliseconds as set by `socket.setTimeout()`.
         * It is `undefined` if a timeout has not been set.
         * @since v10.7.0
         */
        readonly timeout?: number;
        /**
         * Half-closes the socket. i.e., it sends a FIN packet. It is possible the
         * server will still send some data.
         *
         * See `writable.end()` for further details.
         * @since v0.1.90
         * @param [encoding='utf8'] Only used when data is `string`.
         * @param callback Optional callback for when the socket is finished.
         * @return The socket itself.
         */
        end(callback?: () => void): this;
        end(buffer: Uint8Array | string, callback?: () => void): this;
        end(str: Uint8Array | string, encoding?: BufferEncoding, callback?: () => void): this;
        /**
         * events.EventEmitter
         *   1. close
         *   2. connect
         *   3. connectionAttempt
         *   4. connectionAttemptFailed
         *   5. connectionAttemptTimeout
         *   6. data
         *   7. drain
         *   8. end
         *   9. error
         *   10. lookup
         *   11. ready
         *   12. timeout
         */
        addListener(event: string, listener: (...args: any[]) => void): this;
        addListener(event: "close", listener: (hadError: boolean) => void): this;
        addListener(event: "connect", listener: () => void): this;
        addListener(event: "connectionAttempt", listener: (ip: string, port: number, family: number) => void): this;
        addListener(
            event: "connectionAttemptFailed",
            listener: (ip: string, port: number, family: number, error: Error) => void,
        ): this;
        addListener(
            event: "connectionAttemptTimeout",
            listener: (ip: string, port: number, family: number) => void,
        ): this;
        addListener(event: "data", listener: (data: Buffer) => void): this;
        addListener(event: "drain", listener: () => void): this;
        addListener(event: "end", listener: () => void): this;
        addListener(event: "error", listener: (err: Error) => void): this;
        addListener(
            event: "lookup",
            listener: (err: Error, address: string, family: string | number, host: string) => void,
        ): this;
        addListener(event: "ready", listener: () => void): this;
        addListener(event: "timeout", listener: () => void): this;
        emit(event: string | symbol, ...args: any[]): boolean;
        emit(event: "close", hadError: boolean): boolean;
        emit(event: "connect"): boolean;
        emit(event: "connectionAttempt", ip: string, port: number, family: number): boolean;
        emit(event: "connectionAttemptFailed", ip: string, port: number, family: number, error: Error): boolean;
        emit(event: "connectionAttemptTimeout", ip: string, port: number, family: number): boolean;
        emit(event: "data", data: Buffer): boolean;
        emit(event: "drain"): boolean;
        emit(event: "end"): boolean;
        emit(event: "error", err: Error): boolean;
        emit(event: "lookup", err: Error, address: string, family: string | number, host: string): boolean;
        emit(event: "ready"): boolean;
        emit(event: "timeout"): boolean;
        on(event: string, listener: (...args: any[]) => void): this;
        on(event: "close", listener: (hadError: boolean) => void): this;
        on(event: "connect", listener: () => void): this;
        on(event: "connectionAttempt", listener: (ip: string, port: number, family: number) => void): this;
        on(
            event: "connectionAttemptFailed",
            listener: (ip: string, port: number, family: number, error: Error) => void,
        ): this;
        on(event: "connectionAttemptTimeout", listener: (ip: string, port: number, family: number) => void): this;
        on(event: "data", listener: (data: Buffer) => void): this;
        on(event: "drain", listener: () => void): this;
        on(event: "end", listener: () => void): this;
        on(event: "error", listener: (err: Error) => void): this;
        on(
            event: "lookup",
            listener: (err: Error, address: string, family: string | number, host: string) => void,
        ): this;
        on(event: "ready", listener: () => void): this;
        on(event: "timeout", listener: () => void): this;
        once(event: string, listener: (...args: any[]) => void): this;
        once(event: "close", listener: (hadError: boolean) => void): this;
        once(event: "connectionAttempt", listener: (ip: string, port: number, family: number) => void): this;
        once(
            event: "connectionAttemptFailed",
            listener: (ip: string, port: number, family: number, error: Error) => void,
        ): this;
        once(event: "connectionAttemptTimeout", listener: (ip: string, port: number, family: number) => void): this;
        once(event: "connect", listener: () => void): this;
        once(event: "data", listener: (data: Buffer) => void): this;
        once(event: "drain", listener: () => void): this;
        once(event: "end", listener: () => void): this;
        once(event: "error", listener: (err: Error) => void): this;
        once(
            event: "lookup",
            listener: (err: Error, address: string, family: string | number, host: string) => void,
        ): this;
        once(event: "ready", listener: () => void): this;
        once(event: "timeout", listener: () => void): this;
        prependListener(event: string, listener: (...args: any[]) => void): this;
        prependListener(event: "close", listener: (hadError: boolean) => void): this;
        prependListener(event: "connect", listener: () => void): this;
        prependListener(event: "connectionAttempt", listener: (ip: string, port: number, family: number) => void): this;
        prependListener(
            event: "connectionAttemptFailed",
            listener: (ip: string, port: number, family: number, error: Error) => void,
        ): this;
        prependListener(
            event: "connectionAttemptTimeout",
            listener: (ip: string, port: number, family: number) => void,
        ): this;
        prependListener(event: "data", listener: (data: Buffer) => void): this;
        prependListener(event: "drain", listener: () => void): this;
        prependListener(event: "end", listener: () => void): this;
        prependListener(event: "error", listener: (err: Error) => void): this;
        prependListener(
            event: "lookup",
            listener: (err: Error, address: string, family: string | number, host: string) => void,
        ): this;
        prependListener(event: "ready", listener: () => void): this;
        prependListener(event: "timeout", listener: () => void): this;
        prependOnceListener(event: string, listener: (...args: any[]) => void): this;
        prependOnceListener(event: "close", listener: (hadError: boolean) => void): this;
        prependOnceListener(event: "connect", listener: () => void): this;
        prependOnceListener(
            event: "connectionAttempt",
            listener: (ip: string, port: number, family: number) => void,
        ): this;
        prependOnceListener(
            event: "connectionAttemptFailed",
            listener: (ip: string, port: number, family: number, error: Error) => void,
        ): this;
        prependOnceListener(
            event: "connectionAttemptTimeout",
            listener: (ip: string, port: number, family: number) => void,
        ): this;
        prependOnceListener(event: "data", listener: (data: Buffer) => void): this;
        prependOnceListener(event: "drain", listener: () => void): this;
        prependOnceListener(event: "end", listener: () => void): this;
        prependOnceListener(event: "error", listener: (err: Error) => void): this;
        prependOnceListener(
            event: "lookup",
            listener: (err: Error, address: string, family: string | number, host: string) => void,
        ): this;
        prependOnceListener(event: "ready", listener: () => void): this;
        prependOnceListener(event: "timeout", listener: () => void): this;
    }
    interface ListenOptions extends Abortable {
        backlog?: number | undefined;
        exclusive?: boolean | undefined;
        host?: string | undefined;
        /**
         * @default false
         */
        ipv6Only?: boolean | undefined;
        reusePort?: boolean | undefined;
        path?: string | undefined;
        port?: number | undefined;
        readableAll?: boolean | undefined;
        writableAll?: boolean | undefined;
    }
    interface ServerOpts {
        /**
         * Indicates whether half-opened TCP connections are allowed.
         * @default false
         */
        allowHalfOpen?: boolean | undefined;
        /**
         * Indicates whether the socket should be paused on incoming connections.
         * @default false
         */
        pauseOnConnect?: boolean | undefined;
        /**
         * If set to `true`, it disables the use of Nagle's algorithm immediately after a new incoming connection is received.
         * @default false
         * @since v16.5.0
         */
        noDelay?: boolean | undefined;
        /**
         * If set to `true`, it enables keep-alive functionality on the socket immediately after a new incoming connection is received,
         * similarly on what is done in `socket.setKeepAlive([enable][, initialDelay])`.
         * @default false
         * @since v16.5.0
         */
        keepAlive?: boolean | undefined;
        /**
         * If set to a positive number, it sets the initial delay before the first keepalive probe is sent on an idle socket.
         * @default 0
         * @since v16.5.0
         */
        keepAliveInitialDelay?: number | undefined;
        /**
         * Optionally overrides all `net.Socket`s' `readableHighWaterMark` and `writableHighWaterMark`.
         * @default See [stream.getDefaultHighWaterMark()](https://nodejs.org/docs/latest-v22.x/api/stream.html#streamgetdefaulthighwatermarkobjectmode).
         * @since v18.17.0, v20.1.0
         */
        highWaterMark?: number | undefined;
        /**
         * `blockList` can be used for disabling inbound
         * access to specific IP addresses, IP ranges, or IP subnets. This does not
         * work if the server is behind a reverse proxy, NAT, etc. because the address
         * checked against the block list is the address of the proxy, or the one
         * specified by the NAT.
         * @since v22.13.0
         */
        blockList?: BlockList | undefined;
    }
    interface DropArgument {
        localAddress?: string;
        localPort?: number;
        localFamily?: string;
        remoteAddress?: string;
        remotePort?: number;
        remoteFamily?: string;
    }
    /**
     * This class is used to create a TCP or `IPC` server.
     * @since v0.1.90
     */
    class Server extends EventEmitter {
        constructor(connectionListener?: (socket: Socket) => void);
        constructor(options?: ServerOpts, connectionListener?: (socket: Socket) => void);
        /**
         * Start a server listening for connections. A `net.Server` can be a TCP or
         * an `IPC` server depending on what it listens to.
         *
         * Possible signatures:
         *
         * * `server.listen(handle[, backlog][, callback])`
         * * `server.listen(options[, callback])`
         * * `server.listen(path[, backlog][, callback])` for `IPC` servers
         * * `server.listen([port[, host[, backlog]]][, callback])` for TCP servers
         *
         * This function is asynchronous. When the server starts listening, the `'listening'` event will be emitted. The last parameter `callback`will be added as a listener for the `'listening'`
         * event.
         *
         * All `listen()` methods can take a `backlog` parameter to specify the maximum
         * length of the queue of pending connections. The actual length will be determined
         * by the OS through sysctl settings such as `tcp_max_syn_backlog` and `somaxconn` on Linux. The default value of this parameter is 511 (not 512).
         *
         * All {@link Socket} are set to `SO_REUSEADDR` (see [`socket(7)`](https://man7.org/linux/man-pages/man7/socket.7.html) for
         * details).
         *
         * The `server.listen()` method can be called again if and only if there was an
         * error during the first `server.listen()` call or `server.close()` has been
         * called. Otherwise, an `ERR_SERVER_ALREADY_LISTEN` error will be thrown.
         *
         * One of the most common errors raised when listening is `EADDRINUSE`.
         * This happens when another server is already listening on the requested`port`/`path`/`handle`. One way to handle this would be to retry
         * after a certain amount of time:
         *
         * ```js
         * server.on('error', (e) => {
         *   if (e.code === 'EADDRINUSE') {
         *     console.error('Address in use, retrying...');
         *     setTimeout(() => {
         *       server.close();
         *       server.listen(PORT, HOST);
         *     }, 1000);
         *   }
         * });
         * ```
         */
        listen(port?: number, hostname?: string, backlog?: number, listeningListener?: () => void): this;
        listen(port?: number, hostname?: string, listeningListener?: () => void): this;
        listen(port?: number, backlog?: number, listeningListener?: () => void): this;
        listen(port?: number, listeningListener?: () => void): this;
        listen(path: string, backlog?: number, listeningListener?: () => void): this;
        listen(path: string, listeningListener?: () => void): this;
        listen(options: ListenOptions, listeningListener?: () => void): this;
        listen(handle: any, backlog?: number, listeningListener?: () => void): this;
        listen(handle: any, listeningListener?: () => void): this;
        /**
         * Stops the server from accepting new connections and keeps existing
         * connections. This function is asynchronous, the server is finally closed
         * when all connections are ended and the server emits a `'close'` event.
         * The optional `callback` will be called once the `'close'` event occurs. Unlike
         * that event, it will be called with an `Error` as its only argument if the server
         * was not open when it was closed.
         * @since v0.1.90
         * @param callback Called when the server is closed.
         */
        close(callback?: (err?: Error) => void): this;
        /**
         * Returns the bound `address`, the address `family` name, and `port` of the server
         * as reported by the operating system if listening on an IP socket
         * (useful to find which port was assigned when getting an OS-assigned address):`{ port: 12346, family: 'IPv4', address: '127.0.0.1' }`.
         *
         * For a server listening on a pipe or Unix domain socket, the name is returned
         * as a string.
         *
         * ```js
         * const server = net.createServer((socket) => {
         *   socket.end('goodbye\n');
         * }).on('error', (err) => {
         *   // Handle errors here.
         *   throw err;
         * });
         *
         * // Grab an arbitrary unused port.
         * server.listen(() => {
         *   console.log('opened server on', server.address());
         * });
         * ```
         *
         * `server.address()` returns `null` before the `'listening'` event has been
         * emitted or after calling `server.close()`.
         * @since v0.1.90
         */
        address(): AddressInfo | string | null;
        /**
         * Asynchronously get the number of concurrent connections on the server. Works
         * when sockets were sent to forks.
         *
         * Callback should take two arguments `err` and `count`.
         * @since v0.9.7
         */
        getConnections(cb: (error: Error | null, count: number) => void): this;
        /**
         * Opposite of `unref()`, calling `ref()` on a previously `unref`ed server will _not_ let the program exit if it's the only server left (the default behavior).
         * If the server is `ref`ed calling `ref()` again will have no effect.
         * @since v0.9.1
         */
        ref(): this;
        /**
         * Calling `unref()` on a server will allow the program to exit if this is the only
         * active server in the event system. If the server is already `unref`ed calling`unref()` again will have no effect.
         * @since v0.9.1
         */
        unref(): this;
        /**
         * Set this property to reject connections when the server's connection count gets
         * high.
         *
         * It is not recommended to use this option once a socket has been sent to a child
         * with `child_process.fork()`.
         * @since v0.2.0
         */
        maxConnections: number;
        connections: number;
        /**
         * Indicates whether or not the server is listening for connections.
         * @since v5.7.0
         */
        readonly listening: boolean;
        /**
         * events.EventEmitter
         *   1. close
         *   2. connection
         *   3. error
         *   4. listening
         *   5. drop
         */
        addListener(event: string, listener: (...args: any[]) => void): this;
        addListener(event: "close", listener: () => void): this;
        addListener(event: "connection", listener: (socket: Socket) => void): this;
        addListener(event: "error", listener: (err: Error) => void): this;
        addListener(event: "listening", listener: () => void): this;
        addListener(event: "drop", listener: (data?: DropArgument) => void): this;
        emit(event: string | symbol, ...args: any[]): boolean;
        emit(event: "close"): boolean;
        emit(event: "connection", socket: Socket): boolean;
        emit(event: "error", err: Error): boolean;
        emit(event: "listening"): boolean;
        emit(event: "drop", data?: DropArgument): boolean;
        on(event: string, listener: (...args: any[]) => void): this;
        on(event: "close", listener: () => void): this;
        on(event: "connection", listener: (socket: Socket) => void): this;
        on(event: "error", listener: (err: Error) => void): this;
        on(event: "listening", listener: () => void): this;
        on(event: "drop", listener: (data?: DropArgument) => void): this;
        once(event: string, listener: (...args: any[]) => void): this;
        once(event: "close", listener: () => void): this;
        once(event: "connection", listener: (socket: Socket) => void): this;
        once(event: "error", listener: (err: Error) => void): this;
        once(event: "listening", listener: () => void): this;
        once(event: "drop", listener: (data?: DropArgument) => void): this;
        prependListener(event: string, listener: (...args: any[]) => void): this;
        prependListener(event: "close", listener: () => void): this;
        prependListener(event: "connection", listener: (socket: Socket) => void): this;
        prependListener(event: "error", listener: (err: Error) => void): this;
        prependListener(event: "listening", listener: () => void): this;
        prependListener(event: "drop", listener: (data?: DropArgument) => void): this;
        prependOnceListener(event: string, listener: (...args: any[]) => void): this;
        prependOnceListener(event: "close", listener: () => void): this;
        prependOnceListener(event: "connection", listener: (socket: Socket) => void): this;
        prependOnceListener(event: "error", listener: (err: Error) => void): this;
        prependOnceListener(event: "listening", listener: () => void): this;
        prependOnceListener(event: "drop", listener: (data?: DropArgument) => void): this;
        /**
         * Calls {@link Server.close()} and returns a promise that fulfills when the server has closed.
         * @since v20.5.0
         */
        [Symbol.asyncDispose](): Promise<void>;
    }
    type IPVersion = "ipv4" | "ipv6";
    /**
     * The `BlockList` object can be used with some network APIs to specify rules for
     * disabling inbound or outbound access to specific IP addresses, IP ranges, or
     * IP subnets.
     * @since v15.0.0, v14.18.0
     */
    class BlockList {
        /**
         * Adds a rule to block the given IP address.
         * @since v15.0.0, v14.18.0
         * @param address An IPv4 or IPv6 address.
         * @param [type='ipv4'] Either `'ipv4'` or `'ipv6'`.
         */
        addAddress(address: string, type?: IPVersion): void;
        addAddress(address: SocketAddress): void;
        /**
         * Adds a rule to block a range of IP addresses from `start` (inclusive) to`end` (inclusive).
         * @since v15.0.0, v14.18.0
         * @param start The starting IPv4 or IPv6 address in the range.
         * @param end The ending IPv4 or IPv6 address in the range.
         * @param [type='ipv4'] Either `'ipv4'` or `'ipv6'`.
         */
        addRange(start: string, end: string, type?: IPVersion): void;
        addRange(start: SocketAddress, end: SocketAddress): void;
        /**
         * Adds a rule to block a range of IP addresses specified as a subnet mask.
         * @since v15.0.0, v14.18.0
         * @param net The network IPv4 or IPv6 address.
         * @param prefix The number of CIDR prefix bits. For IPv4, this must be a value between `0` and `32`. For IPv6, this must be between `0` and `128`.
         * @param [type='ipv4'] Either `'ipv4'` or `'ipv6'`.
         */
        addSubnet(net: SocketAddress, prefix: number): void;
        addSubnet(net: string, prefix: number, type?: IPVersion): void;
        /**
         * Returns `true` if the given IP address matches any of the rules added to the`BlockList`.
         *
         * ```js
         * const blockList = new net.BlockList();
         * blockList.addAddress('123.123.123.123');
         * blockList.addRange('10.0.0.1', '10.0.0.10');
         * blockList.addSubnet('8592:757c:efae:4e45::', 64, 'ipv6');
         *
         * console.log(blockList.check('123.123.123.123'));  // Prints: true
         * console.log(blockList.check('10.0.0.3'));  // Prints: true
         * console.log(blockList.check('222.111.111.222'));  // Prints: false
         *
         * // IPv6 notation for IPv4 addresses works:
         * console.log(blockList.check('::ffff:7b7b:7b7b', 'ipv6')); // Prints: true
         * console.log(blockList.check('::ffff:123.123.123.123', 'ipv6')); // Prints: true
         * ```
         * @since v15.0.0, v14.18.0
         * @param address The IP address to check
         * @param [type='ipv4'] Either `'ipv4'` or `'ipv6'`.
         */
        check(address: SocketAddress): boolean;
        check(address: string, type?: IPVersion): boolean;
        /**
         * The list of rules added to the blocklist.
         * @since v15.0.0, v14.18.0
         */
        rules: readonly string[];
        /**
         * Returns `true` if the `value` is a `net.BlockList`.
         * @since v22.13.0
         * @param value Any JS value
         */
        static isBlockList(value: unknown): value is BlockList;
    }
    interface TcpNetConnectOpts extends TcpSocketConnectOpts, SocketConstructorOpts {
        timeout?: number | undefined;
    }
    interface IpcNetConnectOpts extends IpcSocketConnectOpts, SocketConstructorOpts {
        timeout?: number | undefined;
    }
    type NetConnectOpts = TcpNetConnectOpts | IpcNetConnectOpts;
    /**
     * Creates a new TCP or `IPC` server.
     *
     * If `allowHalfOpen` is set to `true`, when the other end of the socket
     * signals the end of transmission, the server will only send back the end of
     * transmission when `socket.end()` is explicitly called. For example, in the
     * context of TCP, when a FIN packed is received, a FIN packed is sent
     * back only when `socket.end()` is explicitly called. Until then the
     * connection is half-closed (non-readable but still writable). See `'end'` event and [RFC 1122](https://tools.ietf.org/html/rfc1122) (section 4.2.2.13) for more information.
     *
     * If `pauseOnConnect` is set to `true`, then the socket associated with each
     * incoming connection will be paused, and no data will be read from its handle.
     * This allows connections to be passed between processes without any data being
     * read by the original process. To begin reading data from a paused socket, call `socket.resume()`.
     *
     * The server can be a TCP server or an `IPC` server, depending on what it `listen()` to.
     *
     * Here is an example of a TCP echo server which listens for connections
     * on port 8124:
     *
     * ```js
     * import net from 'node:net';
     * const server = net.createServer((c) => {
     *   // 'connection' listener.
     *   console.log('client connected');
     *   c.on('end', () => {
     *     console.log('client disconnected');
     *   });
     *   c.write('hello\r\n');
     *   c.pipe(c);
     * });
     * server.on('error', (err) => {
     *   throw err;
     * });
     * server.listen(8124, () => {
     *   console.log('server bound');
     * });
     * ```
     *
     * Test this by using `telnet`:
     *
     * ```bash
     * telnet localhost 8124
     * ```
     *
     * To listen on the socket `/tmp/echo.sock`:
     *
     * ```js
     * server.listen('/tmp/echo.sock', () => {
     *   console.log('server bound');
     * });
     * ```
     *
     * Use `nc` to connect to a Unix domain socket server:
     *
     * ```bash
     * nc -U /tmp/echo.sock
     * ```
     * @since v0.5.0
     * @param connectionListener Automatically set as a listener for the {@link 'connection'} event.
     */
    function createServer(connectionListener?: (socket: Socket) => void): Server;
    function createServer(options?: ServerOpts, connectionListener?: (socket: Socket) => void): Server;
    /**
     * Aliases to {@link createConnection}.
     *
     * Possible signatures:
     *
     * * {@link connect}
     * * {@link connect} for `IPC` connections.
     * * {@link connect} for TCP connections.
     */
    function connect(options: NetConnectOpts, connectionListener?: () => void): Socket;
    function connect(port: number, host?: string, connectionListener?: () => void): Socket;
    function connect(path: string, connectionListener?: () => void): Socket;
    /**
     * A factory function, which creates a new {@link Socket},
     * immediately initiates connection with `socket.connect()`,
     * then returns the `net.Socket` that starts the connection.
     *
     * When the connection is established, a `'connect'` event will be emitted
     * on the returned socket. The last parameter `connectListener`, if supplied,
     * will be added as a listener for the `'connect'` event **once**.
     *
     * Possible signatures:
     *
     * * {@link createConnection}
     * * {@link createConnection} for `IPC` connections.
     * * {@link createConnection} for TCP connections.
     *
     * The {@link connect} function is an alias to this function.
     */
    function createConnection(options: NetConnectOpts, connectionListener?: () => void): Socket;
    function createConnection(port: number, host?: string, connectionListener?: () => void): Socket;
    function createConnection(path: string, connectionListener?: () => void): Socket;
    /**
     * Gets the current default value of the `autoSelectFamily` option of `socket.connect(options)`.
     * The initial default value is `true`, unless the command line option`--no-network-family-autoselection` is provided.
     * @since v19.4.0
     */
    function getDefaultAutoSelectFamily(): boolean;
    /**
     * Sets the default value of the `autoSelectFamily` option of `socket.connect(options)`.
     * @param value The new default value.
     * The initial default value is `true`, unless the command line option
     * `--no-network-family-autoselection` is provided.
     * @since v19.4.0
     */
    function setDefaultAutoSelectFamily(value: boolean): void;
    /**
     * Gets the current default value of the `autoSelectFamilyAttemptTimeout` option of `socket.connect(options)`.
     * The initial default value is `250` or the value specified via the command line option `--network-family-autoselection-attempt-timeout`.
     * @returns The current default value of the `autoSelectFamilyAttemptTimeout` option.
     * @since v19.8.0, v18.8.0
     */
    function getDefaultAutoSelectFamilyAttemptTimeout(): number;
    /**
     * Sets the default value of the `autoSelectFamilyAttemptTimeout` option of `socket.connect(options)`.
     * @param value The new default value, which must be a positive number. If the number is less than `10`, the value `10` is used instead. The initial default value is `250` or the value specified via the command line
     * option `--network-family-autoselection-attempt-timeout`.
     * @since v19.8.0, v18.8.0
     */
    function setDefaultAutoSelectFamilyAttemptTimeout(value: number): void;
    /**
     * Returns `6` if `input` is an IPv6 address. Returns `4` if `input` is an IPv4
     * address in [dot-decimal notation](https://en.wikipedia.org/wiki/Dot-decimal_notation) with no leading zeroes. Otherwise, returns`0`.
     *
     * ```js
     * net.isIP('::1'); // returns 6
     * net.isIP('127.0.0.1'); // returns 4
     * net.isIP('127.000.000.001'); // returns 0
     * net.isIP('127.0.0.1/24'); // returns 0
     * net.isIP('fhqwhgads'); // returns 0
     * ```
     * @since v0.3.0
     */
    function isIP(input: string): number;
    /**
     * Returns `true` if `input` is an IPv4 address in [dot-decimal notation](https://en.wikipedia.org/wiki/Dot-decimal_notation) with no
     * leading zeroes. Otherwise, returns `false`.
     *
     * ```js
     * net.isIPv4('127.0.0.1'); // returns true
     * net.isIPv4('127.000.000.001'); // returns false
     * net.isIPv4('127.0.0.1/24'); // returns false
     * net.isIPv4('fhqwhgads'); // returns false
     * ```
     * @since v0.3.0
     */
    function isIPv4(input: string): boolean;
    /**
     * Returns `true` if `input` is an IPv6 address. Otherwise, returns `false`.
     *
     * ```js
     * net.isIPv6('::1'); // returns true
     * net.isIPv6('fhqwhgads'); // returns false
     * ```
     * @since v0.3.0
     */
    function isIPv6(input: string): boolean;
    interface SocketAddressInitOptions {
        /**
         * The network address as either an IPv4 or IPv6 string.
         * @default 127.0.0.1
         */
        address?: string | undefined;
        /**
         * @default `'ipv4'`
         */
        family?: IPVersion | undefined;
        /**
         * An IPv6 flow-label used only if `family` is `'ipv6'`.
         * @default 0
         */
        flowlabel?: number | undefined;
        /**
         * An IP port.
         * @default 0
         */
        port?: number | undefined;
    }
    /**
     * @since v15.14.0, v14.18.0
     */
    class SocketAddress {
        constructor(options: SocketAddressInitOptions);
        /**
         * Either \`'ipv4'\` or \`'ipv6'\`.
         * @since v15.14.0, v14.18.0
         */
        readonly address: string;
        /**
         * Either \`'ipv4'\` or \`'ipv6'\`.
         * @since v15.14.0, v14.18.0
         */
        readonly family: IPVersion;
        /**
         * @since v15.14.0, v14.18.0
         */
        readonly port: number;
        /**
         * @since v15.14.0, v14.18.0
         */
        readonly flowlabel: number;
        /**
         * @since v22.13.0
         * @param input An input string containing an IP address and optional port,
         * e.g. `123.1.2.3:1234` or `[1::1]:1234`.
         * @returns Returns a `SocketAddress` if parsing was successful.
         * Otherwise returns `undefined`.
         */
        static parse(input: string): SocketAddress | undefined;
    }
}
declare module "node:net" {
    export * from "net";
}

```

## ./lib/lambda/node_modules/@types/node/os.d.ts

```typescript
/**
 * The `node:os` module provides operating system-related utility methods and
 * properties. It can be accessed using:
 *
 * ```js
 * import os from 'node:os';
 * ```
 * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/os.js)
 */
declare module "os" {
    interface CpuInfo {
        model: string;
        speed: number;
        times: {
            /** The number of milliseconds the CPU has spent in user mode. */
            user: number;
            /** The number of milliseconds the CPU has spent in nice mode. */
            nice: number;
            /** The number of milliseconds the CPU has spent in sys mode. */
            sys: number;
            /** The number of milliseconds the CPU has spent in idle mode. */
            idle: number;
            /** The number of milliseconds the CPU has spent in irq mode. */
            irq: number;
        };
    }
    interface NetworkInterfaceBase {
        address: string;
        netmask: string;
        mac: string;
        internal: boolean;
        cidr: string | null;
        scopeid?: number;
    }
    interface NetworkInterfaceInfoIPv4 extends NetworkInterfaceBase {
        family: "IPv4";
    }
    interface NetworkInterfaceInfoIPv6 extends NetworkInterfaceBase {
        family: "IPv6";
        scopeid: number;
    }
    interface UserInfo<T> {
        username: T;
        uid: number;
        gid: number;
        shell: T | null;
        homedir: T;
    }
    type NetworkInterfaceInfo = NetworkInterfaceInfoIPv4 | NetworkInterfaceInfoIPv6;
    /**
     * Returns the host name of the operating system as a string.
     * @since v0.3.3
     */
    function hostname(): string;
    /**
     * Returns an array containing the 1, 5, and 15 minute load averages.
     *
     * The load average is a measure of system activity calculated by the operating
     * system and expressed as a fractional number.
     *
     * The load average is a Unix-specific concept. On Windows, the return value is
     * always `[0, 0, 0]`.
     * @since v0.3.3
     */
    function loadavg(): number[];
    /**
     * Returns the system uptime in number of seconds.
     * @since v0.3.3
     */
    function uptime(): number;
    /**
     * Returns the amount of free system memory in bytes as an integer.
     * @since v0.3.3
     */
    function freemem(): number;
    /**
     * Returns the total amount of system memory in bytes as an integer.
     * @since v0.3.3
     */
    function totalmem(): number;
    /**
     * Returns an array of objects containing information about each logical CPU core.
     * The array will be empty if no CPU information is available, such as if the `/proc` file system is unavailable.
     *
     * The properties included on each object include:
     *
     * ```js
     * [
     *   {
     *     model: 'Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz',
     *     speed: 2926,
     *     times: {
     *       user: 252020,
     *       nice: 0,
     *       sys: 30340,
     *       idle: 1070356870,
     *       irq: 0,
     *     },
     *   },
     *   {
     *     model: 'Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz',
     *     speed: 2926,
     *     times: {
     *       user: 306960,
     *       nice: 0,
     *       sys: 26980,
     *       idle: 1071569080,
     *       irq: 0,
     *     },
     *   },
     *   {
     *     model: 'Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz',
     *     speed: 2926,
     *     times: {
     *       user: 248450,
     *       nice: 0,
     *       sys: 21750,
     *       idle: 1070919370,
     *       irq: 0,
     *     },
     *   },
     *   {
     *     model: 'Intel(R) Core(TM) i7 CPU         860  @ 2.80GHz',
     *     speed: 2926,
     *     times: {
     *       user: 256880,
     *       nice: 0,
     *       sys: 19430,
     *       idle: 1070905480,
     *       irq: 20,
     *     },
     *   },
     * ]
     * ```
     *
     * `nice` values are POSIX-only. On Windows, the `nice` values of all processors
     * are always 0.
     *
     * `os.cpus().length` should not be used to calculate the amount of parallelism
     * available to an application. Use {@link availableParallelism} for this purpose.
     * @since v0.3.3
     */
    function cpus(): CpuInfo[];
    /**
     * Returns an estimate of the default amount of parallelism a program should use.
     * Always returns a value greater than zero.
     *
     * This function is a small wrapper about libuv's [`uv_available_parallelism()`](https://docs.libuv.org/en/v1.x/misc.html#c.uv_available_parallelism).
     * @since v19.4.0, v18.14.0
     */
    function availableParallelism(): number;
    /**
     * Returns the operating system name as returned by [`uname(3)`](https://linux.die.net/man/3/uname). For example, it
     * returns `'Linux'` on Linux, `'Darwin'` on macOS, and `'Windows_NT'` on Windows.
     *
     * See [https://en.wikipedia.org/wiki/Uname#Examples](https://en.wikipedia.org/wiki/Uname#Examples) for additional information
     * about the output of running [`uname(3)`](https://linux.die.net/man/3/uname) on various operating systems.
     * @since v0.3.3
     */
    function type(): string;
    /**
     * Returns the operating system as a string.
     *
     * On POSIX systems, the operating system release is determined by calling [`uname(3)`](https://linux.die.net/man/3/uname). On Windows, `GetVersionExW()` is used. See
     * [https://en.wikipedia.org/wiki/Uname#Examples](https://en.wikipedia.org/wiki/Uname#Examples) for more information.
     * @since v0.3.3
     */
    function release(): string;
    /**
     * Returns an object containing network interfaces that have been assigned a
     * network address.
     *
     * Each key on the returned object identifies a network interface. The associated
     * value is an array of objects that each describe an assigned network address.
     *
     * The properties available on the assigned network address object include:
     *
     * ```js
     * {
     *   lo: [
     *     {
     *       address: '127.0.0.1',
     *       netmask: '255.0.0.0',
     *       family: 'IPv4',
     *       mac: '00:00:00:00:00:00',
     *       internal: true,
     *       cidr: '127.0.0.1/8'
     *     },
     *     {
     *       address: '::1',
     *       netmask: 'ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff',
     *       family: 'IPv6',
     *       mac: '00:00:00:00:00:00',
     *       scopeid: 0,
     *       internal: true,
     *       cidr: '::1/128'
     *     }
     *   ],
     *   eth0: [
     *     {
     *       address: '192.168.1.108',
     *       netmask: '255.255.255.0',
     *       family: 'IPv4',
     *       mac: '01:02:03:0a:0b:0c',
     *       internal: false,
     *       cidr: '192.168.1.108/24'
     *     },
     *     {
     *       address: 'fe80::a00:27ff:fe4e:66a1',
     *       netmask: 'ffff:ffff:ffff:ffff::',
     *       family: 'IPv6',
     *       mac: '01:02:03:0a:0b:0c',
     *       scopeid: 1,
     *       internal: false,
     *       cidr: 'fe80::a00:27ff:fe4e:66a1/64'
     *     }
     *   ]
     * }
     * ```
     * @since v0.6.0
     */
    function networkInterfaces(): NodeJS.Dict<NetworkInterfaceInfo[]>;
    /**
     * Returns the string path of the current user's home directory.
     *
     * On POSIX, it uses the `$HOME` environment variable if defined. Otherwise it
     * uses the [effective UID](https://en.wikipedia.org/wiki/User_identifier#Effective_user_ID) to look up the user's home directory.
     *
     * On Windows, it uses the `USERPROFILE` environment variable if defined.
     * Otherwise it uses the path to the profile directory of the current user.
     * @since v2.3.0
     */
    function homedir(): string;
    interface UserInfoOptions {
        encoding?: BufferEncoding | "buffer" | undefined;
    }
    interface UserInfoOptionsWithBufferEncoding extends UserInfoOptions {
        encoding: "buffer";
    }
    interface UserInfoOptionsWithStringEncoding extends UserInfoOptions {
        encoding?: BufferEncoding | undefined;
    }
    /**
     * Returns information about the currently effective user. On POSIX platforms,
     * this is typically a subset of the password file. The returned object includes
     * the `username`, `uid`, `gid`, `shell`, and `homedir`. On Windows, the `uid` and `gid` fields are `-1`, and `shell` is `null`.
     *
     * The value of `homedir` returned by `os.userInfo()` is provided by the operating
     * system. This differs from the result of `os.homedir()`, which queries
     * environment variables for the home directory before falling back to the
     * operating system response.
     *
     * Throws a [`SystemError`](https://nodejs.org/docs/latest-v22.x/api/errors.html#class-systemerror) if a user has no `username` or `homedir`.
     * @since v6.0.0
     */
    function userInfo(options: UserInfoOptionsWithBufferEncoding): UserInfo<Buffer>;
    function userInfo(options?: UserInfoOptionsWithStringEncoding): UserInfo<string>;
    function userInfo(options: UserInfoOptions): UserInfo<string | Buffer>;
    type SignalConstants = {
        [key in NodeJS.Signals]: number;
    };
    namespace constants {
        const UV_UDP_REUSEADDR: number;
        namespace signals {}
        const signals: SignalConstants;
        namespace errno {
            const E2BIG: number;
            const EACCES: number;
            const EADDRINUSE: number;
            const EADDRNOTAVAIL: number;
            const EAFNOSUPPORT: number;
            const EAGAIN: number;
            const EALREADY: number;
            const EBADF: number;
            const EBADMSG: number;
            const EBUSY: number;
            const ECANCELED: number;
            const ECHILD: number;
            const ECONNABORTED: number;
            const ECONNREFUSED: number;
            const ECONNRESET: number;
            const EDEADLK: number;
            const EDESTADDRREQ: number;
            const EDOM: number;
            const EDQUOT: number;
            const EEXIST: number;
            const EFAULT: number;
            const EFBIG: number;
            const EHOSTUNREACH: number;
            const EIDRM: number;
            const EILSEQ: number;
            const EINPROGRESS: number;
            const EINTR: number;
            const EINVAL: number;
            const EIO: number;
            const EISCONN: number;
            const EISDIR: number;
            const ELOOP: number;
            const EMFILE: number;
            const EMLINK: number;
            const EMSGSIZE: number;
            const EMULTIHOP: number;
            const ENAMETOOLONG: number;
            const ENETDOWN: number;
            const ENETRESET: number;
            const ENETUNREACH: number;
            const ENFILE: number;
            const ENOBUFS: number;
            const ENODATA: number;
            const ENODEV: number;
            const ENOENT: number;
            const ENOEXEC: number;
            const ENOLCK: number;
            const ENOLINK: number;
            const ENOMEM: number;
            const ENOMSG: number;
            const ENOPROTOOPT: number;
            const ENOSPC: number;
            const ENOSR: number;
            const ENOSTR: number;
            const ENOSYS: number;
            const ENOTCONN: number;
            const ENOTDIR: number;
            const ENOTEMPTY: number;
            const ENOTSOCK: number;
            const ENOTSUP: number;
            const ENOTTY: number;
            const ENXIO: number;
            const EOPNOTSUPP: number;
            const EOVERFLOW: number;
            const EPERM: number;
            const EPIPE: number;
            const EPROTO: number;
            const EPROTONOSUPPORT: number;
            const EPROTOTYPE: number;
            const ERANGE: number;
            const EROFS: number;
            const ESPIPE: number;
            const ESRCH: number;
            const ESTALE: number;
            const ETIME: number;
            const ETIMEDOUT: number;
            const ETXTBSY: number;
            const EWOULDBLOCK: number;
            const EXDEV: number;
            const WSAEINTR: number;
            const WSAEBADF: number;
            const WSAEACCES: number;
            const WSAEFAULT: number;
            const WSAEINVAL: number;
            const WSAEMFILE: number;
            const WSAEWOULDBLOCK: number;
            const WSAEINPROGRESS: number;
            const WSAEALREADY: number;
            const WSAENOTSOCK: number;
            const WSAEDESTADDRREQ: number;
            const WSAEMSGSIZE: number;
            const WSAEPROTOTYPE: number;
            const WSAENOPROTOOPT: number;
            const WSAEPROTONOSUPPORT: number;
            const WSAESOCKTNOSUPPORT: number;
            const WSAEOPNOTSUPP: number;
            const WSAEPFNOSUPPORT: number;
            const WSAEAFNOSUPPORT: number;
            const WSAEADDRINUSE: number;
            const WSAEADDRNOTAVAIL: number;
            const WSAENETDOWN: number;
            const WSAENETUNREACH: number;
            const WSAENETRESET: number;
            const WSAECONNABORTED: number;
            const WSAECONNRESET: number;
            const WSAENOBUFS: number;
            const WSAEISCONN: number;
            const WSAENOTCONN: number;
            const WSAESHUTDOWN: number;
            const WSAETOOMANYREFS: number;
            const WSAETIMEDOUT: number;
            const WSAECONNREFUSED: number;
            const WSAELOOP: number;
            const WSAENAMETOOLONG: number;
            const WSAEHOSTDOWN: number;
            const WSAEHOSTUNREACH: number;
            const WSAENOTEMPTY: number;
            const WSAEPROCLIM: number;
            const WSAEUSERS: number;
            const WSAEDQUOT: number;
            const WSAESTALE: number;
            const WSAEREMOTE: number;
            const WSASYSNOTREADY: number;
            const WSAVERNOTSUPPORTED: number;
            const WSANOTINITIALISED: number;
            const WSAEDISCON: number;
            const WSAENOMORE: number;
            const WSAECANCELLED: number;
            const WSAEINVALIDPROCTABLE: number;
            const WSAEINVALIDPROVIDER: number;
            const WSAEPROVIDERFAILEDINIT: number;
            const WSASYSCALLFAILURE: number;
            const WSASERVICE_NOT_FOUND: number;
            const WSATYPE_NOT_FOUND: number;
            const WSA_E_NO_MORE: number;
            const WSA_E_CANCELLED: number;
            const WSAEREFUSED: number;
        }
        namespace dlopen {
            const RTLD_LAZY: number;
            const RTLD_NOW: number;
            const RTLD_GLOBAL: number;
            const RTLD_LOCAL: number;
            const RTLD_DEEPBIND: number;
        }
        namespace priority {
            const PRIORITY_LOW: number;
            const PRIORITY_BELOW_NORMAL: number;
            const PRIORITY_NORMAL: number;
            const PRIORITY_ABOVE_NORMAL: number;
            const PRIORITY_HIGH: number;
            const PRIORITY_HIGHEST: number;
        }
    }
    const devNull: string;
    /**
     * The operating system-specific end-of-line marker.
     * * `\n` on POSIX
     * * `\r\n` on Windows
     */
    const EOL: string;
    /**
     * Returns the operating system CPU architecture for which the Node.js binary was
     * compiled. Possible values are `'arm'`, `'arm64'`, `'ia32'`, `'loong64'`, `'mips'`, `'mipsel'`, `'ppc'`, `'ppc64'`, `'riscv64'`, `'s390'`, `'s390x'`,
     * and `'x64'`.
     *
     * The return value is equivalent to [process.arch](https://nodejs.org/docs/latest-v22.x/api/process.html#processarch).
     * @since v0.5.0
     */
    function arch(): string;
    /**
     * Returns a string identifying the kernel version.
     *
     * On POSIX systems, the operating system release is determined by calling [`uname(3)`](https://linux.die.net/man/3/uname). On Windows, `RtlGetVersion()` is used, and if it is not
     * available, `GetVersionExW()` will be used. See [https://en.wikipedia.org/wiki/Uname#Examples](https://en.wikipedia.org/wiki/Uname#Examples) for more information.
     * @since v13.11.0, v12.17.0
     */
    function version(): string;
    /**
     * Returns a string identifying the operating system platform for which
     * the Node.js binary was compiled. The value is set at compile time.
     * Possible values are `'aix'`, `'darwin'`, `'freebsd'`, `'linux'`, `'openbsd'`, `'sunos'`, and `'win32'`.
     *
     * The return value is equivalent to `process.platform`.
     *
     * The value `'android'` may also be returned if Node.js is built on the Android
     * operating system. [Android support is experimental](https://github.com/nodejs/node/blob/HEAD/BUILDING.md#androidandroid-based-devices-eg-firefox-os).
     * @since v0.5.0
     */
    function platform(): NodeJS.Platform;
    /**
     * Returns the machine type as a string, such as `arm`, `arm64`, `aarch64`, `mips`, `mips64`, `ppc64`, `ppc64le`, `s390`, `s390x`, `i386`, `i686`, `x86_64`.
     *
     * On POSIX systems, the machine type is determined by calling [`uname(3)`](https://linux.die.net/man/3/uname). On Windows, `RtlGetVersion()` is used, and if it is not
     * available, `GetVersionExW()` will be used. See [https://en.wikipedia.org/wiki/Uname#Examples](https://en.wikipedia.org/wiki/Uname#Examples) for more information.
     * @since v18.9.0, v16.18.0
     */
    function machine(): string;
    /**
     * Returns the operating system's default directory for temporary files as a
     * string.
     * @since v0.9.9
     */
    function tmpdir(): string;
    /**
     * Returns a string identifying the endianness of the CPU for which the Node.js
     * binary was compiled.
     *
     * Possible values are `'BE'` for big endian and `'LE'` for little endian.
     * @since v0.9.4
     */
    function endianness(): "BE" | "LE";
    /**
     * Returns the scheduling priority for the process specified by `pid`. If `pid` is
     * not provided or is `0`, the priority of the current process is returned.
     * @since v10.10.0
     * @param [pid=0] The process ID to retrieve scheduling priority for.
     */
    function getPriority(pid?: number): number;
    /**
     * Attempts to set the scheduling priority for the process specified by `pid`. If `pid` is not provided or is `0`, the process ID of the current process is used.
     *
     * The `priority` input must be an integer between `-20` (high priority) and `19` (low priority). Due to differences between Unix priority levels and Windows
     * priority classes, `priority` is mapped to one of six priority constants in `os.constants.priority`. When retrieving a process priority level, this range
     * mapping may cause the return value to be slightly different on Windows. To avoid
     * confusion, set `priority` to one of the priority constants.
     *
     * On Windows, setting priority to `PRIORITY_HIGHEST` requires elevated user
     * privileges. Otherwise the set priority will be silently reduced to `PRIORITY_HIGH`.
     * @since v10.10.0
     * @param [pid=0] The process ID to set scheduling priority for.
     * @param priority The scheduling priority to assign to the process.
     */
    function setPriority(priority: number): void;
    function setPriority(pid: number, priority: number): void;
}
declare module "node:os" {
    export * from "os";
}

```

## ./lib/lambda/node_modules/@types/node/package.json

```json
{
    "name": "@types/node",
    "version": "22.18.10",
    "description": "TypeScript definitions for node",
    "homepage": "https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/node",
    "license": "MIT",
    "contributors": [
        {
            "name": "Microsoft TypeScript",
            "githubUsername": "Microsoft",
            "url": "https://github.com/Microsoft"
        },
        {
            "name": "Alberto Schiabel",
            "githubUsername": "jkomyno",
            "url": "https://github.com/jkomyno"
        },
        {
            "name": "Andrew Makarov",
            "githubUsername": "r3nya",
            "url": "https://github.com/r3nya"
        },
        {
            "name": "Benjamin Toueg",
            "githubUsername": "btoueg",
            "url": "https://github.com/btoueg"
        },
        {
            "name": "David Junger",
            "githubUsername": "touffy",
            "url": "https://github.com/touffy"
        },
        {
            "name": "Mohsen Azimi",
            "githubUsername": "mohsen1",
            "url": "https://github.com/mohsen1"
        },
        {
            "name": "Nikita Galkin",
            "githubUsername": "galkin",
            "url": "https://github.com/galkin"
        },
        {
            "name": "Sebastian Silbermann",
            "githubUsername": "eps1lon",
            "url": "https://github.com/eps1lon"
        },
        {
            "name": "Wilco Bakker",
            "githubUsername": "WilcoBakker",
            "url": "https://github.com/WilcoBakker"
        },
        {
            "name": "Marcin Kopacz",
            "githubUsername": "chyzwar",
            "url": "https://github.com/chyzwar"
        },
        {
            "name": "Trivikram Kamat",
            "githubUsername": "trivikr",
            "url": "https://github.com/trivikr"
        },
        {
            "name": "Junxiao Shi",
            "githubUsername": "yoursunny",
            "url": "https://github.com/yoursunny"
        },
        {
            "name": "Ilia Baryshnikov",
            "githubUsername": "qwelias",
            "url": "https://github.com/qwelias"
        },
        {
            "name": "ExE Boss",
            "githubUsername": "ExE-Boss",
            "url": "https://github.com/ExE-Boss"
        },
        {
            "name": "Piotr Baejewicz",
            "githubUsername": "peterblazejewicz",
            "url": "https://github.com/peterblazejewicz"
        },
        {
            "name": "Anna Henningsen",
            "githubUsername": "addaleax",
            "url": "https://github.com/addaleax"
        },
        {
            "name": "Victor Perin",
            "githubUsername": "victorperin",
            "url": "https://github.com/victorperin"
        },
        {
            "name": "NodeJS Contributors",
            "githubUsername": "NodeJS",
            "url": "https://github.com/NodeJS"
        },
        {
            "name": "Linus Unnebck",
            "githubUsername": "LinusU",
            "url": "https://github.com/LinusU"
        },
        {
            "name": "wafuwafu13",
            "githubUsername": "wafuwafu13",
            "url": "https://github.com/wafuwafu13"
        },
        {
            "name": "Matteo Collina",
            "githubUsername": "mcollina",
            "url": "https://github.com/mcollina"
        },
        {
            "name": "Dmitry Semigradsky",
            "githubUsername": "Semigradsky",
            "url": "https://github.com/Semigradsky"
        },
        {
            "name": "Ren",
            "githubUsername": "Renegade334",
            "url": "https://github.com/Renegade334"
        }
    ],
    "main": "",
    "types": "index.d.ts",
    "typesVersions": {
        "<=5.6": {
            "*": [
                "ts5.6/*"
            ]
        }
    },
    "repository": {
        "type": "git",
        "url": "https://github.com/DefinitelyTyped/DefinitelyTyped.git",
        "directory": "types/node"
    },
    "scripts": {},
    "dependencies": {
        "undici-types": "~6.21.0"
    },
    "peerDependencies": {},
    "typesPublisherContentHash": "e5707cd0627075030e43d45d8ff396de8a8bb1b71fd581233c7a8febe823657c",
    "typeScriptVersion": "5.2"
}
```

## ./lib/lambda/node_modules/@types/node/path.d.ts

```typescript
declare module "path/posix" {
    import path = require("path");
    export = path;
}
declare module "path/win32" {
    import path = require("path");
    export = path;
}
/**
 * The `node:path` module provides utilities for working with file and directory
 * paths. It can be accessed using:
 *
 * ```js
 * import path from 'node:path';
 * ```
 * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/path.js)
 */
declare module "path" {
    namespace path {
        /**
         * A parsed path object generated by path.parse() or consumed by path.format().
         */
        interface ParsedPath {
            /**
             * The root of the path such as '/' or 'c:\'
             */
            root: string;
            /**
             * The full directory path such as '/home/user/dir' or 'c:\path\dir'
             */
            dir: string;
            /**
             * The file name including extension (if any) such as 'index.html'
             */
            base: string;
            /**
             * The file extension (if any) such as '.html'
             */
            ext: string;
            /**
             * The file name without extension (if any) such as 'index'
             */
            name: string;
        }
        interface FormatInputPathObject {
            /**
             * The root of the path such as '/' or 'c:\'
             */
            root?: string | undefined;
            /**
             * The full directory path such as '/home/user/dir' or 'c:\path\dir'
             */
            dir?: string | undefined;
            /**
             * The file name including extension (if any) such as 'index.html'
             */
            base?: string | undefined;
            /**
             * The file extension (if any) such as '.html'
             */
            ext?: string | undefined;
            /**
             * The file name without extension (if any) such as 'index'
             */
            name?: string | undefined;
        }
        interface PlatformPath {
            /**
             * Normalize a string path, reducing '..' and '.' parts.
             * When multiple slashes are found, they're replaced by a single one; when the path contains a trailing slash, it is preserved. On Windows backslashes are used.
             *
             * @param path string path to normalize.
             * @throws {TypeError} if `path` is not a string.
             */
            normalize(path: string): string;
            /**
             * Join all arguments together and normalize the resulting path.
             *
             * @param paths paths to join.
             * @throws {TypeError} if any of the path segments is not a string.
             */
            join(...paths: string[]): string;
            /**
             * The right-most parameter is considered {to}. Other parameters are considered an array of {from}.
             *
             * Starting from leftmost {from} parameter, resolves {to} to an absolute path.
             *
             * If {to} isn't already absolute, {from} arguments are prepended in right to left order,
             * until an absolute path is found. If after using all {from} paths still no absolute path is found,
             * the current working directory is used as well. The resulting path is normalized,
             * and trailing slashes are removed unless the path gets resolved to the root directory.
             *
             * @param paths A sequence of paths or path segments.
             * @throws {TypeError} if any of the arguments is not a string.
             */
            resolve(...paths: string[]): string;
            /**
             * The `path.matchesGlob()` method determines if `path` matches the `pattern`.
             * @param path The path to glob-match against.
             * @param pattern The glob to check the path against.
             * @returns Whether or not the `path` matched the `pattern`.
             * @throws {TypeError} if `path` or `pattern` are not strings.
             * @since v22.5.0
             */
            matchesGlob(path: string, pattern: string): boolean;
            /**
             * Determines whether {path} is an absolute path. An absolute path will always resolve to the same location, regardless of the working directory.
             *
             * If the given {path} is a zero-length string, `false` will be returned.
             *
             * @param path path to test.
             * @throws {TypeError} if `path` is not a string.
             */
            isAbsolute(path: string): boolean;
            /**
             * Solve the relative path from {from} to {to} based on the current working directory.
             * At times we have two absolute paths, and we need to derive the relative path from one to the other. This is actually the reverse transform of path.resolve.
             *
             * @throws {TypeError} if either `from` or `to` is not a string.
             */
            relative(from: string, to: string): string;
            /**
             * Return the directory name of a path. Similar to the Unix dirname command.
             *
             * @param path the path to evaluate.
             * @throws {TypeError} if `path` is not a string.
             */
            dirname(path: string): string;
            /**
             * Return the last portion of a path. Similar to the Unix basename command.
             * Often used to extract the file name from a fully qualified path.
             *
             * @param path the path to evaluate.
             * @param suffix optionally, an extension to remove from the result.
             * @throws {TypeError} if `path` is not a string or if `ext` is given and is not a string.
             */
            basename(path: string, suffix?: string): string;
            /**
             * Return the extension of the path, from the last '.' to end of string in the last portion of the path.
             * If there is no '.' in the last portion of the path or the first character of it is '.', then it returns an empty string.
             *
             * @param path the path to evaluate.
             * @throws {TypeError} if `path` is not a string.
             */
            extname(path: string): string;
            /**
             * The platform-specific file separator. '\\' or '/'.
             */
            readonly sep: "\\" | "/";
            /**
             * The platform-specific file delimiter. ';' or ':'.
             */
            readonly delimiter: ";" | ":";
            /**
             * Returns an object from a path string - the opposite of format().
             *
             * @param path path to evaluate.
             * @throws {TypeError} if `path` is not a string.
             */
            parse(path: string): ParsedPath;
            /**
             * Returns a path string from an object - the opposite of parse().
             *
             * @param pathObject path to evaluate.
             */
            format(pathObject: FormatInputPathObject): string;
            /**
             * On Windows systems only, returns an equivalent namespace-prefixed path for the given path.
             * If path is not a string, path will be returned without modifications.
             * This method is meaningful only on Windows system.
             * On POSIX systems, the method is non-operational and always returns path without modifications.
             */
            toNamespacedPath(path: string): string;
            /**
             * Posix specific pathing.
             * Same as parent object on posix.
             */
            readonly posix: PlatformPath;
            /**
             * Windows specific pathing.
             * Same as parent object on windows
             */
            readonly win32: PlatformPath;
        }
    }
    const path: path.PlatformPath;
    export = path;
}
declare module "node:path" {
    import path = require("path");
    export = path;
}
declare module "node:path/posix" {
    import path = require("path/posix");
    export = path;
}
declare module "node:path/win32" {
    import path = require("path/win32");
    export = path;
}

```

## ./lib/lambda/node_modules/@types/node/perf_hooks.d.ts

```typescript
/**
 * This module provides an implementation of a subset of the W3C [Web Performance APIs](https://w3c.github.io/perf-timing-primer/) as well as additional APIs for
 * Node.js-specific performance measurements.
 *
 * Node.js supports the following [Web Performance APIs](https://w3c.github.io/perf-timing-primer/):
 *
 * * [High Resolution Time](https://www.w3.org/TR/hr-time-2)
 * * [Performance Timeline](https://w3c.github.io/performance-timeline/)
 * * [User Timing](https://www.w3.org/TR/user-timing/)
 * * [Resource Timing](https://www.w3.org/TR/resource-timing-2/)
 *
 * ```js
 * import { PerformanceObserver, performance } from 'node:perf_hooks';
 *
 * const obs = new PerformanceObserver((items) => {
 *   console.log(items.getEntries()[0].duration);
 *   performance.clearMarks();
 * });
 * obs.observe({ type: 'measure' });
 * performance.measure('Start to Now');
 *
 * performance.mark('A');
 * doSomeLongRunningProcess(() => {
 *   performance.measure('A to Now', 'A');
 *
 *   performance.mark('B');
 *   performance.measure('A to B', 'A', 'B');
 * });
 * ```
 * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/perf_hooks.js)
 */
declare module "perf_hooks" {
    import { AsyncResource } from "node:async_hooks";
    type EntryType =
        | "dns" // Node.js only
        | "function" // Node.js only
        | "gc" // Node.js only
        | "http2" // Node.js only
        | "http" // Node.js only
        | "mark" // available on the Web
        | "measure" // available on the Web
        | "net" // Node.js only
        | "node" // Node.js only
        | "resource"; // available on the Web
    interface NodeGCPerformanceDetail {
        /**
         * When `performanceEntry.entryType` is equal to 'gc', the `performance.kind` property identifies
         * the type of garbage collection operation that occurred.
         * See perf_hooks.constants for valid values.
         */
        readonly kind: number;
        /**
         * When `performanceEntry.entryType` is equal to 'gc', the `performance.flags`
         * property contains additional information about garbage collection operation.
         * See perf_hooks.constants for valid values.
         */
        readonly flags: number;
    }
    /**
     * The constructor of this class is not exposed to users directly.
     * @since v8.5.0
     */
    class PerformanceEntry {
        protected constructor();
        /**
         * The total number of milliseconds elapsed for this entry. This value will not
         * be meaningful for all Performance Entry types.
         * @since v8.5.0
         */
        readonly duration: number;
        /**
         * The name of the performance entry.
         * @since v8.5.0
         */
        readonly name: string;
        /**
         * The high resolution millisecond timestamp marking the starting time of the
         * Performance Entry.
         * @since v8.5.0
         */
        readonly startTime: number;
        /**
         * The type of the performance entry. It may be one of:
         *
         * * `'node'` (Node.js only)
         * * `'mark'` (available on the Web)
         * * `'measure'` (available on the Web)
         * * `'gc'` (Node.js only)
         * * `'function'` (Node.js only)
         * * `'http2'` (Node.js only)
         * * `'http'` (Node.js only)
         * @since v8.5.0
         */
        readonly entryType: EntryType;
        toJSON(): any;
    }
    /**
     * Exposes marks created via the `Performance.mark()` method.
     * @since v18.2.0, v16.17.0
     */
    class PerformanceMark extends PerformanceEntry {
        readonly detail: any;
        readonly duration: 0;
        readonly entryType: "mark";
    }
    /**
     * Exposes measures created via the `Performance.measure()` method.
     *
     * The constructor of this class is not exposed to users directly.
     * @since v18.2.0, v16.17.0
     */
    class PerformanceMeasure extends PerformanceEntry {
        readonly detail: any;
        readonly entryType: "measure";
    }
    interface UVMetrics {
        /**
         * Number of event loop iterations.
         */
        readonly loopCount: number;
        /**
         * Number of events that have been processed by the event handler.
         */
        readonly events: number;
        /**
         * Number of events that were waiting to be processed when the event provider was called.
         */
        readonly eventsWaiting: number;
    }
    // TODO: PerformanceNodeEntry is missing
    /**
     * _This property is an extension by Node.js. It is not available in Web browsers._
     *
     * Provides timing details for Node.js itself. The constructor of this class
     * is not exposed to users.
     * @since v8.5.0
     */
    class PerformanceNodeTiming extends PerformanceEntry {
        readonly entryType: "node";
        /**
         * The high resolution millisecond timestamp at which the Node.js process
         * completed bootstrapping. If bootstrapping has not yet finished, the property
         * has the value of -1.
         * @since v8.5.0
         */
        readonly bootstrapComplete: number;
        /**
         * The high resolution millisecond timestamp at which the Node.js environment was
         * initialized.
         * @since v8.5.0
         */
        readonly environment: number;
        /**
         * The high resolution millisecond timestamp of the amount of time the event loop
         * has been idle within the event loop's event provider (e.g. `epoll_wait`). This
         * does not take CPU usage into consideration. If the event loop has not yet
         * started (e.g., in the first tick of the main script), the property has the
         * value of 0.
         * @since v14.10.0, v12.19.0
         */
        readonly idleTime: number;
        /**
         * The high resolution millisecond timestamp at which the Node.js event loop
         * exited. If the event loop has not yet exited, the property has the value of -1\.
         * It can only have a value of not -1 in a handler of the `'exit'` event.
         * @since v8.5.0
         */
        readonly loopExit: number;
        /**
         * The high resolution millisecond timestamp at which the Node.js event loop
         * started. If the event loop has not yet started (e.g., in the first tick of the
         * main script), the property has the value of -1.
         * @since v8.5.0
         */
        readonly loopStart: number;
        /**
         * The high resolution millisecond timestamp at which the Node.js process was initialized.
         * @since v8.5.0
         */
        readonly nodeStart: number;
        /**
         * This is a wrapper to the `uv_metrics_info` function.
         * It returns the current set of event loop metrics.
         *
         * It is recommended to use this property inside a function whose execution was
         * scheduled using `setImmediate` to avoid collecting metrics before finishing all
         * operations scheduled during the current loop iteration.
         * @since v22.8.0, v20.18.0
         */
        readonly uvMetricsInfo: UVMetrics;
        /**
         * The high resolution millisecond timestamp at which the V8 platform was
         * initialized.
         * @since v8.5.0
         */
        readonly v8Start: number;
    }
    interface EventLoopUtilization {
        idle: number;
        active: number;
        utilization: number;
    }
    /**
     * @param utilization1 The result of a previous call to `eventLoopUtilization()`.
     * @param utilization2 The result of a previous call to `eventLoopUtilization()` prior to `utilization1`.
     */
    type EventLoopUtilityFunction = (
        utilization1?: EventLoopUtilization,
        utilization2?: EventLoopUtilization,
    ) => EventLoopUtilization;
    interface MarkOptions {
        /**
         * Additional optional detail to include with the mark.
         */
        detail?: unknown | undefined;
        /**
         * An optional timestamp to be used as the mark time.
         * @default `performance.now()`
         */
        startTime?: number | undefined;
    }
    interface MeasureOptions {
        /**
         * Additional optional detail to include with the mark.
         */
        detail?: unknown;
        /**
         * Duration between start and end times.
         */
        duration?: number | undefined;
        /**
         * Timestamp to be used as the end time, or a string identifying a previously recorded mark.
         */
        end?: number | string | undefined;
        /**
         * Timestamp to be used as the start time, or a string identifying a previously recorded mark.
         */
        start?: number | string | undefined;
    }
    interface TimerifyOptions {
        /**
         * A histogram object created using `perf_hooks.createHistogram()` that will record runtime
         * durations in nanoseconds.
         */
        histogram?: RecordableHistogram | undefined;
    }
    interface Performance {
        /**
         * If `name` is not provided, removes all `PerformanceMark` objects from the Performance Timeline.
         * If `name` is provided, removes only the named mark.
         * @since v8.5.0
         */
        clearMarks(name?: string): void;
        /**
         * If `name` is not provided, removes all `PerformanceMeasure` objects from the Performance Timeline.
         * If `name` is provided, removes only the named measure.
         * @since v16.7.0
         */
        clearMeasures(name?: string): void;
        /**
         * If `name` is not provided, removes all `PerformanceResourceTiming` objects from the Resource Timeline.
         * If `name` is provided, removes only the named resource.
         * @since v18.2.0, v16.17.0
         */
        clearResourceTimings(name?: string): void;
        /**
         * eventLoopUtilization is similar to CPU utilization except that it is calculated using high precision wall-clock time.
         * It represents the percentage of time the event loop has spent outside the event loop's event provider (e.g. epoll_wait).
         * No other CPU idle time is taken into consideration.
         */
        eventLoopUtilization: EventLoopUtilityFunction;
        /**
         * Returns a list of `PerformanceEntry` objects in chronological order with respect to `performanceEntry.startTime`.
         * If you are only interested in performance entries of certain types or that have certain names, see
         * `performance.getEntriesByType()` and `performance.getEntriesByName()`.
         * @since v16.7.0
         */
        getEntries(): PerformanceEntry[];
        /**
         * Returns a list of `PerformanceEntry` objects in chronological order with respect to `performanceEntry.startTime`
         * whose `performanceEntry.name` is equal to `name`, and optionally, whose `performanceEntry.entryType` is equal to `type`.
         * @param name
         * @param type
         * @since v16.7.0
         */
        getEntriesByName(name: string, type?: EntryType): PerformanceEntry[];
        /**
         * Returns a list of `PerformanceEntry` objects in chronological order with respect to `performanceEntry.startTime`
         * whose `performanceEntry.entryType` is equal to `type`.
         * @param type
         * @since v16.7.0
         */
        getEntriesByType(type: EntryType): PerformanceEntry[];
        /**
         * Creates a new `PerformanceMark` entry in the Performance Timeline.
         * A `PerformanceMark` is a subclass of `PerformanceEntry` whose `performanceEntry.entryType` is always `'mark'`,
         * and whose `performanceEntry.duration` is always `0`.
         * Performance marks are used to mark specific significant moments in the Performance Timeline.
         *
         * The created `PerformanceMark` entry is put in the global Performance Timeline and can be queried with
         * `performance.getEntries`, `performance.getEntriesByName`, and `performance.getEntriesByType`. When the observation is
         * performed, the entries should be cleared from the global Performance Timeline manually with `performance.clearMarks`.
         * @param name
         */
        mark(name: string, options?: MarkOptions): PerformanceMark;
        /**
         * Creates a new `PerformanceResourceTiming` entry in the Resource Timeline.
         * A `PerformanceResourceTiming` is a subclass of `PerformanceEntry` whose `performanceEntry.entryType` is always `'resource'`.
         * Performance resources are used to mark moments in the Resource Timeline.
         * @param timingInfo [Fetch Timing Info](https://fetch.spec.whatwg.org/#fetch-timing-info)
         * @param requestedUrl The resource url
         * @param initiatorType The initiator name, e.g: 'fetch'
         * @param global
         * @param cacheMode The cache mode must be an empty string ('') or 'local'
         * @param bodyInfo [Fetch Response Body Info](https://fetch.spec.whatwg.org/#response-body-info)
         * @param responseStatus The response's status code
         * @param deliveryType The delivery type. Default: ''.
         * @since v18.2.0, v16.17.0
         */
        markResourceTiming(
            timingInfo: object,
            requestedUrl: string,
            initiatorType: string,
            global: object,
            cacheMode: "" | "local",
            bodyInfo: object,
            responseStatus: number,
            deliveryType?: string,
        ): PerformanceResourceTiming;
        /**
         * Creates a new PerformanceMeasure entry in the Performance Timeline.
         * A PerformanceMeasure is a subclass of PerformanceEntry whose performanceEntry.entryType is always 'measure',
         * and whose performanceEntry.duration measures the number of milliseconds elapsed since startMark and endMark.
         *
         * The startMark argument may identify any existing PerformanceMark in the the Performance Timeline, or may identify
         * any of the timestamp properties provided by the PerformanceNodeTiming class. If the named startMark does not exist,
         * then startMark is set to timeOrigin by default.
         *
         * The endMark argument must identify any existing PerformanceMark in the the Performance Timeline or any of the timestamp
         * properties provided by the PerformanceNodeTiming class. If the named endMark does not exist, an error will be thrown.
         * @param name
         * @param startMark
         * @param endMark
         * @return The PerformanceMeasure entry that was created
         */
        measure(name: string, startMark?: string, endMark?: string): PerformanceMeasure;
        measure(name: string, options: MeasureOptions): PerformanceMeasure;
        /**
         * _This property is an extension by Node.js. It is not available in Web browsers._
         *
         * An instance of the `PerformanceNodeTiming` class that provides performance metrics for specific Node.js operational milestones.
         * @since v8.5.0
         */
        readonly nodeTiming: PerformanceNodeTiming;
        /**
         * Returns the current high resolution millisecond timestamp, where 0 represents the start of the current `node` process.
         * @since v8.5.0
         */
        now(): number;
        /**
         * Sets the global performance resource timing buffer size to the specified number of "resource" type performance entry objects.
         *
         * By default the max buffer size is set to 250.
         * @since v18.8.0
         */
        setResourceTimingBufferSize(maxSize: number): void;
        /**
         * The [`timeOrigin`](https://w3c.github.io/hr-time/#dom-performance-timeorigin) specifies the high resolution millisecond timestamp
         * at which the current `node` process began, measured in Unix time.
         * @since v8.5.0
         */
        readonly timeOrigin: number;
        /**
         * _This property is an extension by Node.js. It is not available in Web browsers._
         *
         * Wraps a function within a new function that measures the running time of the wrapped function.
         * A `PerformanceObserver` must be subscribed to the `'function'` event type in order for the timing details to be accessed.
         *
         * ```js
         * import {
         *   performance,
         *   PerformanceObserver,
         * } from 'node:perf_hooks';
         *
         * function someFunction() {
         *   console.log('hello world');
         * }
         *
         * const wrapped = performance.timerify(someFunction);
         *
         * const obs = new PerformanceObserver((list) => {
         *   console.log(list.getEntries()[0].duration);
         *
         *   performance.clearMarks();
         *   performance.clearMeasures();
         *   obs.disconnect();
         * });
         * obs.observe({ entryTypes: ['function'] });
         *
         * // A performance timeline entry will be created
         * wrapped();
         * ```
         *
         * If the wrapped function returns a promise, a finally handler will be attached to the promise and the duration will be reported
         * once the finally handler is invoked.
         * @param fn
         */
        timerify<T extends (...params: any[]) => any>(fn: T, options?: TimerifyOptions): T;
        /**
         * An object which is JSON representation of the performance object. It is similar to
         * [`window.performance.toJSON`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/toJSON) in browsers.
         * @since v16.1.0
         */
        toJSON(): any;
    }
    class PerformanceObserverEntryList {
        /**
         * Returns a list of `PerformanceEntry` objects in chronological order
         * with respect to `performanceEntry.startTime`.
         *
         * ```js
         * import {
         *   performance,
         *   PerformanceObserver,
         * } from 'node:perf_hooks';
         *
         * const obs = new PerformanceObserver((perfObserverList, observer) => {
         *   console.log(perfObserverList.getEntries());
         *
         *    * [
         *    *   PerformanceEntry {
         *    *     name: 'test',
         *    *     entryType: 'mark',
         *    *     startTime: 81.465639,
         *    *     duration: 0,
         *    *     detail: null
         *    *   },
         *    *   PerformanceEntry {
         *    *     name: 'meow',
         *    *     entryType: 'mark',
         *    *     startTime: 81.860064,
         *    *     duration: 0,
         *    *     detail: null
         *    *   }
         *    * ]
         *
         *   performance.clearMarks();
         *   performance.clearMeasures();
         *   observer.disconnect();
         * });
         * obs.observe({ type: 'mark' });
         *
         * performance.mark('test');
         * performance.mark('meow');
         * ```
         * @since v8.5.0
         */
        getEntries(): PerformanceEntry[];
        /**
         * Returns a list of `PerformanceEntry` objects in chronological order
         * with respect to `performanceEntry.startTime` whose `performanceEntry.name` is
         * equal to `name`, and optionally, whose `performanceEntry.entryType` is equal to`type`.
         *
         * ```js
         * import {
         *   performance,
         *   PerformanceObserver,
         * } from 'node:perf_hooks';
         *
         * const obs = new PerformanceObserver((perfObserverList, observer) => {
         *   console.log(perfObserverList.getEntriesByName('meow'));
         *
         *    * [
         *    *   PerformanceEntry {
         *    *     name: 'meow',
         *    *     entryType: 'mark',
         *    *     startTime: 98.545991,
         *    *     duration: 0,
         *    *     detail: null
         *    *   }
         *    * ]
         *
         *   console.log(perfObserverList.getEntriesByName('nope')); // []
         *
         *   console.log(perfObserverList.getEntriesByName('test', 'mark'));
         *
         *    * [
         *    *   PerformanceEntry {
         *    *     name: 'test',
         *    *     entryType: 'mark',
         *    *     startTime: 63.518931,
         *    *     duration: 0,
         *    *     detail: null
         *    *   }
         *    * ]
         *
         *   console.log(perfObserverList.getEntriesByName('test', 'measure')); // []
         *
         *   performance.clearMarks();
         *   performance.clearMeasures();
         *   observer.disconnect();
         * });
         * obs.observe({ entryTypes: ['mark', 'measure'] });
         *
         * performance.mark('test');
         * performance.mark('meow');
         * ```
         * @since v8.5.0
         */
        getEntriesByName(name: string, type?: EntryType): PerformanceEntry[];
        /**
         * Returns a list of `PerformanceEntry` objects in chronological order
         * with respect to `performanceEntry.startTime` whose `performanceEntry.entryType` is equal to `type`.
         *
         * ```js
         * import {
         *   performance,
         *   PerformanceObserver,
         * } from 'node:perf_hooks';
         *
         * const obs = new PerformanceObserver((perfObserverList, observer) => {
         *   console.log(perfObserverList.getEntriesByType('mark'));
         *
         *    * [
         *    *   PerformanceEntry {
         *    *     name: 'test',
         *    *     entryType: 'mark',
         *    *     startTime: 55.897834,
         *    *     duration: 0,
         *    *     detail: null
         *    *   },
         *    *   PerformanceEntry {
         *    *     name: 'meow',
         *    *     entryType: 'mark',
         *    *     startTime: 56.350146,
         *    *     duration: 0,
         *    *     detail: null
         *    *   }
         *    * ]
         *
         *   performance.clearMarks();
         *   performance.clearMeasures();
         *   observer.disconnect();
         * });
         * obs.observe({ type: 'mark' });
         *
         * performance.mark('test');
         * performance.mark('meow');
         * ```
         * @since v8.5.0
         */
        getEntriesByType(type: EntryType): PerformanceEntry[];
    }
    type PerformanceObserverCallback = (list: PerformanceObserverEntryList, observer: PerformanceObserver) => void;
    /**
     * @since v8.5.0
     */
    class PerformanceObserver extends AsyncResource {
        constructor(callback: PerformanceObserverCallback);
        /**
         * Disconnects the `PerformanceObserver` instance from all notifications.
         * @since v8.5.0
         */
        disconnect(): void;
        /**
         * Subscribes the `PerformanceObserver` instance to notifications of new `PerformanceEntry` instances identified either by `options.entryTypes` or `options.type`:
         *
         * ```js
         * import {
         *   performance,
         *   PerformanceObserver,
         * } from 'node:perf_hooks';
         *
         * const obs = new PerformanceObserver((list, observer) => {
         *   // Called once asynchronously. `list` contains three items.
         * });
         * obs.observe({ type: 'mark' });
         *
         * for (let n = 0; n < 3; n++)
         *   performance.mark(`test${n}`);
         * ```
         * @since v8.5.0
         */
        observe(
            options:
                | {
                    entryTypes: readonly EntryType[];
                    buffered?: boolean | undefined;
                }
                | {
                    type: EntryType;
                    buffered?: boolean | undefined;
                },
        ): void;
        /**
         * @since v16.0.0
         * @returns Current list of entries stored in the performance observer, emptying it out.
         */
        takeRecords(): PerformanceEntry[];
    }
    /**
     * Provides detailed network timing data regarding the loading of an application's resources.
     *
     * The constructor of this class is not exposed to users directly.
     * @since v18.2.0, v16.17.0
     */
    class PerformanceResourceTiming extends PerformanceEntry {
        readonly entryType: "resource";
        protected constructor();
        /**
         * The high resolution millisecond timestamp at immediately before dispatching the `fetch`
         * request. If the resource is not intercepted by a worker the property will always return 0.
         * @since v18.2.0, v16.17.0
         */
        readonly workerStart: number;
        /**
         * The high resolution millisecond timestamp that represents the start time of the fetch which
         * initiates the redirect.
         * @since v18.2.0, v16.17.0
         */
        readonly redirectStart: number;
        /**
         * The high resolution millisecond timestamp that will be created immediately after receiving
         * the last byte of the response of the last redirect.
         * @since v18.2.0, v16.17.0
         */
        readonly redirectEnd: number;
        /**
         * The high resolution millisecond timestamp immediately before the Node.js starts to fetch the resource.
         * @since v18.2.0, v16.17.0
         */
        readonly fetchStart: number;
        /**
         * The high resolution millisecond timestamp immediately before the Node.js starts the domain name lookup
         * for the resource.
         * @since v18.2.0, v16.17.0
         */
        readonly domainLookupStart: number;
        /**
         * The high resolution millisecond timestamp representing the time immediately after the Node.js finished
         * the domain name lookup for the resource.
         * @since v18.2.0, v16.17.0
         */
        readonly domainLookupEnd: number;
        /**
         * The high resolution millisecond timestamp representing the time immediately before Node.js starts to
         * establish the connection to the server to retrieve the resource.
         * @since v18.2.0, v16.17.0
         */
        readonly connectStart: number;
        /**
         * The high resolution millisecond timestamp representing the time immediately after Node.js finishes
         * establishing the connection to the server to retrieve the resource.
         * @since v18.2.0, v16.17.0
         */
        readonly connectEnd: number;
        /**
         * The high resolution millisecond timestamp representing the time immediately before Node.js starts the
         * handshake process to secure the current connection.
         * @since v18.2.0, v16.17.0
         */
        readonly secureConnectionStart: number;
        /**
         * The high resolution millisecond timestamp representing the time immediately before Node.js receives the
         * first byte of the response from the server.
         * @since v18.2.0, v16.17.0
         */
        readonly requestStart: number;
        /**
         * The high resolution millisecond timestamp representing the time immediately after Node.js receives the
         * last byte of the resource or immediately before the transport connection is closed, whichever comes first.
         * @since v18.2.0, v16.17.0
         */
        readonly responseEnd: number;
        /**
         * A number representing the size (in octets) of the fetched resource. The size includes the response header
         * fields plus the response payload body.
         * @since v18.2.0, v16.17.0
         */
        readonly transferSize: number;
        /**
         * A number representing the size (in octets) received from the fetch (HTTP or cache), of the payload body, before
         * removing any applied content-codings.
         * @since v18.2.0, v16.17.0
         */
        readonly encodedBodySize: number;
        /**
         * A number representing the size (in octets) received from the fetch (HTTP or cache), of the message body, after
         * removing any applied content-codings.
         * @since v18.2.0, v16.17.0
         */
        readonly decodedBodySize: number;
        /**
         * Returns a `object` that is the JSON representation of the `PerformanceResourceTiming` object
         * @since v18.2.0, v16.17.0
         */
        toJSON(): any;
    }
    namespace constants {
        const NODE_PERFORMANCE_GC_MAJOR: number;
        const NODE_PERFORMANCE_GC_MINOR: number;
        const NODE_PERFORMANCE_GC_INCREMENTAL: number;
        const NODE_PERFORMANCE_GC_WEAKCB: number;
        const NODE_PERFORMANCE_GC_FLAGS_NO: number;
        const NODE_PERFORMANCE_GC_FLAGS_CONSTRUCT_RETAINED: number;
        const NODE_PERFORMANCE_GC_FLAGS_FORCED: number;
        const NODE_PERFORMANCE_GC_FLAGS_SYNCHRONOUS_PHANTOM_PROCESSING: number;
        const NODE_PERFORMANCE_GC_FLAGS_ALL_AVAILABLE_GARBAGE: number;
        const NODE_PERFORMANCE_GC_FLAGS_ALL_EXTERNAL_MEMORY: number;
        const NODE_PERFORMANCE_GC_FLAGS_SCHEDULE_IDLE: number;
    }
    const performance: Performance;
    interface EventLoopMonitorOptions {
        /**
         * The sampling rate in milliseconds.
         * Must be greater than zero.
         * @default 10
         */
        resolution?: number | undefined;
    }
    interface Histogram {
        /**
         * The number of samples recorded by the histogram.
         * @since v17.4.0, v16.14.0
         */
        readonly count: number;
        /**
         * The number of samples recorded by the histogram.
         * v17.4.0, v16.14.0
         */
        readonly countBigInt: bigint;
        /**
         * The number of times the event loop delay exceeded the maximum 1 hour event
         * loop delay threshold.
         * @since v11.10.0
         */
        readonly exceeds: number;
        /**
         * The number of times the event loop delay exceeded the maximum 1 hour event loop delay threshold.
         * @since v17.4.0, v16.14.0
         */
        readonly exceedsBigInt: bigint;
        /**
         * The maximum recorded event loop delay.
         * @since v11.10.0
         */
        readonly max: number;
        /**
         * The maximum recorded event loop delay.
         * v17.4.0, v16.14.0
         */
        readonly maxBigInt: number;
        /**
         * The mean of the recorded event loop delays.
         * @since v11.10.0
         */
        readonly mean: number;
        /**
         * The minimum recorded event loop delay.
         * @since v11.10.0
         */
        readonly min: number;
        /**
         * The minimum recorded event loop delay.
         * v17.4.0, v16.14.0
         */
        readonly minBigInt: bigint;
        /**
         * Returns the value at the given percentile.
         * @since v11.10.0
         * @param percentile A percentile value in the range (0, 100].
         */
        percentile(percentile: number): number;
        /**
         * Returns the value at the given percentile.
         * @since v17.4.0, v16.14.0
         * @param percentile A percentile value in the range (0, 100].
         */
        percentileBigInt(percentile: number): bigint;
        /**
         * Returns a `Map` object detailing the accumulated percentile distribution.
         * @since v11.10.0
         */
        readonly percentiles: Map<number, number>;
        /**
         * Returns a `Map` object detailing the accumulated percentile distribution.
         * @since v17.4.0, v16.14.0
         */
        readonly percentilesBigInt: Map<bigint, bigint>;
        /**
         * Resets the collected histogram data.
         * @since v11.10.0
         */
        reset(): void;
        /**
         * The standard deviation of the recorded event loop delays.
         * @since v11.10.0
         */
        readonly stddev: number;
    }
    interface IntervalHistogram extends Histogram {
        /**
         * Enables the update interval timer. Returns `true` if the timer was
         * started, `false` if it was already started.
         * @since v11.10.0
         */
        enable(): boolean;
        /**
         * Disables the update interval timer. Returns `true` if the timer was
         * stopped, `false` if it was already stopped.
         * @since v11.10.0
         */
        disable(): boolean;
    }
    interface RecordableHistogram extends Histogram {
        /**
         * @since v15.9.0, v14.18.0
         * @param val The amount to record in the histogram.
         */
        record(val: number | bigint): void;
        /**
         * Calculates the amount of time (in nanoseconds) that has passed since the
         * previous call to `recordDelta()` and records that amount in the histogram.
         * @since v15.9.0, v14.18.0
         */
        recordDelta(): void;
        /**
         * Adds the values from `other` to this histogram.
         * @since v17.4.0, v16.14.0
         */
        add(other: RecordableHistogram): void;
    }
    /**
     * _This property is an extension by Node.js. It is not available in Web browsers._
     *
     * Creates an `IntervalHistogram` object that samples and reports the event loop
     * delay over time. The delays will be reported in nanoseconds.
     *
     * Using a timer to detect approximate event loop delay works because the
     * execution of timers is tied specifically to the lifecycle of the libuv
     * event loop. That is, a delay in the loop will cause a delay in the execution
     * of the timer, and those delays are specifically what this API is intended to
     * detect.
     *
     * ```js
     * import { monitorEventLoopDelay } from 'node:perf_hooks';
     * const h = monitorEventLoopDelay({ resolution: 20 });
     * h.enable();
     * // Do something.
     * h.disable();
     * console.log(h.min);
     * console.log(h.max);
     * console.log(h.mean);
     * console.log(h.stddev);
     * console.log(h.percentiles);
     * console.log(h.percentile(50));
     * console.log(h.percentile(99));
     * ```
     * @since v11.10.0
     */
    function monitorEventLoopDelay(options?: EventLoopMonitorOptions): IntervalHistogram;
    interface CreateHistogramOptions {
        /**
         * The minimum recordable value. Must be an integer value greater than 0.
         * @default 1
         */
        lowest?: number | bigint | undefined;
        /**
         * The maximum recordable value. Must be an integer value greater than min.
         * @default Number.MAX_SAFE_INTEGER
         */
        highest?: number | bigint | undefined;
        /**
         * The number of accuracy digits. Must be a number between 1 and 5.
         * @default 3
         */
        figures?: number | undefined;
    }
    /**
     * Returns a `RecordableHistogram`.
     * @since v15.9.0, v14.18.0
     */
    function createHistogram(options?: CreateHistogramOptions): RecordableHistogram;
    import {
        performance as _performance,
        PerformanceEntry as _PerformanceEntry,
        PerformanceMark as _PerformanceMark,
        PerformanceMeasure as _PerformanceMeasure,
        PerformanceObserver as _PerformanceObserver,
        PerformanceObserverEntryList as _PerformanceObserverEntryList,
        PerformanceResourceTiming as _PerformanceResourceTiming,
    } from "perf_hooks";
    global {
        /**
         * `PerformanceEntry` is a global reference for `import { PerformanceEntry } from 'node:perf_hooks'`
         * @see https://nodejs.org/docs/latest-v22.x/api/globals.html#performanceentry
         * @since v19.0.0
         */
        var PerformanceEntry: typeof globalThis extends {
            onmessage: any;
            PerformanceEntry: infer T;
        } ? T
            : typeof _PerformanceEntry;
        /**
         * `PerformanceMark` is a global reference for `import { PerformanceMark } from 'node:perf_hooks'`
         * @see https://nodejs.org/docs/latest-v22.x/api/globals.html#performancemark
         * @since v19.0.0
         */
        var PerformanceMark: typeof globalThis extends {
            onmessage: any;
            PerformanceMark: infer T;
        } ? T
            : typeof _PerformanceMark;
        /**
         * `PerformanceMeasure` is a global reference for `import { PerformanceMeasure } from 'node:perf_hooks'`
         * @see https://nodejs.org/docs/latest-v22.x/api/globals.html#performancemeasure
         * @since v19.0.0
         */
        var PerformanceMeasure: typeof globalThis extends {
            onmessage: any;
            PerformanceMeasure: infer T;
        } ? T
            : typeof _PerformanceMeasure;
        /**
         * `PerformanceObserver` is a global reference for `import { PerformanceObserver } from 'node:perf_hooks'`
         * @see https://nodejs.org/docs/latest-v22.x/api/globals.html#performanceobserver
         * @since v19.0.0
         */
        var PerformanceObserver: typeof globalThis extends {
            onmessage: any;
            PerformanceObserver: infer T;
        } ? T
            : typeof _PerformanceObserver;
        /**
         * `PerformanceObserverEntryList` is a global reference for `import { PerformanceObserverEntryList } from 'node:perf_hooks'`
         * @see https://nodejs.org/docs/latest-v22.x/api/globals.html#performanceobserverentrylist
         * @since v19.0.0
         */
        var PerformanceObserverEntryList: typeof globalThis extends {
            onmessage: any;
            PerformanceObserverEntryList: infer T;
        } ? T
            : typeof _PerformanceObserverEntryList;
        /**
         * `PerformanceResourceTiming` is a global reference for `import { PerformanceResourceTiming } from 'node:perf_hooks'`
         * @see https://nodejs.org/docs/latest-v22.x/api/globals.html#performanceresourcetiming
         * @since v19.0.0
         */
        var PerformanceResourceTiming: typeof globalThis extends {
            onmessage: any;
            PerformanceResourceTiming: infer T;
        } ? T
            : typeof _PerformanceResourceTiming;
        /**
         * `performance` is a global reference for `import { performance } from 'node:perf_hooks'`
         * @see https://nodejs.org/docs/latest-v22.x/api/globals.html#performance
         * @since v16.0.0
         */
        var performance: typeof globalThis extends {
            onmessage: any;
            performance: infer T;
        } ? T
            : typeof _performance;
    }
}
declare module "node:perf_hooks" {
    export * from "perf_hooks";
}

```

## ./lib/lambda/node_modules/@types/node/process.d.ts

```typescript
declare module "process" {
    import { Control, MessageOptions } from "node:child_process";
    import * as tty from "node:tty";
    import { Worker } from "node:worker_threads";

    interface BuiltInModule {
        "assert": typeof import("assert");
        "node:assert": typeof import("node:assert");
        "assert/strict": typeof import("assert/strict");
        "node:assert/strict": typeof import("node:assert/strict");
        "async_hooks": typeof import("async_hooks");
        "node:async_hooks": typeof import("node:async_hooks");
        "buffer": typeof import("buffer");
        "node:buffer": typeof import("node:buffer");
        "child_process": typeof import("child_process");
        "node:child_process": typeof import("node:child_process");
        "cluster": typeof import("cluster");
        "node:cluster": typeof import("node:cluster");
        "console": typeof import("console");
        "node:console": typeof import("node:console");
        "constants": typeof import("constants");
        "node:constants": typeof import("node:constants");
        "crypto": typeof import("crypto");
        "node:crypto": typeof import("node:crypto");
        "dgram": typeof import("dgram");
        "node:dgram": typeof import("node:dgram");
        "diagnostics_channel": typeof import("diagnostics_channel");
        "node:diagnostics_channel": typeof import("node:diagnostics_channel");
        "dns": typeof import("dns");
        "node:dns": typeof import("node:dns");
        "dns/promises": typeof import("dns/promises");
        "node:dns/promises": typeof import("node:dns/promises");
        "domain": typeof import("domain");
        "node:domain": typeof import("node:domain");
        "events": typeof import("events");
        "node:events": typeof import("node:events");
        "fs": typeof import("fs");
        "node:fs": typeof import("node:fs");
        "fs/promises": typeof import("fs/promises");
        "node:fs/promises": typeof import("node:fs/promises");
        "http": typeof import("http");
        "node:http": typeof import("node:http");
        "http2": typeof import("http2");
        "node:http2": typeof import("node:http2");
        "https": typeof import("https");
        "node:https": typeof import("node:https");
        "inspector": typeof import("inspector");
        "node:inspector": typeof import("node:inspector");
        "inspector/promises": typeof import("inspector/promises");
        "node:inspector/promises": typeof import("node:inspector/promises");
        "module": typeof import("module");
        "node:module": typeof import("node:module");
        "net": typeof import("net");
        "node:net": typeof import("node:net");
        "os": typeof import("os");
        "node:os": typeof import("node:os");
        "path": typeof import("path");
        "node:path": typeof import("node:path");
        "path/posix": typeof import("path/posix");
        "node:path/posix": typeof import("node:path/posix");
        "path/win32": typeof import("path/win32");
        "node:path/win32": typeof import("node:path/win32");
        "perf_hooks": typeof import("perf_hooks");
        "node:perf_hooks": typeof import("node:perf_hooks");
        "process": typeof import("process");
        "node:process": typeof import("node:process");
        "punycode": typeof import("punycode");
        "node:punycode": typeof import("node:punycode");
        "querystring": typeof import("querystring");
        "node:querystring": typeof import("node:querystring");
        "readline": typeof import("readline");
        "node:readline": typeof import("node:readline");
        "readline/promises": typeof import("readline/promises");
        "node:readline/promises": typeof import("node:readline/promises");
        "repl": typeof import("repl");
        "node:repl": typeof import("node:repl");
        "node:sea": typeof import("node:sea");
        "node:sqlite": typeof import("node:sqlite");
        "stream": typeof import("stream");
        "node:stream": typeof import("node:stream");
        "stream/consumers": typeof import("stream/consumers");
        "node:stream/consumers": typeof import("node:stream/consumers");
        "stream/promises": typeof import("stream/promises");
        "node:stream/promises": typeof import("node:stream/promises");
        "stream/web": typeof import("stream/web");
        "node:stream/web": typeof import("node:stream/web");
        "string_decoder": typeof import("string_decoder");
        "node:string_decoder": typeof import("node:string_decoder");
        "node:test": typeof import("node:test");
        "node:test/reporters": typeof import("node:test/reporters");
        "timers": typeof import("timers");
        "node:timers": typeof import("node:timers");
        "timers/promises": typeof import("timers/promises");
        "node:timers/promises": typeof import("node:timers/promises");
        "tls": typeof import("tls");
        "node:tls": typeof import("node:tls");
        "trace_events": typeof import("trace_events");
        "node:trace_events": typeof import("node:trace_events");
        "tty": typeof import("tty");
        "node:tty": typeof import("node:tty");
        "url": typeof import("url");
        "node:url": typeof import("node:url");
        "util": typeof import("util");
        "node:util": typeof import("node:util");
        "sys": typeof import("util");
        "node:sys": typeof import("node:util");
        "util/types": typeof import("util/types");
        "node:util/types": typeof import("node:util/types");
        "v8": typeof import("v8");
        "node:v8": typeof import("node:v8");
        "vm": typeof import("vm");
        "node:vm": typeof import("node:vm");
        "wasi": typeof import("wasi");
        "node:wasi": typeof import("node:wasi");
        "worker_threads": typeof import("worker_threads");
        "node:worker_threads": typeof import("node:worker_threads");
        "zlib": typeof import("zlib");
        "node:zlib": typeof import("node:zlib");
    }
    global {
        var process: NodeJS.Process;
        namespace NodeJS {
            // this namespace merge is here because these are specifically used
            // as the type for process.stdin, process.stdout, and process.stderr.
            // they can't live in tty.d.ts because we need to disambiguate the imported name.
            interface ReadStream extends tty.ReadStream {}
            interface WriteStream extends tty.WriteStream {}
            interface MemoryUsageFn {
                /**
                 * The `process.memoryUsage()` method iterate over each page to gather informations about memory
                 * usage which can be slow depending on the program memory allocations.
                 */
                (): MemoryUsage;
                /**
                 * method returns an integer representing the Resident Set Size (RSS) in bytes.
                 */
                rss(): number;
            }
            interface MemoryUsage {
                /**
                 * Resident Set Size, is the amount of space occupied in the main memory device (that is a subset of the total allocated memory) for the
                 * process, including all C++ and JavaScript objects and code.
                 */
                rss: number;
                /**
                 * Refers to V8's memory usage.
                 */
                heapTotal: number;
                /**
                 * Refers to V8's memory usage.
                 */
                heapUsed: number;
                external: number;
                /**
                 * Refers to memory allocated for `ArrayBuffer`s and `SharedArrayBuffer`s, including all Node.js Buffers. This is also included
                 * in the external value. When Node.js is used as an embedded library, this value may be `0` because allocations for `ArrayBuffer`s
                 * may not be tracked in that case.
                 */
                arrayBuffers: number;
            }
            interface CpuUsage {
                user: number;
                system: number;
            }
            interface ProcessRelease {
                name: string;
                sourceUrl?: string | undefined;
                headersUrl?: string | undefined;
                libUrl?: string | undefined;
                lts?: string | undefined;
            }
            interface ProcessFeatures {
                /**
                 * A boolean value that is `true` if the current Node.js build is caching builtin modules.
                 * @since v12.0.0
                 */
                readonly cached_builtins: boolean;
                /**
                 * A boolean value that is `true` if the current Node.js build is a debug build.
                 * @since v0.5.5
                 */
                readonly debug: boolean;
                /**
                 * A boolean value that is `true` if the current Node.js build includes the inspector.
                 * @since v11.10.0
                 */
                readonly inspector: boolean;
                /**
                 * A boolean value that is `true` if the current Node.js build includes support for IPv6.
                 *
                 * Since all Node.js builds have IPv6 support, this value is always `true`.
                 * @since v0.5.3
                 * @deprecated This property is always true, and any checks based on it are redundant.
                 */
                readonly ipv6: boolean;
                /**
                 * A boolean value that is `true` if the current Node.js build supports
                 * [loading ECMAScript modules using `require()`](https://nodejs.org/docs/latest-v22.x/api/modules.md#loading-ecmascript-modules-using-require).
                 * @since v22.10.0
                 */
                readonly require_module: boolean;
                /**
                 * A boolean value that is `true` if the current Node.js build includes support for TLS.
                 * @since v0.5.3
                 */
                readonly tls: boolean;
                /**
                 * A boolean value that is `true` if the current Node.js build includes support for ALPN in TLS.
                 *
                 * In Node.js 11.0.0 and later versions, the OpenSSL dependencies feature unconditional ALPN support.
                 * This value is therefore identical to that of `process.features.tls`.
                 * @since v4.8.0
                 * @deprecated Use `process.features.tls` instead.
                 */
                readonly tls_alpn: boolean;
                /**
                 * A boolean value that is `true` if the current Node.js build includes support for OCSP in TLS.
                 *
                 * In Node.js 11.0.0 and later versions, the OpenSSL dependencies feature unconditional OCSP support.
                 * This value is therefore identical to that of `process.features.tls`.
                 * @since v0.11.13
                 * @deprecated Use `process.features.tls` instead.
                 */
                readonly tls_ocsp: boolean;
                /**
                 * A boolean value that is `true` if the current Node.js build includes support for SNI in TLS.
                 *
                 * In Node.js 11.0.0 and later versions, the OpenSSL dependencies feature unconditional SNI support.
                 * This value is therefore identical to that of `process.features.tls`.
                 * @since v0.5.3
                 * @deprecated Use `process.features.tls` instead.
                 */
                readonly tls_sni: boolean;
                /**
                 * A value that is `"strip"` by default,
                 * `"transform"` if Node.js is run with `--experimental-transform-types`, and `false` if
                 * Node.js is run with `--no-experimental-strip-types`.
                 * @since v22.10.0
                 */
                readonly typescript: "strip" | "transform" | false;
                /**
                 * A boolean value that is `true` if the current Node.js build includes support for libuv.
                 *
                 * Since it's not possible to build Node.js without libuv, this value is always `true`.
                 * @since v0.5.3
                 * @deprecated This property is always true, and any checks based on it are redundant.
                 */
                readonly uv: boolean;
            }
            interface ProcessVersions extends Dict<string> {
                http_parser: string;
                node: string;
                v8: string;
                ares: string;
                uv: string;
                zlib: string;
                modules: string;
                openssl: string;
            }
            type Platform =
                | "aix"
                | "android"
                | "darwin"
                | "freebsd"
                | "haiku"
                | "linux"
                | "openbsd"
                | "sunos"
                | "win32"
                | "cygwin"
                | "netbsd";
            type Architecture =
                | "arm"
                | "arm64"
                | "ia32"
                | "loong64"
                | "mips"
                | "mipsel"
                | "ppc"
                | "ppc64"
                | "riscv64"
                | "s390"
                | "s390x"
                | "x64";
            type Signals =
                | "SIGABRT"
                | "SIGALRM"
                | "SIGBUS"
                | "SIGCHLD"
                | "SIGCONT"
                | "SIGFPE"
                | "SIGHUP"
                | "SIGILL"
                | "SIGINT"
                | "SIGIO"
                | "SIGIOT"
                | "SIGKILL"
                | "SIGPIPE"
                | "SIGPOLL"
                | "SIGPROF"
                | "SIGPWR"
                | "SIGQUIT"
                | "SIGSEGV"
                | "SIGSTKFLT"
                | "SIGSTOP"
                | "SIGSYS"
                | "SIGTERM"
                | "SIGTRAP"
                | "SIGTSTP"
                | "SIGTTIN"
                | "SIGTTOU"
                | "SIGUNUSED"
                | "SIGURG"
                | "SIGUSR1"
                | "SIGUSR2"
                | "SIGVTALRM"
                | "SIGWINCH"
                | "SIGXCPU"
                | "SIGXFSZ"
                | "SIGBREAK"
                | "SIGLOST"
                | "SIGINFO";
            type UncaughtExceptionOrigin = "uncaughtException" | "unhandledRejection";
            type MultipleResolveType = "resolve" | "reject";
            type BeforeExitListener = (code: number) => void;
            type DisconnectListener = () => void;
            type ExitListener = (code: number) => void;
            type RejectionHandledListener = (promise: Promise<unknown>) => void;
            type UncaughtExceptionListener = (error: Error, origin: UncaughtExceptionOrigin) => void;
            /**
             * Most of the time the unhandledRejection will be an Error, but this should not be relied upon
             * as *anything* can be thrown/rejected, it is therefore unsafe to assume that the value is an Error.
             */
            type UnhandledRejectionListener = (reason: unknown, promise: Promise<unknown>) => void;
            type WarningListener = (warning: Error) => void;
            type MessageListener = (message: unknown, sendHandle: unknown) => void;
            type SignalsListener = (signal: Signals) => void;
            type MultipleResolveListener = (
                type: MultipleResolveType,
                promise: Promise<unknown>,
                value: unknown,
            ) => void;
            type WorkerListener = (worker: Worker) => void;
            interface Socket extends ReadWriteStream {
                isTTY?: true | undefined;
            }
            // Alias for compatibility
            interface ProcessEnv extends Dict<string> {
                /**
                 * Can be used to change the default timezone at runtime
                 */
                TZ?: string | undefined;
            }
            interface HRTime {
                /**
                 * This is the legacy version of {@link process.hrtime.bigint()}
                 * before bigint was introduced in JavaScript.
                 *
                 * The `process.hrtime()` method returns the current high-resolution real time in a `[seconds, nanoseconds]` tuple `Array`,
                 * where `nanoseconds` is the remaining part of the real time that can't be represented in second precision.
                 *
                 * `time` is an optional parameter that must be the result of a previous `process.hrtime()` call to diff with the current time.
                 * If the parameter passed in is not a tuple `Array`, a TypeError will be thrown.
                 * Passing in a user-defined array instead of the result of a previous call to `process.hrtime()` will lead to undefined behavior.
                 *
                 * These times are relative to an arbitrary time in the past,
                 * and not related to the time of day and therefore not subject to clock drift.
                 * The primary use is for measuring performance between intervals:
                 * ```js
                 * const { hrtime } = require('node:process');
                 * const NS_PER_SEC = 1e9;
                 * const time = hrtime();
                 * // [ 1800216, 25 ]
                 *
                 * setTimeout(() => {
                 *   const diff = hrtime(time);
                 *   // [ 1, 552 ]
                 *
                 *   console.log(`Benchmark took ${diff[0] * NS_PER_SEC + diff[1]} nanoseconds`);
                 *   // Benchmark took 1000000552 nanoseconds
                 * }, 1000);
                 * ```
                 * @since 0.7.6
                 * @legacy Use {@link process.hrtime.bigint()} instead.
                 * @param time The result of a previous call to `process.hrtime()`
                 */
                (time?: [number, number]): [number, number];
                /**
                 * The `bigint` version of the {@link process.hrtime()} method returning the current high-resolution real time in nanoseconds as a `bigint`.
                 *
                 * Unlike {@link process.hrtime()}, it does not support an additional time argument since the difference can just be computed directly by subtraction of the two `bigint`s.
                 * ```js
                 * import { hrtime } from 'node:process';
                 *
                 * const start = hrtime.bigint();
                 * // 191051479007711n
                 *
                 * setTimeout(() => {
                 *   const end = hrtime.bigint();
                 *   // 191052633396993n
                 *
                 *   console.log(`Benchmark took ${end - start} nanoseconds`);
                 *   // Benchmark took 1154389282 nanoseconds
                 * }, 1000);
                 * ```
                 * @since v10.7.0
                 */
                bigint(): bigint;
            }
            interface ProcessPermission {
                /**
                 * Verifies that the process is able to access the given scope and reference.
                 * If no reference is provided, a global scope is assumed, for instance, `process.permission.has('fs.read')`
                 * will check if the process has ALL file system read permissions.
                 *
                 * The reference has a meaning based on the provided scope. For example, the reference when the scope is File System means files and folders.
                 *
                 * The available scopes are:
                 *
                 * * `fs` - All File System
                 * * `fs.read` - File System read operations
                 * * `fs.write` - File System write operations
                 * * `child` - Child process spawning operations
                 * * `worker` - Worker thread spawning operation
                 *
                 * ```js
                 * // Check if the process has permission to read the README file
                 * process.permission.has('fs.read', './README.md');
                 * // Check if the process has read permission operations
                 * process.permission.has('fs.read');
                 * ```
                 * @since v20.0.0
                 */
                has(scope: string, reference?: string): boolean;
            }
            interface ProcessReport {
                /**
                 * Write reports in a compact format, single-line JSON, more easily consumable by log processing systems
                 * than the default multi-line format designed for human consumption.
                 * @since v13.12.0, v12.17.0
                 */
                compact: boolean;
                /**
                 * Directory where the report is written.
                 * The default value is the empty string, indicating that reports are written to the current
                 * working directory of the Node.js process.
                 */
                directory: string;
                /**
                 * Filename where the report is written. If set to the empty string, the output filename will be comprised
                 * of a timestamp, PID, and sequence number. The default value is the empty string.
                 */
                filename: string;
                /**
                 * Returns a JavaScript Object representation of a diagnostic report for the running process.
                 * The report's JavaScript stack trace is taken from `err`, if present.
                 */
                getReport(err?: Error): object;
                /**
                 * If true, a diagnostic report is generated on fatal errors,
                 * such as out of memory errors or failed C++ assertions.
                 * @default false
                 */
                reportOnFatalError: boolean;
                /**
                 * If true, a diagnostic report is generated when the process
                 * receives the signal specified by process.report.signal.
                 * @default false
                 */
                reportOnSignal: boolean;
                /**
                 * If true, a diagnostic report is generated on uncaught exception.
                 * @default false
                 */
                reportOnUncaughtException: boolean;
                /**
                 * The signal used to trigger the creation of a diagnostic report.
                 * @default 'SIGUSR2'
                 */
                signal: Signals;
                /**
                 * Writes a diagnostic report to a file. If filename is not provided, the default filename
                 * includes the date, time, PID, and a sequence number.
                 * The report's JavaScript stack trace is taken from `err`, if present.
                 *
                 * If the value of filename is set to `'stdout'` or `'stderr'`, the report is written
                 * to the stdout or stderr of the process respectively.
                 * @param fileName Name of the file where the report is written.
                 * This should be a relative path, that will be appended to the directory specified in
                 * `process.report.directory`, or the current working directory of the Node.js process,
                 * if unspecified.
                 * @param err A custom error used for reporting the JavaScript stack.
                 * @return Filename of the generated report.
                 */
                writeReport(fileName?: string, err?: Error): string;
                writeReport(err?: Error): string;
            }
            interface ResourceUsage {
                fsRead: number;
                fsWrite: number;
                involuntaryContextSwitches: number;
                ipcReceived: number;
                ipcSent: number;
                majorPageFault: number;
                maxRSS: number;
                minorPageFault: number;
                sharedMemorySize: number;
                signalsCount: number;
                swappedOut: number;
                systemCPUTime: number;
                unsharedDataSize: number;
                unsharedStackSize: number;
                userCPUTime: number;
                voluntaryContextSwitches: number;
            }
            interface EmitWarningOptions {
                /**
                 * When `warning` is a `string`, `type` is the name to use for the _type_ of warning being emitted.
                 *
                 * @default 'Warning'
                 */
                type?: string | undefined;
                /**
                 * A unique identifier for the warning instance being emitted.
                 */
                code?: string | undefined;
                /**
                 * When `warning` is a `string`, `ctor` is an optional function used to limit the generated stack trace.
                 *
                 * @default process.emitWarning
                 */
                ctor?: Function | undefined;
                /**
                 * Additional text to include with the error.
                 */
                detail?: string | undefined;
            }
            interface ProcessConfig {
                readonly target_defaults: {
                    readonly cflags: any[];
                    readonly default_configuration: string;
                    readonly defines: string[];
                    readonly include_dirs: string[];
                    readonly libraries: string[];
                };
                readonly variables: {
                    readonly clang: number;
                    readonly host_arch: string;
                    readonly node_install_npm: boolean;
                    readonly node_install_waf: boolean;
                    readonly node_prefix: string;
                    readonly node_shared_openssl: boolean;
                    readonly node_shared_v8: boolean;
                    readonly node_shared_zlib: boolean;
                    readonly node_use_dtrace: boolean;
                    readonly node_use_etw: boolean;
                    readonly node_use_openssl: boolean;
                    readonly target_arch: string;
                    readonly v8_no_strict_aliasing: number;
                    readonly v8_use_snapshot: boolean;
                    readonly visibility: string;
                };
            }
            interface Process extends EventEmitter {
                /**
                 * The `process.stdout` property returns a stream connected to`stdout` (fd `1`). It is a `net.Socket` (which is a `Duplex` stream) unless fd `1` refers to a file, in which case it is
                 * a `Writable` stream.
                 *
                 * For example, to copy `process.stdin` to `process.stdout`:
                 *
                 * ```js
                 * import { stdin, stdout } from 'node:process';
                 *
                 * stdin.pipe(stdout);
                 * ```
                 *
                 * `process.stdout` differs from other Node.js streams in important ways. See `note on process I/O` for more information.
                 */
                stdout: WriteStream & {
                    fd: 1;
                };
                /**
                 * The `process.stderr` property returns a stream connected to`stderr` (fd `2`). It is a `net.Socket` (which is a `Duplex` stream) unless fd `2` refers to a file, in which case it is
                 * a `Writable` stream.
                 *
                 * `process.stderr` differs from other Node.js streams in important ways. See `note on process I/O` for more information.
                 */
                stderr: WriteStream & {
                    fd: 2;
                };
                /**
                 * The `process.stdin` property returns a stream connected to`stdin` (fd `0`). It is a `net.Socket` (which is a `Duplex` stream) unless fd `0` refers to a file, in which case it is
                 * a `Readable` stream.
                 *
                 * For details of how to read from `stdin` see `readable.read()`.
                 *
                 * As a `Duplex` stream, `process.stdin` can also be used in "old" mode that
                 * is compatible with scripts written for Node.js prior to v0.10\.
                 * For more information see `Stream compatibility`.
                 *
                 * In "old" streams mode the `stdin` stream is paused by default, so one
                 * must call `process.stdin.resume()` to read from it. Note also that calling `process.stdin.resume()` itself would switch stream to "old" mode.
                 */
                stdin: ReadStream & {
                    fd: 0;
                };
                /**
                 * The `process.argv` property returns an array containing the command-line
                 * arguments passed when the Node.js process was launched. The first element will
                 * be {@link execPath}. See `process.argv0` if access to the original value
                 * of `argv[0]` is needed. The second element will be the path to the JavaScript
                 * file being executed. The remaining elements will be any additional command-line
                 * arguments.
                 *
                 * For example, assuming the following script for `process-args.js`:
                 *
                 * ```js
                 * import { argv } from 'node:process';
                 *
                 * // print process.argv
                 * argv.forEach((val, index) => {
                 *   console.log(`${index}: ${val}`);
                 * });
                 * ```
                 *
                 * Launching the Node.js process as:
                 *
                 * ```bash
                 * node process-args.js one two=three four
                 * ```
                 *
                 * Would generate the output:
                 *
                 * ```text
                 * 0: /usr/local/bin/node
                 * 1: /Users/mjr/work/node/process-args.js
                 * 2: one
                 * 3: two=three
                 * 4: four
                 * ```
                 * @since v0.1.27
                 */
                argv: string[];
                /**
                 * The `process.argv0` property stores a read-only copy of the original value of`argv[0]` passed when Node.js starts.
                 *
                 * ```console
                 * $ bash -c 'exec -a customArgv0 ./node'
                 * > process.argv[0]
                 * '/Volumes/code/external/node/out/Release/node'
                 * > process.argv0
                 * 'customArgv0'
                 * ```
                 * @since v6.4.0
                 */
                argv0: string;
                /**
                 * The `process.execArgv` property returns the set of Node.js-specific command-line
                 * options passed when the Node.js process was launched. These options do not
                 * appear in the array returned by the {@link argv} property, and do not
                 * include the Node.js executable, the name of the script, or any options following
                 * the script name. These options are useful in order to spawn child processes with
                 * the same execution environment as the parent.
                 *
                 * ```bash
                 * node --icu-data-dir=./foo --require ./bar.js script.js --version
                 * ```
                 *
                 * Results in `process.execArgv`:
                 *
                 * ```js
                 * ["--icu-data-dir=./foo", "--require", "./bar.js"]
                 * ```
                 *
                 * And `process.argv`:
                 *
                 * ```js
                 * ['/usr/local/bin/node', 'script.js', '--version']
                 * ```
                 *
                 * Refer to `Worker constructor` for the detailed behavior of worker
                 * threads with this property.
                 * @since v0.7.7
                 */
                execArgv: string[];
                /**
                 * The `process.execPath` property returns the absolute pathname of the executable
                 * that started the Node.js process. Symbolic links, if any, are resolved.
                 *
                 * ```js
                 * '/usr/local/bin/node'
                 * ```
                 * @since v0.1.100
                 */
                execPath: string;
                /**
                 * The `process.abort()` method causes the Node.js process to exit immediately and
                 * generate a core file.
                 *
                 * This feature is not available in `Worker` threads.
                 * @since v0.7.0
                 */
                abort(): never;
                /**
                 * The `process.chdir()` method changes the current working directory of the
                 * Node.js process or throws an exception if doing so fails (for instance, if
                 * the specified `directory` does not exist).
                 *
                 * ```js
                 * import { chdir, cwd } from 'node:process';
                 *
                 * console.log(`Starting directory: ${cwd()}`);
                 * try {
                 *   chdir('/tmp');
                 *   console.log(`New directory: ${cwd()}`);
                 * } catch (err) {
                 *   console.error(`chdir: ${err}`);
                 * }
                 * ```
                 *
                 * This feature is not available in `Worker` threads.
                 * @since v0.1.17
                 */
                chdir(directory: string): void;
                /**
                 * The `process.cwd()` method returns the current working directory of the Node.js
                 * process.
                 *
                 * ```js
                 * import { cwd } from 'node:process';
                 *
                 * console.log(`Current directory: ${cwd()}`);
                 * ```
                 * @since v0.1.8
                 */
                cwd(): string;
                /**
                 * The port used by the Node.js debugger when enabled.
                 *
                 * ```js
                 * import process from 'node:process';
                 *
                 * process.debugPort = 5858;
                 * ```
                 * @since v0.7.2
                 */
                debugPort: number;
                /**
                 * The `process.dlopen()` method allows dynamically loading shared objects. It is primarily used by `require()` to load C++ Addons, and
                 * should not be used directly, except in special cases. In other words, `require()` should be preferred over `process.dlopen()`
                 * unless there are specific reasons such as custom dlopen flags or loading from ES modules.
                 *
                 * The `flags` argument is an integer that allows to specify dlopen behavior. See the `[os.constants.dlopen](https://nodejs.org/docs/latest-v22.x/api/os.html#dlopen-constants)`
                 * documentation for details.
                 *
                 * An important requirement when calling `process.dlopen()` is that the `module` instance must be passed. Functions exported by the C++ Addon
                 * are then accessible via `module.exports`.
                 *
                 * The example below shows how to load a C++ Addon, named `local.node`, that exports a `foo` function. All the symbols are loaded before the call returns, by passing the `RTLD_NOW` constant.
                 * In this example the constant is assumed to be available.
                 *
                 * ```js
                 * import { dlopen } from 'node:process';
                 * import { constants } from 'node:os';
                 * import { fileURLToPath } from 'node:url';
                 *
                 * const module = { exports: {} };
                 * dlopen(module, fileURLToPath(new URL('local.node', import.meta.url)),
                 *        constants.dlopen.RTLD_NOW);
                 * module.exports.foo();
                 * ```
                 */
                dlopen(module: object, filename: string, flags?: number): void;
                /**
                 * The `process.emitWarning()` method can be used to emit custom or application
                 * specific process warnings. These can be listened for by adding a handler to the `'warning'` event.
                 *
                 * ```js
                 * import { emitWarning } from 'node:process';
                 *
                 * // Emit a warning using a string.
                 * emitWarning('Something happened!');
                 * // Emits: (node: 56338) Warning: Something happened!
                 * ```
                 *
                 * ```js
                 * import { emitWarning } from 'node:process';
                 *
                 * // Emit a warning using a string and a type.
                 * emitWarning('Something Happened!', 'CustomWarning');
                 * // Emits: (node:56338) CustomWarning: Something Happened!
                 * ```
                 *
                 * ```js
                 * import { emitWarning } from 'node:process';
                 *
                 * emitWarning('Something happened!', 'CustomWarning', 'WARN001');
                 * // Emits: (node:56338) [WARN001] CustomWarning: Something happened!
                 * ```js
                 *
                 * In each of the previous examples, an `Error` object is generated internally by `process.emitWarning()` and passed through to the `'warning'` handler.
                 *
                 * ```js
                 * import process from 'node:process';
                 *
                 * process.on('warning', (warning) => {
                 *   console.warn(warning.name);    // 'Warning'
                 *   console.warn(warning.message); // 'Something happened!'
                 *   console.warn(warning.code);    // 'MY_WARNING'
                 *   console.warn(warning.stack);   // Stack trace
                 *   console.warn(warning.detail);  // 'This is some additional information'
                 * });
                 * ```
                 *
                 * If `warning` is passed as an `Error` object, it will be passed through to the `'warning'` event handler
                 * unmodified (and the optional `type`, `code` and `ctor` arguments will be ignored):
                 *
                 * ```js
                 * import { emitWarning } from 'node:process';
                 *
                 * // Emit a warning using an Error object.
                 * const myWarning = new Error('Something happened!');
                 * // Use the Error name property to specify the type name
                 * myWarning.name = 'CustomWarning';
                 * myWarning.code = 'WARN001';
                 *
                 * emitWarning(myWarning);
                 * // Emits: (node:56338) [WARN001] CustomWarning: Something happened!
                 * ```
                 *
                 * A `TypeError` is thrown if `warning` is anything other than a string or `Error` object.
                 *
                 * While process warnings use `Error` objects, the process warning mechanism is not a replacement for normal error handling mechanisms.
                 *
                 * The following additional handling is implemented if the warning `type` is `'DeprecationWarning'`:
                 * * If the `--throw-deprecation` command-line flag is used, the deprecation warning is thrown as an exception rather than being emitted as an event.
                 * * If the `--no-deprecation` command-line flag is used, the deprecation warning is suppressed.
                 * * If the `--trace-deprecation` command-line flag is used, the deprecation warning is printed to `stderr` along with the full stack trace.
                 * @since v8.0.0
                 * @param warning The warning to emit.
                 */
                emitWarning(warning: string | Error, ctor?: Function): void;
                emitWarning(warning: string | Error, type?: string, ctor?: Function): void;
                emitWarning(warning: string | Error, type?: string, code?: string, ctor?: Function): void;
                emitWarning(warning: string | Error, options?: EmitWarningOptions): void;
                /**
                 * The `process.env` property returns an object containing the user environment.
                 * See [`environ(7)`](http://man7.org/linux/man-pages/man7/environ.7.html).
                 *
                 * An example of this object looks like:
                 *
                 * ```js
                 * {
                 *   TERM: 'xterm-256color',
                 *   SHELL: '/usr/local/bin/bash',
                 *   USER: 'maciej',
                 *   PATH: '~/.bin/:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin',
                 *   PWD: '/Users/maciej',
                 *   EDITOR: 'vim',
                 *   SHLVL: '1',
                 *   HOME: '/Users/maciej',
                 *   LOGNAME: 'maciej',
                 *   _: '/usr/local/bin/node'
                 * }
                 * ```
                 *
                 * It is possible to modify this object, but such modifications will not be
                 * reflected outside the Node.js process, or (unless explicitly requested)
                 * to other `Worker` threads.
                 * In other words, the following example would not work:
                 *
                 * ```bash
                 * node -e 'process.env.foo = "bar"' &#x26;&#x26; echo $foo
                 * ```
                 *
                 * While the following will:
                 *
                 * ```js
                 * import { env } from 'node:process';
                 *
                 * env.foo = 'bar';
                 * console.log(env.foo);
                 * ```
                 *
                 * Assigning a property on `process.env` will implicitly convert the value
                 * to a string. **This behavior is deprecated.** Future versions of Node.js may
                 * throw an error when the value is not a string, number, or boolean.
                 *
                 * ```js
                 * import { env } from 'node:process';
                 *
                 * env.test = null;
                 * console.log(env.test);
                 * // => 'null'
                 * env.test = undefined;
                 * console.log(env.test);
                 * // => 'undefined'
                 * ```
                 *
                 * Use `delete` to delete a property from `process.env`.
                 *
                 * ```js
                 * import { env } from 'node:process';
                 *
                 * env.TEST = 1;
                 * delete env.TEST;
                 * console.log(env.TEST);
                 * // => undefined
                 * ```
                 *
                 * On Windows operating systems, environment variables are case-insensitive.
                 *
                 * ```js
                 * import { env } from 'node:process';
                 *
                 * env.TEST = 1;
                 * console.log(env.test);
                 * // => 1
                 * ```
                 *
                 * Unless explicitly specified when creating a `Worker` instance,
                 * each `Worker` thread has its own copy of `process.env`, based on its
                 * parent thread's `process.env`, or whatever was specified as the `env` option
                 * to the `Worker` constructor. Changes to `process.env` will not be visible
                 * across `Worker` threads, and only the main thread can make changes that
                 * are visible to the operating system or to native add-ons. On Windows, a copy of `process.env` on a `Worker` instance operates in a case-sensitive manner
                 * unlike the main thread.
                 * @since v0.1.27
                 */
                env: ProcessEnv;
                /**
                 * The `process.exit()` method instructs Node.js to terminate the process
                 * synchronously with an exit status of `code`. If `code` is omitted, exit uses
                 * either the 'success' code `0` or the value of `process.exitCode` if it has been
                 * set. Node.js will not terminate until all the `'exit'` event listeners are
                 * called.
                 *
                 * To exit with a 'failure' code:
                 *
                 * ```js
                 * import { exit } from 'node:process';
                 *
                 * exit(1);
                 * ```
                 *
                 * The shell that executed Node.js should see the exit code as `1`.
                 *
                 * Calling `process.exit()` will force the process to exit as quickly as possible
                 * even if there are still asynchronous operations pending that have not yet
                 * completed fully, including I/O operations to `process.stdout` and `process.stderr`.
                 *
                 * In most situations, it is not actually necessary to call `process.exit()` explicitly. The Node.js process will exit on its own _if there is no additional_
                 * _work pending_ in the event loop. The `process.exitCode` property can be set to
                 * tell the process which exit code to use when the process exits gracefully.
                 *
                 * For instance, the following example illustrates a _misuse_ of the `process.exit()` method that could lead to data printed to stdout being
                 * truncated and lost:
                 *
                 * ```js
                 * import { exit } from 'node:process';
                 *
                 * // This is an example of what *not* to do:
                 * if (someConditionNotMet()) {
                 *   printUsageToStdout();
                 *   exit(1);
                 * }
                 * ```
                 *
                 * The reason this is problematic is because writes to `process.stdout` in Node.js
                 * are sometimes _asynchronous_ and may occur over multiple ticks of the Node.js
                 * event loop. Calling `process.exit()`, however, forces the process to exit _before_ those additional writes to `stdout` can be performed.
                 *
                 * Rather than calling `process.exit()` directly, the code _should_ set the `process.exitCode` and allow the process to exit naturally by avoiding
                 * scheduling any additional work for the event loop:
                 *
                 * ```js
                 * import process from 'node:process';
                 *
                 * // How to properly set the exit code while letting
                 * // the process exit gracefully.
                 * if (someConditionNotMet()) {
                 *   printUsageToStdout();
                 *   process.exitCode = 1;
                 * }
                 * ```
                 *
                 * If it is necessary to terminate the Node.js process due to an error condition,
                 * throwing an _uncaught_ error and allowing the process to terminate accordingly
                 * is safer than calling `process.exit()`.
                 *
                 * In `Worker` threads, this function stops the current thread rather
                 * than the current process.
                 * @since v0.1.13
                 * @param [code=0] The exit code. For string type, only integer strings (e.g.,'1') are allowed.
                 */
                exit(code?: number | string | null): never;
                /**
                 * A number which will be the process exit code, when the process either
                 * exits gracefully, or is exited via {@link exit} without specifying
                 * a code.
                 *
                 * Specifying a code to {@link exit} will override any
                 * previous setting of `process.exitCode`.
                 * @default undefined
                 * @since v0.11.8
                 */
                exitCode: number | string | null | undefined;
                finalization: {
                    /**
                     * This function registers a callback to be called when the process emits the `exit` event if the `ref` object was not garbage collected.
                     * If the object `ref` was garbage collected before the `exit` event is emitted, the callback will be removed from the finalization registry, and it will not be called on process exit.
                     *
                     * Inside the callback you can release the resources allocated by the `ref` object.
                     * Be aware that all limitations applied to the `beforeExit` event are also applied to the callback function,
                     * this means that there is a possibility that the callback will not be called under special circumstances.
                     *
                     * The idea of this function is to help you free up resources when the starts process exiting, but also let the object be garbage collected if it is no longer being used.
                     * @param ref The reference to the resource that is being tracked.
                     * @param callback The callback function to be called when the resource is finalized.
                     * @since v22.5.0
                     * @experimental
                     */
                    register<T extends object>(ref: T, callback: (ref: T, event: "exit") => void): void;
                    /**
                     * This function behaves exactly like the `register`, except that the callback will be called when the process emits the `beforeExit` event if `ref` object was not garbage collected.
                     *
                     * Be aware that all limitations applied to the `beforeExit` event are also applied to the callback function, this means that there is a possibility that the callback will not be called under special circumstances.
                     * @param ref The reference to the resource that is being tracked.
                     * @param callback The callback function to be called when the resource is finalized.
                     * @since v22.5.0
                     * @experimental
                     */
                    registerBeforeExit<T extends object>(ref: T, callback: (ref: T, event: "beforeExit") => void): void;
                    /**
                     * This function remove the register of the object from the finalization registry, so the callback will not be called anymore.
                     * @param ref The reference to the resource that was registered previously.
                     * @since v22.5.0
                     * @experimental
                     */
                    unregister(ref: object): void;
                };
                /**
                 * The `process.getActiveResourcesInfo()` method returns an array of strings containing
                 * the types of the active resources that are currently keeping the event loop alive.
                 *
                 * ```js
                 * import { getActiveResourcesInfo } from 'node:process';
                 * import { setTimeout } from 'node:timers';

                 * console.log('Before:', getActiveResourcesInfo());
                 * setTimeout(() => {}, 1000);
                 * console.log('After:', getActiveResourcesInfo());
                 * // Prints:
                 * //   Before: [ 'TTYWrap', 'TTYWrap', 'TTYWrap' ]
                 * //   After: [ 'TTYWrap', 'TTYWrap', 'TTYWrap', 'Timeout' ]
                 * ```
                 * @since v17.3.0, v16.14.0
                 */
                getActiveResourcesInfo(): string[];
                /**
                 * Provides a way to load built-in modules in a globally available function.
                 * @param id ID of the built-in module being requested.
                 */
                getBuiltinModule<ID extends keyof BuiltInModule>(id: ID): BuiltInModule[ID];
                getBuiltinModule(id: string): object | undefined;
                /**
                 * The `process.getgid()` method returns the numerical group identity of the
                 * process. (See [`getgid(2)`](http://man7.org/linux/man-pages/man2/getgid.2.html).)
                 *
                 * ```js
                 * import process from 'node:process';
                 *
                 * if (process.getgid) {
                 *   console.log(`Current gid: ${process.getgid()}`);
                 * }
                 * ```
                 *
                 * This function is only available on POSIX platforms (i.e. not Windows or
                 * Android).
                 * @since v0.1.31
                 */
                getgid?: () => number;
                /**
                 * The `process.setgid()` method sets the group identity of the process. (See [`setgid(2)`](http://man7.org/linux/man-pages/man2/setgid.2.html).) The `id` can be passed as either a
                 * numeric ID or a group name
                 * string. If a group name is specified, this method blocks while resolving the
                 * associated numeric ID.
                 *
                 * ```js
                 * import process from 'node:process';
                 *
                 * if (process.getgid &#x26;&#x26; process.setgid) {
                 *   console.log(`Current gid: ${process.getgid()}`);
                 *   try {
                 *     process.setgid(501);
                 *     console.log(`New gid: ${process.getgid()}`);
                 *   } catch (err) {
                 *     console.log(`Failed to set gid: ${err}`);
                 *   }
                 * }
                 * ```
                 *
                 * This function is only available on POSIX platforms (i.e. not Windows or
                 * Android).
                 * This feature is not available in `Worker` threads.
                 * @since v0.1.31
                 * @param id The group name or ID
                 */
                setgid?: (id: number | string) => void;
                /**
                 * The `process.getuid()` method returns the numeric user identity of the process.
                 * (See [`getuid(2)`](http://man7.org/linux/man-pages/man2/getuid.2.html).)
                 *
                 * ```js
                 * import process from 'node:process';
                 *
                 * if (process.getuid) {
                 *   console.log(`Current uid: ${process.getuid()}`);
                 * }
                 * ```
                 *
                 * This function is only available on POSIX platforms (i.e. not Windows or
                 * Android).
                 * @since v0.1.28
                 */
                getuid?: () => number;
                /**
                 * The `process.setuid(id)` method sets the user identity of the process. (See [`setuid(2)`](http://man7.org/linux/man-pages/man2/setuid.2.html).) The `id` can be passed as either a
                 * numeric ID or a username string.
                 * If a username is specified, the method blocks while resolving the associated
                 * numeric ID.
                 *
                 * ```js
                 * import process from 'node:process';
                 *
                 * if (process.getuid &#x26;&#x26; process.setuid) {
                 *   console.log(`Current uid: ${process.getuid()}`);
                 *   try {
                 *     process.setuid(501);
                 *     console.log(`New uid: ${process.getuid()}`);
                 *   } catch (err) {
                 *     console.log(`Failed to set uid: ${err}`);
                 *   }
                 * }
                 * ```
                 *
                 * This function is only available on POSIX platforms (i.e. not Windows or
                 * Android).
                 * This feature is not available in `Worker` threads.
                 * @since v0.1.28
                 */
                setuid?: (id: number | string) => void;
                /**
                 * The `process.geteuid()` method returns the numerical effective user identity of
                 * the process. (See [`geteuid(2)`](http://man7.org/linux/man-pages/man2/geteuid.2.html).)
                 *
                 * ```js
                 * import process from 'node:process';
                 *
                 * if (process.geteuid) {
                 *   console.log(`Current uid: ${process.geteuid()}`);
                 * }
                 * ```
                 *
                 * This function is only available on POSIX platforms (i.e. not Windows or
                 * Android).
                 * @since v2.0.0
                 */
                geteuid?: () => number;
                /**
                 * The `process.seteuid()` method sets the effective user identity of the process.
                 * (See [`seteuid(2)`](http://man7.org/linux/man-pages/man2/seteuid.2.html).) The `id` can be passed as either a numeric ID or a username
                 * string. If a username is specified, the method blocks while resolving the
                 * associated numeric ID.
                 *
                 * ```js
                 * import process from 'node:process';
                 *
                 * if (process.geteuid &#x26;&#x26; process.seteuid) {
                 *   console.log(`Current uid: ${process.geteuid()}`);
                 *   try {
                 *     process.seteuid(501);
                 *     console.log(`New uid: ${process.geteuid()}`);
                 *   } catch (err) {
                 *     console.log(`Failed to set uid: ${err}`);
                 *   }
                 * }
                 * ```
                 *
                 * This function is only available on POSIX platforms (i.e. not Windows or
                 * Android).
                 * This feature is not available in `Worker` threads.
                 * @since v2.0.0
                 * @param id A user name or ID
                 */
                seteuid?: (id: number | string) => void;
                /**
                 * The `process.getegid()` method returns the numerical effective group identity
                 * of the Node.js process. (See [`getegid(2)`](http://man7.org/linux/man-pages/man2/getegid.2.html).)
                 *
                 * ```js
                 * import process from 'node:process';
                 *
                 * if (process.getegid) {
                 *   console.log(`Current gid: ${process.getegid()}`);
                 * }
                 * ```
                 *
                 * This function is only available on POSIX platforms (i.e. not Windows or
                 * Android).
                 * @since v2.0.0
                 */
                getegid?: () => number;
                /**
                 * The `process.setegid()` method sets the effective group identity of the process.
                 * (See [`setegid(2)`](http://man7.org/linux/man-pages/man2/setegid.2.html).) The `id` can be passed as either a numeric ID or a group
                 * name string. If a group name is specified, this method blocks while resolving
                 * the associated a numeric ID.
                 *
                 * ```js
                 * import process from 'node:process';
                 *
                 * if (process.getegid &#x26;&#x26; process.setegid) {
                 *   console.log(`Current gid: ${process.getegid()}`);
                 *   try {
                 *     process.setegid(501);
                 *     console.log(`New gid: ${process.getegid()}`);
                 *   } catch (err) {
                 *     console.log(`Failed to set gid: ${err}`);
                 *   }
                 * }
                 * ```
                 *
                 * This function is only available on POSIX platforms (i.e. not Windows or
                 * Android).
                 * This feature is not available in `Worker` threads.
                 * @since v2.0.0
                 * @param id A group name or ID
                 */
                setegid?: (id: number | string) => void;
                /**
                 * The `process.getgroups()` method returns an array with the supplementary group
                 * IDs. POSIX leaves it unspecified if the effective group ID is included but
                 * Node.js ensures it always is.
                 *
                 * ```js
                 * import process from 'node:process';
                 *
                 * if (process.getgroups) {
                 *   console.log(process.getgroups()); // [ 16, 21, 297 ]
                 * }
                 * ```
                 *
                 * This function is only available on POSIX platforms (i.e. not Windows or
                 * Android).
                 * @since v0.9.4
                 */
                getgroups?: () => number[];
                /**
                 * The `process.setgroups()` method sets the supplementary group IDs for the
                 * Node.js process. This is a privileged operation that requires the Node.js
                 * process to have `root` or the `CAP_SETGID` capability.
                 *
                 * The `groups` array can contain numeric group IDs, group names, or both.
                 *
                 * ```js
                 * import process from 'node:process';
                 *
                 * if (process.getgroups &#x26;&#x26; process.setgroups) {
                 *   try {
                 *     process.setgroups([501]);
                 *     console.log(process.getgroups()); // new groups
                 *   } catch (err) {
                 *     console.log(`Failed to set groups: ${err}`);
                 *   }
                 * }
                 * ```
                 *
                 * This function is only available on POSIX platforms (i.e. not Windows or
                 * Android).
                 * This feature is not available in `Worker` threads.
                 * @since v0.9.4
                 */
                setgroups?: (groups: ReadonlyArray<string | number>) => void;
                /**
                 * The `process.setUncaughtExceptionCaptureCallback()` function sets a function
                 * that will be invoked when an uncaught exception occurs, which will receive the
                 * exception value itself as its first argument.
                 *
                 * If such a function is set, the `'uncaughtException'` event will
                 * not be emitted. If `--abort-on-uncaught-exception` was passed from the
                 * command line or set through `v8.setFlagsFromString()`, the process will
                 * not abort. Actions configured to take place on exceptions such as report
                 * generations will be affected too
                 *
                 * To unset the capture function, `process.setUncaughtExceptionCaptureCallback(null)` may be used. Calling this
                 * method with a non-`null` argument while another capture function is set will
                 * throw an error.
                 *
                 * Using this function is mutually exclusive with using the deprecated `domain` built-in module.
                 * @since v9.3.0
                 */
                setUncaughtExceptionCaptureCallback(cb: ((err: Error) => void) | null): void;
                /**
                 * Indicates whether a callback has been set using {@link setUncaughtExceptionCaptureCallback}.
                 * @since v9.3.0
                 */
                hasUncaughtExceptionCaptureCallback(): boolean;
                /**
                 * The `process.sourceMapsEnabled` property returns whether the [Source Map v3](https://sourcemaps.info/spec.html) support for stack traces is enabled.
                 * @since v20.7.0
                 * @experimental
                 */
                readonly sourceMapsEnabled: boolean;
                /**
                 * This function enables or disables the [Source Map v3](https://sourcemaps.info/spec.html) support for
                 * stack traces.
                 *
                 * It provides same features as launching Node.js process with commandline options `--enable-source-maps`.
                 *
                 * Only source maps in JavaScript files that are loaded after source maps has been
                 * enabled will be parsed and loaded.
                 * @since v16.6.0, v14.18.0
                 * @experimental
                 */
                setSourceMapsEnabled(value: boolean): void;
                /**
                 * The `process.version` property contains the Node.js version string.
                 *
                 * ```js
                 * import { version } from 'node:process';
                 *
                 * console.log(`Version: ${version}`);
                 * // Version: v14.8.0
                 * ```
                 *
                 * To get the version string without the prepended _v_, use`process.versions.node`.
                 * @since v0.1.3
                 */
                readonly version: string;
                /**
                 * The `process.versions` property returns an object listing the version strings of
                 * Node.js and its dependencies. `process.versions.modules` indicates the current
                 * ABI version, which is increased whenever a C++ API changes. Node.js will refuse
                 * to load modules that were compiled against a different module ABI version.
                 *
                 * ```js
                 * import { versions } from 'node:process';
                 *
                 * console.log(versions);
                 * ```
                 *
                 * Will generate an object similar to:
                 *
                 * ```console
                 * { node: '20.2.0',
                 *   acorn: '8.8.2',
                 *   ada: '2.4.0',
                 *   ares: '1.19.0',
                 *   base64: '0.5.0',
                 *   brotli: '1.0.9',
                 *   cjs_module_lexer: '1.2.2',
                 *   cldr: '43.0',
                 *   icu: '73.1',
                 *   llhttp: '8.1.0',
                 *   modules: '115',
                 *   napi: '8',
                 *   nghttp2: '1.52.0',
                 *   nghttp3: '0.7.0',
                 *   ngtcp2: '0.8.1',
                 *   openssl: '3.0.8+quic',
                 *   simdutf: '3.2.9',
                 *   tz: '2023c',
                 *   undici: '5.22.0',
                 *   unicode: '15.0',
                 *   uv: '1.44.2',
                 *   uvwasi: '0.0.16',
                 *   v8: '11.3.244.8-node.9',
                 *   zlib: '1.2.13' }
                 * ```
                 * @since v0.2.0
                 */
                readonly versions: ProcessVersions;
                /**
                 * The `process.config` property returns a frozen `Object` containing the
                 * JavaScript representation of the configure options used to compile the current
                 * Node.js executable. This is the same as the `config.gypi` file that was produced
                 * when running the `./configure` script.
                 *
                 * An example of the possible output looks like:
                 *
                 * ```js
                 * {
                 *   target_defaults:
                 *    { cflags: [],
                 *      default_configuration: 'Release',
                 *      defines: [],
                 *      include_dirs: [],
                 *      libraries: [] },
                 *   variables:
                 *    {
                 *      host_arch: 'x64',
                 *      napi_build_version: 5,
                 *      node_install_npm: 'true',
                 *      node_prefix: '',
                 *      node_shared_cares: 'false',
                 *      node_shared_http_parser: 'false',
                 *      node_shared_libuv: 'false',
                 *      node_shared_zlib: 'false',
                 *      node_use_openssl: 'true',
                 *      node_shared_openssl: 'false',
                 *      strict_aliasing: 'true',
                 *      target_arch: 'x64',
                 *      v8_use_snapshot: 1
                 *    }
                 * }
                 * ```
                 * @since v0.7.7
                 */
                readonly config: ProcessConfig;
                /**
                 * The `process.kill()` method sends the `signal` to the process identified by`pid`.
                 *
                 * Signal names are strings such as `'SIGINT'` or `'SIGHUP'`. See `Signal Events` and [`kill(2)`](http://man7.org/linux/man-pages/man2/kill.2.html) for more information.
                 *
                 * This method will throw an error if the target `pid` does not exist. As a special
                 * case, a signal of `0` can be used to test for the existence of a process.
                 * Windows platforms will throw an error if the `pid` is used to kill a process
                 * group.
                 *
                 * Even though the name of this function is `process.kill()`, it is really just a
                 * signal sender, like the `kill` system call. The signal sent may do something
                 * other than kill the target process.
                 *
                 * ```js
                 * import process, { kill } from 'node:process';
                 *
                 * process.on('SIGHUP', () => {
                 *   console.log('Got SIGHUP signal.');
                 * });
                 *
                 * setTimeout(() => {
                 *   console.log('Exiting.');
                 *   process.exit(0);
                 * }, 100);
                 *
                 * kill(process.pid, 'SIGHUP');
                 * ```
                 *
                 * When `SIGUSR1` is received by a Node.js process, Node.js will start the
                 * debugger. See `Signal Events`.
                 * @since v0.0.6
                 * @param pid A process ID
                 * @param [signal='SIGTERM'] The signal to send, either as a string or number.
                 */
                kill(pid: number, signal?: string | number): true;
                /**
                 * Loads the environment configuration from a `.env` file into `process.env`. If
                 * the file is not found, error will be thrown.
                 *
                 * To load a specific .env file by specifying its path, use the following code:
                 *
                 * ```js
                 * import { loadEnvFile } from 'node:process';
                 *
                 * loadEnvFile('./development.env')
                 * ```
                 * @since v20.12.0
                 * @param path The path to the .env file
                 */
                loadEnvFile(path?: string | URL | Buffer): void;
                /**
                 * The `process.pid` property returns the PID of the process.
                 *
                 * ```js
                 * import { pid } from 'node:process';
                 *
                 * console.log(`This process is pid ${pid}`);
                 * ```
                 * @since v0.1.15
                 */
                readonly pid: number;
                /**
                 * The `process.ppid` property returns the PID of the parent of the
                 * current process.
                 *
                 * ```js
                 * import { ppid } from 'node:process';
                 *
                 * console.log(`The parent process is pid ${ppid}`);
                 * ```
                 * @since v9.2.0, v8.10.0, v6.13.0
                 */
                readonly ppid: number;
                /**
                 * The `process.title` property returns the current process title (i.e. returns
                 * the current value of `ps`). Assigning a new value to `process.title` modifies
                 * the current value of `ps`.
                 *
                 * When a new value is assigned, different platforms will impose different maximum
                 * length restrictions on the title. Usually such restrictions are quite limited.
                 * For instance, on Linux and macOS, `process.title` is limited to the size of the
                 * binary name plus the length of the command-line arguments because setting the `process.title` overwrites the `argv` memory of the process. Node.js v0.8
                 * allowed for longer process title strings by also overwriting the `environ` memory but that was potentially insecure and confusing in some (rather obscure)
                 * cases.
                 *
                 * Assigning a value to `process.title` might not result in an accurate label
                 * within process manager applications such as macOS Activity Monitor or Windows
                 * Services Manager.
                 * @since v0.1.104
                 */
                title: string;
                /**
                 * The operating system CPU architecture for which the Node.js binary was compiled.
                 * Possible values are: `'arm'`, `'arm64'`, `'ia32'`, `'loong64'`, `'mips'`, `'mipsel'`, `'ppc'`, `'ppc64'`, `'riscv64'`, `'s390'`, `'s390x'`, and `'x64'`.
                 *
                 * ```js
                 * import { arch } from 'node:process';
                 *
                 * console.log(`This processor architecture is ${arch}`);
                 * ```
                 * @since v0.5.0
                 */
                readonly arch: Architecture;
                /**
                 * The `process.platform` property returns a string identifying the operating
                 * system platform for which the Node.js binary was compiled.
                 *
                 * Currently possible values are:
                 *
                 * * `'aix'`
                 * * `'darwin'`
                 * * `'freebsd'`
                 * * `'linux'`
                 * * `'openbsd'`
                 * * `'sunos'`
                 * * `'win32'`
                 *
                 * ```js
                 * import { platform } from 'node:process';
                 *
                 * console.log(`This platform is ${platform}`);
                 * ```
                 *
                 * The value `'android'` may also be returned if the Node.js is built on the
                 * Android operating system. However, Android support in Node.js [is experimental](https://github.com/nodejs/node/blob/HEAD/BUILDING.md#androidandroid-based-devices-eg-firefox-os).
                 * @since v0.1.16
                 */
                readonly platform: Platform;
                /**
                 * The `process.mainModule` property provides an alternative way of retrieving `require.main`. The difference is that if the main module changes at
                 * runtime, `require.main` may still refer to the original main module in
                 * modules that were required before the change occurred. Generally, it's
                 * safe to assume that the two refer to the same module.
                 *
                 * As with `require.main`, `process.mainModule` will be `undefined` if there
                 * is no entry script.
                 * @since v0.1.17
                 * @deprecated Since v14.0.0 - Use `main` instead.
                 */
                mainModule?: Module;
                memoryUsage: MemoryUsageFn;
                /**
                 * Gets the amount of memory available to the process (in bytes) based on
                 * limits imposed by the OS. If there is no such constraint, or the constraint
                 * is unknown, `0` is returned.
                 *
                 * See [`uv_get_constrained_memory`](https://docs.libuv.org/en/v1.x/misc.html#c.uv_get_constrained_memory) for more
                 * information.
                 * @since v19.6.0, v18.15.0
                 */
                constrainedMemory(): number;
                /**
                 * Gets the amount of free memory that is still available to the process (in bytes).
                 * See [`uv_get_available_memory`](https://nodejs.org/docs/latest-v22.x/api/process.html#processavailablememory) for more information.
                 * @since v20.13.0
                 */
                availableMemory(): number;
                /**
                 * The `process.cpuUsage()` method returns the user and system CPU time usage of
                 * the current process, in an object with properties `user` and `system`, whose
                 * values are microsecond values (millionth of a second). These values measure time
                 * spent in user and system code respectively, and may end up being greater than
                 * actual elapsed time if multiple CPU cores are performing work for this process.
                 *
                 * The result of a previous call to `process.cpuUsage()` can be passed as the
                 * argument to the function, to get a diff reading.
                 *
                 * ```js
                 * import { cpuUsage } from 'node:process';
                 *
                 * const startUsage = cpuUsage();
                 * // { user: 38579, system: 6986 }
                 *
                 * // spin the CPU for 500 milliseconds
                 * const now = Date.now();
                 * while (Date.now() - now < 500);
                 *
                 * console.log(cpuUsage(startUsage));
                 * // { user: 514883, system: 11226 }
                 * ```
                 * @since v6.1.0
                 * @param previousValue A previous return value from calling `process.cpuUsage()`
                 */
                cpuUsage(previousValue?: CpuUsage): CpuUsage;
                /**
                 * `process.nextTick()` adds `callback` to the "next tick queue". This queue is
                 * fully drained after the current operation on the JavaScript stack runs to
                 * completion and before the event loop is allowed to continue. It's possible to
                 * create an infinite loop if one were to recursively call `process.nextTick()`.
                 * See the [Event Loop](https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#process-nexttick) guide for more background.
                 *
                 * ```js
                 * import { nextTick } from 'node:process';
                 *
                 * console.log('start');
                 * nextTick(() => {
                 *   console.log('nextTick callback');
                 * });
                 * console.log('scheduled');
                 * // Output:
                 * // start
                 * // scheduled
                 * // nextTick callback
                 * ```
                 *
                 * This is important when developing APIs in order to give users the opportunity
                 * to assign event handlers _after_ an object has been constructed but before any
                 * I/O has occurred:
                 *
                 * ```js
                 * import { nextTick } from 'node:process';
                 *
                 * function MyThing(options) {
                 *   this.setupOptions(options);
                 *
                 *   nextTick(() => {
                 *     this.startDoingStuff();
                 *   });
                 * }
                 *
                 * const thing = new MyThing();
                 * thing.getReadyForStuff();
                 *
                 * // thing.startDoingStuff() gets called now, not before.
                 * ```
                 *
                 * It is very important for APIs to be either 100% synchronous or 100%
                 * asynchronous. Consider this example:
                 *
                 * ```js
                 * // WARNING!  DO NOT USE!  BAD UNSAFE HAZARD!
                 * function maybeSync(arg, cb) {
                 *   if (arg) {
                 *     cb();
                 *     return;
                 *   }
                 *
                 *   fs.stat('file', cb);
                 * }
                 * ```
                 *
                 * This API is hazardous because in the following case:
                 *
                 * ```js
                 * const maybeTrue = Math.random() > 0.5;
                 *
                 * maybeSync(maybeTrue, () => {
                 *   foo();
                 * });
                 *
                 * bar();
                 * ```
                 *
                 * It is not clear whether `foo()` or `bar()` will be called first.
                 *
                 * The following approach is much better:
                 *
                 * ```js
                 * import { nextTick } from 'node:process';
                 *
                 * function definitelyAsync(arg, cb) {
                 *   if (arg) {
                 *     nextTick(cb);
                 *     return;
                 *   }
                 *
                 *   fs.stat('file', cb);
                 * }
                 * ```
                 * @since v0.1.26
                 * @param args Additional arguments to pass when invoking the `callback`
                 */
                nextTick(callback: Function, ...args: any[]): void;
                /**
                 * This API is available through the [--permission](https://nodejs.org/api/cli.html#--permission) flag.
                 *
                 * `process.permission` is an object whose methods are used to manage permissions for the current process.
                 * Additional documentation is available in the [Permission Model](https://nodejs.org/api/permissions.html#permission-model).
                 * @since v20.0.0
                 */
                permission: ProcessPermission;
                /**
                 * The `process.release` property returns an `Object` containing metadata related
                 * to the current release, including URLs for the source tarball and headers-only
                 * tarball.
                 *
                 * `process.release` contains the following properties:
                 *
                 * ```js
                 * {
                 *   name: 'node',
                 *   lts: 'Hydrogen',
                 *   sourceUrl: 'https://nodejs.org/download/release/v18.12.0/node-v18.12.0.tar.gz',
                 *   headersUrl: 'https://nodejs.org/download/release/v18.12.0/node-v18.12.0-headers.tar.gz',
                 *   libUrl: 'https://nodejs.org/download/release/v18.12.0/win-x64/node.lib'
                 * }
                 * ```
                 *
                 * In custom builds from non-release versions of the source tree, only the `name` property may be present. The additional properties should not be
                 * relied upon to exist.
                 * @since v3.0.0
                 */
                readonly release: ProcessRelease;
                readonly features: ProcessFeatures;
                /**
                 * `process.umask()` returns the Node.js process's file mode creation mask. Child
                 * processes inherit the mask from the parent process.
                 * @since v0.1.19
                 * @deprecated Calling `process.umask()` with no argument causes the process-wide umask to be written twice. This introduces a race condition between threads, and is a potential
                 * security vulnerability. There is no safe, cross-platform alternative API.
                 */
                umask(): number;
                /**
                 * Can only be set if not in worker thread.
                 */
                umask(mask: string | number): number;
                /**
                 * The `process.uptime()` method returns the number of seconds the current Node.js
                 * process has been running.
                 *
                 * The return value includes fractions of a second. Use `Math.floor()` to get whole
                 * seconds.
                 * @since v0.5.0
                 */
                uptime(): number;
                hrtime: HRTime;
                /**
                 * If the Node.js process was spawned with an IPC channel, the process.channel property is a reference to the IPC channel.
                 * If no IPC channel exists, this property is undefined.
                 * @since v7.1.0
                 */
                channel?: Control;
                /**
                 * If Node.js is spawned with an IPC channel, the `process.send()` method can be
                 * used to send messages to the parent process. Messages will be received as a `'message'` event on the parent's `ChildProcess` object.
                 *
                 * If Node.js was not spawned with an IPC channel, `process.send` will be `undefined`.
                 *
                 * The message goes through serialization and parsing. The resulting message might
                 * not be the same as what is originally sent.
                 * @since v0.5.9
                 * @param options used to parameterize the sending of certain types of handles. `options` supports the following properties:
                 */
                send?(
                    message: any,
                    sendHandle?: any,
                    options?: MessageOptions,
                    callback?: (error: Error | null) => void,
                ): boolean;
                /**
                 * If the Node.js process is spawned with an IPC channel (see the `Child Process` and `Cluster` documentation), the `process.disconnect()` method will close the
                 * IPC channel to the parent process, allowing the child process to exit gracefully
                 * once there are no other connections keeping it alive.
                 *
                 * The effect of calling `process.disconnect()` is the same as calling `ChildProcess.disconnect()` from the parent process.
                 *
                 * If the Node.js process was not spawned with an IPC channel, `process.disconnect()` will be `undefined`.
                 * @since v0.7.2
                 */
                disconnect(): void;
                /**
                 * If the Node.js process is spawned with an IPC channel (see the `Child Process` and `Cluster` documentation), the `process.connected` property will return `true` so long as the IPC
                 * channel is connected and will return `false` after `process.disconnect()` is called.
                 *
                 * Once `process.connected` is `false`, it is no longer possible to send messages
                 * over the IPC channel using `process.send()`.
                 * @since v0.7.2
                 */
                connected: boolean;
                /**
                 * The `process.allowedNodeEnvironmentFlags` property is a special,
                 * read-only `Set` of flags allowable within the `NODE_OPTIONS` environment variable.
                 *
                 * `process.allowedNodeEnvironmentFlags` extends `Set`, but overrides `Set.prototype.has` to recognize several different possible flag
                 * representations. `process.allowedNodeEnvironmentFlags.has()` will
                 * return `true` in the following cases:
                 *
                 * * Flags may omit leading single (`-`) or double (`--`) dashes; e.g., `inspect-brk` for `--inspect-brk`, or `r` for `-r`.
                 * * Flags passed through to V8 (as listed in `--v8-options`) may replace
                 * one or more _non-leading_ dashes for an underscore, or vice-versa;
                 * e.g., `--perf_basic_prof`, `--perf-basic-prof`, `--perf_basic-prof`,
                 * etc.
                 * * Flags may contain one or more equals (`=`) characters; all
                 * characters after and including the first equals will be ignored;
                 * e.g., `--stack-trace-limit=100`.
                 * * Flags _must_ be allowable within `NODE_OPTIONS`.
                 *
                 * When iterating over `process.allowedNodeEnvironmentFlags`, flags will
                 * appear only _once_; each will begin with one or more dashes. Flags
                 * passed through to V8 will contain underscores instead of non-leading
                 * dashes:
                 *
                 * ```js
                 * import { allowedNodeEnvironmentFlags } from 'node:process';
                 *
                 * allowedNodeEnvironmentFlags.forEach((flag) => {
                 *   // -r
                 *   // --inspect-brk
                 *   // --abort_on_uncaught_exception
                 *   // ...
                 * });
                 * ```
                 *
                 * The methods `add()`, `clear()`, and `delete()` of`process.allowedNodeEnvironmentFlags` do nothing, and will fail
                 * silently.
                 *
                 * If Node.js was compiled _without_ `NODE_OPTIONS` support (shown in {@link config}), `process.allowedNodeEnvironmentFlags` will
                 * contain what _would have_ been allowable.
                 * @since v10.10.0
                 */
                allowedNodeEnvironmentFlags: ReadonlySet<string>;
                /**
                 * `process.report` is an object whose methods are used to generate diagnostic reports for the current process.
                 * Additional documentation is available in the [report documentation](https://nodejs.org/docs/latest-v22.x/api/report.html).
                 * @since v11.8.0
                 */
                report: ProcessReport;
                /**
                 * ```js
                 * import { resourceUsage } from 'node:process';
                 *
                 * console.log(resourceUsage());
                 * /*
                 *   Will output:
                 *   {
                 *     userCPUTime: 82872,
                 *     systemCPUTime: 4143,
                 *     maxRSS: 33164,
                 *     sharedMemorySize: 0,
                 *     unsharedDataSize: 0,
                 *     unsharedStackSize: 0,
                 *     minorPageFault: 2469,
                 *     majorPageFault: 0,
                 *     swappedOut: 0,
                 *     fsRead: 0,
                 *     fsWrite: 8,
                 *     ipcSent: 0,
                 *     ipcReceived: 0,
                 *     signalsCount: 0,
                 *     voluntaryContextSwitches: 79,
                 *     involuntaryContextSwitches: 1
                 *   }
                 *
                 * ```
                 * @since v12.6.0
                 * @return the resource usage for the current process. All of these values come from the `uv_getrusage` call which returns a [`uv_rusage_t` struct][uv_rusage_t].
                 */
                resourceUsage(): ResourceUsage;
                /**
                 * The initial value of `process.throwDeprecation` indicates whether the `--throw-deprecation` flag is set on the current Node.js process. `process.throwDeprecation`
                 * is mutable, so whether or not deprecation warnings result in errors may be altered at runtime. See the documentation for the 'warning' event and the emitWarning()
                 * method for more information.
                 *
                 * ```bash
                 * $ node --throw-deprecation -p "process.throwDeprecation"
                 * true
                 * $ node -p "process.throwDeprecation"
                 * undefined
                 * $ node
                 * > process.emitWarning('test', 'DeprecationWarning');
                 * undefined
                 * > (node:26598) DeprecationWarning: test
                 * > process.throwDeprecation = true;
                 * true
                 * > process.emitWarning('test', 'DeprecationWarning');
                 * Thrown:
                 * [DeprecationWarning: test] { name: 'DeprecationWarning' }
                 * ```
                 * @since v0.9.12
                 */
                throwDeprecation: boolean;
                /**
                 * The `process.traceDeprecation` property indicates whether the `--trace-deprecation` flag is set on the current Node.js process. See the
                 * documentation for the `'warning' event` and the `emitWarning() method` for more information about this
                 * flag's behavior.
                 * @since v0.8.0
                 */
                traceDeprecation: boolean;
                /**
                 * An object is "refable" if it implements the Node.js "Refable protocol".
                 * Specifically, this means that the object implements the `Symbol.for('nodejs.ref')`
                 * and `Symbol.for('nodejs.unref')` methods. "Ref'd" objects will keep the Node.js
                 * event loop alive, while "unref'd" objects will not. Historically, this was
                 * implemented by using `ref()` and `unref()` methods directly on the objects.
                 * This pattern, however, is being deprecated in favor of the "Refable protocol"
                 * in order to better support Web Platform API types whose APIs cannot be modified
                 * to add `ref()` and `unref()` methods but still need to support that behavior.
                 * @since v22.14.0
                 * @experimental
                 * @param maybeRefable An object that may be "refable".
                 */
                ref(maybeRefable: any): void;
                /**
                 * An object is "unrefable" if it implements the Node.js "Refable protocol".
                 * Specifically, this means that the object implements the `Symbol.for('nodejs.ref')`
                 * and `Symbol.for('nodejs.unref')` methods. "Ref'd" objects will keep the Node.js
                 * event loop alive, while "unref'd" objects will not. Historically, this was
                 * implemented by using `ref()` and `unref()` methods directly on the objects.
                 * This pattern, however, is being deprecated in favor of the "Refable protocol"
                 * in order to better support Web Platform API types whose APIs cannot be modified
                 * to add `ref()` and `unref()` methods but still need to support that behavior.
                 * @since v22.14.0
                 * @experimental
                 * @param maybeRefable An object that may be "unref'd".
                 */
                unref(maybeRefable: any): void;
                /**
                 * Replaces the current process with a new process.
                 *
                 * This is achieved by using the `execve` POSIX function and therefore no memory or other
                 * resources from the current process are preserved, except for the standard input,
                 * standard output and standard error file descriptor.
                 *
                 * All other resources are discarded by the system when the processes are swapped, without triggering
                 * any exit or close events and without running any cleanup handler.
                 *
                 * This function will never return, unless an error occurred.
                 *
                 * This function is not available on Windows or IBM i.
                 * @since v22.15.0
                 * @experimental
                 * @param file The name or path of the executable file to run.
                 * @param args List of string arguments. No argument can contain a null-byte (`\u0000`).
                 * @param env Environment key-value pairs.
                 * No key or value can contain a null-byte (`\u0000`).
                 * **Default:** `process.env`.
                 */
                execve?(file: string, args?: readonly string[], env?: ProcessEnv): never;
                /* EventEmitter */
                addListener(event: "beforeExit", listener: BeforeExitListener): this;
                addListener(event: "disconnect", listener: DisconnectListener): this;
                addListener(event: "exit", listener: ExitListener): this;
                addListener(event: "rejectionHandled", listener: RejectionHandledListener): this;
                addListener(event: "uncaughtException", listener: UncaughtExceptionListener): this;
                addListener(event: "uncaughtExceptionMonitor", listener: UncaughtExceptionListener): this;
                addListener(event: "unhandledRejection", listener: UnhandledRejectionListener): this;
                addListener(event: "warning", listener: WarningListener): this;
                addListener(event: "message", listener: MessageListener): this;
                addListener(event: Signals, listener: SignalsListener): this;
                addListener(event: "multipleResolves", listener: MultipleResolveListener): this;
                addListener(event: "worker", listener: WorkerListener): this;
                emit(event: "beforeExit", code: number): boolean;
                emit(event: "disconnect"): boolean;
                emit(event: "exit", code: number): boolean;
                emit(event: "rejectionHandled", promise: Promise<unknown>): boolean;
                emit(event: "uncaughtException", error: Error): boolean;
                emit(event: "uncaughtExceptionMonitor", error: Error): boolean;
                emit(event: "unhandledRejection", reason: unknown, promise: Promise<unknown>): boolean;
                emit(event: "warning", warning: Error): boolean;
                emit(event: "message", message: unknown, sendHandle: unknown): this;
                emit(event: Signals, signal?: Signals): boolean;
                emit(
                    event: "multipleResolves",
                    type: MultipleResolveType,
                    promise: Promise<unknown>,
                    value: unknown,
                ): this;
                emit(event: "worker", listener: WorkerListener): this;
                on(event: "beforeExit", listener: BeforeExitListener): this;
                on(event: "disconnect", listener: DisconnectListener): this;
                on(event: "exit", listener: ExitListener): this;
                on(event: "rejectionHandled", listener: RejectionHandledListener): this;
                on(event: "uncaughtException", listener: UncaughtExceptionListener): this;
                on(event: "uncaughtExceptionMonitor", listener: UncaughtExceptionListener): this;
                on(event: "unhandledRejection", listener: UnhandledRejectionListener): this;
                on(event: "warning", listener: WarningListener): this;
                on(event: "message", listener: MessageListener): this;
                on(event: Signals, listener: SignalsListener): this;
                on(event: "multipleResolves", listener: MultipleResolveListener): this;
                on(event: "worker", listener: WorkerListener): this;
                on(event: string | symbol, listener: (...args: any[]) => void): this;
                once(event: "beforeExit", listener: BeforeExitListener): this;
                once(event: "disconnect", listener: DisconnectListener): this;
                once(event: "exit", listener: ExitListener): this;
                once(event: "rejectionHandled", listener: RejectionHandledListener): this;
                once(event: "uncaughtException", listener: UncaughtExceptionListener): this;
                once(event: "uncaughtExceptionMonitor", listener: UncaughtExceptionListener): this;
                once(event: "unhandledRejection", listener: UnhandledRejectionListener): this;
                once(event: "warning", listener: WarningListener): this;
                once(event: "message", listener: MessageListener): this;
                once(event: Signals, listener: SignalsListener): this;
                once(event: "multipleResolves", listener: MultipleResolveListener): this;
                once(event: "worker", listener: WorkerListener): this;
                once(event: string | symbol, listener: (...args: any[]) => void): this;
                prependListener(event: "beforeExit", listener: BeforeExitListener): this;
                prependListener(event: "disconnect", listener: DisconnectListener): this;
                prependListener(event: "exit", listener: ExitListener): this;
                prependListener(event: "rejectionHandled", listener: RejectionHandledListener): this;
                prependListener(event: "uncaughtException", listener: UncaughtExceptionListener): this;
                prependListener(event: "uncaughtExceptionMonitor", listener: UncaughtExceptionListener): this;
                prependListener(event: "unhandledRejection", listener: UnhandledRejectionListener): this;
                prependListener(event: "warning", listener: WarningListener): this;
                prependListener(event: "message", listener: MessageListener): this;
                prependListener(event: Signals, listener: SignalsListener): this;
                prependListener(event: "multipleResolves", listener: MultipleResolveListener): this;
                prependListener(event: "worker", listener: WorkerListener): this;
                prependOnceListener(event: "beforeExit", listener: BeforeExitListener): this;
                prependOnceListener(event: "disconnect", listener: DisconnectListener): this;
                prependOnceListener(event: "exit", listener: ExitListener): this;
                prependOnceListener(event: "rejectionHandled", listener: RejectionHandledListener): this;
                prependOnceListener(event: "uncaughtException", listener: UncaughtExceptionListener): this;
                prependOnceListener(event: "uncaughtExceptionMonitor", listener: UncaughtExceptionListener): this;
                prependOnceListener(event: "unhandledRejection", listener: UnhandledRejectionListener): this;
                prependOnceListener(event: "warning", listener: WarningListener): this;
                prependOnceListener(event: "message", listener: MessageListener): this;
                prependOnceListener(event: Signals, listener: SignalsListener): this;
                prependOnceListener(event: "multipleResolves", listener: MultipleResolveListener): this;
                prependOnceListener(event: "worker", listener: WorkerListener): this;
                listeners(event: "beforeExit"): BeforeExitListener[];
                listeners(event: "disconnect"): DisconnectListener[];
                listeners(event: "exit"): ExitListener[];
                listeners(event: "rejectionHandled"): RejectionHandledListener[];
                listeners(event: "uncaughtException"): UncaughtExceptionListener[];
                listeners(event: "uncaughtExceptionMonitor"): UncaughtExceptionListener[];
                listeners(event: "unhandledRejection"): UnhandledRejectionListener[];
                listeners(event: "warning"): WarningListener[];
                listeners(event: "message"): MessageListener[];
                listeners(event: Signals): SignalsListener[];
                listeners(event: "multipleResolves"): MultipleResolveListener[];
                listeners(event: "worker"): WorkerListener[];
            }
        }
    }
    export = process;
}
declare module "node:process" {
    import process = require("process");
    export = process;
}

```

## ./lib/lambda/node_modules/@types/node/punycode.d.ts

```typescript
/**
 * **The version of the punycode module bundled in Node.js is being deprecated. **In a future major version of Node.js this module will be removed. Users
 * currently depending on the `punycode` module should switch to using the
 * userland-provided [Punycode.js](https://github.com/bestiejs/punycode.js) module instead. For punycode-based URL
 * encoding, see `url.domainToASCII` or, more generally, the `WHATWG URL API`.
 *
 * The `punycode` module is a bundled version of the [Punycode.js](https://github.com/bestiejs/punycode.js) module. It
 * can be accessed using:
 *
 * ```js
 * import punycode from 'node:punycode';
 * ```
 *
 * [Punycode](https://tools.ietf.org/html/rfc3492) is a character encoding scheme defined by RFC 3492 that is
 * primarily intended for use in Internationalized Domain Names. Because host
 * names in URLs are limited to ASCII characters only, Domain Names that contain
 * non-ASCII characters must be converted into ASCII using the Punycode scheme.
 * For instance, the Japanese character that translates into the English word, `'example'` is `''`. The Internationalized Domain Name, `'.com'` (equivalent
 * to `'example.com'`) is represented by Punycode as the ASCII string `'xn--fsq.com'`.
 *
 * The `punycode` module provides a simple implementation of the Punycode standard.
 *
 * The `punycode` module is a third-party dependency used by Node.js and
 * made available to developers as a convenience. Fixes or other modifications to
 * the module must be directed to the [Punycode.js](https://github.com/bestiejs/punycode.js) project.
 * @deprecated Since v7.0.0 - Deprecated
 * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/punycode.js)
 */
declare module "punycode" {
    /**
     * The `punycode.decode()` method converts a [Punycode](https://tools.ietf.org/html/rfc3492) string of ASCII-only
     * characters to the equivalent string of Unicode codepoints.
     *
     * ```js
     * punycode.decode('maana-pta'); // 'maana'
     * punycode.decode('--dqo34k'); // '-'
     * ```
     * @since v0.5.1
     */
    function decode(string: string): string;
    /**
     * The `punycode.encode()` method converts a string of Unicode codepoints to a [Punycode](https://tools.ietf.org/html/rfc3492) string of ASCII-only characters.
     *
     * ```js
     * punycode.encode('maana'); // 'maana-pta'
     * punycode.encode('-'); // '--dqo34k'
     * ```
     * @since v0.5.1
     */
    function encode(string: string): string;
    /**
     * The `punycode.toUnicode()` method converts a string representing a domain name
     * containing [Punycode](https://tools.ietf.org/html/rfc3492) encoded characters into Unicode. Only the [Punycode](https://tools.ietf.org/html/rfc3492) encoded parts of the domain name are be
     * converted.
     *
     * ```js
     * // decode domain names
     * punycode.toUnicode('xn--maana-pta.com'); // 'maana.com'
     * punycode.toUnicode('xn----dqo34k.com');  // '-.com'
     * punycode.toUnicode('example.com');       // 'example.com'
     * ```
     * @since v0.6.1
     */
    function toUnicode(domain: string): string;
    /**
     * The `punycode.toASCII()` method converts a Unicode string representing an
     * Internationalized Domain Name to [Punycode](https://tools.ietf.org/html/rfc3492). Only the non-ASCII parts of the
     * domain name will be converted. Calling `punycode.toASCII()` on a string that
     * already only contains ASCII characters will have no effect.
     *
     * ```js
     * // encode domain names
     * punycode.toASCII('maana.com');  // 'xn--maana-pta.com'
     * punycode.toASCII('-.com');   // 'xn----dqo34k.com'
     * punycode.toASCII('example.com'); // 'example.com'
     * ```
     * @since v0.6.1
     */
    function toASCII(domain: string): string;
    /**
     * @deprecated since v7.0.0
     * The version of the punycode module bundled in Node.js is being deprecated.
     * In a future major version of Node.js this module will be removed.
     * Users currently depending on the punycode module should switch to using
     * the userland-provided Punycode.js module instead.
     */
    const ucs2: ucs2;
    interface ucs2 {
        /**
         * @deprecated since v7.0.0
         * The version of the punycode module bundled in Node.js is being deprecated.
         * In a future major version of Node.js this module will be removed.
         * Users currently depending on the punycode module should switch to using
         * the userland-provided Punycode.js module instead.
         */
        decode(string: string): number[];
        /**
         * @deprecated since v7.0.0
         * The version of the punycode module bundled in Node.js is being deprecated.
         * In a future major version of Node.js this module will be removed.
         * Users currently depending on the punycode module should switch to using
         * the userland-provided Punycode.js module instead.
         */
        encode(codePoints: readonly number[]): string;
    }
    /**
     * @deprecated since v7.0.0
     * The version of the punycode module bundled in Node.js is being deprecated.
     * In a future major version of Node.js this module will be removed.
     * Users currently depending on the punycode module should switch to using
     * the userland-provided Punycode.js module instead.
     */
    const version: string;
}
declare module "node:punycode" {
    export * from "punycode";
}

```

## ./lib/lambda/node_modules/@types/node/querystring.d.ts

```typescript
/**
 * The `node:querystring` module provides utilities for parsing and formatting URL
 * query strings. It can be accessed using:
 *
 * ```js
 * import querystring from 'node:querystring';
 * ```
 *
 * `querystring` is more performant than `URLSearchParams` but is not a
 * standardized API. Use `URLSearchParams` when performance is not critical or
 * when compatibility with browser code is desirable.
 * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/querystring.js)
 */
declare module "querystring" {
    interface StringifyOptions {
        /**
         * The function to use when converting URL-unsafe characters to percent-encoding in the query string.
         * @default `querystring.escape()`
         */
        encodeURIComponent?: ((str: string) => string) | undefined;
    }
    interface ParseOptions {
        /**
         * Specifies the maximum number of keys to parse. Specify `0` to remove key counting limitations.
         * @default 1000
         */
        maxKeys?: number | undefined;
        /**
         * The function to use when decoding percent-encoded characters in the query string.
         * @default `querystring.unescape()`
         */
        decodeURIComponent?: ((str: string) => string) | undefined;
    }
    interface ParsedUrlQuery extends NodeJS.Dict<string | string[]> {}
    interface ParsedUrlQueryInput extends
        NodeJS.Dict<
            | string
            | number
            | boolean
            | bigint
            | ReadonlyArray<string | number | boolean | bigint>
            | null
        >
    {}
    /**
     * The `querystring.stringify()` method produces a URL query string from a
     * given `obj` by iterating through the object's "own properties".
     *
     * It serializes the following types of values passed in `obj`: [string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) |
     * [number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) |
     * [bigint](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt) |
     * [boolean](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) |
     * [string\[\]](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) |
     * [number\[\]](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) |
     * [bigint\[\]](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt) |
     * [boolean\[\]](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) The numeric values must be finite. Any other input values will be coerced to
     * empty strings.
     *
     * ```js
     * querystring.stringify({ foo: 'bar', baz: ['qux', 'quux'], corge: '' });
     * // Returns 'foo=bar&#x26;baz=qux&#x26;baz=quux&#x26;corge='
     *
     * querystring.stringify({ foo: 'bar', baz: 'qux' }, ';', ':');
     * // Returns 'foo:bar;baz:qux'
     * ```
     *
     * By default, characters requiring percent-encoding within the query string will
     * be encoded as UTF-8\. If an alternative encoding is required, then an alternative `encodeURIComponent` option will need to be specified:
     *
     * ```js
     * // Assuming gbkEncodeURIComponent function already exists,
     *
     * querystring.stringify({ w: '', foo: 'bar' }, null, null,
     *                       { encodeURIComponent: gbkEncodeURIComponent });
     * ```
     * @since v0.1.25
     * @param obj The object to serialize into a URL query string
     * @param [sep='&'] The substring used to delimit key and value pairs in the query string.
     * @param [eq='='] . The substring used to delimit keys and values in the query string.
     */
    function stringify(obj?: ParsedUrlQueryInput, sep?: string, eq?: string, options?: StringifyOptions): string;
    /**
     * The `querystring.parse()` method parses a URL query string (`str`) into a
     * collection of key and value pairs.
     *
     * For example, the query string `'foo=bar&#x26;abc=xyz&#x26;abc=123'` is parsed into:
     *
     * ```json
     * {
     *   "foo": "bar",
     *   "abc": ["xyz", "123"]
     * }
     * ```
     *
     * The object returned by the `querystring.parse()` method _does not_ prototypically inherit from the JavaScript `Object`. This means that typical `Object` methods such as `obj.toString()`,
     * `obj.hasOwnProperty()`, and others
     * are not defined and _will not work_.
     *
     * By default, percent-encoded characters within the query string will be assumed
     * to use UTF-8 encoding. If an alternative character encoding is used, then an
     * alternative `decodeURIComponent` option will need to be specified:
     *
     * ```js
     * // Assuming gbkDecodeURIComponent function already exists...
     *
     * querystring.parse('w=%D6%D0%CE%C4&#x26;foo=bar', null, null,
     *                   { decodeURIComponent: gbkDecodeURIComponent });
     * ```
     * @since v0.1.25
     * @param str The URL query string to parse
     * @param [sep='&'] The substring used to delimit key and value pairs in the query string.
     * @param [eq='='] The substring used to delimit keys and values in the query string.
     */
    function parse(str: string, sep?: string, eq?: string, options?: ParseOptions): ParsedUrlQuery;
    /**
     * The querystring.encode() function is an alias for querystring.stringify().
     */
    const encode: typeof stringify;
    /**
     * The querystring.decode() function is an alias for querystring.parse().
     */
    const decode: typeof parse;
    /**
     * The `querystring.escape()` method performs URL percent-encoding on the given `str` in a manner that is optimized for the specific requirements of URL
     * query strings.
     *
     * The `querystring.escape()` method is used by `querystring.stringify()` and is
     * generally not expected to be used directly. It is exported primarily to allow
     * application code to provide a replacement percent-encoding implementation if
     * necessary by assigning `querystring.escape` to an alternative function.
     * @since v0.1.25
     */
    function escape(str: string): string;
    /**
     * The `querystring.unescape()` method performs decoding of URL percent-encoded
     * characters on the given `str`.
     *
     * The `querystring.unescape()` method is used by `querystring.parse()` and is
     * generally not expected to be used directly. It is exported primarily to allow
     * application code to provide a replacement decoding implementation if
     * necessary by assigning `querystring.unescape` to an alternative function.
     *
     * By default, the `querystring.unescape()` method will attempt to use the
     * JavaScript built-in `decodeURIComponent()` method to decode. If that fails,
     * a safer equivalent that does not throw on malformed URLs will be used.
     * @since v0.1.25
     */
    function unescape(str: string): string;
}
declare module "node:querystring" {
    export * from "querystring";
}

```

## ./lib/lambda/node_modules/@types/node/readline.d.ts

```typescript
/**
 * The `node:readline` module provides an interface for reading data from a [Readable](https://nodejs.org/docs/latest-v22.x/api/stream.html#readable-streams) stream
 * (such as [`process.stdin`](https://nodejs.org/docs/latest-v22.x/api/process.html#processstdin)) one line at a time.
 *
 * To use the promise-based APIs:
 *
 * ```js
 * import * as readline from 'node:readline/promises';
 * ```
 *
 * To use the callback and sync APIs:
 *
 * ```js
 * import * as readline from 'node:readline';
 * ```
 *
 * The following simple example illustrates the basic use of the `node:readline` module.
 *
 * ```js
 * import * as readline from 'node:readline/promises';
 * import { stdin as input, stdout as output } from 'node:process';
 *
 * const rl = readline.createInterface({ input, output });
 *
 * const answer = await rl.question('What do you think of Node.js? ');
 *
 * console.log(`Thank you for your valuable feedback: ${answer}`);
 *
 * rl.close();
 * ```
 *
 * Once this code is invoked, the Node.js application will not terminate until the `readline.Interface` is closed because the interface waits for data to be
 * received on the `input` stream.
 * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/readline.js)
 */
declare module "readline" {
    import { Abortable, EventEmitter } from "node:events";
    import * as promises from "node:readline/promises";
    export { promises };
    export interface Key {
        sequence?: string | undefined;
        name?: string | undefined;
        ctrl?: boolean | undefined;
        meta?: boolean | undefined;
        shift?: boolean | undefined;
    }
    /**
     * Instances of the `readline.Interface` class are constructed using the `readline.createInterface()` method. Every instance is associated with a
     * single `input` [Readable](https://nodejs.org/docs/latest-v22.x/api/stream.html#readable-streams) stream and a single `output` [Writable](https://nodejs.org/docs/latest-v22.x/api/stream.html#writable-streams) stream.
     * The `output` stream is used to print prompts for user input that arrives on,
     * and is read from, the `input` stream.
     * @since v0.1.104
     */
    export class Interface extends EventEmitter implements Disposable {
        readonly terminal: boolean;
        /**
         * The current input data being processed by node.
         *
         * This can be used when collecting input from a TTY stream to retrieve the
         * current value that has been processed thus far, prior to the `line` event
         * being emitted. Once the `line` event has been emitted, this property will
         * be an empty string.
         *
         * Be aware that modifying the value during the instance runtime may have
         * unintended consequences if `rl.cursor` is not also controlled.
         *
         * **If not using a TTY stream for input, use the `'line'` event.**
         *
         * One possible use case would be as follows:
         *
         * ```js
         * const values = ['lorem ipsum', 'dolor sit amet'];
         * const rl = readline.createInterface(process.stdin);
         * const showResults = debounce(() => {
         *   console.log(
         *     '\n',
         *     values.filter((val) => val.startsWith(rl.line)).join(' '),
         *   );
         * }, 300);
         * process.stdin.on('keypress', (c, k) => {
         *   showResults();
         * });
         * ```
         * @since v0.1.98
         */
        readonly line: string;
        /**
         * The cursor position relative to `rl.line`.
         *
         * This will track where the current cursor lands in the input string, when
         * reading input from a TTY stream. The position of cursor determines the
         * portion of the input string that will be modified as input is processed,
         * as well as the column where the terminal caret will be rendered.
         * @since v0.1.98
         */
        readonly cursor: number;
        /**
         * NOTE: According to the documentation:
         *
         * > Instances of the `readline.Interface` class are constructed using the
         * > `readline.createInterface()` method.
         *
         * @see https://nodejs.org/dist/latest-v22.x/docs/api/readline.html#class-interfaceconstructor
         */
        protected constructor(
            input: NodeJS.ReadableStream,
            output?: NodeJS.WritableStream,
            completer?: Completer | AsyncCompleter,
            terminal?: boolean,
        );
        /**
         * NOTE: According to the documentation:
         *
         * > Instances of the `readline.Interface` class are constructed using the
         * > `readline.createInterface()` method.
         *
         * @see https://nodejs.org/dist/latest-v22.x/docs/api/readline.html#class-interfaceconstructor
         */
        protected constructor(options: ReadLineOptions);
        /**
         * The `rl.getPrompt()` method returns the current prompt used by `rl.prompt()`.
         * @since v15.3.0, v14.17.0
         * @return the current prompt string
         */
        getPrompt(): string;
        /**
         * The `rl.setPrompt()` method sets the prompt that will be written to `output` whenever `rl.prompt()` is called.
         * @since v0.1.98
         */
        setPrompt(prompt: string): void;
        /**
         * The `rl.prompt()` method writes the `Interface` instances configured`prompt` to a new line in `output` in order to provide a user with a new
         * location at which to provide input.
         *
         * When called, `rl.prompt()` will resume the `input` stream if it has been
         * paused.
         *
         * If the `Interface` was created with `output` set to `null` or `undefined` the prompt is not written.
         * @since v0.1.98
         * @param preserveCursor If `true`, prevents the cursor placement from being reset to `0`.
         */
        prompt(preserveCursor?: boolean): void;
        /**
         * The `rl.question()` method displays the `query` by writing it to the `output`,
         * waits for user input to be provided on `input`, then invokes the `callback` function passing the provided input as the first argument.
         *
         * When called, `rl.question()` will resume the `input` stream if it has been
         * paused.
         *
         * If the `Interface` was created with `output` set to `null` or `undefined` the `query` is not written.
         *
         * The `callback` function passed to `rl.question()` does not follow the typical
         * pattern of accepting an `Error` object or `null` as the first argument.
         * The `callback` is called with the provided answer as the only argument.
         *
         * An error will be thrown if calling `rl.question()` after `rl.close()`.
         *
         * Example usage:
         *
         * ```js
         * rl.question('What is your favorite food? ', (answer) => {
         *   console.log(`Oh, so your favorite food is ${answer}`);
         * });
         * ```
         *
         * Using an `AbortController` to cancel a question.
         *
         * ```js
         * const ac = new AbortController();
         * const signal = ac.signal;
         *
         * rl.question('What is your favorite food? ', { signal }, (answer) => {
         *   console.log(`Oh, so your favorite food is ${answer}`);
         * });
         *
         * signal.addEventListener('abort', () => {
         *   console.log('The food question timed out');
         * }, { once: true });
         *
         * setTimeout(() => ac.abort(), 10000);
         * ```
         * @since v0.3.3
         * @param query A statement or query to write to `output`, prepended to the prompt.
         * @param callback A callback function that is invoked with the user's input in response to the `query`.
         */
        question(query: string, callback: (answer: string) => void): void;
        question(query: string, options: Abortable, callback: (answer: string) => void): void;
        /**
         * The `rl.pause()` method pauses the `input` stream, allowing it to be resumed
         * later if necessary.
         *
         * Calling `rl.pause()` does not immediately pause other events (including `'line'`) from being emitted by the `Interface` instance.
         * @since v0.3.4
         */
        pause(): this;
        /**
         * The `rl.resume()` method resumes the `input` stream if it has been paused.
         * @since v0.3.4
         */
        resume(): this;
        /**
         * The `rl.close()` method closes the `Interface` instance and
         * relinquishes control over the `input` and `output` streams. When called,
         * the `'close'` event will be emitted.
         *
         * Calling `rl.close()` does not immediately stop other events (including `'line'`)
         * from being emitted by the `Interface` instance.
         * @since v0.1.98
         */
        close(): void;
        /**
         * Alias for `rl.close()`.
         * @since v22.15.0
         */
        [Symbol.dispose](): void;
        /**
         * The `rl.write()` method will write either `data` or a key sequence identified
         * by `key` to the `output`. The `key` argument is supported only if `output` is
         * a `TTY` text terminal. See `TTY keybindings` for a list of key
         * combinations.
         *
         * If `key` is specified, `data` is ignored.
         *
         * When called, `rl.write()` will resume the `input` stream if it has been
         * paused.
         *
         * If the `Interface` was created with `output` set to `null` or `undefined` the `data` and `key` are not written.
         *
         * ```js
         * rl.write('Delete this!');
         * // Simulate Ctrl+U to delete the line written previously
         * rl.write(null, { ctrl: true, name: 'u' });
         * ```
         *
         * The `rl.write()` method will write the data to the `readline` `Interface`'s `input` _as if it were provided by the user_.
         * @since v0.1.98
         */
        write(data: string | Buffer, key?: Key): void;
        write(data: undefined | null | string | Buffer, key: Key): void;
        /**
         * Returns the real position of the cursor in relation to the input
         * prompt + string. Long input (wrapping) strings, as well as multiple
         * line prompts are included in the calculations.
         * @since v13.5.0, v12.16.0
         */
        getCursorPos(): CursorPos;
        /**
         * events.EventEmitter
         * 1. close
         * 2. line
         * 3. pause
         * 4. resume
         * 5. SIGCONT
         * 6. SIGINT
         * 7. SIGTSTP
         * 8. history
         */
        addListener(event: string, listener: (...args: any[]) => void): this;
        addListener(event: "close", listener: () => void): this;
        addListener(event: "line", listener: (input: string) => void): this;
        addListener(event: "pause", listener: () => void): this;
        addListener(event: "resume", listener: () => void): this;
        addListener(event: "SIGCONT", listener: () => void): this;
        addListener(event: "SIGINT", listener: () => void): this;
        addListener(event: "SIGTSTP", listener: () => void): this;
        addListener(event: "history", listener: (history: string[]) => void): this;
        emit(event: string | symbol, ...args: any[]): boolean;
        emit(event: "close"): boolean;
        emit(event: "line", input: string): boolean;
        emit(event: "pause"): boolean;
        emit(event: "resume"): boolean;
        emit(event: "SIGCONT"): boolean;
        emit(event: "SIGINT"): boolean;
        emit(event: "SIGTSTP"): boolean;
        emit(event: "history", history: string[]): boolean;
        on(event: string, listener: (...args: any[]) => void): this;
        on(event: "close", listener: () => void): this;
        on(event: "line", listener: (input: string) => void): this;
        on(event: "pause", listener: () => void): this;
        on(event: "resume", listener: () => void): this;
        on(event: "SIGCONT", listener: () => void): this;
        on(event: "SIGINT", listener: () => void): this;
        on(event: "SIGTSTP", listener: () => void): this;
        on(event: "history", listener: (history: string[]) => void): this;
        once(event: string, listener: (...args: any[]) => void): this;
        once(event: "close", listener: () => void): this;
        once(event: "line", listener: (input: string) => void): this;
        once(event: "pause", listener: () => void): this;
        once(event: "resume", listener: () => void): this;
        once(event: "SIGCONT", listener: () => void): this;
        once(event: "SIGINT", listener: () => void): this;
        once(event: "SIGTSTP", listener: () => void): this;
        once(event: "history", listener: (history: string[]) => void): this;
        prependListener(event: string, listener: (...args: any[]) => void): this;
        prependListener(event: "close", listener: () => void): this;
        prependListener(event: "line", listener: (input: string) => void): this;
        prependListener(event: "pause", listener: () => void): this;
        prependListener(event: "resume", listener: () => void): this;
        prependListener(event: "SIGCONT", listener: () => void): this;
        prependListener(event: "SIGINT", listener: () => void): this;
        prependListener(event: "SIGTSTP", listener: () => void): this;
        prependListener(event: "history", listener: (history: string[]) => void): this;
        prependOnceListener(event: string, listener: (...args: any[]) => void): this;
        prependOnceListener(event: "close", listener: () => void): this;
        prependOnceListener(event: "line", listener: (input: string) => void): this;
        prependOnceListener(event: "pause", listener: () => void): this;
        prependOnceListener(event: "resume", listener: () => void): this;
        prependOnceListener(event: "SIGCONT", listener: () => void): this;
        prependOnceListener(event: "SIGINT", listener: () => void): this;
        prependOnceListener(event: "SIGTSTP", listener: () => void): this;
        prependOnceListener(event: "history", listener: (history: string[]) => void): this;
        [Symbol.asyncIterator](): NodeJS.AsyncIterator<string>;
    }
    export type ReadLine = Interface; // type forwarded for backwards compatibility
    export type Completer = (line: string) => CompleterResult;
    export type AsyncCompleter = (
        line: string,
        callback: (err?: null | Error, result?: CompleterResult) => void,
    ) => void;
    export type CompleterResult = [string[], string];
    export interface ReadLineOptions {
        /**
         * The [`Readable`](https://nodejs.org/docs/latest-v22.x/api/stream.html#readable-streams) stream to listen to
         */
        input: NodeJS.ReadableStream;
        /**
         * The [`Writable`](https://nodejs.org/docs/latest-v22.x/api/stream.html#writable-streams) stream to write readline data to.
         */
        output?: NodeJS.WritableStream | undefined;
        /**
         * An optional function used for Tab autocompletion.
         */
        completer?: Completer | AsyncCompleter | undefined;
        /**
         * `true` if the `input` and `output` streams should be treated like a TTY,
         * and have ANSI/VT100 escape codes written to it.
         * Default: checking `isTTY` on the `output` stream upon instantiation.
         */
        terminal?: boolean | undefined;
        /**
         * Initial list of history lines.
         * This option makes sense only if `terminal` is set to `true` by the user or by an internal `output` check,
         * otherwise the history caching mechanism is not initialized at all.
         * @default []
         */
        history?: string[] | undefined;
        /**
         * Maximum number of history lines retained.
         * To disable the history set this value to `0`.
         * This option makes sense only if `terminal` is set to `true` by the user or by an internal `output` check,
         * otherwise the history caching mechanism is not initialized at all.
         * @default 30
         */
        historySize?: number | undefined;
        /**
         * If `true`, when a new input line added to the history list duplicates an older one,
         * this removes the older line from the list.
         * @default false
         */
        removeHistoryDuplicates?: boolean | undefined;
        /**
         * The prompt string to use.
         * @default "> "
         */
        prompt?: string | undefined;
        /**
         * If the delay between `\r` and `\n` exceeds `crlfDelay` milliseconds,
         * both `\r` and `\n` will be treated as separate end-of-line input.
         * `crlfDelay` will be coerced to a number no less than `100`.
         * It can be set to `Infinity`, in which case
         * `\r` followed by `\n` will always be considered a single newline
         * (which may be reasonable for [reading files](https://nodejs.org/docs/latest-v22.x/api/readline.html#example-read-file-stream-line-by-line) with `\r\n` line delimiter).
         * @default 100
         */
        crlfDelay?: number | undefined;
        /**
         * The duration `readline` will wait for a character
         * (when reading an ambiguous key sequence in milliseconds
         * one that can both form a complete key sequence using the input read so far
         * and can take additional input to complete a longer key sequence).
         * @default 500
         */
        escapeCodeTimeout?: number | undefined;
        /**
         * The number of spaces a tab is equal to (minimum 1).
         * @default 8
         */
        tabSize?: number | undefined;
        /**
         * Allows closing the interface using an AbortSignal.
         * Aborting the signal will internally call `close` on the interface.
         */
        signal?: AbortSignal | undefined;
    }
    /**
     * The `readline.createInterface()` method creates a new `readline.Interface` instance.
     *
     * ```js
     * import readline from 'node:readline';
     * const rl = readline.createInterface({
     *   input: process.stdin,
     *   output: process.stdout,
     * });
     * ```
     *
     * Once the `readline.Interface` instance is created, the most common case is to
     * listen for the `'line'` event:
     *
     * ```js
     * rl.on('line', (line) => {
     *   console.log(`Received: ${line}`);
     * });
     * ```
     *
     * If `terminal` is `true` for this instance then the `output` stream will get
     * the best compatibility if it defines an `output.columns` property and emits
     * a `'resize'` event on the `output` if or when the columns ever change
     * (`process.stdout` does this automatically when it is a TTY).
     *
     * When creating a `readline.Interface` using `stdin` as input, the program
     * will not terminate until it receives an [EOF character](https://en.wikipedia.org/wiki/End-of-file#EOF_character). To exit without
     * waiting for user input, call `process.stdin.unref()`.
     * @since v0.1.98
     */
    export function createInterface(
        input: NodeJS.ReadableStream,
        output?: NodeJS.WritableStream,
        completer?: Completer | AsyncCompleter,
        terminal?: boolean,
    ): Interface;
    export function createInterface(options: ReadLineOptions): Interface;
    /**
     * The `readline.emitKeypressEvents()` method causes the given `Readable` stream to begin emitting `'keypress'` events corresponding to received input.
     *
     * Optionally, `interface` specifies a `readline.Interface` instance for which
     * autocompletion is disabled when copy-pasted input is detected.
     *
     * If the `stream` is a `TTY`, then it must be in raw mode.
     *
     * This is automatically called by any readline instance on its `input` if the `input` is a terminal. Closing the `readline` instance does not stop
     * the `input` from emitting `'keypress'` events.
     *
     * ```js
     * readline.emitKeypressEvents(process.stdin);
     * if (process.stdin.isTTY)
     *   process.stdin.setRawMode(true);
     * ```
     *
     * ## Example: Tiny CLI
     *
     * The following example illustrates the use of `readline.Interface` class to
     * implement a small command-line interface:
     *
     * ```js
     * import readline from 'node:readline';
     * const rl = readline.createInterface({
     *   input: process.stdin,
     *   output: process.stdout,
     *   prompt: 'OHAI> ',
     * });
     *
     * rl.prompt();
     *
     * rl.on('line', (line) => {
     *   switch (line.trim()) {
     *     case 'hello':
     *       console.log('world!');
     *       break;
     *     default:
     *       console.log(`Say what? I might have heard '${line.trim()}'`);
     *       break;
     *   }
     *   rl.prompt();
     * }).on('close', () => {
     *   console.log('Have a great day!');
     *   process.exit(0);
     * });
     * ```
     *
     * ## Example: Read file stream line-by-Line
     *
     * A common use case for `readline` is to consume an input file one line at a
     * time. The easiest way to do so is leveraging the `fs.ReadStream` API as
     * well as a `for await...of` loop:
     *
     * ```js
     * import fs from 'node:fs';
     * import readline from 'node:readline';
     *
     * async function processLineByLine() {
     *   const fileStream = fs.createReadStream('input.txt');
     *
     *   const rl = readline.createInterface({
     *     input: fileStream,
     *     crlfDelay: Infinity,
     *   });
     *   // Note: we use the crlfDelay option to recognize all instances of CR LF
     *   // ('\r\n') in input.txt as a single line break.
     *
     *   for await (const line of rl) {
     *     // Each line in input.txt will be successively available here as `line`.
     *     console.log(`Line from file: ${line}`);
     *   }
     * }
     *
     * processLineByLine();
     * ```
     *
     * Alternatively, one could use the `'line'` event:
     *
     * ```js
     * import fs from 'node:fs';
     * import readline from 'node:readline';
     *
     * const rl = readline.createInterface({
     *   input: fs.createReadStream('sample.txt'),
     *   crlfDelay: Infinity,
     * });
     *
     * rl.on('line', (line) => {
     *   console.log(`Line from file: ${line}`);
     * });
     * ```
     *
     * Currently, `for await...of` loop can be a bit slower. If `async` / `await` flow and speed are both essential, a mixed approach can be applied:
     *
     * ```js
     * import { once } from 'node:events';
     * import { createReadStream } from 'node:fs';
     * import { createInterface } from 'node:readline';
     *
     * (async function processLineByLine() {
     *   try {
     *     const rl = createInterface({
     *       input: createReadStream('big-file.txt'),
     *       crlfDelay: Infinity,
     *     });
     *
     *     rl.on('line', (line) => {
     *       // Process the line.
     *     });
     *
     *     await once(rl, 'close');
     *
     *     console.log('File processed.');
     *   } catch (err) {
     *     console.error(err);
     *   }
     * })();
     * ```
     * @since v0.7.7
     */
    export function emitKeypressEvents(stream: NodeJS.ReadableStream, readlineInterface?: Interface): void;
    export type Direction = -1 | 0 | 1;
    export interface CursorPos {
        rows: number;
        cols: number;
    }
    /**
     * The `readline.clearLine()` method clears current line of given [TTY](https://nodejs.org/docs/latest-v22.x/api/tty.html) stream
     * in a specified direction identified by `dir`.
     * @since v0.7.7
     * @param callback Invoked once the operation completes.
     * @return `false` if `stream` wishes for the calling code to wait for the `'drain'` event to be emitted before continuing to write additional data; otherwise `true`.
     */
    export function clearLine(stream: NodeJS.WritableStream, dir: Direction, callback?: () => void): boolean;
    /**
     * The `readline.clearScreenDown()` method clears the given [TTY](https://nodejs.org/docs/latest-v22.x/api/tty.html) stream from
     * the current position of the cursor down.
     * @since v0.7.7
     * @param callback Invoked once the operation completes.
     * @return `false` if `stream` wishes for the calling code to wait for the `'drain'` event to be emitted before continuing to write additional data; otherwise `true`.
     */
    export function clearScreenDown(stream: NodeJS.WritableStream, callback?: () => void): boolean;
    /**
     * The `readline.cursorTo()` method moves cursor to the specified position in a
     * given [TTY](https://nodejs.org/docs/latest-v22.x/api/tty.html) `stream`.
     * @since v0.7.7
     * @param callback Invoked once the operation completes.
     * @return `false` if `stream` wishes for the calling code to wait for the `'drain'` event to be emitted before continuing to write additional data; otherwise `true`.
     */
    export function cursorTo(stream: NodeJS.WritableStream, x: number, y?: number, callback?: () => void): boolean;
    /**
     * The `readline.moveCursor()` method moves the cursor _relative_ to its current
     * position in a given [TTY](https://nodejs.org/docs/latest-v22.x/api/tty.html) `stream`.
     * @since v0.7.7
     * @param callback Invoked once the operation completes.
     * @return `false` if `stream` wishes for the calling code to wait for the `'drain'` event to be emitted before continuing to write additional data; otherwise `true`.
     */
    export function moveCursor(stream: NodeJS.WritableStream, dx: number, dy: number, callback?: () => void): boolean;
}
declare module "node:readline" {
    export * from "readline";
}

```

## ./lib/lambda/node_modules/@types/node/repl.d.ts

```typescript
/**
 * The `node:repl` module provides a Read-Eval-Print-Loop (REPL) implementation
 * that is available both as a standalone program or includible in other
 * applications. It can be accessed using:
 *
 * ```js
 * import repl from 'node:repl';
 * ```
 * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/repl.js)
 */
declare module "repl" {
    import { AsyncCompleter, Completer, Interface } from "node:readline";
    import { Context } from "node:vm";
    import { InspectOptions } from "node:util";
    interface ReplOptions {
        /**
         * The input prompt to display.
         * @default "> "
         */
        prompt?: string | undefined;
        /**
         * The `Readable` stream from which REPL input will be read.
         * @default process.stdin
         */
        input?: NodeJS.ReadableStream | undefined;
        /**
         * The `Writable` stream to which REPL output will be written.
         * @default process.stdout
         */
        output?: NodeJS.WritableStream | undefined;
        /**
         * If `true`, specifies that the output should be treated as a TTY terminal, and have
         * ANSI/VT100 escape codes written to it.
         * Default: checking the value of the `isTTY` property on the output stream upon
         * instantiation.
         */
        terminal?: boolean | undefined;
        /**
         * The function to be used when evaluating each given line of input.
         * **Default:** an async wrapper for the JavaScript `eval()` function. An `eval` function can
         * error with `repl.Recoverable` to indicate the input was incomplete and prompt for
         * additional lines. See the [custom evaluation functions](https://nodejs.org/dist/latest-v22.x/docs/api/repl.html#custom-evaluation-functions)
         * section for more details.
         */
        eval?: REPLEval | undefined;
        /**
         * Defines if the repl prints output previews or not.
         * @default `true` Always `false` in case `terminal` is falsy.
         */
        preview?: boolean | undefined;
        /**
         * If `true`, specifies that the default `writer` function should include ANSI color
         * styling to REPL output. If a custom `writer` function is provided then this has no
         * effect.
         * @default the REPL instance's `terminal` value
         */
        useColors?: boolean | undefined;
        /**
         * If `true`, specifies that the default evaluation function will use the JavaScript
         * `global` as the context as opposed to creating a new separate context for the REPL
         * instance. The node CLI REPL sets this value to `true`.
         * @default false
         */
        useGlobal?: boolean | undefined;
        /**
         * If `true`, specifies that the default writer will not output the return value of a
         * command if it evaluates to `undefined`.
         * @default false
         */
        ignoreUndefined?: boolean | undefined;
        /**
         * The function to invoke to format the output of each command before writing to `output`.
         * @default a wrapper for `util.inspect`
         *
         * @see https://nodejs.org/dist/latest-v22.x/docs/api/repl.html#repl_customizing_repl_output
         */
        writer?: REPLWriter | undefined;
        /**
         * An optional function used for custom Tab auto completion.
         *
         * @see https://nodejs.org/dist/latest-v22.x/docs/api/readline.html#readline_use_of_the_completer_function
         */
        completer?: Completer | AsyncCompleter | undefined;
        /**
         * A flag that specifies whether the default evaluator executes all JavaScript commands in
         * strict mode or default (sloppy) mode.
         * Accepted values are:
         * - `repl.REPL_MODE_SLOPPY` - evaluates expressions in sloppy mode.
         * - `repl.REPL_MODE_STRICT` - evaluates expressions in strict mode. This is equivalent to
         *   prefacing every repl statement with `'use strict'`.
         */
        replMode?: typeof REPL_MODE_SLOPPY | typeof REPL_MODE_STRICT | undefined;
        /**
         * Stop evaluating the current piece of code when `SIGINT` is received, i.e. `Ctrl+C` is
         * pressed. This cannot be used together with a custom `eval` function.
         * @default false
         */
        breakEvalOnSigint?: boolean | undefined;
    }
    type REPLEval = (
        this: REPLServer,
        evalCmd: string,
        context: Context,
        file: string,
        cb: (err: Error | null, result: any) => void,
    ) => void;
    type REPLWriter = (this: REPLServer, obj: any) => string;
    /**
     * This is the default "writer" value, if none is passed in the REPL options,
     * and it can be overridden by custom print functions.
     */
    const writer: REPLWriter & {
        options: InspectOptions;
    };
    type REPLCommandAction = (this: REPLServer, text: string) => void;
    interface REPLCommand {
        /**
         * Help text to be displayed when `.help` is entered.
         */
        help?: string | undefined;
        /**
         * The function to execute, optionally accepting a single string argument.
         */
        action: REPLCommandAction;
    }
    /**
     * Instances of `repl.REPLServer` are created using the {@link start} method
     * or directly using the JavaScript `new` keyword.
     *
     * ```js
     * import repl from 'node:repl';
     *
     * const options = { useColors: true };
     *
     * const firstInstance = repl.start(options);
     * const secondInstance = new repl.REPLServer(options);
     * ```
     * @since v0.1.91
     */
    class REPLServer extends Interface {
        /**
         * The `vm.Context` provided to the `eval` function to be used for JavaScript
         * evaluation.
         */
        readonly context: Context;
        /**
         * @deprecated since v14.3.0 - Use `input` instead.
         */
        readonly inputStream: NodeJS.ReadableStream;
        /**
         * @deprecated since v14.3.0 - Use `output` instead.
         */
        readonly outputStream: NodeJS.WritableStream;
        /**
         * The `Readable` stream from which REPL input will be read.
         */
        readonly input: NodeJS.ReadableStream;
        /**
         * The `Writable` stream to which REPL output will be written.
         */
        readonly output: NodeJS.WritableStream;
        /**
         * The commands registered via `replServer.defineCommand()`.
         */
        readonly commands: NodeJS.ReadOnlyDict<REPLCommand>;
        /**
         * A value indicating whether the REPL is currently in "editor mode".
         *
         * @see https://nodejs.org/dist/latest-v22.x/docs/api/repl.html#repl_commands_and_special_keys
         */
        readonly editorMode: boolean;
        /**
         * A value indicating whether the `_` variable has been assigned.
         *
         * @see https://nodejs.org/dist/latest-v22.x/docs/api/repl.html#repl_assignment_of_the_underscore_variable
         */
        readonly underscoreAssigned: boolean;
        /**
         * The last evaluation result from the REPL (assigned to the `_` variable inside of the REPL).
         *
         * @see https://nodejs.org/dist/latest-v22.x/docs/api/repl.html#repl_assignment_of_the_underscore_variable
         */
        readonly last: any;
        /**
         * A value indicating whether the `_error` variable has been assigned.
         *
         * @since v9.8.0
         * @see https://nodejs.org/dist/latest-v22.x/docs/api/repl.html#repl_assignment_of_the_underscore_variable
         */
        readonly underscoreErrAssigned: boolean;
        /**
         * The last error raised inside the REPL (assigned to the `_error` variable inside of the REPL).
         *
         * @since v9.8.0
         * @see https://nodejs.org/dist/latest-v22.x/docs/api/repl.html#repl_assignment_of_the_underscore_variable
         */
        readonly lastError: any;
        /**
         * Specified in the REPL options, this is the function to be used when evaluating each
         * given line of input. If not specified in the REPL options, this is an async wrapper
         * for the JavaScript `eval()` function.
         */
        readonly eval: REPLEval;
        /**
         * Specified in the REPL options, this is a value indicating whether the default
         * `writer` function should include ANSI color styling to REPL output.
         */
        readonly useColors: boolean;
        /**
         * Specified in the REPL options, this is a value indicating whether the default `eval`
         * function will use the JavaScript `global` as the context as opposed to creating a new
         * separate context for the REPL instance.
         */
        readonly useGlobal: boolean;
        /**
         * Specified in the REPL options, this is a value indicating whether the default `writer`
         * function should output the result of a command if it evaluates to `undefined`.
         */
        readonly ignoreUndefined: boolean;
        /**
         * Specified in the REPL options, this is the function to invoke to format the output of
         * each command before writing to `outputStream`. If not specified in the REPL options,
         * this will be a wrapper for `util.inspect`.
         */
        readonly writer: REPLWriter;
        /**
         * Specified in the REPL options, this is the function to use for custom Tab auto-completion.
         */
        readonly completer: Completer | AsyncCompleter;
        /**
         * Specified in the REPL options, this is a flag that specifies whether the default `eval`
         * function should execute all JavaScript commands in strict mode or default (sloppy) mode.
         * Possible values are:
         * - `repl.REPL_MODE_SLOPPY` - evaluates expressions in sloppy mode.
         * - `repl.REPL_MODE_STRICT` - evaluates expressions in strict mode. This is equivalent to
         *    prefacing every repl statement with `'use strict'`.
         */
        readonly replMode: typeof REPL_MODE_SLOPPY | typeof REPL_MODE_STRICT;
        /**
         * NOTE: According to the documentation:
         *
         * > Instances of `repl.REPLServer` are created using the `repl.start()` method and
         * > _should not_ be created directly using the JavaScript `new` keyword.
         *
         * `REPLServer` cannot be subclassed due to implementation specifics in NodeJS.
         *
         * @see https://nodejs.org/dist/latest-v22.x/docs/api/repl.html#repl_class_replserver
         */
        private constructor();
        /**
         * The `replServer.defineCommand()` method is used to add new `.`\-prefixed commands
         * to the REPL instance. Such commands are invoked by typing a `.` followed by the `keyword`. The `cmd` is either a `Function` or an `Object` with the following
         * properties:
         *
         * The following example shows two new commands added to the REPL instance:
         *
         * ```js
         * import repl from 'node:repl';
         *
         * const replServer = repl.start({ prompt: '> ' });
         * replServer.defineCommand('sayhello', {
         *   help: 'Say hello',
         *   action(name) {
         *     this.clearBufferedCommand();
         *     console.log(`Hello, ${name}!`);
         *     this.displayPrompt();
         *   },
         * });
         * replServer.defineCommand('saybye', function saybye() {
         *   console.log('Goodbye!');
         *   this.close();
         * });
         * ```
         *
         * The new commands can then be used from within the REPL instance:
         *
         * ```console
         * > .sayhello Node.js User
         * Hello, Node.js User!
         * > .saybye
         * Goodbye!
         * ```
         * @since v0.3.0
         * @param keyword The command keyword (_without_ a leading `.` character).
         * @param cmd The function to invoke when the command is processed.
         */
        defineCommand(keyword: string, cmd: REPLCommandAction | REPLCommand): void;
        /**
         * The `replServer.displayPrompt()` method readies the REPL instance for input
         * from the user, printing the configured `prompt` to a new line in the `output` and resuming the `input` to accept new input.
         *
         * When multi-line input is being entered, an ellipsis is printed rather than the
         * 'prompt'.
         *
         * When `preserveCursor` is `true`, the cursor placement will not be reset to `0`.
         *
         * The `replServer.displayPrompt` method is primarily intended to be called from
         * within the action function for commands registered using the `replServer.defineCommand()` method.
         * @since v0.1.91
         */
        displayPrompt(preserveCursor?: boolean): void;
        /**
         * The `replServer.clearBufferedCommand()` method clears any command that has been
         * buffered but not yet executed. This method is primarily intended to be
         * called from within the action function for commands registered using the `replServer.defineCommand()` method.
         * @since v9.0.0
         */
        clearBufferedCommand(): void;
        /**
         * Initializes a history log file for the REPL instance. When executing the
         * Node.js binary and using the command-line REPL, a history file is initialized
         * by default. However, this is not the case when creating a REPL
         * programmatically. Use this method to initialize a history log file when working
         * with REPL instances programmatically.
         * @since v11.10.0
         * @param historyPath the path to the history file
         * @param callback called when history writes are ready or upon error
         */
        setupHistory(path: string, callback: (err: Error | null, repl: this) => void): void;
        /**
         * events.EventEmitter
         * 1. close - inherited from `readline.Interface`
         * 2. line - inherited from `readline.Interface`
         * 3. pause - inherited from `readline.Interface`
         * 4. resume - inherited from `readline.Interface`
         * 5. SIGCONT - inherited from `readline.Interface`
         * 6. SIGINT - inherited from `readline.Interface`
         * 7. SIGTSTP - inherited from `readline.Interface`
         * 8. exit
         * 9. reset
         */
        addListener(event: string, listener: (...args: any[]) => void): this;
        addListener(event: "close", listener: () => void): this;
        addListener(event: "line", listener: (input: string) => void): this;
        addListener(event: "pause", listener: () => void): this;
        addListener(event: "resume", listener: () => void): this;
        addListener(event: "SIGCONT", listener: () => void): this;
        addListener(event: "SIGINT", listener: () => void): this;
        addListener(event: "SIGTSTP", listener: () => void): this;
        addListener(event: "exit", listener: () => void): this;
        addListener(event: "reset", listener: (context: Context) => void): this;
        emit(event: string | symbol, ...args: any[]): boolean;
        emit(event: "close"): boolean;
        emit(event: "line", input: string): boolean;
        emit(event: "pause"): boolean;
        emit(event: "resume"): boolean;
        emit(event: "SIGCONT"): boolean;
        emit(event: "SIGINT"): boolean;
        emit(event: "SIGTSTP"): boolean;
        emit(event: "exit"): boolean;
        emit(event: "reset", context: Context): boolean;
        on(event: string, listener: (...args: any[]) => void): this;
        on(event: "close", listener: () => void): this;
        on(event: "line", listener: (input: string) => void): this;
        on(event: "pause", listener: () => void): this;
        on(event: "resume", listener: () => void): this;
        on(event: "SIGCONT", listener: () => void): this;
        on(event: "SIGINT", listener: () => void): this;
        on(event: "SIGTSTP", listener: () => void): this;
        on(event: "exit", listener: () => void): this;
        on(event: "reset", listener: (context: Context) => void): this;
        once(event: string, listener: (...args: any[]) => void): this;
        once(event: "close", listener: () => void): this;
        once(event: "line", listener: (input: string) => void): this;
        once(event: "pause", listener: () => void): this;
        once(event: "resume", listener: () => void): this;
        once(event: "SIGCONT", listener: () => void): this;
        once(event: "SIGINT", listener: () => void): this;
        once(event: "SIGTSTP", listener: () => void): this;
        once(event: "exit", listener: () => void): this;
        once(event: "reset", listener: (context: Context) => void): this;
        prependListener(event: string, listener: (...args: any[]) => void): this;
        prependListener(event: "close", listener: () => void): this;
        prependListener(event: "line", listener: (input: string) => void): this;
        prependListener(event: "pause", listener: () => void): this;
        prependListener(event: "resume", listener: () => void): this;
        prependListener(event: "SIGCONT", listener: () => void): this;
        prependListener(event: "SIGINT", listener: () => void): this;
        prependListener(event: "SIGTSTP", listener: () => void): this;
        prependListener(event: "exit", listener: () => void): this;
        prependListener(event: "reset", listener: (context: Context) => void): this;
        prependOnceListener(event: string, listener: (...args: any[]) => void): this;
        prependOnceListener(event: "close", listener: () => void): this;
        prependOnceListener(event: "line", listener: (input: string) => void): this;
        prependOnceListener(event: "pause", listener: () => void): this;
        prependOnceListener(event: "resume", listener: () => void): this;
        prependOnceListener(event: "SIGCONT", listener: () => void): this;
        prependOnceListener(event: "SIGINT", listener: () => void): this;
        prependOnceListener(event: "SIGTSTP", listener: () => void): this;
        prependOnceListener(event: "exit", listener: () => void): this;
        prependOnceListener(event: "reset", listener: (context: Context) => void): this;
    }
    /**
     * A flag passed in the REPL options. Evaluates expressions in sloppy mode.
     */
    const REPL_MODE_SLOPPY: unique symbol;
    /**
     * A flag passed in the REPL options. Evaluates expressions in strict mode.
     * This is equivalent to prefacing every repl statement with `'use strict'`.
     */
    const REPL_MODE_STRICT: unique symbol;
    /**
     * The `repl.start()` method creates and starts a {@link REPLServer} instance.
     *
     * If `options` is a string, then it specifies the input prompt:
     *
     * ```js
     * import repl from 'node:repl';
     *
     * // a Unix style prompt
     * repl.start('$ ');
     * ```
     * @since v0.1.91
     */
    function start(options?: string | ReplOptions): REPLServer;
    /**
     * Indicates a recoverable error that a `REPLServer` can use to support multi-line input.
     *
     * @see https://nodejs.org/dist/latest-v22.x/docs/api/repl.html#repl_recoverable_errors
     */
    class Recoverable extends SyntaxError {
        err: Error;
        constructor(err: Error);
    }
}
declare module "node:repl" {
    export * from "repl";
}

```

## ./lib/lambda/node_modules/@types/node/sea.d.ts

```typescript
/**
 * This feature allows the distribution of a Node.js application conveniently to a
 * system that does not have Node.js installed.
 *
 * Node.js supports the creation of [single executable applications](https://github.com/nodejs/single-executable) by allowing
 * the injection of a blob prepared by Node.js, which can contain a bundled script,
 * into the `node` binary. During start up, the program checks if anything has been
 * injected. If the blob is found, it executes the script in the blob. Otherwise
 * Node.js operates as it normally does.
 *
 * The single executable application feature currently only supports running a
 * single embedded script using the `CommonJS` module system.
 *
 * Users can create a single executable application from their bundled script
 * with the `node` binary itself and any tool which can inject resources into the
 * binary.
 *
 * Here are the steps for creating a single executable application using one such
 * tool, [postject](https://github.com/nodejs/postject):
 *
 * 1. Create a JavaScript file:
 * ```bash
 * echo 'console.log(`Hello, ${process.argv[2]}!`);' > hello.js
 * ```
 * 2. Create a configuration file building a blob that can be injected into the
 * single executable application (see `Generating single executable preparation blobs` for details):
 * ```bash
 * echo '{ "main": "hello.js", "output": "sea-prep.blob" }' > sea-config.json
 * ```
 * 3. Generate the blob to be injected:
 * ```bash
 * node --experimental-sea-config sea-config.json
 * ```
 * 4. Create a copy of the `node` executable and name it according to your needs:
 *    * On systems other than Windows:
 * ```bash
 * cp $(command -v node) hello
 * ```
 *    * On Windows:
 * ```text
 * node -e "require('fs').copyFileSync(process.execPath, 'hello.exe')"
 * ```
 * The `.exe` extension is necessary.
 * 5. Remove the signature of the binary (macOS and Windows only):
 *    * On macOS:
 * ```bash
 * codesign --remove-signature hello
 * ```
 *    * On Windows (optional):
 * [signtool](https://learn.microsoft.com/en-us/windows/win32/seccrypto/signtool) can be used from the installed [Windows SDK](https://developer.microsoft.com/en-us/windows/downloads/windows-sdk/).
 * If this step is
 * skipped, ignore any signature-related warning from postject.
 * ```powershell
 * signtool remove /s hello.exe
 * ```
 * 6. Inject the blob into the copied binary by running `postject` with
 * the following options:
 *    * `hello` / `hello.exe` \- The name of the copy of the `node` executable
 *    created in step 4.
 *    * `NODE_SEA_BLOB` \- The name of the resource / note / section in the binary
 *    where the contents of the blob will be stored.
 *    * `sea-prep.blob` \- The name of the blob created in step 1.
 *    * `--sentinel-fuse NODE_SEA_FUSE_fce680ab2cc467b6e072b8b5df1996b2` \- The [fuse](https://www.electronjs.org/docs/latest/tutorial/fuses) used by the Node.js project to detect if a file has been
 * injected.
 *    * `--macho-segment-name NODE_SEA` (only needed on macOS) - The name of the
 *    segment in the binary where the contents of the blob will be
 *    stored.
 * To summarize, here is the required command for each platform:
 *    * On Linux:
 *    ```bash
 *    npx postject hello NODE_SEA_BLOB sea-prep.blob \
 *        --sentinel-fuse NODE_SEA_FUSE_fce680ab2cc467b6e072b8b5df1996b2
 *    ```
 *    * On Windows - PowerShell:
 *    ```powershell
 *    npx postject hello.exe NODE_SEA_BLOB sea-prep.blob `
 *        --sentinel-fuse NODE_SEA_FUSE_fce680ab2cc467b6e072b8b5df1996b2
 *    ```
 *    * On Windows - Command Prompt:
 *    ```text
 *    npx postject hello.exe NODE_SEA_BLOB sea-prep.blob ^
 *        --sentinel-fuse NODE_SEA_FUSE_fce680ab2cc467b6e072b8b5df1996b2
 *    ```
 *    * On macOS:
 *    ```bash
 *    npx postject hello NODE_SEA_BLOB sea-prep.blob \
 *        --sentinel-fuse NODE_SEA_FUSE_fce680ab2cc467b6e072b8b5df1996b2 \
 *        --macho-segment-name NODE_SEA
 *    ```
 * 7. Sign the binary (macOS and Windows only):
 *    * On macOS:
 * ```bash
 * codesign --sign - hello
 * ```
 *    * On Windows (optional):
 * A certificate needs to be present for this to work. However, the unsigned
 * binary would still be runnable.
 * ```powershell
 * signtool sign /fd SHA256 hello.exe
 * ```
 * 8. Run the binary:
 *    * On systems other than Windows
 * ```console
 * $ ./hello world
 * Hello, world!
 * ```
 *    * On Windows
 * ```console
 * $ .\hello.exe world
 * Hello, world!
 * ```
 * @since v19.7.0, v18.16.0
 * @experimental
 * @see [source](https://github.com/nodejs/node/blob/v22.x/src/node_sea.cc)
 */
declare module "node:sea" {
    type AssetKey = string;
    /**
     * @since v20.12.0
     * @return Whether this script is running inside a single-executable application.
     */
    function isSea(): boolean;
    /**
     * This method can be used to retrieve the assets configured to be bundled into the
     * single-executable application at build time.
     * An error is thrown when no matching asset can be found.
     * @since v20.12.0
     */
    function getAsset(key: AssetKey): ArrayBuffer;
    function getAsset(key: AssetKey, encoding: string): string;
    /**
     * Similar to `sea.getAsset()`, but returns the result in a [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob).
     * An error is thrown when no matching asset can be found.
     * @since v20.12.0
     */
    function getAssetAsBlob(key: AssetKey, options?: {
        type: string;
    }): Blob;
    /**
     * This method can be used to retrieve the assets configured to be bundled into the
     * single-executable application at build time.
     * An error is thrown when no matching asset can be found.
     *
     * Unlike `sea.getRawAsset()` or `sea.getAssetAsBlob()`, this method does not
     * return a copy. Instead, it returns the raw asset bundled inside the executable.
     *
     * For now, users should avoid writing to the returned array buffer. If the
     * injected section is not marked as writable or not aligned properly,
     * writes to the returned array buffer is likely to result in a crash.
     * @since v20.12.0
     */
    function getRawAsset(key: AssetKey): ArrayBuffer;
}

```

## ./lib/lambda/node_modules/@types/node/sqlite.d.ts

```typescript

```

## ./lib/lambda/node_modules/bowser/index.d.ts

```typescript
// Type definitions for Bowser v2
// Project: https://github.com/lancedikson/bowser
// Definitions by: Alexander P. Cerutti <https://github.com/alexandercerutti>,

export = Bowser;
export as namespace Bowser;

declare namespace Bowser {
  /**
   * Creates a Parser instance
   * @param {string}UA - User agent string
   * @param {boolean} skipParsing
   */

  function getParser(UA: string, skipParsing?: boolean): Parser.Parser;

  /**
   * Creates a Parser instance and runs Parser.getResult immediately
   * @param UA - User agent string
   * @returns {Parser.ParsedResult}
   */

  function parse(UA: string): Parser.ParsedResult;

  /**
   * Constants exposed via bowser getters
   */
  const BROWSER_MAP: Record<string, string>;
  const ENGINE_MAP: Record<string, string>;
  const OS_MAP: Record<string, string>;
  const PLATFORMS_MAP: Record<string, string>;

  namespace Parser {
    interface Parser {
      constructor(UA: string, skipParsing?: boolean): Parser.Parser;

      /**
       * Check if the version is equals the browser version
       * @param version The string to compare with the browser version
       * @returns {boolean}
       */

      compareVersion(version: string): boolean;

      /**
       * Get parsed browser object
       * @return {BrowserDetails} Browser's details
       */

      getBrowser(): BrowserDetails;

      /**
       * Get browser's name
       * @param {Boolean} [toLowerCase] return lower-cased value
       * @return {String} Browser's name or an empty string
       */

      getBrowserName(toLowerCase?: boolean): string;

      /**
       * Get browser's version
       * @return {String} version of browser
       */

      getBrowserVersion(): string | undefined;

      /**
       * Get OS
       * @return {OSDetails} - OS Details
       *
       * @example
       * this.getOS(); // {
       * //   name: 'macOS',
       * //   version: '10.11.12',
       * // }
       */

      getOS(): OSDetails;

      /**
       * Get OS name
       * @param {Boolean} [toLowerCase] return lower-cased value
       * @return {String} name of the OS  macOS, Windows, Linux, etc.
       */

      getOSName(toLowerCase?: boolean): string;

      /**
       * Get OS version
       * @return {String} full version with dots ('10.11.12', '5.6', etc)
       */

      getOSVersion(): string;

      /**
       * Get parsed platform
       * @returns {PlatformDetails}
       */

      getPlatform(): PlatformDetails;

      /**
       * Get platform name
       * @param {boolean} toLowerCase
       */

      getPlatformType(toLowerCase?: boolean): string;

      /**
       * Get parsed engine
       * @returns {EngineDetails}
       */

      getEngine(): EngineDetails;

      /**
       * Get parsed engine's name
       * @returns {String} Engine's name or an empty string
       */

      getEngineName(): string;

      /**
       * Get parsed result
       * @return {ParsedResult}
       */

      getResult(): ParsedResult;

      /**
       * Get UserAgent string of current Parser instance
       * @return {String} User-Agent String of the current <Parser> object
       */

      getUA(): string;

      /**
       * Is anything? Check if the browser is called "anything",
       * the OS called "anything" or the platform called "anything"
       * @param {String} anything
       * @param [includingAlias=false] The flag showing whether alias will be included into comparison
       * @returns {Boolean}
       */

      is(anything: any, includingAlias?: boolean): boolean;

      /**
       * Check if the browser name equals the passed string
       * @param browserName The string to compare with the browser name
       * @param [includingAlias=false] The flag showing whether alias will be included into comparison
       * @returns {boolean}
       */

      isBrowser(browserName: string, includingAlias?: boolean): boolean;

      /**
       * Check if the engine name equals the passed string
       * @param engineName The string to compare with the engine name
       * @returns {boolean}
       */

      isEngine(engineName: string): boolean;

      /**
       * Check if the OS name equals the passed string
       * @param OSName The string to compare with the OS name
       * @returns {boolean}
       */

      isOS(OSName: string): boolean;

      /**
       * Check if the platform name equals the passed string
       * @param platformName The string to compare with the platform name
       * @returns {boolean}
       */

      isPlatform(platformName: string): boolean;

      /**
       * Parse full information about the browser
       * @returns {Parser.Parser}
       */

      parse(): Parser.Parser;

      /**
       * Get parsed browser object
       * @returns {BrowserDetails}
       */

      parseBrowser(): BrowserDetails;

      /**
       * Get parsed engine
       * @returns {EngineDetails}
       */

      parseEngine(): EngineDetails;

      /**
       * Parse OS and save it to this.parsedResult.os
       * @returns {OSDetails}
       */

      parseOS(): OSDetails;

      /**
       * Get parsed platform
       * @returns {PlatformDetails}
       */

      parsePlatform(): PlatformDetails;

      /**
       * Check if parsed browser matches certain conditions
       *
       * @param {checkTree} checkTree It's one or two layered object,
       * which can include a platform or an OS on the first layer
       * and should have browsers specs on the bottom-laying layer
       *
       * @returns {Boolean|undefined} Whether the browser satisfies the set conditions or not.
       * Returns `undefined` when the browser is no described in the checkTree object.
       *
       * @example
       * const browser = new Bowser(UA);
       * if (browser.check({chrome: '>118.01.1322' }))
       * // or with os
       * if (browser.check({windows: { chrome: '>118.01.1322' } }))
       * // or with platforms
       * if (browser.check({desktop: { chrome: '>118.01.1322' } }))
       */

      satisfies(checkTree: checkTree): boolean | undefined;

      /**
       * Check if the browser name equals the passed string
       * @param {string} browserName The string to compare with the browser name
       * @param [includingAlias=false] The flag showing whether alias will be included into comparison
       * @returns {boolean}
       */

      isBrowser(browserName: string, includingAlias?: boolean): boolean;

      /**
       * Check if the engine name equals the passed string
       * @param {string} engineName The string to compare with the engine name
       * @returns {boolean}
       */

      isEngine(engineName: string): boolean;

      /**
       * Check if the platform type equals the passed string
       * @param {string} platformType The string to compare with the platform type
       * @returns {boolean}
       */

      isPlatform(platformType: string): boolean;

      /**
       * Check if the OS name equals the passed string
       * @param {string} osName The string to compare with the OS name
       * @returns {boolean}
       */

      isOS(osName: string): boolean;

      /**
       * Check if any of the given values satisfies `.is(anything)`
       * @param {string[]} anythings
       * @returns {boolean} true if at least one condition is satisfied, false otherwise.
       */

      some(anythings: string[]): boolean | undefined;

      /**
       * Test a UA string for a regexp
       * @param regex
       * @returns {boolean} true if the regex matches the UA, false otherwise.
       */

      test(regex: RegExp): boolean;
    }

    interface ParsedResult {
      browser: BrowserDetails;
      os: OSDetails;
      platform: PlatformDetails;
      engine: EngineDetails;
    }

    interface Details {
      name?: string;
      version?: string;
    }

    interface OSDetails extends Details {
      versionName?: string;
    }

    interface PlatformDetails {
      type?: string;
      vendor?: string;
      model?: string;
    }

    type BrowserDetails = Details;
    type EngineDetails = Details;

    interface checkTree {
      [key: string]: any;
    }
  }
}

```

## ./lib/lambda/node_modules/bowser/package.json

```json
{
  "name": "bowser",
  "description": "Lightweight browser detector",
  "keywords": [
    "browser",
    "useragent",
    "user-agent",
    "parser",
    "ua",
    "detection",
    "ender",
    "sniff"
  ],
  "homepage": "https://github.com/lancedikson/bowser",
  "author": "Dustin Diaz <dustin@dustindiaz.com> (http://dustindiaz.com)",
  "contributors": [
    {
      "name": "Denis Demchenko",
      "url": "http://twitter.com/lancedikson"
    }
  ],
  "main": "es5.js",
  "browser": "es5.js",
  "module": "src/bowser.js",
  "types": "index.d.ts",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/lancedikson/bowser.git"
  },
  "devDependencies": {
    "@babel/cli": "^7.11.6",
    "@babel/core": "^7.8.0",
    "@babel/polyfill": "^7.8.3",
    "@babel/preset-env": "^7.8.2",
    "@babel/register": "^7.8.3",
    "ava": "^3.0.0",
    "babel-eslint": "^10.0.3",
    "babel-loader": "^8.0.6",
    "babel-plugin-add-module-exports": "^1.0.2",
    "babel-plugin-istanbul": "^6.0.0",
    "compression-webpack-plugin": "^4.0.0",
    "coveralls": "^3.0.6",
    "docdash": "^1.1.1",
    "eslint": "^6.5.1",
    "eslint-config-airbnb-base": "^13.2.0",
    "eslint-plugin-ava": "^10.0.0",
    "eslint-plugin-import": "^2.18.2",
    "gh-pages": "^3.0.0",
    "jsdoc": "^3.6.3",
    "nyc": "^15.0.0",
    "sinon": "^9.0.0",
    "testem": "^3.0.0",
    "webpack": "^4.41.0",
    "webpack-bundle-analyzer": "^3.5.2",
    "webpack-cli": "^3.3.9",
    "yamljs": "^0.3.0"
  },
  "ava": {
    "require": [
      "@babel/register"
    ]
  },
  "bugs": {
    "url": "https://github.com/lancedikson/bowser/issues"
  },
  "directories": {
    "test": "test"
  },
  "scripts": {
    "build": "webpack --config webpack.config.js",
    "generate-and-deploy-docs": "npm run generate-docs && gh-pages --dist docs --dest docs",
    "watch": "webpack --watch --config webpack.config.js",
    "prepublishOnly": "npm run build",
    "lint:check": "eslint ./src",
    "lint:fix": "eslint --fix ./src",
    "testem": "testem",
    "test": "nyc --reporter=html --reporter=text ava",
    "test:watch": "ava --watch",
    "coverage": "nyc report --reporter=text-lcov | coveralls",
    "generate-docs": "jsdoc -c jsdoc.json"
  },
  "license": "MIT",
  "version": "2.12.1"
}

```

## ./lib/lambda/node_modules/fast-xml-parser/package.json

```json
{
  "name": "fast-xml-parser",
  "version": "5.2.5",
  "description": "Validate XML, Parse XML, Build XML without C/C++ based libraries",
  "main": "./lib/fxp.cjs",
  "type": "module",
  "sideEffects": false,
  "module": "./src/fxp.js",
  "types": "./src/fxp.d.ts",
  "exports": {
    ".": {
      "import": {
        "types": "./src/fxp.d.ts",
        "default": "./src/fxp.js"
      },
      "require": {
        "types": "./lib/fxp.d.cts",
        "default": "./lib/fxp.cjs"
      }
    }
  },
  "scripts": {
    "test": "c8 --reporter=lcov --reporter=text jasmine spec/*spec.js",
    "test-types": "tsc --noEmit spec/typings/typings-test.ts",
    "unit": "jasmine",
    "coverage": "nyc report --reporter html --reporter text -t .nyc_output --report-dir .nyc_output/summary",
    "perf": "node ./benchmark/perfTest3.js",
    "lint": "eslint src/**/*.js spec/**/*.js benchmark/**/*.js",
    "bundle": "webpack --config webpack.cjs.config.js",
    "prettier": "prettier --write src/**/*.js",
    "checkReadiness": "publish-please --dry-run"
  },
  "bin": {
    "fxparser": "./src/cli/cli.js"
  },
  "files": [
    "lib",
    "src",
    "CHANGELOG.md"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/NaturalIntelligence/fast-xml-parser"
  },
  "keywords": [
    "fast",
    "xml",
    "json",
    "parser",
    "xml2js",
    "x2js",
    "xml2json",
    "js",
    "validator",
    "validate",
    "transformer",
    "assert",
    "js2xml",
    "json2xml",
    "html"
  ],
  "author": "Amit Gupta (https://solothought.com)",
  "license": "MIT",
  "devDependencies": {
    "@babel/core": "^7.13.10",
    "@babel/plugin-transform-runtime": "^7.13.10",
    "@babel/preset-env": "^7.13.10",
    "@babel/register": "^7.13.8",
    "@types/node": "20",
    "babel-loader": "^8.2.2",
    "c8": "^10.1.3",
    "eslint": "^8.3.0",
    "he": "^1.2.0",
    "jasmine": "^5.6.0",
    "prettier": "^3.5.1",
    "publish-please": "^5.5.2",
    "typescript": "5",
    "webpack": "^5.64.4",
    "webpack-cli": "^4.9.1"
  },
  "funding": [
    {
      "type": "github",
      "url": "https://github.com/sponsors/NaturalIntelligence"
    }
  ],
  "dependencies": {
    "strnum": "^2.1.0"
  }
}

```

## ./lib/lambda/node_modules/fast-xml-parser/src/fxp.d.ts

```typescript
export type X2jOptions = {
  /**
   * Preserve the order of tags in resulting JS object
   * 
   * Defaults to `false`
   */
  preserveOrder?: boolean;

  /**
   * Give a prefix to the attribute name in the resulting JS object
   * 
   * Defaults to '@_'
   */  
  attributeNamePrefix?: string;

  /**
   * A name to group all attributes of a tag under, or `false` to disable
   * 
   * Defaults to `false`
   */
  attributesGroupName?: false | string;

  /**
   * The name of the next node in the resulting JS
   * 
   * Defaults to `#text`
   */
  textNodeName?: string;

  /**
   * Whether to ignore attributes when parsing
   * 
   * When `true` - ignores all the attributes
   * 
   * When `false` - parses all the attributes
   * 
   * When `Array<string | RegExp>` - filters out attributes that match provided patterns
   * 
   * When `Function` - calls the function for each attribute and filters out those for which the function returned `true`
   * 
   * Defaults to `true`
   */
  ignoreAttributes?: boolean | (string | RegExp)[] | ((attrName: string, jPath: string) => boolean);

  /**
   * Whether to remove namespace string from tag and attribute names
   * 
   * Defaults to `false`
   */
  removeNSPrefix?: boolean;

  /**
   * Whether to allow attributes without value
   * 
   * Defaults to `false`
   */
  allowBooleanAttributes?: boolean;

  /**
   * Whether to parse tag value with `strnum` package
   * 
   * Defaults to `true`
   */
  parseTagValue?: boolean;

  /**
   * Whether to parse tag value with `strnum` package
   * 
   * Defaults to `false`
   */
  parseAttributeValue?: boolean;

  /**
   * Whether to remove surrounding whitespace from tag or attribute value
   * 
   * Defaults to `true`
   */
  trimValues?: boolean;

  /**
   * Give a property name to set CDATA values to instead of merging to tag's text value
   * 
   * Defaults to `false`
   */
  cdataPropName?: false | string;

  /**
   * If set, parse comments and set as this property
   * 
   * Defaults to `false`
   */
  commentPropName?: false | string;

  /**
   * Control how tag value should be parsed. Called only if tag value is not empty
   * 
   * @returns {undefined|null} `undefined` or `null` to set original value.
   * @returns {unknown} 
   * 
   * 1. Different value or value with different data type to set new value.
   * 2. Same value to set parsed value if `parseTagValue: true`.
   * 
   * Defaults to `(tagName, val, jPath, hasAttributes, isLeafNode) => val`
   */
  tagValueProcessor?: (tagName: string, tagValue: string, jPath: string, hasAttributes: boolean, isLeafNode: boolean) => unknown;

  /**
   * Control how attribute value should be parsed
   * 
   * @param attrName 
   * @param attrValue 
   * @param jPath 
   * @returns {undefined|null} `undefined` or `null` to set original value
   * @returns {unknown}
   * 
   * Defaults to `(attrName, val, jPath) => val`
   */
  attributeValueProcessor?: (attrName: string, attrValue: string, jPath: string) => unknown;

  /**
   * Options to pass to `strnum` for parsing numbers
   * 
   * Defaults to `{ hex: true, leadingZeros: true, eNotation: true }`
   */
  numberParseOptions?: strnumOptions;

  /**
   * Nodes to stop parsing at
   * 
   * Defaults to `[]`
   */
  stopNodes?: string[];

  /**
   * List of tags without closing tags
   * 
   * Defaults to `[]`
   */
  unpairedTags?: string[];

  /**
   * Whether to always create a text node
   * 
   * Defaults to `false`
   */
  alwaysCreateTextNode?: boolean;

  /**
   * Determine whether a tag should be parsed as an array
   * 
   * @param tagName 
   * @param jPath 
   * @param isLeafNode 
   * @param isAttribute 
   * @returns {boolean}
   * 
   * Defaults to `() => false`
   */
  isArray?: (tagName: string, jPath: string, isLeafNode: boolean, isAttribute: boolean) => boolean;

  /**
   * Whether to process default and DOCTYPE entities
   * 
   * Defaults to `true`
   */
  processEntities?: boolean;

  /**
   * Whether to process HTML entities
   * 
   * Defaults to `false`
   */
  htmlEntities?: boolean;

  /**
   * Whether to ignore the declaration tag from output
   * 
   * Defaults to `false`
   */
  ignoreDeclaration?: boolean;

  /**
   * Whether to ignore Pi tags
   * 
   * Defaults to `false`
   */
  ignorePiTags?: boolean;

  /**
   * Transform tag names
   * 
   * Defaults to `false`
   */
  transformTagName?: ((tagName: string) => string) | false;

  /**
   * Transform attribute names
   * 
   * Defaults to `false`
   */
  transformAttributeName?: ((attributeName: string) => string) | false;

  /**
   * Change the tag name when a different name is returned. Skip the tag from parsed result when false is returned.
   * Modify `attrs` object to control attributes for the given tag.
   * 
   * @returns {string} new tag name.
   * @returns false to skip the tag
   * 
   * Defaults to `(tagName, jPath, attrs) => tagName`
   */
  updateTag?: (tagName: string, jPath: string, attrs: {[k: string]: string}) =>  string | boolean;

  /**
   * If true, adds a Symbol to all object nodes, accessible by {@link XMLParser.getMetaDataSymbol} with
   * metadata about each the node in the XML file.
   */
  captureMetaData?: boolean;
};

export type strnumOptions = {
  hex: boolean;
  leadingZeros: boolean,
  skipLike?: RegExp,
  eNotation?: boolean
}

export type validationOptions = {
  /**
   * Whether to allow attributes without value
   * 
   * Defaults to `false`
   */
  allowBooleanAttributes?: boolean;
  
  /**
   * List of tags without closing tags
   * 
   * Defaults to `[]`
   */
  unpairedTags?: string[];
};

export type XmlBuilderOptions = {
  /**
   * Give a prefix to the attribute name in the resulting JS object
   * 
   * Defaults to '@_'
   */  
  attributeNamePrefix?: string;

  /**
   * A name to group all attributes of a tag under, or `false` to disable
   * 
   * Defaults to `false`
   */
  attributesGroupName?: false | string;

  /**
   * The name of the next node in the resulting JS
   * 
   * Defaults to `#text`
   */
  textNodeName?: string;

  /**
   * Whether to ignore attributes when building
   * 
   * When `true` - ignores all the attributes
   * 
   * When `false` - builds all the attributes
   * 
   * When `Array<string | RegExp>` - filters out attributes that match provided patterns
   * 
   * When `Function` - calls the function for each attribute and filters out those for which the function returned `true`
   * 
   * Defaults to `true`
   */
  ignoreAttributes?: boolean | (string | RegExp)[] | ((attrName: string, jPath: string) => boolean);

  /**
   * Give a property name to set CDATA values to instead of merging to tag's text value
   * 
   * Defaults to `false`
   */
  cdataPropName?: false | string;

  /**
   * If set, parse comments and set as this property
   * 
   * Defaults to `false`
   */
  commentPropName?: false | string;

  /**
   * Whether to make output pretty instead of single line
   * 
   * Defaults to `false`
   */
  format?: boolean;


  /**
   * If `format` is set to `true`, sets the indent string
   * 
   * Defaults to `  `
   */
  indentBy?: string;

  /**
   * Give a name to a top-level array
   * 
   * Defaults to `undefined`
   */
  arrayNodeName?: string;

  /**
   * Create empty tags for tags with no text value
   * 
   * Defaults to `false`
   */
  suppressEmptyNode?: boolean;

  /**
   * Suppress an unpaired tag
   * 
   * Defaults to `true`
   */
  suppressUnpairedNode?: boolean;

  /**
   * Don't put a value for boolean attributes
   * 
   * Defaults to `true`
   */
  suppressBooleanAttributes?: boolean;

  /**
   * Preserve the order of tags in resulting JS object
   * 
   * Defaults to `false`
   */
  preserveOrder?: boolean;

  /**
   * List of tags without closing tags
   * 
   * Defaults to `[]`
   */
  unpairedTags?: string[];

  /**
   * Nodes to stop parsing at
   * 
   * Defaults to `[]`
   */
  stopNodes?: string[];

  /**
   * Control how tag value should be parsed. Called only if tag value is not empty
   * 
   * @returns {undefined|null} `undefined` or `null` to set original value.
   * @returns {unknown} 
   * 
   * 1. Different value or value with different data type to set new value.
   * 2. Same value to set parsed value if `parseTagValue: true`.
   * 
   * Defaults to `(tagName, val, jPath, hasAttributes, isLeafNode) => val`
   */
  tagValueProcessor?: (name: string, value: unknown) => unknown;

  /**
   * Control how attribute value should be parsed
   * 
   * @param attrName 
   * @param attrValue 
   * @param jPath 
   * @returns {undefined|null} `undefined` or `null` to set original value
   * @returns {unknown}
   * 
   * Defaults to `(attrName, val, jPath) => val`
   */
  attributeValueProcessor?: (name: string, value: unknown) => unknown;

  /**
   * Whether to process default and DOCTYPE entities
   * 
   * Defaults to `true`
   */
  processEntities?: boolean;


  oneListGroup?: boolean;
};

type ESchema = string | object | Array<string|object>;

export type ValidationError = {
  err: { 
    code: string;
    msg: string,
    line: number,
    col: number 
  };
};

export class XMLParser {
  constructor(options?: X2jOptions);
  parse(xmlData: string | Buffer ,validationOptions?: validationOptions | boolean): any;
  /**
   * Add Entity which is not by default supported by this library
   * @param entityIdentifier {string} Eg: 'ent' for &ent;
   * @param entityValue {string} Eg: '\r'
   */
  addEntity(entityIdentifier: string, entityValue: string): void;

  /**
   * Returns a Symbol that can be used to access the {@link XMLMetaData}
   * property on a node.
   * 
   * If Symbol is not available in the environment, an ordinary property is used
   * and the name of the property is here returned.
   * 
   * The XMLMetaData property is only present when {@link X2jOptions.captureMetaData}
   * is true in the options.
   */
  static getMetaDataSymbol() : Symbol;
}

export class XMLValidator{
  static validate(  xmlData: string,  options?: validationOptions): true | ValidationError;
}
export class XMLBuilder {
  constructor(options?: XmlBuilderOptions);
  build(jObj: any): string;
}

/**
 * This object is available on nodes via the symbol {@link XMLParser.getMetaDataSymbol} 
 * when {@link X2jOptions.captureMetaData} is true.
 */
export interface XMLMetaData {
  /** The index, if available, of the character where the XML node began in the input stream. */
  startIndex?: number;
}

```

## ./lib/lambda/node_modules/mnemonist/bi-map.d.ts

```typescript
/**
 * Mnemonist BiMap Typings
 * ========================
 */
export class InverseMap<K, V> implements Iterable<[K, V]> {

  // Members
  size: number;
  inverse: BiMap<V, K>;

  // Methods
  clear(): void;
  set(key: K, value: V): this;
  delete(key: K): boolean;
  has(key: K): boolean;
  get(key: K): V;
  forEach(callback: (value: V, key: K, map: this) => void, scope?: any): void;
  keys(): IterableIterator<K>;
  values(): IterableIterator<V>;
  entries(): IterableIterator<[K, V]>;
  [Symbol.iterator](): IterableIterator<[K, V]>;
  inspect(): any;
}

export default class BiMap<K, V> implements Iterable<[K, V]> {

  // Members
  size: number;
  inverse: InverseMap<V, K>;

  // Methods
  clear(): void;
  set(key: K, value: V): this;
  delete(key: K): boolean;
  has(key: K): boolean;
  get(key: K): V;
  forEach(callback: (value: V, key: K, map: this) => void, scope?: any): void;
  keys(): IterableIterator<K>;
  values(): IterableIterator<V>;
  entries(): IterableIterator<[K, V]>;
  [Symbol.iterator](): IterableIterator<[K, V]>;
  inspect(): any;

  // Statics
  static from<I, J>(iterable: Iterable<[I, J]> | {[key: string]: J}): BiMap<I, J>;
}

```

## ./lib/lambda/node_modules/mnemonist/bit-set.d.ts

```typescript
/**
 * Mnemonist BitSet Typings
 * =========================
 */
export default class BitSet implements Iterable<number> {

  // Members
  length: number;
  size: number;

  // Constructor
  constructor(length: number);

  // Methods
  clear(): void;
  set(index: number, value?: boolean |number): void;
  reset(index: number, value: boolean | number): void;
  flip(index: number, value: boolean | number): void;
  get(index: number): number;
  test(index: number): boolean;
  rank(r: number): number;
  select(r: number): number;
  forEach(callback: (index: number, value: number, set: this) => void, scope?: any): void;
  values(): IterableIterator<number>;
  entries(): IterableIterator<[number, number]>;
  [Symbol.iterator](): IterableIterator<number>;
  inspect(): any;
  toJSON(): Array<number>;
}

```

## ./lib/lambda/node_modules/mnemonist/bit-vector.d.ts

```typescript
/**
 * Mnemonist BitVector Typings
 * ============================
 */
type BitVectorOptions = {
  initialLength?: number;
  initialCapacity?: number;
  policy?: (capacity: number) => number;
}

export default class BitVector implements Iterable<number> {

  // Members
  capacity: number;
  length: number;
  size: number;

  // Constructor
  constructor(length: number);
  constructor(options: BitVectorOptions);

  // Methods
  clear(): void;
  set(index: number, value?: boolean |number): this;
  reset(index: number, value: boolean | number): void;
  flip(index: number, value: boolean | number): void;
  reallocate(capacity: number): this;
  grow(capacity?: number): this;
  resize(length: number): this;
  push(value: boolean | number): number;
  pop(): number | undefined;
  get(index: number): number;
  test(index: number): boolean;
  rank(r: number): number;
  select(r: number): number;
  forEach(callback: (index: number, value: number, set: this) => void, scope?: any): void;
  values(): IterableIterator<number>;
  entries(): IterableIterator<[number, number]>;
  [Symbol.iterator](): IterableIterator<number>;
  inspect(): any;
  toJSON(): Array<number>;
}

```

## ./lib/lambda/node_modules/mnemonist/bk-tree.d.ts

```typescript
/**
 * Mnemonist BKTree Typings
 * =========================
 */
type DistanceFunction<T> = (a: T, b: T) => number;

export default class BKTree<T>{
  
  // Members
  distance: DistanceFunction<T>;
  size: number;

  // Constructor
  constructor(distance: DistanceFunction<T>);

  // Methods
  add(item: T): this;
  search(n: number, query: T): Array<{item: T, distance: number}>;
  toJSON(): object;
  inspect(): any;

  // Statics
  static from<I>(iterable: Iterable<I> | {[key: string] : I}, distance: DistanceFunction<I>): BKTree<I>;
}
```

## ./lib/lambda/node_modules/mnemonist/bloom-filter.d.ts

```typescript
/**
 * Mnemonist BloomFilter Typings
 * ==============================
 */
type BloomFilterOptions = {
  capacity: number;
  errorRate?: number;
}

export default class BloomFilter {

  // Members
  capacity: number;
  errorRate: number;
  hashFunctions: number;

  // Constructor
  constructor(capacity: number);
  constructor(options: BloomFilterOptions);

  // Methods
  clear(): void;
  add(string: string): this;
  test(string: string): boolean;
  toJSON(): Uint8Array;

  // Statics
  from(iterable: Iterable<string>, options?: number | BloomFilterOptions): BloomFilter;
}

```

## ./lib/lambda/node_modules/mnemonist/circular-buffer.d.ts

```typescript
/**
 * Mnemonist CircularBuffer Typings
 * =================================
 */
import {IArrayLikeConstructor} from './utils/types';

export default class CircularBuffer<T> implements Iterable<T> {

  // Members
  capacity: number;
  size: number;

  // Constructor
  constructor(ArrayClass: IArrayLikeConstructor, capacity: number);

  // Methods
  clear(): void;
  push(item: T): number;
  unshift(item: T): number;
  pop(): T | undefined;
  shift(): T | undefined;
  peekFirst(): T | undefined;
  peekLast(): T | undefined;
  get(index: number): T | undefined;
  forEach(callback: (item: T, index: number, buffer: this) => void, scope?: any): void;
  toArray(): Iterable<T>;
  values(): IterableIterator<T>;
  entries(): IterableIterator<[number, T]>;
  [Symbol.iterator](): IterableIterator<T>;
  inspect(): any;

  // Statics
  static from<I>(iterable: Iterable<I> | {[key: string] : I}, ArrayClass: IArrayLikeConstructor, capacity?: number): CircularBuffer<I>;
}

```

## ./lib/lambda/node_modules/mnemonist/default-map.d.ts

```typescript
/**
 * Mnemonist DefaultMap Typings
 * =============================
 */
export default class DefaultMap<K, V> implements Iterable<[K, V]> {

  // Members
  size: number;

  // Constructor
  constructor(factory: (key: K, index: number) => V);

  // Methods
  clear(): void;
  set(key: K, value: V): this;
  delete(key: K): boolean;
  has(key: K): boolean;
  get(key: K): V;
  peek(key: K): V | undefined;
  forEach(callback: (value: V, key: K, map: this) => void, scope?: any): void;
  keys(): IterableIterator<K>;
  values(): IterableIterator<V>;
  entries(): IterableIterator<[K, V]>;
  [Symbol.iterator](): IterableIterator<[K, V]>;
  inspect(): any;

  // Statics
  static autoIncrement(): number;
}

```

## ./lib/lambda/node_modules/mnemonist/default-weak-map.d.ts

```typescript
/**
 * Mnemonist DefaultWeakMap Typings
 * ================================
 */
export default class DefaultWeakMap<K extends object, V> {

  // Constructor
  constructor(factory: (key: K) => V);

  // Methods
  clear(): void;
  set(key: K, value: V): this;
  delete(key: K): boolean;
  has(key: K): boolean;
  get(key: K): V;
  peek(key: K): V | undefined;
  inspect(): any;
}

```

## ./lib/lambda/node_modules/mnemonist/fibonacci-heap.d.ts

```typescript
/**
 * Mnemonist FibonacciHeap Typings
 * ================================
 */
type FibonacciHeapComparator<T> = (a: T, b: T) => number;

export default class FibonacciHeap<T> {

  // Members
  size: number;

  // Constructor
  constructor(comparator?: FibonacciHeapComparator<T>);

  // Methods
  clear(): void;
  push(item: T): number;
  peek(): T | undefined;
  pop(): T | undefined;
  inspect(): any;

  // Statics
  static from<I>(
    iterable: Iterable<I> | {[key: string] : I},
    comparator?: FibonacciHeapComparator<I>
  ): FibonacciHeap<I>;
}

export class MinFibonacciHeap<T> {

  // Members
  size: number;

  // Constructor
  constructor(comparator?: FibonacciHeapComparator<T>);

  // Methods
  clear(): void;
  push(item: T): number;
  peek(): T | undefined;
  pop(): T | undefined;
  inspect(): any;

  // Statics
  static from<I>(iterable: Iterable<I> | {[key: string] : I}): FibonacciHeap<I>;
}

export class MaxFibonacciHeap<T> {

  // Members
  size: number;

  // Constructor
  constructor(comparator?: FibonacciHeapComparator<T>);

  // Methods
  clear(): void;
  push(item: T): number;
  peek(): T | undefined;
  pop(): T | undefined;
  inspect(): any;

  // Statics
  static from<I>(iterable: Iterable<I> | {[key: string] : I}): FibonacciHeap<I>;
}

```

## ./lib/lambda/node_modules/mnemonist/fixed-deque.d.ts

```typescript
/**
 * Mnemonist FixedDeque Typings
 * =============================
 */
import {IArrayLikeConstructor} from './utils/types';

export default class FixedDeque<T> implements Iterable<T> {

  // Members
  capacity: number;
  size: number;

  // Constructor
  constructor(ArrayClass: IArrayLikeConstructor, capacity: number);

  // Methods
  clear(): void;
  push(item: T): number;
  unshift(item: T): number;
  pop(): T | undefined;
  shift(): T | undefined;
  peekFirst(): T | undefined;
  peekLast(): T | undefined;
  get(index: number): T | undefined;
  forEach(callback: (item: T, index: number, buffer: this) => void, scope?: any): void;
  toArray(): Iterable<T>;
  values(): IterableIterator<T>;
  entries(): IterableIterator<[number, T]>;
  [Symbol.iterator](): IterableIterator<T>;
  inspect(): any;

  // Statics
  static from<I>(iterable: Iterable<I> | {[key: string] : I}, ArrayClass: IArrayLikeConstructor, capacity?: number): FixedDeque<I>;
}

```

## ./lib/lambda/node_modules/mnemonist/fixed-reverse-heap.d.ts

```typescript
/**
 * Mnemonist FixedReverseHeap Typings
 * ===================================
 */
import {IArrayLikeConstructor} from './utils/types';

type HeapComparator<T> = (a: T, b: T) => number;

export default class FixedReverseHeap<T> {

  // Members
  capacity: number;
  size: number;

  // Constructor
  constructor(ArrayClass: IArrayLikeConstructor, comparator: HeapComparator<T>, capacity: number);
  constructor(ArrayClass: IArrayLikeConstructor, capacity: number);

  // Methods
  clear(): void;
  push(item: T): number;
  consume(): Iterable<T>;
  toArray(): Iterable<T>;
  inspect(): any;
}

```

## ./lib/lambda/node_modules/mnemonist/fixed-stack.d.ts

```typescript
/**
 * Mnemonist FixedStack Typings
 * =============================
 */
import {IArrayLikeConstructor} from './utils/types';

export default class FixedStack<T> implements Iterable<T> {

  // Members
  capacity: number;
  size: number;

  // Constructor
  constructor(ArrayClass: IArrayLikeConstructor, capacity: number);

  // Methods
  clear(): void;
  push(item: T): number;
  pop(): T | undefined;
  peek(): T | undefined;
  forEach(callback: (item: T, index: number, stack: this) => void, scope?: any): void;
  toArray(): Iterable<T>;
  values(): IterableIterator<T>;
  entries(): IterableIterator<[number, T]>;
  [Symbol.iterator](): IterableIterator<T>;
  toString(): string;
  toJSON(): Iterable<T>;
  inspect(): any;

  // Statics
  static from<I>(
    iterable: Iterable<I> | {[key: string] : I},
    ArrayClass: IArrayLikeConstructor,
    capacity?: number
  ): FixedStack<I>;
}

```

## ./lib/lambda/node_modules/mnemonist/fuzzy-map.d.ts

```typescript
/**
 * Mnemonist FuzzyMap Typings
 * ==========================
 */
type HashFunction<K> = (key: any) => K;
type HashFunctionsTuple<K> = [HashFunction<K>, HashFunction<K>];

export default class FuzzyMap<K, V> implements Iterable<V> {

  // Members
  size: number;

  // Constructor
  constructor(hashFunction: HashFunction<K>);
  constructor(hashFunctionsTuple: HashFunctionsTuple<K>);

  // Methods
  clear(): void;
  add(key: V): this;
  set(key: K, value: V): this;
  get(key: any): V | undefined;
  has(key: any): boolean;
  forEach(callback: (value: V, key: V) => void, scope?: this): void;
  values(): IterableIterator<V>;
  [Symbol.iterator](): IterableIterator<V>;
  inspect(): any;

  // Statics
  static from<I, J>(
    iterable: Iterable<[I, J]> | {[key: string]: J},
    hashFunction: HashFunction<I> | HashFunctionsTuple<I>,
  ): FuzzyMap<I, J>;
}
```

## ./lib/lambda/node_modules/mnemonist/fuzzy-multi-map.d.ts

```typescript
/**
 * Mnemonist FuzzyMultiMap Typings
 * ================================
 */
type HashFunction<K> = (key: any) => K;
type HashFunctionsTuple<K> = [HashFunction<K>, HashFunction<K>];
type FuzzyMultiMapContainer = ArrayConstructor | SetConstructor;

export default class FuzzyMultiMap<K, V> implements Iterable<V> {

  // Members
  dimension: number;
  size: number;

  // Constructor
  constructor(hashFunction: HashFunction<K>, Container?: FuzzyMultiMapContainer);
  constructor(hashFunctions: HashFunctionsTuple<K>, Container?: FuzzyMultiMapContainer);

  // Methods
  clear(): void;
  add(value: V): this;
  set(key: K, value: V): this;
  get(key: any): Array<V> | Set<V> | undefined;
  has(key: any): boolean;
  forEach(callback: (value: V, key: V) => void, scope?: any): void;
  values(): IterableIterator<V>;
  [Symbol.iterator](): IterableIterator<V>;
  inspect(): any;

  // Statics
  static from<I, J>(
    iterable: Iterable<[I, J]> | {[key: string]: J},
    hashFunction: HashFunction<I> | HashFunctionsTuple<I>,
    Container?: FuzzyMultiMapContainer
  ): FuzzyMultiMap<I, J>;
}

```

## ./lib/lambda/node_modules/mnemonist/hashed-array-tree.d.ts

```typescript
/**
 * Mnemonist HashedArrayTree Typings
 * ==================================
 */
import {IArrayLikeConstructor} from './utils/types';

type HashedArrayTreeOptions = {
  initialCapacity?: number;
  initialLength?: number;
  blockSize?: number;
}

export default class HashedArrayTree<T> {

  // Members
  blockSize: number;
  capacity: number;
  length: number;

  // Constructor
  constructor(ArrayClass: IArrayLikeConstructor, capacity: number);
  constructor(ArrayClass: IArrayLikeConstructor, options: HashedArrayTreeOptions);

  // Methods
  set(index: number, value: T): this;
  get(index: number): T | undefined;
  grow(capacity: number): this;
  resize(length: number): this;
  push(value: T): number;
  pop(): T | undefined;
  inspect(): any;
}

```

## ./lib/lambda/node_modules/mnemonist/heap.d.ts

```typescript
/**
 * Mnemonist Heap Typings
 * =======================
 */
type HeapComparator<T> = (a: T, b: T) => number;

export default class Heap<T> {

  // Members
  size: number;

  // Constructor
  constructor(comparator?: HeapComparator<T>);

  // Methods
  clear(): void;
  push(item: T): number;
  peek(): T | undefined;
  pop(): T | undefined;
  replace(item: T): T| undefined;
  pushpop(item: T): T |undefined;
  toArray(): Array<T>;
  consume(): Array<T>;
  inspect(): any;

  // Statics
  static from<I>(
    iterable: Iterable<I> | {[key: string] : I},
    comparator?: HeapComparator<I>
  ): Heap<I>;
}

export class MinHeap<T> {

  // Members
  size: number;

  // Constructor
  constructor(comparator?: HeapComparator<T>);

  // Methods
  clear(): void;
  push(item: T): number;
  peek(): T | undefined;
  pop(): T | undefined;
  replace(item: T): T| undefined;
  pushpop(item: T): T |undefined;
  toArray(): Array<T>;
  consume(): Array<T>;
  inspect(): any;
}

export class MaxHeap<T> {

  // Members
  size: number;

  // Constructor
  constructor(comparator?: HeapComparator<T>);

  // Methods
  clear(): void;
  push(item: T): number;
  peek(): T | undefined;
  pop(): T | undefined;
  replace(item: T): T| undefined;
  pushpop(item: T): T |undefined;
  toArray(): Array<T>;
  consume(): Array<T>;
  inspect(): any;
}

// Static helpers
export function push<T>(comparator: HeapComparator<T>, heap: Array<T>, item: T): void;
export function pop<T>(comparator: HeapComparator<T>, heap: Array<T>): T;
export function replace<T>(comparator: HeapComparator<T>, heap: Array<T>, item: T): T;
export function pushpop<T>(comparator: HeapComparator<T>, heap: Array<T>, item: T): T;
export function heapify<T>(comparator: HeapComparator<T>, array: Array<T>): void;
export function consume<T>(comparator: HeapComparator<T>, heap: Array<T>): Array<T>;

export function nsmallest<T>(comparator: HeapComparator<T>, n: number, values: Iterable<T>): Array<T>;
export function nsmallest<T>(n: number, values: Iterable<T>): Array<T>;
export function nlargest<T>(comparator: HeapComparator<T>, n: number, values: Iterable<T>): Array<T>;
export function nlargest<T>(n: number, values: Iterable<T>): Array<T>;

```

## ./lib/lambda/node_modules/mnemonist/index.d.ts

```typescript
/**
 * Mnemonist Typings
 * ==================
 *
 * Gathering the library's typings.
 */
import * as set from './set';

export {default as BiMap, InverseMap} from './bi-map';
export {default as BitSet} from './bit-set';
export {default as BitVector} from './bit-vector';
export {default as BKTree} from './bk-tree';
export {default as BloomFilter} from './bloom-filter';
export {default as CircularBuffer} from './circular-buffer';
export {default as DefaultMap} from './default-map';
export {default as DefaultWeakMap} from './default-weak-map';
export {default as FixedDeque} from './fixed-deque';
export {default as FibonacciHeap, MinFibonacciHeap, MaxFibonacciHeap} from './fibonacci-heap';
export {default as FixedReverseHeap} from './fixed-reverse-heap';
export {default as FixedStack} from './fixed-stack';
export {default as FuzzyMap} from './fuzzy-map';
export {default as FuzzyMultiMap} from './fuzzy-multi-map';
export {default as HashedArrayTree} from './hashed-array-tree';
export {default as Heap, MinHeap, MaxHeap} from './heap';
export {default as InvertedIndex} from './inverted-index';
export {default as KDTree} from './kd-tree';
export {default as LinkedList} from './linked-list';
export {default as LRUCache} from './lru-cache';
export {default as LRUMap} from './lru-map';
export {default as MultiMap} from './multi-map';
export {default as MultiSet} from './multi-set';
export {default as PassjoinIndex} from './passjoin-index';
export {default as Queue} from './queue';
export {set};
export {default as SparseQueueSet} from './sparse-queue-set';
export {default as SparseMap} from './sparse-map';
export {default as SparseSet} from './sparse-set';
export {default as Stack} from './stack';
export {default as StaticDisjointSet} from './static-disjoint-set';
export {default as StaticIntervalTree} from './static-interval-tree';
export {default as SuffixArray, GeneralizedSuffixArray} from './suffix-array';
export {default as SymSpell} from './symspell';
export {default as Trie} from './trie';
export {default as TrieMap} from './trie-map';
export {default as Vector, Uint8Vector, Uint8ClampedVector, Int8Vector, Uint16Vector, Int16Vector, Uint32Vector, Int32Vector, Float32Vector, Float64Array} from './vector';
export {default as VPTree} from './vp-tree';

```

## ./lib/lambda/node_modules/mnemonist/inverted-index.d.ts

```typescript
/**
 * Mnemonist InvertedIndex Typings
 * ================================
 */
type Tokenizer = (key: any) => Array<string>;
type TokenizersTuple = [Tokenizer, Tokenizer];

export default class InvertedIndex<D> implements Iterable<D> {

  // Members
  dimension: number;
  size: number;

  // Constructor
  constructor(tokenizer?: Tokenizer);
  constructor(tokenizers?: TokenizersTuple);

  // Methods
  clear(): void;
  add(document: D): this;
  get(query: any): Array<D>;
  forEach(callback: (document: D, index: number, invertedIndex: this) => void, scope?: any): void;
  documents(): IterableIterator<D>;
  tokens(): IterableIterator<string>;
  [Symbol.iterator](): IterableIterator<D>;
  inspect(): any;

  // Statics
  static from<I>(
    iterable: Iterable<I> | {[key: string] : I},
    tokenizer?: Tokenizer | TokenizersTuple
  ): InvertedIndex<I>;
}
```

## ./lib/lambda/node_modules/mnemonist/kd-tree.d.ts

```typescript
/**
 * Mnemonist KDTree Typings
 * =========================
 */
import {IArrayLike} from './utils/types';

export default class KDTree<V> {

  // Members
  dimensions: number;
  size: number;
  visited: number;

  // Methods
  nearestNeighbor(point: Array<number>): V;
  kNearestNeighbors(k: number, point: Array<number>): Array<V>;
  linearKNearestNeighbors(k: number, point: Array<number>): Array<V>;
  inspect(): any;

  // Statics
  static from<I>(iterable: Iterable<[I, Array<number>]>, dimensions: number): KDTree<I>;
  static from(axes: IArrayLike): KDTree<number>;
  static from<I>(axes: IArrayLike, labels: Array<I>): KDTree<I>;
}


```

## ./lib/lambda/node_modules/mnemonist/linked-list.d.ts

```typescript
/**
 * Mnemonist LinkedList Typings
 * =============================
 */
export default class LinkedList<T> implements Iterable<T> {

  // Members
  size: number;

  // Methods
  clear(): void;
  first(): T | undefined;
  last(): T | undefined;
  peek(): T | undefined;
  push(value: T): number;
  shift(): T | undefined;
  unshift(value: T): number;
  forEach(callback: (value: T, index: number, list: this) => void, scope?: any): void;
  toArray(): Array<T>;
  values(): IterableIterator<T>;
  entries(): IterableIterator<[number, T]>;
  [Symbol.iterator](): IterableIterator<T>;
  toString(): string;
  toJSON(): Array<T>;
  inspect(): any;

  // Statics
  static from<I>(iterable: Iterable<I> | {[key: string] : I}): LinkedList<I>;
}
```

## ./lib/lambda/node_modules/mnemonist/lru-cache.d.ts

```typescript
/**
 * Mnemonist LRUCache Typings
 * ===========================
 */
import {IArrayLikeConstructor} from './utils/types';

export default class LRUCache<K, V> implements Iterable<[K, V]> {

  // Members
  capacity: number;
  size: number;

  // Constructor
  constructor(capacity: number);
  constructor(KeyArrayClass: IArrayLikeConstructor, ValueArrayClass: IArrayLikeConstructor, capacity: number);

  // Methods
  clear(): void;
  set(key: K, value: V): this;
  setpop(key: K, value: V): {evicted: boolean, key: K, value: V};
  get(key: K): V | undefined;
  peek(key: K): V | undefined;
  has(key: K): boolean;
  forEach(callback: (value: V, key: K, cache: this) => void, scope?: any): void;
  keys(): IterableIterator<K>;
  values(): IterableIterator<V>;
  entries(): IterableIterator<[K, V]>;
  [Symbol.iterator](): IterableIterator<[K, V]>;
  inspect(): any;

  // Statics
  static from<I, J>(
    iterable: Iterable<[I, J]> | {[key: string]: J},
    KeyArrayClass: IArrayLikeConstructor,
    ValueArrayClass: IArrayLikeConstructor,
    capacity?: number
  ): LRUCache<I, J>;

  static from<I, J>(
    iterable: Iterable<[I, J]> | {[key: string]: J},
    capacity?: number
  ): LRUCache<I, J>;
}

```

## ./lib/lambda/node_modules/mnemonist/lru-map.d.ts

```typescript
/**
 * Mnemonist LRUMap Typings
 * =========================
 */
import {IArrayLikeConstructor} from './utils/types';

export default class LRUMap<K, V> implements Iterable<[K, V]> {

  // Members
  capacity: number;
  size: number;

  // Constructor
  constructor(capacity: number);
  constructor(KeyArrayClass: IArrayLikeConstructor, ValueArrayClass: IArrayLikeConstructor, capacity: number);

  // Methods
  clear(): void;
  set(key: K, value: V): this;
  setpop(key: K, value: V): {evicted: boolean, key: K, value: V};
  get(key: K): V | undefined;
  peek(key: K): V | undefined;
  has(key: K): boolean;
  forEach(callback: (value: V, key: K, cache: this) => void, scope?: any): void;
  keys(): IterableIterator<K>;
  values(): IterableIterator<V>;
  entries(): IterableIterator<[K, V]>;
  [Symbol.iterator](): IterableIterator<[K, V]>;
  inspect(): any;

  // Statics
  static from<I, J>(
    iterable: Iterable<[I, J]> | {[key: string]: J},
    KeyArrayClass: IArrayLikeConstructor,
    ValueArrayClass: IArrayLikeConstructor,
    capacity?: number
  ): LRUMap<I, J>;

  static from<I, J>(
    iterable: Iterable<[I, J]> | {[key: string]: J},
    capacity?: number
  ): LRUMap<I, J>;
}

```

## ./lib/lambda/node_modules/mnemonist/multi-map.d.ts

```typescript
/**
 * Mnemonist MultiMap Typings
 * ===========================
 */

interface MultiMap<K, V, C extends V[] | Set<V> = V[]> extends Iterable<[K, V]> {

  // Members
  dimension: number;
  size: number;

  // Methods
  clear(): void;
  set(key: K, value: V): this;
  delete(key: K): boolean;
  remove(key: K, value: V): boolean;
  has(key: K): boolean;
  get(key: K): C | undefined;
  multiplicity(key: K): number;
  forEach(callback: (value: V, key: K, map: this) => void, scope?: any): void;
  forEachAssociation(callback: (value: C, key: K, map: this) => void, scope?: any): void;
  keys(): IterableIterator<K>;
  values(): IterableIterator<V>;
  entries(): IterableIterator<[K, V]>;
  containers(): IterableIterator<C>;
  associations(): IterableIterator<[K, C]>;
  [Symbol.iterator](): IterableIterator<[K, V]>;
  inspect(): any;
  toJSON(): any;
}

interface MultiMapConstructor {
  new <K, V>(container: SetConstructor): MultiMap<K, V, Set<V>>;
  new <K, V>(container?: ArrayConstructor): MultiMap<K, V, V[]>;

  from<K, V>(
    iterable: Iterable<[K, V]> | {[key: string]: V},
    Container: SetConstructor
  ): MultiMap<K, V, Set<V>>;
  from<K, V>(
    iterable: Iterable<[K, V]> | {[key: string]: V},
    Container?: ArrayConstructor
  ): MultiMap<K, V, V[]>;
}

declare const MultiMap: MultiMapConstructor;
export default MultiMap;
```

## ./lib/lambda/node_modules/mnemonist/multi-set.d.ts

```typescript
/**
 * Mnemonist MultiSet Typings
 * ===========================
 */
export default class MultiSet<K> implements Iterable<K> {

  // Members
  dimension: number;
  size: number;

  // Methods
  clear(): void;
  add(key: K, count?: number): this;
  set(key: K, count: number): this;
  has(key: K): boolean;
  delete(key: K): boolean;
  remove(key: K, count?: number): void;
  edit(a: K, b: K): this;
  multiplicity(key: K): number;
  count(key: K): number;
  get(key: K): number;
  frequency(key: K): number;
  top(n: number): Array<[K, number]>;
  forEach(callback: (value: K, key: K, set: this) => void, scope?: any): void;
  forEachMultiplicity(callback: (value: number, key: K, set: this) => void, scope?: any): void;
  keys(): IterableIterator<K>;
  values(): IterableIterator<K>;
  multiplicities(): IterableIterator<[K, number]>;
  [Symbol.iterator](): IterableIterator<K>;
  inspect(): any;
  toJSON(): any;

  // Statics
  static from<I>(iterable: Iterable<I> | {[key: string]: I}): MultiSet<I>;
  static isSubset<T>(a: MultiSet<T>, b: MultiSet<T>): boolean;
  static isSuperset<T>(a: MultiSet<T>, b: MultiSet<T>): boolean;
}

```

## ./lib/lambda/node_modules/mnemonist/package.json

```json
{
  "name": "mnemonist",
  "version": "0.38.3",
  "description": "Curated collection of data structures for the JavaScript language.",
  "scripts": {
    "lint": "eslint ./*.js ./utils ./test",
    "prepublish": "npm run lint && npm test && npm run test:types",
    "test": "mocha",
    "test:types": "tsc --target es2015 --noEmit --noImplicitAny --noImplicitReturns ./test/types.ts"
  },
  "main": "./index.js",
  "types": "./index.d.ts",
  "files": [
    "sort",
    "utils",
    "*.d.ts",
    "*.js"
  ],
  "repository": {
    "type": "git",
    "url": "git+https://github.com/yomguithereal/mnemonist.git"
  },
  "keywords": [
    "bag",
    "bimap",
    "bit array",
    "bit set",
    "bit vector",
    "bitset",
    "bk tree",
    "burkhard-keller tree",
    "cache",
    "circular buffer",
    "counter",
    "data structures",
    "default map",
    "deque",
    "disjoint set",
    "fibonacci heap",
    "fuzzy map",
    "hashed array tree",
    "heap",
    "interval tree",
    "inverted index",
    "kd tree",
    "linked list",
    "lru",
    "lru cache",
    "multimap",
    "multiset",
    "passjoin",
    "queue",
    "sparse map",
    "sparse set",
    "stack",
    "structures",
    "suffix tree",
    "symspell",
    "trie",
    "union find",
    "vantage point tree",
    "vector",
    "vp tree"
  ],
  "author": {
    "name": "Guillaume Plique",
    "url": "http://github.com/Yomguithereal"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/yomguithereal/mnemonist/issues"
  },
  "homepage": "https://github.com/yomguithereal/mnemonist#readme",
  "dependencies": {
    "obliterator": "^1.6.1"
  },
  "devDependencies": {
    "@yomguithereal/eslint-config": "^4.0.0",
    "asciitree": "^1.0.2",
    "damerau-levenshtein": "^1.0.6",
    "eslint": "^7.21.0",
    "leven": "^3.1.0",
    "lodash": "^4.17.21",
    "matcha": "^0.7.0",
    "mocha": "^8.3.0",
    "pandemonium": "^2.0.0",
    "seedrandom": "^3.0.5",
    "static-kdtree": "^1.0.2",
    "typescript": "^4.2.2"
  },
  "eslintConfig": {
    "extends": "@yomguithereal/eslint-config",
    "globals": {
      "Set": true,
      "Map": true,
      "WeakMap": true,
      "Symbol": true,
      "ArrayBuffer": true,
      "Uint8Array": true,
      "Uint8ClampedArray": true,
      "Uint16Array": true,
      "Uint32Array": true,
      "Int8Array": true,
      "Int16Array": true,
      "Int32Array": true,
      "Float32Array": true,
      "Float64Array": true
    },
    "parserOptions": {
      "ecmaVersion": 6,
      "ecmaFeatures": {
        "forOf": true
      }
    },
    "rules": {
      "no-new": 0
    }
  }
}

```

## ./lib/lambda/node_modules/mnemonist/passjoin-index.d.ts

```typescript
/**
 * Mnemonist PassjoinIndex Typings
 * ================================
 */
type LevenshteinDistanceFunction<T> = (a: T, b: T) => number;

export default class PassjoinIndex<T> implements Iterable<T> {

  // Members
  size: number;

  // Constructor
  constructor(levenshtein: LevenshteinDistanceFunction<T>, k: number);

  // Methods
  add(value: T): this;
  search(query: T): Set<T>;
  clear(): void;
  forEach(callback: (value: T, index: number, self: this) => void, scope?: any): void;
  values(): IterableIterator<T>;
  [Symbol.iterator](): IterableIterator<T>;
  inspect(): any;

  // Statics
  static from<I>(
    iterable: Iterable<I> | {[key: string] : I},
    levenshtein: LevenshteinDistanceFunction<I>,
    k: number
  ): PassjoinIndex<I>;
}

export function countKeys(k: number, s: number): number;
export function comparator<T>(a: T, b: T): number;
export function partition(k: number, l: number): Array<[number, number]>;
export function segments<T>(k: number, string: T): Array<T>;
export function segmentPos<T>(k: number, i: number, string: T): number;

export function multiMatchAwareInterval(
  k: number,
  delta: number,
  i: number,
  s: number,
  pi: number,
  li: number
): [number, number];

export function multiMatchAwareSubstrings<T>(
  k: number,
  string: T,
  l: number,
  i: number,
  pi: number,
  li: number
): Array<T>;

```

## ./lib/lambda/node_modules/mnemonist/queue.d.ts

```typescript
/**
 * Mnemonist Queue Typings
 * ========================
 */
export default class Queue<T> implements Iterable<T> {

  // Members
  size: number;

  // Methods
  clear(): void;
  enqueue(item: T): number;
  dequeue(): T | undefined;
  peek(): T | undefined;
  forEach(callback: (item: T, index: number, queue: this) => void, scope?: any): void;
  toArray(): Array<T>;
  values(): IterableIterator<T>;
  entries(): IterableIterator<[number, T]>;
  [Symbol.iterator](): IterableIterator<T>;
  toString(): string;
  toJSON(): Array<T>;
  inspect(): any;

  // Statics
  static from<I>(iterable: Iterable<I> | {[key: string] : I}): Queue<I>;
  static of<I>(...items: Array<I>): Queue<I>;
}

```

## ./lib/lambda/node_modules/mnemonist/set.d.ts

```typescript
/**
 * Mnemonist Set Typings
 * ======================
 */
export function intersection<T>(...set: Array<Set<T>>): Set<T>;
export function union<T>(...set: Array<Set<T>>): Set<T>;
export function difference<T>(a: Set<T>, b: Set<T>): Set<T>;
export function symmetricDifference<T>(a: Set<T>, b: Set<T>): Set<T>;
export function isSubset<T>(a: Set<T>, b: Set<T>): boolean;
export function isSuperset<T>(a: Set<T>, b: Set<T>): boolean;
export function add<T>(a: Set<T>, b: Set<T>): void;
export function subtract<T>(a: Set<T>, b: Set<T>): void;
export function intersect<T>(a: Set<T>, b: Set<T>): void;
export function disjunct<T>(a: Set<T>, b: Set<T>): void;
export function intersectionSize<T>(a: Set<T>, b:Set<T>): number;
export function unionSize<T>(a: Set<T>, b:Set<T>): number;
export function jaccard<T>(a: Set<T>, b:Set<T>): number;
export function overlap<T>(a: Set<T>, b: Set<T>): number;

```

## ./lib/lambda/node_modules/mnemonist/sort/insertion.d.ts

```typescript
import {IArrayLike} from '../utils/types';

export function inplaceInsertionSort(array: IArrayLike, lo: number, hi: number): IArrayLike;
export function inplaceInsertionSortIndices(array: IArrayLike, indices: IArrayLike, lo: number, hi: number): IArrayLike;

```

## ./lib/lambda/node_modules/mnemonist/sort/quick.d.ts

```typescript
import {IArrayLike} from '../utils/types';

export function inplaceQuickSort(array: IArrayLike, lo: number, hi: number): IArrayLike;
export function inplaceQuickSortIndices(array: IArrayLike, indices: IArrayLike, lo: number, hi: number): IArrayLike;

```

## ./lib/lambda/node_modules/mnemonist/sparse-map.d.ts

```typescript
/**
 * Mnemonist SparseMap Typings
 * ============================
 */
export default class SparseMap<V> implements Iterable<[number, V]> {

  // Members
  length: number;
  size: number;

  // Constructor
  constructor(length: number);

  // Methods
  clear(): void;
  has(key: number): boolean;
  get(key: number): V | undefined;
  set(key: number, value: V): this;
  delete(key: number): boolean;
  forEach(callback: (value: V, key: number, set: this) => void, scope?: any): void;
  keys(): IterableIterator<number>;
  values(): IterableIterator<V>;
  entries(): IterableIterator<[number, V]>;
  [Symbol.iterator](): IterableIterator<[number, V]>;
  inspect(): any;
}

```

## ./lib/lambda/node_modules/mnemonist/sparse-queue-set.d.ts

```typescript
/**
 * Mnemonist SparseQueueSet Typings
 * =================================
 */
export default class SparseQueueSet implements Iterable<number> {

  // Members
  capacity: number;
  start: number;
  size: number;

  // Constructor
  constructor(length: number);

  // Methods
  clear(): void;
  has(value: number): boolean;
  enqueue(value: number): this;
  dequeue(): number | undefined;
  forEach(callback: (value: number, key: number, set: this) => void, scope?: any): void;
  values(): IterableIterator<number>;
  [Symbol.iterator](): IterableIterator<number>;
  inspect(): any;
}

```

## ./lib/lambda/node_modules/mnemonist/sparse-set.d.ts

```typescript
/**
 * Mnemonist SparseSet Typings
 * ============================
 */
export default class SparseSet implements Iterable<number> {

  // Members
  length: number;
  size: number;

  // Constructor
  constructor(length: number);

  // Methods
  clear(): void;
  has(value: number): boolean;
  add(value: number): this;
  delete(value: number): boolean;
  forEach(callback: (value: number, key: number, set: this) => void, scope?: any): void;
  values(): IterableIterator<number>;
  [Symbol.iterator](): IterableIterator<number>;
  inspect(): any;
}

```

## ./lib/lambda/node_modules/mnemonist/stack.d.ts

```typescript
/**
 * Mnemonist Stack Typings
 * ========================
 */
export default class Stack<T> implements Iterable<T> {

  // Members
  size: number;

  // Methods
  clear(): void;
  push(item: T): number;
  pop(): T | undefined;
  peek(): T | undefined;
  forEach(callback: (item: T, index: number, stack: this) => void, scope?: any): void;
  toArray(): Array<T>;
  values(): IterableIterator<T>;
  entries(): IterableIterator<[number, T]>;
  [Symbol.iterator](): IterableIterator<T>;
  toString(): string;
  toJSON(): Array<T>;
  inspect(): any;

  // Statics
  static from<I>(iterable: Iterable<I> | {[key: string] : I}): Stack<I>;
  static of<I>(...items: Array<I>): Stack<I>;
}

```

## ./lib/lambda/node_modules/mnemonist/static-disjoint-set.d.ts

```typescript
/**
 * Mnemonist StaticDisjointSet Typings
 * ====================================
 */
import {ArrayLike} from './utils/types';

export default class StaticDisjointSet {
  
  // Members
  dimension: number;
  size: number;

  // Constructor
  constructor(size: number);

  // Methods
  find(x: number): number;
  union(x: number, y: number): this;
  connected(x: number, y: number): boolean;
  mapping(): ArrayLike;
  compile(): Array<Array<number>>;
  inspect(): any;
}
```

## ./lib/lambda/node_modules/mnemonist/static-interval-tree.d.ts

```typescript
/**
 * Mnemonist StaticIntervalTree Typings
 * =====================================
 */
type StaticIntervalTreeGetter<T> = (item: T) => number;
type StaticIntervalTreeGettersTuple<T> = [StaticIntervalTreeGetter<T>, StaticIntervalTreeGetter<T>];

export default class StaticIntervalTree<T> {

  // Members
  height: number;
  size: number;

  // Constructor
  constructor(intervals: Array<T>, getters?: StaticIntervalTreeGettersTuple<T>);

  // Methods
  intervalsContainingPoint(point: number): Array<T>;
  intervalsOverlappingInterval(interval: T): Array<T>;
  inspect(): any;
  
  // Statics
  static from<I>(iterable: Iterable<I> | {[key: string] : I}): StaticIntervalTree<I>;
}
```

## ./lib/lambda/node_modules/mnemonist/suffix-array.d.ts

```typescript
/**
 * Mnemonist SuffixArray Typings
 * ==============================
 */
export default class SuffixArray {
  
  // Members
  array: Array<number>;
  length: number;
  string: string | Array<string>;

  // Constructor
  constructor(string: string | Array<string>);

  // Methods
  toString(): string;
  toJSON(): Array<number>;
  inspect(): any;
}

export class GeneralizedSuffixArray {

  // Members
  array: Array<number>;
  length: number;
  size: number;
  text: string | Array<string>;

  // Constructor
  constructor(strings: Array<string> | Array<Array<string>>);

  // Methods
  longestCommonSubsequence(): string | Array<string>;
  toString(): string;
  toJSON(): Array<number>;
  inspect(): any;
}
```

## ./lib/lambda/node_modules/mnemonist/symspell.d.ts

```typescript
/**
 * Mnemonist SymSpell Typings
 * ===========================
 */
type SymSpellVerbosity = 0 | 1 | 2;

type SymSpellOptions = {
  maxDistance?: number;
  verbosity?: SymSpellVerbosity
};

type SymSpellMatch = {
  term: string;
  distance: number;
  count: number;
}

export default class SymSpell {

  // Members
  size: number;

  // Constructor
  constructor(options?: SymSpellOptions);

  // Methods
  clear(): void;
  add(string: string): this;
  search(query: string): Array<SymSpellMatch>;

  // Statics
  static from(strings: Iterable<string> | {[key: string]: string}, options?: SymSpellOptions): SymSpell;
} 

```

## ./lib/lambda/node_modules/mnemonist/trie-map.d.ts

```typescript
/**
 * Mnemonist TrieMap Typings
 * ==========================
 */
export default class TrieMap<K, V> implements Iterable<[K, V]> {

  // Members
  size: number;

  // Constructor
  constructor(Token?: new () => K);

  // Methods
  clear(): void;
  set(prefix: K, value: V): this;
  update(prefix: K, updateFunction: (oldValue: V | undefined) => V): this
  get(prefix: K): V;
  delete(prefix: K): boolean;
  has(prefix: K): boolean;
  find(prefix: K): Array<[K, V]>;
  values(): IterableIterator<V>;
  prefixes(): IterableIterator<K>;
  keys(): IterableIterator<K>;
  entries(): IterableIterator<[K, V]>;
  [Symbol.iterator](): IterableIterator<[K, V]>;
  inspect(): any;

  // Statics
  static from<I, J>(iterable: Iterable<[I, J]> | {[key: string]: J}): TrieMap<I, J>;
}

```

## ./lib/lambda/node_modules/mnemonist/trie.d.ts

```typescript
/**
 * Mnemonist Trie Typings
 * =======================
 */
export default class Trie<T> implements Iterable<T> {

  // Members
  size: number;

  // Constructor
  constructor(Token?: new () => T);

  // Methods
  clear(): void;
  add(prefix: T): this;
  delete(prefix: T): boolean;
  has(prefix: T): boolean;
  find(prefix: T): Array<T>;
  prefixes(): IterableIterator<T>;
  keys(): IterableIterator<T>;
  [Symbol.iterator](): IterableIterator<T>;
  inspect(): any;

  // Statics
  static from<I>(iterable: Iterable<I> | {[key: string]: I}): Trie<I>;
}

```

## ./lib/lambda/node_modules/mnemonist/utils/types.d.ts

```typescript
/**
 * Mnemonist Generic Types
 * ========================
 * 
 * Collection of types used throughout the library.
 */
export interface IArrayLike {
  length: number;
  slice(from: number, to?: number): IArrayLike;
}

export type ArrayLike = IArrayLike | ArrayBuffer;

export interface IArrayLikeConstructor {
  new(...args: any[]): ArrayLike;
}

```

## ./lib/lambda/node_modules/mnemonist/vector.d.ts

```typescript
/**
 * Mnemonist Vector Typings
 * =========================
 */
import {IArrayLikeConstructor} from './utils/types';

type VectorOptions = {
  initialLength?: number;
  initialCapacity?: number;
  policy?: (capacity: number) => number;
}

export default class Vector implements Iterable<number> {

  // Members
  capacity: number;
  length: number;
  size: number;

  // Constructor
  constructor(ArrayClass: IArrayLikeConstructor, length: number | VectorOptions);

  // Methods
  clear(): void;
  set(index: number, value: number): this;
  reallocate(capacity: number): this;
  grow(capacity?: number): this;
  resize(length: number): this;
  push(value: number): number;
  pop(): number | undefined;
  get(index: number): number;
  forEach(callback: (index: number, value: number, set: this) => void, scope?: any): void;
  values(): IterableIterator<number>;
  entries(): IterableIterator<[number, number]>;
  [Symbol.iterator](): IterableIterator<number>;
  inspect(): any;
  toJSON(): any;

  // Statics
  static from<I>(iterable: Iterable<I> | {[key: string] : I}, ArrayClass: IArrayLikeConstructor, capacity?: number): Vector;
}

declare class TypedVector implements Iterable<number> {

  // Members
  capacity: number;
  length: number;
  size: number;

  // Constructor
  constructor(length: number | VectorOptions);

  // Methods
  clear(): void;
  set(index: number, value: number): this;
  reallocate(capacity: number): this;
  grow(capacity?: number): this;
  resize(length: number): this;
  push(value: number): number;
  pop(): number | undefined;
  get(index: number): number;
  forEach(callback: (index: number, value: number, set: this) => void, scope?: any): void;
  values(): IterableIterator<number>;
  entries(): IterableIterator<[number, number]>;
  [Symbol.iterator](): IterableIterator<number>;
  inspect(): any;
  toJSON(): any;

  // Statics
  static from<I>(iterable: Iterable<I> | {[key: string] : I}, capacity?: number): TypedVector;
}

export class Int8Vector extends TypedVector {}
export class Uint8Vector extends TypedVector {}
export class Uint8ClampedVector extends TypedVector {}
export class Int16Vector extends TypedVector {}
export class Uint16Vector extends TypedVector {}
export class Int32Vector extends TypedVector {}
export class Uint32Vector extends TypedVector {}
export class Float32Vector extends TypedVector {}
export class Float64Array extends TypedVector {}

```

## ./lib/lambda/node_modules/mnemonist/vp-tree.d.ts

```typescript
/**
 * Mnemonist VPTree Typings
 * =========================
 */
type DistanceFunction<T> = (a: T, b: T) => number;
type QueryMatch<T> = {distance: number, item: T};

export default class VPTree<T> {

  // Members
  distance: DistanceFunction<T>;
  size: number;
  D: number;

  // Constructor
  constructor(distance: DistanceFunction<T>, items: Iterable<T>);

  // Methods
  nearestNeighbors(k: number, query: T): Array<QueryMatch<T>>;
  neighbors(radius: number, query: T): Array<QueryMatch<T>>;

  // Statics
  static from<I>(
    iterable: Iterable<I> | {[key: string] : I},
    distance: DistanceFunction<I>
  ): VPTree<I>;
}

```

## ./lib/lambda/node_modules/obliterator/chain.d.ts

```typescript
import {default as ObliteratorIterator} from './iterator.js';

export default function chain<T>(...iterators: Iterator<T>[]): ObliteratorIterator<T>;

```

## ./lib/lambda/node_modules/obliterator/combinations.d.ts

```typescript
import {default as ObliteratorIterator} from './iterator.js';

export default function combinations<T>(array: Array<T>, r: number): ObliteratorIterator<Array<T>>;

```

## ./lib/lambda/node_modules/obliterator/consume.d.ts

```typescript
export default function consume<T>(iterator: Iterator<T>, steps?: number): void;

```

## ./lib/lambda/node_modules/obliterator/filter.d.ts

```typescript
import {default as ObliteratorIterator} from './iterator.js';

type PredicateFunction<T> = (item: T) => boolean;

export default function filter<T>(predicate: PredicateFunction<T>, iterator: Iterator<T>): ObliteratorIterator<T>;

```

## ./lib/lambda/node_modules/obliterator/foreach.d.ts

```typescript
export default function forEach(iterable: any, callback: (item: any, key: any) => void): void;

```

## ./lib/lambda/node_modules/obliterator/index.d.ts

```typescript
export {default as Iterator} from './iterator';
export {default as chain} from './chain';
export {default as combinations} from './combinations';
export {default as consume} from './consume';
export {default as filter} from './filter';
export {default as forEach} from './foreach';
export {default as map} from './map';
export {default as match} from './match';
export {default as permutations} from './permutations';
export {default as powerSet} from './power-set';
export {default as range} from './range';
export {default as split} from './split';
export {default as take} from './take';
export {default as takeInto} from './take-into';

```

## ./lib/lambda/node_modules/obliterator/iterator.d.ts

```typescript
type NextFunction<V> = () => IteratorResult<V>;

export default class Iterator<V> implements IterableIterator<V> {

  // Constructor
  constructor(next: NextFunction<V>);

  // Members
  done: boolean;

  // Well-known methods
  next(): IteratorResult<V>;
  [Symbol.iterator](): IterableIterator<V>;

  // Static methods
  static of<T>(...args: T[]): Iterator<T>;
  static empty<T>(): Iterator<T>;
  static is(value: any): boolean;
}

```

## ./lib/lambda/node_modules/obliterator/map.d.ts

```typescript
import {default as ObliteratorIterator} from './iterator.js';

type MapFunction<S, T> = (item: S) => T;

export default function map<S, T>(predicate: MapFunction<S, T>, iterator: Iterator<S>): ObliteratorIterator<T>;

```

## ./lib/lambda/node_modules/obliterator/match.d.ts

```typescript
import {default as ObliteratorIterator} from './iterator.js';

export default function match(pattern: RegExp, string: string): ObliteratorIterator<string>;

```

## ./lib/lambda/node_modules/obliterator/package.json

```json
{
  "name": "obliterator",
  "version": "1.6.1",
  "description": "Higher order iterator library for JavaScript.",
  "main": "index.js",
  "scripts": {
    "lint": "eslint *.js",
    "prepublish": "npm run lint && npm test",
    "test": "mocha test.js && npm run test:types",
    "test:types": "tsc --lib es2015,dom --noEmit --noImplicitAny --noImplicitReturns ./test-types.ts"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/yomguithereal/obliterator.git"
  },
  "keywords": [
    "iterator"
  ],
  "author": {
    "name": "Guillaume Plique",
    "url": "http://github.com/Yomguithereal"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/yomguithereal/obliterator/issues"
  },
  "homepage": "https://github.com/yomguithereal/obliterator#readme",
  "devDependencies": {
    "@yomguithereal/eslint-config": "^4.0.0",
    "eslint": "^6.8.0",
    "mocha": "^7.0.0",
    "typescript": "^3.7.5"
  },
  "eslintConfig": {
    "extends": "@yomguithereal/eslint-config",
    "globals": {
      "ArrayBuffer": true,
      "Map": true,
      "Set": true,
      "Symbol": true,
      "Uint8Array": true,
      "Uint32Array": true
    }
  }
}

```

## ./lib/lambda/node_modules/obliterator/permutations.d.ts

```typescript
import {default as ObliteratorIterator} from './iterator.js';

export default function permutations<T>(array: Array<T>, r: number): ObliteratorIterator<Array<T>>;

```

## ./lib/lambda/node_modules/obliterator/power-set.d.ts

```typescript
import {default as ObliteratorIterator} from './iterator.js';

export default function powerSet<T>(array: Array<T>): ObliteratorIterator<Array<T>>;

```

## ./lib/lambda/node_modules/obliterator/range.d.ts

```typescript
import {default as ObliteratorIterator} from './iterator.js';

export default function range(end: number): ObliteratorIterator<number>;
export default function range(start: number, end: number): ObliteratorIterator<number>;
export default function range(start: number, end: number, step: number): ObliteratorIterator<number>;

```

## ./lib/lambda/node_modules/obliterator/split.d.ts

```typescript
import {default as ObliteratorIterator} from './iterator.js';

export default function split(pattern: RegExp, string: string): ObliteratorIterator<string>;

```

## ./lib/lambda/node_modules/obliterator/take-into.d.ts

```typescript
import {default as ObliteratorIterator} from './iterator.js';

// Requires a resolution of https://github.com/microsoft/TypeScript/issues/1213
// export default function takeInto<C<~>, T>(ArrayClass: new <T>(n: number) => C<T>, iterator: Iterator<T>, n: number): C<T>;
export default function takeInto<T>(ArrayClass: new <T>(arrayLength: number) => T[], iterator: Iterator<T>, n: number): T[];

```

## ./lib/lambda/node_modules/obliterator/take.d.ts

```typescript
import {default as ObliteratorIterator} from './iterator.js';

export default function take<T>(iterator: Iterator<T>, n: number): Array<T>;

```

## ./lib/lambda/node_modules/strnum/.vscode/launch.json

```json
{
    "version": "0.2.0",
    "configurations": [
        {
            "type": "node",
            "request": "launch",
            "name": "Jasmine Tests",
            "program": "${workspaceFolder}/node_modules/jasmine/bin/jasmine.js",
            "args": [
                "${workspaceFolder}/spec/attr_spec.js"
            ],
            "internalConsoleOptions": "openOnSessionStart"
        },{
            "type": "node",
            "request": "launch",
            "name": "Jasmine Tests current test file",
            "program": "${workspaceFolder}/node_modules/jasmine/bin/jasmine.js",
            "args": [
                "${file}"
            ],
            "internalConsoleOptions": "openOnSessionStart"
        }
    ]
   
}
```

## ./lib/lambda/node_modules/strnum/package.json

```json
{
  "name": "strnum",
  "version": "2.1.1",
  "description": "Parse String to Number based on configuration",
  "type": "module",
  "main": "strnum.js",
  "scripts": {
    "test": "jasmine strnum.test.js"
  },
  "keywords": [
    "string",
    "number",
    "parse",
    "convert"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/NaturalIntelligence/strnum"
  },
  "author": "Amit Gupta (https://amitkumargupta.work/)",
  "license": "MIT",
  "funding": [
    {
      "type": "github",
      "url": "https://github.com/sponsors/NaturalIntelligence"
    }
  ],
  "devDependencies": {
    "jasmine": "^5.6.0"
  }
}

```

## ./lib/lambda/node_modules/tslib/modules/index.d.ts

```typescript
// Note: named reexports are used instead of `export *` because
// TypeScript itself doesn't resolve the `export *` when checking
// if a particular helper exists.
export {
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __esDecorate,
  __runInitializers,
  __propKey,
  __setFunctionName,
  __metadata,
  __awaiter,
  __generator,
  __exportStar,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn,
  __createBinding,
  __addDisposableResource,
  __disposeResources,
  __rewriteRelativeImportExtension,
} from '../tslib.js';
export * as default from '../tslib.js';

```

## ./lib/lambda/node_modules/tslib/modules/package.json

```json
{
    "type": "module"
}
```

## ./lib/lambda/node_modules/tslib/package.json

```json
{
    "name": "tslib",
    "author": "Microsoft Corp.",
    "homepage": "https://www.typescriptlang.org/",
    "version": "2.8.1",
    "license": "0BSD",
    "description": "Runtime library for TypeScript helper functions",
    "keywords": [
        "TypeScript",
        "Microsoft",
        "compiler",
        "language",
        "javascript",
        "tslib",
        "runtime"
    ],
    "bugs": {
        "url": "https://github.com/Microsoft/TypeScript/issues"
    },
    "repository": {
        "type": "git",
        "url": "https://github.com/Microsoft/tslib.git"
    },
    "main": "tslib.js",
    "module": "tslib.es6.js",
    "jsnext:main": "tslib.es6.js",
    "typings": "tslib.d.ts",
    "sideEffects": false,
    "exports": {
        ".": {
            "module": {
                "types": "./modules/index.d.ts",
                "default": "./tslib.es6.mjs"
            },
            "import": {
                "node": "./modules/index.js",
                "default": {
                    "types": "./modules/index.d.ts",
                    "default": "./tslib.es6.mjs"
                }
            },
            "default": "./tslib.js"
        },
        "./*": "./*",
        "./": "./"
    }
}

```

## ./lib/lambda/node_modules/tslib/tslib.d.ts

```typescript
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

/**
 * Used to shim class extends.
 *
 * @param d The derived class.
 * @param b The base class.
 */
export declare function __extends(d: Function, b: Function): void;

/**
 * Copy the values of all of the enumerable own properties from one or more source objects to a
 * target object. Returns the target object.
 *
 * @param t The target object to copy to.
 * @param sources One or more source objects from which to copy properties
 */
export declare function __assign(t: any, ...sources: any[]): any;

/**
 * Performs a rest spread on an object.
 *
 * @param t The source value.
 * @param propertyNames The property names excluded from the rest spread.
 */
export declare function __rest(t: any, propertyNames: (string | symbol)[]): any;

/**
 * Applies decorators to a target object
 *
 * @param decorators The set of decorators to apply.
 * @param target The target object.
 * @param key If specified, the own property to apply the decorators to.
 * @param desc The property descriptor, defaults to fetching the descriptor from the target object.
 * @experimental
 */
export declare function __decorate(decorators: Function[], target: any, key?: string | symbol, desc?: any): any;

/**
 * Creates an observing function decorator from a parameter decorator.
 *
 * @param paramIndex The parameter index to apply the decorator to.
 * @param decorator The parameter decorator to apply. Note that the return value is ignored.
 * @experimental
 */
export declare function __param(paramIndex: number, decorator: Function): Function;

/**
 * Applies decorators to a class or class member, following the native ECMAScript decorator specification.
 * @param ctor For non-field class members, the class constructor. Otherwise, `null`.
 * @param descriptorIn The `PropertyDescriptor` to use when unable to look up the property from `ctor`.
 * @param decorators The decorators to apply
 * @param contextIn The `DecoratorContext` to clone for each decorator application.
 * @param initializers An array of field initializer mutation functions into which new initializers are written.
 * @param extraInitializers An array of extra initializer functions into which new initializers are written.
 */
export declare function __esDecorate(ctor: Function | null, descriptorIn: object | null, decorators: Function[], contextIn: object, initializers: Function[] | null, extraInitializers: Function[]): void;

/**
 * Runs field initializers or extra initializers generated by `__esDecorate`.
 * @param thisArg The `this` argument to use.
 * @param initializers The array of initializers to evaluate.
 * @param value The initial value to pass to the initializers.
 */
export declare function __runInitializers(thisArg: unknown, initializers: Function[], value?: any): any;

/**
 * Converts a computed property name into a `string` or `symbol` value.
 */
export declare function __propKey(x: any): string | symbol;

/**
 * Assigns the name of a function derived from the left-hand side of an assignment.
 * @param f The function to rename.
 * @param name The new name for the function.
 * @param prefix A prefix (such as `"get"` or `"set"`) to insert before the name.
 */
export declare function __setFunctionName(f: Function, name: string | symbol, prefix?: string): Function;

/**
 * Creates a decorator that sets metadata.
 *
 * @param metadataKey The metadata key
 * @param metadataValue The metadata value
 * @experimental
 */
export declare function __metadata(metadataKey: any, metadataValue: any): Function;

/**
 * Converts a generator function into a pseudo-async function, by treating each `yield` as an `await`.
 *
 * @param thisArg The reference to use as the `this` value in the generator function
 * @param _arguments The optional arguments array
 * @param P The optional promise constructor argument, defaults to the `Promise` property of the global object.
 * @param generator The generator function
 */
export declare function __awaiter(thisArg: any, _arguments: any, P: Function, generator: Function): any;

/**
 * Creates an Iterator object using the body as the implementation.
 *
 * @param thisArg The reference to use as the `this` value in the function
 * @param body The generator state-machine based implementation.
 *
 * @see [./docs/generator.md]
 */
export declare function __generator(thisArg: any, body: Function): any;

/**
 * Creates bindings for all enumerable properties of `m` on `exports`
 *
 * @param m The source object
 * @param o The `exports` object.
 */
export declare function __exportStar(m: any, o: any): void;

/**
 * Creates a value iterator from an `Iterable` or `ArrayLike` object.
 *
 * @param o The object.
 * @throws {TypeError} If `o` is neither `Iterable`, nor an `ArrayLike`.
 */
export declare function __values(o: any): any;

/**
 * Reads values from an `Iterable` or `ArrayLike` object and returns the resulting array.
 *
 * @param o The object to read from.
 * @param n The maximum number of arguments to read, defaults to `Infinity`.
 */
export declare function __read(o: any, n?: number): any[];

/**
 * Creates an array from iterable spread.
 *
 * @param args The Iterable objects to spread.
 * @deprecated since TypeScript 4.2 - Use `__spreadArray`
 */
export declare function __spread(...args: any[][]): any[];

/**
 * Creates an array from array spread.
 *
 * @param args The ArrayLikes to spread into the resulting array.
 * @deprecated since TypeScript 4.2 - Use `__spreadArray`
 */
export declare function __spreadArrays(...args: any[][]): any[];

/**
 * Spreads the `from` array into the `to` array.
 *
 * @param pack Replace empty elements with `undefined`.
 */
export declare function __spreadArray(to: any[], from: any[], pack?: boolean): any[];

/**
 * Creates an object that signals to `__asyncGenerator` that it shouldn't be yielded,
 * and instead should be awaited and the resulting value passed back to the generator.
 *
 * @param v The value to await.
 */
export declare function __await(v: any): any;

/**
 * Converts a generator function into an async generator function, by using `yield __await`
 * in place of normal `await`.
 *
 * @param thisArg The reference to use as the `this` value in the generator function
 * @param _arguments The optional arguments array
 * @param generator The generator function
 */
export declare function __asyncGenerator(thisArg: any, _arguments: any, generator: Function): any;

/**
 * Used to wrap a potentially async iterator in such a way so that it wraps the result
 * of calling iterator methods of `o` in `__await` instances, and then yields the awaited values.
 *
 * @param o The potentially async iterator.
 * @returns A synchronous iterator yielding `__await` instances on every odd invocation
 *          and returning the awaited `IteratorResult` passed to `next` every even invocation.
 */
export declare function __asyncDelegator(o: any): any;

/**
 * Creates a value async iterator from an `AsyncIterable`, `Iterable` or `ArrayLike` object.
 *
 * @param o The object.
 * @throws {TypeError} If `o` is neither `AsyncIterable`, `Iterable`, nor an `ArrayLike`.
 */
export declare function __asyncValues(o: any): any;

/**
 * Creates a `TemplateStringsArray` frozen object from the `cooked` and `raw` arrays.
 *
 * @param cooked The cooked possibly-sparse array.
 * @param raw The raw string content.
 */
export declare function __makeTemplateObject(cooked: string[], raw: string[]): TemplateStringsArray;

/**
 * Used to shim default and named imports in ECMAScript Modules transpiled to CommonJS.
 *
 * ```js
 * import Default, { Named, Other } from "mod";
 * // or
 * import { default as Default, Named, Other } from "mod";
 * ```
 *
 * @param mod The CommonJS module exports object.
 */
export declare function __importStar<T>(mod: T): T;

/**
 * Used to shim default imports in ECMAScript Modules transpiled to CommonJS.
 *
 * ```js
 * import Default from "mod";
 * ```
 *
 * @param mod The CommonJS module exports object.
 */
export declare function __importDefault<T>(mod: T): T | { default: T };

/**
 * Emulates reading a private instance field.
 *
 * @param receiver The instance from which to read the private field.
 * @param state A WeakMap containing the private field value for an instance.
 * @param kind Either `"f"` for a field, `"a"` for an accessor, or `"m"` for a method.
 *
 * @throws {TypeError} If `state` doesn't have an entry for `receiver`.
 */
export declare function __classPrivateFieldGet<T extends object, V>(
    receiver: T,
    state: { has(o: T): boolean, get(o: T): V | undefined },
    kind?: "f"
): V;

/**
 * Emulates reading a private static field.
 *
 * @param receiver The object from which to read the private static field.
 * @param state The class constructor containing the definition of the static field.
 * @param kind Either `"f"` for a field, `"a"` for an accessor, or `"m"` for a method.
 * @param f The descriptor that holds the static field value.
 *
 * @throws {TypeError} If `receiver` is not `state`.
 */
export declare function __classPrivateFieldGet<T extends new (...args: any[]) => unknown, V>(
    receiver: T,
    state: T,
    kind: "f",
    f: { value: V }
): V;

/**
 * Emulates evaluating a private instance "get" accessor.
 *
 * @param receiver The instance on which to evaluate the private "get" accessor.
 * @param state A WeakSet used to verify an instance supports the private "get" accessor.
 * @param kind Either `"f"` for a field, `"a"` for an accessor, or `"m"` for a method.
 * @param f The "get" accessor function to evaluate.
 *
 * @throws {TypeError} If `state` doesn't have an entry for `receiver`.
 */
export declare function __classPrivateFieldGet<T extends object, V>(
    receiver: T,
    state: { has(o: T): boolean },
    kind: "a",
    f: () => V
): V;

/**
 * Emulates evaluating a private static "get" accessor.
 *
 * @param receiver The object on which to evaluate the private static "get" accessor.
 * @param state The class constructor containing the definition of the static "get" accessor.
 * @param kind Either `"f"` for a field, `"a"` for an accessor, or `"m"` for a method.
 * @param f The "get" accessor function to evaluate.
 *
 * @throws {TypeError} If `receiver` is not `state`.
 */
export declare function __classPrivateFieldGet<T extends new (...args: any[]) => unknown, V>(
    receiver: T,
    state: T,
    kind: "a",
    f: () => V
): V;

/**
 * Emulates reading a private instance method.
 *
 * @param receiver The instance from which to read a private method.
 * @param state A WeakSet used to verify an instance supports the private method.
 * @param kind Either `"f"` for a field, `"a"` for an accessor, or `"m"` for a method.
 * @param f The function to return as the private instance method.
 *
 * @throws {TypeError} If `state` doesn't have an entry for `receiver`.
 */
export declare function __classPrivateFieldGet<T extends object, V extends (...args: any[]) => unknown>(
    receiver: T,
    state: { has(o: T): boolean },
    kind: "m",
    f: V
): V;

/**
 * Emulates reading a private static method.
 *
 * @param receiver The object from which to read the private static method.
 * @param state The class constructor containing the definition of the static method.
 * @param kind Either `"f"` for a field, `"a"` for an accessor, or `"m"` for a method.
 * @param f The function to return as the private static method.
 *
 * @throws {TypeError} If `receiver` is not `state`.
 */
export declare function __classPrivateFieldGet<T extends new (...args: any[]) => unknown, V extends (...args: any[]) => unknown>(
    receiver: T,
    state: T,
    kind: "m",
    f: V
): V;

/**
 * Emulates writing to a private instance field.
 *
 * @param receiver The instance on which to set a private field value.
 * @param state A WeakMap used to store the private field value for an instance.
 * @param value The value to store in the private field.
 * @param kind Either `"f"` for a field, `"a"` for an accessor, or `"m"` for a method.
 *
 * @throws {TypeError} If `state` doesn't have an entry for `receiver`.
 */
export declare function __classPrivateFieldSet<T extends object, V>(
    receiver: T,
    state: { has(o: T): boolean, set(o: T, value: V): unknown },
    value: V,
    kind?: "f"
): V;

/**
 * Emulates writing to a private static field.
 *
 * @param receiver The object on which to set the private static field.
 * @param state The class constructor containing the definition of the private static field.
 * @param value The value to store in the private field.
 * @param kind Either `"f"` for a field, `"a"` for an accessor, or `"m"` for a method.
 * @param f The descriptor that holds the static field value.
 *
 * @throws {TypeError} If `receiver` is not `state`.
 */
export declare function __classPrivateFieldSet<T extends new (...args: any[]) => unknown, V>(
    receiver: T,
    state: T,
    value: V,
    kind: "f",
    f: { value: V }
): V;

/**
 * Emulates writing to a private instance "set" accessor.
 *
 * @param receiver The instance on which to evaluate the private instance "set" accessor.
 * @param state A WeakSet used to verify an instance supports the private "set" accessor.
 * @param value The value to store in the private accessor.
 * @param kind Either `"f"` for a field, `"a"` for an accessor, or `"m"` for a method.
 * @param f The "set" accessor function to evaluate.
 *
 * @throws {TypeError} If `state` doesn't have an entry for `receiver`.
 */
export declare function __classPrivateFieldSet<T extends object, V>(
    receiver: T,
    state: { has(o: T): boolean },
    value: V,
    kind: "a",
    f: (v: V) => void
): V;

/**
 * Emulates writing to a private static "set" accessor.
 *
 * @param receiver The object on which to evaluate the private static "set" accessor.
 * @param state The class constructor containing the definition of the static "set" accessor.
 * @param value The value to store in the private field.
 * @param kind Either `"f"` for a field, `"a"` for an accessor, or `"m"` for a method.
 * @param f The "set" accessor function to evaluate.
 *
 * @throws {TypeError} If `receiver` is not `state`.
 */
export declare function __classPrivateFieldSet<T extends new (...args: any[]) => unknown, V>(
    receiver: T,
    state: T,
    value: V,
    kind: "a",
    f: (v: V) => void
): V;

/**
 * Checks for the existence of a private field/method/accessor.
 *
 * @param state The class constructor containing the static member, or the WeakMap or WeakSet associated with a private instance member.
 * @param receiver The object for which to test the presence of the private member.
 */
export declare function __classPrivateFieldIn(
    state: (new (...args: any[]) => unknown) | { has(o: any): boolean },
    receiver: unknown,
): boolean;

/**
 * Creates a re-export binding on `object` with key `objectKey` that references `target[key]`.
 *
 * @param object The local `exports` object.
 * @param target The object to re-export from.
 * @param key The property key of `target` to re-export.
 * @param objectKey The property key to re-export as. Defaults to `key`.
 */
export declare function __createBinding(object: object, target: object, key: PropertyKey, objectKey?: PropertyKey): void;

/**
 * Adds a disposable resource to a resource-tracking environment object.
 * @param env A resource-tracking environment object.
 * @param value Either a Disposable or AsyncDisposable object, `null`, or `undefined`.
 * @param async When `true`, `AsyncDisposable` resources can be added. When `false`, `AsyncDisposable` resources cannot be added.
 * @returns The {@link value} argument.
 *
 * @throws {TypeError} If {@link value} is not an object, or if either `Symbol.dispose` or `Symbol.asyncDispose` are not
 * defined, or if {@link value} does not have an appropriate `Symbol.dispose` or `Symbol.asyncDispose` method.
 */
export declare function __addDisposableResource<T>(env: { stack: { value?: unknown, dispose?: Function, async: boolean }[]; error: unknown; hasError: boolean; }, value: T, async: boolean): T;

/**
 * Disposes all resources in a resource-tracking environment object.
 * @param env A resource-tracking environment object.
 * @returns A {@link Promise} if any resources in the environment were marked as `async` when added; otherwise, `void`.
 *
 * @throws {SuppressedError} if an error thrown during disposal would have suppressed a prior error from disposal or the
 * error recorded in the resource-tracking environment object.
 * @seealso {@link __addDisposableResource}
 */
export declare function __disposeResources(env: { stack: { value?: unknown, dispose?: Function, async: boolean }[]; error: unknown; hasError: boolean; }): any;

/**
 * Transforms a relative import specifier ending in a non-declaration TypeScript file extension to its JavaScript file extension counterpart.
 * @param path The import specifier.
 * @param preserveJsx Causes '*.tsx' to transform to '*.jsx' instead of '*.js'. Should be true when `--jsx` is set to `preserve`.
 */
export declare function __rewriteRelativeImportExtension(path: string, preserveJsx?: boolean): string;
```

## ./lib/lambda/node_modules/tslib/tslib.es6.mjs

```javascript
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol, Iterator */

var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
  return extendStatics(d, b);
};

export function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() { this.constructor = d; }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

export var __assign = function() {
  __assign = Object.assign || function __assign(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
      return t;
  }
  return __assign.apply(this, arguments);
}

export function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
      }
  return t;
}

export function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

export function __param(paramIndex, decorator) {
  return function (target, key) { decorator(target, key, paramIndex); }
}

export function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
      var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind === "accessor") {
          if (result === void 0) continue;
          if (result === null || typeof result !== "object") throw new TypeError("Object expected");
          if (_ = accept(result.get)) descriptor.get = _;
          if (_ = accept(result.set)) descriptor.set = _;
          if (_ = accept(result.init)) initializers.unshift(_);
      }
      else if (_ = accept(result)) {
          if (kind === "field") initializers.unshift(_);
          else descriptor[key] = _;
      }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};

export function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};

export function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
};

export function __setFunctionName(f, name, prefix) {
  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};

export function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

export function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
  return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
      function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

export function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
  function verb(n) { return function (v) { return step([n, v]); }; }
  function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
              case 0: case 1: t = op; break;
              case 4: _.label++; return { value: op[1], done: false };
              case 5: _.label++; y = op[1]; op = [0]; continue;
              case 7: op = _.ops.pop(); _.trys.pop(); continue;
              default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                  if (t[2]) _.ops.pop();
                  _.trys.pop(); continue;
          }
          op = body.call(thisArg, _);
      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
  }
}

export var __createBinding = Object.create ? (function(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
  }
  Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

export function __exportStar(m, o) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

export function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
      next: function () {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
      }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

export function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  }
  catch (error) { e = { error: error }; }
  finally {
      try {
          if (r && !r.done && (m = i["return"])) m.call(i);
      }
      finally { if (e) throw e.error; }
  }
  return ar;
}

/** @deprecated */
export function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
      ar = ar.concat(__read(arguments[i]));
  return ar;
}

/** @deprecated */
export function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
  return r;
}

export function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
      }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}

export function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}

export function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;
  function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }
  function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }
  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
  function fulfill(value) { resume("next", value); }
  function reject(value) { resume("throw", value); }
  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

export function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }
}

export function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

export function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
  return cooked;
};

var __setModuleDefault = Object.create ? (function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
  o["default"] = v;
};

var ownKeys = function(o) {
  ownKeys = Object.getOwnPropertyNames || function (o) {
    var ar = [];
    for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
    return ar;
  };
  return ownKeys(o);
};

export function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
  __setModuleDefault(result, mod);
  return result;
}

export function __importDefault(mod) {
  return (mod && mod.__esModule) ? mod : { default: mod };
}

export function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

export function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

export function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}

export function __addDisposableResource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };
    env.stack.push({ value: value, dispose: dispose, async: async });
  }
  else if (async) {
    env.stack.push({ async: true });
  }
  return value;
}

var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

export function __disposeResources(env) {
  function fail(e) {
    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
    env.hasError = true;
  }
  var r, s = 0;
  function next() {
    while (r = env.stack.pop()) {
      try {
        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
        if (r.dispose) {
          var result = r.dispose.call(r.value);
          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
        }
        else s |= 1;
      }
      catch (e) {
        fail(e);
      }
    }
    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
    if (env.hasError) throw env.error;
  }
  return next();
}

export function __rewriteRelativeImportExtension(path, preserveJsx) {
  if (typeof path === "string" && /^\.\.?\//.test(path)) {
      return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {
          return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : (d + ext + "." + cm.toLowerCase() + "js");
      });
  }
  return path;
}

export default {
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __esDecorate,
  __runInitializers,
  __propKey,
  __setFunctionName,
  __metadata,
  __awaiter,
  __generator,
  __createBinding,
  __exportStar,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources,
  __rewriteRelativeImportExtension,
};

```

## ./lib/lambda/node_modules/undici-types/agent.d.ts

```typescript
import { URL } from 'url'
import Pool from './pool'
import Dispatcher from "./dispatcher";

export default Agent

declare class Agent extends Dispatcher{
  constructor(opts?: Agent.Options)
  /** `true` after `dispatcher.close()` has been called. */
  closed: boolean;
  /** `true` after `dispatcher.destroyed()` has been called or `dispatcher.close()` has been called and the dispatcher shutdown has completed. */
  destroyed: boolean;
  /** Dispatches a request. */
  dispatch(options: Agent.DispatchOptions, handler: Dispatcher.DispatchHandlers): boolean;
}

declare namespace Agent {
  export interface Options extends Pool.Options {
    /** Default: `(origin, opts) => new Pool(origin, opts)`. */
    factory?(origin: string | URL, opts: Object): Dispatcher;
    /** Integer. Default: `0` */
    maxRedirections?: number;

    interceptors?: { Agent?: readonly Dispatcher.DispatchInterceptor[] } & Pool.Options["interceptors"]
  }

  export interface DispatchOptions extends Dispatcher.DispatchOptions {
    /** Integer. */
    maxRedirections?: number;
  }
}

```

## ./lib/lambda/node_modules/undici-types/api.d.ts

```typescript
import { URL, UrlObject } from 'url'
import { Duplex } from 'stream'
import Dispatcher from './dispatcher'

export {
  request,
  stream,
  pipeline,
  connect,
  upgrade,
}

/** Performs an HTTP request. */
declare function request(
  url: string | URL | UrlObject,
  options?: { dispatcher?: Dispatcher } & Omit<Dispatcher.RequestOptions, 'origin' | 'path' | 'method'> & Partial<Pick<Dispatcher.RequestOptions, 'method'>>,
): Promise<Dispatcher.ResponseData>;

/** A faster version of `request`. */
declare function stream(
  url: string | URL | UrlObject,
  options: { dispatcher?: Dispatcher } & Omit<Dispatcher.RequestOptions, 'origin' | 'path'>,
  factory: Dispatcher.StreamFactory
): Promise<Dispatcher.StreamData>;

/** For easy use with `stream.pipeline`. */
declare function pipeline(
  url: string | URL | UrlObject,
  options: { dispatcher?: Dispatcher } & Omit<Dispatcher.PipelineOptions, 'origin' | 'path'>,
  handler: Dispatcher.PipelineHandler
): Duplex;

/** Starts two-way communications with the requested resource. */
declare function connect(
  url: string | URL | UrlObject,
  options?: { dispatcher?: Dispatcher } & Omit<Dispatcher.ConnectOptions, 'origin' | 'path'>
): Promise<Dispatcher.ConnectData>;

/** Upgrade to a different protocol. */
declare function upgrade(
  url: string | URL | UrlObject,
  options?: { dispatcher?: Dispatcher } & Omit<Dispatcher.UpgradeOptions, 'origin' | 'path'>
): Promise<Dispatcher.UpgradeData>;

```

## ./lib/lambda/node_modules/undici-types/balanced-pool.d.ts

```typescript
import Pool from './pool'
import Dispatcher from './dispatcher'
import { URL } from 'url'

export default BalancedPool

type BalancedPoolConnectOptions = Omit<Dispatcher.ConnectOptions, "origin">;

declare class BalancedPool extends Dispatcher {
  constructor(url: string | string[] | URL | URL[], options?: Pool.Options);

  addUpstream(upstream: string | URL): BalancedPool;
  removeUpstream(upstream: string | URL): BalancedPool;
  upstreams: Array<string>;

  /** `true` after `pool.close()` has been called. */
  closed: boolean;
  /** `true` after `pool.destroyed()` has been called or `pool.close()` has been called and the pool shutdown has completed. */
  destroyed: boolean;

  // Override dispatcher APIs.
  override connect(
    options: BalancedPoolConnectOptions
  ): Promise<Dispatcher.ConnectData>;
  override connect(
    options: BalancedPoolConnectOptions,
    callback: (err: Error | null, data: Dispatcher.ConnectData) => void
  ): void;
}

```

## ./lib/lambda/node_modules/undici-types/cache.d.ts

```typescript
import type { RequestInfo, Response, Request } from './fetch'

export interface CacheStorage {
  match (request: RequestInfo, options?: MultiCacheQueryOptions): Promise<Response | undefined>,
  has (cacheName: string): Promise<boolean>,
  open (cacheName: string): Promise<Cache>,
  delete (cacheName: string): Promise<boolean>,
  keys (): Promise<string[]>
}

declare const CacheStorage: {
  prototype: CacheStorage
  new(): CacheStorage
}

export interface Cache {
  match (request: RequestInfo, options?: CacheQueryOptions): Promise<Response | undefined>,
  matchAll (request?: RequestInfo, options?: CacheQueryOptions): Promise<readonly Response[]>,
  add (request: RequestInfo): Promise<undefined>,
  addAll (requests: RequestInfo[]): Promise<undefined>,
  put (request: RequestInfo, response: Response): Promise<undefined>,
  delete (request: RequestInfo, options?: CacheQueryOptions): Promise<boolean>,
  keys (request?: RequestInfo, options?: CacheQueryOptions): Promise<readonly Request[]>
}

export interface CacheQueryOptions {
  ignoreSearch?: boolean,
  ignoreMethod?: boolean,
  ignoreVary?: boolean
}

export interface MultiCacheQueryOptions extends CacheQueryOptions {
  cacheName?: string
}

export declare const caches: CacheStorage

```

## ./lib/lambda/node_modules/undici-types/client.d.ts

```typescript
import { URL } from 'url'
import { TlsOptions } from 'tls'
import Dispatcher from './dispatcher'
import buildConnector from "./connector";

type ClientConnectOptions = Omit<Dispatcher.ConnectOptions, "origin">;

/**
 * A basic HTTP/1.1 client, mapped on top a single TCP/TLS connection. Pipelining is disabled by default.
 */
export class Client extends Dispatcher {
  constructor(url: string | URL, options?: Client.Options);
  /** Property to get and set the pipelining factor. */
  pipelining: number;
  /** `true` after `client.close()` has been called. */
  closed: boolean;
  /** `true` after `client.destroyed()` has been called or `client.close()` has been called and the client shutdown has completed. */
  destroyed: boolean;

  // Override dispatcher APIs.
  override connect(
    options: ClientConnectOptions
  ): Promise<Dispatcher.ConnectData>;
  override connect(
    options: ClientConnectOptions,
    callback: (err: Error | null, data: Dispatcher.ConnectData) => void
  ): void;
}

export declare namespace Client {
  export interface OptionsInterceptors {
    Client: readonly Dispatcher.DispatchInterceptor[];
  }
  export interface Options {
    /** TODO */
    interceptors?: OptionsInterceptors;
    /** The maximum length of request headers in bytes. Default: Node.js' `--max-http-header-size` or `16384` (16KiB). */
    maxHeaderSize?: number;
    /** The amount of time, in milliseconds, the parser will wait to receive the complete HTTP headers (Node 14 and above only). Default: `300e3` milliseconds (300s). */
    headersTimeout?: number;
    /** @deprecated unsupported socketTimeout, use headersTimeout & bodyTimeout instead */
    socketTimeout?: never;
    /** @deprecated unsupported requestTimeout, use headersTimeout & bodyTimeout instead */
    requestTimeout?: never;
    /** TODO */
    connectTimeout?: number;
    /** The timeout after which a request will time out, in milliseconds. Monitors time between receiving body data. Use `0` to disable it entirely. Default: `300e3` milliseconds (300s). */
    bodyTimeout?: number;
    /** @deprecated unsupported idleTimeout, use keepAliveTimeout instead */
    idleTimeout?: never;
    /** @deprecated unsupported keepAlive, use pipelining=0 instead */
    keepAlive?: never;
    /** the timeout, in milliseconds, after which a socket without active requests will time out. Monitors time between activity on a connected socket. This value may be overridden by *keep-alive* hints from the server. Default: `4e3` milliseconds (4s). */
    keepAliveTimeout?: number;
    /** @deprecated unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead */
    maxKeepAliveTimeout?: never;
    /** the maximum allowed `idleTimeout`, in milliseconds, when overridden by *keep-alive* hints from the server. Default: `600e3` milliseconds (10min). */
    keepAliveMaxTimeout?: number;
    /** A number of milliseconds subtracted from server *keep-alive* hints when overriding `idleTimeout` to account for timing inaccuracies caused by e.g. transport latency. Default: `1e3` milliseconds (1s). */
    keepAliveTimeoutThreshold?: number;
    /** TODO */
    socketPath?: string;
    /** The amount of concurrent requests to be sent over the single TCP/TLS connection according to [RFC7230](https://tools.ietf.org/html/rfc7230#section-6.3.2). Default: `1`. */
    pipelining?: number;
    /** @deprecated use the connect option instead */
    tls?: never;
    /** If `true`, an error is thrown when the request content-length header doesn't match the length of the request body. Default: `true`. */
    strictContentLength?: boolean;
    /** TODO */
    maxCachedSessions?: number;
    /** TODO */
    maxRedirections?: number;
    /** TODO */
    connect?: buildConnector.BuildOptions | buildConnector.connector;
    /** TODO */
    maxRequestsPerClient?: number;
    /** TODO */
    localAddress?: string;
    /** Max response body size in bytes, -1 is disabled */
    maxResponseSize?: number;
    /** Enables a family autodetection algorithm that loosely implements section 5 of RFC 8305. */
    autoSelectFamily?: boolean;
    /** The amount of time in milliseconds to wait for a connection attempt to finish before trying the next address when using the `autoSelectFamily` option. */
    autoSelectFamilyAttemptTimeout?: number;
    /**
     * @description Enables support for H2 if the server has assigned bigger priority to it through ALPN negotiation.
     * @default false
    */
    allowH2?: boolean;
    /**
     * @description Dictates the maximum number of concurrent streams for a single H2 session. It can be overridden by a SETTINGS remote frame.
     * @default 100
    */
    maxConcurrentStreams?: number
  }
  export interface SocketInfo {
    localAddress?: string
    localPort?: number
    remoteAddress?: string
    remotePort?: number
    remoteFamily?: string
    timeout?: number
    bytesWritten?: number
    bytesRead?: number
  }
}

export default Client;

```

## ./lib/lambda/node_modules/undici-types/connector.d.ts

```typescript
import { TLSSocket, ConnectionOptions } from 'tls'
import { IpcNetConnectOpts, Socket, TcpNetConnectOpts } from 'net'

export default buildConnector
declare function buildConnector (options?: buildConnector.BuildOptions): buildConnector.connector

declare namespace buildConnector {
  export type BuildOptions = (ConnectionOptions | TcpNetConnectOpts | IpcNetConnectOpts) & {
    allowH2?: boolean;
    maxCachedSessions?: number | null;
    socketPath?: string | null;
    timeout?: number | null;
    port?: number;
    keepAlive?: boolean | null;
    keepAliveInitialDelay?: number | null;
  }

  export interface Options {
    hostname: string
    host?: string
    protocol: string
    port: string
    servername?: string
    localAddress?: string | null
    httpSocket?: Socket
  }

  export type Callback = (...args: CallbackArgs) => void
  type CallbackArgs = [null, Socket | TLSSocket] | [Error, null]

  export interface connector {
    (options: buildConnector.Options, callback: buildConnector.Callback): void
  }
}

```

## ./lib/lambda/node_modules/undici-types/content-type.d.ts

```typescript
/// <reference types="node" />

interface MIMEType {
  type: string
  subtype: string
  parameters: Map<string, string>
  essence: string
}

/**
 * Parse a string to a {@link MIMEType} object. Returns `failure` if the string
 * couldn't be parsed.
 * @see https://mimesniff.spec.whatwg.org/#parse-a-mime-type
 */
export function parseMIMEType (input: string): 'failure' | MIMEType

/**
 * Convert a MIMEType object to a string.
 * @see https://mimesniff.spec.whatwg.org/#serialize-a-mime-type
 */
export function serializeAMimeType (mimeType: MIMEType): string

```

## ./lib/lambda/node_modules/undici-types/cookies.d.ts

```typescript
/// <reference types="node" />

import type { Headers } from './fetch'

export interface Cookie {
  name: string
  value: string
  expires?: Date | number
  maxAge?: number
  domain?: string
  path?: string
  secure?: boolean
  httpOnly?: boolean
  sameSite?: 'Strict' | 'Lax' | 'None'
  unparsed?: string[]
}

export function deleteCookie (
  headers: Headers,
  name: string,
  attributes?: { name?: string, domain?: string }
): void

export function getCookies (headers: Headers): Record<string, string>

export function getSetCookies (headers: Headers): Cookie[]

export function setCookie (headers: Headers, cookie: Cookie): void

```

## ./lib/lambda/node_modules/undici-types/diagnostics-channel.d.ts

```typescript
import { Socket } from "net";
import { URL } from "url";
import Connector from "./connector";
import Dispatcher from "./dispatcher";

declare namespace DiagnosticsChannel {
  interface Request {
    origin?: string | URL;
    completed: boolean;
    method?: Dispatcher.HttpMethod;
    path: string;
    headers: any;
  }
  interface Response {
    statusCode: number;
    statusText: string;
    headers: Array<Buffer>;
  }
  type Error = unknown;
  interface ConnectParams {
    host: URL["host"];
    hostname: URL["hostname"];
    protocol: URL["protocol"];
    port: URL["port"];
    servername: string | null;
  }
  type Connector = Connector.connector;
  export interface RequestCreateMessage {
    request: Request;
  }
  export interface RequestBodySentMessage {
    request: Request;
  }
  export interface RequestHeadersMessage {
    request: Request;
    response: Response;
  }
  export interface RequestTrailersMessage {
    request: Request;
    trailers: Array<Buffer>;
  }
  export interface RequestErrorMessage {
    request: Request;
    error: Error;
  }
  export interface ClientSendHeadersMessage {
    request: Request;
    headers: string;
    socket: Socket;
  }
  export interface ClientBeforeConnectMessage {
    connectParams: ConnectParams;
    connector: Connector;
  }
  export interface ClientConnectedMessage {
    socket: Socket;
    connectParams: ConnectParams;
    connector: Connector;
  }
  export interface ClientConnectErrorMessage {
    error: Error;
    socket: Socket;
    connectParams: ConnectParams;
    connector: Connector;
  }
}

```

## ./lib/lambda/node_modules/undici-types/dispatcher.d.ts

```typescript
import { URL } from 'url'
import { Duplex, Readable, Writable } from 'stream'
import { EventEmitter } from 'events'
import { Blob } from 'buffer'
import { IncomingHttpHeaders } from './header'
import BodyReadable from './readable'
import { FormData } from './formdata'
import Errors from './errors'

type AbortSignal = unknown;

export default Dispatcher

/** Dispatcher is the core API used to dispatch requests. */
declare class Dispatcher extends EventEmitter {
  /** Dispatches a request. This API is expected to evolve through semver-major versions and is less stable than the preceding higher level APIs. It is primarily intended for library developers who implement higher level APIs on top of this. */
  dispatch(options: Dispatcher.DispatchOptions, handler: Dispatcher.DispatchHandlers): boolean;
  /** Starts two-way communications with the requested resource. */
  connect(options: Dispatcher.ConnectOptions): Promise<Dispatcher.ConnectData>;
  connect(options: Dispatcher.ConnectOptions, callback: (err: Error | null, data: Dispatcher.ConnectData) => void): void;
  /** Compose a chain of dispatchers */
  compose(dispatchers: Dispatcher.DispatcherComposeInterceptor[]): Dispatcher.ComposedDispatcher;
  compose(...dispatchers: Dispatcher.DispatcherComposeInterceptor[]): Dispatcher.ComposedDispatcher;
  /** Performs an HTTP request. */
  request(options: Dispatcher.RequestOptions): Promise<Dispatcher.ResponseData>;
  request(options: Dispatcher.RequestOptions, callback: (err: Error | null, data: Dispatcher.ResponseData) => void): void;
  /** For easy use with `stream.pipeline`. */
  pipeline(options: Dispatcher.PipelineOptions, handler: Dispatcher.PipelineHandler): Duplex;
  /** A faster version of `Dispatcher.request`. */
  stream(options: Dispatcher.RequestOptions, factory: Dispatcher.StreamFactory): Promise<Dispatcher.StreamData>;
  stream(options: Dispatcher.RequestOptions, factory: Dispatcher.StreamFactory, callback: (err: Error | null, data: Dispatcher.StreamData) => void): void;
  /** Upgrade to a different protocol. */
  upgrade(options: Dispatcher.UpgradeOptions): Promise<Dispatcher.UpgradeData>;
  upgrade(options: Dispatcher.UpgradeOptions, callback: (err: Error | null, data: Dispatcher.UpgradeData) => void): void;
  /** Closes the client and gracefully waits for enqueued requests to complete before invoking the callback (or returning a promise if no callback is provided). */
  close(): Promise<void>;
  close(callback: () => void): void;
  /** Destroy the client abruptly with the given err. All the pending and running requests will be asynchronously aborted and error. Waits until socket is closed before invoking the callback (or returning a promise if no callback is provided). Since this operation is asynchronously dispatched there might still be some progress on dispatched requests. */
  destroy(): Promise<void>;
  destroy(err: Error | null): Promise<void>;
  destroy(callback: () => void): void;
  destroy(err: Error | null, callback: () => void): void;

  on(eventName: 'connect', callback: (origin: URL, targets: readonly Dispatcher[]) => void): this;
  on(eventName: 'disconnect', callback: (origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError) => void): this;
  on(eventName: 'connectionError', callback: (origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError) => void): this;
  on(eventName: 'drain', callback: (origin: URL) => void): this;


  once(eventName: 'connect', callback: (origin: URL, targets: readonly Dispatcher[]) => void): this;
  once(eventName: 'disconnect', callback: (origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError) => void): this;
  once(eventName: 'connectionError', callback: (origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError) => void): this;
  once(eventName: 'drain', callback: (origin: URL) => void): this;


  off(eventName: 'connect', callback: (origin: URL, targets: readonly Dispatcher[]) => void): this;
  off(eventName: 'disconnect', callback: (origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError) => void): this;
  off(eventName: 'connectionError', callback: (origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError) => void): this;
  off(eventName: 'drain', callback: (origin: URL) => void): this;


  addListener(eventName: 'connect', callback: (origin: URL, targets: readonly Dispatcher[]) => void): this;
  addListener(eventName: 'disconnect', callback: (origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError) => void): this;
  addListener(eventName: 'connectionError', callback: (origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError) => void): this;
  addListener(eventName: 'drain', callback: (origin: URL) => void): this;

  removeListener(eventName: 'connect', callback: (origin: URL, targets: readonly Dispatcher[]) => void): this;
  removeListener(eventName: 'disconnect', callback: (origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError) => void): this;
  removeListener(eventName: 'connectionError', callback: (origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError) => void): this;
  removeListener(eventName: 'drain', callback: (origin: URL) => void): this;

  prependListener(eventName: 'connect', callback: (origin: URL, targets: readonly Dispatcher[]) => void): this;
  prependListener(eventName: 'disconnect', callback: (origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError) => void): this;
  prependListener(eventName: 'connectionError', callback: (origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError) => void): this;
  prependListener(eventName: 'drain', callback: (origin: URL) => void): this;

  prependOnceListener(eventName: 'connect', callback: (origin: URL, targets: readonly Dispatcher[]) => void): this;
  prependOnceListener(eventName: 'disconnect', callback: (origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError) => void): this;
  prependOnceListener(eventName: 'connectionError', callback: (origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError) => void): this;
  prependOnceListener(eventName: 'drain', callback: (origin: URL) => void): this;

  listeners(eventName: 'connect'): ((origin: URL, targets: readonly Dispatcher[]) => void)[]
  listeners(eventName: 'disconnect'): ((origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError) => void)[];
  listeners(eventName: 'connectionError'): ((origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError) => void)[];
  listeners(eventName: 'drain'): ((origin: URL) => void)[];

  rawListeners(eventName: 'connect'): ((origin: URL, targets: readonly Dispatcher[]) => void)[]
  rawListeners(eventName: 'disconnect'): ((origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError) => void)[];
  rawListeners(eventName: 'connectionError'): ((origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError) => void)[];
  rawListeners(eventName: 'drain'): ((origin: URL) => void)[];

  emit(eventName: 'connect', origin: URL, targets: readonly Dispatcher[]): boolean;
  emit(eventName: 'disconnect', origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError): boolean;
  emit(eventName: 'connectionError', origin: URL, targets: readonly Dispatcher[], error: Errors.UndiciError): boolean;
  emit(eventName: 'drain', origin: URL): boolean;
}

declare namespace Dispatcher {
  export interface ComposedDispatcher extends Dispatcher {}
  export type DispatcherComposeInterceptor = (dispatch: Dispatcher['dispatch']) => Dispatcher['dispatch'];
  export interface DispatchOptions {
    origin?: string | URL;
    path: string;
    method: HttpMethod;
    /** Default: `null` */
    body?: string | Buffer | Uint8Array | Readable | null | FormData;
    /** Default: `null` */
    headers?: IncomingHttpHeaders | string[] | Iterable<[string, string | string[] | undefined]> | null;
    /** Query string params to be embedded in the request URL. Default: `null` */
    query?: Record<string, any>;
    /** Whether the requests can be safely retried or not. If `false` the request won't be sent until all preceding requests in the pipeline have completed. Default: `true` if `method` is `HEAD` or `GET`. */
    idempotent?: boolean;
    /** Whether the response is expected to take a long time and would end up blocking the pipeline. When this is set to `true` further pipelining will be avoided on the same connection until headers have been received. */
    blocking?: boolean;
    /** Upgrade the request. Should be used to specify the kind of upgrade i.e. `'Websocket'`. Default: `method === 'CONNECT' || null`. */
    upgrade?: boolean | string | null;
    /** The amount of time, in milliseconds, the parser will wait to receive the complete HTTP headers. Defaults to 300 seconds. */
    headersTimeout?: number | null;
    /** The timeout after which a request will time out, in milliseconds. Monitors time between receiving body data. Use 0 to disable it entirely. Defaults to 300 seconds. */
    bodyTimeout?: number | null;
    /** Whether the request should stablish a keep-alive or not. Default `false` */
    reset?: boolean;
    /** Whether Undici should throw an error upon receiving a 4xx or 5xx response from the server. Defaults to false */
    throwOnError?: boolean;
    /** For H2, it appends the expect: 100-continue header, and halts the request body until a 100-continue is received from the remote server*/
    expectContinue?: boolean;
  }
  export interface ConnectOptions {
    origin: string | URL;
    path: string;
    /** Default: `null` */
    headers?: IncomingHttpHeaders | string[] | null;
    /** Default: `null` */
    signal?: AbortSignal | EventEmitter | null;
    /** This argument parameter is passed through to `ConnectData` */
    opaque?: unknown;
    /** Default: 0 */
    maxRedirections?: number;
    /** Default: false */
    redirectionLimitReached?: boolean;
    /** Default: `null` */
    responseHeader?: 'raw' | null;
  }
  export interface RequestOptions extends DispatchOptions {
    /** Default: `null` */
    opaque?: unknown;
    /** Default: `null` */
    signal?: AbortSignal | EventEmitter | null;
    /** Default: 0 */
    maxRedirections?: number;
    /** Default: false */
    redirectionLimitReached?: boolean;
    /** Default: `null` */
    onInfo?: (info: { statusCode: number, headers: Record<string, string | string[]> }) => void;
    /** Default: `null` */
    responseHeader?: 'raw' | null;
    /** Default: `64 KiB` */
    highWaterMark?: number;
  }
  export interface PipelineOptions extends RequestOptions {
    /** `true` if the `handler` will return an object stream. Default: `false` */
    objectMode?: boolean;
  }
  export interface UpgradeOptions {
    path: string;
    /** Default: `'GET'` */
    method?: string;
    /** Default: `null` */
    headers?: IncomingHttpHeaders | string[] | null;
    /** A string of comma separated protocols, in descending preference order. Default: `'Websocket'` */
    protocol?: string;
    /** Default: `null` */
    signal?: AbortSignal | EventEmitter | null;
    /** Default: 0 */
    maxRedirections?: number;
    /** Default: false */
    redirectionLimitReached?: boolean;
    /** Default: `null` */
    responseHeader?: 'raw' | null;
  }
  export interface ConnectData {
    statusCode: number;
    headers: IncomingHttpHeaders;
    socket: Duplex;
    opaque: unknown;
  }
  export interface ResponseData {
    statusCode: number;
    headers: IncomingHttpHeaders;
    body: BodyReadable & BodyMixin;
    trailers: Record<string, string>;
    opaque: unknown;
    context: object;
  }
  export interface PipelineHandlerData {
    statusCode: number;
    headers: IncomingHttpHeaders;
    opaque: unknown;
    body: BodyReadable;
    context: object;
  }
  export interface StreamData {
    opaque: unknown;
    trailers: Record<string, string>;
  }
  export interface UpgradeData {
    headers: IncomingHttpHeaders;
    socket: Duplex;
    opaque: unknown;
  }
  export interface StreamFactoryData {
    statusCode: number;
    headers: IncomingHttpHeaders;
    opaque: unknown;
    context: object;
  }
  export type StreamFactory = (data: StreamFactoryData) => Writable;
  export interface DispatchHandlers {
    /** Invoked before request is dispatched on socket. May be invoked multiple times when a request is retried when the request at the head of the pipeline fails. */
    onConnect?(abort: (err?: Error) => void): void;
    /** Invoked when an error has occurred. */
    onError?(err: Error): void;
    /** Invoked when request is upgraded either due to a `Upgrade` header or `CONNECT` method. */
    onUpgrade?(statusCode: number, headers: Buffer[] | string[] | null, socket: Duplex): void;
    /** Invoked when response is received, before headers have been read. **/
    onResponseStarted?(): void;
    /** Invoked when statusCode and headers have been received. May be invoked multiple times due to 1xx informational headers. */
    onHeaders?(statusCode: number, headers: Buffer[], resume: () => void, statusText: string): boolean;
    /** Invoked when response payload data is received. */
    onData?(chunk: Buffer): boolean;
    /** Invoked when response payload and trailers have been received and the request has completed. */
    onComplete?(trailers: string[] | null): void;
    /** Invoked when a body chunk is sent to the server. May be invoked multiple times for chunked requests */
    onBodySent?(chunkSize: number, totalBytesSent: number): void;
  }
  export type PipelineHandler = (data: PipelineHandlerData) => Readable;
  export type HttpMethod = 'GET' | 'HEAD' | 'POST' | 'PUT' | 'DELETE' | 'CONNECT' | 'OPTIONS' | 'TRACE' | 'PATCH';

  /**
   * @link https://fetch.spec.whatwg.org/#body-mixin
   */
  interface BodyMixin {
    readonly body?: never;
    readonly bodyUsed: boolean;
    arrayBuffer(): Promise<ArrayBuffer>;
    blob(): Promise<Blob>;
    bytes(): Promise<Uint8Array>;
    formData(): Promise<never>;
    json(): Promise<unknown>;
    text(): Promise<string>;
  }

  export interface DispatchInterceptor {
    (dispatch: Dispatcher['dispatch']): Dispatcher['dispatch']
  }
}

```

## ./lib/lambda/node_modules/undici-types/env-http-proxy-agent.d.ts

```typescript
import Agent from './agent'
import Dispatcher from './dispatcher'

export default EnvHttpProxyAgent

declare class EnvHttpProxyAgent extends Dispatcher {
  constructor(opts?: EnvHttpProxyAgent.Options)

  dispatch(options: Agent.DispatchOptions, handler: Dispatcher.DispatchHandlers): boolean;
}

declare namespace EnvHttpProxyAgent {
  export interface Options extends Agent.Options {
    /** Overrides the value of the HTTP_PROXY environment variable  */
    httpProxy?: string;
    /** Overrides the value of the HTTPS_PROXY environment variable  */
    httpsProxy?: string;
    /** Overrides the value of the NO_PROXY environment variable  */
    noProxy?: string;
  }
}

```

## ./lib/lambda/node_modules/undici-types/errors.d.ts

```typescript
import { IncomingHttpHeaders } from "./header";
import Client from './client'

export default Errors

declare namespace Errors {
  export class UndiciError extends Error {
    name: string;
    code: string;
  }

  /** Connect timeout error. */
  export class ConnectTimeoutError extends UndiciError {
    name: 'ConnectTimeoutError';
    code: 'UND_ERR_CONNECT_TIMEOUT';
  }

  /** A header exceeds the `headersTimeout` option. */
  export class HeadersTimeoutError extends UndiciError {
    name: 'HeadersTimeoutError';
    code: 'UND_ERR_HEADERS_TIMEOUT';
  }

  /** Headers overflow error. */
  export class HeadersOverflowError extends UndiciError {
    name: 'HeadersOverflowError'
    code: 'UND_ERR_HEADERS_OVERFLOW'
  }

  /** A body exceeds the `bodyTimeout` option. */
  export class BodyTimeoutError extends UndiciError {
    name: 'BodyTimeoutError';
    code: 'UND_ERR_BODY_TIMEOUT';
  }

  export class ResponseStatusCodeError extends UndiciError {
    constructor (
      message?: string,
      statusCode?: number,
      headers?: IncomingHttpHeaders | string[] | null,
      body?: null | Record<string, any> | string
    );
    name: 'ResponseStatusCodeError';
    code: 'UND_ERR_RESPONSE_STATUS_CODE';
    body: null | Record<string, any> | string
    status: number
    statusCode: number
    headers: IncomingHttpHeaders | string[] | null;
  }

  /** Passed an invalid argument. */
  export class InvalidArgumentError extends UndiciError {
    name: 'InvalidArgumentError';
    code: 'UND_ERR_INVALID_ARG';
  }

  /** Returned an invalid value. */
  export class InvalidReturnValueError extends UndiciError {
    name: 'InvalidReturnValueError';
    code: 'UND_ERR_INVALID_RETURN_VALUE';
  }

  /** The request has been aborted by the user. */
  export class RequestAbortedError extends UndiciError {
    name: 'AbortError';
    code: 'UND_ERR_ABORTED';
  }

  /** Expected error with reason. */
  export class InformationalError extends UndiciError {
    name: 'InformationalError';
    code: 'UND_ERR_INFO';
  }

  /** Request body length does not match content-length header. */
  export class RequestContentLengthMismatchError extends UndiciError {
    name: 'RequestContentLengthMismatchError';
    code: 'UND_ERR_REQ_CONTENT_LENGTH_MISMATCH';
  }

  /** Response body length does not match content-length header. */
  export class ResponseContentLengthMismatchError extends UndiciError {
    name: 'ResponseContentLengthMismatchError';
    code: 'UND_ERR_RES_CONTENT_LENGTH_MISMATCH';
  }

  /** Trying to use a destroyed client. */
  export class ClientDestroyedError extends UndiciError {
    name: 'ClientDestroyedError';
    code: 'UND_ERR_DESTROYED';
  }

  /** Trying to use a closed client. */
  export class ClientClosedError extends UndiciError {
    name: 'ClientClosedError';
    code: 'UND_ERR_CLOSED';
  }

  /** There is an error with the socket. */
  export class SocketError extends UndiciError {
    name: 'SocketError';
    code: 'UND_ERR_SOCKET';
    socket: Client.SocketInfo | null
  }

  /** Encountered unsupported functionality. */
  export class NotSupportedError extends UndiciError {
    name: 'NotSupportedError';
    code: 'UND_ERR_NOT_SUPPORTED';
  }

  /** No upstream has been added to the BalancedPool. */
  export class BalancedPoolMissingUpstreamError extends UndiciError {
    name: 'MissingUpstreamError';
    code: 'UND_ERR_BPL_MISSING_UPSTREAM';
  }

  export class HTTPParserError extends UndiciError {
    name: 'HTTPParserError';
    code: string;
  }

  /** The response exceed the length allowed. */
  export class ResponseExceededMaxSizeError extends UndiciError {
    name: 'ResponseExceededMaxSizeError';
    code: 'UND_ERR_RES_EXCEEDED_MAX_SIZE';
  }

  export class RequestRetryError extends UndiciError {
    constructor (
      message: string,
      statusCode: number,
      headers?: IncomingHttpHeaders | string[] | null,
      body?: null | Record<string, any> | string
    );
    name: 'RequestRetryError';
    code: 'UND_ERR_REQ_RETRY';
    statusCode: number;
    data: {
      count: number;
    };
    headers: Record<string, string | string[]>;
  }

  export class SecureProxyConnectionError extends UndiciError {
    name: 'SecureProxyConnectionError';
    code: 'UND_ERR_PRX_TLS';
  }
}

```

## ./lib/lambda/node_modules/undici-types/eventsource.d.ts

```typescript
import { MessageEvent, ErrorEvent } from './websocket'
import Dispatcher from './dispatcher'

import {
  EventListenerOptions,
  AddEventListenerOptions,
  EventListenerOrEventListenerObject
} from './patch'

interface EventSourceEventMap {
  error: ErrorEvent
  message: MessageEvent
  open: Event
}

interface EventSource extends EventTarget {
  close(): void
  readonly CLOSED: 2
  readonly CONNECTING: 0
  readonly OPEN: 1
  onerror: (this: EventSource, ev: ErrorEvent) => any
  onmessage: (this: EventSource, ev: MessageEvent) => any
  onopen: (this: EventSource, ev: Event) => any
  readonly readyState: 0 | 1 | 2
  readonly url: string
  readonly withCredentials: boolean

  addEventListener<K extends keyof EventSourceEventMap>(
    type: K,
    listener: (this: EventSource, ev: EventSourceEventMap[K]) => any,
    options?: boolean | AddEventListenerOptions
  ): void
  addEventListener(
    type: string,
    listener: EventListenerOrEventListenerObject,
    options?: boolean | AddEventListenerOptions
  ): void
  removeEventListener<K extends keyof EventSourceEventMap>(
    type: K,
    listener: (this: EventSource, ev: EventSourceEventMap[K]) => any,
    options?: boolean | EventListenerOptions
  ): void
  removeEventListener(
    type: string,
    listener: EventListenerOrEventListenerObject,
    options?: boolean | EventListenerOptions
  ): void
}

export declare const EventSource: {
  prototype: EventSource
  new (url: string | URL, init?: EventSourceInit): EventSource
  readonly CLOSED: 2
  readonly CONNECTING: 0
  readonly OPEN: 1
}

interface EventSourceInit {
  withCredentials?: boolean,
  dispatcher?: Dispatcher
}

```

## ./lib/lambda/node_modules/undici-types/fetch.d.ts

```typescript
// based on https://github.com/Ethan-Arrowood/undici-fetch/blob/249269714db874351589d2d364a0645d5160ae71/index.d.ts (MIT license)
// and https://github.com/node-fetch/node-fetch/blob/914ce6be5ec67a8bab63d68510aabf07cb818b6d/index.d.ts (MIT license)
/// <reference types="node" />

import { Blob } from 'buffer'
import { URL, URLSearchParams } from 'url'
import { ReadableStream } from 'stream/web'
import { FormData } from './formdata'

import Dispatcher from './dispatcher'

export type RequestInfo = string | URL | Request

export declare function fetch (
  input: RequestInfo,
  init?: RequestInit
): Promise<Response>

export type BodyInit =
  | ArrayBuffer
  | AsyncIterable<Uint8Array>
  | Blob
  | FormData
  | Iterable<Uint8Array>
  | NodeJS.ArrayBufferView
  | URLSearchParams
  | null
  | string

export class BodyMixin {
  readonly body: ReadableStream | null
  readonly bodyUsed: boolean

  readonly arrayBuffer: () => Promise<ArrayBuffer>
  readonly blob: () => Promise<Blob>
  /**
   * @deprecated This method is not recommended for parsing multipart/form-data bodies in server environments.
   * It is recommended to use a library such as [@fastify/busboy](https://www.npmjs.com/package/@fastify/busboy) as follows:
   * 
   * @example
   * ```js
   * import { Busboy } from '@fastify/busboy'
   * import { Readable } from 'node:stream'
   * 
   * const response = await fetch('...')
   * const busboy = new Busboy({ headers: { 'content-type': response.headers.get('content-type') } })
   * 
   * // handle events emitted from `busboy`
   * 
   * Readable.fromWeb(response.body).pipe(busboy)
   * ```
   */
  readonly formData: () => Promise<FormData>
  readonly json: () => Promise<unknown>
  readonly text: () => Promise<string>
}

export interface SpecIterator<T, TReturn = any, TNext = undefined> {
  next(...args: [] | [TNext]): IteratorResult<T, TReturn>;
}

export interface SpecIterableIterator<T> extends SpecIterator<T> {
  [Symbol.iterator](): SpecIterableIterator<T>;
}

export interface SpecIterable<T> {
  [Symbol.iterator](): SpecIterator<T>;
}

export type HeadersInit = string[][] | Record<string, string | ReadonlyArray<string>> | Headers

export declare class Headers implements SpecIterable<[string, string]> {
  constructor (init?: HeadersInit)
  readonly append: (name: string, value: string) => void
  readonly delete: (name: string) => void
  readonly get: (name: string) => string | null
  readonly has: (name: string) => boolean
  readonly set: (name: string, value: string) => void
  readonly getSetCookie: () => string[]
  readonly forEach: (
    callbackfn: (value: string, key: string, iterable: Headers) => void,
    thisArg?: unknown
  ) => void

  readonly keys: () => SpecIterableIterator<string>
  readonly values: () => SpecIterableIterator<string>
  readonly entries: () => SpecIterableIterator<[string, string]>
  readonly [Symbol.iterator]: () => SpecIterableIterator<[string, string]>
}

export type RequestCache =
  | 'default'
  | 'force-cache'
  | 'no-cache'
  | 'no-store'
  | 'only-if-cached'
  | 'reload'

export type RequestCredentials = 'omit' | 'include' | 'same-origin'

type RequestDestination =
  | ''
  | 'audio'
  | 'audioworklet'
  | 'document'
  | 'embed'
  | 'font'
  | 'image'
  | 'manifest'
  | 'object'
  | 'paintworklet'
  | 'report'
  | 'script'
  | 'sharedworker'
  | 'style'
  | 'track'
  | 'video'
  | 'worker'
  | 'xslt'

export interface RequestInit {
  method?: string
  keepalive?: boolean
  headers?: HeadersInit
  body?: BodyInit | null
  redirect?: RequestRedirect
  integrity?: string
  signal?: AbortSignal | null
  credentials?: RequestCredentials
  mode?: RequestMode
  referrer?: string
  referrerPolicy?: ReferrerPolicy
  window?: null
  dispatcher?: Dispatcher
  duplex?: RequestDuplex
}

export type ReferrerPolicy =
  | ''
  | 'no-referrer'
  | 'no-referrer-when-downgrade'
  | 'origin'
  | 'origin-when-cross-origin'
  | 'same-origin'
  | 'strict-origin'
  | 'strict-origin-when-cross-origin'
  | 'unsafe-url';

export type RequestMode = 'cors' | 'navigate' | 'no-cors' | 'same-origin'

export type RequestRedirect = 'error' | 'follow' | 'manual'

export type RequestDuplex = 'half'

export declare class Request extends BodyMixin {
  constructor (input: RequestInfo, init?: RequestInit)

  readonly cache: RequestCache
  readonly credentials: RequestCredentials
  readonly destination: RequestDestination
  readonly headers: Headers
  readonly integrity: string
  readonly method: string
  readonly mode: RequestMode
  readonly redirect: RequestRedirect
  readonly referrer: string
  readonly referrerPolicy: ReferrerPolicy
  readonly url: string

  readonly keepalive: boolean
  readonly signal: AbortSignal
  readonly duplex: RequestDuplex

  readonly clone: () => Request
}

export interface ResponseInit {
  readonly status?: number
  readonly statusText?: string
  readonly headers?: HeadersInit
}

export type ResponseType =
  | 'basic'
  | 'cors'
  | 'default'
  | 'error'
  | 'opaque'
  | 'opaqueredirect'

export type ResponseRedirectStatus = 301 | 302 | 303 | 307 | 308

export declare class Response extends BodyMixin {
  constructor (body?: BodyInit, init?: ResponseInit)

  readonly headers: Headers
  readonly ok: boolean
  readonly status: number
  readonly statusText: string
  readonly type: ResponseType
  readonly url: string
  readonly redirected: boolean

  readonly clone: () => Response

  static error (): Response
  static json(data: any, init?: ResponseInit): Response
  static redirect (url: string | URL, status: ResponseRedirectStatus): Response
}

```

## ./lib/lambda/node_modules/undici-types/file.d.ts

```typescript
// Based on https://github.com/octet-stream/form-data/blob/2d0f0dc371517444ce1f22cdde13f51995d0953a/lib/File.ts (MIT)
/// <reference types="node" />

import { Blob } from 'buffer'

export interface BlobPropertyBag {
  type?: string
  endings?: 'native' | 'transparent'
}

export interface FilePropertyBag extends BlobPropertyBag {
  /**
   * The last modified date of the file as the number of milliseconds since the Unix epoch (January 1, 1970 at midnight). Files without a known last modified date return the current date.
   */
  lastModified?: number
}

export declare class File extends Blob {
  /**
   * Creates a new File instance.
   *
   * @param fileBits An `Array` strings, or [`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer), [`ArrayBufferView`](https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView), [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob) objects, or a mix of any of such objects, that will be put inside the [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File).
   * @param fileName The name of the file.
   * @param options An options object containing optional attributes for the file.
   */
  constructor(fileBits: ReadonlyArray<string | NodeJS.ArrayBufferView | Blob>, fileName: string, options?: FilePropertyBag)

  /**
   * Name of the file referenced by the File object.
   */
  readonly name: string

  /**
   * The last modified date of the file as the number of milliseconds since the Unix epoch (January 1, 1970 at midnight). Files without a known last modified date return the current date.
   */
  readonly lastModified: number

  readonly [Symbol.toStringTag]: string
}

```

## ./lib/lambda/node_modules/undici-types/filereader.d.ts

```typescript
/// <reference types="node" />

import { Blob } from 'buffer'
import { DOMException, EventInit } from './patch'

export declare class FileReader {
  __proto__: EventTarget & FileReader

  constructor ()

  readAsArrayBuffer (blob: Blob): void
  readAsBinaryString (blob: Blob): void
  readAsText (blob: Blob, encoding?: string): void
  readAsDataURL (blob: Blob): void

  abort (): void

  static readonly EMPTY = 0
  static readonly LOADING = 1
  static readonly DONE = 2

  readonly EMPTY = 0
  readonly LOADING = 1
  readonly DONE = 2

  readonly readyState: number

  readonly result: string | ArrayBuffer | null

  readonly error: DOMException | null

  onloadstart: null | ((this: FileReader, event: ProgressEvent) => void)
  onprogress: null | ((this: FileReader, event: ProgressEvent) => void)
  onload: null | ((this: FileReader, event: ProgressEvent) => void)
  onabort: null |  ((this: FileReader, event: ProgressEvent) => void)
  onerror: null | ((this: FileReader, event: ProgressEvent) => void)
  onloadend: null | ((this: FileReader, event: ProgressEvent) => void)
}

export interface ProgressEventInit extends EventInit {
  lengthComputable?: boolean
  loaded?: number
  total?: number
}

export declare class ProgressEvent {
  __proto__: Event & ProgressEvent

  constructor (type: string, eventInitDict?: ProgressEventInit)

  readonly lengthComputable: boolean
  readonly loaded: number
  readonly total: number
}

```

## ./lib/lambda/node_modules/undici-types/formdata.d.ts

```typescript
// Based on https://github.com/octet-stream/form-data/blob/2d0f0dc371517444ce1f22cdde13f51995d0953a/lib/FormData.ts (MIT)
/// <reference types="node" />

import { File } from './file'
import { SpecIterableIterator } from './fetch'

/**
 * A `string` or `File` that represents a single value from a set of `FormData` key-value pairs.
 */
declare type FormDataEntryValue = string | File

/**
 * Provides a way to easily construct a set of key/value pairs representing form fields and their values, which can then be easily sent using fetch().
 */
export declare class FormData {
  /**
   * Appends a new value onto an existing key inside a FormData object,
   * or adds the key if it does not already exist.
   *
   * The difference between `set()` and `append()` is that if the specified key already exists, `set()` will overwrite all existing values with the new one, whereas `append()` will append the new value onto the end of the existing set of values.
   *
   * @param name The name of the field whose data is contained in `value`.
   * @param value The field's value. This can be [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob)
    or [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File). If none of these are specified the value is converted to a string.
   * @param fileName The filename reported to the server, when a Blob or File is passed as the second parameter. The default filename for Blob objects is "blob". The default filename for File objects is the file's filename.
   */
  append(name: string, value: unknown, fileName?: string): void

  /**
   * Set a new value for an existing key inside FormData,
   * or add the new field if it does not already exist.
   *
   * @param name The name of the field whose data is contained in `value`.
   * @param value The field's value. This can be [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob)
    or [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File). If none of these are specified the value is converted to a string.
   * @param fileName The filename reported to the server, when a Blob or File is passed as the second parameter. The default filename for Blob objects is "blob". The default filename for File objects is the file's filename.
   *
   */
  set(name: string, value: unknown, fileName?: string): void

  /**
   * Returns the first value associated with a given key from within a `FormData` object.
   * If you expect multiple values and want all of them, use the `getAll()` method instead.
   *
   * @param {string} name A name of the value you want to retrieve.
   *
   * @returns A `FormDataEntryValue` containing the value. If the key doesn't exist, the method returns null.
   */
  get(name: string): FormDataEntryValue | null

  /**
   * Returns all the values associated with a given key from within a `FormData` object.
   *
   * @param {string} name A name of the value you want to retrieve.
   *
   * @returns An array of `FormDataEntryValue` whose key matches the value passed in the `name` parameter. If the key doesn't exist, the method returns an empty list.
   */
  getAll(name: string): FormDataEntryValue[]

  /**
   * Returns a boolean stating whether a `FormData` object contains a certain key.
   *
   * @param name A string representing the name of the key you want to test for.
   *
   * @return A boolean value.
   */
  has(name: string): boolean

  /**
   * Deletes a key and its value(s) from a `FormData` object.
   *
   * @param name The name of the key you want to delete.
   */
  delete(name: string): void

  /**
   * Executes given callback function for each field of the FormData instance
   */
  forEach: (
    callbackfn: (value: FormDataEntryValue, key: string, iterable: FormData) => void,
    thisArg?: unknown
  ) => void

  /**
   * Returns an [`iterator`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols) allowing to go through all keys contained in this `FormData` object.
   * Each key is a `string`.
   */
  keys: () => SpecIterableIterator<string>

  /**
   * Returns an [`iterator`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols) allowing to go through all values contained in this object `FormData` object.
   * Each value is a [`FormDataValue`](https://developer.mozilla.org/en-US/docs/Web/API/FormDataEntryValue).
   */
  values: () => SpecIterableIterator<FormDataEntryValue>

  /**
   * Returns an [`iterator`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols) allowing to go through the `FormData` key/value pairs.
   * The key of each pair is a string; the value is a [`FormDataValue`](https://developer.mozilla.org/en-US/docs/Web/API/FormDataEntryValue).
   */
  entries: () => SpecIterableIterator<[string, FormDataEntryValue]>

  /**
   * An alias for FormData#entries()
   */
  [Symbol.iterator]: () => SpecIterableIterator<[string, FormDataEntryValue]>

  readonly [Symbol.toStringTag]: string
}

```

## ./lib/lambda/node_modules/undici-types/global-dispatcher.d.ts

```typescript
import Dispatcher from "./dispatcher";

export {
  getGlobalDispatcher,
  setGlobalDispatcher
}

declare function setGlobalDispatcher<DispatcherImplementation extends Dispatcher>(dispatcher: DispatcherImplementation): void;
declare function getGlobalDispatcher(): Dispatcher;

```

## ./lib/lambda/node_modules/undici-types/global-origin.d.ts

```typescript
export {
	setGlobalOrigin,
	getGlobalOrigin
}
  
declare function setGlobalOrigin(origin: string | URL | undefined): void;
declare function getGlobalOrigin(): URL | undefined;
```

## ./lib/lambda/node_modules/undici-types/handlers.d.ts

```typescript
import Dispatcher from "./dispatcher";

export declare class RedirectHandler implements Dispatcher.DispatchHandlers {
  constructor(
    dispatch: Dispatcher,
    maxRedirections: number,
    opts: Dispatcher.DispatchOptions,
    handler: Dispatcher.DispatchHandlers,
    redirectionLimitReached: boolean
  );
}

export declare class DecoratorHandler implements Dispatcher.DispatchHandlers {
  constructor(handler: Dispatcher.DispatchHandlers);
}

```

## ./lib/lambda/node_modules/undici-types/header.d.ts

```typescript
/**
 * The header type declaration of `undici`.
 */
export type IncomingHttpHeaders = Record<string, string | string[] | undefined>;

```

## ./lib/lambda/node_modules/undici-types/index.d.ts

```typescript
import Dispatcher from'./dispatcher'
import { setGlobalDispatcher, getGlobalDispatcher } from './global-dispatcher'
import { setGlobalOrigin, getGlobalOrigin } from './global-origin'
import Pool from'./pool'
import { RedirectHandler, DecoratorHandler } from './handlers'

import BalancedPool from './balanced-pool'
import Client from'./client'
import buildConnector from'./connector'
import errors from'./errors'
import Agent from'./agent'
import MockClient from'./mock-client'
import MockPool from'./mock-pool'
import MockAgent from'./mock-agent'
import mockErrors from'./mock-errors'
import ProxyAgent from'./proxy-agent'
import EnvHttpProxyAgent from './env-http-proxy-agent'
import RetryHandler from'./retry-handler'
import RetryAgent from'./retry-agent'
import { request, pipeline, stream, connect, upgrade } from './api'
import interceptors from './interceptors'

export * from './util'
export * from './cookies'
export * from './eventsource'
export * from './fetch'
export * from './file'
export * from './filereader'
export * from './formdata'
export * from './diagnostics-channel'
export * from './websocket'
export * from './content-type'
export * from './cache'
export { Interceptable } from './mock-interceptor'

export { Dispatcher, BalancedPool, Pool, Client, buildConnector, errors, Agent, request, stream, pipeline, connect, upgrade, setGlobalDispatcher, getGlobalDispatcher, setGlobalOrigin, getGlobalOrigin, interceptors, MockClient, MockPool, MockAgent, mockErrors, ProxyAgent, EnvHttpProxyAgent, RedirectHandler, DecoratorHandler, RetryHandler, RetryAgent }
export default Undici

declare namespace Undici {
  var Dispatcher: typeof import('./dispatcher').default
  var Pool: typeof import('./pool').default;
  var RedirectHandler: typeof import ('./handlers').RedirectHandler
  var DecoratorHandler: typeof import ('./handlers').DecoratorHandler
  var RetryHandler: typeof import ('./retry-handler').default
  var createRedirectInterceptor: typeof import ('./interceptors').default.createRedirectInterceptor
  var BalancedPool: typeof import('./balanced-pool').default;
  var Client: typeof import('./client').default;
  var buildConnector: typeof import('./connector').default;
  var errors: typeof import('./errors').default;
  var Agent: typeof import('./agent').default;
  var setGlobalDispatcher: typeof import('./global-dispatcher').setGlobalDispatcher;
  var getGlobalDispatcher: typeof import('./global-dispatcher').getGlobalDispatcher;
  var request: typeof import('./api').request;
  var stream: typeof import('./api').stream;
  var pipeline: typeof import('./api').pipeline;
  var connect: typeof import('./api').connect;
  var upgrade: typeof import('./api').upgrade;
  var MockClient: typeof import('./mock-client').default;
  var MockPool: typeof import('./mock-pool').default;
  var MockAgent: typeof import('./mock-agent').default;
  var mockErrors: typeof import('./mock-errors').default;
  var fetch: typeof import('./fetch').fetch;
  var Headers: typeof import('./fetch').Headers;
  var Response: typeof import('./fetch').Response;
  var Request: typeof import('./fetch').Request;
  var FormData: typeof import('./formdata').FormData;
  var File: typeof import('./file').File;
  var FileReader: typeof import('./filereader').FileReader;
  var caches: typeof import('./cache').caches;
  var interceptors: typeof import('./interceptors').default;
}

```

## ./lib/lambda/node_modules/undici-types/interceptors.d.ts

```typescript
import Dispatcher from "./dispatcher";
import RetryHandler from "./retry-handler";

export default Interceptors;

declare namespace Interceptors {
  export type DumpInterceptorOpts = { maxSize?: number }
  export type RetryInterceptorOpts = RetryHandler.RetryOptions
  export type RedirectInterceptorOpts = { maxRedirections?: number }
  export type ResponseErrorInterceptorOpts = { throwOnError: boolean }

  export function createRedirectInterceptor(opts: RedirectInterceptorOpts): Dispatcher.DispatcherComposeInterceptor
  export function dump(opts?: DumpInterceptorOpts): Dispatcher.DispatcherComposeInterceptor
  export function retry(opts?: RetryInterceptorOpts): Dispatcher.DispatcherComposeInterceptor
  export function redirect(opts?: RedirectInterceptorOpts): Dispatcher.DispatcherComposeInterceptor
  export function responseError(opts?: ResponseErrorInterceptorOpts): Dispatcher.DispatcherComposeInterceptor
}

```

## ./lib/lambda/node_modules/undici-types/mock-agent.d.ts

```typescript
import Agent from './agent'
import Dispatcher from './dispatcher'
import { Interceptable, MockInterceptor } from './mock-interceptor'
import MockDispatch = MockInterceptor.MockDispatch;

export default MockAgent

interface PendingInterceptor extends MockDispatch {
  origin: string;
}

/** A mocked Agent class that implements the Agent API. It allows one to intercept HTTP requests made through undici and return mocked responses instead. */
declare class MockAgent<TMockAgentOptions extends MockAgent.Options = MockAgent.Options> extends Dispatcher {
  constructor(options?: MockAgent.Options)
  /** Creates and retrieves mock Dispatcher instances which can then be used to intercept HTTP requests. If the number of connections on the mock agent is set to 1, a MockClient instance is returned. Otherwise a MockPool instance is returned. */
  get<TInterceptable extends Interceptable>(origin: string): TInterceptable;
  get<TInterceptable extends Interceptable>(origin: RegExp): TInterceptable;
  get<TInterceptable extends Interceptable>(origin: ((origin: string) => boolean)): TInterceptable;
  /** Dispatches a mocked request. */
  dispatch(options: Agent.DispatchOptions, handler: Dispatcher.DispatchHandlers): boolean;
  /** Closes the mock agent and waits for registered mock pools and clients to also close before resolving. */
  close(): Promise<void>;
  /** Disables mocking in MockAgent. */
  deactivate(): void;
  /** Enables mocking in a MockAgent instance. When instantiated, a MockAgent is automatically activated. Therefore, this method is only effective after `MockAgent.deactivate` has been called. */
  activate(): void;
  /** Define host matchers so only matching requests that aren't intercepted by the mock dispatchers will be attempted. */
  enableNetConnect(): void;
  enableNetConnect(host: string): void;
  enableNetConnect(host: RegExp): void;
  enableNetConnect(host: ((host: string) => boolean)): void;
  /** Causes all requests to throw when requests are not matched in a MockAgent intercept. */
  disableNetConnect(): void;
  pendingInterceptors(): PendingInterceptor[];
  assertNoPendingInterceptors(options?: {
    pendingInterceptorsFormatter?: PendingInterceptorsFormatter;
  }): void;
}

interface PendingInterceptorsFormatter {
  format(pendingInterceptors: readonly PendingInterceptor[]): string;
}

declare namespace MockAgent {
  /** MockAgent options. */
  export interface Options extends Agent.Options {
    /** A custom agent to be encapsulated by the MockAgent. */
    agent?: Agent;
  }
}

```

## ./lib/lambda/node_modules/undici-types/mock-client.d.ts

```typescript
import Client from './client'
import Dispatcher from './dispatcher'
import MockAgent from './mock-agent'
import { MockInterceptor, Interceptable } from './mock-interceptor'

export default MockClient

/** MockClient extends the Client API and allows one to mock requests. */
declare class MockClient extends Client implements Interceptable {
  constructor(origin: string, options: MockClient.Options);
  /** Intercepts any matching requests that use the same origin as this mock client. */
  intercept(options: MockInterceptor.Options): MockInterceptor;
  /** Dispatches a mocked request. */
  dispatch(options: Dispatcher.DispatchOptions, handlers: Dispatcher.DispatchHandlers): boolean;
  /** Closes the mock client and gracefully waits for enqueued requests to complete. */
  close(): Promise<void>;
}

declare namespace MockClient {
  /** MockClient options. */
  export interface Options extends Client.Options {
    /** The agent to associate this MockClient with. */
    agent: MockAgent;
  }
}

```

## ./lib/lambda/node_modules/undici-types/mock-errors.d.ts

```typescript
import Errors from './errors'

export default MockErrors

declare namespace MockErrors {
  /** The request does not match any registered mock dispatches. */
  export class MockNotMatchedError extends Errors.UndiciError {
    constructor(message?: string);
    name: 'MockNotMatchedError';
    code: 'UND_MOCK_ERR_MOCK_NOT_MATCHED';
  }
}

```

## ./lib/lambda/node_modules/undici-types/mock-interceptor.d.ts

```typescript
import { IncomingHttpHeaders } from './header'
import Dispatcher from './dispatcher';
import { BodyInit, Headers } from './fetch'

export {
  Interceptable,
  MockInterceptor,
  MockScope
}

/** The scope associated with a mock dispatch. */
declare class MockScope<TData extends object = object> {
  constructor(mockDispatch: MockInterceptor.MockDispatch<TData>);
  /** Delay a reply by a set amount of time in ms. */
  delay(waitInMs: number): MockScope<TData>;
  /** Persist the defined mock data for the associated reply. It will return the defined mock data indefinitely. */
  persist(): MockScope<TData>;
  /** Define a reply for a set amount of matching requests. */
  times(repeatTimes: number): MockScope<TData>;
}

/** The interceptor for a Mock. */
declare class MockInterceptor {
  constructor(options: MockInterceptor.Options, mockDispatches: MockInterceptor.MockDispatch[]);
  /** Mock an undici request with the defined reply. */
  reply<TData extends object = object>(replyOptionsCallback: MockInterceptor.MockReplyOptionsCallback<TData>): MockScope<TData>;
  reply<TData extends object = object>(
    statusCode: number,
    data?: TData | Buffer | string | MockInterceptor.MockResponseDataHandler<TData>,
    responseOptions?: MockInterceptor.MockResponseOptions
  ): MockScope<TData>;
  /** Mock an undici request by throwing the defined reply error. */
  replyWithError<TError extends Error = Error>(error: TError): MockScope;
  /** Set default reply headers on the interceptor for subsequent mocked replies. */
  defaultReplyHeaders(headers: IncomingHttpHeaders): MockInterceptor;
  /** Set default reply trailers on the interceptor for subsequent mocked replies. */
  defaultReplyTrailers(trailers: Record<string, string>): MockInterceptor;
  /** Set automatically calculated content-length header on subsequent mocked replies. */
  replyContentLength(): MockInterceptor;
}

declare namespace MockInterceptor {
  /** MockInterceptor options. */
  export interface Options {
    /** Path to intercept on. */
    path: string | RegExp | ((path: string) => boolean);
    /** Method to intercept on. Defaults to GET. */
    method?: string | RegExp | ((method: string) => boolean);
    /** Body to intercept on. */
    body?: string | RegExp | ((body: string) => boolean);
    /** Headers to intercept on. */
    headers?: Record<string, string | RegExp | ((body: string) => boolean)> | ((headers: Record<string, string>) => boolean);
    /** Query params to intercept on */
    query?: Record<string, any>;
  }
  export interface MockDispatch<TData extends object = object, TError extends Error = Error> extends Options {
    times: number | null;
    persist: boolean;
    consumed: boolean;
    data: MockDispatchData<TData, TError>;
  }
  export interface MockDispatchData<TData extends object = object, TError extends Error = Error> extends MockResponseOptions {
    error: TError | null;
    statusCode?: number;
    data?: TData | string;
  }
  export interface MockResponseOptions {
    headers?: IncomingHttpHeaders;
    trailers?: Record<string, string>;
  }

  export interface MockResponseCallbackOptions {
    path: string;
    method: string;
    headers?: Headers | Record<string, string>;
    origin?: string;
    body?: BodyInit | Dispatcher.DispatchOptions['body'] | null;
    maxRedirections?: number;
  }

  export type MockResponseDataHandler<TData extends object = object> = (
    opts: MockResponseCallbackOptions
  ) => TData | Buffer | string;

  export type MockReplyOptionsCallback<TData extends object = object> = (
    opts: MockResponseCallbackOptions
  ) => { statusCode: number, data?: TData | Buffer | string, responseOptions?: MockResponseOptions }
}

interface Interceptable extends Dispatcher {
  /** Intercepts any matching requests that use the same origin as this mock client. */
  intercept(options: MockInterceptor.Options): MockInterceptor;
}

```

## ./lib/lambda/node_modules/undici-types/mock-pool.d.ts

```typescript
import Pool from './pool'
import MockAgent from './mock-agent'
import { Interceptable, MockInterceptor } from './mock-interceptor'
import Dispatcher from './dispatcher'

export default MockPool

/** MockPool extends the Pool API and allows one to mock requests. */
declare class MockPool extends Pool implements Interceptable {
  constructor(origin: string, options: MockPool.Options);
  /** Intercepts any matching requests that use the same origin as this mock pool. */
  intercept(options: MockInterceptor.Options): MockInterceptor;
  /** Dispatches a mocked request. */
  dispatch(options: Dispatcher.DispatchOptions, handlers: Dispatcher.DispatchHandlers): boolean;
  /** Closes the mock pool and gracefully waits for enqueued requests to complete. */
  close(): Promise<void>;
}

declare namespace MockPool {
  /** MockPool options. */
  export interface Options extends Pool.Options {
    /** The agent to associate this MockPool with. */
    agent: MockAgent;
  }
}

```

## ./lib/lambda/node_modules/undici-types/package.json

```json
{
  "name": "undici-types",
  "version": "6.21.0",
  "description": "A stand-alone types package for Undici",
  "homepage": "https://undici.nodejs.org",
  "bugs": {
    "url": "https://github.com/nodejs/undici/issues"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/nodejs/undici.git"
  },
  "license": "MIT",
  "types": "index.d.ts",
  "files": [
    "*.d.ts"
  ],
  "contributors": [
    {
      "name": "Daniele Belardi",
      "url": "https://github.com/dnlup",
      "author": true
    },
    {
      "name": "Ethan Arrowood",
      "url": "https://github.com/ethan-arrowood",
      "author": true
    },
    {
      "name": "Matteo Collina",
      "url": "https://github.com/mcollina",
      "author": true
    },
    {
      "name": "Matthew Aitken",
      "url": "https://github.com/KhafraDev",
      "author": true
    },
    {
      "name": "Robert Nagy",
      "url": "https://github.com/ronag",
      "author": true
    },
    {
      "name": "Szymon Marczak",
      "url": "https://github.com/szmarczak",
      "author": true
    },
    {
      "name": "Tomas Della Vedova",
      "url": "https://github.com/delvedor",
      "author": true
    }
  ]
}
```

## ./lib/lambda/node_modules/undici-types/patch.d.ts

```typescript
/// <reference types="node" />

// See https://github.com/nodejs/undici/issues/1740

export type DOMException = typeof globalThis extends { DOMException: infer T }
 ? T
 : any

export interface EventInit {
  bubbles?: boolean
  cancelable?: boolean
  composed?: boolean
}

export interface EventListenerOptions {
  capture?: boolean
}

export interface AddEventListenerOptions extends EventListenerOptions {
  once?: boolean
  passive?: boolean
  signal?: AbortSignal
}

export type EventListenerOrEventListenerObject = EventListener | EventListenerObject

export interface EventListenerObject {
  handleEvent (object: Event): void
}

export interface EventListener {
  (evt: Event): void
}

```

## ./lib/lambda/node_modules/undici-types/pool-stats.d.ts

```typescript
import Pool from "./pool"

export default PoolStats

declare class PoolStats {
  constructor(pool: Pool);
  /** Number of open socket connections in this pool. */
  connected: number;
  /** Number of open socket connections in this pool that do not have an active request. */
  free: number;
  /** Number of pending requests across all clients in this pool. */
  pending: number;
  /** Number of queued requests across all clients in this pool. */
  queued: number;
  /** Number of currently active requests across all clients in this pool. */
  running: number;
  /** Number of active, pending, or queued requests across all clients in this pool. */
  size: number;
}

```

## ./lib/lambda/node_modules/undici-types/pool.d.ts

```typescript
import Client from './client'
import TPoolStats from './pool-stats'
import { URL } from 'url'
import Dispatcher from "./dispatcher";

export default Pool

type PoolConnectOptions = Omit<Dispatcher.ConnectOptions, "origin">;

declare class Pool extends Dispatcher {
  constructor(url: string | URL, options?: Pool.Options)
  /** `true` after `pool.close()` has been called. */
  closed: boolean;
  /** `true` after `pool.destroyed()` has been called or `pool.close()` has been called and the pool shutdown has completed. */
  destroyed: boolean;
  /** Aggregate stats for a Pool. */
  readonly stats: TPoolStats;

  // Override dispatcher APIs.
  override connect(
    options: PoolConnectOptions
  ): Promise<Dispatcher.ConnectData>;
  override connect(
    options: PoolConnectOptions,
    callback: (err: Error | null, data: Dispatcher.ConnectData) => void
  ): void;
}

declare namespace Pool {
  export type PoolStats = TPoolStats;
  export interface Options extends Client.Options {
    /** Default: `(origin, opts) => new Client(origin, opts)`. */
    factory?(origin: URL, opts: object): Dispatcher;
    /** The max number of clients to create. `null` if no limit. Default `null`. */
    connections?: number | null;

    interceptors?: { Pool?: readonly Dispatcher.DispatchInterceptor[] } & Client.Options["interceptors"]
  }
}

```

## ./lib/lambda/node_modules/undici-types/proxy-agent.d.ts

```typescript
import Agent from './agent'
import buildConnector from './connector';
import Dispatcher from './dispatcher'
import { IncomingHttpHeaders } from './header'

export default ProxyAgent

declare class ProxyAgent extends Dispatcher {
  constructor(options: ProxyAgent.Options | string)

  dispatch(options: Agent.DispatchOptions, handler: Dispatcher.DispatchHandlers): boolean;
  close(): Promise<void>;
}

declare namespace ProxyAgent {
  export interface Options extends Agent.Options {
    uri: string;
    /**
     * @deprecated use opts.token
     */
    auth?: string;
    token?: string;
    headers?: IncomingHttpHeaders;
    requestTls?: buildConnector.BuildOptions;
    proxyTls?: buildConnector.BuildOptions;
    clientFactory?(origin: URL, opts: object): Dispatcher;
  }
}

```

## ./lib/lambda/node_modules/undici-types/readable.d.ts

```typescript
import { Readable } from "stream";
import { Blob } from 'buffer'

export default BodyReadable

declare class BodyReadable extends Readable {
  constructor(
    resume?: (this: Readable, size: number) => void | null,
    abort?: () => void | null,
    contentType?: string
  )

  /** Consumes and returns the body as a string
   *  https://fetch.spec.whatwg.org/#dom-body-text
   */
  text(): Promise<string>

  /** Consumes and returns the body as a JavaScript Object
   *  https://fetch.spec.whatwg.org/#dom-body-json
   */
  json(): Promise<unknown>

  /** Consumes and returns the body as a Blob
   *  https://fetch.spec.whatwg.org/#dom-body-blob
   */
  blob(): Promise<Blob>

  /** Consumes and returns the body as an Uint8Array
   *  https://fetch.spec.whatwg.org/#dom-body-bytes
   */
  bytes(): Promise<Uint8Array>

  /** Consumes and returns the body as an ArrayBuffer
   *  https://fetch.spec.whatwg.org/#dom-body-arraybuffer
   */
  arrayBuffer(): Promise<ArrayBuffer>

  /** Not implemented
   *
   *  https://fetch.spec.whatwg.org/#dom-body-formdata
   */
  formData(): Promise<never>

  /** Returns true if the body is not null and the body has been consumed
   *
   *  Otherwise, returns false
   *
   * https://fetch.spec.whatwg.org/#dom-body-bodyused
   */
  readonly bodyUsed: boolean

  /** 
   * If body is null, it should return null as the body
   *
   *  If body is not null, should return the body as a ReadableStream
   *
   *  https://fetch.spec.whatwg.org/#dom-body-body
   */
  readonly body: never | undefined

  /** Dumps the response body by reading `limit` number of bytes.
   * @param opts.limit Number of bytes to read (optional) - Default: 262144
   */
  dump(opts?: { limit: number }): Promise<void>
}

```

## ./lib/lambda/node_modules/undici-types/retry-agent.d.ts

```typescript
import Dispatcher from './dispatcher'
import RetryHandler from './retry-handler'

export default RetryAgent

declare class RetryAgent extends Dispatcher {
  constructor(dispatcher: Dispatcher, options?: RetryHandler.RetryOptions)
}

```

## ./lib/lambda/node_modules/undici-types/retry-handler.d.ts

```typescript
import Dispatcher from "./dispatcher";

export default RetryHandler;

declare class RetryHandler implements Dispatcher.DispatchHandlers {
  constructor(
    options: Dispatcher.DispatchOptions & {
      retryOptions?: RetryHandler.RetryOptions;
    },
    retryHandlers: RetryHandler.RetryHandlers
  );
}

declare namespace RetryHandler {
  export type RetryState = { counter: number; };

  export type RetryContext = {
    state: RetryState;
    opts: Dispatcher.DispatchOptions & {
      retryOptions?: RetryHandler.RetryOptions;
    };
  }

  export type OnRetryCallback = (result?: Error | null) => void;

  export type RetryCallback = (
    err: Error,
    context: {
      state: RetryState;
      opts: Dispatcher.DispatchOptions & {
        retryOptions?: RetryHandler.RetryOptions;
      };
    },
    callback: OnRetryCallback
  ) => number | null;

  export interface RetryOptions {
    /**
     * Callback to be invoked on every retry iteration.
     * It receives the error, current state of the retry object and the options object
     * passed when instantiating the retry handler.
     *
     * @type {RetryCallback}
     * @memberof RetryOptions
     */
    retry?: RetryCallback;
    /**
     * Maximum number of retries to allow.
     *
     * @type {number}
     * @memberof RetryOptions
     * @default 5
     */
    maxRetries?: number;
    /**
     * Max number of milliseconds allow between retries
     *
     * @type {number}
     * @memberof RetryOptions
     * @default 30000
     */
    maxTimeout?: number;
    /**
     * Initial number of milliseconds to wait before retrying for the first time.
     *
     * @type {number}
     * @memberof RetryOptions
     * @default 500
     */
    minTimeout?: number;
    /**
     * Factior to multiply the timeout factor between retries.
     *
     * @type {number}
     * @memberof RetryOptions
     * @default 2
     */
    timeoutFactor?: number;
    /**
     * It enables to automatically infer timeout between retries based on the `Retry-After` header.
     *
     * @type {boolean}
     * @memberof RetryOptions
     * @default true
     */
    retryAfter?: boolean;
    /**
     * HTTP methods to retry.
     *
     * @type {Dispatcher.HttpMethod[]}
     * @memberof RetryOptions
     * @default ['GET', 'HEAD', 'OPTIONS', 'PUT', 'DELETE', 'TRACE'],
     */
    methods?: Dispatcher.HttpMethod[];
    /**
     * Error codes to be retried. e.g. `ECONNRESET`, `ENOTFOUND`, `ETIMEDOUT`, `ECONNREFUSED`, etc.
     *
     * @type {string[]}
     * @default ['ECONNRESET','ECONNREFUSED','ENOTFOUND','ENETDOWN','ENETUNREACH','EHOSTDOWN','EHOSTUNREACH','EPIPE']
     */
    errorCodes?: string[];
    /**
     * HTTP status codes to be retried.
     *
     * @type {number[]}
     * @memberof RetryOptions
     * @default [500, 502, 503, 504, 429],
     */
    statusCodes?: number[];
  }

  export interface RetryHandlers {
    dispatch: Dispatcher["dispatch"];
    handler: Dispatcher.DispatchHandlers;
  }
}

```

## ./lib/lambda/node_modules/undici-types/util.d.ts

```typescript
export namespace util {
  /**
   * Retrieves a header name and returns its lowercase value.
   * @param value Header name
   */
  export function headerNameToString(value: string | Buffer): string;

  /**
   * Receives a header object and returns the parsed value.
   * @param headers Header object
   * @param obj Object to specify a proxy object. Used to assign parsed values.
   * @returns If `obj` is specified, it is equivalent to `obj`.
   */
  export function parseHeaders(
    headers: (Buffer | string | (Buffer | string)[])[],
    obj?: Record<string, string | string[]>
  ): Record<string, string | string[]>;
}

```

## ./lib/lambda/node_modules/undici-types/webidl.d.ts

```typescript
// These types are not exported, and are only used internally

/**
 * Take in an unknown value and return one that is of type T
 */
type Converter<T> = (object: unknown) => T

type SequenceConverter<T> = (object: unknown, iterable?: IterableIterator<T>) => T[]

type RecordConverter<K extends string, V> = (object: unknown) => Record<K, V>

interface ConvertToIntOpts {
  clamp?: boolean
  enforceRange?: boolean
}

interface WebidlErrors {
  exception (opts: { header: string, message: string }): TypeError
  /**
   * @description Throw an error when conversion from one type to another has failed
   */
  conversionFailed (opts: {
    prefix: string
    argument: string
    types: string[]
  }): TypeError
  /**
   * @description Throw an error when an invalid argument is provided
   */
  invalidArgument (opts: {
    prefix: string
    value: string
    type: string
  }): TypeError
}

interface WebidlUtil {
  /**
   * @see https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values
   */
  Type (object: unknown):
    | 'Undefined'
    | 'Boolean'
    | 'String'
    | 'Symbol'
    | 'Number'
    | 'BigInt'
    | 'Null'
    | 'Object'

  /**
   * @see https://webidl.spec.whatwg.org/#abstract-opdef-converttoint
   */
  ConvertToInt (
    V: unknown,
    bitLength: number,
    signedness: 'signed' | 'unsigned',
    opts?: ConvertToIntOpts
  ): number

  /**
   * @see https://webidl.spec.whatwg.org/#abstract-opdef-converttoint
   */
  IntegerPart (N: number): number

  /**
   * Stringifies {@param V}
   */
  Stringify (V: any): string

  /**
   * Mark a value as uncloneable for Node.js.
   * This is only effective in some newer Node.js versions.
   */
  markAsUncloneable (V: any): void
}

interface WebidlConverters {
  /**
   * @see https://webidl.spec.whatwg.org/#es-DOMString
   */
  DOMString (V: unknown, prefix: string, argument: string, opts?: {
    legacyNullToEmptyString: boolean
  }): string

  /**
   * @see https://webidl.spec.whatwg.org/#es-ByteString
   */
  ByteString (V: unknown, prefix: string, argument: string): string

  /**
   * @see https://webidl.spec.whatwg.org/#es-USVString
   */
  USVString (V: unknown): string

  /**
   * @see https://webidl.spec.whatwg.org/#es-boolean
   */
  boolean (V: unknown): boolean

  /**
   * @see https://webidl.spec.whatwg.org/#es-any
   */
  any <Value>(V: Value): Value

  /**
   * @see https://webidl.spec.whatwg.org/#es-long-long
   */
  ['long long'] (V: unknown): number

  /**
   * @see https://webidl.spec.whatwg.org/#es-unsigned-long-long
   */
  ['unsigned long long'] (V: unknown): number

  /**
   * @see https://webidl.spec.whatwg.org/#es-unsigned-long
   */
  ['unsigned long'] (V: unknown): number

  /**
   * @see https://webidl.spec.whatwg.org/#es-unsigned-short
   */
  ['unsigned short'] (V: unknown, opts?: ConvertToIntOpts): number

  /**
   * @see https://webidl.spec.whatwg.org/#idl-ArrayBuffer
   */
  ArrayBuffer (V: unknown): ArrayBufferLike
  ArrayBuffer (V: unknown, opts: { allowShared: false }): ArrayBuffer

  /**
   * @see https://webidl.spec.whatwg.org/#es-buffer-source-types
   */
  TypedArray (
    V: unknown,
    TypedArray: NodeJS.TypedArray | ArrayBufferLike
  ): NodeJS.TypedArray | ArrayBufferLike
  TypedArray (
    V: unknown,
    TypedArray: NodeJS.TypedArray | ArrayBufferLike,
    opts?: { allowShared: false }
  ): NodeJS.TypedArray | ArrayBuffer

  /**
   * @see https://webidl.spec.whatwg.org/#es-buffer-source-types
   */
  DataView (V: unknown, opts?: { allowShared: boolean }): DataView

  /**
   * @see https://webidl.spec.whatwg.org/#BufferSource
   */
  BufferSource (
    V: unknown,
    opts?: { allowShared: boolean }
  ): NodeJS.TypedArray | ArrayBufferLike | DataView

  ['sequence<ByteString>']: SequenceConverter<string>
  
  ['sequence<sequence<ByteString>>']: SequenceConverter<string[]>

  ['record<ByteString, ByteString>']: RecordConverter<string, string>

  [Key: string]: (...args: any[]) => unknown
}

export interface Webidl {
  errors: WebidlErrors
  util: WebidlUtil
  converters: WebidlConverters

  /**
   * @description Performs a brand-check on {@param V} to ensure it is a
   * {@param cls} object.
   */
  brandCheck <Interface>(V: unknown, cls: Interface, opts?: { strict?: boolean }): asserts V is Interface

  /**
   * @see https://webidl.spec.whatwg.org/#es-sequence
   * @description Convert a value, V, to a WebIDL sequence type.
   */
  sequenceConverter <Type>(C: Converter<Type>): SequenceConverter<Type>

  illegalConstructor (): never

  /**
   * @see https://webidl.spec.whatwg.org/#es-to-record
   * @description Convert a value, V, to a WebIDL record type.
   */
  recordConverter <K extends string, V>(
    keyConverter: Converter<K>,
    valueConverter: Converter<V>
  ): RecordConverter<K, V>

  /**
   * Similar to {@link Webidl.brandCheck} but allows skipping the check if third party
   * interfaces are allowed.
   */
  interfaceConverter <Interface>(cls: Interface): (
    V: unknown,
    opts?: { strict: boolean }
  ) => asserts V is typeof cls

  // TODO(@KhafraDev): a type could likely be implemented that can infer the return type
  // from the converters given?
  /**
   * Converts a value, V, to a WebIDL dictionary types. Allows limiting which keys are
   * allowed, values allowed, optional and required keys. Auto converts the value to
   * a type given a converter.
   */
  dictionaryConverter (converters: {
    key: string,
    defaultValue?: () => unknown,
    required?: boolean,
    converter: (...args: unknown[]) => unknown,
    allowedValues?: unknown[]
  }[]): (V: unknown) => Record<string, unknown>

  /**
   * @see https://webidl.spec.whatwg.org/#idl-nullable-type
   * @description allows a type, V, to be null
   */
  nullableConverter <T>(
    converter: Converter<T>
  ): (V: unknown) => ReturnType<typeof converter> | null

  argumentLengthCheck (args: { length: number }, min: number, context: string): void
}

```

## ./lib/lambda/node_modules/undici-types/websocket.d.ts

```typescript
/// <reference types="node" />

import type { Blob } from 'buffer'
import type { MessagePort } from 'worker_threads'
import {
  EventInit,
  EventListenerOptions,
  AddEventListenerOptions,
  EventListenerOrEventListenerObject
} from './patch'
import Dispatcher from './dispatcher'
import { HeadersInit } from './fetch'

export type BinaryType = 'blob' | 'arraybuffer'

interface WebSocketEventMap {
  close: CloseEvent
  error: ErrorEvent
  message: MessageEvent
  open: Event
}

interface WebSocket extends EventTarget {
  binaryType: BinaryType
  
  readonly bufferedAmount: number
  readonly extensions: string

  onclose: ((this: WebSocket, ev: WebSocketEventMap['close']) => any) | null
  onerror: ((this: WebSocket, ev: WebSocketEventMap['error']) => any) | null
  onmessage: ((this: WebSocket, ev: WebSocketEventMap['message']) => any) | null
  onopen: ((this: WebSocket, ev: WebSocketEventMap['open']) => any) | null

  readonly protocol: string
  readonly readyState: number
  readonly url: string

  close(code?: number, reason?: string): void
  send(data: string | ArrayBufferLike | Blob | ArrayBufferView): void

  readonly CLOSED: number
  readonly CLOSING: number
  readonly CONNECTING: number
  readonly OPEN: number

  addEventListener<K extends keyof WebSocketEventMap>(
    type: K,
    listener: (this: WebSocket, ev: WebSocketEventMap[K]) => any,
    options?: boolean | AddEventListenerOptions
  ): void
  addEventListener(
    type: string,
    listener: EventListenerOrEventListenerObject,
    options?: boolean | AddEventListenerOptions
  ): void
  removeEventListener<K extends keyof WebSocketEventMap>(
    type: K,
    listener: (this: WebSocket, ev: WebSocketEventMap[K]) => any,
    options?: boolean | EventListenerOptions
  ): void
  removeEventListener(
    type: string,
    listener: EventListenerOrEventListenerObject,
    options?: boolean | EventListenerOptions
  ): void
}

export declare const WebSocket: {
  prototype: WebSocket
  new (url: string | URL, protocols?: string | string[] | WebSocketInit): WebSocket
  readonly CLOSED: number
  readonly CLOSING: number
  readonly CONNECTING: number
  readonly OPEN: number
}

interface CloseEventInit extends EventInit {
  code?: number
  reason?: string
  wasClean?: boolean
}

interface CloseEvent extends Event {
  readonly code: number
  readonly reason: string
  readonly wasClean: boolean
}

export declare const CloseEvent: {
  prototype: CloseEvent
  new (type: string, eventInitDict?: CloseEventInit): CloseEvent
}

interface MessageEventInit<T = any> extends EventInit {
  data?: T
  lastEventId?: string
  origin?: string
  ports?: (typeof MessagePort)[]
  source?: typeof MessagePort | null
}

interface MessageEvent<T = any> extends Event {
  readonly data: T
  readonly lastEventId: string
  readonly origin: string
  readonly ports: ReadonlyArray<typeof MessagePort>
  readonly source: typeof MessagePort | null
  initMessageEvent(
    type: string,
    bubbles?: boolean,
    cancelable?: boolean,
    data?: any,
    origin?: string,
    lastEventId?: string,
    source?: typeof MessagePort | null,
    ports?: (typeof MessagePort)[]
  ): void;
}

export declare const MessageEvent: {
  prototype: MessageEvent
  new<T>(type: string, eventInitDict?: MessageEventInit<T>): MessageEvent<T>
}

interface ErrorEventInit extends EventInit {
  message?: string
  filename?: string
  lineno?: number
  colno?: number
  error?: any
}

interface ErrorEvent extends Event {
  readonly message: string
  readonly filename: string
  readonly lineno: number
  readonly colno: number
  readonly error: any
}

export declare const ErrorEvent: {
  prototype: ErrorEvent
  new (type: string, eventInitDict?: ErrorEventInit): ErrorEvent
}

interface WebSocketInit {
  protocols?: string | string[],
  dispatcher?: Dispatcher,
  headers?: HeadersInit
}

```

## ./lib/tap-stack.ts

```typescript
import * as cdk from 'aws-cdk-lib';
import * as apigateway from 'aws-cdk-lib/aws-apigateway';
import * as dynamodb from 'aws-cdk-lib/aws-dynamodb';
import * as ec2 from 'aws-cdk-lib/aws-ec2';
import * as iam from 'aws-cdk-lib/aws-iam';
import * as lambda from 'aws-cdk-lib/aws-lambda';
import { NodejsFunction } from 'aws-cdk-lib/aws-lambda-nodejs';
import * as logs from 'aws-cdk-lib/aws-logs';
import * as s3 from 'aws-cdk-lib/aws-s3';
import * as secretsmanager from 'aws-cdk-lib/aws-secretsmanager';
import { Construct } from 'constructs';

interface TapStackProps extends cdk.StackProps {
  environmentSuffix?: string;
}

export class TapStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: TapStackProps) {
    super(scope, id, props);

    // Get environment suffix from props, context, or use 'dev' as default
    const environmentSuffix =
      props?.environmentSuffix ||
      this.node.tryGetContext('environmentSuffix') ||
      'dev';

    // ==================== VPC Configuration ====================
    // Create VPC for API Gateway
    const vpc = new ec2.Vpc(this, `TapVpc-${environmentSuffix}`, {
      vpcName: `tap-vpc-${environmentSuffix}`,
      maxAzs: 2,
      natGateways: 1,
      subnetConfiguration: [
        {
          cidrMask: 24,
          name: 'Public',
          subnetType: ec2.SubnetType.PUBLIC,
        },
        {
          cidrMask: 24,
          name: 'Private',
          subnetType: ec2.SubnetType.PRIVATE_WITH_EGRESS,
        },
      ],
    });
    cdk.Tags.of(vpc).add('iac-rlhf-amazon', 'true');

    // VPC Endpoint for API Gateway
    const apiGatewayEndpoint = vpc.addInterfaceEndpoint('ApiGatewayEndpoint', {
      service: ec2.InterfaceVpcEndpointAwsService.APIGATEWAY,
    });
    cdk.Tags.of(apiGatewayEndpoint).add('iac-rlhf-amazon', 'true');

    // ==================== S3 Bucket ====================
    // S3 bucket for static files storage
    const staticFilesBucket = new s3.Bucket(
      this,
      `StaticFilesBucket-${environmentSuffix}`,
      {
        bucketName: `tap-static-files-${environmentSuffix}-${this.account}`,
        versioned: true,
        encryption: s3.BucketEncryption.S3_MANAGED,
        blockPublicAccess: s3.BlockPublicAccess.BLOCK_ALL,
        removalPolicy: cdk.RemovalPolicy.RETAIN,
        cors: [
          {
            allowedHeaders: ['*'],
            allowedMethods: [
              s3.HttpMethods.GET,
              s3.HttpMethods.PUT,
              s3.HttpMethods.POST,
              s3.HttpMethods.DELETE,
              s3.HttpMethods.HEAD,
            ],
            allowedOrigins: ['*'],
            exposedHeaders: ['ETag'],
            maxAge: 3000,
          },
        ],
      }
    );
    cdk.Tags.of(staticFilesBucket).add('iac-rlhf-amazon', 'true');

    // ==================== DynamoDB Table ====================
    // DynamoDB table for application data
    const applicationTable = new dynamodb.Table(
      this,
      `ApplicationTable-${environmentSuffix}`,
      {
        tableName: `tap-application-table-${environmentSuffix}`,
        partitionKey: {
          name: 'id',
          type: dynamodb.AttributeType.STRING,
        },
        sortKey: {
          name: 'timestamp',
          type: dynamodb.AttributeType.NUMBER,
        },
        billingMode: dynamodb.BillingMode.PAY_PER_REQUEST,
        pointInTimeRecovery: true,
        encryption: dynamodb.TableEncryption.AWS_MANAGED,
        removalPolicy: cdk.RemovalPolicy.RETAIN,
      }
    );

    // Add Global Secondary Index for additional query patterns
    applicationTable.addGlobalSecondaryIndex({
      indexName: 'StatusIndex',
      partitionKey: {
        name: 'status',
        type: dynamodb.AttributeType.STRING,
      },
      sortKey: {
        name: 'timestamp',
        type: dynamodb.AttributeType.NUMBER,
      },
      projectionType: dynamodb.ProjectionType.ALL,
    });
    cdk.Tags.of(applicationTable).add('iac-rlhf-amazon', 'true');

    // ==================== Secrets Manager ====================
    // Secrets Manager for storing sensitive data
    const apiSecrets = new secretsmanager.Secret(
      this,
      `ApiSecrets-${environmentSuffix}`,
      {
        secretName: `tap-api-secrets-${environmentSuffix}`,
        description: 'API keys and other sensitive configuration',
        generateSecretString: {
          secretStringTemplate: JSON.stringify({
            apiKey: 'default-api-key',
            dbPassword: 'default-db-password',
          }),
          generateStringKey: 'secretToken',
          excludeCharacters: ' %+~`#$&*()|[]{}:;<>?!\'/@"\\',
        },
      }
    );
    cdk.Tags.of(apiSecrets).add('iac-rlhf-amazon', 'true');

    // ==================== CloudWatch Log Groups ====================
    // Log group for Lambda functions
    const lambdaLogGroup = new logs.LogGroup(
      this,
      `LambdaLogGroup-${environmentSuffix}`,
      {
        logGroupName: `/aws/lambda/tap-${environmentSuffix}`,
        retention: logs.RetentionDays.TWO_WEEKS,
        removalPolicy: cdk.RemovalPolicy.DESTROY,
      }
    );
    cdk.Tags.of(lambdaLogGroup).add('iac-rlhf-amazon', 'true');

    // ==================== IAM Role for Lambda ====================
    // IAM role for Lambda execution
    const lambdaExecutionRole = new iam.Role(
      this,
      `LambdaExecutionRole-${environmentSuffix}`,
      {
        roleName: `tap-lambda-execution-role-${environmentSuffix}`,
        assumedBy: new iam.ServicePrincipal('lambda.amazonaws.com'),
        managedPolicies: [
          iam.ManagedPolicy.fromAwsManagedPolicyName(
            'service-role/AWSLambdaVPCAccessExecutionRole'
          ),
        ],
        inlinePolicies: {
          CustomPolicy: new iam.PolicyDocument({
            statements: [
              new iam.PolicyStatement({
                effect: iam.Effect.ALLOW,
                actions: [
                  'logs:CreateLogGroup',
                  'logs:CreateLogStream',
                  'logs:PutLogEvents',
                ],
                resources: [
                  `arn:aws:logs:${this.region}:${this.account}:log-group:/aws/lambda/*`,
                ],
              }),
            ],
          }),
        },
      }
    );
    cdk.Tags.of(lambdaExecutionRole).add('iac-rlhf-amazon', 'true');

    // ==================== Lambda Functions ====================
    // Main application Lambda function
    const mainLambdaFunction = new NodejsFunction(
      this,
      `MainLambdaFunction-${environmentSuffix}`,
      {
        functionName: `tap-main-function-${environmentSuffix}`,
        runtime: lambda.Runtime.NODEJS_22_X,
        entry: 'lib/lambda/main-handler.ts',
        handler: 'handler',
        bundling: {
          externalModules: [
            '@aws-sdk/*', // AWS SDK v3 is included in Node.js 18+ runtime
          ],
          minify: true,
          sourceMap: false,
        },
        role: lambdaExecutionRole,
        timeout: cdk.Duration.seconds(30),
        memorySize: 256,
        vpc: vpc,
        vpcSubnets: {
          subnetType: ec2.SubnetType.PRIVATE_WITH_EGRESS,
        },
        environment: {
          ENVIRONMENT_SUFFIX: environmentSuffix,
          DYNAMODB_TABLE_NAME: applicationTable.tableName,
          S3_BUCKET_NAME: staticFilesBucket.bucketName,
          SECRET_NAME: apiSecrets.secretName,
          REGION: this.region,
        },
        logGroup: lambdaLogGroup,
      }
    );
    cdk.Tags.of(mainLambdaFunction).add('iac-rlhf-amazon', 'true');

    // CRUD operations Lambda function
    const crudLambdaFunction = new NodejsFunction(
      this,
      `CrudLambdaFunction-${environmentSuffix}`,
      {
        functionName: `tap-crud-function-${environmentSuffix}`,
        runtime: lambda.Runtime.NODEJS_22_X,
        entry: 'lib/lambda/crud-handler.ts',
        handler: 'handler',
        bundling: {
          externalModules: [
            '@aws-sdk/*', // AWS SDK v3 is included in Node.js 18+ runtime
          ],
          minify: true,
          sourceMap: false,
        },
        role: lambdaExecutionRole,
        timeout: cdk.Duration.seconds(30),
        memorySize: 256,
        vpc: vpc,
        vpcSubnets: {
          subnetType: ec2.SubnetType.PRIVATE_WITH_EGRESS,
        },
        environment: {
          ENVIRONMENT_SUFFIX: environmentSuffix,
          DYNAMODB_TABLE_NAME: applicationTable.tableName,
          REGION: this.region,
        },
        logGroup: lambdaLogGroup,
      }
    );
    cdk.Tags.of(crudLambdaFunction).add('iac-rlhf-amazon', 'true');

    // File processing Lambda function
    const fileProcessingLambdaFunction = new NodejsFunction(
      this,
      `FileProcessingLambdaFunction-${environmentSuffix}`,
      {
        functionName: `tap-file-processing-function-${environmentSuffix}`,
        runtime: lambda.Runtime.NODEJS_22_X,
        entry: 'lib/lambda/file-processing-handler.ts',
        handler: 'handler',
        bundling: {
          externalModules: [
            '@aws-sdk/*', // AWS SDK v3 is included in Node.js 18+ runtime
          ],
          minify: true,
          sourceMap: false,
        },
        role: lambdaExecutionRole,
        timeout: cdk.Duration.seconds(30),
        memorySize: 256,
        vpc: vpc,
        vpcSubnets: {
          subnetType: ec2.SubnetType.PRIVATE_WITH_EGRESS,
        },
        environment: {
          ENVIRONMENT_SUFFIX: environmentSuffix,
          S3_BUCKET_NAME: staticFilesBucket.bucketName,
          DYNAMODB_TABLE_NAME: applicationTable.tableName,
          REGION: this.region,
        },
        logGroup: lambdaLogGroup,
      }
    );
    cdk.Tags.of(fileProcessingLambdaFunction).add('iac-rlhf-amazon', 'true');

    // ==================== Grant Permissions ====================
    // Grant Lambda functions permissions to access resources
    applicationTable.grantReadWriteData(mainLambdaFunction);
    applicationTable.grantReadWriteData(crudLambdaFunction);
    applicationTable.grantReadWriteData(fileProcessingLambdaFunction);
    staticFilesBucket.grantReadWrite(mainLambdaFunction);
    staticFilesBucket.grantReadWrite(fileProcessingLambdaFunction);
    apiSecrets.grantRead(mainLambdaFunction);

    // ==================== API Gateway ====================
    // REST API Gateway
    const restApi = new apigateway.RestApi(
      this,
      `TapRestApi-${environmentSuffix}`,
      {
        restApiName: `tap-api-${environmentSuffix}`,
        description: 'TAP Serverless Application API',
        deployOptions: {
          stageName: environmentSuffix,
          loggingLevel: apigateway.MethodLoggingLevel.INFO,
          dataTraceEnabled: true,
          tracingEnabled: true,
          metricsEnabled: true,
        },
        defaultCorsPreflightOptions: {
          allowOrigins: apigateway.Cors.ALL_ORIGINS,
          allowMethods: apigateway.Cors.ALL_METHODS,
          allowHeaders: [
            'Content-Type',
            'X-Amz-Date',
            'Authorization',
            'X-Api-Key',
            'X-Amz-Security-Token',
          ],
        },
        endpointConfiguration: {
          types: [apigateway.EndpointType.PRIVATE],
          vpcEndpoints: [apiGatewayEndpoint],
        },
        policy: new iam.PolicyDocument({
          statements: [
            new iam.PolicyStatement({
              effect: iam.Effect.ALLOW,
              principals: [new iam.AnyPrincipal()],
              actions: ['execute-api:Invoke'],
              resources: ['execute-api:/*'],
            }),
          ],
        }),
      }
    );
    cdk.Tags.of(restApi).add('iac-rlhf-amazon', 'true');

    // ==================== API Gateway Integrations ====================
    // Main endpoint integration
    const mainIntegration = new apigateway.LambdaIntegration(
      mainLambdaFunction,
      {
        requestTemplates: { 'application/json': '{ "statusCode": "200" }' },
      }
    );

    // CRUD endpoint integration
    const crudIntegration = new apigateway.LambdaIntegration(
      crudLambdaFunction,
      {
        requestTemplates: { 'application/json': '{ "statusCode": "200" }' },
      }
    );

    // File processing endpoint integration
    const fileIntegration = new apigateway.LambdaIntegration(
      fileProcessingLambdaFunction,
      {
        requestTemplates: { 'application/json': '{ "statusCode": "200" }' },
      }
    );

    // ==================== API Gateway Routes ====================
    // Root endpoint
    const rootResource = restApi.root;
    rootResource.addMethod('GET', mainIntegration);

    // /api resource
    const apiResource = rootResource.addResource('api');
    apiResource.addMethod('GET', mainIntegration);

    // /api/items resource for CRUD operations
    const itemsResource = apiResource.addResource('items');
    itemsResource.addMethod('GET', crudIntegration);
    itemsResource.addMethod('POST', crudIntegration);

    // /api/items/{id} resource
    const itemResource = itemsResource.addResource('{id}');
    itemResource.addMethod('GET', crudIntegration);
    itemResource.addMethod('PUT', crudIntegration);
    itemResource.addMethod('DELETE', crudIntegration);

    // /api/files resource for file operations
    const filesResource = apiResource.addResource('files');
    filesResource.addMethod('GET', fileIntegration);
    filesResource.addMethod('POST', fileIntegration);

    // /api/files/{filename} resource
    const fileResource = filesResource.addResource('{filename}');
    fileResource.addMethod('GET', fileIntegration);
    fileResource.addMethod('DELETE', fileIntegration);

    // ==================== CloudFormation Outputs ====================
    // Output important resource information
    new cdk.CfnOutput(this, 'ApiEndpoint', {
      value: restApi.url,
      description: 'API Gateway endpoint URL',
    });

    new cdk.CfnOutput(this, 'S3BucketName', {
      value: staticFilesBucket.bucketName,
      description: 'S3 bucket name for static files',
    });

    new cdk.CfnOutput(this, 'DynamoDBTableName', {
      value: applicationTable.tableName,
      description: 'DynamoDB table name',
    });

    new cdk.CfnOutput(this, 'SecretName', {
      value: apiSecrets.secretName,
      description: 'Secrets Manager secret name',
    });

    new cdk.CfnOutput(this, 'VpcId', {
      value: vpc.vpcId,
      description: 'VPC ID',
    });

    new cdk.CfnOutput(this, 'MainLambdaFunctionArn', {
      value: mainLambdaFunction.functionArn,
      description: 'Main Lambda function ARN',
    });
  }
}

```

## ./test/tap-stack.int.test.ts

```typescript
// Configuration - These are coming from cfn-outputs after cdk deploy
import fs from 'fs';
import { DynamoDBClient, DescribeTableCommand } from '@aws-sdk/client-dynamodb';
import {
  DynamoDBDocumentClient,
  DeleteCommand,
  ScanCommand,
} from '@aws-sdk/lib-dynamodb';
import {
  S3Client,
  HeadBucketCommand,
  ListObjectsV2Command,
  DeleteObjectCommand,
} from '@aws-sdk/client-s3';
import {
  SecretsManagerClient,
  GetSecretValueCommand,
} from '@aws-sdk/client-secrets-manager';
import { LambdaClient, InvokeCommand } from '@aws-sdk/client-lambda';

const outputs = JSON.parse(
  fs.readFileSync('cfn-outputs/flat-outputs.json', 'utf8')
);

// Get environment suffix and region from environment variables (set by CI/CD pipeline)
const environmentSuffix = process.env.ENVIRONMENT_SUFFIX || 'dev';
const region = process.env.AWS_REGION || 'ap-northeast-1';

// AWS SDK clients
const dynamoClient = new DynamoDBClient({ region });
const dynamodb = DynamoDBDocumentClient.from(dynamoClient);
const s3Client = new S3Client({ region });
const secretsClient = new SecretsManagerClient({ region });
const lambdaClient = new LambdaClient({ region });

// Extract outputs
const apiEndpoint =
  outputs.ApiEndpoint || outputs.TapRestApidev2Endpoint5853073A;
const s3BucketName = outputs.S3BucketName;
const dynamoTableName = outputs.DynamoDBTableName;
const secretName = outputs.SecretName;
const vpcId = outputs.VpcId;

// Lambda function names
const mainLambdaName = `tap-main-function-${environmentSuffix}`;
const crudLambdaName = `tap-crud-function-${environmentSuffix}`;
const fileProcessingLambdaName = `tap-file-processing-function-${environmentSuffix}`;

// Helper function to invoke Lambda functions directly
// This is needed because API Gateway is private (VPC endpoint only)
async function invokeLambda(
  functionName: string,
  path: string,
  method: string,
  body?: unknown,
  pathParameters?: Record<string, string>,
  queryStringParameters?: Record<string, string>
): Promise<{ status: number; data: unknown; headers: Record<string, string> }> {
  const event = {
    httpMethod: method,
    path: `/${environmentSuffix}/${path}`,
    pathParameters: pathParameters || null,
    queryStringParameters: queryStringParameters || null,
    headers: {
      'Content-Type': 'application/json',
    },
    body: body ? JSON.stringify(body) : null,
  };

  const command = new InvokeCommand({
    FunctionName: functionName,
    Payload: JSON.stringify(event),
  });

  const response = await lambdaClient.send(command);
  const payload = JSON.parse(new TextDecoder().decode(response.Payload));

  return {
    status: payload.statusCode || 200,
    data: payload.body ? JSON.parse(payload.body) : {},
    headers: payload.headers || {},
  };
}

// Test data cleanup helpers
const createdItemIds: Array<{ id: string; timestamp: number }> = [];
const createdFileIds: string[] = [];

afterAll(async () => {
  // Clean up created DynamoDB items
  for (const item of createdItemIds) {
    try {
      await dynamodb.send(
        new DeleteCommand({
          TableName: dynamoTableName,
          Key: item,
        })
      );
    } catch (error) {
      console.warn('Failed to cleanup item:', item, error);
    }
  }

  // Clean up created S3 files
  for (const fileId of createdFileIds) {
    try {
      const listResult = await s3Client.send(
        new ListObjectsV2Command({
          Bucket: s3BucketName,
          Prefix: `uploads/${fileId}/`,
        })
      );

      if (listResult.Contents) {
        for (const object of listResult.Contents) {
          if (object.Key) {
            await s3Client.send(
              new DeleteObjectCommand({
                Bucket: s3BucketName,
                Key: object.Key,
              })
            );
          }
        }
      }
    } catch (error) {
      console.warn('Failed to cleanup file:', fileId, error);
    }
  }
});

describe(`TAP Stack Integration Tests - ${environmentSuffix}`, () => {
  describe('Infrastructure Validation', () => {
    test('DynamoDB table exists and is accessible', async () => {
      const result = await dynamoClient.send(
        new DescribeTableCommand({ TableName: dynamoTableName })
      );

      expect(result.Table).toBeDefined();
      expect(result.Table?.TableName).toBe(dynamoTableName);
      expect(result.Table?.TableStatus).toBe('ACTIVE');
      expect(result.Table?.KeySchema).toEqual(
        expect.arrayContaining([
          expect.objectContaining({ AttributeName: 'id', KeyType: 'HASH' }),
          expect.objectContaining({
            AttributeName: 'timestamp',
            KeyType: 'RANGE',
          }),
        ])
      );
    });

    test('DynamoDB table has StatusIndex GSI', async () => {
      const result = await dynamoClient.send(
        new DescribeTableCommand({ TableName: dynamoTableName })
      );

      expect(result.Table?.GlobalSecondaryIndexes).toEqual(
        expect.arrayContaining([
          expect.objectContaining({
            IndexName: 'StatusIndex',
          }),
        ])
      );
    });

    test('S3 bucket exists and is accessible', async () => {
      const result = await s3Client.send(
        new HeadBucketCommand({ Bucket: s3BucketName })
      );

      expect(result.$metadata.httpStatusCode).toBe(200);
    });

    test('Secrets Manager secret exists and is accessible', async () => {
      const result = await secretsClient.send(
        new GetSecretValueCommand({ SecretId: secretName })
      );

      expect(result.Name).toBe(secretName);
      expect(result.ARN).toBeDefined();
    });

    test('Lambda functions are accessible', async () => {
      const result = await invokeLambda(mainLambdaName, 'health', 'GET');
      expect(result.status).toBeLessThan(500);
    });
  });

  describe('Health Check Lambda (Main Handler)', () => {
    test('returns health status for all services', async () => {
      const result = await invokeLambda(mainLambdaName, 'health', 'GET');

      expect(result.status).toBe(200);
      expect(result.data).toMatchObject({
        status: 'healthy',
        environment: environmentSuffix,
        region: region,
        timestamp: expect.any(String),
        services: expect.arrayContaining([
          expect.objectContaining({
            service: 'DynamoDB',
            status: 'healthy',
          }),
          expect.objectContaining({
            service: 'S3',
            status: 'healthy',
          }),
          expect.objectContaining({
            service: 'Secrets Manager',
            status: 'healthy',
          }),
        ]),
      });
    });

    test('includes CORS headers', async () => {
      const result = await invokeLambda(mainLambdaName, 'health', 'GET');

      expect(result.headers['Access-Control-Allow-Origin']).toBe('*');
      expect(result.headers['Content-Type']).toContain('application/json');
    });
  });

  describe('CRUD Lambda Operations', () => {
    test('creates a new item via POST', async () => {
      const newItem = {
        title: `Integration Test Item ${Date.now()}`,
        description: 'Test item created by integration tests',
        status: 'active',
        data: { testField: 'testValue' },
      };

      const result = await invokeLambda(
        crudLambdaName,
        'crud',
        'POST',
        newItem
      );

      expect(result.status).toBe(201);
      expect(result.data).toMatchObject({
        message: 'Item created successfully',
        item: expect.objectContaining({
          id: expect.any(String),
          timestamp: expect.any(Number),
          title: newItem.title,
          description: newItem.description,
          status: 'active',
        }),
      });

      // Track for cleanup
      const createdItem = (
        result.data as { item: { id: string; timestamp: number } }
      ).item;
      createdItemIds.push({
        id: createdItem.id,
        timestamp: createdItem.timestamp,
      });
    });

    test('retrieves items by status using GSI', async () => {
      // Create a test item first
      const newItem = {
        title: `Test for Query ${Date.now()}`,
        status: 'pending',
      };

      const createResult = await invokeLambda(
        crudLambdaName,
        'crud',
        'POST',
        newItem
      );
      const createdItem = (
        createResult.data as { item: { id: string; timestamp: number } }
      ).item;
      createdItemIds.push({
        id: createdItem.id,
        timestamp: createdItem.timestamp,
      });

      // Query by status
      const result = await invokeLambda(
        crudLambdaName,
        'crud',
        'GET',
        undefined,
        undefined,
        { status: 'pending' }
      );

      expect(result.status).toBe(200);
      expect(result.data).toMatchObject({
        items: expect.any(Array),
        count: expect.any(Number),
      });

      const items = (result.data as { items: Array<{ status: string }> }).items;
      expect(items.every(item => item.status === 'pending')).toBe(true);
    });

    test('updates an existing item via PUT', async () => {
      // Create item first
      const createResult = await invokeLambda(crudLambdaName, 'crud', 'POST', {
        title: 'Item to Update',
      });

      const createdItem = (
        createResult.data as { item: { id: string; timestamp: number } }
      ).item;
      createdItemIds.push({
        id: createdItem.id,
        timestamp: createdItem.timestamp,
      });

      // Update the item
      const updateData = {
        title: 'Updated Title',
        description: 'Updated description',
        status: 'completed',
      };

      const result = await invokeLambda(
        crudLambdaName,
        'crud',
        'PUT',
        updateData,
        { id: createdItem.id, timestamp: createdItem.timestamp.toString() }
      );

      expect(result.status).toBe(200);
      expect(result.data).toMatchObject({
        message: 'Item updated successfully',
        item: expect.objectContaining({
          title: 'Updated Title',
          description: 'Updated description',
          status: 'completed',
        }),
      });
    });

    test('deletes an item via DELETE', async () => {
      // Create item first
      const createResult = await invokeLambda(crudLambdaName, 'crud', 'POST', {
        title: 'Item to Delete',
      });

      const createdItem = (
        createResult.data as { item: { id: string; timestamp: number } }
      ).item;

      // Delete the item
      const result = await invokeLambda(
        crudLambdaName,
        'crud',
        'DELETE',
        undefined,
        { id: createdItem.id, timestamp: createdItem.timestamp.toString() }
      );

      expect(result.status).toBe(200);
      expect(result.data).toMatchObject({
        message: 'Item deleted successfully',
        id: createdItem.id,
      });

      // Remove from cleanup array since it's already deleted
      const index = createdItemIds.findIndex(
        item =>
          item.id === createdItem.id && item.timestamp === createdItem.timestamp
      );
      if (index > -1) {
        createdItemIds.splice(index, 1);
      }
    });

    test('returns 400 for POST without required title field', async () => {
      const result = await invokeLambda(crudLambdaName, 'crud', 'POST', {
        description: 'Missing title',
      });

      expect(result.status).toBe(400);
      expect(result.data).toMatchObject({
        error: 'title field is required',
      });
    });

    test('scans all items when no query parameters provided', async () => {
      const result = await invokeLambda(crudLambdaName, 'crud', 'GET');

      expect(result.status).toBe(200);
      expect(result.data).toMatchObject({
        items: expect.any(Array),
        count: expect.any(Number),
      });
    });
  });

  describe('File Processing Lambda', () => {
    test('uploads a file to S3 and creates metadata', async () => {
      const fileData = {
        fileName: `test-file-${Date.now()}.txt`,
        content: 'Test file content for integration testing',
        contentType: 'text/plain',
        uploadedBy: 'integration-test',
        tags: ['test', 'integration'],
      };

      const result = await invokeLambda(
        fileProcessingLambdaName,
        'files',
        'POST',
        fileData
      );

      expect(result.status).toBe(201);
      expect(result.data).toMatchObject({
        message: 'File uploaded successfully',
        file: expect.objectContaining({
          id: expect.any(String),
          fileName: fileData.fileName,
          status: 'uploaded',
          contentType: 'text/plain',
          downloadUrl: expect.stringContaining('amazonaws.com'),
        }),
      });

      // Track for cleanup
      const uploadedFile = (
        result.data as { file: { id: string; timestamp: number } }
      ).file;
      createdFileIds.push(uploadedFile.id);
      createdItemIds.push({
        id: uploadedFile.id,
        timestamp: uploadedFile.timestamp,
      });
    });

    test('retrieves file metadata and download URL', async () => {
      // Upload file first
      const fileData = {
        fileName: `retrieve-test-${Date.now()}.txt`,
        content: 'Content for retrieval test',
        contentType: 'text/plain',
      };

      const uploadResult = await invokeLambda(
        fileProcessingLambdaName,
        'files',
        'POST',
        fileData
      );
      const uploadedFile = (
        uploadResult.data as { file: { id: string; timestamp: number } }
      ).file;
      createdFileIds.push(uploadedFile.id);
      createdItemIds.push({
        id: uploadedFile.id,
        timestamp: uploadedFile.timestamp,
      });

      // Retrieve file
      const result = await invokeLambda(
        fileProcessingLambdaName,
        'files',
        'GET',
        undefined,
        { filename: uploadedFile.id }
      );

      expect(result.status).toBe(200);
      expect(result.data).toMatchObject({
        id: uploadedFile.id,
        fileName: fileData.fileName,
        downloadUrl: expect.stringContaining('amazonaws.com'),
      });
    });

    test('lists files by status', async () => {
      const result = await invokeLambda(
        fileProcessingLambdaName,
        'files',
        'GET',
        undefined,
        undefined,
        { status: 'uploaded' }
      );

      expect(result.status).toBe(200);
      expect(result.data).toMatchObject({
        files: expect.any(Array),
        count: expect.any(Number),
      });

      const files = (result.data as { files: Array<{ status: string }> }).files;
      expect(files.every(file => file.status === 'uploaded')).toBe(true);
    });

    test('deletes file from S3 and metadata', async () => {
      // Upload file first
      const fileData = {
        fileName: `delete-test-${Date.now()}.txt`,
        content: 'Content to be deleted',
        contentType: 'text/plain',
      };

      const uploadResult = await invokeLambda(
        fileProcessingLambdaName,
        'files',
        'POST',
        fileData
      );
      const uploadedFile = (
        uploadResult.data as { file: { id: string; timestamp: number } }
      ).file;

      // Delete file
      const result = await invokeLambda(
        fileProcessingLambdaName,
        'files',
        'DELETE',
        undefined,
        { filename: uploadedFile.id }
      );

      expect(result.status).toBe(200);
      expect(result.data).toMatchObject({
        message: 'File deleted successfully',
        fileId: uploadedFile.id,
      });

      // Remove from cleanup arrays
      const fileIndex = createdFileIds.indexOf(uploadedFile.id);
      if (fileIndex > -1) {
        createdFileIds.splice(fileIndex, 1);
      }
      const itemIndex = createdItemIds.findIndex(
        item => item.id === uploadedFile.id
      );
      if (itemIndex > -1) {
        createdItemIds.splice(itemIndex, 1);
      }
    });

    test('validates file content type', async () => {
      const fileData = {
        fileName: `invalid-${Date.now()}.exe`,
        content: 'Invalid content',
        contentType: 'application/x-msdownload',
      };

      const result = await invokeLambda(
        fileProcessingLambdaName,
        'files',
        'POST',
        fileData
      );

      expect(result.status).toBe(400);
      expect(result.data).toMatchObject({
        error: expect.stringContaining('Content type'),
        allowedTypes: expect.any(Array),
      });
    });

    test('returns 404 for non-existent file', async () => {
      const result = await invokeLambda(
        fileProcessingLambdaName,
        'files',
        'GET',
        undefined,
        { filename: 'non-existent-file' }
      );

      expect(result.status).toBe(404);
      expect(result.data).toMatchObject({
        error: 'File not found',
      });
    });
  });

  describe('API Gateway Configuration', () => {
    test('API endpoint uses HTTPS', () => {
      expect(apiEndpoint).toMatch(/^https:\/\//);
    });

    test('API endpoint includes environment suffix in path', () => {
      expect(apiEndpoint).toContain(environmentSuffix);
    });

    test('Lambda returns CORS headers on all responses', async () => {
      const result = await invokeLambda(mainLambdaName, 'health', 'GET');

      expect(result.headers['Access-Control-Allow-Origin']).toBe('*');
    });
  });

  describe('End-to-End Workflows', () => {
    test('complete CRUD workflow: create -> update -> query -> delete', async () => {
      // 1. Create
      const createResult = await invokeLambda(crudLambdaName, 'crud', 'POST', {
        title: 'E2E Test Item',
        status: 'pending',
      });
      expect(createResult.status).toBe(201);

      const createdItem = (
        createResult.data as { item: { id: string; timestamp: number } }
      ).item;
      createdItemIds.push({
        id: createdItem.id,
        timestamp: createdItem.timestamp,
      });

      // 2. Update
      const updateResult = await invokeLambda(
        crudLambdaName,
        'crud',
        'PUT',
        { status: 'completed' },
        { id: createdItem.id, timestamp: createdItem.timestamp.toString() }
      );
      expect(updateResult.status).toBe(200);

      // 3. Query by new status
      const queryResult = await invokeLambda(
        crudLambdaName,
        'crud',
        'GET',
        undefined,
        undefined,
        { status: 'completed' }
      );
      expect(queryResult.status).toBe(200);
      const items = (queryResult.data as { items: Array<{ id: string }> })
        .items;
      expect(items.some(item => item.id === createdItem.id)).toBe(true);

      // 4. Delete
      const deleteResult = await invokeLambda(
        crudLambdaName,
        'crud',
        'DELETE',
        undefined,
        { id: createdItem.id, timestamp: createdItem.timestamp.toString() }
      );
      expect(deleteResult.status).toBe(200);

      // Remove from cleanup
      const index = createdItemIds.findIndex(
        item => item.id === createdItem.id
      );
      if (index > -1) {
        createdItemIds.splice(index, 1);
      }
    });

    test('complete file workflow: upload -> retrieve -> delete', async () => {
      // 1. Upload
      const uploadResult = await invokeLambda(
        fileProcessingLambdaName,
        'files',
        'POST',
        {
          fileName: `e2e-test-${Date.now()}.json`,
          content: JSON.stringify({ test: 'data' }),
          contentType: 'application/json',
        }
      );
      expect(uploadResult.status).toBe(201);

      const uploadedFile = (
        uploadResult.data as {
          file: { id: string; timestamp: number; downloadUrl: string };
        }
      ).file;
      createdFileIds.push(uploadedFile.id);
      createdItemIds.push({
        id: uploadedFile.id,
        timestamp: uploadedFile.timestamp,
      });

      // 2. Retrieve
      const retrieveResult = await invokeLambda(
        fileProcessingLambdaName,
        'files',
        'GET',
        undefined,
        { filename: uploadedFile.id }
      );
      expect(retrieveResult.status).toBe(200);
      expect(
        (retrieveResult.data as { downloadUrl: string }).downloadUrl
      ).toBeDefined();

      // 3. Verify presigned URL works
      const downloadResponse = await fetch(uploadedFile.downloadUrl);
      expect(downloadResponse.ok).toBe(true);

      // 4. Delete
      const deleteResult = await invokeLambda(
        fileProcessingLambdaName,
        'files',
        'DELETE',
        undefined,
        { filename: uploadedFile.id }
      );
      expect(deleteResult.status).toBe(200);

      // Remove from cleanup
      const fileIndex = createdFileIds.indexOf(uploadedFile.id);
      if (fileIndex > -1) {
        createdFileIds.splice(fileIndex, 1);
      }
      const itemIndex = createdItemIds.findIndex(
        item => item.id === uploadedFile.id
      );
      if (itemIndex > -1) {
        createdItemIds.splice(itemIndex, 1);
      }
    });
  });
});

```

## ./test/tap-stack.unit.test.ts

```typescript
import * as cdk from 'aws-cdk-lib';
import { Template, Match } from 'aws-cdk-lib/assertions';
import { TapStack } from '../lib/tap-stack';

const environmentSuffix = process.env.ENVIRONMENT_SUFFIX || 'dev';

describe('TapStack', () => {
  let app: cdk.App;
  let stack: TapStack;
  let template: Template;

  beforeEach(() => {
    app = new cdk.App();
    stack = new TapStack(app, 'TestTapStack', { environmentSuffix });
    template = Template.fromStack(stack);
  });

  describe('VPC Infrastructure', () => {
    test('creates VPC with correct configuration', () => {
      template.hasResourceProperties('AWS::EC2::VPC', {
        EnableDnsHostnames: true,
        EnableDnsSupport: true,
        Tags: Match.arrayWith([
          Match.objectLike({
            Key: 'iac-rlhf-amazon',
            Value: 'true',
          }),
          Match.objectLike({
            Key: 'Name',
            Value: `tap-vpc-${environmentSuffix}`,
          }),
        ]),
      });
    });

    test('creates public and private subnets', () => {
      template.resourceCountIs('AWS::EC2::Subnet', 4);
    });

    test('creates NAT Gateway in public subnet', () => {
      template.resourceCountIs('AWS::EC2::NatGateway', 1);
    });

    test('creates VPC endpoint for API Gateway', () => {
      template.hasResourceProperties('AWS::EC2::VPCEndpoint', {
        ServiceName: Match.stringLikeRegexp('execute-api'),
        VpcEndpointType: 'Interface',
      });
    });

    test('VPC endpoint has iac-rlhf-amazon tag', () => {
      template.hasResource('AWS::EC2::VPCEndpoint', {
        Properties: Match.anyValue(),
        Metadata: Match.anyValue(),
      });
    });
  });

  describe('S3 Bucket', () => {
    test('creates S3 bucket with correct name pattern', () => {
      template.hasResourceProperties('AWS::S3::Bucket', {
        BucketName: Match.stringLikeRegexp(
          `tap-static-files-${environmentSuffix}-`
        ),
        VersioningConfiguration: {
          Status: 'Enabled',
        },
      });
    });

    test('S3 bucket has encryption enabled', () => {
      template.hasResourceProperties('AWS::S3::Bucket', {
        BucketEncryption: {
          ServerSideEncryptionConfiguration: [
            {
              ServerSideEncryptionByDefault: {
                SSEAlgorithm: 'AES256',
              },
            },
          ],
        },
      });
    });

    test('S3 bucket blocks public access', () => {
      template.hasResourceProperties('AWS::S3::Bucket', {
        PublicAccessBlockConfiguration: {
          BlockPublicAcls: true,
          BlockPublicPolicy: true,
          IgnorePublicAcls: true,
          RestrictPublicBuckets: true,
        },
      });
    });

    test('S3 bucket has CORS configuration', () => {
      template.hasResourceProperties('AWS::S3::Bucket', {
        CorsConfiguration: {
          CorsRules: Match.arrayWith([
            Match.objectLike({
              AllowedMethods: Match.arrayWith(['GET', 'PUT', 'POST', 'DELETE']),
              AllowedOrigins: ['*'],
            }),
          ]),
        },
      });
    });

    test('S3 bucket has iac-rlhf-amazon tag', () => {
      template.hasResourceProperties('AWS::S3::Bucket', {
        Tags: Match.arrayWith([
          {
            Key: 'iac-rlhf-amazon',
            Value: 'true',
          },
        ]),
      });
    });
  });

  describe('DynamoDB Table', () => {
    test('creates DynamoDB table with correct name', () => {
      template.hasResourceProperties('AWS::DynamoDB::Table', {
        TableName: `tap-application-table-${environmentSuffix}`,
      });
    });

    test('DynamoDB has partition and sort keys', () => {
      template.hasResourceProperties('AWS::DynamoDB::Table', {
        KeySchema: [
          {
            AttributeName: 'id',
            KeyType: 'HASH',
          },
          {
            AttributeName: 'timestamp',
            KeyType: 'RANGE',
          },
        ],
      });
    });

    test('DynamoDB has Global Secondary Index', () => {
      template.hasResourceProperties('AWS::DynamoDB::Table', {
        GlobalSecondaryIndexes: [
          {
            IndexName: 'StatusIndex',
            KeySchema: [
              {
                AttributeName: 'status',
                KeyType: 'HASH',
              },
              {
                AttributeName: 'timestamp',
                KeyType: 'RANGE',
              },
            ],
            Projection: {
              ProjectionType: 'ALL',
            },
          },
        ],
      });
    });

    test('DynamoDB has point-in-time recovery enabled', () => {
      template.hasResourceProperties('AWS::DynamoDB::Table', {
        PointInTimeRecoverySpecification: {
          PointInTimeRecoveryEnabled: true,
        },
      });
    });

    test('DynamoDB uses PAY_PER_REQUEST billing', () => {
      template.hasResourceProperties('AWS::DynamoDB::Table', {
        BillingMode: 'PAY_PER_REQUEST',
      });
    });

    test('DynamoDB has iac-rlhf-amazon tag', () => {
      template.hasResourceProperties('AWS::DynamoDB::Table', {
        Tags: Match.arrayWith([
          {
            Key: 'iac-rlhf-amazon',
            Value: 'true',
          },
        ]),
      });
    });
  });

  describe('Secrets Manager', () => {
    test('creates Secrets Manager secret', () => {
      template.hasResourceProperties('AWS::SecretsManager::Secret', {
        Name: `tap-api-secrets-${environmentSuffix}`,
        Description: 'API keys and other sensitive configuration',
      });
    });

    test('Secrets Manager has iac-rlhf-amazon tag', () => {
      template.hasResourceProperties('AWS::SecretsManager::Secret', {
        Tags: Match.arrayWith([
          {
            Key: 'iac-rlhf-amazon',
            Value: 'true',
          },
        ]),
      });
    });
  });

  describe('CloudWatch Logs', () => {
    test('creates CloudWatch log group', () => {
      template.hasResourceProperties('AWS::Logs::LogGroup', {
        LogGroupName: `/aws/lambda/tap-${environmentSuffix}`,
        RetentionInDays: 14,
      });
    });

    test('log group has iac-rlhf-amazon tag', () => {
      template.hasResourceProperties('AWS::Logs::LogGroup', {
        Tags: Match.arrayWith([
          {
            Key: 'iac-rlhf-amazon',
            Value: 'true',
          },
        ]),
      });
    });
  });

  describe('IAM Roles', () => {
    test('creates Lambda execution role', () => {
      template.hasResourceProperties('AWS::IAM::Role', {
        RoleName: `tap-lambda-execution-role-${environmentSuffix}`,
        AssumeRolePolicyDocument: {
          Statement: [
            {
              Action: 'sts:AssumeRole',
              Effect: 'Allow',
              Principal: {
                Service: 'lambda.amazonaws.com',
              },
            },
          ],
        },
      });
    });

    test('Lambda role has VPC access policy', () => {
      template.hasResourceProperties('AWS::IAM::Role', {
        ManagedPolicyArns: Match.arrayWith([
          Match.objectLike({
            'Fn::Join': Match.arrayWith([
              Match.arrayWith([
                Match.stringLikeRegexp('AWSLambdaVPCAccessExecutionRole'),
              ]),
            ]),
          }),
        ]),
      });
    });

    test('Lambda role has iac-rlhf-amazon tag', () => {
      template.hasResourceProperties('AWS::IAM::Role', {
        Tags: Match.arrayWith([
          {
            Key: 'iac-rlhf-amazon',
            Value: 'true',
          },
        ]),
      });
    });

    test('creates IAM policy for Lambda permissions', () => {
      template.hasResourceProperties('AWS::IAM::Policy', {
        PolicyDocument: {
          Statement: Match.arrayWith([
            Match.objectLike({
              Action: Match.arrayWith([
                'dynamodb:BatchGetItem',
                'dynamodb:GetItem',
                'dynamodb:PutItem',
                'dynamodb:Query',
                'dynamodb:Scan',
              ]),
              Effect: 'Allow',
            }),
            Match.objectLike({
              Action: Match.arrayWith([
                's3:GetObject*',
                's3:PutObject',
                's3:DeleteObject*',
              ]),
              Effect: 'Allow',
            }),
          ]),
        },
      });
    });
  });

  describe('Lambda Functions', () => {
    test('creates main Lambda function', () => {
      template.hasResourceProperties('AWS::Lambda::Function', {
        FunctionName: `tap-main-function-${environmentSuffix}`,
        Runtime: 'nodejs22.x',
        Timeout: 30,
        MemorySize: 256,
      });
    });

    test('creates CRUD Lambda function', () => {
      template.hasResourceProperties('AWS::Lambda::Function', {
        FunctionName: `tap-crud-function-${environmentSuffix}`,
        Runtime: 'nodejs22.x',
      });
    });

    test('creates file processing Lambda function', () => {
      template.hasResourceProperties('AWS::Lambda::Function', {
        FunctionName: `tap-file-processing-function-${environmentSuffix}`,
        Runtime: 'nodejs22.x',
      });
    });

    test('Lambda functions have environment variables', () => {
      template.hasResourceProperties('AWS::Lambda::Function', {
        Environment: {
          Variables: Match.objectLike({
            ENVIRONMENT_SUFFIX: environmentSuffix,
            REGION: Match.anyValue(),
          }),
        },
      });
    });

    test('Lambda functions are in VPC', () => {
      template.hasResourceProperties('AWS::Lambda::Function', {
        VpcConfig: Match.objectLike({
          SecurityGroupIds: Match.anyValue(),
          SubnetIds: Match.anyValue(),
        }),
      });
    });

    test('Lambda functions have iac-rlhf-amazon tag', () => {
      template.hasResourceProperties('AWS::Lambda::Function', {
        Tags: Match.arrayWith([
          {
            Key: 'iac-rlhf-amazon',
            Value: 'true',
          },
        ]),
      });
    });

    test('creates exactly 3 Lambda functions', () => {
      const lambdas = template.findResources('AWS::Lambda::Function');
      const appLambdas = Object.keys(lambdas).filter(
        key => !key.includes('CustomResource')
      );
      expect(appLambdas.length).toBe(3);
    });
  });

  describe('API Gateway', () => {
    test('creates REST API', () => {
      template.hasResourceProperties('AWS::ApiGateway::RestApi', {
        Name: `tap-api-${environmentSuffix}`,
        Description: 'TAP Serverless Application API',
      });
    });

    test('API Gateway is private (VPC endpoint)', () => {
      template.hasResourceProperties('AWS::ApiGateway::RestApi', {
        EndpointConfiguration: {
          Types: ['PRIVATE'],
        },
      });
    });

    test('API Gateway has CORS enabled', () => {
      template.hasResource('AWS::ApiGateway::Method', {
        Properties: {
          HttpMethod: 'OPTIONS',
          Integration: {
            Type: 'MOCK',
          },
        },
      });
    });

    test('creates API Gateway resources', () => {
      template.hasResourceProperties('AWS::ApiGateway::Resource', {
        PathPart: 'api',
      });
    });

    test('creates API Gateway methods', () => {
      template.resourceCountIs('AWS::ApiGateway::Method', Match.anyValue());
    });

    test('creates API Gateway deployment', () => {
      template.hasResourceProperties('AWS::ApiGateway::Deployment', {
        StageName: environmentSuffix,
      });
    });

    test('API Gateway has iac-rlhf-amazon tag', () => {
      template.hasResource('AWS::ApiGateway::RestApi', Match.anyValue());
    });
  });

  describe('Stack Outputs', () => {
    test('exports API endpoint', () => {
      template.hasOutput('ApiEndpoint', {
        Description: 'API Gateway endpoint URL',
      });
    });

    test('exports S3 bucket name', () => {
      template.hasOutput('S3BucketName', {
        Description: 'S3 bucket name for static files',
      });
    });

    test('exports DynamoDB table name', () => {
      template.hasOutput('DynamoDBTableName', {
        Description: 'DynamoDB table name',
      });
    });

    test('exports Secret name', () => {
      template.hasOutput('SecretName', {
        Description: 'Secrets Manager secret name',
      });
    });

    test('exports VPC ID', () => {
      template.hasOutput('VpcId', {
        Description: 'VPC ID',
      });
    });

    test('exports Lambda function ARN', () => {
      template.hasOutput('MainLambdaFunctionArn', {
        Description: 'Main Lambda function ARN',
      });
    });
  });

  describe('Resource Tags', () => {
    test('all taggable resources have iac-rlhf-amazon tag', () => {
      const resources = template.toJSON().Resources;
      const taggableTypes = [
        'AWS::EC2::VPC',
        'AWS::S3::Bucket',
        'AWS::DynamoDB::Table',
        'AWS::SecretsManager::Secret',
        'AWS::Logs::LogGroup',
        'AWS::IAM::Role',
        'AWS::Lambda::Function',
      ];

      Object.entries(resources).forEach(
        ([logicalId, resource]: [string, any]) => {
          if (
            taggableTypes.includes(resource.Type) &&
            !logicalId.includes('CustomResource')
          ) {
            expect(resource.Properties.Tags).toEqual(
              expect.arrayContaining([
                expect.objectContaining({
                  Key: 'iac-rlhf-amazon',
                  Value: 'true',
                }),
              ])
            );
          }
        }
      );
    });
  });

  describe('Stack Configuration', () => {
    test('uses correct environment suffix', () => {
      const resources = template.toJSON().Resources;
      const hasEnvSuffix = Object.values(resources).some((resource: any) =>
        JSON.stringify(resource).includes(environmentSuffix)
      );
      expect(hasEnvSuffix).toBe(true);
    });

    test('stack synthesizes without errors', () => {
      expect(() => {
        app.synth();
      }).not.toThrow();
    });
  });
});

```

## ./cdk.json

```json
{
  "app": "npx ts-node --prefer-ts-exts bin/tap.ts",
  "watch": {
    "include": [
      "**"
    ],
    "exclude": [
      "README.md",
      "cdk*.json",
      "**/*.d.ts",
      "**/*.js",
      "tsconfig.json",
      "package*.json",
      "yarn.lock",
      "node_modules",
      "test"
    ]
  },
  "context": {
    "@aws-cdk/aws-lambda:recognizeLayerVersion": true,
    "@aws-cdk/core:checkSecretUsage": true,
    "@aws-cdk/core:target-partitions": [
      "aws",
      "aws-cn"
    ],
    "@aws-cdk-containers/ecs-service-extensions:enableDefaultLogDriver": true,
    "@aws-cdk/aws-ec2:uniqueImdsv2TemplateName": true,
    "@aws-cdk/aws-ecs:arnFormatIncludesClusterName": true,
    "@aws-cdk/aws-iam:minimizePolicies": true,
    "@aws-cdk/core:validateSnapshotRemovalPolicy": true,
    "@aws-cdk/aws-codepipeline:crossAccountKeyAliasStackSafeResourceName": true,
    "@aws-cdk/aws-s3:createDefaultLoggingPolicy": true,
    "@aws-cdk/aws-sns-subscriptions:restrictSqsDescryption": true,
    "@aws-cdk/aws-apigateway:disableCloudWatchRole": true,
    "@aws-cdk/core:enablePartitionLiterals": true,
    "@aws-cdk/aws-events:eventsTargetQueueSameAccount": true,
    "@aws-cdk/aws-ecs:disableExplicitDeploymentControllerForCircuitBreaker": true,
    "@aws-cdk/aws-iam:importedRoleStackSafeDefaultPolicyName": true,
    "@aws-cdk/aws-s3:serverAccessLogsUseBucketPolicy": true,
    "@aws-cdk/aws-route53-patters:useCertificate": true,
    "@aws-cdk/customresources:installLatestAwsSdkDefault": false,
    "@aws-cdk/aws-rds:databaseProxyUniqueResourceName": true,
    "@aws-cdk/aws-codedeploy:removeAlarmsFromDeploymentGroup": true,
    "@aws-cdk/aws-apigateway:authorizerChangeDeploymentLogicalId": true,
    "@aws-cdk/aws-ec2:launchTemplateDefaultUserData": true,
    "@aws-cdk/aws-secretsmanager:useAttachedSecretResourcePolicyForSecretTargetAttachments": true,
    "@aws-cdk/aws-redshift:columnId": true,
    "@aws-cdk/aws-stepfunctions-tasks:enableEmrServicePolicyV2": true,
    "@aws-cdk/aws-ec2:restrictDefaultSecurityGroup": true,
    "@aws-cdk/aws-apigateway:requestValidatorUniqueId": true,
    "@aws-cdk/aws-kms:aliasNameRef": true,
    "@aws-cdk/aws-autoscaling:generateLaunchTemplateInsteadOfLaunchConfig": true,
    "@aws-cdk/core:includePrefixInUniqueNameGeneration": true,
    "@aws-cdk/aws-efs:denyAnonymousAccess": true,
    "@aws-cdk/aws-opensearchservice:enableOpensearchMultiAzWithStandby": true,
    "@aws-cdk/aws-lambda-nodejs:useLatestRuntimeVersion": true,
    "@aws-cdk/aws-efs:mountTargetOrderInsensitiveLogicalId": true,
    "@aws-cdk/aws-rds:auroraClusterChangeScopeOfInstanceParameterGroupWithEachParameters": true,
    "@aws-cdk/aws-appsync:useArnForSourceApiAssociationIdentifier": true,
    "@aws-cdk/aws-rds:preventRenderingDeprecatedCredentials": true,
    "@aws-cdk/aws-codepipeline-actions:useNewDefaultBranchForCodeCommitSource": true,
    "@aws-cdk/aws-cloudwatch-actions:changeLambdaPermissionLogicalIdForLambdaAction": true,
    "@aws-cdk/aws-codepipeline:crossAccountKeysDefaultValueToFalse": true,
    "@aws-cdk/aws-codepipeline:defaultPipelineTypeToV2": true,
    "@aws-cdk/aws-kms:reduceCrossAccountRegionPolicyScope": true,
    "@aws-cdk/aws-eks:nodegroupNameAttribute": true,
    "@aws-cdk/aws-ec2:ebsDefaultGp3Volume": true,
    "@aws-cdk/aws-ecs:removeDefaultDeploymentAlarm": true,
    "@aws-cdk/custom-resources:logApiResponseDataPropertyTrueDefault": false,
    "@aws-cdk/aws-s3:keepNotificationInImportedBucket": false,
    "@aws-cdk/aws-ecs:enableImdsBlockingDeprecatedFeature": false,
    "@aws-cdk/aws-ecs:disableEcsImdsBlocking": true,
    "@aws-cdk/aws-ecs:reduceEc2FargateCloudWatchPermissions": true,
    "@aws-cdk/aws-dynamodb:resourcePolicyPerReplica": true,
    "@aws-cdk/aws-ec2:ec2SumTImeoutEnabled": true,
    "@aws-cdk/aws-appsync:appSyncGraphQLAPIScopeLambdaPermission": true,
    "@aws-cdk/aws-rds:setCorrectValueForDatabaseInstanceReadReplicaInstanceResourceId": true,
    "@aws-cdk/core:cfnIncludeRejectComplexResourceUpdateCreatePolicyIntrinsics": true,
    "@aws-cdk/aws-lambda-nodejs:sdkV3ExcludeSmithyPackages": true,
    "@aws-cdk/aws-stepfunctions-tasks:fixRunEcsTaskPolicy": true,
    "@aws-cdk/aws-ec2:bastionHostUseAmazonLinux2023ByDefault": true,
    "@aws-cdk/aws-route53-targets:userPoolDomainNameMethodWithoutCustomResource": true,
    "@aws-cdk/aws-elasticloadbalancingV2:albDualstackWithoutPublicIpv4SecurityGroupRulesDefault": true,
    "@aws-cdk/aws-iam:oidcRejectUnauthorizedConnections": true,
    "@aws-cdk/core:enableAdditionalMetadataCollection": true,
    "@aws-cdk/aws-lambda:createNewPoliciesWithAddToRolePolicy": false,
    "@aws-cdk/aws-s3:setUniqueReplicationRoleName": true,
    "@aws-cdk/aws-events:requireEventBusPolicySid": true,
    "@aws-cdk/core:aspectPrioritiesMutating": true,
    "@aws-cdk/aws-dynamodb:retainTableReplica": true,
    "@aws-cdk/aws-stepfunctions:useDistributedMapResultWriterV2": true,
    "@aws-cdk/s3-notifications:addS3TrustKeyPolicyForSnsSubscriptions": true,
    "@aws-cdk/aws-ec2:requirePrivateSubnetsForEgressOnlyInternetGateway": true,
    "@aws-cdk/aws-s3:publicAccessBlockedByDefault": true,
    "@aws-cdk/aws-lambda:useCdkManagedLogGroup": true
  }
}
```
