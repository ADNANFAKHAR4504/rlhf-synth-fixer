# Model Failure Analysis: Secure AWS Baseline Stack

### 1. Non-functional CloudWatch Alarms

The most significant failure is the creation of multiple `CloudwatchMetricAlarm` resources that reference metrics that do not exist.

- Failure: The model created alarms for metrics like `RootAccountUsage`, `UnauthorizedAPICalls`, and `FailedConsoleLogins` using the `CloudTrailMetrics` namespace (e.g., `rootAccountAlarm`, `unauthorizedApiAlarm`).
- Why this is wrong: These metrics are not available in AWS by default. To monitor CloudTrail events, you must first create a CloudTrail, direct its logs to a CloudWatch Log Group, and then create CloudWatch Log Metric Filters to parse those logs and generate the custom metrics.
- Ideal Implementation: The `IDEAL_RESPONSE.md` file correctly demonstrates this pattern by creating a `Cloudtrail`, a `CloudwatchLogGroup`, `CloudwatchLogMetricFilter` resources (`root-user-filter`, `login-failure-filter`), and _then_ creating `CloudwatchMetricAlarm` resources that target the metrics generated by those filters. The model's alarms would fail to deploy or would never fire.

### 2. Inefficient and Incorrect Import Strategy

The model used an inefficient and outdated import style for the AWS provider.

- Failure: The model used a single, massive wildcard import:
  `import { ..., ..., ... } from '@cdktf/provider-aws';`
- Why this is wrong: The CDKTF documentation and best practices strongly recommend using deep imports for each resource. Wildcard imports pull in the entire provider, significantly increasing synth times and memory usage.
- Ideal Implementation: The `IDEAL_RESPONSE.md` correctly uses specific, deep imports, which is the standard practice:
  ```typescript
  import { KmsKey } from '@cdktf/provider-aws/lib/kms-key';
  import { IamRole } from '@cdktf/provider-aws/lib/iam-role';
  import { IamPolicy } from '@cdktf/provider-aws/lib/iam-policy';
  ```

### 3. Poor Readability due to Inlined JSON

The model repeatedly inlined large, complex JSON policy documents directly into resource definitions.

- Failure: Resources like `iam.IamRole` (`mfaTrustPolicy`), `s3.S3BucketPolicy` (`config-bucket-policy`), and `awsConfig.ConfigConfigRule` (`iamPasswordPolicyRule`) have large `JSON.stringify({...})` blocks directly in their properties.
- Why this is wrong: This practice makes the code extremely difficult to read, debug, and maintain.
- Ideal Implementation: The `IDEAL_RESPONSE.md` file correctly abstracts these documents into separate `const` variables (e.g., `mfaPolicyDocument`, `assumeRolePolicy`, `trailBucketPolicyJson`). This makes the resource definition clean and the policy logic reusable and easy to read.

### 4. Missing Explicit Dependencies (Race Condition)

The model failed to declare an explicit dependency between a resource and the policy it requires, creating a potential race condition.

- Failure: The model created a `configBucket` and a `config-bucket-policy` (which allows the `config.amazonaws.com` service principal to write to the bucket). It then created a `ConfigDeliveryChannel` that _uses_ that bucket, but it did not add an explicit `dependsOn` for the `config-bucket-policy`.
- Why this is wrong: During deployment, Terraform might try to create the `ConfigDeliveryChannel` _before_ the `S3BucketPolicy` is fully applied. This would cause the configuration recorder to fail, as it would be denied permission to write to the bucket.
- Ideal Implementation: The `IDEAL_RESPONSE.md` explicitly demonstrates this correct pattern. It creates a `trail` that depends on a `trailBucketPolicyResource` (`dependsOn: [trailBucketPolicyResource]`) to ensure the policy is active _before_ CloudTrail tries to use it.
