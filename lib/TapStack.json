{
  "AWSTemplateFormatVersion": "2010-09-09",
  "Description": "Serverless Polling and Voting System with Real-time Results and Analytics",
  "Parameters": {
    "Environment": {
      "Type": "String",
      "Default": "production",
      "AllowedValues": [
        "development",
        "staging",
        "production"
      ],
      "Description": "Environment name"
    },
    "ApiThrottleRateLimit": {
      "Type": "Number",
      "Default": 100,
      "Description": "API Gateway throttle rate limit per second"
    },
    "ApiThrottleBurstLimit": {
      "Type": "Number",
      "Default": 200,
      "Description": "API Gateway throttle burst limit"
    },
    "ElastiCacheNodeType": {
      "Type": "String",
      "Default": "cache.t3.micro",
      "AllowedValues": [
        "cache.t3.micro",
        "cache.t3.small",
        "cache.t3.medium"
      ],
      "Description": "ElastiCache node instance type"
    },
    "QuickSightUserArn": {
      "Type": "String",
      "Description": "ARN of the QuickSight user/group for dashboard access",
      "Default": ""
    }
  },
  "Conditions": {
    "HasQuickSightUser": {
      "Fn::Not": [
        {
          "Fn::Equals": [
            {
              "Ref": "QuickSightUserArn"
            },
            ""
          ]
        }
      ]
    }
  },
  "Resources": {
    "VotingVPC": {
      "Type": "AWS::EC2::VPC",
      "Properties": {
        "CidrBlock": "10.0.0.0/16",
        "EnableDnsHostnames": true,
        "EnableDnsSupport": true,
        "Tags": [
          {
            "Key": "Name",
            "Value": {
              "Fn::Sub": "${AWS::StackName}-vpc"
            }
          }
        ]
      }
    },
    "PrivateSubnet1": {
      "Type": "AWS::EC2::Subnet",
      "Properties": {
        "VpcId": {
          "Ref": "VotingVPC"
        },
        "CidrBlock": "10.0.1.0/24",
        "AvailabilityZone": {
          "Fn::Select": [
            0,
            {
              "Fn::GetAZs": ""
            }
          ]
        },
        "Tags": [
          {
            "Key": "Name",
            "Value": {
              "Fn::Sub": "${AWS::StackName}-private-subnet-1"
            }
          }
        ]
      }
    },
    "PrivateSubnet2": {
      "Type": "AWS::EC2::Subnet",
      "Properties": {
        "VpcId": {
          "Ref": "VotingVPC"
        },
        "CidrBlock": "10.0.2.0/24",
        "AvailabilityZone": {
          "Fn::Select": [
            1,
            {
              "Fn::GetAZs": ""
            }
          ]
        },
        "Tags": [
          {
            "Key": "Name",
            "Value": {
              "Fn::Sub": "${AWS::StackName}-private-subnet-2"
            }
          }
        ]
      }
    },
    "SecurityGroupLambda": {
      "Type": "AWS::EC2::SecurityGroup",
      "Properties": {
        "GroupDescription": "Security group for Lambda functions",
        "VpcId": {
          "Ref": "VotingVPC"
        },
        "SecurityGroupEgress": [
          {
            "IpProtocol": -1,
            "CidrIp": "0.0.0.0/0"
          }
        ],
        "Tags": [
          {
            "Key": "Name",
            "Value": {
              "Fn::Sub": "${AWS::StackName}-lambda-sg"
            }
          }
        ]
      }
    },
    "SecurityGroupElastiCache": {
      "Type": "AWS::EC2::SecurityGroup",
      "Properties": {
        "GroupDescription": "Security group for ElastiCache",
        "VpcId": {
          "Ref": "VotingVPC"
        },
        "SecurityGroupIngress": [
          {
            "IpProtocol": "tcp",
            "FromPort": 6379,
            "ToPort": 6379,
            "SourceSecurityGroupId": {
              "Ref": "SecurityGroupLambda"
            }
          }
        ],
        "Tags": [
          {
            "Key": "Name",
            "Value": {
              "Fn::Sub": "${AWS::StackName}-elasticache-sg"
            }
          }
        ]
      }
    },
    "VotesTable": {
      "Type": "AWS::DynamoDB::Table",
      "Properties": {
        "TableName": {
          "Fn::Sub": "${AWS::StackName}-votes"
        },
        "BillingMode": "PAY_PER_REQUEST",
        "StreamSpecification": {
          "StreamViewType": "NEW_AND_OLD_IMAGES"
        },
        "AttributeDefinitions": [
          {
            "AttributeName": "voteId",
            "AttributeType": "S"
          },
          {
            "AttributeName": "pollId",
            "AttributeType": "S"
          },
          {
            "AttributeName": "timestamp",
            "AttributeType": "N"
          },
          {
            "AttributeName": "voterId",
            "AttributeType": "S"
          }
        ],
        "KeySchema": [
          {
            "AttributeName": "voteId",
            "KeyType": "HASH"
          }
        ],
        "GlobalSecondaryIndexes": [
          {
            "IndexName": "PollIndex",
            "KeySchema": [
              {
                "AttributeName": "pollId",
                "KeyType": "HASH"
              },
              {
                "AttributeName": "timestamp",
                "KeyType": "RANGE"
              }
            ],
            "Projection": {
              "ProjectionType": "ALL"
            }
          },
          {
            "IndexName": "VoterIndex",
            "KeySchema": [
              {
                "AttributeName": "voterId",
                "KeyType": "HASH"
              },
              {
                "AttributeName": "timestamp",
                "KeyType": "RANGE"
              }
            ],
            "Projection": {
              "ProjectionType": "KEYS_ONLY"
            }
          }
        ],
        "PointInTimeRecoverySpecification": {
          "PointInTimeRecoveryEnabled": true
        },
        "SSESpecification": {
          "SSEEnabled": true
        },
        "Tags": [
          {
            "Key": "Environment",
            "Value": {
              "Ref": "Environment"
            }
          }
        ]
      }
    },
    "PollsTable": {
      "Type": "AWS::DynamoDB::Table",
      "Properties": {
        "TableName": {
          "Fn::Sub": "${AWS::StackName}-polls"
        },
        "BillingMode": "PAY_PER_REQUEST",
        "AttributeDefinitions": [
          {
            "AttributeName": "pollId",
            "AttributeType": "S"
          },
          {
            "AttributeName": "status",
            "AttributeType": "S"
          },
          {
            "AttributeName": "createdAt",
            "AttributeType": "N"
          }
        ],
        "KeySchema": [
          {
            "AttributeName": "pollId",
            "KeyType": "HASH"
          }
        ],
        "GlobalSecondaryIndexes": [
          {
            "IndexName": "StatusIndex",
            "KeySchema": [
              {
                "AttributeName": "status",
                "KeyType": "HASH"
              },
              {
                "AttributeName": "createdAt",
                "KeyType": "RANGE"
              }
            ],
            "Projection": {
              "ProjectionType": "ALL"
            }
          }
        ],
        "SSESpecification": {
          "SSEEnabled": true
        },
        "Tags": [
          {
            "Key": "Environment",
            "Value": {
              "Ref": "Environment"
            }
          }
        ]
      }
    },
    "IdempotencyTable": {
      "Type": "AWS::DynamoDB::Table",
      "Properties": {
        "TableName": {
          "Fn::Sub": "${AWS::StackName}-idempotency"
        },
        "BillingMode": "PAY_PER_REQUEST",
        "AttributeDefinitions": [
          {
            "AttributeName": "idempotencyKey",
            "AttributeType": "S"
          }
        ],
        "KeySchema": [
          {
            "AttributeName": "idempotencyKey",
            "KeyType": "HASH"
          }
        ],
        "TimeToLiveSpecification": {
          "AttributeName": "ttl",
          "Enabled": true
        },
        "SSESpecification": {
          "SSEEnabled": true
        },
        "Tags": [
          {
            "Key": "Environment",
            "Value": {
              "Ref": "Environment"
            }
          }
        ]
      }
    },
    "ElastiCacheSubnetGroup": {
      "Type": "AWS::ElastiCache::SubnetGroup",
      "Properties": {
        "Description": "Subnet group for ElastiCache",
        "SubnetIds": [
          {
            "Ref": "PrivateSubnet1"
          },
          {
            "Ref": "PrivateSubnet2"
          }
        ]
      }
    },
    "ElastiCacheCluster": {
      "Type": "AWS::ElastiCache::ReplicationGroup",
      "Properties": {
        "ReplicationGroupId": {
          "Fn::Sub": "${AWS::StackName}-cache"
        },
        "ReplicationGroupDescription": "Redis cache for real-time vote results",
        "Engine": "redis",
        "CacheNodeType": {
          "Ref": "ElastiCacheNodeType"
        },
        "NumCacheClusters": 2,
        "AutomaticFailoverEnabled": true,
        "MultiAZEnabled": true,
        "CacheSubnetGroupName": {
          "Ref": "ElastiCacheSubnetGroup"
        },
        "SecurityGroupIds": [
          {
            "Ref": "SecurityGroupElastiCache"
          }
        ],
        "AtRestEncryptionEnabled": true,
        "TransitEncryptionEnabled": true,
        "SnapshotRetentionLimit": 7,
        "Tags": [
          {
            "Key": "Environment",
            "Value": {
              "Ref": "Environment"
            }
          }
        ]
      }
    },
    "ResultsBucket": {
      "Type": "AWS::S3::Bucket",
      "Properties": {
        "BucketEncryption": {
          "ServerSideEncryptionConfiguration": [
            {
              "ServerSideEncryptionByDefault": {
                "SSEAlgorithm": "AES256"
              }
            }
          ]
        },
        "VersioningConfiguration": {
          "Status": "Enabled"
        },
        "LifecycleConfiguration": {
          "Rules": [
            {
              "Id": "ArchiveOldResults",
              "Status": "Enabled",
              "Transitions": [
                {
                  "TransitionInDays": 30,
                  "StorageClass": "STANDARD_IA"
                },
                {
                  "TransitionInDays": 90,
                  "StorageClass": "GLACIER"
                }
              ]
            }
          ]
        },
        "PublicAccessBlockConfiguration": {
          "BlockPublicAcls": true,
          "BlockPublicPolicy": true,
          "IgnorePublicAcls": true,
          "RestrictPublicBuckets": true
        },
        "Tags": [
          {
            "Key": "Environment",
            "Value": {
              "Ref": "Environment"
            }
          }
        ]
      }
    },
    "LambdaExecutionRole": {
      "Type": "AWS::IAM::Role",
      "Properties": {
        "AssumeRolePolicyDocument": {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Effect": "Allow",
              "Principal": {
                "Service": "lambda.amazonaws.com"
              },
              "Action": "sts:AssumeRole"
            }
          ]
        },
        "ManagedPolicyArns": [
          "arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole"
        ],
        "Policies": [
          {
            "PolicyName": "DynamoDBAccess",
            "PolicyDocument": {
              "Version": "2012-10-17",
              "Statement": [
                {
                  "Effect": "Allow",
                  "Action": [
                    "dynamodb:PutItem",
                    "dynamodb:GetItem",
                    "dynamodb:UpdateItem",
                    "dynamodb:Query",
                    "dynamodb:Scan",
                    "dynamodb:BatchWriteItem",
                    "dynamodb:DescribeTable"
                  ],
                  "Resource": [
                    {
                      "Fn::GetAtt": [
                        "VotesTable",
                        "Arn"
                      ]
                    },
                    {
                      "Fn::Sub": "${VotesTable.Arn}/index/*"
                    },
                    {
                      "Fn::GetAtt": [
                        "PollsTable",
                        "Arn"
                      ]
                    },
                    {
                      "Fn::Sub": "${PollsTable.Arn}/index/*"
                    },
                    {
                      "Fn::GetAtt": [
                        "IdempotencyTable",
                        "Arn"
                      ]
                    }
                  ]
                }
              ]
            }
          },
          {
            "PolicyName": "ElastiCacheAccess",
            "PolicyDocument": {
              "Version": "2012-10-17",
              "Statement": [
                {
                  "Effect": "Allow",
                  "Action": [
                    "elasticache:DescribeCacheClusters",
                    "elasticache:DescribeReplicationGroups"
                  ],
                  "Resource": "*"
                }
              ]
            }
          },
          {
            "PolicyName": "S3Access",
            "PolicyDocument": {
              "Version": "2012-10-17",
              "Statement": [
                {
                  "Effect": "Allow",
                  "Action": [
                    "s3:PutObject",
                    "s3:GetObject",
                    "s3:ListBucket"
                  ],
                  "Resource": [
                    {
                      "Fn::GetAtt": [
                        "ResultsBucket",
                        "Arn"
                      ]
                    },
                    {
                      "Fn::Sub": "${ResultsBucket.Arn}/*"
                    }
                  ]
                }
              ]
            }
          },
          {
            "PolicyName": "CloudWatchMetrics",
            "PolicyDocument": {
              "Version": "2012-10-17",
              "Statement": [
                {
                  "Effect": "Allow",
                  "Action": [
                    "cloudwatch:PutMetricData"
                  ],
                  "Resource": "*"
                }
              ]
            }
          }
        ]
      }
    },
    "VoteProcessorFunction": {
      "Type": "AWS::Lambda::Function",
      "Properties": {
        "FunctionName": {
          "Fn::Sub": "${AWS::StackName}-vote-processor"
        },
        "Runtime": "python3.10",
        "Handler": "index.lambda_handler",
        "Role": {
          "Fn::GetAtt": [
            "LambdaExecutionRole",
            "Arn"
          ]
        },
        "Timeout": 30,
        "MemorySize": 512,
        "Environment": {
          "Variables": {
            "VOTES_TABLE": {
              "Ref": "VotesTable"
            },
            "POLLS_TABLE": {
              "Ref": "PollsTable"
            },
            "IDEMPOTENCY_TABLE": {
              "Ref": "IdempotencyTable"
            },
            "REDIS_ENDPOINT": {
              "Fn::GetAtt": [
                "ElastiCacheCluster",
                "PrimaryEndPoint.Address"
              ]
            },
            "REDIS_PORT": {
              "Fn::GetAtt": [
                "ElastiCacheCluster",
                "PrimaryEndPoint.Port"
              ]
            },
            "ENVIRONMENT": {
              "Ref": "Environment"
            }
          }
        },
        "VpcConfig": {
          "SecurityGroupIds": [
            {
              "Ref": "SecurityGroupLambda"
            }
          ],
          "SubnetIds": [
            {
              "Ref": "PrivateSubnet1"
            },
            {
              "Ref": "PrivateSubnet2"
            }
          ]
        },
        "Code": {
          "ZipFile": "import json\nimport boto3\nimport redis\nimport hashlib\nimport time\nimport os\nfrom datetime import datetime, timedelta\nfrom decimal import Decimal\nfrom botocore.exceptions import ClientError\n\n# Initialize clients\ndynamodb = boto3.resource('dynamodb')\ncloudwatch = boto3.client('cloudwatch')\n\n# Environment variables\nVOTES_TABLE = os.environ['VOTES_TABLE']\nPOLLS_TABLE = os.environ['POLLS_TABLE']\nIDEMPOTENCY_TABLE = os.environ['IDEMPOTENCY_TABLE']\nREDIS_ENDPOINT = os.environ['REDIS_ENDPOINT']\nREDIS_PORT = int(os.environ['REDIS_PORT'])\n\n# Initialize Redis connection\nredis_client = redis.Redis(\n    host=REDIS_ENDPOINT,\n    port=REDIS_PORT,\n    decode_responses=True,\n    socket_connect_timeout=5,\n    socket_timeout=5\n)\n\ndef lambda_handler(event, context):\n    try:\n        body = json.loads(event['body'])\n        \n        # Extract vote data\n        poll_id = body['pollId']\n        option_id = body['optionId']\n        voter_id = body.get('voterId', event['requestContext']['identity']['sourceIp'])\n        idempotency_key = body.get('idempotencyKey', '')\n        demographics = body.get('demographics', {})\n        \n        # Check idempotency\n        if idempotency_key:\n            if not check_idempotency(idempotency_key):\n                return {\n                    'statusCode': 409,\n                    'body': json.dumps({'message': 'Duplicate vote detected'})\n                }\n        \n        # Generate vote ID\n        vote_id = generate_vote_id(poll_id, voter_id, option_id)\n        \n        # Store vote\n        vote_data = store_vote(vote_id, poll_id, option_id, voter_id, demographics)\n        \n        # Update atomic counters\n        update_vote_counts(poll_id, option_id)\n        \n        # Update Redis cache\n        update_redis_cache(poll_id, option_id)\n        \n        # Send metrics to CloudWatch\n        send_metrics(poll_id, demographics)\n        \n        return {\n            'statusCode': 200,\n            'body': json.dumps({\n                'message': 'Vote processed successfully',\n                'voteId': vote_id\n            })\n        }\n        \n    except Exception as e:\n        print(f\"Error processing vote: {str(e)}\")\n        return {\n            'statusCode': 500,\n            'body': json.dumps({'message': 'Internal server error'})\n        }\n\ndef check_idempotency(idempotency_key):\n    \"\"\"Check and set idempotency key with TTL\"\"\"\n    table = dynamodb.Table(IDEMPOTENCY_TABLE)\n    ttl = int(time.time()) + 86400  # 24 hours TTL\n    \n    try:\n        table.put_item(\n            Item={\n                'idempotencyKey': idempotency_key,\n                'ttl': ttl,\n                'timestamp': int(time.time())\n            },\n            ConditionExpression='attribute_not_exists(idempotencyKey)'\n        )\n        return True\n    except ClientError as e:\n        if e.response['Error']['Code'] == 'ConditionalCheckFailedException':\n            return False\n        raise\n\ndef generate_vote_id(poll_id, voter_id, option_id):\n    \"\"\"Generate unique vote ID\"\"\"\n    timestamp = str(int(time.time() * 1000000))\n    data = f\"{poll_id}{voter_id}{option_id}{timestamp}\"\n    return hashlib.sha256(data.encode()).hexdigest()[:16]\n\ndef store_vote(vote_id, poll_id, option_id, voter_id, demographics):\n    \"\"\"Store vote in DynamoDB\"\"\"\n    table = dynamodb.Table(VOTES_TABLE)\n    \n    vote_data = {\n        'voteId': vote_id,\n        'pollId': poll_id,\n        'optionId': option_id,\n        'voterId': voter_id,\n        'timestamp': Decimal(str(time.time())),\n        'demographics': demographics,\n        'createdAt': datetime.utcnow().isoformat()\n    }\n    \n    table.put_item(Item=vote_data)\n    return vote_data\n\ndef update_vote_counts(poll_id, option_id):\n    \"\"\"Update atomic counters in DynamoDB\"\"\"\n    table = dynamodb.Table(POLLS_TABLE)\n    \n    table.update_item(\n        Key={'pollId': poll_id},\n        UpdateExpression='ADD #votes.#option :val, totalVotes :val',\n        ExpressionAttributeNames={\n            '#votes': 'votes',\n            '#option': option_id\n        },\n        ExpressionAttributeValues={\n            ':val': 1\n        }\n    )\n\ndef update_redis_cache(poll_id, option_id):\n    \"\"\"Update real-time vote counts in Redis\"\"\"\n    try:\n        # Increment vote count\n        redis_client.hincrby(f\"poll:{poll_id}:votes\", option_id, 1)\n        redis_client.incr(f\"poll:{poll_id}:total\")\n        \n        # Set expiry for 1 hour\n        redis_client.expire(f\"poll:{poll_id}:votes\", 3600)\n        redis_client.expire(f\"poll:{poll_id}:total\", 3600)\n    except Exception as e:\n        print(f\"Redis error: {str(e)}\")\n        # Continue processing even if Redis fails\n\ndef send_metrics(poll_id, demographics):\n    \"\"\"Send custom metrics to CloudWatch\"\"\"\n    try:\n        metrics = []\n        \n        # Vote count metric\n        metrics.append({\n            'MetricName': 'VoteCount',\n            'Dimensions': [\n                {'Name': 'PollId', 'Value': poll_id}\n            ],\n            'Value': 1,\n            'Unit': 'Count'\n        })\n        \n        # Demographics metrics\n        if 'ageGroup' in demographics:\n            metrics.append({\n                'MetricName': 'VotesByAgeGroup',\n                'Dimensions': [\n                    {'Name': 'AgeGroup', 'Value': demographics['ageGroup']}\n                ],\n                'Value': 1,\n                'Unit': 'Count'\n            })\n        \n        cloudwatch.put_metric_data(\n            Namespace='VotingSystem',\n            MetricData=metrics\n        )\n    except Exception as e:\n        print(f\"CloudWatch metrics error: {str(e)}\")\n"
        },
        "Tags": [
          {
            "Key": "Environment",
            "Value": {
              "Ref": "Environment"
            }
          }
        ]
      }
    },
    "ResultsExporterFunction": {
      "Type": "AWS::Lambda::Function",
      "Properties": {
        "FunctionName": {
          "Fn::Sub": "${AWS::StackName}-results-exporter"
        },
        "Runtime": "python3.10",
        "Handler": "index.lambda_handler",
        "Role": {
          "Fn::GetAtt": [
            "LambdaExecutionRole",
            "Arn"
          ]
        },
        "Timeout": 300,
        "MemorySize": 1024,
        "Environment": {
          "Variables": {
            "VOTES_TABLE": {
              "Ref": "VotesTable"
            },
            "POLLS_TABLE": {
              "Ref": "PollsTable"
            },
            "RESULTS_BUCKET": {
              "Ref": "ResultsBucket"
            },
            "ENVIRONMENT": {
              "Ref": "Environment"
            }
          }
        },
        "Code": {
          "ZipFile": "import json\nimport boto3\nimport csv\nimport io\nimport os\nfrom datetime import datetime, timedelta\nfrom decimal import Decimal\n\ndynamodb = boto3.resource('dynamodb')\ns3 = boto3.client('s3')\n\nVOTES_TABLE = os.environ['VOTES_TABLE']\nPOLLS_TABLE = os.environ['POLLS_TABLE']\nRESULTS_BUCKET = os.environ['RESULTS_BUCKET']\n\ndef lambda_handler(event, context):\n    try:\n        # Get all active polls\n        polls = get_active_polls()\n        \n        for poll in polls:\n            export_poll_results(poll['pollId'])\n        \n        return {\n            'statusCode': 200,\n            'body': json.dumps({\n                'message': f'Successfully exported results for {len(polls)} polls'\n            })\n        }\n        \n    except Exception as e:\n        print(f\"Error exporting results: {str(e)}\")\n        return {\n            'statusCode': 500,\n            'body': json.dumps({'message': 'Error exporting results'})\n        }\n\ndef get_active_polls():\n    \"\"\"Get all active polls from DynamoDB\"\"\"\n    table = dynamodb.Table(POLLS_TABLE)\n    \n    response = table.scan(\n        FilterExpression='#status = :status',\n        ExpressionAttributeNames={'#status': 'status'},\n        ExpressionAttributeValues={':status': 'active'}\n    )\n    \n    return response.get('Items', [])\n\ndef export_poll_results(poll_id):\n    \"\"\"Export poll results to S3\"\"\"\n    votes_table = dynamodb.Table(VOTES_TABLE)\n    \n    # Query all votes for the poll\n    votes = []\n    last_evaluated_key = None\n    \n    while True:\n        if last_evaluated_key:\n            response = votes_table.query(\n                IndexName='PollIndex',\n                KeyConditionExpression='pollId = :pollId',\n                ExpressionAttributeValues={':pollId': poll_id},\n                ExclusiveStartKey=last_evaluated_key\n            )\n        else:\n            response = votes_table.query(\n                IndexName='PollIndex',\n                KeyConditionExpression='pollId = :pollId',\n                ExpressionAttributeValues={':pollId': poll_id}\n            )\n        \n        votes.extend(response['Items'])\n        \n        last_evaluated_key = response.get('LastEvaluatedKey')\n        if not last_evaluated_key:\n            break\n    \n    # Generate CSV\n    csv_buffer = io.StringIO()\n    csv_writer = csv.DictWriter(\n        csv_buffer,\n        fieldnames=['voteId', 'pollId', 'optionId', 'voterId', 'timestamp', 'demographics']\n    )\n    csv_writer.writeheader()\n    \n    for vote in votes:\n        csv_writer.writerow({\n            'voteId': vote.get('voteId'),\n            'pollId': vote.get('pollId'),\n            'optionId': vote.get('optionId'),\n            'voterId': vote.get('voterId'),\n            'timestamp': str(vote.get('timestamp')),\n            'demographics': json.dumps(vote.get('demographics', {}))\n        })\n    \n    # Upload to S3\n    timestamp = datetime.utcnow().strftime('%Y%m%d_%H%M%S')\n    key = f\"exports/{poll_id}/{timestamp}_results.csv\"\n    \n    s3.put_object(\n        Bucket=RESULTS_BUCKET,\n        Key=key,\n        Body=csv_buffer.getvalue(),\n        ContentType='text/csv'\n    )\n    \n    print(f\"Exported {len(votes)} votes to s3://{RESULTS_BUCKET}/{key}\")\n"
        },
        "Tags": [
          {
            "Key": "Environment",
            "Value": {
              "Ref": "Environment"
            }
          }
        ]
      }
    },
    "VotingApi": {
      "Type": "AWS::ApiGateway::RestApi",
      "Properties": {
        "Name": {
          "Fn::Sub": "${AWS::StackName}-api"
        },
        "Description": "Voting System API",
        "EndpointConfiguration": {
          "Types": [
            "REGIONAL"
          ]
        }
      }
    },
    "VotingApiDeployment": {
      "Type": "AWS::ApiGateway::Deployment",
      "DependsOn": [
        "VoteMethod",
        "ResultsMethod"
      ],
      "Properties": {
        "RestApiId": {
          "Ref": "VotingApi"
        }
      }
    },
    "VotingApiStage": {
      "Type": "AWS::ApiGateway::Stage",
      "Properties": {
        "StageName": {
          "Ref": "Environment"
        },
        "RestApiId": {
          "Ref": "VotingApi"
        },
        "DeploymentId": {
          "Ref": "VotingApiDeployment"
        },
        "MethodSettings": [
          {
            "ResourcePath": "/*",
            "HttpMethod": "*",
            "MetricsEnabled": true,
            "ThrottlingRateLimit": {
              "Ref": "ApiThrottleRateLimit"
            },
            "ThrottlingBurstLimit": {
              "Ref": "ApiThrottleBurstLimit"
            }
          }
        ]
      }
    },
    "VoteResource": {
      "Type": "AWS::ApiGateway::Resource",
      "Properties": {
        "RestApiId": {
          "Ref": "VotingApi"
        },
        "ParentId": {
          "Fn::GetAtt": [
            "VotingApi",
            "RootResourceId"
          ]
        },
        "PathPart": "vote"
      }
    },
    "VoteMethod": {
      "Type": "AWS::ApiGateway::Method",
      "Properties": {
        "RestApiId": {
          "Ref": "VotingApi"
        },
        "ResourceId": {
          "Ref": "VoteResource"
        },
        "HttpMethod": "POST",
        "AuthorizationType": "NONE",
        "RequestValidatorId": {
          "Ref": "RequestValidator"
        },
        "RequestModels": {
          "application/json": {
            "Ref": "VoteModel"
          }
        },
        "Integration": {
          "Type": "AWS_PROXY",
          "IntegrationHttpMethod": "POST",
          "Uri": {
            "Fn::Sub": "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${VoteProcessorFunction.Arn}/invocations"
          }
        }
      }
    },
    "ResultsResource": {
      "Type": "AWS::ApiGateway::Resource",
      "Properties": {
        "RestApiId": {
          "Ref": "VotingApi"
        },
        "ParentId": {
          "Fn::GetAtt": [
            "VotingApi",
            "RootResourceId"
          ]
        },
        "PathPart": "results"
      }
    },
    "ResultsMethod": {
      "Type": "AWS::ApiGateway::Method",
      "Properties": {
        "RestApiId": {
          "Ref": "VotingApi"
        },
        "ResourceId": {
          "Ref": "ResultsResource"
        },
        "HttpMethod": "GET",
        "AuthorizationType": "NONE",
        "Integration": {
          "Type": "AWS_PROXY",
          "IntegrationHttpMethod": "POST",
          "Uri": {
            "Fn::Sub": "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${VoteProcessorFunction.Arn}/invocations"
          }
        }
      }
    },
    "RequestValidator": {
      "Type": "AWS::ApiGateway::RequestValidator",
      "Properties": {
        "RestApiId": {
          "Ref": "VotingApi"
        },
        "Name": "RequestBodyValidator",
        "ValidateRequestBody": true,
        "ValidateRequestParameters": false
      }
    },
    "VoteModel": {
      "Type": "AWS::ApiGateway::Model",
      "Properties": {
        "RestApiId": {
          "Ref": "VotingApi"
        },
        "ContentType": "application/json",
        "Name": "VoteModel",
        "Schema": {
          "$schema": "http://json-schema.org/draft-04/schema#",
          "title": "Vote",
          "type": "object",
          "required": [
            "pollId",
            "optionId"
          ],
          "properties": {
            "pollId": {
              "type": "string",
              "minLength": 1
            },
            "optionId": {
              "type": "string",
              "minLength": 1
            },
            "idempotencyKey": {
              "type": "string"
            },
            "demographics": {
              "type": "object",
              "properties": {
                "ageGroup": {
                  "type": "string"
                },
                "location": {
                  "type": "string"
                },
                "gender": {
                  "type": "string"
                }
              }
            }
          }
        }
      }
    },
    "ApiGatewayInvokePermission": {
      "Type": "AWS::Lambda::Permission",
      "Properties": {
        "FunctionName": {
          "Ref": "VoteProcessorFunction"
        },
        "Action": "lambda:InvokeFunction",
        "Principal": "apigateway.amazonaws.com",
        "SourceArn": {
          "Fn::Sub": "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${VotingApi}/*/*/*"
        }
      }
    },
    "ResultsExportSchedule": {
      "Type": "AWS::Events::Rule",
      "Properties": {
        "Name": {
          "Fn::Sub": "${AWS::StackName}-export-schedule"
        },
        "Description": "Schedule for exporting voting results",
        "ScheduleExpression": "rate(1 hour)",
        "State": "ENABLED",
        "Targets": [
          {
            "Arn": {
              "Fn::GetAtt": [
                "ResultsExporterFunction",
                "Arn"
              ]
            },
            "Id": "ResultsExporter"
          }
        ]
      }
    },
    "SchedulePermission": {
      "Type": "AWS::Lambda::Permission",
      "Properties": {
        "FunctionName": {
          "Ref": "ResultsExporterFunction"
        },
        "Action": "lambda:InvokeFunction",
        "Principal": "events.amazonaws.com",
        "SourceArn": {
          "Fn::GetAtt": [
            "ResultsExportSchedule",
            "Arn"
          ]
        }
      }
    },
    "HighVoteVolumeAlarm": {
      "Type": "AWS::CloudWatch::Alarm",
      "Properties": {
        "AlarmName": {
          "Fn::Sub": "${AWS::StackName}-high-vote-volume"
        },
        "AlarmDescription": "Alert when vote volume exceeds threshold",
        "MetricName": "VoteCount",
        "Namespace": "VotingSystem",
        "Statistic": "Sum",
        "Period": 300,
        "EvaluationPeriods": 2,
        "Threshold": 100,
        "ComparisonOperator": "GreaterThanThreshold"
      }
    },
    "LambdaErrorAlarm": {
      "Type": "AWS::CloudWatch::Alarm",
      "Properties": {
        "AlarmName": {
          "Fn::Sub": "${AWS::StackName}-lambda-errors"
        },
        "AlarmDescription": "Alert on Lambda function errors",
        "MetricName": "Errors",
        "Namespace": "AWS/Lambda",
        "Dimensions": [
          {
            "Name": "FunctionName",
            "Value": {
              "Ref": "VoteProcessorFunction"
            }
          }
        ],
        "Statistic": "Sum",
        "Period": 60,
        "EvaluationPeriods": 2,
        "Threshold": 5,
        "ComparisonOperator": "GreaterThanThreshold"
      }
    },
    "QuickSightDataSource": {
      "Type": "AWS::QuickSight::DataSource",
      "Condition": "HasQuickSightUser",
      "Properties": {
        "DataSourceId": {
          "Fn::Sub": "${AWS::StackName}-datasource"
        },
        "Name": {
          "Fn::Sub": "${AWS::StackName} Voting Data"
        },
        "Type": "S3",
        "AwsAccountId": {
          "Ref": "AWS::AccountId"
        },
        "DataSourceParameters": {
          "S3Parameters": {
            "ManifestFileLocation": {
              "Bucket": {
                "Ref": "ResultsBucket"
              },
              "Key": "quicksight/manifest.json"
            }
          }
        }
      }
    },
    "QuickSightDataSet": {
      "Type": "AWS::QuickSight::DataSet",
      "Condition": "HasQuickSightUser",
      "Properties": {
        "DataSetId": {
          "Fn::Sub": "${AWS::StackName}-dataset"
        },
        "Name": {
          "Fn::Sub": "${AWS::StackName} Voting Dataset"
        },
        "AwsAccountId": {
          "Ref": "AWS::AccountId"
        },
        "ImportMode": "SPICE",
        "PhysicalTableMap": {
          "VotingData": {
            "S3Source": {
              "DataSourceArn": {
                "Fn::GetAtt": [
                  "QuickSightDataSource",
                  "Arn"
                ]
              },
              "InputColumns": [
                {
                  "Name": "voteId",
                  "Type": "STRING"
                },
                {
                  "Name": "pollId",
                  "Type": "STRING"
                },
                {
                  "Name": "optionId",
                  "Type": "STRING"
                },
                {
                  "Name": "timestamp",
                  "Type": "DATETIME"
                },
                {
                  "Name": "demographics",
                  "Type": "STRING"
                }
              ]
            }
          }
        }
      }
    }
  },
  "Outputs": {
    "ApiEndpoint": {
      "Description": "API Gateway endpoint URL",
      "Value": {
        "Fn::Sub": "https://${VotingApi}.execute-api.${AWS::Region}.amazonaws.com/${Environment}"
      },
      "Export": {
        "Name": {
          "Fn::Sub": "${AWS::StackName}-api-endpoint"
        }
      }
    },
    "VotesTableName": {
      "Description": "DynamoDB Votes table name",
      "Value": {
        "Ref": "VotesTable"
      },
      "Export": {
        "Name": {
          "Fn::Sub": "${AWS::StackName}-votes-table"
        }
      }
    },
    "PollsTableName": {
      "Description": "DynamoDB Polls table name",
      "Value": {
        "Ref": "PollsTable"
      },
      "Export": {
        "Name": {
          "Fn::Sub": "${AWS::StackName}-polls-table"
        }
      }
    },
    "ResultsBucketName": {
      "Description": "S3 bucket for results",
      "Value": {
        "Ref": "ResultsBucket"
      },
      "Export": {
        "Name": {
          "Fn::Sub": "${AWS::StackName}-results-bucket"
        }
      }
    },
    "ElastiCacheEndpoint": {
      "Description": "ElastiCache Redis endpoint",
      "Value": {
        "Fn::GetAtt": [
          "ElastiCacheCluster",
          "PrimaryEndPoint.Address"
        ]
      },
      "Export": {
        "Name": {
          "Fn::Sub": "${AWS::StackName}-redis-endpoint"
        }
      }
    },
    "VoteProcessorFunctionArn": {
      "Description": "Vote processor Lambda function ARN",
      "Value": {
        "Fn::GetAtt": [
          "VoteProcessorFunction",
          "Arn"
        ]
      },
      "Export": {
        "Name": {
          "Fn::Sub": "${AWS::StackName}-vote-processor-arn"
        }
      }
    }
  }
}