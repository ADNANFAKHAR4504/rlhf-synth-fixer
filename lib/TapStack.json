{
  "AWSTemplateFormatVersion": "2010-09-09",
  "Description": "Comprehensive serverless RESTful API for CRUD operations with DynamoDB, VPC, and API Gateway",
  "Parameters": {
    "EnvironmentSuffix": {
      "Type": "String",
      "Default": "dev",
      "Description": "Environment suffix for resource naming and tagging"
    }
  },
  "Mappings": {
    "EnvironmentConfig": {
      "default": {
        "LambdaMemorySize": 256,
        "LambdaTimeout": 30
      },
      "prod": {
        "LambdaMemorySize": 512,
        "LambdaTimeout": 60
      }
    }
  },
  "Conditions": {
    "IsProdEnvironment": {
      "Fn::Equals": [
        {
          "Ref": "EnvironmentSuffix"
        },
        "prod"
      ]
    }
  },
  "Resources": {
    "MyVPC": {
      "Type": "AWS::EC2::VPC",
      "Properties": {
        "CidrBlock": "10.0.0.0/16",
        "EnableDnsHostnames": true,
        "EnableDnsSupport": true,
        "Tags": [
          {
            "Key": "Name",
            "Value": {
              "Fn::Sub": "${EnvironmentSuffix}-serverless-api-vpc"
            }
          },
          {
            "Key": "Environment",
            "Value": {
              "Ref": "EnvironmentSuffix"
            }
          },
          {
            "Key": "Project",
            "Value": "ServerlessAPI"
          }
        ]
      }
    },
    "MyInternetGateway": {
      "Type": "AWS::EC2::InternetGateway",
      "Properties": {
        "Tags": [
          {
            "Key": "Name",
            "Value": {
              "Fn::Sub": "${EnvironmentSuffix}-serverless-api-igw"
            }
          },
          {
            "Key": "Environment",
            "Value": {
              "Ref": "EnvironmentSuffix"
            }
          },
          {
            "Key": "Project",
            "Value": "ServerlessAPI"
          }
        ]
      }
    },
    "AttachGateway": {
      "Type": "AWS::EC2::VPCGatewayAttachment",
      "Properties": {
        "VpcId": {
          "Ref": "MyVPC"
        },
        "InternetGatewayId": {
          "Ref": "MyInternetGateway"
        }
      }
    },
    "PublicSubnet": {
      "Type": "AWS::EC2::Subnet",
      "Properties": {
        "VpcId": {
          "Ref": "MyVPC"
        },
        "CidrBlock": "10.0.1.0/24",
        "AvailabilityZone": {
          "Fn::Select": [
            0,
            {
              "Fn::GetAZs": ""
            }
          ]
        },
        "MapPublicIpOnLaunch": true,
        "Tags": [
          {
            "Key": "Name",
            "Value": {
              "Fn::Sub": "${EnvironmentSuffix}-public-subnet-1a"
            }
          },
          {
            "Key": "Environment",
            "Value": {
              "Ref": "EnvironmentSuffix"
            }
          },
          {
            "Key": "Project",
            "Value": "ServerlessAPI"
          },
          {
            "Key": "Type",
            "Value": "Public"
          }
        ]
      }
    },
    "PrivateSubnet": {
      "Type": "AWS::EC2::Subnet",
      "Properties": {
        "VpcId": {
          "Ref": "MyVPC"
        },
        "CidrBlock": "10.0.2.0/24",
        "AvailabilityZone": {
          "Fn::Select": [
            1,
            {
              "Fn::GetAZs": ""
            }
          ]
        },
        "Tags": [
          {
            "Key": "Name",
            "Value": {
              "Fn::Sub": "${EnvironmentSuffix}-private-subnet-1b"
            }
          },
          {
            "Key": "Environment",
            "Value": {
              "Ref": "EnvironmentSuffix"
            }
          },
          {
            "Key": "Project",
            "Value": "ServerlessAPI"
          },
          {
            "Key": "Type",
            "Value": "Private"
          }
        ]
      }
    },
    "NATGatewayEIP": {
      "Type": "AWS::EC2::EIP",
      "DependsOn": "AttachGateway",
      "Properties": {
        "Domain": "vpc",
        "Tags": [
          {
            "Key": "Name",
            "Value": {
              "Fn::Sub": "${EnvironmentSuffix}-nat-gateway-eip"
            }
          },
          {
            "Key": "Environment",
            "Value": {
              "Ref": "EnvironmentSuffix"
            }
          },
          {
            "Key": "Project",
            "Value": "ServerlessAPI"
          }
        ]
      }
    },
    "NATGateway": {
      "Type": "AWS::EC2::NatGateway",
      "Properties": {
        "AllocationId": {
          "Fn::GetAtt": [
            "NATGatewayEIP",
            "AllocationId"
          ]
        },
        "SubnetId": {
          "Ref": "PublicSubnet"
        },
        "Tags": [
          {
            "Key": "Name",
            "Value": {
              "Fn::Sub": "${EnvironmentSuffix}-nat-gateway"
            }
          },
          {
            "Key": "Environment",
            "Value": {
              "Ref": "EnvironmentSuffix"
            }
          },
          {
            "Key": "Project",
            "Value": "ServerlessAPI"
          }
        ]
      }
    },
    "PublicRouteTable": {
      "Type": "AWS::EC2::RouteTable",
      "Properties": {
        "VpcId": {
          "Ref": "MyVPC"
        },
        "Tags": [
          {
            "Key": "Name",
            "Value": {
              "Fn::Sub": "${EnvironmentSuffix}-public-route-table"
            }
          },
          {
            "Key": "Environment",
            "Value": {
              "Ref": "EnvironmentSuffix"
            }
          },
          {
            "Key": "Project",
            "Value": "ServerlessAPI"
          }
        ]
      }
    },
    "PrivateRouteTable": {
      "Type": "AWS::EC2::RouteTable",
      "Properties": {
        "VpcId": {
          "Ref": "MyVPC"
        },
        "Tags": [
          {
            "Key": "Name",
            "Value": {
              "Fn::Sub": "${EnvironmentSuffix}-private-route-table"
            }
          },
          {
            "Key": "Environment",
            "Value": {
              "Ref": "EnvironmentSuffix"
            }
          },
          {
            "Key": "Project",
            "Value": "ServerlessAPI"
          }
        ]
      }
    },
    "PublicRoute": {
      "Type": "AWS::EC2::Route",
      "DependsOn": "AttachGateway",
      "Properties": {
        "RouteTableId": {
          "Ref": "PublicRouteTable"
        },
        "DestinationCidrBlock": "0.0.0.0/0",
        "GatewayId": {
          "Ref": "MyInternetGateway"
        }
      }
    },
    "PrivateRoute": {
      "Type": "AWS::EC2::Route",
      "Properties": {
        "RouteTableId": {
          "Ref": "PrivateRouteTable"
        },
        "DestinationCidrBlock": "0.0.0.0/0",
        "NatGatewayId": {
          "Ref": "NATGateway"
        }
      }
    },
    "PublicSubnetRouteTableAssociation": {
      "Type": "AWS::EC2::SubnetRouteTableAssociation",
      "Properties": {
        "SubnetId": {
          "Ref": "PublicSubnet"
        },
        "RouteTableId": {
          "Ref": "PublicRouteTable"
        }
      }
    },
    "PrivateSubnetRouteTableAssociation": {
      "Type": "AWS::EC2::SubnetRouteTableAssociation",
      "Properties": {
        "SubnetId": {
          "Ref": "PrivateSubnet"
        },
        "RouteTableId": {
          "Ref": "PrivateRouteTable"
        }
      }
    },
    "LambdaSecurityGroup": {
      "Type": "AWS::EC2::SecurityGroup",
      "Properties": {
        "GroupDescription": "Security group for Lambda functions with least privilege access",
        "VpcId": {
          "Ref": "MyVPC"
        },
        "SecurityGroupEgress": [
          {
            "IpProtocol": "tcp",
            "FromPort": 443,
            "ToPort": 443,
            "CidrIp": "0.0.0.0/0",
            "Description": "HTTPS outbound for AWS API calls"
          },
          {
            "IpProtocol": "tcp",
            "FromPort": 80,
            "ToPort": 80,
            "CidrIp": "0.0.0.0/0",
            "Description": "HTTP outbound for package downloads"
          }
        ],
        "Tags": [
          {
            "Key": "Name",
            "Value": {
              "Fn::Sub": "${EnvironmentSuffix}-lambda-security-group"
            }
          },
          {
            "Key": "Environment",
            "Value": {
              "Ref": "EnvironmentSuffix"
            }
          },
          {
            "Key": "Project",
            "Value": "ServerlessAPI"
          }
        ]
      }
    },
    "ItemsTable": {
      "Type": "AWS::DynamoDB::Table",
      "Properties": {
        "TableName": {
          "Fn::Sub": "${EnvironmentSuffix}-items-table"
        },
        "AttributeDefinitions": [
          {
            "AttributeName": "id",
            "AttributeType": "S"
          }
        ],
        "KeySchema": [
          {
            "AttributeName": "id",
            "KeyType": "HASH"
          }
        ],
        "BillingMode": "PAY_PER_REQUEST",
        "PointInTimeRecoverySpecification": {
          "PointInTimeRecoveryEnabled": true
        },
        "Tags": [
          {
            "Key": "Name",
            "Value": {
              "Fn::Sub": "${EnvironmentSuffix}-items-table"
            }
          },
          {
            "Key": "Environment",
            "Value": {
              "Ref": "EnvironmentSuffix"
            }
          },
          {
            "Key": "Project",
            "Value": "ServerlessAPI"
          },
          {
            "Key": "Purpose",
            "Value": "Data storage for RESTful API entities"
          }
        ]
      }
    },
    "CreateItemRole": {
      "Type": "AWS::IAM::Role",
      "Properties": {
        "AssumeRolePolicyDocument": {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Effect": "Allow",
              "Principal": {
                "Service": "lambda.amazonaws.com"
              },
              "Action": "sts:AssumeRole"
            }
          ]
        },
        "ManagedPolicyArns": [
          "arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole"
        ],
        "Policies": [
          {
            "PolicyName": "DynamoDBCreatePolicy",
            "PolicyDocument": {
              "Version": "2012-10-17",
              "Statement": [
                {
                  "Effect": "Allow",
                  "Action": [
                    "dynamodb:PutItem"
                  ],
                  "Resource": {
                    "Fn::GetAtt": [
                      "ItemsTable",
                      "Arn"
                    ]
                  }
                }
              ]
            }
          }
        ],
        "Tags": [
          {
            "Key": "Environment",
            "Value": {
              "Ref": "EnvironmentSuffix"
            }
          },
          {
            "Key": "Project",
            "Value": "ServerlessAPI"
          },
          {
            "Key": "Function",
            "Value": "CreateItem"
          }
        ]
      }
    },
    "GetItemRole": {
      "Type": "AWS::IAM::Role",
      "Properties": {
        "AssumeRolePolicyDocument": {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Effect": "Allow",
              "Principal": {
                "Service": "lambda.amazonaws.com"
              },
              "Action": "sts:AssumeRole"
            }
          ]
        },
        "ManagedPolicyArns": [
          "arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole"
        ],
        "Policies": [
          {
            "PolicyName": "DynamoDBGetPolicy",
            "PolicyDocument": {
              "Version": "2012-10-17",
              "Statement": [
                {
                  "Effect": "Allow",
                  "Action": [
                    "dynamodb:GetItem"
                  ],
                  "Resource": {
                    "Fn::GetAtt": [
                      "ItemsTable",
                      "Arn"
                    ]
                  }
                }
              ]
            }
          }
        ],
        "Tags": [
          {
            "Key": "Environment",
            "Value": {
              "Ref": "EnvironmentSuffix"
            }
          },
          {
            "Key": "Project",
            "Value": "ServerlessAPI"
          },
          {
            "Key": "Function",
            "Value": "GetItem"
          }
        ]
      }
    },
    "UpdateItemRole": {
      "Type": "AWS::IAM::Role",
      "Properties": {
        "RoleName": {
          "Fn::Sub": "${EnvironmentSuffix}-update-item-role"
        },
        "AssumeRolePolicyDocument": {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Effect": "Allow",
              "Principal": {
                "Service": "lambda.amazonaws.com"
              },
              "Action": "sts:AssumeRole"
            }
          ]
        },
        "ManagedPolicyArns": [
          "arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole"
        ],
        "Policies": [
          {
            "PolicyName": "DynamoDBUpdatePolicy",
            "PolicyDocument": {
              "Version": "2012-10-17",
              "Statement": [
                {
                  "Effect": "Allow",
                  "Action": [
                    "dynamodb:UpdateItem",
                    "dynamodb:GetItem"
                  ],
                  "Resource": {
                    "Fn::GetAtt": [
                      "ItemsTable",
                      "Arn"
                    ]
                  }
                }
              ]
            }
          }
        ],
        "Tags": [
          {
            "Key": "Environment",
            "Value": {
              "Ref": "EnvironmentSuffix"
            }
          },
          {
            "Key": "Project",
            "Value": "ServerlessAPI"
          },
          {
            "Key": "Function",
            "Value": "UpdateItem"
          }
        ]
      }
    },
    "DeleteItemRole": {
      "Type": "AWS::IAM::Role",
      "Properties": {
        "RoleName": {
          "Fn::Sub": "${EnvironmentSuffix}-delete-item-role"
        },
        "AssumeRolePolicyDocument": {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Effect": "Allow",
              "Principal": {
                "Service": "lambda.amazonaws.com"
              },
              "Action": "sts:AssumeRole"
            }
          ]
        },
        "ManagedPolicyArns": [
          "arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole"
        ],
        "Policies": [
          {
            "PolicyName": "DynamoDBDeletePolicy",
            "PolicyDocument": {
              "Version": "2012-10-17",
              "Statement": [
                {
                  "Effect": "Allow",
                  "Action": [
                    "dynamodb:DeleteItem"
                  ],
                  "Resource": {
                    "Fn::GetAtt": [
                      "ItemsTable",
                      "Arn"
                    ]
                  }
                }
              ]
            }
          }
        ],
        "Tags": [
          {
            "Key": "Environment",
            "Value": {
              "Ref": "EnvironmentSuffix"
            }
          },
          {
            "Key": "Project",
            "Value": "ServerlessAPI"
          },
          {
            "Key": "Function",
            "Value": "DeleteItem"
          }
        ]
      }
    },
    "CreateItemFunction": {
      "Type": "AWS::Lambda::Function",
      "Properties": {
        "FunctionName": {
          "Fn::Sub": "${EnvironmentSuffix}-create-item"
        },
        "Runtime": "python3.11",
        "Handler": "index.lambda_handler",
        "Role": {
          "Fn::GetAtt": [
            "CreateItemRole",
            "Arn"
          ]
        },
        "MemorySize": {
          "Fn::If": [
            "IsProdEnvironment",
            {
              "Fn::FindInMap": [
                "EnvironmentConfig",
                "prod",
                "LambdaMemorySize"
              ]
            },
            {
              "Fn::FindInMap": [
                "EnvironmentConfig",
                "default",
                "LambdaMemorySize"
              ]
            }
          ]
        },
        "Timeout": {
          "Fn::If": [
            "IsProdEnvironment",
            {
              "Fn::FindInMap": [
                "EnvironmentConfig",
                "prod",
                "LambdaTimeout"
              ]
            },
            {
              "Fn::FindInMap": [
                "EnvironmentConfig",
                "default",
                "LambdaTimeout"
              ]
            }
          ]
        },
        "VpcConfig": {
          "SecurityGroupIds": [
            {
              "Ref": "LambdaSecurityGroup"
            }
          ],
          "SubnetIds": [
            {
              "Ref": "PrivateSubnet"
            }
          ]
        },
        "Environment": {
          "Variables": {
            "TABLE_NAME": {
              "Ref": "ItemsTable"
            },
            "LOG_LEVEL": "INFO"
          }
        },
        "Code": {
          "ZipFile": "import json\nimport boto3\nimport os\nimport logging\nfrom botocore.exceptions import ClientError\nfrom decimal import Decimal\n\n# Configure logging\nlogger = logging.getLogger()\nlogger.setLevel(os.environ.get('LOG_LEVEL', 'INFO'))\n\ndynamodb = boto3.resource('dynamodb')\ntable = dynamodb.Table(os.environ['TABLE_NAME'])\n\ndef decimal_default(obj):\n    if isinstance(obj, Decimal):\n        return float(obj)\n    raise TypeError\n\ndef lambda_handler(event, context):\n    logger.info(f\"Received event: {json.dumps(event)}\")\n    \n    try:\n        # Parse request body\n        if not event.get('body'):\n            return {\n                'statusCode': 400,\n                'headers': {\n                    'Access-Control-Allow-Origin': '*',\n                    'Access-Control-Allow-Methods': 'POST, OPTIONS',\n                    'Access-Control-Allow-Headers': 'Content-Type, X-Amz-Date, Authorization, X-Api-Key, X-Amz-Security-Token',\n                    'Content-Type': 'application/json'\n                },\n                'body': json.dumps({'error': 'Request body is required'})\n            }\n        \n        body = json.loads(event['body'])\n        logger.info(f\"Parsed body: {body}\")\n        \n        # Validate required fields\n        if 'id' not in body:\n            return {\n                'statusCode': 400,\n                'headers': {\n                    'Access-Control-Allow-Origin': '*',\n                    'Access-Control-Allow-Methods': 'POST, OPTIONS',\n                    'Access-Control-Allow-Headers': 'Content-Type, X-Amz-Date, Authorization, X-Api-Key, X-Amz-Security-Token',\n                    'Content-Type': 'application/json'\n                },\n                'body': json.dumps({'error': 'Missing required field: id'})\n            }\n        \n        # Check if item already exists\n        try:\n            existing_item = table.get_item(Key={'id': body['id']})\n            if 'Item' in existing_item:\n                return {\n                    'statusCode': 409,\n                    'headers': {\n                        'Access-Control-Allow-Origin': '*',\n                        'Access-Control-Allow-Methods': 'POST, OPTIONS',\n                        'Access-Control-Allow-Headers': 'Content-Type, X-Amz-Date, Authorization, X-Api-Key, X-Amz-Security-Token',\n                        'Content-Type': 'application/json'\n                    },\n                    'body': json.dumps({'error': 'Item with this id already exists'})\n                }\n        except ClientError as e:\n            logger.error(f\"Error checking existing item: {str(e)}\")\n        \n        # Create item in DynamoDB\n        response = table.put_item(Item=body)\n        logger.info(f\"Item created successfully: {body['id']}\")\n        \n        return {\n            'statusCode': 201,\n            'headers': {\n                'Access-Control-Allow-Origin': '*',\n                'Access-Control-Allow-Methods': 'POST, OPTIONS',\n                'Access-Control-Allow-Headers': 'Content-Type, X-Amz-Date, Authorization, X-Api-Key, X-Amz-Security-Token',\n                'Content-Type': 'application/json'\n            },\n            'body': json.dumps({\n                'message': 'Item created successfully', \n                'item': body\n            }, default=decimal_default)\n        }\n    \n    except json.JSONDecodeError:\n        logger.error(\"Invalid JSON in request body\")\n        return {\n            'statusCode': 400,\n            'headers': {\n                'Access-Control-Allow-Origin': '*',\n                'Access-Control-Allow-Methods': 'POST, OPTIONS',\n                'Access-Control-Allow-Headers': 'Content-Type, X-Amz-Date, Authorization, X-Api-Key, X-Amz-Security-Token',\n                'Content-Type': 'application/json'\n            },\n            'body': json.dumps({'error': 'Invalid JSON format in request body'})\n        }\n    except ClientError as e:\n        logger.error(f\"DynamoDB error: {str(e)}\")\n        return {\n            'statusCode': 500,\n            'headers': {\n                'Access-Control-Allow-Origin': '*',\n                'Access-Control-Allow-Methods': 'POST, OPTIONS',\n                'Access-Control-Allow-Headers': 'Content-Type, X-Amz-Date, Authorization, X-Api-Key, X-Amz-Security-Token',\n                'Content-Type': 'application/json'\n            },\n            'body': json.dumps({'error': 'Database error occurred'})\n        }\n    except Exception as e:\n        logger.error(f\"Unexpected error: {str(e)}\")\n        return {\n            'statusCode': 500,\n            'headers': {\n                'Access-Control-Allow-Origin': '*',\n                'Access-Control-Allow-Methods': 'POST, OPTIONS',\n                'Access-Control-Allow-Headers': 'Content-Type, X-Amz-Date, Authorization, X-Api-Key, X-Amz-Security-Token',\n                'Content-Type': 'application/json'\n            },\n            'body': json.dumps({'error': 'Internal server error'})\n        }\n"
        },
        "Tags": [
          {
            "Key": "Environment",
            "Value": {
              "Ref": "EnvironmentSuffix"
            }
          },
          {
            "Key": "Project",
            "Value": "ServerlessAPI"
          },
          {
            "Key": "Function",
            "Value": "CreateItem"
          }
        ]
      }
    },
    "GetItemFunction": {
      "Type": "AWS::Lambda::Function",
      "Properties": {
        "FunctionName": {
          "Fn::Sub": "${EnvironmentSuffix}-get-item"
        },
        "Runtime": "python3.11",
        "Handler": "index.lambda_handler",
        "Role": {
          "Fn::GetAtt": [
            "GetItemRole",
            "Arn"
          ]
        },
        "MemorySize": {
          "Fn::If": [
            "IsProdEnvironment",
            {
              "Fn::FindInMap": [
                "EnvironmentConfig",
                "prod",
                "LambdaMemorySize"
              ]
            },
            {
              "Fn::FindInMap": [
                "EnvironmentConfig",
                "default",
                "LambdaMemorySize"
              ]
            }
          ]
        },
        "Timeout": {
          "Fn::If": [
            "IsProdEnvironment",
            {
              "Fn::FindInMap": [
                "EnvironmentConfig",
                "prod",
                "LambdaTimeout"
              ]
            },
            {
              "Fn::FindInMap": [
                "EnvironmentConfig",
                "default",
                "LambdaTimeout"
              ]
            }
          ]
        },
        "VpcConfig": {
          "SecurityGroupIds": [
            {
              "Ref": "LambdaSecurityGroup"
            }
          ],
          "SubnetIds": [
            {
              "Ref": "PrivateSubnet"
            }
          ]
        },
        "Environment": {
          "Variables": {
            "TABLE_NAME": {
              "Ref": "ItemsTable"
            },
            "LOG_LEVEL": "INFO"
          }
        },
        "Code": {
          "ZipFile": "import json\nimport boto3\nimport os\nimport logging\nfrom botocore.exceptions import ClientError\nfrom decimal import Decimal\n\n# Configure logging\nlogger = logging.getLogger()\nlogger.setLevel(os.environ.get('LOG_LEVEL', 'INFO'))\n\ndynamodb = boto3.resource('dynamodb')\ntable = dynamodb.Table(os.environ['TABLE_NAME'])\n\ndef decimal_default(obj):\n    if isinstance(obj, Decimal):\n        return float(obj)\n    raise TypeError\n\ndef lambda_handler(event, context):\n    logger.info(f\"Received event: {json.dumps(event)}\")\n    \n    try:\n        # Get item ID from path parameters\n        if not event.get('pathParameters') or not event['pathParameters'].get('id'):\n            return {\n                'statusCode': 400,\n                'headers': {\n                    'Access-Control-Allow-Origin': '*',\n                    'Access-Control-Allow-Methods': 'GET, OPTIONS',\n                    'Access-Control-Allow-Headers': 'Content-Type, X-Amz-Date, Authorization, X-Api-Key, X-Amz-Security-Token',\n                    'Content-Type': 'application/json'\n                },\n                'body': json.dumps({'error': 'Missing required path parameter: id'})\n            }\n        \n        item_id = event['pathParameters']['id']\n        logger.info(f\"Getting item with id: {item_id}\")\n        \n        # Get item from DynamoDB\n        response = table.get_item(Key={'id': item_id})\n        \n        if 'Item' not in response:\n            logger.info(f\"Item not found: {item_id}\")\n            return {\n                'statusCode': 404,\n                'headers': {\n                    'Access-Control-Allow-Origin': '*',\n                    'Access-Control-Allow-Methods': 'GET, OPTIONS',\n                    'Access-Control-Allow-Headers': 'Content-Type, X-Amz-Date, Authorization, X-Api-Key, X-Amz-Security-Token',\n                    'Content-Type': 'application/json'\n                },\n                'body': json.dumps({'error': 'Item not found'})\n            }\n        \n        logger.info(f\"Item retrieved successfully: {item_id}\")\n        return {\n            'statusCode': 200,\n            'headers': {\n                'Access-Control-Allow-Origin': '*',\n                'Access-Control-Allow-Methods': 'GET, OPTIONS',\n                'Access-Control-Allow-Headers': 'Content-Type, X-Amz-Date, Authorization, X-Api-Key, X-Amz-Security-Token',\n                'Content-Type': 'application/json'\n            },\n            'body': json.dumps(response['Item'], default=decimal_default)\n        }\n    \n    except ClientError as e:\n        logger.error(f\"DynamoDB error: {str(e)}\")\n        return {\n            'statusCode': 500,\n            'headers': {\n                'Access-Control-Allow-Origin': '*',\n                'Access-Control-Allow-Methods': 'GET, OPTIONS',\n                'Access-Control-Allow-Headers': 'Content-Type, X-Amz-Date, Authorization, X-Api-Key, X-Amz-Security-Token',\n                'Content-Type': 'application/json'\n            },\n            'body': json.dumps({'error': 'Database error occurred'})\n        }\n    except Exception as e:\n        logger.error(f\"Unexpected error: {str(e)}\")\n        return {\n            'statusCode': 500,\n            'headers': {\n                'Access-Control-Allow-Origin': '*',\n                'Access-Control-Allow-Methods': 'GET, OPTIONS',\n                'Access-Control-Allow-Headers': 'Content-Type, X-Amz-Date, Authorization, X-Api-Key, X-Amz-Security-Token',\n                'Content-Type': 'application/json'\n            },\n            'body': json.dumps({'error': 'Internal server error'})\n        }\n"
        },
        "Tags": [
          {
            "Key": "Environment",
            "Value": {
              "Ref": "EnvironmentSuffix"
            }
          },
          {
            "Key": "Project",
            "Value": "ServerlessAPI"
          },
          {
            "Key": "Function",
            "Value": "GetItem"
          }
        ]
      }
    },
    "UpdateItemFunction": {
      "Type": "AWS::Lambda::Function",
      "Properties": {
        "FunctionName": {
          "Fn::Sub": "${EnvironmentSuffix}-update-item"
        },
        "Runtime": "python3.11",
        "Handler": "index.lambda_handler",
        "Role": {
          "Fn::GetAtt": [
            "UpdateItemRole",
            "Arn"
          ]
        },
        "MemorySize": {
          "Fn::If": [
            "IsProdEnvironment",
            {
              "Fn::FindInMap": [
                "EnvironmentConfig",
                "prod",
                "LambdaMemorySize"
              ]
            },
            {
              "Fn::FindInMap": [
                "EnvironmentConfig",
                "default",
                "LambdaMemorySize"
              ]
            }
          ]
        },
        "Timeout": {
          "Fn::If": [
            "IsProdEnvironment",
            {
              "Fn::FindInMap": [
                "EnvironmentConfig",
                "prod",
                "LambdaTimeout"
              ]
            },
            {
              "Fn::FindInMap": [
                "EnvironmentConfig",
                "default",
                "LambdaTimeout"
              ]
            }
          ]
        },
        "VpcConfig": {
          "SecurityGroupIds": [
            {
              "Ref": "LambdaSecurityGroup"
            }
          ],
          "SubnetIds": [
            {
              "Ref": "PrivateSubnet"
            }
          ]
        },
        "Environment": {
          "Variables": {
            "TABLE_NAME": {
              "Ref": "ItemsTable"
            },
            "LOG_LEVEL": "INFO"
          }
        },
        "Code": {
          "ZipFile": "import json\nimport boto3\nimport os\nimport logging\nfrom botocore.exceptions import ClientError\nfrom decimal import Decimal\n\n# Configure logging\nlogger = logging.getLogger()\nlogger.setLevel(os.environ.get('LOG_LEVEL', 'INFO'))\n\ndynamodb = boto3.resource('dynamodb')\ntable = dynamodb.Table(os.environ['TABLE_NAME'])\n\ndef decimal_default(obj):\n    if isinstance(obj, Decimal):\n        return float(obj)\n    raise TypeError\n\ndef lambda_handler(event, context):\n    logger.info(f\"Received event: {json.dumps(event)}\")\n    \n    try:\n        # Get item ID from path parameters\n        if not event.get('pathParameters') or not event['pathParameters'].get('id'):\n            return {\n                'statusCode': 400,\n                'headers': {\n                    'Access-Control-Allow-Origin': '*',\n                    'Access-Control-Allow-Methods': 'PUT, OPTIONS',\n                    'Access-Control-Allow-Headers': 'Content-Type, X-Amz-Date, Authorization, X-Api-Key, X-Amz-Security-Token',\n                    'Content-Type': 'application/json'\n                },\n                'body': json.dumps({'error': 'Missing required path parameter: id'})\n            }\n        \n        item_id = event['pathParameters']['id']\n        \n        # Parse request body\n        if not event.get('body'):\n            return {\n                'statusCode': 400,\n                'headers': {\n                    'Access-Control-Allow-Origin': '*',\n                    'Access-Control-Allow-Methods': 'PUT, OPTIONS',\n                    'Access-Control-Allow-Headers': 'Content-Type, X-Amz-Date, Authorization, X-Api-Key, X-Amz-Security-Token',\n                    'Content-Type': 'application/json'\n                },\n                'body': json.dumps({'error': 'Request body is required'})\n            }\n        \n        body = json.loads(event['body'])\n        logger.info(f\"Updating item {item_id} with data: {body}\")\n        \n        # Check if item exists first\n        try:\n            existing_item = table.get_item(Key={'id': item_id})\n            if 'Item' not in existing_item:\n                return {\n                    'statusCode': 404,\n                    'headers': {\n                        'Access-Control-Allow-Origin': '*',\n                        'Access-Control-Allow-Methods': 'PUT, OPTIONS',\n                        'Access-Control-Allow-Headers': 'Content-Type, X-Amz-Date, Authorization, X-Api-Key, X-Amz-Security-Token',\n                        'Content-Type': 'application/json'\n                    },\n                    'body': json.dumps({'error': 'Item not found'})\n                }\n        except ClientError as e:\n            logger.error(f\"Error checking existing item: {str(e)}\")\n        \n        # Build update expression\n        update_expression = \"SET \"\n        expression_attribute_values = {}\n        expression_attribute_names = {}\n        \n        for key, value in body.items():\n            if key != 'id':  # Don't update the primary key\n                update_expression += f\"#{key} = :{key}, \"\n                expression_attribute_names[f\"#{key}\"] = key\n                expression_attribute_values[f\":{key}\"] = value\n        \n        # Remove trailing comma and space\n        update_expression = update_expression.rstrip(', ')\n        \n        if not expression_attribute_values:\n            return {\n                'statusCode': 400,\n                'headers': {\n                    'Access-Control-Allow-Origin': '*',\n                    'Access-Control-Allow-Methods': 'PUT, OPTIONS',\n                    'Access-Control-Allow-Headers': 'Content-Type, X-Amz-Date, Authorization, X-Api-Key, X-Amz-Security-Token',\n                    'Content-Type': 'application/json'\n                },\n                'body': json.dumps({'error': 'No valid fields to update'})\n            }\n        \n        # Update item in DynamoDB\n        response = table.update_item(\n            Key={'id': item_id},\n            UpdateExpression=update_expression,\n            ExpressionAttributeNames=expression_attribute_names,\n            ExpressionAttributeValues=expression_attribute_values,\n            ReturnValues='ALL_NEW'\n        )\n        \n        logger.info(f\"Item updated successfully: {item_id}\")\n        return {\n            'statusCode': 200,\n            'headers': {\n                'Access-Control-Allow-Origin': '*',\n                'Access-Control-Allow-Methods': 'PUT, OPTIONS',\n                'Access-Control-Allow-Headers': 'Content-Type, X-Amz-Date, Authorization, X-Api-Key, X-Amz-Security-Token',\n                'Content-Type': 'application/json'\n            },\n            'body': json.dumps({\n                'message': 'Item updated successfully', \n                'item': response['Attributes']\n            }, default=decimal_default)\n        }\n    \n    except json.JSONDecodeError:\n        logger.error(\"Invalid JSON in request body\")\n        return {\n            'statusCode': 400,\n            'headers': {\n                'Access-Control-Allow-Origin': '*',\n                'Access-Control-Allow-Methods': 'PUT, OPTIONS',\n                'Access-Control-Allow-Headers': 'Content-Type, X-Amz-Date, Authorization, X-Api-Key, X-Amz-Security-Token',\n                'Content-Type': 'application/json'\n            },\n            'body': json.dumps({'error': 'Invalid JSON format in request body'})\n        }\n    except ClientError as e:\n        logger.error(f\"DynamoDB error: {str(e)}\")\n        return {\n            'statusCode': 500,\n            'headers': {\n                'Access-Control-Allow-Origin': '*',\n                'Access-Control-Allow-Methods': 'PUT, OPTIONS',\n                'Access-Control-Allow-Headers': 'Content-Type, X-Amz-Date, Authorization, X-Api-Key, X-Amz-Security-Token',\n                'Content-Type': 'application/json'\n            },\n            'body': json.dumps({'error': 'Database error occurred'})\n        }\n    except Exception as e:\n        logger.error(f\"Unexpected error: {str(e)}\")\n        return {\n            'statusCode': 500,\n            'headers': {\n                'Access-Control-Allow-Origin': '*',\n                'Access-Control-Allow-Methods': 'PUT, OPTIONS',\n                'Access-Control-Allow-Headers': 'Content-Type, X-Amz-Date, Authorization, X-Api-Key, X-Amz-Security-Token',\n                'Content-Type': 'application/json'\n            },\n            'body': json.dumps({'error': 'Internal server error'})\n        }\n"
        },
        "Tags": [
          {
            "Key": "Environment",
            "Value": {
              "Ref": "EnvironmentSuffix"
            }
          },
          {
            "Key": "Project",
            "Value": "ServerlessAPI"
          },
          {
            "Key": "Function",
            "Value": "UpdateItem"
          }
        ]
      }
    },
    "DeleteItemFunction": {
      "Type": "AWS::Lambda::Function",
      "Properties": {
        "FunctionName": {
          "Fn::Sub": "${EnvironmentSuffix}-delete-item"
        },
        "Runtime": "python3.11",
        "Handler": "index.lambda_handler",
        "Role": {
          "Fn::GetAtt": [
            "DeleteItemRole",
            "Arn"
          ]
        },
        "MemorySize": {
          "Fn::If": [
            "IsProdEnvironment",
            {
              "Fn::FindInMap": [
                "EnvironmentConfig",
                "prod",
                "LambdaMemorySize"
              ]
            },
            {
              "Fn::FindInMap": [
                "EnvironmentConfig",
                "default",
                "LambdaMemorySize"
              ]
            }
          ]
        },
        "Timeout": {
          "Fn::If": [
            "IsProdEnvironment",
            {
              "Fn::FindInMap": [
                "EnvironmentConfig",
                "prod",
                "LambdaTimeout"
              ]
            },
            {
              "Fn::FindInMap": [
                "EnvironmentConfig",
                "default",
                "LambdaTimeout"
              ]
            }
          ]
        },
        "VpcConfig": {
          "SecurityGroupIds": [
            {
              "Ref": "LambdaSecurityGroup"
            }
          ],
          "SubnetIds": [
            {
              "Ref": "PrivateSubnet"
            }
          ]
        },
        "Environment": {
          "Variables": {
            "TABLE_NAME": {
              "Ref": "ItemsTable"
            },
            "LOG_LEVEL": "INFO"
          }
        },
        "Code": {
          "ZipFile": "import json\nimport boto3\nimport os\nimport logging\nfrom botocore.exceptions import ClientError\nfrom decimal import Decimal\n\n# Configure logging\nlogger = logging.getLogger()\nlogger.setLevel(os.environ.get('LOG_LEVEL', 'INFO'))\n\ndynamodb = boto3.resource('dynamodb')\ntable = dynamodb.Table(os.environ['TABLE_NAME'])\n\ndef decimal_default(obj):\n    if isinstance(obj, Decimal):\n        return float(obj)\n    raise TypeError\n\ndef lambda_handler(event, context):\n    logger.info(f\"Received event: {json.dumps(event)}\")\n    \n    try:\n        # Get item ID from path parameters\n        if not event.get('pathParameters') or not event['pathParameters'].get('id'):\n            return {\n                'statusCode': 400,\n                'headers': {\n                    'Access-Control-Allow-Origin': '*',\n                    'Access-Control-Allow-Methods': 'DELETE, OPTIONS',\n                    'Access-Control-Allow-Headers': 'Content-Type, X-Amz-Date, Authorization, X-Api-Key, X-Amz-Security-Token',\n                    'Content-Type': 'application/json'\n                },\n                'body': json.dumps({'error': 'Missing required path parameter: id'})\n            }\n        \n        item_id = event['pathParameters']['id']\n        logger.info(f\"Deleting item with id: {item_id}\")\n        \n        # Delete item from DynamoDB\n        response = table.delete_item(\n            Key={'id': item_id},\n            ReturnValues='ALL_OLD'\n        )\n        \n        if 'Attributes' not in response:\n            logger.info(f\"Item not found: {item_id}\")\n            return {\n                'statusCode': 404,\n                'headers': {\n                    'Access-Control-Allow-Origin': '*',\n                    'Access-Control-Allow-Methods': 'DELETE, OPTIONS',\n                    'Access-Control-Allow-Headers': 'Content-Type, X-Amz-Date, Authorization, X-Api-Key, X-Amz-Security-Token',\n                    'Content-Type': 'application/json'\n                },\n                'body': json.dumps({'error': 'Item not found'})\n            }\n        \n        logger.info(f\"Item deleted successfully: {item_id}\")\n        return {\n            'statusCode': 200,\n            'headers': {\n                'Access-Control-Allow-Origin': '*',\n                'Access-Control-Allow-Methods': 'DELETE, OPTIONS',\n                'Access-Control-Allow-Headers': 'Content-Type, X-Amz-Date, Authorization, X-Api-Key, X-Amz-Security-Token',\n                'Content-Type': 'application/json'\n            },\n            'body': json.dumps({\n                'message': 'Item deleted successfully',\n                'deletedItem': response['Attributes']\n            }, default=decimal_default)\n        }\n    \n    except ClientError as e:\n        logger.error(f\"DynamoDB error: {str(e)}\")\n        return {\n            'statusCode': 500,\n            'headers': {\n                'Access-Control-Allow-Origin': '*',\n                'Access-Control-Allow-Methods': 'DELETE, OPTIONS',\n                'Access-Control-Allow-Headers': 'Content-Type, X-Amz-Date, Authorization, X-Api-Key, X-Amz-Security-Token',\n                'Content-Type': 'application/json'\n            },\n            'body': json.dumps({'error': 'Database error occurred'})\n        }\n    except Exception as e:\n        logger.error(f\"Unexpected error: {str(e)}\")\n        return {\n            'statusCode': 500,\n            'headers': {\n                'Access-Control-Allow-Origin': '*',\n                'Access-Control-Allow-Methods': 'DELETE, OPTIONS',\n                'Access-Control-Allow-Headers': 'Content-Type, X-Amz-Date, Authorization, X-Api-Key, X-Amz-Security-Token',\n                'Content-Type': 'application/json'\n            },\n            'body': json.dumps({'error': 'Internal server error'})\n        }\n"
        },
        "Tags": [
          {
            "Key": "Environment",
            "Value": {
              "Ref": "EnvironmentSuffix"
            }
          },
          {
            "Key": "Project",
            "Value": "ServerlessAPI"
          },
          {
            "Key": "Function",
            "Value": "DeleteItem"
          }
        ]
      }
    },
    "ItemsRestApi": {
      "Type": "AWS::ApiGateway::RestApi",
      "Properties": {
        "Name": {
          "Fn::Sub": "${EnvironmentSuffix}-items-api"
        },
        "Description": "Serverless RESTful API for managing data entities with full CRUD operations",
        "EndpointConfiguration": {
          "Types": [
            "REGIONAL"
          ]
        },
        "Tags": [
          {
            "Key": "Environment",
            "Value": {
              "Ref": "EnvironmentSuffix"
            }
          },
          {
            "Key": "Project",
            "Value": "ServerlessAPI"
          }
        ]
      }
    },
    "ItemsResource": {
      "Type": "AWS::ApiGateway::Resource",
      "Properties": {
        "RestApiId": {
          "Ref": "ItemsRestApi"
        },
        "ParentId": {
          "Fn::GetAtt": [
            "ItemsRestApi",
            "RootResourceId"
          ]
        },
        "PathPart": "items"
      }
    },
    "ItemResource": {
      "Type": "AWS::ApiGateway::Resource",
      "Properties": {
        "RestApiId": {
          "Ref": "ItemsRestApi"
        },
        "ParentId": {
          "Ref": "ItemsResource"
        },
        "PathPart": "{id}"
      }
    },
    "CreateItemMethod": {
      "Type": "AWS::ApiGateway::Method",
      "Properties": {
        "RestApiId": {
          "Ref": "ItemsRestApi"
        },
        "ResourceId": {
          "Ref": "ItemsResource"
        },
        "HttpMethod": "POST",
        "AuthorizationType": "NONE",
        "Integration": {
          "Type": "AWS_PROXY",
          "IntegrationHttpMethod": "POST",
          "Uri": {
            "Fn::Sub": "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${CreateItemFunction.Arn}/invocations"
          }
        },
        "MethodResponses": [
          {
            "StatusCode": 201
          },
          {
            "StatusCode": 400
          },
          {
            "StatusCode": 409
          },
          {
            "StatusCode": 500
          }
        ]
      }
    },
    "GetItemMethod": {
      "Type": "AWS::ApiGateway::Method",
      "Properties": {
        "RestApiId": {
          "Ref": "ItemsRestApi"
        },
        "ResourceId": {
          "Ref": "ItemResource"
        },
        "HttpMethod": "GET",
        "AuthorizationType": "NONE",
        "Integration": {
          "Type": "AWS_PROXY",
          "IntegrationHttpMethod": "POST",
          "Uri": {
            "Fn::Sub": "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${GetItemFunction.Arn}/invocations"
          }
        },
        "MethodResponses": [
          {
            "StatusCode": 200
          },
          {
            "StatusCode": 404
          },
          {
            "StatusCode": 500
          }
        ]
      }
    },
    "UpdateItemMethod": {
      "Type": "AWS::ApiGateway::Method",
      "Properties": {
        "RestApiId": {
          "Ref": "ItemsRestApi"
        },
        "ResourceId": {
          "Ref": "ItemResource"
        },
        "HttpMethod": "PUT",
        "AuthorizationType": "NONE",
        "Integration": {
          "Type": "AWS_PROXY",
          "IntegrationHttpMethod": "POST",
          "Uri": {
            "Fn::Sub": "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${UpdateItemFunction.Arn}/invocations"
          }
        },
        "MethodResponses": [
          {
            "StatusCode": 200
          },
          {
            "StatusCode": 400
          },
          {
            "StatusCode": 404
          },
          {
            "StatusCode": 500
          }
        ]
      }
    },
    "DeleteItemMethod": {
      "Type": "AWS::ApiGateway::Method",
      "Properties": {
        "RestApiId": {
          "Ref": "ItemsRestApi"
        },
        "ResourceId": {
          "Ref": "ItemResource"
        },
        "HttpMethod": "DELETE",
        "AuthorizationType": "NONE",
        "Integration": {
          "Type": "AWS_PROXY",
          "IntegrationHttpMethod": "POST",
          "Uri": {
            "Fn::Sub": "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${DeleteItemFunction.Arn}/invocations"
          }
        },
        "MethodResponses": [
          {
            "StatusCode": 200
          },
          {
            "StatusCode": 404
          },
          {
            "StatusCode": 500
          }
        ]
      }
    },
    "ItemsOptionsMethod": {
      "Type": "AWS::ApiGateway::Method",
      "Properties": {
        "RestApiId": {
          "Ref": "ItemsRestApi"
        },
        "ResourceId": {
          "Ref": "ItemsResource"
        },
        "HttpMethod": "OPTIONS",
        "AuthorizationType": "NONE",
        "Integration": {
          "Type": "MOCK",
          "IntegrationResponses": [
            {
              "StatusCode": 200,
              "ResponseParameters": {
                "method.response.header.Access-Control-Allow-Headers": "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'",
                "method.response.header.Access-Control-Allow-Methods": "'POST,OPTIONS'",
                "method.response.header.Access-Control-Allow-Origin": "'*'"
              }
            }
          ],
          "RequestTemplates": {
            "application/json": "{\"statusCode\": 200}"
          }
        },
        "MethodResponses": [
          {
            "StatusCode": 200,
            "ResponseParameters": {
              "method.response.header.Access-Control-Allow-Headers": true,
              "method.response.header.Access-Control-Allow-Methods": true,
              "method.response.header.Access-Control-Allow-Origin": true
            }
          }
        ]
      }
    },
    "ItemOptionsMethod": {
      "Type": "AWS::ApiGateway::Method",
      "Properties": {
        "RestApiId": {
          "Ref": "ItemsRestApi"
        },
        "ResourceId": {
          "Ref": "ItemResource"
        },
        "HttpMethod": "OPTIONS",
        "AuthorizationType": "NONE",
        "Integration": {
          "Type": "MOCK",
          "IntegrationResponses": [
            {
              "StatusCode": 200,
              "ResponseParameters": {
                "method.response.header.Access-Control-Allow-Headers": "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'",
                "method.response.header.Access-Control-Allow-Methods": "'GET,PUT,DELETE,OPTIONS'",
                "method.response.header.Access-Control-Allow-Origin": "'*'"
              }
            }
          ],
          "RequestTemplates": {
            "application/json": "{\"statusCode\": 200}"
          }
        },
        "MethodResponses": [
          {
            "StatusCode": 200,
            "ResponseParameters": {
              "method.response.header.Access-Control-Allow-Headers": true,
              "method.response.header.Access-Control-Allow-Methods": true,
              "method.response.header.Access-Control-Allow-Origin": true
            }
          }
        ]
      }
    },
    "CreateItemPermission": {
      "Type": "AWS::Lambda::Permission",
      "Properties": {
        "FunctionName": {
          "Ref": "CreateItemFunction"
        },
        "Action": "lambda:InvokeFunction",
        "Principal": "apigateway.amazonaws.com",
        "SourceArn": {
          "Fn::Sub": "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ItemsRestApi}/*/*"
        }
      }
    },
    "GetItemPermission": {
      "Type": "AWS::Lambda::Permission",
      "Properties": {
        "FunctionName": {
          "Ref": "GetItemFunction"
        },
        "Action": "lambda:InvokeFunction",
        "Principal": "apigateway.amazonaws.com",
        "SourceArn": {
          "Fn::Sub": "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ItemsRestApi}/*/*"
        }
      }
    },
    "UpdateItemPermission": {
      "Type": "AWS::Lambda::Permission",
      "Properties": {
        "FunctionName": {
          "Ref": "UpdateItemFunction"
        },
        "Action": "lambda:InvokeFunction",
        "Principal": "apigateway.amazonaws.com",
        "SourceArn": {
          "Fn::Sub": "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ItemsRestApi}/*/*"
        }
      }
    },
    "DeleteItemPermission": {
      "Type": "AWS::Lambda::Permission",
      "Properties": {
        "FunctionName": {
          "Ref": "DeleteItemFunction"
        },
        "Action": "lambda:InvokeFunction",
        "Principal": "apigateway.amazonaws.com",
        "SourceArn": {
          "Fn::Sub": "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ItemsRestApi}/*/*"
        }
      }
    },
    "ApiDeployment": {
      "Type": "AWS::ApiGateway::Deployment",
      "DependsOn": [
        "CreateItemMethod",
        "GetItemMethod",
        "UpdateItemMethod",
        "DeleteItemMethod",
        "ItemsOptionsMethod",
        "ItemOptionsMethod"
      ],
      "Properties": {
        "RestApiId": {
          "Ref": "ItemsRestApi"
        },
        "StageName": {
          "Ref": "EnvironmentSuffix"
        }
      }
    }
  },
  "Outputs": {
    "ApiGatewayInvokeURL": {
      "Description": "URL for the deployed REST API",
      "Value": {
        "Fn::Sub": "https://${ItemsRestApi}.execute-api.${AWS::Region}.amazonaws.com/${EnvironmentSuffix}"
      },
      "Export": {
        "Name": {
          "Fn::Sub": "${AWS::StackName}-ApiGatewayURL"
        }
      }
    },
    "DynamoDBTableName": {
      "Description": "Name of the DynamoDB table",
      "Value": {
        "Ref": "ItemsTable"
      },
      "Export": {
        "Name": {
          "Fn::Sub": "${AWS::StackName}-DynamoDBTable"
        }
      }
    },
    "DynamoDBTableArn": {
      "Description": "ARN of the DynamoDB table",
      "Value": {
        "Fn::GetAtt": [
          "ItemsTable",
          "Arn"
        ]
      },
      "Export": {
        "Name": {
          "Fn::Sub": "${AWS::StackName}-DynamoDBTableArn"
        }
      }
    },
    "VPCId": {
      "Description": "VPC ID for the serverless infrastructure",
      "Value": {
        "Ref": "MyVPC"
      },
      "Export": {
        "Name": {
          "Fn::Sub": "${AWS::StackName}-VPC"
        }
      }
    },
    "PrivateSubnetId": {
      "Description": "Private Subnet ID where Lambda functions are deployed",
      "Value": {
        "Ref": "PrivateSubnet"
      },
      "Export": {
        "Name": {
          "Fn::Sub": "${AWS::StackName}-PrivateSubnet"
        }
      }
    },
    "PublicSubnetId": {
      "Description": "Public Subnet ID for NAT Gateway",
      "Value": {
        "Ref": "PublicSubnet"
      },
      "Export": {
        "Name": {
          "Fn::Sub": "${AWS::StackName}-PublicSubnet"
        }
      }
    },
    "LambdaSecurityGroupId": {
      "Description": "Security Group ID for Lambda functions",
      "Value": {
        "Ref": "LambdaSecurityGroup"
      },
      "Export": {
        "Name": {
          "Fn::Sub": "${AWS::StackName}-LambdaSecurityGroup"
        }
      }
    },
    "Environment": {
      "Description": "Environment name used for this deployment",
      "Value": {
        "Ref": "EnvironmentSuffix"
      },
      "Export": {
        "Name": {
          "Fn::Sub": "${AWS::StackName}-Environment"
        }
      }
    }
  }
}
