AWSTemplateFormatVersion: "2010-09-09"
Transform: AWS::Serverless-2016-10-31
Description: "TAP Stack - Task Assignment Platform SAM Template - Serverless Application"

Parameters:
  EnvironmentSuffix:
    Type: String
    Default: dev
    Description: Environment suffix for resource naming

Resources:
  # Lambda Execution Role with CloudWatch Logs permissions
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: CloudWatchLogsPolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*"

  # S3 Bucket for Lambda function assets with encryption
  LambdaAssetsBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub "tap-lambda-assets-${EnvironmentSuffix}-${AWS::AccountId}"
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      VersioningConfiguration:
        Status: Enabled
  # SAM Lambda Function
  TapFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !Sub "TapFunction-${EnvironmentSuffix}"
      Runtime: python3.8
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 30
      MemorySize: 128
      Environment:
        Variables:
          ENVIRONMENT: !Ref EnvironmentSuffix
          BUCKET_NAME: !Ref LambdaAssetsBucket
      Events:
        ApiEvent:
          Type: HttpApi
          Properties:
            Path: /{proxy+}
            Method: ANY
        RootEvent:
          Type: HttpApi
          Properties:
            Path: /
            Method: ANY
      InlineCode: |
        import json
        import os
        import logging
        import re

        # Configure logging
        logger = logging.getLogger()
        logger.setLevel(logging.INFO)

        def validate_email(email):
            """Basic email validation"""
            pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
            return re.match(pattern, str(email)) is not None

        def validate_required_fields(data, required_fields):
            """Validate that required fields are present in the data"""
            missing_fields = []
            for field in required_fields:
                if field not in data or not str(data[field]).strip():
                    missing_fields.append(field)
            return missing_fields

        def sanitize_input(data):
            """Basic input sanitization"""
            if isinstance(data, dict):
                return {k: sanitize_input(v) for k, v in data.items()}
            elif isinstance(data, list):
                return [sanitize_input(item) for item in data]
            elif isinstance(data, str):
                # Basic HTML/script tag removal
                data = re.sub(r'<[^>]*>', '', data)
                return data.strip()
            return data

        def lambda_handler(event, context):
            """
            AWS Lambda handler function for the TAP serverless application.
            Handles HTTP requests from HTTP API Gateway (v2).
            """
            
            # Log the incoming event
            logger.info(f"Received event: {json.dumps(event)}")
            
            # Extract HTTP method and path from HTTP API v2 event format
            http_method = event.get('requestContext', {}).get('http', {}).get('method', 'UNKNOWN')
            path = event.get('requestContext', {}).get('http', {}).get('path', '/')
            
            # Get environment variables
            environment = os.environ.get('ENVIRONMENT', 'dev')
            bucket_name = os.environ.get('BUCKET_NAME', 'unknown')

            # Basic routing based on HTTP method and path
            if http_method == 'GET':
                # Handle GET requests - typically for reading/retrieving resources
                if path == '/health' or path == '/':
                    response_body = {
                        'message': 'TAP Serverless Application is running!',
                        'status': 'healthy',
                        'environment': environment,
                        'bucket': bucket_name,
                        'path': path,
                        'method': http_method,
                        'timestamp': context.aws_request_id,
                        'version': '1.0.0'
                    }
                    status_code = 200
                elif path.startswith('/api/'):
                    # Handle API endpoints
                    query_params = event.get('queryStringParameters') or {}
                    path_params = event.get('pathParameters') or {}
                    
                    response_body = {
                        'message': f'GET API endpoint {path}',
                        'query_parameters': query_params,
                        'path_parameters': path_params,
                        'environment': environment,
                        'request_id': context.aws_request_id
                    }
                    status_code = 200
                else:
                    response_body = {
                        'error': f'GET endpoint {path} not found',
                        'available_endpoints': {
                            'health_check': '/health or /',
                            'api_endpoints': '/api/*'
                        },
                        'message': 'Please use one of the available endpoints'
                    }
                    status_code = 404
            elif http_method == 'POST':
                # Handle POST requests - typically for creating resources
                try:
                    request_body = json.loads(event.get('body', '{}'))
                    
                    # Basic validation for POST requests
                    if not request_body:
                        response_body = {
                            'error': 'POST request requires a request body',
                            'message': 'Please provide data to create a resource'
                        }
                        status_code = 400
                    else:
                        # Sanitize input data
                        sanitized_data = sanitize_input(request_body)
                        
                        # Example validation - you can customize this based on your needs
                        if 'email' in sanitized_data and not validate_email(sanitized_data['email']):
                            response_body = {
                                'error': 'Invalid email format',
                                'message': 'Please provide a valid email address'
                            }
                            status_code = 400
                        else:
                            response_body = {
                                'message': 'POST request processed successfully',
                                'action': 'resource_created',
                                'received_data': sanitized_data,
                                'environment': environment,
                                'request_id': context.aws_request_id
                            }
                            status_code = 201  # Created
                        
                except json.JSONDecodeError:
                    response_body = {
                        'error': 'Invalid JSON in request body',
                        'message': 'POST request body must be valid JSON'
                    }
                    status_code = 400
            elif http_method == 'PUT':
                # Handle PUT requests - typically for updating resources
                try:
                    request_body = json.loads(event.get('body', '{}'))
                    
                    # Basic validation for PUT requests
                    if not request_body:
                        response_body = {
                            'error': 'PUT request requires a request body',
                            'message': 'Please provide data to update'
                        }
                        status_code = 400
                    else:
                        # Sanitize input data
                        sanitized_data = sanitize_input(request_body)
                        
                        # Validate required fields for update operations
                        missing_fields = validate_required_fields(sanitized_data, ['id'])
                        if missing_fields:
                            response_body = {
                                'error': f'Missing required fields: {", ".join(missing_fields)}',
                                'message': 'PUT requests must include an id field to identify the resource to update',
                                'required_fields': ['id']
                            }
                            status_code = 400
                        else:
                            # Additional email validation if present
                            if 'email' in sanitized_data and not validate_email(sanitized_data['email']):
                                response_body = {
                                    'error': 'Invalid email format',
                                    'message': 'Please provide a valid email address'
                                }
                                status_code = 400
                            else:
                                response_body = {
                                    'message': 'PUT request processed successfully',
                                    'action': 'resource_updated',
                                    'resource_id': sanitized_data.get('id'),
                                    'updated_data': sanitized_data,
                                    'environment': environment,
                                    'request_id': context.aws_request_id
                                }
                                status_code = 200
                            
                except json.JSONDecodeError:
                    response_body = {
                        'error': 'Invalid JSON in request body',
                        'message': 'PUT request body must be valid JSON'
                    }
                    status_code = 400
            elif http_method == 'DELETE':
                # Handle DELETE requests - typically for removing resources
                query_params = event.get('queryStringParameters') or {}
                path_params = event.get('pathParameters') or {}
                
                # Extract resource identifier from path or query parameters
                resource_id = path_params.get('id') or query_params.get('id')
                
                if not resource_id:
                    response_body = {
                        'error': 'Missing resource identifier',
                        'message': 'DELETE requests require an id parameter in the path or query string',
                        'examples': [
                            f'{path}?id=123',
                            'Use path parameter: /resource/123'
                        ]
                    }
                    status_code = 400
                else:
                    # Validate resource ID format
                    if not str(resource_id).strip():
                        response_body = {
                            'error': 'Invalid resource identifier',
                            'message': 'Resource ID cannot be empty'
                        }
                        status_code = 400
                    else:
                        response_body = {
                            'message': 'DELETE request processed successfully',
                            'action': 'resource_deleted',
                            'resource_id': resource_id,
                            'path': path,
                            'environment': environment,
                            'request_id': context.aws_request_id
                        }
                        status_code = 200
            elif http_method == 'OPTIONS':
                # Handle OPTIONS requests - for CORS preflight
                response_body = {
                    'message': 'CORS preflight response',
                    'allowed_methods': ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
                    'allowed_headers': ['Content-Type', 'X-Amz-Date', 'Authorization', 'X-Api-Key', 'X-Amz-Security-Token'],
                    'environment': environment
                }
                status_code = 200
            else:
                # Handle unsupported HTTP methods
                response_body = {
                    'error': f'HTTP method {http_method} is not supported',
                    'path': path,
                    'supported_methods': ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
                    'message': 'Please use one of the supported HTTP methods'
                }
                status_code = 405
            
            # Prepare the response
            response = {
                'statusCode': status_code,
                'headers': {
                    'Content-Type': 'application/json',
                    'Access-Control-Allow-Origin': '*',
                    'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token',
                    'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS'
                },
                'body': json.dumps(response_body)
            }
            logger.info(f"Returning response: {json.dumps(response)}")
            return response

Outputs:
  HttpApiUrl:
    Description: "HTTP API endpoint URL"
    Value: !Sub "https://${ServerlessHttpApi}.execute-api.${AWS::Region}.amazonaws.com/"
    Export:
      Name: !Sub "TapStack-${EnvironmentSuffix}-ApiUrl"

  LambdaFunctionArn:
    Description: "Lambda Function ARN"
    Value: !GetAtt TapFunction.Arn
    Export:
      Name: !Sub "TapStack-${EnvironmentSuffix}-LambdaArn"

  S3BucketName:
    Description: "S3 Bucket for Lambda assets"
    Value: !Ref LambdaAssetsBucket
    Export:
      Name: !Sub "TapStack-${EnvironmentSuffix}-S3Bucket"

  LambdaExecutionRoleArn:
    Description: "Lambda Execution Role ARN"
    Value: !GetAtt LambdaExecutionRole.Arn
    Export:
      Name: !Sub "TapStack-${EnvironmentSuffix}-RoleArn"
