AWSTemplateFormatVersion: "2010-09-09"
Description: "Production-grade serverless payment workflow with API Gateway, Lambda, Step Functions, DynamoDB, S3, and monitoring"

Parameters:
  Environment:
    Type: String
    Default: prod
    AllowedValues:
      - dev
      - test
      - prod
    Description: Deployment environment

  NotificationEmail:
    Type: String
    Description: Email address for notifications
    Default: govardhan.y@turing.com

  TransactionRetentionDays:
    Type: Number
    Default: 90
    Description: Number of days to retain transaction audit logs before deletion (TTL)

  ApiThrottlingRateLimit:
    Type: Number
    Default: 10000
    Description: API Gateway throttling rate limit (requests per second)

  ValidatorConcurrency:
    Type: Number
    Default: 100
    Description: Reserved concurrency for the validator Lambda function

  StandardConcurrency:
    Type: Number
    Default: 50
    Description: Reserved concurrency for standard Lambda functions

  LogRetentionInDays:
    Type: Number
    Default: 30
    Description: CloudWatch Logs retention period in days

  EnvironmentSuffix:
    Type: String
    Default: ""
    Description: Unique suffix for resource naming (e.g., pr1234, synth123) for deployment isolation

Resources:
  # IAM Roles - Permissions for the services
  ValidatorLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        - !Sub arn:${AWS::Partition}:iam::aws:policy/AWSXrayWriteOnlyAccess # X-Ray Tracing Enabled
      Policies:
        - PolicyName: !Sub ${AWS::StackName}-validator-lambda-policy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:PutItem # Initial record creation
                  - dynamodb:UpdateItem # Status updates
                Resource: !GetAtt TransactionsTable.Arn
              - Effect: Allow
                Action:
                  - dynamodb:PutItem # Audit logging
                Resource: !GetAtt AuditLogsTable.Arn
              - Effect: Allow
                Action:
                  - ssm:GetParameter
                  - ssm:GetParameters # Access configuration from SSM
                Resource: !Sub arn:${AWS::Partition}:ssm:${AWS::Region}:${AWS::AccountId}:parameter/payment-workflow/${Environment}/*

  FraudDetectorLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        - !Sub arn:${AWS::Partition}:iam::aws:policy/AWSXrayWriteOnlyAccess
      Policies:
        - PolicyName: !Sub ${AWS::StackName}-fraud-detector-lambda-policy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:UpdateItem # Update fraud result
                Resource: !GetAtt TransactionsTable.Arn
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                Resource: !GetAtt AuditLogsTable.Arn
              - Effect: Allow
                Action:
                  - ssm:GetParameter
                  - ssm:GetParameters
                Resource: !Sub arn:${AWS::Partition}:ssm:${AWS::Region}:${AWS::AccountId}:parameter/payment-workflow/${Environment}/*

  SettlementLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        - !Sub arn:${AWS::Partition}:iam::aws:policy/AWSXrayWriteOnlyAccess
      Policies:
        - PolicyName: !Sub ${AWS::StackName}-settlement-lambda-policy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:UpdateItem # Final status update
                Resource: !GetAtt TransactionsTable.Arn
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                Resource: !GetAtt AuditLogsTable.Arn
              - Effect: Allow
                Action:
                  - s3:PutObject # Archive complete transaction to S3
                  - s3:PutObjectAcl # Required for S3 object ACL permissions
                Resource: !Sub ${TransactionArchivesBucket.Arn}/*
              - Effect: Allow
                Action:
                  - ssm:GetParameter
                  - ssm:GetParameters
                Resource: !Sub arn:${AWS::Partition}:ssm:${AWS::Region}:${AWS::AccountId}:parameter/payment-workflow/${Environment}/*

  NotificationLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        - !Sub arn:${AWS::Partition}:iam::aws:policy/AWSXrayWriteOnlyAccess
      Policies:
        - PolicyName: !Sub ${AWS::StackName}-notification-lambda-policy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - sns:Publish # Send notifications
                Resource:
                  - !Ref AlertsTopic
                  - !Ref FailedTransactionsTopic
              - Effect: Allow
                Action:
                  - dynamodb:PutItem
                Resource: !GetAtt AuditLogsTable.Arn
              - Effect: Allow
                Action:
                  - ssm:GetParameter
                  - ssm:GetParameters
                Resource: !Sub arn:${AWS::Partition}:ssm:${AWS::Region}:${AWS::AccountId}:parameter/payment-workflow/${Environment}/*

  # Lambda Functions - Python 3.12, 512MB
  ValidatorFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub ${AWS::StackName}-validator-${Environment}-${EnvironmentSuffix}
      Handler: index.lambda_handler
      Role: !GetAtt ValidatorLambdaRole.Arn
      Code:
        ZipFile: |
          import json
          import os
          import boto3
          import time
          from decimal import Decimal
          # X-Ray tracing is enabled via Lambda configuration and IAM policies

          dynamodb = boto3.resource('dynamodb')
          transactions_table = dynamodb.Table(os.environ['TRANSACTIONS_TABLE'])
          audit_table = dynamodb.Table(os.environ['AUDIT_LOGS_TABLE'])

          def lambda_handler(event, context):
              transaction_id = event['transaction_id']
              
              # *** IMPROVEMENT: Store the full initial transaction data ***
              # This ensures the TransactionsTable has the complete record immediately.
              transactions_table.put_item(
                  Item={
                      'transaction_id': transaction_id,
                      'merchant_id': event.get('merchant_id', 'UNKNOWN'), # Required for GSI
                      'customer_id': event.get('customer_id', 'UNKNOWN'),
                      'amount': Decimal(str(event.get('amount', 0))),
                      'payment_method': event.get('payment_method', 'UNKNOWN'),
                      'initial_request': event,
                      'status': 'VALIDATING',
                      'created_at': int(time.time()),
                      'updated_at': int(time.time())
                  }
              )
              
              # Log the validation attempt
              audit_table.put_item(
                  Item={
                      'audit_id': f"VALIDATION_{transaction_id}_{int(time.time())}",
                      'transaction_id': transaction_id,
                      'timestamp': int(time.time()),
                      'action': 'VALIDATION_ATTEMPT',
                      'details': json.dumps(event),
                      'ttl': int(time.time()) + (int(os.environ['TTL_DAYS']) * 24 * 60 * 60)
                  }
              )
              
              # Validate the transaction (simplified for demo)
              is_valid = True
              if 'amount' not in event or Decimal(str(event['amount'])) <= 0:
                  is_valid = False
              if 'payment_method' not in event:
                  is_valid = False
              
              validation_result = {
                  'transaction_id': transaction_id,
                  'is_valid': is_valid,
                  'timestamp': int(time.time()),
                  'validation_details': {
                      'validator_version': '1.1',
                      'checks_performed': ['amount', 'payment_method']
                  }
              }
              
              # Update validation result in DynamoDB
              transactions_table.update_item(
                  Key={'transaction_id': transaction_id},
                  UpdateExpression='SET validation_result = :vr, #st = :s, updated_at = :ua',
                  ExpressionAttributeNames={'#st': 'status'},
                  ExpressionAttributeValues={
                      ':vr': validation_result,
                      ':s': 'VALIDATED',
                      ':ua': int(time.time())
                  }
              )
              
              return validation_result
      Runtime: python3.12
      MemorySize: 512
      Timeout: 30
      ReservedConcurrentExecutions: !Ref ValidatorConcurrency
      Environment:
        Variables:
          TRANSACTIONS_TABLE: !Ref TransactionsTable
          AUDIT_LOGS_TABLE: !Ref AuditLogsTable
          ENVIRONMENT: !Ref Environment
          TTL_DAYS: !Ref TransactionRetentionDays
      TracingConfig:
        Mode: Active # Explicitly enable X-Ray tracing
      LoggingConfig:
        LogGroup: !Ref ValidatorLogGroup

  FraudDetectorFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub ${AWS::StackName}-fraud-detector-${Environment}-${EnvironmentSuffix}
      Handler: index.lambda_handler
      Role: !GetAtt FraudDetectorLambdaRole.Arn
      Code:
        ZipFile: |
          import json
          import os
          import boto3
          import time
          from decimal import Decimal
          # X-Ray tracing is enabled via Lambda configuration and IAM policies

          dynamodb = boto3.resource('dynamodb')
          transactions_table = dynamodb.Table(os.environ['TRANSACTIONS_TABLE'])
          audit_table = dynamodb.Table(os.environ['AUDIT_LOGS_TABLE'])

          def lambda_handler(event, context):
              transaction_id = event['transaction_id']
              
              # Log the fraud detection attempt
              audit_table.put_item(
                  Item={
                      'audit_id': f"FRAUD_DETECTION_{transaction_id}_{int(time.time())}",
                      'transaction_id': transaction_id,
                      'timestamp': int(time.time()),
                      'action': 'FRAUD_DETECTION_ATTEMPT',
                      'details': json.dumps(event),
                      'ttl': int(time.time()) + (int(os.environ['TTL_DAYS']) * 24 * 60 * 60)
                  }
              )
              
              # Run fraud detection algorithms (simplified for demo)
              is_fraudulent = False
              if 'amount' in event and Decimal(str(event['amount'])) > Decimal('10000'):
                  is_fraudulent = True
              
              fraud_result = {
                  'transaction_id': transaction_id,
                  'is_fraudulent': is_fraudulent,
                  'risk_score': Decimal('0.2') if not is_fraudulent else Decimal('0.8'),
                  'timestamp': int(time.time()),
                  'fraud_details': {
                      'detector_version': '1.0',
                      'checks_performed': ['amount_threshold']
                  }
              }
              
              # Store fraud detection result in DynamoDB
              # Handle race condition - if record doesn't exist, put_item first
              try:
                  transactions_table.update_item(
                      Key={'transaction_id': transaction_id},
                      UpdateExpression='SET fraud_result = :fr, updated_at = :ua',
                      ConditionExpression='attribute_exists(transaction_id)',
                      ExpressionAttributeValues={
                          ':fr': fraud_result,
                          ':ua': int(time.time())
                      }
                  )
              except transactions_table.meta.client.exceptions.ConditionalCheckFailedException:
                  # Record doesn't exist, create minimal record with fraud result
                  transactions_table.put_item(
                      Item={
                          'transaction_id': transaction_id,
                          'fraud_result': fraud_result,
                          'status': 'PROCESSING',
                          'created_at': int(time.time()),
                          'updated_at': int(time.time())
                      }
                  )
              except Exception as e:
                  # Fallback: use put_item to ensure the fraud result is stored
                  transactions_table.put_item(
                      Item={
                          'transaction_id': transaction_id,
                          'fraud_result': fraud_result,
                          'status': 'PROCESSING',
                          'created_at': int(time.time()),
                          'updated_at': int(time.time())
                      }
                  )
              
              return fraud_result
      Runtime: python3.12
      MemorySize: 512
      Timeout: 30
      ReservedConcurrentExecutions: !Ref StandardConcurrency
      Environment:
        Variables:
          TRANSACTIONS_TABLE: !Ref TransactionsTable
          AUDIT_LOGS_TABLE: !Ref AuditLogsTable
          ENVIRONMENT: !Ref Environment
          TTL_DAYS: !Ref TransactionRetentionDays
      TracingConfig:
        Mode: Active
      LoggingConfig:
        LogGroup: !Ref FraudDetectorLogGroup

  SettlementFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub ${AWS::StackName}-settlement-${Environment}-${EnvironmentSuffix}
      Handler: index.lambda_handler
      Role: !GetAtt SettlementLambdaRole.Arn
      Code:
        ZipFile: |
          import json
          import os
          import boto3
          import time
          # X-Ray tracing is enabled via Lambda configuration and IAM policies

          dynamodb = boto3.resource('dynamodb')
          s3 = boto3.client('s3')
          transactions_table = dynamodb.Table(os.environ['TRANSACTIONS_TABLE'])
          audit_table = dynamodb.Table(os.environ['AUDIT_LOGS_TABLE'])

          def lambda_handler(event, context):
              transaction_id = event['transaction_id']
              validation_result = event.get('validation_result', {})
              fraud_result = event.get('fraud_result', {})
              
              # Log the settlement attempt
              audit_table.put_item(
                  Item={
                      'audit_id': f"SETTLEMENT_{transaction_id}_{int(time.time())}",
                      'transaction_id': transaction_id,
                      'timestamp': int(time.time()),
                      'action': 'SETTLEMENT_ATTEMPT',
                      'details': json.dumps(event),
                      'ttl': int(time.time()) + (int(os.environ['TTL_DAYS']) * 24 * 60 * 60)
                  }
              )
              
              # Check if the transaction is valid and not fraudulent
              is_valid = validation_result.get('is_valid', False)
              is_fraudulent = fraud_result.get('is_fraudulent', True)
              
              if not is_valid or is_fraudulent:
                  settlement_status = 'REJECTED'
                  settlement_reason = 'VALIDATION_FAILED' if not is_valid else 'FRAUD_DETECTED'
              else:
                  settlement_status = 'COMPLETED'
                  settlement_reason = 'PAYMENT_PROCESSED'
              
              settlement_result = {
                  'transaction_id': transaction_id,
                  'status': settlement_status,
                  'reason': settlement_reason,
                  'timestamp': int(time.time()),
                  'settlement_details': {
                      'processor': 'DEMO',
                      'reference_id': f"REF-{int(time.time())}"
                  }
              }
              
              # Store settlement result in DynamoDB
              transactions_table.update_item(
                  Key={'transaction_id': transaction_id},
                  UpdateExpression='SET settlement_result = :sr, updated_at = :ua, #st = :s',
                  ExpressionAttributeNames={'#st': 'status'},
                  ExpressionAttributeValues={
                      ':sr': settlement_result,
                      ':ua': int(time.time()),
                      ':s': settlement_status,
                  }
              )
              
              # Archive the complete transaction to S3
              transaction_data = {
                  'transaction_id': transaction_id,
                  'validation_result': validation_result,
                  'fraud_result': fraud_result,
                  'settlement_result': settlement_result,
                  'archived_at': int(time.time())
              }
              
              s3.put_object(
                  Bucket=os.environ['ARCHIVE_BUCKET'],
                  Key=f"transactions/{transaction_id}/{int(time.time())}.json",
                  Body=json.dumps(transaction_data),
                  ContentType='application/json'
              )
              
              # Log the settlement result
              audit_table.put_item(
                  Item={
                      'audit_id': f"SETTLEMENT_RESULT_{transaction_id}_{int(time.time())}",
                      'transaction_id': transaction_id,
                      'timestamp': int(time.time()),
                      'action': 'SETTLEMENT_COMPLETE',
                      'details': json.dumps(settlement_result),
                      'ttl': int(time.time()) + (int(os.environ['TTL_DAYS']) * 24 * 60 * 60)
                  }
              )
              
              return settlement_result
      Runtime: python3.12
      MemorySize: 512
      Timeout: 30
      ReservedConcurrentExecutions: !Ref StandardConcurrency
      Environment:
        Variables:
          TRANSACTIONS_TABLE: !Ref TransactionsTable
          AUDIT_LOGS_TABLE: !Ref AuditLogsTable
          ARCHIVE_BUCKET: !Ref TransactionArchivesBucket
          ENVIRONMENT: !Ref Environment
          TTL_DAYS: !Ref TransactionRetentionDays
      TracingConfig:
        Mode: Active
      LoggingConfig:
        LogGroup: !Ref SettlementLogGroup

  NotificationFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub ${AWS::StackName}-notification-${Environment}-${EnvironmentSuffix}
      Handler: index.lambda_handler
      Role: !GetAtt NotificationLambdaRole.Arn
      Code:
        ZipFile: |
          import json
          import os
          import boto3
          import time
          # X-Ray tracing is enabled via Lambda configuration and IAM policies

          dynamodb = boto3.resource('dynamodb')
          sns = boto3.client('sns')
          audit_table = dynamodb.Table(os.environ['AUDIT_LOGS_TABLE'])

          def lambda_handler(event, context):
              transaction_id = event['transaction_id']
              settlement_result = event.get('settlement_result', {})
              
              # Log the notification attempt
              audit_table.put_item(
                  Item={
                      'audit_id': f"NOTIFICATION_{transaction_id}_{int(time.time())}",
                      'transaction_id': transaction_id,
                      'timestamp': int(time.time()),
                      'action': 'NOTIFICATION_ATTEMPT',
                      'details': json.dumps(event),
                      'ttl': int(time.time()) + (int(os.environ['TTL_DAYS']) * 24 * 60 * 60)
                  }
              )
              
              status = settlement_result.get('status', 'UNKNOWN')
              
              # Prepare notification message
              notification_message = {
                  'transaction_id': transaction_id,
                  'status': status,
                  'timestamp': int(time.time()),
                  'details': settlement_result
              }
              
              # Send notification based on status
              if status == 'COMPLETED':
                  sns.publish(
                      TopicArn=os.environ['ALERTS_TOPIC'],
                      Message=json.dumps(notification_message),
                      Subject=f"Transaction {transaction_id} Completed Successfully"
                  )
              else:
                  sns.publish(
                      TopicArn=os.environ['FAILED_TRANSACTIONS_TOPIC'],
                      Message=json.dumps(notification_message),
                      Subject=f"Transaction {transaction_id} Failed: {settlement_result.get('reason', 'UNKNOWN')}"
                  )
              
              # Log the notification result
              notification_result = {
                  'transaction_id': transaction_id,
                  'notification_sent': True,
                  'notification_type': 'SUCCESS' if status == 'COMPLETED' else 'FAILURE',
                  'timestamp': int(time.time())
              }
              
              audit_table.put_item(
                  Item={
                      'audit_id': f"NOTIFICATION_RESULT_{transaction_id}_{int(time.time())}",
                      'transaction_id': transaction_id,
                      'timestamp': int(time.time()),
                      'action': 'NOTIFICATION_COMPLETE',
                      'details': json.dumps(notification_result),
                      'ttl': int(time.time()) + (int(os.environ['TTL_DAYS']) * 24 * 60 * 60)
                  }
              )
              
              return notification_result
      Runtime: python3.12
      MemorySize: 512
      Timeout: 30
      ReservedConcurrentExecutions: !Ref StandardConcurrency
      Environment:
        Variables:
          TRANSACTIONS_TABLE: !Ref TransactionsTable
          AUDIT_LOGS_TABLE: !Ref AuditLogsTable
          ALERTS_TOPIC: !Ref AlertsTopic
          FAILED_TRANSACTIONS_TOPIC: !Ref FailedTransactionsTopic
          ENVIRONMENT: !Ref Environment
          TTL_DAYS: !Ref TransactionRetentionDays
      TracingConfig:
        Mode: Active
      LoggingConfig:
        LogGroup: !Ref NotificationLogGroup

  # Lambda Log Groups with Retention (30 days)
  ValidatorLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub /aws/lambda/${AWS::StackName}-validator-${Environment}-${EnvironmentSuffix}
      RetentionInDays: !Ref LogRetentionInDays

  FraudDetectorLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub /aws/lambda/${AWS::StackName}-fraud-detector-${Environment}-${EnvironmentSuffix}
      RetentionInDays: !Ref LogRetentionInDays

  SettlementLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub /aws/lambda/${AWS::StackName}-settlement-${Environment}-${EnvironmentSuffix}
      RetentionInDays: !Ref LogRetentionInDays

  NotificationLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub /aws/lambda/${AWS::StackName}-notification-${Environment}-${EnvironmentSuffix}
      RetentionInDays: !Ref LogRetentionInDays

  # DynamoDB Tables (On-Demand, PITR Enabled)
  TransactionsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub ${AWS::StackName}-transactions-${Environment}-${EnvironmentSuffix}
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: transaction_id
          AttributeType: S
        - AttributeName: merchant_id
          AttributeType: S
      KeySchema:
        - AttributeName: transaction_id
          KeyType: HASH
      GlobalSecondaryIndexes:
        - IndexName: MerchantIndex
          KeySchema:
            - AttributeName: merchant_id
              KeyType: HASH
          Projection:
            ProjectionType: ALL
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      SSESpecification:
        SSEEnabled: true

  AuditLogsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub ${AWS::StackName}-audit-logs-${Environment}-${EnvironmentSuffix}
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: audit_id
          AttributeType: S
        # FIX: The 'ttl' attribute was removed here (line 617) as it is only for TimeToLiveSpecification, not the KeySchema.
      KeySchema:
        - AttributeName: audit_id
          KeyType: HASH
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      SSESpecification:
        SSEEnabled: true
      TimeToLiveSpecification:
        AttributeName: ttl
        Enabled: true

  # S3 Bucket for Transaction Archives (SSE-S3, Glacier Lifecycle)
  TransactionArchivesBucket:
    Type: AWS::S3::Bucket
    Properties:
      # Note: BucketName property removed to prevent creation conflicts - CloudFormation will auto-generate unique name
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256 # SSE-S3 Encryption
      LifecycleConfiguration:
        Rules:
          - Id: GlacierTransition
            Status: Enabled
            Transitions:
              - TransitionInDays: 30
                StorageClass: GLACIER # Transition to Glacier after 30 days
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      VersioningConfiguration:
        Status: Enabled

  TransactionArchivesBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref TransactionArchivesBucket
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Deny
            Principal: "*"
            Action: "s3:*"
            Resource:
              - !Sub ${TransactionArchivesBucket.Arn}
              - !Sub ${TransactionArchivesBucket.Arn}/*
            Condition:
              Bool:
                aws:SecureTransport: false # Enforce HTTPS/SSL

  # SNS Topics and Subscriptions
  AlertsTopic:
    Type: AWS::SNS::Topic
    Properties:
      TopicName: !Sub ${AWS::StackName}-alerts-${Environment}-${EnvironmentSuffix}

  FailedTransactionsTopic:
    Type: AWS::SNS::Topic
    Properties:
      TopicName: !Sub ${AWS::StackName}-failed-transactions-${Environment}-${EnvironmentSuffix}

  AlertsSubscription:
    Type: AWS::SNS::Subscription
    Properties:
      TopicArn: !Ref AlertsTopic
      Protocol: email
      Endpoint: !Ref NotificationEmail

  FailedTransactionsSubscription:
    Type: AWS::SNS::Subscription
    Properties:
      TopicArn: !Ref FailedTransactionsTopic
      Protocol: email
      Endpoint: !Ref NotificationEmail

  # Step Functions Role and State Machine (Timeout: 60s, Retries 3x)
  StateMachineRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: states.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: !Sub ${AWS::StackName}-state-machine-policy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource:
                  - !GetAtt ValidatorFunction.Arn
                  - !GetAtt FraudDetectorFunction.Arn
                  - !GetAtt SettlementFunction.Arn
                  - !GetAtt NotificationFunction.Arn
              - Effect: Allow
                Action:
                  - xray:PutTraceSegments
                  - xray:PutTelemetryRecords
                  - xray:GetSamplingRules
                  - xray:GetSamplingTargets
                Resource: "*"
              # Enhanced logs permissions with proper resource scoping
              - Effect: Allow
                Action:
                  - logs:CreateLogDelivery
                  - logs:GetLogDelivery
                  - logs:UpdateLogDelivery
                  - logs:DeleteLogDelivery
                  - logs:ListLogDeliveries
                  - logs:PutResourcePolicy
                  - logs:DescribeResourcePolicies
                  - logs:DescribeLogGroups
                Resource: "*"
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:DescribeLogStreams
                  - logs:PutLogEvents
                  - logs:GetLogEvents
                  - logs:GetLogRecord
                  - logs:GetLogGroupFields
                  - logs:GetQueryResults
                Resource:
                  - !GetAtt StateMachineLogGroup.Arn
                  - !Sub "${StateMachineLogGroup.Arn}:*"

  PaymentWorkflow:
    Type: AWS::StepFunctions::StateMachine
    Properties:
      StateMachineName: !Sub ${AWS::StackName}-payment-workflow-${Environment}-${EnvironmentSuffix}
      RoleArn: !GetAtt StateMachineRole.Arn
      StateMachineType: STANDARD
      TracingConfiguration:
        Enabled: true
      LoggingConfiguration:
        Level: ALL
        IncludeExecutionData: true
        Destinations:
          - CloudWatchLogsLogGroup:
              LogGroupArn: !GetAtt StateMachineLogGroup.Arn
      Definition:
        Comment: "Payment processing workflow with validation, fraud detection, settlement, and notification"
        StartAt: ValidationAndFraudDetection
        States:
          ValidationAndFraudDetection:
            Type: Parallel
            Branches:
              - StartAt: ValidateTransaction
                States:
                  ValidateTransaction:
                    Type: Task
                    Resource: !GetAtt ValidatorFunction.Arn
                    Retry: # 3x Retry with exponential backoff
                      - ErrorEquals:
                          - States.ALL
                        IntervalSeconds: 1
                        MaxAttempts: 3
                        BackoffRate: 2
                    End: true
              - StartAt: DetectFraud
                States:
                  DetectFraud:
                    Type: Task
                    Resource: !GetAtt FraudDetectorFunction.Arn
                    Retry: # 3x Retry with exponential backoff
                      - ErrorEquals:
                          - States.ALL
                        IntervalSeconds: 1
                        MaxAttempts: 3
                        BackoffRate: 2
                    End: true
            Next: ProcessResults
            ResultPath: "$.validation_results"
          ProcessResults:
            Type: Pass
            Parameters:
              transaction_id.$: "$.transaction_id" # Retrieve transaction_id from root level
              validation_result.$: "$.validation_results[0]"
              fraud_result.$: "$.validation_results[1]"
            Next: SettleTransaction
          SettleTransaction:
            Type: Task
            Resource: !GetAtt SettlementFunction.Arn
            Retry:
              - ErrorEquals:
                  - States.ALL
                IntervalSeconds: 1
                MaxAttempts: 3
                BackoffRate: 2
            ResultPath: "$.settlement_result"
            Next: SendNotification
          SendNotification:
            Type: Task
            Resource: !GetAtt NotificationFunction.Arn
            Retry:
              - ErrorEquals:
                  - States.ALL
                IntervalSeconds: 1
                MaxAttempts: 3
                BackoffRate: 2
            ResultPath: "$.notification_result"
            End: true
        TimeoutSeconds: 60 # SFN Timeout

  StateMachineLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub /aws/states/${AWS::StackName}-payment-workflow-${Environment}-${EnvironmentSuffix}
      RetentionInDays: !Ref LogRetentionInDays

  # API Gateway (REST, Key Auth, 10k RPS, X-Ray)
  ApiGatewayRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: apigateway.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AmazonAPIGatewayPushToCloudWatchLogs
        - arn:aws:iam::aws:policy/AWSXrayWriteOnlyAccess
      Policies:
        - PolicyName: AllowStepFunctionsStartExecution
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - states:StartExecution
                Resource:
                  - !Ref PaymentWorkflow
                  - !Sub arn:${AWS::Partition}:states:${AWS::Region}:${AWS::AccountId}:execution:${AWS::StackName}-payment-workflow-${Environment}:*

  PaymentApi:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: !Sub ${AWS::StackName}-payment-api-${Environment}-${EnvironmentSuffix}
      EndpointConfiguration:
        Types:
          - REGIONAL
      ApiKeySourceType: HEADER

  PaymentApiAccount:
    Type: AWS::ApiGateway::Account
    Properties:
      CloudWatchRoleArn: !GetAtt ApiGatewayRole.Arn

  ApiGatewayUsagePlan:
    Type: AWS::ApiGateway::UsagePlan
    Properties:
      UsagePlanName: !Sub ${AWS::StackName}-usage-plan-${Environment}-${EnvironmentSuffix}
      ApiStages:
        - ApiId: !Ref PaymentApi
          Stage: !Ref ApiStage
      Throttle:
        RateLimit: !Ref ApiThrottlingRateLimit
        BurstLimit: !Ref ApiThrottlingRateLimit

  ApiKey:
    Type: AWS::ApiGateway::ApiKey
    Properties:
      Name: !Sub ${AWS::StackName}-api-key-${Environment}-${EnvironmentSuffix}
      Enabled: true
      Value: !Sub ${AWS::StackName}-${Environment}-${EnvironmentSuffix}-${AWS::AccountId}

  ApiKeyUsagePlanAssociation:
    Type: AWS::ApiGateway::UsagePlanKey
    Properties:
      KeyId: !Ref ApiKey
      KeyType: API_KEY
      UsagePlanId: !Ref ApiGatewayUsagePlan

  ApiStage:
    Type: AWS::ApiGateway::Stage
    Properties:
      StageName: !Ref Environment
      RestApiId: !Ref PaymentApi
      DeploymentId: !Ref ApiDeployment
      TracingEnabled: true # X-Ray Tracing
      MethodSettings:
        - ResourcePath: "/*"
          HttpMethod: "*"
          MetricsEnabled: true
          LoggingLevel: INFO
          ThrottlingBurstLimit: !Ref ApiThrottlingRateLimit
          ThrottlingRateLimit: !Ref ApiThrottlingRateLimit

  ApiDeployment:
    Type: AWS::ApiGateway::Deployment
    DependsOn:
      - TransactionPostMethod
    Properties:
      RestApiId: !Ref PaymentApi

  TransactionsResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref PaymentApi
      ParentId: !GetAtt PaymentApi.RootResourceId
      PathPart: transactions

  TransactionRequestValidator:
    Type: AWS::ApiGateway::RequestValidator
    Properties:
      Name: !Sub ${AWS::StackName}-transaction-validator-${EnvironmentSuffix}
      RestApiId: !Ref PaymentApi
      ValidateRequestBody: true
      ValidateRequestParameters: true

  TransactionModel:
    Type: AWS::ApiGateway::Model
    Properties:
      RestApiId: !Ref PaymentApi
      ContentType: application/json
      Name: TransactionModel
      Schema:
        $schema: http://json-schema.org/draft-04/schema#
        title: TransactionModel
        type: object
        required:
          - transaction_id
          - merchant_id
          - amount
          - payment_method
          - customer_id
        properties:
          transaction_id:
            type: string
          merchant_id:
            type: string
          amount:
            type: number
            minimum: 0.01
          payment_method:
            type: string
          customer_id:
            type: string
          description:
            type: string
          metadata:
            type: object

  TransactionPostMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      HttpMethod: POST
      AuthorizationType: NONE
      ApiKeyRequired: true # API Key Authentication
      RestApiId: !Ref PaymentApi
      ResourceId: !Ref TransactionsResource
      RequestValidatorId: !Ref TransactionRequestValidator
      RequestModels:
        application/json: !Ref TransactionModel
      Integration:
        Type: AWS
        IntegrationHttpMethod: POST
        Uri: !Sub arn:${AWS::Partition}:apigateway:${AWS::Region}:states:action/StartExecution
        Credentials: !GetAtt ApiGatewayRole.Arn
        PassthroughBehavior: NEVER
        RequestTemplates:
          application/json:
            Fn::Sub: |
              {
                "stateMachineArn": "${PaymentWorkflow}",
                "input": "$util.escapeJavaScript($input.json('$'))"
              }
        IntegrationResponses:
          - StatusCode: 202
            ResponseTemplates:
              application/json: |
                {
                  "executionArn": "$input.path('$.executionArn')",
                  "startDate": "$input.path('$.startDate')",
                  "status": "PROCESSING"
                }
      MethodResponses:
        - StatusCode: 202
          ResponseModels:
            application/json: "Empty"

  # CloudWatch Alarms - UPDATED for Error Rate
  LambdaErrorRateMetricFilter:
    Type: AWS::Logs::MetricFilter
    Properties:
      LogGroupName: !Ref ValidatorLogGroup
      FilterPattern: '{ $.errorMessage = "*" }'
      MetricTransformations:
        - MetricName: ErrorCount
          MetricNamespace: !Sub ${AWS::StackName}/LambdaMetrics
          MetricValue: 1
          DefaultValue: 0

  LambdaInvocationMetricFilter:
    Type: AWS::Logs::MetricFilter
    Properties:
      LogGroupName: !Ref ValidatorLogGroup
      FilterPattern: "" # Match all logs to count all invocations
      MetricTransformations:
        - MetricName: InvocationCount
          MetricNamespace: !Sub ${AWS::StackName}/LambdaMetrics
          MetricValue: 1
          DefaultValue: 0

  LambdaErrorRateAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !Sub ${AWS::StackName}-lambda-error-rate-${Environment}
      AlarmDescription: Alarm if Validator Lambda error rate exceeds 1% over 5 minutes
      ComparisonOperator: GreaterThanThreshold
      EvaluationPeriods: 1
      Threshold: 0.01 # 1% error rate
      TreatMissingData: notBreaching
      AlarmActions:
        - !Ref AlertsTopic
      OKActions:
        - !Ref AlertsTopic
      Metrics:
        # FIX: Correctly structured MetricStat property for CloudFormation
        - Id: e
          MetricStat:
            Metric:
              MetricName: ErrorCount
              Namespace: !Sub ${AWS::StackName}/LambdaMetrics
            Period: 300
            Stat: Sum
          ReturnData: false
        # FIX: Correctly structured MetricStat property for CloudFormation
        - Id: i
          MetricStat:
            Metric:
              MetricName: InvocationCount
              Namespace: !Sub ${AWS::StackName}/LambdaMetrics
            Period: 300
            Stat: Sum
          ReturnData: false
        - Id: e_rate
          Expression: "e / i" # Calculate Error Rate
          Label: "Error Rate"
          ReturnData: true

  API4xxErrorsAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmName: !Sub ${AWS::StackName}-api-4xx-errors-${Environment}
      AlarmDescription: Alarm if API 4XX errors exceed 5%
      ComparisonOperator: GreaterThanThreshold
      EvaluationPeriods: 1
      MetricName: 4XXError
      Namespace: AWS/ApiGateway
      Period: 60
      Statistic: Average
      Threshold: 0.05
      TreatMissingData: notBreaching
      AlarmActions:
        - !Ref AlertsTopic
      OKActions:
        - !Ref AlertsTopic
      Dimensions:
        - Name: ApiName
          Value: !Ref PaymentApi

Outputs:
  ApiEndpoint:
    Description: The URL of the API Gateway endpoint
    Value: !Sub https://${PaymentApi}.execute-api.${AWS::Region}.amazonaws.com/${Environment}/transactions
    Export:
      Name: !Sub ${AWS::StackName}-ApiEndpoint-${Environment}

  StateMachineArn:
    Description: ARN of the payment workflow state machine
    Value: !Ref PaymentWorkflow
    Export:
      Name: !Sub ${AWS::StackName}-StateMachineArn-${Environment}

  TransactionsTableArn:
    Description: ARN of the transactions DynamoDB table
    Value: !GetAtt TransactionsTable.Arn
    Export:
      Name: !Sub ${AWS::StackName}-TransactionsTableArn-${Environment}

  AuditLogsTableArn:
    Description: ARN of the audit logs DynamoDB table
    Value: !GetAtt AuditLogsTable.Arn
    Export:
      Name: !Sub ${AWS::StackName}-AuditLogsTableArn-${Environment}

  TransactionArchivesBucketArn:
    Description: ARN of the transaction archives S3 bucket
    Value: !GetAtt TransactionArchivesBucket.Arn
    Export:
      Name: !Sub ${AWS::StackName}-TransactionArchivesBucketArn-${Environment}

  ApiKey:
    Description: API Key for accessing the payment API
    Value: !Sub ${AWS::StackName}-${Environment}-${EnvironmentSuffix}-${AWS::AccountId}
    Export:
      Name: !Sub ${AWS::StackName}-ApiKey-${Environment}
