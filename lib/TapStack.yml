AWSTemplateFormatVersion: '2010-09-09'
Description: 'Multi-region deployable CloudFormation template with comprehensive AWS services including AWS Config for compliance monitoring'

Parameters:
  # Environment parameters
  EnvironmentSuffix:
    Description: The deployment environment suffix
    Type: String
    Default: dev
  
  # VPC parameters
  VpcCidr:
    Description: CIDR block for the VPC
    Type: String
    Default: 10.0.0.0/16
  
  # Cross-region replication parameters
  CrossRegionReplicationBuckets:
    Description: Comma-separated list of ARNs of S3 buckets in other regions for cross-region replication
    Type: CommaDelimitedList
    Default: ""
  
  # RDS parameters
  DBInstanceClass:
    Description: RDS instance class
    Type: String
    Default: db.t3.small
  
  DBName:
    Description: Database name
    Type: String
    Default: mydb
    MinLength: 1
    MaxLength: 64
    AllowedPattern: '[a-zA-Z][a-zA-Z0-9]*'
  
  DBBackupRetentionPeriod:
    Description: The number of days for which automated backups are retained
    Type: Number
    Default: 7
    MinValue: 7
  
  # WAF parameters
  WAFScope:
    Description: The scope of the WAF (REGIONAL or CLOUDFRONT)
    Type: String
    Default: REGIONAL
    AllowedValues:
      - REGIONAL
      - CLOUDFRONT

  # Random suffix for unique resource naming
  RandomSuffix:
    Description: 5-digit random number suffix for unique resource naming
    Type: String
    Default: '12345'
    AllowedPattern: '[0-9]{5}'
    ConstraintDescription: Must be exactly 5 digits

  # Route 53 Domain Name
  DomainName:
    Description: Domain name for Route 53 hosted zone (can be any name like test.local, myapp.dev, etc. - doesn't need to be a real domain)
    Type: String
    Default: 'myapp.test'
    ConstraintDescription: Can be any valid domain format (e.g., example.com, test.local, myapp.dev) - ownership not required

  # Create Route 53 resources flag
  CreateRoute53Records:
    Description: Whether to create Route 53 hosted zone and DNS records
    Type: String
    Default: 'true'
    AllowedValues:
      - 'true'
      - 'false'


Conditions:
  # Condition to check if cross-region replication buckets are provided
  HasReplicationBuckets: !Not [!Equals [!Join ['', !Ref CrossRegionReplicationBuckets], '']]
  
  # Condition to check if Route 53 records should be created
  CreateRoute53: !And
    - !Equals [!Ref CreateRoute53Records, 'true']
    - !Not [!Equals [!Ref DomainName, '']]

Mappings:
  # API Gateway Regional Hosted Zone IDs (only for supported regions)
  # These are AWS-managed hosted zone IDs for Regional API Gateway endpoints
  RegionMap:
    us-east-1:
      APIGatewayHostedZoneId: Z1UJRXOUMOOFQ8  # US East (N. Virginia)
    us-east-2:
      APIGatewayHostedZoneId: ZOJJZC49E0EPZ   # US East (Ohio)
    us-west-1:
      APIGatewayHostedZoneId: Z2MUQ32089INYE  # US West (N. California)
    us-west-2:
      APIGatewayHostedZoneId: Z2OJLYMUO9EFXC  # US West (Oregon)
    af-south-1:
      APIGatewayHostedZoneId: Z2DHW2332DAMTN  # Africa (Cape Town)
    ap-east-1:
      APIGatewayHostedZoneId: Z3FD1VL90ND7K5  # Asia Pacific (Hong Kong)
    ap-east-2:
      APIGatewayHostedZoneId: Z02909591O7FG9Q56HWB1  # Asia Pacific (Taipei)
    ap-northeast-1:
      APIGatewayHostedZoneId: Z1YSHQZHG15GKL  # Asia Pacific (Tokyo)
    ap-northeast-2:
      APIGatewayHostedZoneId: Z20JF4UZKIW1U8  # Asia Pacific (Seoul)
    ap-northeast-3:
      APIGatewayHostedZoneId: Z22ILHG95FLSZ2  # Asia Pacific (Osaka)
    ap-south-1:
      APIGatewayHostedZoneId: Z3VO1THU9YC4UR  # Asia Pacific (Mumbai)
    ap-south-2:
      APIGatewayHostedZoneId: Z0853509Q1135NJ66RUH  # Asia Pacific (Hyderabad)
    ap-southeast-1:
      APIGatewayHostedZoneId: ZL327KTPIQFUL   # Asia Pacific (Singapore)
    ap-southeast-2:
      APIGatewayHostedZoneId: Z2RPCDW04V8134  # Asia Pacific (Sydney)
    ap-southeast-3:
      APIGatewayHostedZoneId: Z10132843TYUYSLUG4HA3  # Asia Pacific (Jakarta)
    ap-southeast-4:
      APIGatewayHostedZoneId: Z092189423Y7RJK61311D  # Asia Pacific (Melbourne)
    ap-southeast-5:
      APIGatewayHostedZoneId: Z0314042F0KBUTZ3X5HF  # Asia Pacific (Malaysia)
    ap-southeast-7:
      APIGatewayHostedZoneId: Z048508712PZLK5NKG8R0  # Asia Pacific (Thailand)
    ca-central-1:
      APIGatewayHostedZoneId: Z19DQILCV0OWEC  # Canada (Central)
    ca-west-1:
      APIGatewayHostedZoneId: Z04745493436AWVTG1OQY  # Canada West (Calgary)
    eu-central-1:
      APIGatewayHostedZoneId: Z1U9ULNL0V5AJ3  # Europe (Frankfurt)
    eu-central-2:
      APIGatewayHostedZoneId: Z09222482MK253X48U76H  # Europe (Zurich)
    eu-north-1:
      APIGatewayHostedZoneId: Z3UWIKFBOOGXPP  # Europe (Stockholm)
    eu-south-1:
      APIGatewayHostedZoneId: Z3BT4WSQ9TDYZV  # Europe (Milan)
    eu-south-2:
      APIGatewayHostedZoneId: Z02499852UI5HEQ5JVWX3  # Europe (Spain)
    eu-west-1:
      APIGatewayHostedZoneId: ZLY8HYME6SFDD   # Europe (Ireland)
    eu-west-2:
      APIGatewayHostedZoneId: ZJ5UAJN8Y3Z2Q   # Europe (London)
    eu-west-3:
      APIGatewayHostedZoneId: Z3KY65QIEKYHQQ  # Europe (Paris)
    il-central-1:
      APIGatewayHostedZoneId: Z07264553HBI44N5X2CKP  # Israel (Tel Aviv)
    me-central-1:
      APIGatewayHostedZoneId: Z08780021BKYYY8U0YHTV  # Middle East (UAE)
    me-south-1:
      APIGatewayHostedZoneId: Z20ZBPC0SS8806  # Middle East (Bahrain)
    mx-central-1:
      APIGatewayHostedZoneId: Z00020171WIGL5M88SHRM  # Mexico (Central)
    sa-east-1:
      APIGatewayHostedZoneId: ZCMLWB8V5SYIT   # South America (SÃ£o Paulo)
    us-gov-east-1:
      APIGatewayHostedZoneId: Z3SE9ATJYCRCZJ  # AWS GovCloud (US-East)
    us-gov-west-1:
      APIGatewayHostedZoneId: Z1K6XKP9SAGWDV  # AWS GovCloud (US-West)
    
  # Note: These IDs are for Regional API Gateway endpoints only
  # For Edge-Optimized APIs, use Z2FDTNDATAQYW2 (global CloudFront hosted zone)

Resources:
  # S3 Bucket for AWS Config data storage
  ConfigS3Bucket:
    Type: AWS::S3::Bucket
    DeletionPolicy: Delete
    Properties:
      BucketName: !Sub '${AWS::AccountId}-${AWS::Region}-${EnvironmentSuffix}-config-bucket-${RandomSuffix}'
      VersioningConfiguration:
        Status: Suspended
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      LifecycleConfiguration:
        Rules:
          - Id: DeleteEverythingRule
            Status: Enabled
            ExpirationInDays: 1
            NoncurrentVersionExpirationInDays: 1
            AbortIncompleteMultipartUpload:
              DaysAfterInitiation: 1
      Tags:
        - Key: Name
          Value: !Sub '${EnvironmentSuffix}-config-bucket'
        - Key: Purpose
          Value: AWS Config Data Storage
        - Key: iac-rlhf-amazon
          Value: 'true'

  # S3 Bucket Policy for AWS Config
  ConfigS3BucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref ConfigS3Bucket
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: AWSConfigBucketPermissionsCheck
            Effect: Allow
            Principal:
              Service: config.amazonaws.com
            Action: 's3:GetBucketAcl'
            Resource: !GetAtt ConfigS3Bucket.Arn
            Condition:
              StringEquals:
                'AWS:SourceAccount': !Ref 'AWS::AccountId'
          - Sid: AWSConfigBucketExistenceCheck
            Effect: Allow
            Principal:
              Service: config.amazonaws.com
            Action: 's3:ListBucket'
            Resource: !GetAtt ConfigS3Bucket.Arn
            Condition:
              StringEquals:
                'AWS:SourceAccount': !Ref 'AWS::AccountId'
          - Sid: AWSConfigBucketDelivery
            Effect: Allow
            Principal:
              Service: config.amazonaws.com
            Action: 's3:PutObject'
            Resource: !Sub '${ConfigS3Bucket.Arn}/AWSLogs/${AWS::AccountId}/*'
            Condition:
              StringEquals:
                's3:x-amz-acl': 'bucket-owner-full-control'
                'AWS:SourceAccount': !Ref 'AWS::AccountId'
          - Sid: AWSConfigBucketDeliveryCheck
            Effect: Allow
            Principal:
              Service: config.amazonaws.com
            Action: 's3:GetBucketAcl'
            Resource: !GetAtt ConfigS3Bucket.Arn
            Condition:
              StringEquals:
                'AWS:SourceAccount': !Ref 'AWS::AccountId'

  # IAM Role for AWS Config
  ConfigServiceRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${EnvironmentSuffix}-config-service-role-${RandomSuffix}'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: config.amazonaws.com
            Action: 'sts:AssumeRole'
            Condition:
              StringEquals:
                'AWS:SourceAccount': !Ref 'AWS::AccountId'
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AWS_ConfigRole'
      Path: '/service-role/'
      Tags:
        - Key: Name
          Value: !Sub '${EnvironmentSuffix}-config-service-role'
        - Key: Purpose
          Value: AWS Config Service Role
        - Key: iac-rlhf-amazon
          Value: 'true'

  # AWS Config Configuration Recorder
  ConfigRecorder:
    Type: AWS::Config::ConfigurationRecorder
    DependsOn:
      - ConfigS3BucketPolicy
    Properties:
      Name: !Sub '${EnvironmentSuffix}-config-recorder'
      RoleARN: !GetAtt ConfigServiceRole.Arn
      RecordingGroup:
        AllSupported: true
        IncludeGlobalResourceTypes: true
        RecordingStrategy:
          UseOnly: ALL_SUPPORTED_RESOURCE_TYPES

  # AWS Config Delivery Channel
  ConfigDeliveryChannel:
    Type: AWS::Config::DeliveryChannel
    DependsOn:
      - ConfigS3BucketPolicy
    Properties:
      Name: !Sub '${EnvironmentSuffix}-config-delivery-channel'
      S3BucketName: !Ref ConfigS3Bucket
      ConfigSnapshotDeliveryProperties:
        DeliveryFrequency: TwentyFour_Hours

  # Config Rule: S3 Bucket Public Read Prohibited
  S3BucketPublicReadRule:
    Type: AWS::Config::ConfigRule
    DependsOn:
      - ConfigRecorder
    Properties:
      ConfigRuleName: !Sub '${EnvironmentSuffix}-s3-bucket-public-read-prohibited'
      Description: 'Checks that S3 buckets do not allow public read access'
      Scope:
        ComplianceResourceTypes:
          - 'AWS::S3::Bucket'
      Source:
        Owner: AWS
        SourceIdentifier: S3_BUCKET_PUBLIC_READ_PROHIBITED

  # Config Rule: S3 Bucket Public Write Prohibited
  S3BucketPublicWriteRule:
    Type: AWS::Config::ConfigRule
    DependsOn:
      - ConfigRecorder
    Properties:
      ConfigRuleName: !Sub '${EnvironmentSuffix}-s3-bucket-public-write-prohibited'
      Description: 'Checks that S3 buckets do not allow public write access'
      Scope:
        ComplianceResourceTypes:
          - 'AWS::S3::Bucket'
      Source:
        Owner: AWS
        SourceIdentifier: S3_BUCKET_PUBLIC_WRITE_PROHIBITED

  # S3 Bucket with versioning and encryption
  S3Bucket:
    Type: AWS::S3::Bucket
    DeletionPolicy: Delete
    Properties:
      BucketName: !Sub '${AWS::AccountId}-${AWS::Region}-${EnvironmentSuffix}-data-bucket-${RandomSuffix}'
      VersioningConfiguration:
        Status: Suspended
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: aws:kms
              KMSMasterKeyID: !GetAtt S3BucketKMSKey.Arn
      LifecycleConfiguration:
        Rules:
          - Id: DeleteEverythingRule
            Status: Enabled
            ExpirationInDays: 1
            NoncurrentVersionExpirationInDays: 1
            AbortIncompleteMultipartUpload:
              DaysAfterInitiation: 1
      ReplicationConfiguration: !If
        - HasReplicationBuckets
        - Role: !GetAtt S3ReplicationRole.Arn
          Rules:
            - Status: Enabled
              Destination:
                Bucket: !Select [0, !Ref CrossRegionReplicationBuckets]
                EncryptionConfiguration:
                  ReplicaKmsKeyID: 'arn:aws:kms:*:*:alias/aws/s3'
        - !Ref 'AWS::NoValue'
      Tags:
        - Key: Name
          Value: !Sub '${EnvironmentSuffix}-data-bucket'
        - Key: iac-rlhf-amazon
          Value: 'true'

  # KMS Key for S3 Bucket Encryption
  S3BucketKMSKey:
    Type: AWS::KMS::Key
    Properties:
      Description: KMS key for S3 bucket encryption
      EnableKeyRotation: true
      KeyPolicy:
        Version: '2012-10-17'
        Id: key-policy
        Statement:
          - Sid: Enable IAM User Permissions
            Effect: Allow
            Principal:
              AWS: !Sub 'arn:aws:iam::${AWS::AccountId}:root'
            Action: 'kms:*'
            Resource: '*'
          - Sid: Allow S3 to use the key
            Effect: Allow
            Principal:
              Service: s3.amazonaws.com
            Action:
              - kms:Encrypt
              - kms:Decrypt
              - kms:ReEncrypt*
              - kms:GenerateDataKey*
              - kms:DescribeKey
            Resource: '*'
      Tags:
        - Key: Name
          Value: !Sub '${EnvironmentSuffix}-s3-kms-key'
        - Key: iac-rlhf-amazon
          Value: 'true'

  # IAM Replication Role
  S3ReplicationRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: s3.amazonaws.com
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/AmazonS3FullAccess'
      Policies:
        - PolicyName: S3ReplicationPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 's3:GetReplicationConfiguration'
                  - 's3:ListBucket'
                Resource: !Sub 'arn:aws:s3:::${AWS::AccountId}-${AWS::Region}-${EnvironmentSuffix}-data-bucket-${RandomSuffix}'
              - Effect: Allow
                Action:
                  - 's3:GetObjectVersionForReplication'
                  - 's3:GetObjectVersionAcl'
                  - 's3:GetObjectVersionTagging'
                Resource: !Sub 'arn:aws:s3:::${AWS::AccountId}-${AWS::Region}-${EnvironmentSuffix}-data-bucket-${RandomSuffix}/*'
              - !If
                - HasReplicationBuckets
                - Effect: Allow
                  Action:
                    - 's3:ReplicateObject'
                    - 's3:ReplicateDelete'
                    - 's3:ReplicateTags'
                  Resource: !Join ['', ['arn:aws:s3:::', !Select [0, !Ref CrossRegionReplicationBuckets], '/*']]
                - !Ref 'AWS::NoValue'
              - Effect: Allow
                Action:
                  - 'kms:Decrypt'
                Resource: !GetAtt S3BucketKMSKey.Arn
                Condition:
                  StringEquals:
                    'kms:ViaService': !Sub 's3.${AWS::Region}.amazonaws.com'
              - Effect: Allow
                Action:
                  - 'kms:Encrypt'
                Resource: 'arn:aws:kms:*:*:alias/aws/s3'
                Condition:
                  StringLike:
                    'kms:ViaService': 's3.*.amazonaws.com'

  # VPC
  VPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: !Ref VpcCidr
      EnableDnsSupport: true
      EnableDnsHostnames: true
      Tags:
        - Key: Name
          Value: !Sub '${EnvironmentSuffix}-vpc'
        - Key: iac-rlhf-amazon
          Value: 'true'

  # Internet Gateway
  InternetGateway:
    Type: AWS::EC2::InternetGateway
    Properties:
      Tags:
        - Key: Name
          Value: !Sub '${EnvironmentSuffix}-igw'
        - Key: iac-rlhf-amazon
          Value: 'true'

  InternetGatewayAttachment:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      InternetGatewayId: !Ref InternetGateway
      VpcId: !Ref VPC

  # Public Subnets
  PublicSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Select [0, !GetAZs '']
      CidrBlock: 10.0.1.0/24
      MapPublicIpOnLaunch: true
      Tags:
        - Key: Name
          Value: !Sub '${EnvironmentSuffix}-public-subnet-1'
        - Key: iac-rlhf-amazon
          Value: 'true'

  PublicSubnet2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Select [1, !GetAZs '']
      CidrBlock: 10.0.2.0/24
      MapPublicIpOnLaunch: true
      Tags:
        - Key: Name
          Value: !Sub '${EnvironmentSuffix}-public-subnet-2'
        - Key: iac-rlhf-amazon
          Value: 'true'

  # Private Subnets
  PrivateSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Select [0, !GetAZs '']
      CidrBlock: 10.0.3.0/24
      MapPublicIpOnLaunch: false
      Tags:
        - Key: Name
          Value: !Sub '${EnvironmentSuffix}-private-subnet-1'
        - Key: iac-rlhf-amazon
          Value: 'true'

  PrivateSubnet2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref VPC
      AvailabilityZone: !Select [1, !GetAZs '']
      CidrBlock: 10.0.4.0/24
      MapPublicIpOnLaunch: false
      Tags:
        - Key: Name
          Value: !Sub '${EnvironmentSuffix}-private-subnet-2'
        - Key: iac-rlhf-amazon
          Value: 'true'

  # NAT Gateways
  NatGateway1EIP:
    Type: AWS::EC2::EIP
    DependsOn: InternetGatewayAttachment
    Properties:
      Domain: vpc

  NatGateway2EIP:
    Type: AWS::EC2::EIP
    DependsOn: InternetGatewayAttachment
    Properties:
      Domain: vpc

  NatGateway1:
    Type: AWS::EC2::NatGateway
    Properties:
      AllocationId: !GetAtt NatGateway1EIP.AllocationId
      SubnetId: !Ref PublicSubnet1
      Tags:
        - Key: Name
          Value: !Sub '${EnvironmentSuffix}-nat-gateway-1'
        - Key: iac-rlhf-amazon
          Value: 'true'

  NatGateway2:
    Type: AWS::EC2::NatGateway
    Properties:
      AllocationId: !GetAtt NatGateway2EIP.AllocationId
      SubnetId: !Ref PublicSubnet2
      Tags:
        - Key: Name
          Value: !Sub '${EnvironmentSuffix}-nat-gateway-2'
        - Key: iac-rlhf-amazon
          Value: 'true'

  # Route Tables
  PublicRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: !Sub '${EnvironmentSuffix}-public-routes'
        - Key: iac-rlhf-amazon
          Value: 'true'

  PublicRoute:
    Type: AWS::EC2::Route
    DependsOn: InternetGatewayAttachment
    Properties:
      RouteTableId: !Ref PublicRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref InternetGateway

  PublicSubnet1RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref PublicRouteTable
      SubnetId: !Ref PublicSubnet1

  PublicSubnet2RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref PublicRouteTable
      SubnetId: !Ref PublicSubnet2

  PrivateRouteTable1:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: !Sub '${EnvironmentSuffix}-private-routes-1'
        - Key: iac-rlhf-amazon
          Value: 'true'

  PrivateRoute1:
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref PrivateRouteTable1
      DestinationCidrBlock: 0.0.0.0/0
      NatGatewayId: !Ref NatGateway1

  PrivateSubnet1RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref PrivateRouteTable1
      SubnetId: !Ref PrivateSubnet1

  PrivateRouteTable2:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: !Sub '${EnvironmentSuffix}-private-routes-2'
        - Key: iac-rlhf-amazon
          Value: 'true'

  PrivateRoute2:
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref PrivateRouteTable2
      DestinationCidrBlock: 0.0.0.0/0
      NatGatewayId: !Ref NatGateway2

  PrivateSubnet2RouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref PrivateRouteTable2
      SubnetId: !Ref PrivateSubnet2

  # Security Groups
  AppSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for application servers
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          CidrIp: 0.0.0.0/0
          Description: Allow HTTP from anywhere
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 0.0.0.0/0
          Description: Allow HTTPS from anywhere
      SecurityGroupEgress:
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          CidrIp: 0.0.0.0/0
          Description: Allow HTTP to anywhere
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 0.0.0.0/0
          Description: Allow HTTPS to anywhere
        - IpProtocol: tcp
          FromPort: 3306
          ToPort: 3306
          CidrIp: !Ref VpcCidr
          Description: Allow MySQL to VPC CIDR
      Tags:
        - Key: Name
          Value: !Sub '${EnvironmentSuffix}-app-sg'
        - Key: iac-rlhf-amazon
          Value: 'true'

  DbSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for database instances
      VpcId: !Ref VPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 3306
          ToPort: 3306
          CidrIp: !Ref VpcCidr
          Description: Allow MySQL from VPC CIDR
      Tags:
        - Key: Name
          Value: !Sub '${EnvironmentSuffix}-db-sg'
        - Key: iac-rlhf-amazon
          Value: 'true'

  # EC2 Instance Profile
  EC2InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Roles:
        - !Ref EC2InstanceRole

  EC2InstanceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore'
      Policies:
        - PolicyName: EC2MinimalAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 's3:GetObject'
                  - 's3:ListBucket'
                Resource:
                  - !GetAtt S3Bucket.Arn
                  - !Sub '${S3Bucket.Arn}/*'
              - Effect: Allow
                Action:
                  - 'secretsmanager:GetSecretValue'
                Resource: !Ref DbSecret
              - Effect: Allow
                Action:
                  - 'cloudwatch:PutMetricData'
                Resource: '*'

  # Launch Template
  LaunchTemplate:
    Type: AWS::EC2::LaunchTemplate
    Properties:
      LaunchTemplateName: !Sub '${EnvironmentSuffix}-launch-template'
      LaunchTemplateData:
        ImageId: '{{resolve:ssm:/aws/service/canonical/ubuntu/server/20.04/stable/current/amd64/hvm/ebs-gp2/ami-id}}'
        InstanceType: t3.micro
        SecurityGroupIds:
          - !Ref AppSecurityGroup
        IamInstanceProfile:
          Name: !Ref EC2InstanceProfile
        UserData:
          Fn::Base64: |
            #!/bin/bash -xe
            apt-get update
            apt-get install -y nginx
            systemctl enable nginx
            systemctl start nginx

  # Auto Scaling Group
  AutoScalingGroup:
    Type: AWS::AutoScaling::AutoScalingGroup
    Properties:
      AutoScalingGroupName: !Sub '${EnvironmentSuffix}-asg'
      MinSize: 2
      MaxSize: 4
      DesiredCapacity: 2
      VPCZoneIdentifier:
        - !Ref PrivateSubnet1
        - !Ref PrivateSubnet2
      LaunchTemplate:
        LaunchTemplateId: !Ref LaunchTemplate
        Version: !GetAtt LaunchTemplate.LatestVersionNumber
      TargetGroupARNs:
        - !Ref ALBTargetGroup
      HealthCheckType: ELB
      HealthCheckGracePeriod: 300
      Tags:
        - Key: Name
          Value: !Sub '${EnvironmentSuffix}-app-instance'
          PropagateAtLaunch: true
        - Key: iac-rlhf-amazon
          Value: 'true'
          PropagateAtLaunch: true

  # CPU Scale-Out Policy
  ScaleOutPolicy:
    Type: AWS::AutoScaling::ScalingPolicy
    Properties:
      AutoScalingGroupName: !Ref AutoScalingGroup
      PolicyType: TargetTrackingScaling
      TargetTrackingConfiguration:
        PredefinedMetricSpecification:
          PredefinedMetricType: ASGAverageCPUUtilization
        TargetValue: 70.0

  # Load Balancer
  ALB:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Name: !Sub '${EnvironmentSuffix}-alb'
      Subnets:
        - !Ref PublicSubnet1
        - !Ref PublicSubnet2
      SecurityGroups:
        - !Ref AppSecurityGroup
      Type: application
      Tags:
        - Key: Name
          Value: !Sub '${EnvironmentSuffix}-alb'
        - Key: iac-rlhf-amazon
          Value: 'true'

  ALBListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      DefaultActions:
        - Type: forward
          TargetGroupArn: !Ref ALBTargetGroup
      LoadBalancerArn: !Ref ALB
      Port: 80
      Protocol: HTTP

  ALBTargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      HealthCheckPath: /
      HealthCheckProtocol: HTTP
      HealthCheckIntervalSeconds: 30
      HealthCheckTimeoutSeconds: 5
      HealthyThresholdCount: 2
      UnhealthyThresholdCount: 5
      Port: 80
      Protocol: HTTP
      TargetType: instance
      VpcId: !Ref VPC
      Tags:
        - Key: Name
          Value: !Sub '${EnvironmentSuffix}-alb-tg'
        - Key: iac-rlhf-amazon
          Value: 'true'

  # RDS Database
  DbSubnetGroup:
    Type: AWS::RDS::DBSubnetGroup
    Properties:
      DBSubnetGroupDescription: Subnet group for RDS DB instances
      SubnetIds:
        - !Ref PrivateSubnet1
        - !Ref PrivateSubnet2
      Tags:
        - Key: Name
          Value: !Sub '${EnvironmentSuffix}-db-subnet-group'
        - Key: iac-rlhf-amazon
          Value: 'true'

  DbParameterGroup:
    Type: AWS::RDS::DBParameterGroup
    Properties:
      Description: Parameter group for RDS MySQL instances
      Family: mysql8.0
      Parameters:
        max_connections: '100'
        character_set_server: 'utf8mb4'
        collation_server: 'utf8mb4_general_ci'
      Tags:
        - Key: Name
          Value: !Sub '${EnvironmentSuffix}-db-parameter-group'
        - Key: iac-rlhf-amazon
          Value: 'true'

  DbSecret:
    Type: AWS::SecretsManager::Secret
    Properties:
      Name: !Sub '${EnvironmentSuffix}-db-credentials'
      Description: RDS database credentials
      GenerateSecretString:
        SecretStringTemplate: '{"username": "admin"}'
        GenerateStringKey: password
        PasswordLength: 16
        ExcludeCharacters: '"@/\'
      Tags:
        - Key: Name
          Value: !Sub '${EnvironmentSuffix}-db-secret'
        - Key: iac-rlhf-amazon
          Value: 'true'

  DbInstance:
    Type: AWS::RDS::DBInstance
    DeletionPolicy: Delete
    Properties:
      DBInstanceIdentifier: !Sub '${EnvironmentSuffix}-db'
      DBName: !Ref DBName
      Engine: mysql
      EngineVersion: 8.0.43
      DBInstanceClass: !Ref DBInstanceClass
      AllocatedStorage: 20
      MaxAllocatedStorage: 100
      StorageType: gp2
      StorageEncrypted: true
      BackupRetentionPeriod: !Ref DBBackupRetentionPeriod
      PreferredBackupWindow: '03:00-04:00'
      PreferredMaintenanceWindow: 'mon:04:00-mon:05:00'
      MultiAZ: true
      PubliclyAccessible: false
      DBSubnetGroupName: !Ref DbSubnetGroup
      VPCSecurityGroups:
        - !Ref DbSecurityGroup
      DBParameterGroupName: !Ref DbParameterGroup
      MasterUsername: !Join ['', ['{{resolve:secretsmanager:', !Ref DbSecret, ':SecretString:username}}' ]]
      MasterUserPassword: !Join ['', ['{{resolve:secretsmanager:', !Ref DbSecret, ':SecretString:password}}' ]]
      EnableIAMDatabaseAuthentication: true
      MonitoringInterval: 60
      MonitoringRoleArn: !GetAtt RDSMonitoringRole.Arn
      DeletionProtection: false
      DeleteAutomatedBackups: true
      Tags:
        - Key: Name
          Value: !Sub '${EnvironmentSuffix}-db-instance'
        - Key: iac-rlhf-amazon
          Value: 'true'

  RDSMonitoringRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: monitoring.rds.amazonaws.com
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AmazonRDSEnhancedMonitoringRole'

  SecretRotationSchedule:
    Type: AWS::SecretsManager::RotationSchedule
    DependsOn: SecretRotationLambdaPermission
    Properties:
      SecretId: !Ref DbSecret
      RotationLambdaARN: !GetAtt SecretRotationLambda.Arn
      RotationRules:
        AutomaticallyAfterDays: 30

  SecretRotationLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${EnvironmentSuffix}-secret-rotation-lambda'
      Runtime: python3.11
      Handler: index.lambda_handler
      Role: !GetAtt SecretRotationLambdaRole.Arn
      Timeout: 30
      Environment:
        Variables:
          SECRET_ID: !Ref DbSecret
          DB_INSTANCE: !Ref DbInstance
      Code:
        ZipFile: |
          import boto3
          import os
          import logging
          
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          
          def lambda_handler(event, context):
              logger.info(f"Received event: {event}")
              # Note: This is a placeholder for a real rotation function
              # Actual implementation would handle secret rotation logic
              return {
                  'statusCode': 200,
                  'body': 'Secret rotation processed'
              }
      Tags:
        - Key: Name
          Value: !Sub '${EnvironmentSuffix}-secret-rotation-lambda'
        - Key: iac-rlhf-amazon
          Value: 'true'

  SecretRotationLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref SecretRotationLambda
      Action: lambda:InvokeFunction
      Principal: secretsmanager.amazonaws.com
      SourceArn: !Ref DbSecret

  SecretRotationLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole'
      Policies:
        - PolicyName: SecretRotationPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'secretsmanager:GetSecretValue'
                  - 'secretsmanager:DescribeSecret'
                  - 'secretsmanager:PutSecretValue'
                  - 'secretsmanager:UpdateSecretVersionStage'
                Resource: !Ref DbSecret
              - Effect: Allow
                Action:
                  - 'rds:ModifyDBInstance'
                Resource: !Sub 'arn:aws:rds:${AWS::Region}:${AWS::AccountId}:db:${DbInstance}'

  # Lambda Function for Web Application
  WebAppLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole'
        - 'arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole'
      Policies:
        - PolicyName: WebAppLambdaPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'secretsmanager:GetSecretValue'
                Resource: !Ref DbSecret
              - Effect: Allow
                Action:
                  - 's3:GetObject'
                  - 's3:PutObject'
                Resource: !Sub '${S3Bucket.Arn}/*'

  WebAppLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${EnvironmentSuffix}-webapp-lambda'
      Runtime: python3.11
      Handler: index.lambda_handler
      Role: !GetAtt WebAppLambdaRole.Arn
      Timeout: 30
      MemorySize: 256
      VpcConfig:
        SecurityGroupIds:
          - !Ref AppSecurityGroup
        SubnetIds:
          - !Ref PrivateSubnet1
          - !Ref PrivateSubnet2
      Environment:
        Variables:
          DB_SECRET_ARN: !Ref DbSecret
          S3_BUCKET: !Ref S3Bucket
          DB_ENDPOINT: !GetAtt DbInstance.Endpoint.Address
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          import logging
          from datetime import datetime
          import socket
          
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          
          def test_database_connectivity():
              """Test database connectivity and return results"""
              db_test_result = {
                  'connection_attempted': False,
                  'connection_successful': False,
                  'error': None,
                  'endpoint': None,
                  'port_accessible': False,
                  'credentials_retrieved': False,
                  'mysql_handshake_received': False,
                  'mysql_version': None,
                  'protocol_version': None,
                  'network_info': {}
              }
              
              try:
                  # Collect network information for debugging
                  try:
                      import subprocess
                      import urllib.request
                      
                      # Get Lambda's network interface info
                      network_info = {}
                      
                      # Get Lambda's IP address by checking what IP it uses for outbound connections
                      try:
                          # Try to get our outbound IP (this will show what IP Lambda uses)
                          req = urllib.request.Request('https://api.ipify.org', headers={'User-Agent': 'Lambda-Test'})
                          with urllib.request.urlopen(req, timeout=5) as response:
                              network_info['lambda_outbound_ip'] = response.read().decode('utf-8')
                      except:
                          network_info['lambda_outbound_ip'] = 'Unable to determine'
                      
                      # Get VPC endpoint information if available
                      try:
                          # Check if we can resolve internal AWS services (indicates VPC setup)
                          vpc_dns_test = socket.gethostbyname('s3.amazonaws.com')
                          network_info['vpc_dns_working'] = True
                          network_info['s3_resolved_ip'] = vpc_dns_test
                      except:
                          network_info['vpc_dns_working'] = False
                      
                      # Check Lambda's environment network details
                      network_info['aws_region'] = os.environ.get('AWS_REGION', 'unknown')
                      network_info['lambda_function_name'] = os.environ.get('AWS_LAMBDA_FUNCTION_NAME', 'unknown')
                      
                      db_test_result['network_info'] = network_info
                      
                  except Exception as net_error:
                      db_test_result['network_info'] = {'error': str(net_error)}
                  
                  # Check if we have database configuration
                  db_secret_arn = os.environ.get('DB_SECRET_ARN')
                  if not db_secret_arn:
                      db_test_result['error'] = 'DB_SECRET_ARN not configured'
                      return db_test_result
                  
                  # Try to get database credentials
                  secrets_client = boto3.client('secretsmanager')
                  secret_response = secrets_client.get_secret_value(SecretId=db_secret_arn)
                  credentials = json.loads(secret_response['SecretString'])
                  db_test_result['credentials_retrieved'] = True
                  
                  # Get RDS endpoint from environment variable
                  db_endpoint = os.environ.get('DB_ENDPOINT')
                  if not db_endpoint:
                      db_test_result['error'] = 'DB_ENDPOINT not configured'
                      return db_test_result
                  
                  db_test_result['endpoint'] = db_endpoint
                  db_test_result['connection_attempted'] = True
                  
                  # Test TCP connectivity to database port
                  try:
                      sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                      sock.settimeout(5)
                      result = sock.connect_ex((db_endpoint, 3306))
                      sock.close()
                      
                      if result == 0:
                          db_test_result['port_accessible'] = True
                          logger.info(f"TCP connection to {db_endpoint}:3306 successful")
                      else:
                          logger.warning(f"TCP connection to {db_endpoint}:3306 failed with code {result}")
                  
                  except Exception as tcp_error:
                      logger.warning(f"TCP test failed: {str(tcp_error)}")
                  
                  # Test MySQL protocol handshake (simpler approach)
                  try:
                      # Create socket connection to MySQL port
                      import struct
                      import time
                      
                      sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                      sock.settimeout(10)
                      sock.connect((db_endpoint, 3306))
                      
                      # Read MySQL initial handshake packet
                      # This will tell us if MySQL is actually responding
                      try:
                          # MySQL sends an initial handshake packet when you connect
                          data = sock.recv(1024)
                          
                          if len(data) > 5:
                              # Parse basic MySQL handshake packet
                              # First 4 bytes are packet length + sequence
                              packet_length = struct.unpack('<I', data[0:4] + b'\x00')[0] & 0xffffff
                              protocol_version = data[4]
                              
                              # Find the server version string (null-terminated)
                              version_start = 5
                              version_end = data.find(b'\x00', version_start)
                              
                              if version_end > version_start:
                                  mysql_version = data[version_start:version_end].decode('utf-8', errors='ignore')
                                  
                                  db_test_result['connection_successful'] = True
                                  db_test_result['mysql_handshake_received'] = True
                                  db_test_result['mysql_version'] = mysql_version
                                  db_test_result['protocol_version'] = protocol_version
                                  
                                  logger.info(f"MySQL handshake successful - Version: {mysql_version}")
                              else:
                                  db_test_result['connection_successful'] = True
                                  db_test_result['mysql_handshake_received'] = True
                                  db_test_result['mysql_version'] = 'Unknown'
                                  logger.info("MySQL handshake received but version parsing failed")
                          else:
                              db_test_result['error'] = 'Received data too short for MySQL handshake'
                              logger.warning("Received data too short for MySQL handshake")
                      
                      except Exception as handshake_error:
                          db_test_result['error'] = f'Handshake parsing failed: {str(handshake_error)}'
                          logger.warning(f"MySQL handshake parsing failed: {str(handshake_error)}")
                      
                      finally:
                          sock.close()
                          
                  except Exception as socket_error:
                      db_test_result['connection_successful'] = False
                      db_test_result['error'] = f'Socket connection failed: {str(socket_error)}'
                      logger.error(f"Socket connection to MySQL failed: {str(socket_error)}")
                  
                  # Test DNS resolution
                  try:
                      import socket as socket_module
                      resolved_ip = socket_module.gethostbyname(db_endpoint)
                      db_test_result['dns_resolution'] = {
                          'successful': True,
                          'resolved_ip': resolved_ip
                      }
                      logger.info(f"DNS resolution successful: {db_endpoint} -> {resolved_ip}")
                  except Exception as dns_error:
                      db_test_result['dns_resolution'] = {
                          'successful': False,
                          'error': str(dns_error)
                      }
                      logger.error(f"DNS resolution failed: {str(dns_error)}")
                  
                  # Test different connection approaches
                  connection_tests = []
                  
                  # Test 1: Quick connection test
                  try:
                      test_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                      test_sock.settimeout(3)
                      start_time = time.time()
                      result = test_sock.connect_ex((db_endpoint, 3306))
                      end_time = time.time()
                      test_sock.close()
                      
                      connection_tests.append({
                          'test': 'quick_connect',
                          'successful': result == 0,
                          'response_time_ms': round((end_time - start_time) * 1000, 2),
                          'error_code': result if result != 0 else None
                      })
                  except Exception as test_error:
                      connection_tests.append({
                          'test': 'quick_connect',
                          'successful': False,
                          'error': str(test_error)
                      })
                  
                  db_test_result['connection_tests'] = connection_tests
              
              except Exception as e:
                  db_test_result['error'] = str(e)
                  logger.error(f"Database test failed: {str(e)}")
              
              return db_test_result
          
          def lambda_handler(event, context):
              logger.info(f"Received event: {event}")
              
              # Test database connectivity
              db_test = test_database_connectivity()
              
              # Create response data
              response_data = {
                  'message': 'Hello from TapStack WebApp Lambda!',
                  'timestamp': datetime.utcnow().isoformat() + 'Z',
                  'environment': os.environ.get('AWS_LAMBDA_FUNCTION_NAME', 'unknown'),
                  'region': os.environ.get('AWS_REGION', 'unknown'),
                  'data': {
                      'users': [
                          {'id': 1, 'name': 'John Doe', 'email': 'john@example.com'},
                          {'id': 2, 'name': 'Jane Smith', 'email': 'jane@example.com'},
                          {'id': 3, 'name': 'Bob Johnson', 'email': 'bob@example.com'}
                      ],
                      'stats': {
                          'total_users': 3,
                          'active_sessions': 12,
                          'last_updated': '2024-01-15T10:30:00Z'
                      }
                  },
                  'config': {
                      's3_bucket': os.environ.get('S3_BUCKET', 'not-configured'),
                      'db_secret_configured': bool(os.environ.get('DB_SECRET_ARN')),
                      'vpc_enabled': True
                  },
                  'database_test': db_test
              }
              
              return {
                  'statusCode': 200,
                  'headers': {
                      'Content-Type': 'application/json',
                      'Access-Control-Allow-Origin': '*',
                      'Access-Control-Allow-Headers': 'Content-Type',
                      'Access-Control-Allow-Methods': 'GET,POST,OPTIONS'
                  },
                  'body': json.dumps(response_data, indent=2)
              }
      Tags:
        - Key: Name
          Value: !Sub '${EnvironmentSuffix}-webapp-lambda'
        - Key: iac-rlhf-amazon
          Value: 'true'

  WebAppLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref WebAppLambda
      Principal: apigateway.amazonaws.com

  # API Gateway
  ApiGateway:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: !Sub '${EnvironmentSuffix}-api'
      EndpointConfiguration:
        Types:
          - REGIONAL
      Tags:
        - Key: Name
          Value: !Sub '${EnvironmentSuffix}-api'
        - Key: iac-rlhf-amazon
          Value: 'true'

  ApiGatewayRootMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      AuthorizationType: NONE
      HttpMethod: GET
      Integration:
        IntegrationHttpMethod: POST
        Type: AWS_PROXY
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${WebAppLambda.Arn}/invocations'
      ResourceId: !GetAtt ApiGateway.RootResourceId
      RestApiId: !Ref ApiGateway

  ApiGatewayDeployment:
    Type: AWS::ApiGateway::Deployment
    DependsOn:
      - ApiGatewayRootMethod
    Properties:
      RestApiId: !Ref ApiGateway

  ApiGatewayStage:
    Type: AWS::ApiGateway::Stage
    Properties:
      DeploymentId: !Ref ApiGatewayDeployment
      RestApiId: !Ref ApiGateway
      StageName: !Ref EnvironmentSuffix
      MethodSettings:
        - ResourcePath: /*
          HttpMethod: '*'
          MetricsEnabled: true

  # CloudTrail
  CloudTrail:
    Type: AWS::CloudTrail::Trail
    Properties:
      IsLogging: true
      S3BucketName: !Ref CloudTrailS3Bucket
      TrailName: !Sub '${EnvironmentSuffix}-cloudtrail'
      EnableLogFileValidation: true
      IncludeGlobalServiceEvents: true
      IsMultiRegionTrail: true
      CloudWatchLogsLogGroupArn: !GetAtt CloudTrailLogGroup.Arn
      CloudWatchLogsRoleArn: !GetAtt CloudTrailLogsRole.Arn
      Tags:
        - Key: Name
          Value: !Sub '${EnvironmentSuffix}-cloudtrail'
        - Key: iac-rlhf-amazon
          Value: 'true'

  CloudTrailS3Bucket:
    Type: AWS::S3::Bucket
    DeletionPolicy: Delete
    Properties:
      BucketName: !Sub '${AWS::AccountId}-${AWS::Region}-${EnvironmentSuffix}-cloudtrail-logs-${RandomSuffix}'
      VersioningConfiguration:
        Status: Suspended
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      LifecycleConfiguration:
        Rules:
          - Id: DeleteEverythingRule
            Status: Enabled
            ExpirationInDays: 1
            NoncurrentVersionExpirationInDays: 1
            AbortIncompleteMultipartUpload:
              DaysAfterInitiation: 1
      Tags:
        - Key: Name
          Value: !Sub '${EnvironmentSuffix}-cloudtrail-bucket'
        - Key: iac-rlhf-amazon
          Value: 'true'

  CloudTrailS3BucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref CloudTrailS3Bucket
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: AWSCloudTrailAclCheck
            Effect: Allow
            Principal:
              Service: cloudtrail.amazonaws.com
            Action: 's3:GetBucketAcl'
            Resource: !GetAtt CloudTrailS3Bucket.Arn
          - Sid: AWSCloudTrailWrite
            Effect: Allow
            Principal:
              Service: cloudtrail.amazonaws.com
            Action: 's3:PutObject'
            Resource: !Sub '${CloudTrailS3Bucket.Arn}/AWSLogs/${AWS::AccountId}/*'
            Condition:
              StringEquals:
                's3:x-amz-acl': 'bucket-owner-full-control'

  CloudTrailLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/aws/cloudtrail/${EnvironmentSuffix}'
      RetentionInDays: 90
      Tags:
        - Key: Name
          Value: !Sub '${EnvironmentSuffix}-cloudtrail-log-group'
        - Key: iac-rlhf-amazon
          Value: 'true'

  CloudTrailLogsRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: cloudtrail.amazonaws.com
            Action: 'sts:AssumeRole'
      Policies:
        - PolicyName: CloudTrailLogsPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'logs:CreateLogStream'
                  - 'logs:PutLogEvents'
                Resource: !GetAtt CloudTrailLogGroup.Arn

  # CloudWatch Logs
  AppLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/aws/ec2/${EnvironmentSuffix}-app'
      RetentionInDays: 90
      Tags:
        - Key: Name
          Value: !Sub '${EnvironmentSuffix}-app-log-group'
        - Key: iac-rlhf-amazon
          Value: 'true'

  LambdaLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub '/aws/lambda/${EnvironmentSuffix}-webapp-lambda'
      RetentionInDays: 90
      Tags:
        - Key: Name
          Value: !Sub '${EnvironmentSuffix}-lambda-log-group'
        - Key: iac-rlhf-amazon
          Value: 'true'

  # AWS WAF
  WebACL:
    Type: AWS::WAFv2::WebACL
    Properties:
      Name: !Sub '${EnvironmentSuffix}-web-acl'
      Scope: !Ref WAFScope
      DefaultAction:
        Allow: {}
      VisibilityConfig:
        CloudWatchMetricsEnabled: true
        MetricName: !Sub '${EnvironmentSuffix}WebACLMetric'
        SampledRequestsEnabled: true
      Rules:
        - Name: AWSManagedRulesCommonRuleSet
          Priority: 0
          OverrideAction:
            None: {}
          VisibilityConfig:
            CloudWatchMetricsEnabled: true
            MetricName: !Sub '${EnvironmentSuffix}AWSManagedRulesCommonRuleSetMetric'
            SampledRequestsEnabled: true
          Statement:
            ManagedRuleGroupStatement:
              VendorName: AWS
              Name: AWSManagedRulesCommonRuleSet
        - Name: RateLimitRule
          Priority: 1
          Action:
            Block: {}
          VisibilityConfig:
            CloudWatchMetricsEnabled: true
            MetricName: !Sub '${EnvironmentSuffix}RateLimitRuleMetric'
            SampledRequestsEnabled: true
          Statement:
            RateBasedStatement:
              Limit: 100
              AggregateKeyType: IP

  WebACLAssociation:
    Type: AWS::WAFv2::WebACLAssociation
    Properties:
      ResourceArn: !Ref ALB
      WebACLArn: !GetAtt WebACL.Arn

  # Route 53 Hosted Zone
  HostedZone:
    Type: AWS::Route53::HostedZone
    Condition: CreateRoute53
    Properties:
      Name: !Ref DomainName
      HostedZoneConfig:
        Comment: !Sub 'Hosted zone for ${EnvironmentSuffix} environment'
      HostedZoneTags:
        - Key: Name
          Value: !Sub '${EnvironmentSuffix}-hosted-zone'
        - Key: Environment
          Value: !Ref EnvironmentSuffix
        - Key: iac-rlhf-amazon
          Value: 'true'

  # Route 53 A Record for ALB (HTTP)
  ALBRecord:
    Type: AWS::Route53::RecordSet
    Condition: CreateRoute53
    Properties:
      HostedZoneId: !Ref HostedZone
      Name: !Sub 'app.${DomainName}'
      Type: A
      AliasTarget:
        DNSName: !GetAtt ALB.DNSName
        HostedZoneId: !GetAtt ALB.CanonicalHostedZoneID
        EvaluateTargetHealth: true
      Comment: !Sub 'A record for ${EnvironmentSuffix} ALB (HTTP)'

  # Route 53 A Record for API Gateway
  # Note: Uses AWS's hosted zone ID for API Gateway regional endpoints
  # These IDs are AWS-managed and don't require you to own any domain
  APIRecord:
    Type: AWS::Route53::RecordSet
    Condition: CreateRoute53
    Properties:
      HostedZoneId: !Ref HostedZone
      Name: !Sub 'api.${DomainName}'
      Type: A
      AliasTarget:
        DNSName: !Sub '${ApiGateway}.execute-api.${AWS::Region}.amazonaws.com'
        HostedZoneId: !FindInMap
          - RegionMap
          - !Ref 'AWS::Region'
          - APIGatewayHostedZoneId
        EvaluateTargetHealth: true
      Comment: !Sub 'A record for ${EnvironmentSuffix} API Gateway (points to AWS-managed endpoint)'

  # Route 53 CNAME Record for www subdomain (points to ALB)
  WWWRecord:
    Type: AWS::Route53::RecordSet
    Condition: CreateRoute53
    Properties:
      HostedZoneId: !Ref HostedZone
      Name: !Sub 'www.${DomainName}'
      Type: CNAME
      TTL: 300
      ResourceRecords:
        - !Sub 'app.${DomainName}'
      Comment: !Sub 'CNAME record for www.${DomainName} pointing to ALB'

  # Route 53 root domain A record (points to ALB)
  RootRecord:
    Type: AWS::Route53::RecordSet
    Condition: CreateRoute53
    Properties:
      HostedZoneId: !Ref HostedZone
      Name: !Ref DomainName
      Type: A
      AliasTarget:
        DNSName: !GetAtt ALB.DNSName
        HostedZoneId: !GetAtt ALB.CanonicalHostedZoneID
        EvaluateTargetHealth: true
      Comment: !Sub 'Root A record for ${DomainName} pointing to ALB'


Outputs:
  ConfigS3BucketName:
    Description: Name of the S3 bucket used for AWS Config
    Value: !Ref ConfigS3Bucket
    Export:
      Name: !Sub '${AWS::StackName}-ConfigS3BucketName'

  ConfigS3BucketArn:
    Description: ARN of the S3 bucket used for AWS Config
    Value: !GetAtt ConfigS3Bucket.Arn
    Export:
      Name: !Sub '${AWS::StackName}-ConfigS3BucketArn'

  ConfigServiceRoleArn:
    Description: ARN of the IAM role used by AWS Config
    Value: !GetAtt ConfigServiceRole.Arn
    Export:
      Name: !Sub '${AWS::StackName}-ConfigServiceRoleArn'

  ConfigRecorderName:
    Description: Name of the AWS Config Configuration Recorder
    Value: !Ref ConfigRecorder
    Export:
      Name: !Sub '${AWS::StackName}-ConfigRecorderName'

  ConfigDeliveryChannelName:
    Description: Name of the AWS Config Delivery Channel
    Value: !Ref ConfigDeliveryChannel
    Export:
      Name: !Sub '${AWS::StackName}-ConfigDeliveryChannelName'

  ConfigRulesCount:
    Description: Number of Config Rules deployed
    Value: '2'
    Export:
      Name: !Sub '${AWS::StackName}-ConfigRulesCount'

  S3BucketPublicReadRuleName:
    Description: Name of the S3 Bucket Public Read Config Rule
    Value: !Ref S3BucketPublicReadRule
    Export:
      Name: !Sub '${AWS::StackName}-S3BucketPublicReadRuleName'

  S3BucketPublicWriteRuleName:
    Description: Name of the S3 Bucket Public Write Config Rule
    Value: !Ref S3BucketPublicWriteRule
    Export:
      Name: !Sub '${AWS::StackName}-S3BucketPublicWriteRuleName'

  S3BucketName:
    Description: Name of the S3 bucket
    Value: !Ref S3Bucket
    Export:
      Name: !Sub '${AWS::StackName}-S3BucketName'

  S3BucketArn:
    Description: ARN of the S3 bucket
    Value: !GetAtt S3Bucket.Arn
    Export:
      Name: !Sub '${AWS::StackName}-S3BucketArn'

  S3ReplicationRoleArn:
    Description: ARN of the IAM role used for S3 replication
    Value: !GetAtt S3ReplicationRole.Arn
    Export:
      Name: !Sub '${AWS::StackName}-S3ReplicationRoleArn'

  S3BucketKMSKeyArn:
    Description: ARN of the KMS key used for S3 bucket encryption
    Value: !GetAtt S3BucketKMSKey.Arn
    Export:
      Name: !Sub '${AWS::StackName}-S3BucketKMSKeyArn'

  VpcId:
    Description: ID of the VPC
    Value: !Ref VPC
    Export:
      Name: !Sub '${AWS::StackName}-VpcId'

  PublicSubnet1Id:
    Description: ID of the public subnet in the first availability zone
    Value: !Ref PublicSubnet1
    Export:
      Name: !Sub '${AWS::StackName}-PublicSubnet1Id'

  PublicSubnet2Id:
    Description: ID of the public subnet in the second availability zone
    Value: !Ref PublicSubnet2
    Export:
      Name: !Sub '${AWS::StackName}-PublicSubnet2Id'

  PrivateSubnet1Id:
    Description: ID of the private subnet in the first availability zone
    Value: !Ref PrivateSubnet1
    Export:
      Name: !Sub '${AWS::StackName}-PrivateSubnet1Id'

  PrivateSubnet2Id:
    Description: ID of the private subnet in the second availability zone
    Value: !Ref PrivateSubnet2
    Export:
      Name: !Sub '${AWS::StackName}-PrivateSubnet2Id'

  AppSecurityGroupId:
    Description: ID of the security group for the application servers
    Value: !Ref AppSecurityGroup
    Export:
      Name: !Sub '${AWS::StackName}-AppSecurityGroupId'

  DbSecurityGroupId:
    Description: ID of the security group for the database servers
    Value: !Ref DbSecurityGroup
    Export:
      Name: !Sub '${AWS::StackName}-DbSecurityGroupId'

  AutoScalingGroupName:
    Description: Name of the auto scaling group
    Value: !Ref AutoScalingGroup
    Export:
      Name: !Sub '${AWS::StackName}-AutoScalingGroupName'

  LaunchTemplateId:
    Description: ID of the launch template
    Value: !Ref LaunchTemplate
    Export:
      Name: !Sub '${AWS::StackName}-LaunchTemplateId'

  EC2InstanceRoleArn:
    Description: ARN of the IAM role for EC2 instances
    Value: !GetAtt EC2InstanceRole.Arn
    Export:
      Name: !Sub '${AWS::StackName}-EC2InstanceRoleArn'

  LoadBalancerDnsName:
    Description: DNS name of the load balancer
    Value: !GetAtt ALB.DNSName
    Export:
      Name: !Sub '${AWS::StackName}-LoadBalancerDnsName'

  LoadBalancerArn:
    Description: ARN of the load balancer
    Value: !Ref ALB
    Export:
      Name: !Sub '${AWS::StackName}-LoadBalancerArn'

  DbInstanceEndpoint:
    Description: Connection endpoint for the RDS instance
    Value: !GetAtt DbInstance.Endpoint.Address
    Export:
      Name: !Sub '${AWS::StackName}-DbInstanceEndpoint'

  DbSecretArn:
    Description: ARN of the secret storing database credentials
    Value: !Ref DbSecret
    Export:
      Name: !Sub '${AWS::StackName}-DbSecretArn'

  WebAppLambdaArn:
    Description: ARN of the Lambda function for web application
    Value: !GetAtt WebAppLambda.Arn
    Export:
      Name: !Sub '${AWS::StackName}-WebAppLambdaArn'

  ApiGatewayUrl:
    Description: URL of the API Gateway endpoint
    Value: !Sub 'https://${ApiGateway}.execute-api.${AWS::Region}.amazonaws.com/${EnvironmentSuffix}/'
    Export:
      Name: !Sub '${AWS::StackName}-ApiGatewayUrl'

  WebsiteUrl:
    Description: URL of the website (ALB endpoint)
    Value: !Sub 'http://${ALB.DNSName}'
    Export:
      Name: !Sub '${AWS::StackName}-WebsiteUrl'

  ApiUrl:
    Description: URL of the API (API Gateway endpoint)
    Value: !Sub 'https://${ApiGateway}.execute-api.${AWS::Region}.amazonaws.com/${EnvironmentSuffix}/'
    Export:
      Name: !Sub '${AWS::StackName}-ApiUrl'

  CloudTrailName:
    Description: Name of the CloudTrail trail
    Value: !Ref CloudTrail
    Export:
      Name: !Sub '${AWS::StackName}-CloudTrailName'

  CloudTrailS3BucketName:
    Description: Name of the S3 bucket for CloudTrail logs
    Value: !Ref CloudTrailS3Bucket
    Export:
      Name: !Sub '${AWS::StackName}-CloudTrailS3BucketName'

  WebACLArn:
    Description: ARN of the WAF web ACL
    Value: !GetAtt WebACL.Arn
    Export:
      Name: !Sub '${AWS::StackName}-WebACLArn'

  # Additional outputs for integration testing
  NatGateway1Id:
    Description: ID of the first NAT Gateway
    Value: !Ref NatGateway1
    Export:
      Name: !Sub '${AWS::StackName}-NatGateway1Id'

  NatGateway2Id:
    Description: ID of the second NAT Gateway
    Value: !Ref NatGateway2
    Export:
      Name: !Sub '${AWS::StackName}-NatGateway2Id'

  InternetGatewayId:
    Description: ID of the Internet Gateway
    Value: !Ref InternetGateway
    Export:
      Name: !Sub '${AWS::StackName}-InternetGatewayId'

  SecretRotationLambdaArn:
    Description: ARN of the secret rotation Lambda function
    Value: !GetAtt SecretRotationLambda.Arn
    Export:
      Name: !Sub '${AWS::StackName}-SecretRotationLambdaArn'

  CloudTrailArn:
    Description: ARN of the CloudTrail trail
    Value: !GetAtt CloudTrail.Arn
    Export:
      Name: !Sub '${AWS::StackName}-CloudTrailArn'

  KMSKeyId:
    Description: ID of the KMS key used for S3 encryption
    Value: !Ref S3BucketKMSKey
    Export:
      Name: !Sub '${AWS::StackName}-KMSKeyId'

  PublicRouteTableId:
    Description: ID of the public route table
    Value: !Ref PublicRouteTable
    Export:
      Name: !Sub '${AWS::StackName}-PublicRouteTableId'

  PrivateRouteTable1Id:
    Description: ID of the first private route table
    Value: !Ref PrivateRouteTable1
    Export:
      Name: !Sub '${AWS::StackName}-PrivateRouteTable1Id'

  PrivateRouteTable2Id:
    Description: ID of the second private route table
    Value: !Ref PrivateRouteTable2
    Export:
      Name: !Sub '${AWS::StackName}-PrivateRouteTable2Id'

  # Route 53 Outputs (conditional)
  HostedZoneId:
    Condition: CreateRoute53
    Description: ID of the Route 53 hosted zone
    Value: !Ref HostedZone
    Export:
      Name: !Sub '${AWS::StackName}-HostedZoneId'

  HostedZoneName:
    Condition: CreateRoute53
    Description: Name of the Route 53 hosted zone
    Value: !Ref DomainName
    Export:
      Name: !Sub '${AWS::StackName}-HostedZoneName'

  DomainNameServers:
    Condition: CreateRoute53
    Description: Name servers for the hosted zone
    Value: !Join [',', !GetAtt HostedZone.NameServers]
    Export:
      Name: !Sub '${AWS::StackName}-DomainNameServers'

  AppDomainName:
    Condition: CreateRoute53
    Description: Domain name for the application (ALB)
    Value: !Sub 'app.${DomainName}'
    Export:
      Name: !Sub '${AWS::StackName}-AppDomainName'

  APIDomainName:
    Condition: CreateRoute53
    Description: Domain name for the API (API Gateway)
    Value: !Sub 'api.${DomainName}'
    Export:
      Name: !Sub '${AWS::StackName}-APIDomainName'

  RootDomainName:
    Condition: CreateRoute53
    Description: Root domain name
    Value: !Ref DomainName
    Export:
      Name: !Sub '${AWS::StackName}-RootDomainName'

  WWWDomainName:
    Condition: CreateRoute53
    Description: WWW subdomain name
    Value: !Sub 'www.${DomainName}'
    Export:
      Name: !Sub '${AWS::StackName}-WWWDomainName'