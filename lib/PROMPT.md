You're building a production-ready static website hosting infrastructure on AWS S3 to serve media assets for an upcoming product launch. The solution requires a single S3 bucket configured for public website hosting with a globally unique name that combines the prefix "media-assets-" with an 8-character random suffix. This bucket will host your index.html and error.html pages along with all associated static content like images, CSS, and JavaScript files. The infrastructure must support version tracking, implement intelligent storage cost optimization through lifecycle policies, and ensure proper CORS configuration for modern web applications. Deploy everything to the us-west-2 region using AWS provider version 5.x.

Security is critical even for publicly accessible content. Enable server-side encryption using AWS-managed keys (SSE-S3) to protect data at rest. Configure bucket versioning to maintain a complete history of all object modifications, enabling recovery from accidental overwrites or deletions. While the bucket must allow public read access for static website hosting functionality, implement this through a carefully scoped bucket policy that references the bucket ARN dynamically rather than hardcoding values. The policy should grant s3:GetObject permissions to all principals for objects within the bucket, and ensure public access settings permit this configuration.

The bucket requires specific operational configurations. Use the random_string resource to generate exactly 8 characters for the bucket name suffix. Configure static website hosting with "index.html" as the index document and "error.html" as the error document. Implement a lifecycle rule that transitions objects to S3 Standard-IA storage class after 30 days—this rule must only transition storage classes, never delete objects. Set up CORS rules allowing GET requests from any origin with a max age of 3600 seconds, explicitly permitting "Content-Type" and "Authorization" headers. Apply tags: Environment='production' and Project='media-launch'.

Organize the code into exactly two Terraform files: provider.tf should contain the Terraform block with required_providers for Terraform version 1.5.0 or higher and AWS provider version 5.0 or higher, configure S3 backend with backend "s3" {}, and include the AWS provider with region set to "us-west-2" with default_tags configuration. The main.tf file should contain all code organized in this order: variables section with aws_region, data sources for aws_caller_identity and aws_region, locals for account_id and common_tags (including Environment and Project tags), resource blocks including random_string for the suffix, aws_s3_bucket, aws_s3_bucket_versioning, aws_s3_bucket_server_side_encryption_configuration, aws_s3_bucket_website_configuration, aws_s3_bucket_cors_configuration, aws_s3_bucket_lifecycle_configuration, aws_s3_bucket_public_access_block, and aws_s3_bucket_policy, and outputs for bucket_name, website_endpoint, and bucket_arn with descriptions.

Don't hardcode the AWS account ID or bucket ARN—use data sources and resource references. Don't configure lifecycle rules to delete objects, only transition storage classes. Don't use AWS provider versions outside ~> 5.0. Don't set the region to anything other than us-west-2. Ensure the random suffix is exactly 8 characters by setting the length parameter correctly in the random_string resource.

The infrastructure should deploy successfully with terraform init, plan, and apply in sequence. After deployment, test the website endpoint accessibility and verify that CORS headers are correctly configured. Upload sample objects to validate public read access works properly and confirm that lifecycle policies are active for long-term cost optimization.