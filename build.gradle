import groovy.xml.XmlParser

plugins {
    id 'java'
    id 'application'
    id 'checkstyle'
    id 'jacoco'
}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(17)
        vendor = JvmVendorSpec.ADOPTIUM
    }
}

repositories {
    maven {
        url("https://maven-central.storage-download.googleapis.com/maven2/")
    }
    mavenCentral()
    mavenLocal()
}

ext {
    //Dependency version management
    pulumiVersion = '1.16.1'
    pulumiAwsVersion = '7.5.0'
    awsCdkVersion = '2.204.0'
    awsCdkConstructsVersion = '10.4.2'
    hashicorpCdktfVersion = '0.21.0'
    hashicorpCdktfAwsVersion = '21.0.0'
    hashicorpCdktfRandomVersion = '12.0.0'
    hashicorpCdktfArchiveVersion = '11.0.0'
    guavaVersion = '33.0.0-jre'
    jacksonVersion = '2.17.1'
    awsSdkVersion = '2.25.16'
    junitVersion = '5.10.2'
    mockitoVersion = '5.11.0'
    assertjVersion = '3.24.2'
    googleCodeGsonVersion = '2.10.1'

    //Build settings
    def metadataFile = file("metadata.json")
    def platform = "default"
    if (metadataFile.exists()) {
        def metadata = new groovy.json.JsonSlurper().parseText(metadataFile.text)
        platform = metadata.platform ?: "default"
    }

    switch (platform) {
        case "pulumi":
            minimumTestCoverage = 20.0
            break
        case "cdk":
            minimumTestCoverage = 90.0
            break
        case "cdktf":
            minimumTestCoverage = 90.0
            break
        default:
            minimumTestCoverage = 20.0
    }
}

// Resolve dependency conflicts
configurations.configureEach {
    resolutionStrategy {
        force "com.google.guava:guava:${guavaVersion}"
        eachDependency { details ->
            if (details.requested.group == 'com.google.collections' && details.requested.name == 'google-collections') {
                details.useTarget "com.google.guava:guava:${guavaVersion}"
                details.because 'google-collections is replaced by guava'
            }
        }
    }
}

dependencies {
    // Pulumi dependencies
    implementation "com.pulumi:pulumi:${pulumiVersion}"
    implementation "com.pulumi:aws:${pulumiAwsVersion}"
    implementation "com.hashicorp:cdktf:${hashicorpCdktfVersion}"
    implementation "com.hashicorp:cdktf-provider-aws:${hashicorpCdktfAwsVersion}"
    implementation "com.hashicorp:cdktf-provider-random:${hashicorpCdktfRandomVersion}"
    implementation "com.hashicorp:cdktf-provider-archive:${hashicorpCdktfArchiveVersion}"
    implementation "com.hashicorp:cdktf-provider-tls:11.0.0"
    implementation 'com.pulumi:tls:5.2.0'
    implementation 'software.amazon.awscdk:aws-cdk-lib:2.149.0'
    implementation 'software.constructs:constructs:10.3.0'
    implementation 'io.github.cdklabs:cdknag:2.37.40'
    implementation platform("software.amazon.awssdk:bom:${awsSdkVersion}")
    implementation 'software.amazon.awssdk:cloudwatchlogs'
    implementation 'software.amazon.awssdk:ssm'
    implementation 'software.amazon.awssdk:rds'
    implementation 'software.amazon.awssdk:wafv2'

    // AWS CDK dependencies
    implementation "software.amazon.awscdk:aws-cdk-lib:${awsCdkVersion}"
    implementation "software.constructs:constructs:${awsCdkConstructsVersion}"

    // Utilities
    implementation "com.google.code.gson:gson:${googleCodeGsonVersion}"
    implementation "com.google.guava:guava:${guavaVersion}"

    // Test dependencies
    testImplementation "org.junit.jupiter:junit-jupiter:${junitVersion}"
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
    testImplementation "org.mockito:mockito-core:${mockitoVersion}"
    testImplementation "org.mockito:mockito-junit-jupiter:${mockitoVersion}"
    testImplementation "org.assertj:assertj-core:${assertjVersion}"
    testImplementation "com.fasterxml.jackson.core:jackson-databind:${jacksonVersion}"
    testImplementation 'org.junit.jupiter:junit-jupiter:5.10.1'
    testImplementation 'org.assertj:assertj-core:3.24.2'
    
    // SLF4J implementation for tests
    testImplementation 'org.slf4j:slf4j-simple:2.0.7'
}

application {
    mainClass = 'app.Main'
}

// Override run task to handle environment properly
tasks.named('run') {
    standardInput = System.in
    workingDir = projectDir
    systemProperties = System.getProperties()
    environment = System.getenv()
}

// Configure source directories
sourceSets {
    main {
        java {
            srcDirs = ['src/main/java', 'lib/src/main/java']
        }
    }
    test {
        java {
            srcDirs = ['tests/unit/java']
        }
    }
    integrationTest {
        java {
            srcDirs = ['tests/integration/java']
        }
        resources {
            srcDirs = ['tests/integration/resources']
        }
        compileClasspath += sourceSets.main.output + sourceSets.test.output
        runtimeClasspath += sourceSets.main.output + sourceSets.test.output
    }
}

// Configure integration test configurations
configurations {
    integrationTestImplementation.extendsFrom implementation, testImplementation
    integrationTestRuntimeOnly.extendsFrom runtimeOnly, testRuntimeOnly
}

// Integration test dependencies
dependencies {
    // AWS SDK BOM for consistent versions
    integrationTestImplementation platform("software.amazon.awssdk:bom:${awsSdkVersion}")
    integrationTestImplementation 'software.amazon.awssdk:s3'
    integrationTestImplementation 'software.amazon.awssdk:ec2'
    integrationTestImplementation 'software.amazon.awssdk:iam'
    integrationTestImplementation 'software.amazon.awssdk:kms'
    integrationTestImplementation 'software.amazon.awssdk:cloudformation'
    integrationTestImplementation 'software.amazon.awssdk:cloudtrail'
    integrationTestImplementation 'software.amazon.awssdk:cloudwatch'
    integrationTestImplementation 'software.amazon.awssdk:cloudwatchlogs'
    integrationTestImplementation 'software.amazon.awssdk:sns'
    integrationTestImplementation 'software.amazon.awssdk:sts'
    integrationTestImplementation 'software.amazon.awssdk:elasticloadbalancingv2'
    integrationTestImplementation 'software.amazon.awssdk:autoscaling'
    integrationTestImplementation 'software.amazon.awssdk:rds'
    integrationTestImplementation 'software.amazon.awssdk:lambda'
    integrationTestImplementation 'software.amazon.awssdk:apigateway'
    integrationTestImplementation 'software.amazon.awssdk:dynamodb'
    integrationTestImplementation 'software.amazon.awssdk:sqs'
    integrationTestImplementation 'software.amazon.awssdk:networkfirewall'
    integrationTestImplementation 'software.amazon.awssdk:config'
    integrationTestImplementation 'software.amazon.awssdk:secretsmanager'
    integrationTestImplementation 'software.amazon.awssdk:ssm'
    integrationTestImplementation 'software.amazon.awssdk:codepipeline'
    integrationTestImplementation 'software.amazon.awssdk:codebuild'
    integrationTestImplementation 'software.amazon.awssdk:codedeploy'
    integrationTestImplementation 'software.amazon.awssdk:cognitoidentityprovider'
    integrationTestImplementation 'software.amazon.awssdk:ecs'
    integrationTestImplementation 'software.amazon.awssdk:servicediscovery'
    integrationTestImplementation 'software.amazon.awssdk:kinesis'
    // ElastiCache for Redis cluster testing
    integrationTestImplementation 'software.amazon.awssdk:elasticache'
    // SageMaker for ML endpoint testing
    integrationTestImplementation 'software.amazon.awssdk:sagemaker'
    // CloudFront for CDN testing
    integrationTestImplementation 'software.amazon.awssdk:cloudfront'
    // Jedis - Redis client library for ElastiCache integration testing
    // This is NOT an AWS SDK - it's a Java Redis client
    integrationTestImplementation 'redis.clients:jedis:5.0.0'
    

    // Additional AWS SDK dependencies for comprehensive integration tests
    integrationTestImplementation 'software.amazon.awssdk:kendra'
    integrationTestImplementation 'software.amazon.awssdk:sfn'
    integrationTestImplementation 'software.amazon.awssdk:eventbridge'
    integrationTestImplementation 'software.amazon.awssdk:auth'
    integrationTestImplementation 'software.amazon.awssdk:regions'
    
    // NEW: AWS AI/ML Services for integration tests
    integrationTestImplementation 'software.amazon.awssdk:comprehend'
    integrationTestImplementation 'software.amazon.awssdk:translate'
    
    // NEW: SES for email testing
    integrationTestImplementation 'software.amazon.awssdk:ses'


    integrationTestImplementation 'software.amazon.awssdk:cloudfront'
    integrationTestImplementation 'software.amazon.awssdk:guardduty'
    integrationTestImplementation 'software.amazon.awssdk:wafv2'

    // WebSocket client for testing
    integrationTestImplementation 'javax.websocket:javax.websocket-api:1.1'
    integrationTestImplementation 'org.glassfish.tyrus.bundles:tyrus-standalone-client:1.19'

    // JSON parsing for integration tests
    integrationTestImplementation "com.fasterxml.jackson.core:jackson-databind:${jacksonVersion}"
    integrationTestImplementation "com.fasterxml.jackson.core:jackson-core:${jacksonVersion}"
    
    // SLF4J implementation for integration tests
    integrationTestImplementation 'org.slf4j:slf4j-simple:2.0.7'
}
// Configure JAR with main class
jar {
    manifest {
        attributes(
                'Main-Class': 'app.Main'
        )
    }
    archiveBaseName.set('app')
    archiveVersion.set('')
}

// Create a fat JAR task separately if needed
tasks.register('fatJar', Jar) {
    group = 'build'
    description = 'Creates a fat JAR with all dependencies'
    archiveClassifier.set('fat')

    manifest {
        attributes(
                'Main-Class': 'app.Main'
        )
    }

    from {
        configurations.runtimeClasspath.collect {
            it.isDirectory() ? it : zipTree(it)
        }
    }

    with jar
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    zip64 = true
}

// Clean task for JaCoCo execution data
tasks.register('cleanJacocoData') {
    group = 'verification'
    description = 'Cleans JaCoCo execution data files'
    doLast {
        delete fileTree(layout.buildDirectory.dir("jacoco")).include("*.exec")
        delete layout.buildDirectory.dir("reports/jacoco")
    }
}

// JUnit configuration
test {
    useJUnitPlatform()
    testClassesDirs = sourceSets.test.output.classesDirs
    classpath = sourceSets.test.runtimeClasspath

    testLogging {
        events "passed", "skipped", "failed", "standardOut", "standardError"
        exceptionFormat "full"
        showCauses true
        showExceptions true
        showStackTraces true
    }

    // Enable test execution when tests are specifically requested
    systemProperty 'gradle.test.enabled', 'true'

    // Clean JaCoCo data before running tests to ensure fresh coverage data
    dependsOn cleanJacocoData

    onlyIf {
        isCoverageTaskRequested()
    }

}

// Integration test task
tasks.register('integrationTest', Test) {
    description = 'Runs integration tests.'
    group = 'verification'

    testClassesDirs = sourceSets.integrationTest.output.classesDirs
    classpath = sourceSets.integrationTest.runtimeClasspath
    useJUnitPlatform()

    testLogging {
        events "passed", "skipped", "failed", "standardOut", "standardError"
        exceptionFormat "full"
        showCauses true
        showExceptions true
        showStackTraces true
        showStandardStreams true
        displayGranularity = 2
    }

    // Set test timeout to prevent hanging
    systemProperty "junit.jupiter.execution.timeout.default", "30s"
    
    // Continue on failure to see all test results
    ignoreFailures = false
    
    // Disable parallel execution for integration tests
    systemProperty "junit.jupiter.execution.parallel.enabled", "false"

    shouldRunAfter test

    // Enable JaCoCo for integration tests
    jacoco {
        enabled = true
        destinationFile = layout.buildDirectory.file("jacoco/integrationTest.exec").get().asFile
    }

    onlyIf {
        isTestTaskRequested()
    }
}

// Helper method to check if test tasks are requested
def isTestTaskRequested() {
    def requestedTasks = gradle.startParameter.taskNames
    def testTasks = ['test', 'integrationTest', 'testAll', 'showCoverage', 'jacocoTestReport']
    return testTasks.any { testTask ->
        requestedTasks.any { requestedTask ->
            requestedTask.contains(testTask)
        }
    }
}

// Helper method for coverage verification (includes itself in the task list)
def isCoverageTaskRequested() {
    def requestedTasks = gradle.startParameter.taskNames
    def testTasks = ['test', 'integrationTest', 'testAll', 'showCoverage',
                     'jacocoTestReport', 'jacocoTestCoverageVerification']
    return testTasks.any { testTask ->
        requestedTasks.any { requestedTask ->
            requestedTask.contains(testTask)
        }
    }
}

// Checkstyle configuration
checkstyle {
    toolVersion = '10.12.7'
    configFile = file('config/checkstyle/checkstyle.xml')
    ignoreFailures = false
    maxWarnings = 0
    maxErrors = 0
}

tasks.withType(Checkstyle).configureEach {

    source = sourceSets.main.allJava
    exclude {
        it.file.absolutePath.contains('src/main/java/imports/')
    }
}

// JaCoCo configuration
jacoco {
    toolVersion = "0.8.11"
}

jacocoTestReport {
    dependsOn test

    reports {
        xml.required = true
        html.required = true
        csv.required = false
    }

    // Only include unit test execution data
    executionData layout.buildDirectory.file("jacoco/test.exec")

    finalizedBy jacocoTestCoverageVerification

    onlyIf {
        isTestTaskRequested()
    }
}

// Integration test JaCoCo report
tasks.register('jacocoIntegrationTestReport', JacocoReport) {
    dependsOn integrationTest
    group = 'verification'
    description = 'Generate JaCoCo coverage report for integration tests'

    reports {
        xml.required = true
        html.required = true
        csv.required = false
    }

    // Only include integration test execution data
    executionData layout.buildDirectory.file("jacoco/integrationTest.exec")

    finalizedBy jacocoIntegrationTestCoverageVerification

    onlyIf {
        isTestTaskRequested()
    }
}

// Integration test coverage verification
tasks.register('jacocoIntegrationTestCoverageVerification', JacocoCoverageVerification) {
    dependsOn jacocoIntegrationTestReport
    group = 'verification'
    description = 'Verify integration test coverage meets minimum requirements'

    violationRules {
        rule {
            limit {
                minimum = minimumTestCoverage / 100.0
                counter = 'LINE'
                value = 'COVEREDRATIO'
            }
        }
    }

    executionData layout.buildDirectory.file("jacoco/integrationTest.exec")

    onlyIf {
        isTestTaskRequested()
    }
}

// Configure JaCoCo reports and trigger coverage summaries
afterEvaluate {
    // Configure unit test report
    jacocoTestReport.configure {
        classDirectories.setFrom(files(classDirectories.files.collect {
            fileTree(dir: it, exclude: [
                '**/imports/**'
            ])
        }))
        sourceDirectories.setFrom(files(sourceSets.main.allJava.srcDirs))
    }
    
    // Configure integration test report
    jacocoIntegrationTestReport.configure {
        classDirectories.setFrom(files(sourceSets.main.output.classesDirs.collect {
            fileTree(dir: it, exclude: [
                '**/Main.class',
                '**/imports/**'
            ])
        }))
        sourceDirectories.setFrom(files(sourceSets.main.allJava.srcDirs))
    }
    
    // Set up coverage summary triggers
    jacocoTestReport.finalizedBy(showCoverage)
    jacocoIntegrationTestReport.finalizedBy(showIntegrationCoverage)
}

jacocoTestCoverageVerification {
    dependsOn jacocoTestReport
    violationRules {
        rule {
            limit {
                minimum = minimumTestCoverage / 100.0
                counter = 'LINE'
                value = 'COVEREDRATIO'
            }
        }
    }

    // Uses only unit test execution data
    executionData layout.buildDirectory.file("jacoco/test.exec")

    onlyIf {
        isTestTaskRequested()
    }
}

// Unit test coverage summary task
tasks.register('showCoverage') {
    dependsOn jacocoTestReport
    group = 'verification'
    description = 'Shows unit test execution and coverage summary'

    doLast {
        def xmlReportFile = layout.buildDirectory.file("reports/jacoco/test/jacocoTestReport.xml").get().asFile
        def htmlReportFile = layout.buildDirectory.file("reports/jacoco/test/html/index.html").get().asFile
        def unitTestResultsDir = layout.buildDirectory.dir("test-results/test").get().asFile

        // Parse unit test execution results only
        def testStats = [total: 0, passed: 0, failed: 0, skipped: 0]

        if (unitTestResultsDir.exists()) {
            unitTestResultsDir.listFiles().each { file ->
                if (file.name.endsWith('.xml')) {
                    try {
                        def parser = new XmlParser()
                        parser.setFeature("http://apache.org/xml/features/disallow-doctype-decl", false)
                        parser.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false)
                        def xml = parser.parse(file)

                        testStats.total += (xml.@tests as Integer) ?: 0
                        testStats.failed += (xml.@failures as Integer) ?: 0
                        testStats.failed += (xml.@errors as Integer) ?: 0
                        testStats.skipped += (xml.@skipped as Integer) ?: 0
                        testStats.passed = testStats.total - testStats.failed - testStats.skipped
                    } catch (Exception ignored) {
                        // Ignore parsing errors for individual test files
                    }
                }
            }
        }

        // Display unit test execution summary
        println "\nğŸ§ª Unit Test Execution Summary:"
        if (testStats.total > 0) {
            println "Tests Run: ${testStats.total}"
            println "Passed: ${testStats.passed}, Failed: ${testStats.failed}, Skipped: ${testStats.skipped}"
            println "Test Status: ${testStats.failed == 0 ? 'âœ… PASSED' : 'âŒ FAILED'}"
        } else {
            println "No unit tests found"
        }

        // Display coverage summary
        if (xmlReportFile.exists()) {
            try {
                def parser = new XmlParser()
                parser.setFeature("http://apache.org/xml/features/disallow-doctype-decl", false)
                parser.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false)
                def xml = parser.parse(xmlReportFile)

                def counter = xml.counter.find { it.@type == 'LINE' }
                if (counter) {
                    def covered = counter.@covered.toInteger()
                    def missed = counter.@missed.toInteger()
                    def total = covered + missed
                    def percentage = total > 0 ? (covered * 100 / total).round(1) : 0

                    println "\nğŸ“Š Unit Test Coverage Summary:"
                    println "Lines Covered: ${covered}/${total} (${percentage}%)"
                    println "Coverage Status: ${percentage >= minimumTestCoverage ? 'âœ… PASSED' : 'âŒ FAILED'} " +
                            "(minimum: ${minimumTestCoverage}%)"

                    if (htmlReportFile.exists()) {
                        println "ğŸ“„ Detailed HTML Report: file://${htmlReportFile.absolutePath}"
                    }
                } else {
                    println "\nğŸ“Š Unit Test Coverage: Report generated successfully"
                }
            } catch (Exception e) {
                println "\nğŸ“Š Unit Test Coverage: Tests completed successfully"
                println "âš ï¸  Coverage report parsing failed: ${e.message}"
            }
        } else {
            println "\nğŸ“Š Unit Test Coverage: No coverage data found"
        }
    }
}

// Integration test coverage summary task
tasks.register('showIntegrationCoverage') {
    dependsOn jacocoIntegrationTestReport
    group = 'verification'
    description = 'Shows integration test execution and coverage summary'

    doLast {
        def xmlReportFile = layout.buildDirectory.file("reports/jacoco/integrationTest/jacocoIntegrationTestReport.xml").get().asFile
        def htmlReportFile = layout.buildDirectory.file("reports/jacoco/integrationTest/html/index.html").get().asFile
        def integrationTestResultsDir = layout.buildDirectory.dir("test-results/integrationTest").get().asFile

        // Parse integration test execution results only
        def testStats = [total: 0, passed: 0, failed: 0, skipped: 0]

        if (integrationTestResultsDir.exists()) {
            integrationTestResultsDir.listFiles().each { file ->
                if (file.name.endsWith('.xml')) {
                    try {
                        def parser = new XmlParser()
                        parser.setFeature("http://apache.org/xml/features/disallow-doctype-decl", false)
                        parser.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false)
                        def xml = parser.parse(file)

                        testStats.total += (xml.@tests as Integer) ?: 0
                        testStats.failed += (xml.@failures as Integer) ?: 0
                        testStats.failed += (xml.@errors as Integer) ?: 0
                        testStats.skipped += (xml.@skipped as Integer) ?: 0
                        testStats.passed = testStats.total - testStats.failed - testStats.skipped
                    } catch (Exception ignored) {
                        // Ignore parsing errors for individual test files
                    }
                }
            }
        }

        // Display integration test execution summary
        println "\nğŸ§ª Integration Test Execution Summary:"
        if (testStats.total > 0) {
            println "Tests Run: ${testStats.total}"
            println "Passed: ${testStats.passed}, Failed: ${testStats.failed}, Skipped: ${testStats.skipped}"
            println "Test Status: ${testStats.failed == 0 ? 'âœ… PASSED' : 'âŒ FAILED'}"
        } else {
            println "No integration tests found"
        }

        // Display coverage summary
        if (xmlReportFile.exists()) {
            try {
                def parser = new XmlParser()
                parser.setFeature("http://apache.org/xml/features/disallow-doctype-decl", false)
                parser.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false)
                def xml = parser.parse(xmlReportFile)

                def counter = xml.counter.find { it.@type == 'LINE' }
                if (counter) {
                    def covered = counter.@covered.toInteger()
                    def missed = counter.@missed.toInteger()
                    def total = covered + missed
                    def percentage = total > 0 ? (covered * 100 / total).round(1) : 0

                    println "\nğŸ“Š Integration Test Coverage Summary:"
                    println "Lines Covered: ${covered}/${total} (${percentage}%)"
                    println "Coverage Status: ${percentage >= minimumTestCoverage ? 'âœ… PASSED' : 'âŒ FAILED'} " +
                            "(minimum: ${minimumTestCoverage}%)"

                    if (htmlReportFile.exists()) {
                        println "ğŸ“„ Detailed HTML Report: file://${htmlReportFile.absolutePath}"
                    }
                } else {
                    println "\nğŸ“Š Integration Test Coverage: Report generated successfully"
                }
            } catch (Exception e) {
                println "\nğŸ“Š Integration Test Coverage: Tests completed successfully"
                println "âš ï¸  Coverage report parsing failed: ${e.message}"
            }
        } else {
            println "\nğŸ“Š Integration Test Coverage: No coverage data found"
        }
    }
}

// Integration test with coverage task
tasks.register('integrationTestWithCoverage') {
    dependsOn integrationTest, jacocoIntegrationTestReport
    group = 'verification'
    description = 'Runs integration tests and displays coverage summary'

    doFirst {
        println "\nğŸš€ Running integration tests with coverage analysis..."
    }
}

// Comprehensive test task
tasks.register('testAll') {
    dependsOn test, integrationTest, showCoverage
    group = 'verification'
    description = 'Runs all tests and displays coverage summary'

    doFirst {
        println "\nğŸš€ Running all tests with coverage analysis..."
    }
}